{"id": "1", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Represents a financial instrument in a portfolio.\n */\nclass FinancialInstrument {\npublic:\n    FinancialInstrument(const std::string &name, double price)\n        : name(name), price(price) {}\n\n    const std::string &getName() const { return name; }\n    double getPrice() const { return price; }\n\nprivate:\n    std::string name;\n    double price;\n};\n\n/**\n * @brief Portfolio class to manage multiple financial instruments.\n */\nclass Portfolio {\npublic:\n    void addInstrument(const FinancialInstrument &instrument) {\n        instruments.push_back(instrument);\n    }\n\n    double calculateTotalValue() const {\n        double total = 0.0;\n        for (const auto &instrument : instruments) {\n            total += instrument.getPrice();\n        }\n        return total;\n    }\n\nprivate:\n    std::vector<FinancialInstrument> instruments;\n};\n\n/**\n * @brief Risk assessment class for evaluating portfolio risk.\n */\nclass RiskAssessment {\npublic:\n    RiskAssessment(const Portfolio &portfolio)\n        : portfolio(portfolio) {}\n\n    /**\n     * @brief Calculate the risk of the portfolio based on the value and predefined risk factors.\n     * @return Risk value as a percentage.\n     */\n    double calculateRisk() const;\n\nprivate:\n    const Portfolio &portfolio;\n};\n\n// Implementation of RiskAssessment::calculateRisk\n", "suffix": "int main() {\n    FinancialInstrument stock1(\"AAPL\", 150.0);\n    FinancialInstrument stock2(\"GOOGL\", 2800.0);\n    FinancialInstrument bond1(\"US10Y\", 100.0);\n\n    Portfolio portfolio;\n    portfolio.addInstrument(stock1);\n    portfolio.addInstrument(stock2);\n    portfolio.addInstrument(bond1);\n\n    RiskAssessment riskAssessment(portfolio);\n    double risk = riskAssessment.calculateRisk();\n\n    assert(risk >= 0.0 && risk <= 100.0);\n    std::cout << \"Portfolio risk: \" << risk << \"%\" << std::endl;\n\n    return 0;\n}\n", "golden_completion": "double RiskAssessment::calculateRisk() const {\n    double totalValue = portfolio.calculateTotalValue();\n    if (totalValue == 0.0) {\n        return 0.0;\n    }\n    double riskFactor = 0.05; // Assume a fixed risk factor for simplicity\n    return (totalValue * riskFactor) / totalValue * 100;\n}\n", "LLM_justification": "This test case demonstrates the translation between C++ code and documentation for a realistic financial portfolio management scenario. The prefix provides a comprehensive setup including class definitions for financial instruments, portfolio management, and risk assessment. The golden completion requires the implementation of the calculateRisk method based on provided documentation. The suffix includes a main function that tests the functionality. This scenario tests the LLM's ability to understand and generate both code and documentation, with assertions verifying the correctness of the risk calculation implementation.", "assertions": ""}
{"id": "2", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Represents a customer in a business domain.\n */\nclass Customer {\npublic:\n    Customer(const std::string &name, int age) : name(name), age(age) {}\n\n    /**\n     * @brief Get the name of the customer.\n     * @return std::string\n     */\n    std::string getName() const { return name; }\n\n    /**\n     * @brief Get the age of the customer.\n     * @return int\n     */\n    int getAge() const { return age; }\n\nprivate:\n    std::string name;\n    int age;\n};\n\n/**\n * @brief Represents a collection of customers.\n */\nclass CustomerCollection {\npublic:\n    /**\n     * @brief Add a customer to the collection.\n     * @param customer The customer to add.\n     */\n    void addCustomer(const Customer &customer) {\n        customers.push_back(customer);\n    }\n\n    /**\n     * @brief Remove customers below a certain age.\n     * @param minAge The minimum age required to stay in the collection.\n     */\n    void removeCustomersBelowAge(int minAge) {\n        customers.erase(\n            std::remove_if(customers.begin(), customers.end(), [minAge](const Customer &c) {\n                return c.getAge() < minAge;\n            }),\n            customers.end()\n        );\n    }\n\n    /**\n     * @brief Get the list of customer names.\n     * @return std::vector<std::string>\n     */\n    std::vector<std::string> getCustomerNames() const {\n        std::vector<std::string> names;\n        for (const auto &customer : customers) {\n            names.push_back(customer.getName());\n        }\n        return names;\n    }\n\nprivate:\n    std::vector<Customer> customers;\n};\n\n/**\n * @brief Validate the age of the customers in the collection.\n * @details Checks that all customers in the collection are above a specified minimum age.\n * @param minAge The minimum age threshold for validation.\n * @return true if all customers are above the minAge, false otherwise.\n */\nbool validateCustomerAges(const CustomerCollection &collection, int minAge) {", "suffix": "}\n\nint main() {\n    CustomerCollection collection;\n    collection.addCustomer(Customer(\"Alice\", 30));\n    collection.addCustomer(Customer(\"Bob\", 20));\n    collection.addCustomer(Customer(\"Charlie\", 25));\n\n    assert(collection.getCustomerNames().size() == 3);\n    collection.removeCustomersBelowAge(25);\n    assert(collection.getCustomerNames().size() == 2);\n\n    assert(validateCustomerAges(collection, 25));\n\n    return 0;\n}", "golden_completion": "\n    const auto &customers = collection.getCustomerNames();\n    return std::all_of(customers.begin(), customers.end(), [minAge, &collection](const std::string &name) {\n        auto it = std::find_if(collection.customers.begin(), collection.customers.end(), [&name](const Customer &c) {\n            return c.getName() == name;\n        });\n        return it != collection.customers.end() && it->getAge() >= minAge;\n    });", "LLM_justification": "This scenario tests the LLM's ability to translate between C++ code and documentation effectively in both directions. The prefix includes a detailed class definition for a Customer and a CustomerCollection, with appropriate methods for adding, removing, and retrieving customers. The golden completion focuses on the implementation of a validation function to ensure all customers meet a minimum age requirement. The suffix contains code to test this validation function, ensuring comprehensive coverage. This scenario is realistic and non-trivial, involving domain modeling and business rule validation, making it a good test case.", "assertions": ""}
{"id": "3", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <cassert>\n\n/**\n * @brief Interface for a task in a workflow pipeline.\n */\nclass ITask {\npublic:\n    virtual ~ITask() = default;\n    virtual void execute() = 0;\n};\n\n/**\n * @brief Example task that prints a message.\n */\nclass PrintTask : public ITask {\npublic:\n    PrintTask(const std::string& message) : message_(message) {}\n    void execute() override {\n        std::cout << message_ << std::endl;\n    }\nprivate:\n    std::string message_;\n};\n\n/**\n * @brief Manages execution of a sequence of tasks.\n */\nclass TaskManager {\npublic:\n    /**\n     * @brief Add a task to the pipeline.\n     * @param task A unique pointer to the task to add.\n     */\n    void addTask(std::unique_ptr<ITask> task) {\n        tasks_.push_back(std::move(task));\n    }\n\n    /**\n     * @brief Execute all tasks in the pipeline.\n     */\n    void executeAll() {\n        for (const auto& task : tasks_) {\n            task->execute();\n        }\n    }\n\nprivate:\n    std::vector<std::unique_ptr<ITask>> tasks_;\n};\n\nint main() {\n    TaskManager manager;\n    manager.addTask(std::make_unique<PrintTask>(\"Task 1\"));\n    manager.addTask(std::make_unique<PrintTask>(\"Task 2\"));\n    // Execute all tasks\n    ", "suffix": "\n\n    // Assertions to verify the expected behavior\n    std::ostringstream oss;\n    std::streambuf* oldCoutBuf = std::cout.rdbuf(oss.rdbuf());\n    manager.executeAll();\n    std::cout.rdbuf(oldCoutBuf);\n    assert(oss.str() == \"Task 1\\nTask 2\\nTask 1\\nTask 2\\n\");\n\n    return 0;\n}\n", "golden_completion": "    manager.executeAll();\n", "LLM_justification": "This test case provides a practical example of a task scheduling and execution workflow. The TaskManager class orchestrates a sequence of tasks, demonstrating the addition and execution of tasks. The golden_completion focuses on the execution of all tasks, which is a critical part of the workflow. The assertions validate the correct execution and output of tasks, ensuring the integrity of the workflow pipeline. This scenario effectively tests the LLM's ability to translate between code and documentation, maintaining consistency and correctness.", "assertions": ""}
{"id": "4", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n", "suffix": "class FinancialInstrument {\npublic:\n    FinancialInstrument(std::string name, double price, double risk) : name_(name), price_(price), risk_(risk) {}\n    \n    /// @brief Gets the name of the instrument.\n    /// @return The name of the instrument.\n    std::string getName() const { return name_; }\n\n    /// @brief Gets the price of the instrument.\n    /// @return The price of the instrument.\n    double getPrice() const { return price_; }\n\n    /// @brief Gets the risk factor of the instrument.\n    /// @return The risk factor of the instrument.\n    double getRisk() const { return risk_; }\n\nprivate:\n    std::string name_;\n    double price_;\n    double risk_;\n};\n\n/// @brief Calculates the total value of a portfolio of financial instruments.\n/// @param portfolio A vector of financial instruments.\n/// @return The total value of the portfolio.\ndouble calculateTotalValue(const std::vector<FinancialInstrument>& portfolio) {\n    double totalValue = 0.0;\n    for (const auto& instrument : portfolio) {\n        totalValue += instrument.getPrice();\n    }\n    return totalValue;\n}\n\n/// @brief Calculates the average risk of a portfolio of financial instruments.\n/// @param portfolio A vector of financial instruments.\n/// @return The average risk of the portfolio.\ndouble calculateAverageRisk(const std::vector<FinancialInstrument>& portfolio) {\n    double totalRisk = 0.0;\n    for (const auto& instrument : portfolio) {\n        totalRisk += instrument.getRisk();\n    }\n    return totalRisk / portfolio.size();\n}\nint main() {\n    std::vector<FinancialInstrument> portfolio = {\n        FinancialInstrument(\"Stock A\", 100.0, 0.5),\n        FinancialInstrument(\"Bond B\", 200.0, 0.2),\n        FinancialInstrument(\"Commodity C\", 150.0, 0.7)\n    };\n\n    double totalValue = calculateTotalValue(portfolio);\n    double averageRisk = calculateAverageRisk(portfolio);\n\n    assert(totalValue == 450.0);\n    assert(averageRisk == 0.4666666666666667);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Represents a financial instrument in a portfolio.\n * @param name The name of the instrument.\n * @param price The price of the instrument.\n * @param risk The risk factor of the instrument.\n */\n\n", "LLM_justification": "This test case evaluates the LLM's ability to generate appropriate documentation for a C++ financial class based on implementation details. The task requires the model to infer the purpose and parameters of the FinancialInstrument class from its implementation and create a properly formatted documentation comment. The test demonstrates documentation generation capabilities in a realistic financial portfolio management context, where clear API documentation is essential. The suffix code provides a complete implementation including portfolio valuation and risk assessment functions with assertions to verify correctness, ensuring the documentation accurately reflects the functionality.", "assertions": ""}
{"id": "5", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n// Business Logic: Financial calculations for portfolio analysis\n// This class represents a single investment in a portfolio\nclass Investment {\npublic:\n    Investment(const std::string& name, double value, double risk) : name(name), value(value), risk(risk) {}\n\n    // Returns the name of the investment\n    const std::string& getName() const { return name; }\n\n    // Returns the value of the investment\n    double getValue() const { return value; }\n\n    // Returns the risk factor of the investment\n    double getRisk() const { return risk; }\n\nprivate:\n    std::string name;  // Name of the investment\n    double value;      // Value of the investment\n    double risk;       // Risk factor of the investment\n};\n\n", "suffix": "class Portfolio {\npublic:\n    // Adds an investment to the portfolio\n    void addInvestment(const Investment& investment) {\n        investments.push_back(investment);\n    }\n\n    // Calculates the total value of the portfolio\n    double calculateTotalValue() const {\n        double totalValue = 0;\n        for (const auto& investment : investments) {\n            totalValue += investment.getValue();\n        }\n        return totalValue;\n    }\n\n    // Calculates the average risk of the portfolio\n    double calculateAverageRisk() const {\n        if (investments.empty()) {\n            return 0.0;\n        }\n        double totalRisk = 0;\n        for (const auto& investment : investments) {\n            totalRisk += investment.getRisk();\n        }\n        return totalRisk / investments.size();\n    }\n\nprivate:\n    std::vector<Investment> investments;  // List of investments in the portfolio\n};\n\nint main() {\n    Portfolio portfolio;\n    portfolio.addInvestment(Investment(\"Stock A\", 1000.0, 0.5));\n    portfolio.addInvestment(Investment(\"Stock B\", 2000.0, 0.3));\n    portfolio.addInvestment(Investment(\"Bond C\", 1500.0, 0.2));\n    double totalValue = portfolio.calculateTotalValue();\n    double averageRisk = portfolio.calculateAverageRisk();\n\n    assert(totalValue == 4500.0);\n    assert(averageRisk == (0.5 + 0.3 + 0.2) / 3);\n\n    std::cout << \"Total Value: \" << totalValue << std::endl;\n    std::cout << \"Average Risk: \" << averageRisk << std::endl;\n\n    return 0;\n}\n", "golden_completion": "/**\n * @class Portfolio\n * @brief Represents a portfolio containing multiple investments.\n * \n * This class allows adding investments and calculating the total value and average risk of the portfolio.\n * \n * @section USAGE\n * Portfolio portfolio;\n * portfolio.addInvestment(Investment(\"Stock A\", 1000.0, 0.5));\n * portfolio.addInvestment(Investment(\"Stock B\", 2000.0, 0.3));\n * portfolio.addInvestment(Investment(\"Bond C\", 1500.0, 0.2));\n * double totalValue = portfolio.calculateTotalValue();\n * double averageRisk = portfolio.calculateAverageRisk();\n * \n * @section PARAMETERS\n * \n * No parameters are taken by the class methods.\n * \n * @section RETURNS\n * \n * calculateTotalValue: Returns the total value of all investments in the portfolio.\n * calculateAverageRisk: Returns the average risk of all investments in the portfolio.\n */", "LLM_justification": "This test case is a good example because it covers a realistic financial calculation scenario with complex business logic. The golden completion provides comprehensive documentation for the `Portfolio` class, including usage examples, parameter descriptions, and return value documentation. The suffix includes assertions that verify the correctness of the calculations, ensuring that the generated documentation accurately describes the implemented code.", "assertions": ""}
{"id": "6", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\n/**\n * @brief Represents a single stock in a portfolio.\n */\nclass Stock {\npublic:\n    std::string symbol;\n    double price;\n    int shares;\n\n    Stock(const std::string& symbol, double price, int shares)\n        : symbol(symbol), price(price), shares(shares) {}\n};\n\n/**\n * @brief Represents a portfolio of stocks and provides methods to analyze it.\n */\nclass Portfolio {\nprivate:\n    std::vector<Stock> stocks;\n\npublic:\n    /**\n     * @brief Adds a stock to the portfolio.\n     * @param stock The stock to be added.\n     */\n    void addStock(const Stock& stock) {\n        stocks.push_back(stock);\n    }\n\n    /**\n     * @brief Calculates the total value of the portfolio.\n     * @return The total value of the portfolio.\n     */\n    double calculateTotalValue() const {\n        double totalValue = 0.0;\n        for (const auto& stock : stocks) {\n            totalValue += stock.price * stock.shares;\n        }\n        return totalValue;\n    }\n\n    /**\n     * @brief Finds the stock with the highest value in the portfolio.\n     * @return The stock with the highest value.\n     */\n    Stock findHighestValueStock() const;\n};", "suffix": "\nStock Portfolio::findHighestValueStock() const {\n    if (stocks.empty()) {\n        throw std::runtime_error(\"Portfolio is empty\");\n    }\n    return *std::max_element(stocks.begin(), stocks.end(), [](const Stock& a, const Stock& b) {\n        return (a.price * a.shares) < (b.price * b.shares);\n    });\n}\n\nint main() {\n    Portfolio portfolio;\n    portfolio.addStock(Stock(\"AAPL\", 150.0, 10));\n    portfolio.addStock(Stock(\"GOOGL\", 2800.0, 5));\n    portfolio.addStock(Stock(\"MSFT\", 300.0, 20));\n\n    double totalValue = portfolio.calculateTotalValue();\n    assert(totalValue == (150.0 * 10 + 2800.0 * 5 + 300.0 * 20));\n\n    Stock highestValueStock = portfolio.findHighestValueStock();\n    assert(highestValueStock.symbol == \"GOOGL\");\n    assert(highestValueStock.price == 2800.0);\n    assert(highestValueStock.shares == 5);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Finds the stock with the highest value in the portfolio.\n * @return The stock with the highest value.\n * @throw std::runtime_error if the portfolio is empty.\n */\n", "LLM_justification": "This is a good test case because it involves a realistic scenario of managing a stock portfolio, which includes adding stocks, calculating the total value, and finding the highest value stock. The documentation part tests the LLM's ability to generate comprehensive and accurate comments for a complex method, while the code part tests the LLM's ability to implement a function based on detailed comments. The assertions ensure that both the functionality and documentation are correct and complete.", "assertions": ""}
{"id": "7", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <stdexcept>\n\n/**\n * @brief Represents a financial instrument in a portfolio.\n */\nclass FinancialInstrument {\npublic:\n    FinancialInstrument(const std::string& name, double value) : name(name), value(value) {}\n    const std::string& getName() const { return name; }\n    double getValue() const { return value; }\n    void setValue(double newValue) { value = newValue; }\nprivate:\n    std::string name;\n    double value;\n};\n\n/**\n * @brief Represents a portfolio containing multiple financial instruments.\n */\nclass Portfolio {\npublic:\n    void addInstrument(const FinancialInstrument& instrument) {\n        instruments.push_back(instrument);\n    }\n    double calculateTotalValue() const {\n        double totalValue = 0.0;\n        for (const auto& instrument : instruments) {\n            totalValue += instrument.getValue();\n        }\n        return totalValue;\n    }\n    /**\n     * @brief Perform risk assessment on the portfolio.\n     * @return Risk score as a double.\n     * @throw std::runtime_error if the portfolio is empty.\n     */\n    double assessRisk() const;\nprivate:\n    std::vector<FinancialInstrument> instruments;\n};", "suffix": "int main() {\n    Portfolio portfolio;\n    portfolio.addInstrument(FinancialInstrument(\"Stock A\", 1000.0));\n    portfolio.addInstrument(FinancialInstrument(\"Bond B\", 500.0));\n    portfolio.addInstrument(FinancialInstrument(\"Real Estate C\", 2000.0));\n    \n    // Calculate total value\n    assert(portfolio.calculateTotalValue() == 3500.0);\n\n    // Assess risk\n    try {\n        double risk = portfolio.assessRisk();\n        assert(risk >= 0.0 && risk <= 1.0); // Assume risk score is between 0 and 1\n    } catch (const std::runtime_error& e) {\n        std::cerr << e.what() << std::endl;\n        assert(false); // Should not throw in this case\n    }\n\n    // Edge case: empty portfolio\n    Portfolio emptyPortfolio;\n    try {\n        emptyPortfolio.assessRisk();\n        assert(false); // Should throw\n    } catch (const std::runtime_error& e) {\n        assert(std::string(e.what()) == \"Portfolio is empty\");\n    }\n\n    return 0;\n}\n\n", "golden_completion": "\ndouble Portfolio::assessRisk() const {\n    if (instruments.empty()) {\n        throw std::runtime_error(\"Portfolio is empty\");\n    }\n    double totalValue = calculateTotalValue();\n    double riskScore = 0.0;\n    for (const auto& instrument : instruments) {\n        // Hypothetical risk assessment logic\n        riskScore += instrument.getValue() / totalValue;\n    }\n    return riskScore / instruments.size();\n}\n", "LLM_justification": "This test case demonstrates a comprehensive scenario involving a financial portfolio's risk assessment. It includes realistic business logic for adding financial instruments to a portfolio, calculating the total value, and assessing risk. The documentation provided in the prefix describes the methods and classes clearly, while the golden_completion fills in the implementation of the assessRisk method. Assertions in the suffix verify the correctness of the implementation, including edge cases like an empty portfolio. This scenario effectively tests an LLM's ability to translate between C++ code and detailed documentation, ensuring proper understanding and functionality.", "assertions": ""}
{"id": "8", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief Class representing a financial portfolio.\n */\nclass Portfolio {\npublic:\n    /**\n     * @brief Adds a stock to the portfolio.\n     * @param stockName The name of the stock.\n     * @param quantity The number of shares.\n     */\n    void addStock(const std::string& stockName, int quantity) {\n        stocks.push_back({stockName, quantity});\n    }\n\n    /**\n     * @brief Calculates the total value of the portfolio.\n     * @param prices A map of stock prices.\n     * @return The total value of the portfolio.\n     */\n    double calculateTotalValue(const std::map<std::string, double>& prices) const {\n        double totalValue = 0.0;\n        for (const auto& stock : stocks) {\n            auto it = prices.find(stock.first);\n            if (it != prices.end()) {\n                totalValue += it->second * stock.second;\n            } else {\n                std::cerr << \"Error: Price not found for stock \" << stock.first << std::endl;\n            }\n        }\n        return totalValue;\n    }\n\nprivate:\n    std::vector<std::pair<std::string, int>> stocks; ///< The list of stocks and their quantities\n};\n\n", "suffix": "void testPortfolio() {\n    Portfolio portfolio;\n    portfolio.addStock(\"AAPL\", 10);\n    portfolio.addStock(\"GOOGL\", 5);\n    std::map<std::string, double> prices = { {\"AAPL\", 150.0}, {\"GOOGL\", 2800.0} };\n    double totalValue = portfolio.calculateTotalValue(prices);\n    assert(totalValue == 1500.0 + 14000.0);\n    std::cout << \"Total portfolio value: $\" << totalValue << std::endl;\n}\n\nint main() {\n    testPortfolio();\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Function to test the Portfolio class.\n *\n * This function creates a Portfolio, adds stocks to it, and calculates the total value based on given prices.\n * It then asserts that the calculated total value is correct.\n */\n", "LLM_justification": "This test case is ideal because it involves realistic business logic for financial calculations within a portfolio. It includes detailed documentation for class methods, error handling for missing stock prices, and assertions that validate the correctness of the total value calculation. The scenario tests the model's ability to generate accurate and comprehensive documentation from code and vice versa, covering complex business rules and technical requirements in a financial domain.", "assertions": ""}
{"id": "9", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Represents a financial instrument in a portfolio.\n */\nclass Instrument {\npublic:\n    enum class Type {\n        STOCK,\n        BOND\n    };\n\n    Instrument(std::string name, Type type, double value)\n        : name(name), type(type), value(value) {}\n\n    std::string getName() const { return name; }\n    Type getType() const { return type; }\n    double getValue() const { return value; }\n\nprivate:\n    std::string name;\n    Type type;\n    double value;\n};\n\n/**\n * @brief Represents a portfolio of financial instruments.\n */\nclass Portfolio {\npublic:\n    void addInstrument(const Instrument& instrument) {\n        instruments.push_back(instrument);\n    }\n\n    /**\n     * @brief Calculate the total value of the portfolio.\n     * @return The sum of the values of all instruments in the portfolio.\n     */\n    double calculateTotalValue() const {\n        double totalValue = 0.0;\n        for (const auto& instrument : instruments) {\n            totalValue += instrument.getValue();\n        }\n        return totalValue;\n    }\n\nprivate:\n    std::vector<Instrument> instruments;\n};\n\n/**\n * @brief Perform risk assessment on the portfolio.\n * @param portfolio The portfolio to assess.\n * @return The calculated risk value based on instrument types and values. Stocks should have a risk multiplier of 0.5, whereas bonds should use 0.2.\n */\ndouble assessRisk(const Portfolio& portfolio) {\n", "suffix": "int main() {\n    Portfolio portfolio;\n    portfolio.addInstrument(Instrument(\"AAPL\", Instrument::Type::STOCK, 150.0));\n    portfolio.addInstrument(Instrument(\"GOOGL\", Instrument::Type::STOCK, 120.0));\n    portfolio.addInstrument(Instrument(\"US10Y\", Instrument::Type::BOND, 100.0));\n\n    double totalValue = portfolio.calculateTotalValue();\n    assert(totalValue == 370.0);\n\n    double riskValue = assessRisk(portfolio);\n    assert(riskValue > 0.0);\n\n    return 0;\n}\n\n", "golden_completion": "\n    double risk = 0.0;\n    for (const auto& instrument : portfolio.instruments) {\n        if (instrument.getType() == Instrument::Type::STOCK) {\n            risk += instrument.getValue() * 0.5; // Stocks have higher risk\n        } else if (instrument.getType() == Instrument::Type::BOND) {\n            risk += instrument.getValue() * 0.2; // Bonds have lower risk\n        }\n    }\n    return risk;\n}", "LLM_justification": "This test case provides a realistic financial scenario involving a portfolio of instruments (stocks and bonds) with risk assessment functionality. It tests the LLM's ability to generate comprehensive documentation for a function based on its implementation and to generate accurate code from detailed comments. The context includes detailed class definitions and method implementations, ensuring that the LLM can handle complex business logic and technical requirements. The assertions verify functional correctness and ensure the generated documentation is accurate and complete.", "assertions": ""}
{"id": "10", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief A class representing a portfolio of financial assets.\n */\nclass Portfolio {\npublic:\n    /**\n     * @brief Adds a new asset to the portfolio.\n     * @param assetName The name of the asset.\n     * @param assetValue The value of the asset.\n     */\n    void addAsset(const std::string &assetName, double assetValue) {\n        assets.push_back(assetName);\n        values.push_back(assetValue);\n    }\n\n    /**\n     * @brief Calculates the total value of the portfolio.\n     * @return The total value of all assets in the portfolio.\n     */\n    double calculateTotalValue() const {\n        double total = 0.0;\n        for (double value : values) {\n            total += value;\n        }\n        return total;\n    }\n\nprivate:\n    std::vector<std::string> assets;\n    std::vector<double> values;\n};\n\n/**\n * @brief A class representing risk assessment for a portfolio.\n */\nclass RiskAssessment {\npublic:\n    /**\n     * @brief Assesses the risk level of a portfolio based on its total value.\n     * @param portfolio The portfolio to assess.\n     * @return The risk level as a string.\n     */\n    std::string assessRisk(const Portfolio &portfolio) const;\n};\n", "suffix": "int main() {\n    Portfolio portfolio;\n    portfolio.addAsset(\"Stock A\", 1500.0);\n    portfolio.addAsset(\"Bond B\", 500.0);\n    portfolio.addAsset(\"Commodity C\", 1000.0);\n\n    double totalValue = portfolio.calculateTotalValue();\n    assert(totalValue == 3000.0);\n\n    RiskAssessment riskAssessment;\n    std::string riskLevel = riskAssessment.assessRisk(portfolio);\n    assert(riskLevel == \"Medium\");\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "std::string RiskAssessment::assessRisk(const Portfolio &portfolio) const {\n    double totalValue = portfolio.calculateTotalValue();\n    if (totalValue < 1000.0) {\n        return \"Low\";\n    } else if (totalValue < 5000.0) {\n        return \"Medium\";\n    } else {\n        return \"High\";\n    }\n}\n", "LLM_justification": "This test case demonstrates a realistic scenario in the domain of financial calculations and risk assessment. It includes a class for managing a portfolio of assets and another for assessing the risk based on the portfolio's total value. The golden completion requires implementing a method to evaluate risk levels, providing a good challenge for translating between comments and code. The assertions verify the correctness of the implementation and ensure the translation has been accurately performed.", "assertions": ""}
{"id": "11", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @class Portfolio\n * @brief Represents a financial portfolio containing various assets.\n */\nclass Portfolio {\npublic:\n    Portfolio() {}\n\n    /**\n     * @brief Adds an asset to the portfolio.\n     * @param assetName The name of the asset to add.\n     * @param assetValue The value of the asset to add.\n     */\n    void addAsset(const std::string& assetName, double assetValue) {\n        assets.push_back({assetName, assetValue});\n    }\n\n    /**\n     * @brief Calculates the total value of the portfolio.\n     * @return The total value of all assets in the portfolio.\n     */\n    double calculateTotalValue() const {\n        double totalValue = 0.0;\n        for (const auto& asset : assets) {\n            totalValue += asset.second;\n        }\n        return totalValue;\n    }\n\nprivate:\n    std::vector<std::pair<std::string, double>> assets;\n};\n\n/**\n * @brief Calculates the risk of the portfolio based on asset values.\n * @param portfolio The portfolio to calculate risk for.\n * @return The calculated risk value.\n */\ndouble calculateRisk(const Portfolio& portfolio) {", "suffix": "\nint main() {\n    Portfolio portfolio;\n    portfolio.addAsset(\"Stocks\", 50000);\n    portfolio.addAsset(\"Bonds\", 30000);\n    portfolio.addAsset(\"Real Estate\", 20000);\n\n    double totalValue = portfolio.calculateTotalValue();\n    assert(totalValue == 100000);\n\n    double risk = calculateRisk(portfolio);\n    assert(risk >= 0 && risk <= 1); // Assuming risk is a value between 0 and 1\n\n    std::cout << \"Total portfolio value: \" << totalValue << std::endl;\n    std::cout << \"Portfolio risk: \" << risk << std::endl;\n\n    return 0;\n}", "golden_completion": "\n    double totalValue = portfolio.calculateTotalValue();\n    // Simple risk calculation: risk is proportional to total value\n    return totalValue / 100000; // Assume 100000 as the maximum value for normalization\n}", "LLM_justification": "This test case is a realistic example of a financial portfolio management scenario, involving the addition of assets, calculation of total portfolio value, and risk assessment. It tests the LLM's ability to generate comprehensive documentation for an existing function (code-to-comment) and to implement a function based on provided documentation (comment-to-code). The scenario includes detailed class and method documentation, making it an excellent test for the LLM's documentation generation capabilities. The assertions validate functional requirements, ensuring the code performs as expected, including edge cases like risk calculation normalization.", "assertions": ""}
{"id": "12", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n", "suffix": "class Portfolio {\npublic:\n    Portfolio() = default;\n\n    /**\n     * @brief Adds an asset to the portfolio.\n     * @param name The name of the asset.\n     * @param value The value of the asset.\n     */\n    void addAsset(const std::string& name, double value) {\n        assets.push_back({name, value});\n    }\n\n    /**\n     * @brief Removes an asset from the portfolio.\n     * @param name The name of the asset to remove.\n     */\n    void removeAsset(const std::string& name) {\n        assets.erase(std::remove_if(assets.begin(), assets.end(), [&](const Asset& asset) {\n            return asset.name == name;\n        }), assets.end());\n    }\n\n    /**\n     * @brief Calculates the total value of the portfolio.\n     * @return The total value of all assets.\n     */\n    double totalValue() const {\n        double total = 0.0;\n        for (const auto& asset : assets) {\n            total += asset.value;\n        }\n        return total;\n    }\n\nprivate:\n    struct Asset {\n        std::string name;\n        double value;\n    };\n\n    std::vector<Asset> assets;\n};\n\nint main() {\n    Portfolio portfolio;\n    portfolio.addAsset(\"AAPL\", 150.0);\n    portfolio.addAsset(\"GOOGL\", 200.0);\n    portfolio.addAsset(\"TSLA\", 250.0);\n\n    assert(portfolio.totalValue() == 600.0);\n\n    portfolio.removeAsset(\"AAPL\");\n    assert(portfolio.totalValue() == 450.0);\n\n    portfolio.removeAsset(\"MSFT\"); // Removing non-existent asset, should not affect the total value\n    assert(portfolio.totalValue() == 450.0);\n\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Financial portfolio class for managing investment assets.\n *\n * This class provides functionalities to add, remove, and analyze assets in a financial portfolio.\n *\n * @details\n * - The class uses a vector to store assets, where each asset has a name and a value.\n * - Error handling is minimal; removing a non-existent asset does nothing.\n * - Performance could degrade with a large number of assets due to linear search and removal.\n *\n * @note This implementation assumes no duplicate asset names.\n *\n * @code\n * Portfolio portfolio;\n * portfolio.addAsset(\"AAPL\", 150.0);\n * portfolio.addAsset(\"GOOGL\", 200.0);\n * portfolio.addAsset(\"TSLA\", 250.0);\n * assert(portfolio.totalValue() == 600.0);\n * portfolio.removeAsset(\"AAPL\");\n * assert(portfolio.totalValue() == 450.0);\n * portfolio.removeAsset(\"MSFT\"); // Removing non-existent asset, should not affect the total value\n * assert(portfolio.totalValue() == 450.0);\n * @endcode\n *\n * @class Portfolio\n *\n * @author\n * @version 1.0\n * @date 2023\n */\n", "LLM_justification": "This test case effectively evaluates an LLM's ability to generate comprehensive documentation for a complex financial portfolio class. The documentation needs to cover class functionalities, error handling, performance characteristics, and include usage examples. Assertions verify that the class implementation meets the documented behavior, ensuring the consistency between code and comments.", "assertions": ""}
{"id": "13", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Represents a financial instrument with basic attributes.\n */\nclass FinancialInstrument {\npublic:\n    FinancialInstrument(const std::string& name, double value)\n        : name_(name), value_(value) {}\n\n    /**\n     * @brief Get the name of the financial instrument.\n     * @return The name of the financial instrument.\n     */\n    std::string getName() const { return name_; }\n\n    /**\n     * @brief Get the value of the financial instrument.\n     * @return The value of the financial instrument.\n     */\n    double getValue() const { return value_; }\n\nprivate:\n    std::string name_;\n    double value_;\n};\n\n/**\n * @brief Manages a portfolio of financial instruments.\n */\nclass Portfolio {\npublic:\n    /**\n     * @brief Adds a financial instrument to the portfolio.\n     * @param instrument The financial instrument to add.\n     */\n    void addInstrument(const FinancialInstrument& instrument) {\n        instruments_.push_back(instrument);\n    }\n\n    /**\n     * @brief Calculates the total value of the portfolio.\n     * @return The total value of all financial instruments in the portfolio.\n     */\n    double calculateTotalValue() const;\n\nprivate:\n    std::vector<FinancialInstrument> instruments_;\n};\n", "suffix": "\n\nint main() {\n    FinancialInstrument fi1(\"Stock A\", 100.0);\n    FinancialInstrument fi2(\"Bond B\", 200.0);\n    Portfolio portfolio;\n    portfolio.addInstrument(fi1);\n    portfolio.addInstrument(fi2);\n    double totalValue = portfolio.calculateTotalValue();\n    assert(totalValue == 300.0);\n    std::cout << \"Total Portfolio Value: \" << totalValue << std::endl;\n    return 0;\n}", "golden_completion": "\ndouble Portfolio::calculateTotalValue() const {\n    double totalValue = 0.0;\n    for (const auto& instrument : instruments_) {\n        totalValue += instrument.getValue();\n    }\n    return totalValue;\n}", "LLM_justification": "This example tests the LLM's capability to generate comprehensive Doxygen-style documentation for an existing C++ method implementation. The code involves financial calculations, specifically the management and valuation of a portfolio of financial instruments, which is a realistic business logic scenario. The golden completion provides detailed documentation for the `calculateTotalValue` method, and the suffix includes assertions that validate the correctness of the method by calculating the total value of the portfolio and verifying it against expected results.", "assertions": ""}
{"id": "14", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @class Employee\n * @brief Represents an employee in the company.\n */\nclass Employee {\npublic:\n    Employee(const std::string& name, int age, const std::string& role)\n        : name_(name), age_(age), role_(role) {}\n\n    /**\n     * @brief Get the name of the employee.\n     * @return The name of the employee.\n     */\n    std::string getName() const { return name_; }\n\n    /**\n     * @brief Get the age of the employee.\n     * @return The age of the employee.\n     */\n    int getAge() const { return age_; }\n\n    /**\n     * @brief Get the role of the employee.\n     * @return The role of the employee.\n     */\n    std::string getRole() const { return role_; }\n\nprivate:\n    std::string name_;\n    int age_;\n    std::string role_;\n};\n\n/**\n * @class Company\n * @brief Represents a company with a list of employees.\n */\nclass Company {\npublic:\n    /**\n     * @brief Adds an employee to the company.\n     * @param employee The employee to add.\n     */\n    void addEmployee(const Employee& employee) {\n        employees_.push_back(employee);\n    }\n\n    /**\n     * @brief Finds an employee by name.\n     * @param name The name of the employee to find.\n     * @return A pointer to the employee if found, nullptr otherwise.\n     */\n    Employee* findEmployeeByName(const std::string& name);\n\nprivate:\n    std::vector<Employee> employees_;\n};\n", "suffix": "\n\nint main() {\n    Company company;\n    Employee emp1(\"John Doe\", 30, \"Developer\");\n    Employee emp2(\"Jane Smith\", 25, \"Designer\");\n    company.addEmployee(emp1);\n    company.addEmployee(emp2);\n\n    Employee* foundEmp = company.findEmployeeByName(\"John Doe\");\n    assert(foundEmp != nullptr);\n    assert(foundEmp->getName() == \"John Doe\");\n    assert(foundEmp->getAge() == 30);\n    assert(foundEmp->getRole() == \"Developer\");\n\n    Employee* notFoundEmp = company.findEmployeeByName(\"Alice\");\n    assert(notFoundEmp == nullptr);\n\n    return 0;\n}\n", "golden_completion": "Employee* Company::findEmployeeByName(const std::string& name) {\n    for (auto& employee : employees_) {\n        if (employee.getName() == name) {\n            return &employee;\n        }\n    }\n    return nullptr;\n}\n", "LLM_justification": "This test case provides a realistic business scenario involving a company and its employees. It tests the LLM's ability to understand and generate both documentation and implementation for class methods. The `findEmployeeByName` method is a common business logic function that requires both clear documentation and correct implementation. The provided code includes detailed Doxygen-style comments, a comprehensive class setup, and assertions to ensure the function works as expected. This scenario tests the LLM's ability to translate between code and natural language effectively, ensuring that the documentation matches the implementation and vice versa.", "assertions": ""}
{"id": "15", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cassert>\n\n/**\n * @brief Class representing a simple user database.\n *\n * The UserDatabase class provides functionalities to add users, \n * retrieve user information, and validate user data based on some business rules.\n */\nclass UserDatabase {\npublic:\n    /**\n     * @brief Adds a new user to the database.\n     *\n     * @param id The unique identifier for the user.\n     * @param name The name of the user.\n     * @param email The email address of the user.\n     * @return true if the user was added successfully, false otherwise.\n     */\n    bool addUser(int id, const std::string& name, const std::string& email);\n\n    /**\n     * @brief Retrieves the name of the user by their ID.\n     *\n     * @param id The unique identifier for the user.\n     * @return The name of the user.\n     */\n    std::string getUser(int id) const;\n\n    /**\n     * @brief Validates if the email format is correct.\n     *\n     * @param email The email address to validate.\n     * @return true if the email format is valid, false otherwise.\n     */\n    bool validateEmail(const std::string& email) const;\n\nprivate:\n    std::map<int, std::pair<std::string, std::string>> users; ///< A map of user ID to user name and email.\n};\n\nbool UserDatabase::addUser(int id, const std::string& name, const std::string& email) {\n    if (!validateEmail(email)) {\n        return false;\n    }\n    users[id] = std::make_pair(name, email);\n    return true;\n}\n", "suffix": "\n\nint main() {\n    UserDatabase db;\n    assert(db.addUser(1, \"Alice\", \"alice@example.com\"));\n    assert(db.addUser(2, \"Bob\", \"bobexample.com\") == false); // Invalid email\n    assert(db.getUser(1) == \"Alice\");\n    assert(db.getUser(2) == \"\"); // User not added due to invalid email\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Retrieves the name of the user by their ID.\n *\n * @param id The unique identifier for the user.\n * @return The name of the user if found, or an empty string if not found.\n */\nstd::string UserDatabase::getUser(int id) const {\n    auto it = users.find(id);\n    if (it != users.end()) {\n        return it->second.first;\n    }\n    return \"\";\n}\n\n/**\n * @brief Validates if the email format is correct.\n *\n * @param email The email address to validate.\n * @return true if the email format is valid, false otherwise.\n */\nbool UserDatabase::validateEmail(const std::string& email) const {\n    // Simple email validation rule: must contain '@' and '.'\n    size_t at_pos = email.find('@');\n    size_t dot_pos = email.find('.');\n    return (at_pos != std::string::npos) && (dot_pos != std::string::npos) && (at_pos < dot_pos);\n}\n", "LLM_justification": "This test case provides a realistic example involving a user database with functionalities to add users, retrieve user information, and validate email addresses. The golden completion includes comprehensive Doxygen-style documentation for the methods `getUser` and `validateEmail`. The suffix contains assertions that verify the correctness of the method implementations and the business rules enforced. This scenario tests both code-to-comment and comment-to-code translation capabilities of an LLM, ensuring the generated documentation accurately reflects the implementation and the generated code meets the specified requirements.", "assertions": ""}
{"id": "16", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief A class representing a simple workflow orchestration system.\n * \n * This class models a workflow system where tasks can be added and executed in sequence.\n */\nclass Workflow {\npublic:\n    /**\n     * @brief Adds a task to the workflow.\n     * \n     * @param task The task to be added, represented as a string.\n     */\n    void addTask(const std::string& task) {\n        tasks.push_back(task);\n    }\n\n    /**\n     * @brief Executes all tasks in the workflow.\n     * \n     * @return A vector of strings representing the results of each task.\n     */\n    std::vector<std::string> executeTasks() {\n        std::vector<std::string> results;\n        for (const auto& task : tasks) {\n            results.push_back(executeTask(task));\n        }\n        return results;\n    }\n\nprivate:\n    std::vector<std::string> tasks;\n\n    /**\n     * @brief Executes a single task.\n     * \n     * @param task The task to be executed, represented as a string.\n     * @return A string representing the result of the task execution.\n     */\n    std::string executeTask(const std::string& task) {\n        // Simulate task execution by returning a simple message\n        return \"Executed: \" + task;\n    }\n};\n\n", "suffix": "void testWorkflow() {\n    Workflow wf;\n    wf.addTask(\"Task 1\");\n    wf.addTask(\"Task 2\");\n    wf.addTask(\"Task 3\");\n\n    auto results = wf.executeTasks();\n    assert(results.size() == 3);\n    assert(results[0] == \"Executed: Task 1\");\n    assert(results[1] == \"Executed: Task 2\");\n    assert(results[2] == \"Executed: Task 3\");\n\n    // Cleanup code if necessary would go here (none required in this case)\n}\n\nint main() {\n    testWorkflow();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    /**\n     * @brief Tests the Workflow class by adding tasks and executing them.\n     * \n     * This function adds three tasks to a Workflow instance and executes them,\n     * then verifies that the results are as expected.\n     */", "LLM_justification": "This test case is a good example because it involves a realistic business logic scenario of workflow orchestration. The prefix includes a fully functional Workflow class with methods for adding and executing tasks. The golden completion provides comprehensive documentation for the test function, including the purpose and expected behavior of the test. The suffix contains assertions to verify the correctness of the Workflow class implementation, ensuring the tasks are executed as expected. This scenario tests the LLM's ability to generate accurate and detailed documentation as well as its ability to implement functional code from given documentation.", "assertions": ""}
{"id": "17", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @class User\n * @brief Represents a user in the system.\n *\n * The User class encapsulates all the necessary information and operations\n * related to a user in the system. Each user has a unique ID, a name, and\n * an email address.\n */\nclass User {\npublic:\n    /**\n     * @brief Constructs a new User object.\n     * @param id The unique ID of the user.\n     * @param name The name of the user.\n     * @param email The email address of the user.\n     */\n    User(int id, const std::string& name, const std::string& email)\n        : id_(id), name_(name), email_(email) {}\n\n    /**\n     * @brief Gets the user's ID.\n     * @return The unique ID of the user.\n     */\n    int getId() const { return id_; }\n\n    /**\n     * @brief Gets the user's name.\n     * @return The name of the user.\n     */\n    std::string getName() const { return name_; }\n\n    /**\n     * @brief Gets the user's email address.\n     * @return The email address of the user.\n     */\n    std::string getEmail() const { return email_; }\n\n    /**\n     * @brief Sets the user's email address.\n     * @param email The new email address of the user.\n     */\n    void setEmail(const std::string& email) { email_ = email; }\n\nprivate:\n    int id_; ///< The unique ID of the user.\n    std::string name_; ///< The name of the user.\n    std::string email_; ///< The email address of the user.\n};\n\n/**\n * @class UserManager\n * @brief Manages a collection of users.\n *\n * The UserManager class provides functionality to add, remove, and retrieve\n * users from a collection. It ensures that each user has a unique ID and\n * provides methods to find users by their ID or email address.\n */\nclass UserManager {\npublic:\n    /**\n     * @brief Adds a new user to the collection.\n     * @param user The user to add.\n     * @return True if the user was added successfully, false if a user with the same ID already exists.\n     */\n    bool addUser(const User& user);\n\n    /**\n     * @brief Removes a user from the collection by their ID.\n     * @param id The ID of the user to remove.\n     * @return True if the user was removed successfully, false if no user with the given ID exists.\n     */\n    bool removeUser(int id);\n\n    /**\n     * @brief Finds a user by their ID.\n     * @param id The ID of the user to find.\n     * @return A pointer to the user if found, nullptr otherwise.\n     */\n    const User* findUserById(int id) const;\n\n    /**\n     * @brief Finds a user by their email address.\n     * @param email The email address of the user to find.\n     * @return A pointer to the user if found, nullptr otherwise.\n     */\n    const User* findUserByEmail(const std::string& email) const;\n\nprivate:\n    std::vector<User> users_; ///< The collection of users.\n};\n", "suffix": "\n\nbool UserManager::removeUser(int id) {\n    for (auto it = users_.begin(); it != users_.end(); ++it) {\n        if (it->getId() == id) {\n            users_.erase(it);\n            return true;\n        }\n    }\n    return false; // No user with the given ID exists.\n}\n\nconst User* UserManager::findUserById(int id) const {\n    for (const auto& user : users_) {\n        if (user.getId() == id) {\n            return &user;\n        }\n    }\n    return nullptr; // No user with the given ID found.\n}\n\nconst User* UserManager::findUserByEmail(const std::string& email) const {\n    for (const auto& user : users_) {\n        if (user.getEmail() == email) {\n            return &user;\n        }\n    }\n    return nullptr; // No user with the given email found.\n}\n\nint main() {\n    UserManager manager;\n    User user1(1, \"Alice\", \"alice@example.com\");\n    User user2(2, \"Bob\", \"bob@example.com\");\n\n    // Add users\n    assert(manager.addUser(user1) == true);\n    assert(manager.addUser(user2) == true);\n    assert(manager.addUser(user1) == false); // Duplicate ID\n\n    // Find users by ID\n    assert(manager.findUserById(1) != nullptr);\n    assert(manager.findUserById(1)->getName() == \"Alice\");\n    assert(manager.findUserById(3) == nullptr); // Nonexistent ID\n\n    // Find users by email\n    assert(manager.findUserByEmail(\"bob@example.com\") != nullptr);\n    assert(manager.findUserByEmail(\"bob@example.com\")->getName() == \"Bob\");\n    assert(manager.findUserByEmail(\"charlie@example.com\") == nullptr); // Nonexistent email\n\n    // Remove users\n    assert(manager.removeUser(1) == true);\n    assert(manager.removeUser(1) == false); // Already removed\n    assert(manager.findUserById(1) == nullptr); // Verify removal\n\n    return 0;\n}", "golden_completion": "\nbool UserManager::addUser(const User& user) {\n    for (const auto& existingUser : users_) {\n        if (existingUser.getId() == user.getId()) {\n            return false; // User with the same ID already exists.\n        }\n    }\n    users_.push_back(user);\n    return true;\n}\n\n", "LLM_justification": "This example is a good test case because it involves translating between comprehensive documentation and working C++ code. The provided code in the prefix includes detailed class definitions and methods for managing a collection of users, which is a common scenario in business logic. The golden completion requires generating documentation for these methods, ensuring that the LLM can accurately describe the functionality and parameters of each method. The suffix includes the implementation of the methods and assertions to verify their correctness, ensuring that the generated documentation is consistent with the actual code behavior. This tests the LLM's ability to handle both code-to-comment and comment-to-code translations effectively.", "assertions": ""}
{"id": "18", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Represents an employee in the organization.\n */\nclass Employee {\npublic:\n    /**\n     * @brief Constructs an Employee with the given name and ID.\n     * @param name The name of the employee.\n     * @param id The unique identifier for the employee.\n     */\n    Employee(const std::string& name, int id) : name(name), id(id) {}\n\n    /**\n     * @brief Gets the employee's name.\n     * @return The name of the employee.\n     */\n    std::string getName() const { return name; }\n\n    /**\n     * @brief Gets the employee's ID.\n     * @return The ID of the employee.\n     */\n    int getId() const { return id; }\n\nprivate:\n    std::string name;\n    int id;\n};\n\n/**\n * @brief Manages a list of employees.\n */\nclass EmployeeManager {\npublic:\n    /**\n     * @brief Adds a new employee to the manager.\n     * @param employee The employee to add.\n     */\n    void addEmployee(const Employee& employee) {\n        employees.push_back(employee);\n    }\n\n    /**\n     * @brief Finds an employee by ID.\n     * @param id The ID of the employee to find.\n     * @return The employee with the given ID, or nullptr if not found.\n     */\n    Employee* findEmployeeById(int id);\n\nprivate:\n    std::vector<Employee> employees;\n};\n", "suffix": "int main() {\n    EmployeeManager manager;\n    Employee emp1(\"Alice\", 1);\n    Employee emp2(\"Bob\", 2);\n    manager.addEmployee(emp1);\n    manager.addEmployee(emp2);\n\n    Employee* foundEmp = manager.findEmployeeById(1);\n    assert(foundEmp != nullptr);\n    assert(foundEmp->getName() == \"Alice\");\n\n    foundEmp = manager.findEmployeeById(3);\n    assert(foundEmp == nullptr);\n\n    foundEmp = manager.findEmployeeById(2);\n    assert(foundEmp != nullptr);\n    assert(foundEmp->getName() == \"Bob\");\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "Employee* EmployeeManager::findEmployeeById(int id) {\n    for (auto& employee : employees) {\n        if (employee.getId() == id) {\n            return &employee;\n        }\n    }\n    return nullptr;\n}\n", "LLM_justification": "This test case provides a realistic business logic scenario involving an Employee and EmployeeManager class. The prefix includes detailed class definitions and method prototypes, setting up the context for the golden completion. The golden completion involves implementing the findEmployeeById method, which is a typical task in managing collections of business entities. The suffix includes a main function that thoroughly tests the implementation with various assertions, ensuring correctness. This scenario effectively tests the LLM's ability to translate between code and documentation by verifying functional requirements, testing edge cases, and validating return values.", "assertions": ""}
{"id": "19", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief This class represents a simple cache system that stores key-value pairs.\n */\nclass SimpleCache {\npublic:\n    /**\n     * @brief Adds a key-value pair to the cache.\n     * @param key The key associated with the value.\n     * @param value The value to be cached.\n     */\n    void add(const std::string& key, const std::string& value);\n\n    /**\n     * @brief Retrieves a value from the cache based on the key.\n     * @param key The key associated with the value.\n     * @return The cached value, or an empty string if the key is not found.\n     */\n    std::string get(const std::string& key) const;\n\n    /**\n     * @brief Removes a key-value pair from the cache.\n     * @param key The key associated with the value to be removed.\n     */\n    void remove(const std::string& key);\n\nprivate:\n    std::vector<std::pair<std::string, std::string>> cache;\n};\n\nvoid SimpleCache::add(const std::string& key, const std::string& value) {\n    for (auto& pair : cache) {\n        if (pair.first == key) {\n            pair.second = value;\n            return;\n        }\n    }\n    cache.emplace_back(key, value);\n}\n\nstd::string SimpleCache::get(const std::string& key) const {\n    for (const auto& pair : cache) {\n        if (pair.first == key) {\n            return pair.second;\n        }\n    }\n    return \"\";\n}\n", "suffix": "\n\nint main() {\n    SimpleCache cache;\n    cache.add(\"key1\", \"value1\");\n    cache.add(\"key2\", \"value2\");\n\n    assert(cache.get(\"key1\") == \"value1\");\n    assert(cache.get(\"key2\") == \"value2\");\n\n    cache.remove(\"key1\");\n    assert(cache.get(\"key1\").empty());\n    assert(cache.get(\"key2\") == \"value2\");\n\n    cache.remove(\"key2\");\n    assert(cache.get(\"key2\").empty());\n\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "void SimpleCache::remove(const std::string& key) {\n    cache.erase(std::remove_if(cache.begin(), cache.end(), [&key](const std::pair<std::string, std::string>& pair) {\n        return pair.first == key;\n    }), cache.end());\n}\n", "LLM_justification": "This example tests the LLM's ability to translate C++ code into comprehensive documentation and vice versa. The prefix provides a class definition for a simple cache system, including method declarations and implementations for adding and retrieving key-value pairs, along with detailed Doxygen-style documentation. The golden_completion requires implementing the remove method for the cache, following the provided documentation style and ensuring consistency with the existing methods. The suffix includes assertions that verify the correctness of the implementation by adding, retrieving, and removing key-value pairs, ensuring the cache behaves as expected. This scenario is realistic, involves resource management, error handling, and demonstrates good documentation practices, making it an effective test case for code-to-comment and comment-to-code translation capabilities.", "assertions": ""}
{"id": "20", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief A class representing a product in an inventory system.\n */\nclass Product {\npublic:\n    /**\n     * @brief Constructs a product with the given name, price, and quantity.\n     * @param name The name of the product.\n     * @param price The price of the product.\n     * @param quantity The quantity of the product in stock.\n     */\n    Product(const std::string& name, double price, int quantity)\n        : name_(name), price_(price), quantity_(quantity) {}\n\n    /**\n     * @brief Gets the name of the product.\n     * @return The name of the product.\n     */\n    std::string getName() const { return name_; }\n\n    /**\n     * @brief Gets the price of the product.\n     * @return The price of the product.\n     */\n    double getPrice() const { return price_; }\n\n    /**\n     * @brief Gets the quantity of the product in stock.\n     * @return The quantity of the product.\n     */\n    int getQuantity() const { return quantity_; }\n\nprivate:\n    std::string name_;\n    double price_;\n    int quantity_;\n};\n\n/**\n * @brief A class representing an inventory system.\n */\nclass Inventory {\npublic:\n    /**\n     * @brief Adds a product to the inventory.\n     * @param product The product to add.\n     */\n    void addProduct(const Product& product) {\n        products_.push_back(product);\n    }\n\n    /**\n     * @brief Calculates the total value of the inventory.\n     * @return The total value of all products in the inventory.\n     */\n    double calculateTotalValue() const {\n        double totalValue = 0.0;\n        for (const auto& product : products_) {\n            totalValue += product.getPrice() * product.getQuantity();\n        }\n        return totalValue;\n    }\n\nprivate:\n    std::vector<Product> products_;\n};\n\n", "suffix": "void testInventory() {\n    Inventory inventory;\n    inventory.addProduct(Product(\"Laptop\", 1000.0, 5));\n    inventory.addProduct(Product(\"Phone\", 500.0, 10));\n    double totalValue = inventory.calculateTotalValue();\n    assert(totalValue == 10000.0);\n    std::cout << \"Total inventory value: \" << totalValue << std::endl;\n}\n\nint main() {\n    testInventory();\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Tests the Inventory class by adding products and calculating the total value.\n *\n * This function creates an Inventory object, adds two products to it, and then\n * calculates the total value of the inventory. The total value is verified\n * using an assertion.\n */\n", "LLM_justification": "This example tests bidirectional translation between code and documentation by providing a complete class and method implementation for an inventory system and requiring the generation of comprehensive documentation for a test function. It assesses the LLM's ability to understand class relationships, method functionalities, and their integration, while also verifying the correctness of the documentation using assertions.", "assertions": ""}
{"id": "21", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Represents a user in the business domain.\n */\nclass User {\npublic:\n    User(const std::string &name, int age) : name_(name), age_(age) {}\n    const std::string &getName() const { return name_; }\n    int getAge() const { return age_; }\nprivate:\n    std::string name_;\n    int age_;\n};\n\n/**\n * @brief Represents a policy that checks if a user is eligible for a specific service.\n */\nclass EligibilityPolicy {\npublic:\n    /**\n     * @brief Determines if a user is eligible based on their age.\n     * @param user The user to check.\n     * @return True if the user is eligible, otherwise false.\n     */\n    bool isEligible(const User &user) const;\n};\n\nbool EligibilityPolicy::isEligible(const User &user) const {\n    return user.getAge() >= 18;\n}\n\n/**\n * @brief Service that processes users based on their eligibility.\n */\nclass UserService {\npublic:\n    UserService(const EligibilityPolicy &policy) : policy_(policy) {}\n    /**\n     * @brief Processes a list of users and returns the names of eligible users.\n     * @param users The list of users to process.\n     * @return A list of names of eligible users.\n     */\n    std::vector<std::string> processUsers(const std::vector<User> &users) const;\nprivate:\n    const EligibilityPolicy &policy_;\n};\n\n", "suffix": "int main() {\n    EligibilityPolicy policy;\n    UserService service(policy);\n    std::vector<User> users = { User(\"Alice\", 20), User(\"Bob\", 16), User(\"Charlie\", 22) };\n    std::vector<std::string> eligibleUsers = service.processUsers(users);\n\n    assert(eligibleUsers.size() == 2);\n    assert(eligibleUsers[0] == \"Alice\");\n    assert(eligibleUsers[1] == \"Charlie\");\n\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "\nstd::vector<std::string> UserService::processUsers(const std::vector<User> &users) const {\n    std::vector<std::string> eligibleUsers;\n    for (const auto &user : users) {\n        if (policy_.isEligible(user)) {\n            eligibleUsers.push_back(user.getName());\n        }\n    }\n    return eligibleUsers;\n}\n", "LLM_justification": "This test case covers a realistic business logic scenario involving user eligibility processing and service orchestration. The code-to-comment part demonstrates a comprehensive documentation style for a method implementation, ensuring that all details such as parameter descriptions and return values are covered. The comment-to-code part requires implementing a method based on detailed documentation, testing the LLM's ability to translate specifications into functional code. Assertions in the suffix verify that the implementation meets the documented requirements.", "assertions": ""}
{"id": "22", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Represents an Employee in a company.\n */\nclass Employee {\npublic:\n    Employee(const std::string& name, int id, double salary)\n        : name(name), id(id), salary(salary) {}\n\n    /**\n     * @brief Gets the employee's name.\n     * @return The name of the employee.\n     */\n    std::string getName() const { return name; }\n\n    /**\n     * @brief Gets the employee's ID.\n     * @return The ID of the employee.\n     */\n    int getId() const { return id; }\n\n    /**\n     * @brief Gets the employee's salary.\n     * @return The salary of the employee.\n     */\n    double getSalary() const { return salary; }\n\n    /**\n     * @brief Sets the employee's salary.\n     * @param newSalary The new salary to be set.\n     */\n    void setSalary(double newSalary) { salary = newSalary; }\n\nprivate:\n    std::string name;\n    int id;\n    double salary;\n};\n\n/**\n * @brief Represents a collection of employees in a department.\n */\nclass Department {\npublic:\n    /**\n     * @brief Adds an employee to the department.\n     * @param employee The employee to be added.\n     */\n    void addEmployee(const Employee& employee) {\n        employees.push_back(employee);\n    }\n\n    /**\n     * @brief Calculates the total salary of all employees in the department.\n     * @return The total salary of all employees.\n     */\n    double calculateTotalSalary() const;\n\nprivate:\n    std::vector<Employee> employees;\n};\n", "suffix": "\n\nint main() {\n    Employee emp1(\"John Doe\", 1, 50000);\n    Employee emp2(\"Jane Smith\", 2, 60000);\n    Department dept;\n    dept.addEmployee(emp1);\n    dept.addEmployee(emp2);\n\n    double totalSalary = dept.calculateTotalSalary();\n    assert(totalSalary == 110000);\n\n    std::cout << \"Total Salary: \" << totalSalary << std::endl;\n    return 0;\n}\n", "golden_completion": "\ndouble Department::calculateTotalSalary() const {\n    double totalSalary = 0.0;\n    for (const auto& employee : employees) {\n        totalSalary += employee.getSalary();\n    }\n    return totalSalary;\n}\n", "LLM_justification": "This test case covers both code-to-comment and comment-to-code translation. The code-to-comment part requires the LLM to generate comprehensive documentation for the `calculateTotalSalary` method in the `Department` class. The comment-to-code part requires the LLM to implement the `calculateTotalSalary` method based on the provided documentation. The assertions in the suffix verify the correctness of the implementation by ensuring the total salary calculation is accurate. This scenario is realistic as it deals with business logic related to employee management and salary calculations, which are common in enterprise applications.", "assertions": ""}
{"id": "23", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief A class that represents a User in a business application.\n *\n * This class stores user information and validates business rules\n * such as ensuring the user's age is within a valid range and the\n * email format is correct.\n */\nclass User {\npublic:\n    /**\n     * @brief Constructs a new User object.\n     *\n     * @param name The name of the user.\n     * @param age The age of the user.\n     * @param email The email address of the user.\n     */\n    User(const std::string& name, int age, const std::string& email)\n        : name_(name), age_(age), email_(email) {}\n\n    /**\n     * @brief Validates the user's age.\n     *\n     * @return true if the age is between 18 and 99, false otherwise.\n     */\n    bool validateAge() const {\n        return age_ >= 18 && age_ <= 99;\n    }\n\n    /**\n     * @brief Validates the user's email format.\n     *\n     * @return true if the email contains '@' and '.', false otherwise.\n     */\n    bool validateEmail() const {\n        return email_.find('@') != std::string::npos && email_.find('.') != std::string::npos;\n    }\n\nprivate:\n    std::string name_;\n    int age_;\n    std::string email_;\n};\n\n/**\n * @brief A class that manages a list of users and performs operations on them.\n *\n * This class supports adding users, validating all users, and displaying user information.\n */\nclass UserManager {\npublic:\n    /**\n     * @brief Adds a new user to the list.\n     *\n     * @param user The User object to add.\n     */\n    void addUser(const User& user) {\n        users_.push_back(user);\n    }\n\n    /**\n     * @brief Validates all users in the list.\n     *\n     * @return true if all users pass validation, false otherwise.\n     */\n    bool validateAllUsers() const;\n\n    /**\n     * @brief Displays all users' information.\n     */\n    void displayUsers() const;\n\nprivate:\n    std::vector<User> users_;\n};\n", "suffix": "\n\n/**\n * @brief Implements the method to display all users' information.\n */\nvoid UserManager::displayUsers() const {\n    for (const auto& user : users_) {\n        std::cout << \"Name: \" << user.name_ << \", Age: \" << user.age_ << \", Email: \" << user.email_ << std::endl;\n    }\n}\n\nint main() {\n    UserManager manager;\n    User user1(\"Alice\", 25, \"alice@example.com\");\n    User user2(\"Bob\", 17, \"bob@example\");\n    manager.addUser(user1);\n    manager.addUser(user2);\n\n    assert(manager.validateAllUsers() == false);\n\n    manager.displayUsers();\n\n    return 0;\n}", "golden_completion": "/**\n * @brief Implements the method to validate all users in the list.\n *\n * @return true if all users pass validation, false otherwise.\n */\nbool UserManager::validateAllUsers() const {\n    for (const auto& user : users_) {\n        if (!user.validateAge() || !user.validateEmail()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n", "LLM_justification": "This test case is a good example of a realistic business scenario where user data is managed and validated against business rules. The code-to-comment translation tests the model's ability to generate comprehensive documentation for methods in a class. The scenario also includes validation logic and edge cases, making it a robust test for both code generation and documentation capabilities. The assertions verify that the validation logic is correctly implemented and that the documentation covers all necessary details.", "assertions": ""}
{"id": "24", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * Represents a single task in the workflow.\n */\nclass Task {\npublic:\n    Task(const std::string &name) : name(name), completed(false) {}\n\n    /**\n     * Marks the task as completed.\n     */\n    void complete() {\n        completed = true;\n    }\n\n    /**\n     * Checks if the task is completed.\n     * @return True if the task is completed, false otherwise.\n     */\n    bool isCompleted() const {\n        return completed;\n    }\n\n    /**\n     * Gets the name of the task.\n     * @return The name of the task.\n     */\n    std::string getName() const {\n        return name;\n    }\n\nprivate:\n    std::string name;\n    bool completed;\n};\n\n/**\n * Manages a list of tasks and allows for task completion and status checks.\n */\nclass Workflow {\npublic:\n    /**\n     * Adds a new task to the workflow.\n     * @param task The task to be added.\n     */\n    void addTask(const Task &task) {\n        tasks.push_back(task);\n    }\n\n    /**\n     * Marks a task as completed by its name.\n     * @param name The name of the task to be completed.\n     * @return True if the task was found and marked as completed, false otherwise.\n     */\n    bool completeTask(const std::string &name);\n\n    /**\n     * Checks the completion status of a task by its name.\n     * @param name The name of the task to check.\n     * @return True if the task is completed, false otherwise.\n     */\n    bool isTaskCompleted(const std::string &name) const;\n\nprivate:\n    std::vector<Task> tasks;\n};\n\nbool Workflow::completeTask(const std::string &name) {\n    for (auto &task : tasks) {\n        if (task.getName() == name) {\n            task.complete();\n            return true;\n        }\n    }\n    return false;\n}", "suffix": "\n\nint main() {\n    Workflow workflow;\n    Task task1(\"Design\");\n    Task task2(\"Implementation\");\n    Task task3(\"Testing\");\n\n    workflow.addTask(task1);\n    workflow.addTask(task2);\n    workflow.addTask(task3);\n\n    // Complete the 'Implementation' task\n    assert(workflow.completeTask(\"Implementation\"));\n    // Check the status of the tasks\n    assert(workflow.isTaskCompleted(\"Design\") == false);\n    assert(workflow.isTaskCompleted(\"Implementation\") == true);\n    assert(workflow.isTaskCompleted(\"Testing\") == false);\n    // Try to complete a non-existent task\n    assert(workflow.completeTask(\"Deployment\") == false);\n\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "\nbool Workflow::isTaskCompleted(const std::string &name) const {\n    for (const auto &task : tasks) {\n        if (task.getName() == name) {\n            return task.isCompleted();\n        }\n    }\n    return false;\n}\n", "LLM_justification": "This test case is designed to evaluate the ability of an LLM to translate detailed natural language documentation into accurate and executable C++ code, and vice versa. The Workflow and Task classes represent a common business logic scenario of managing and checking the status of tasks. The prefix provides detailed documentation and partially implemented methods, the golden_completion fills in the missing documentation, and the suffix includes assertions to validate the implementation and documentation. This comprehensive setup ensures the LLM's proficiency in both understanding and generating documentation, as well as implementing functional code correctly.", "assertions": ""}
{"id": "25", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief A class representing a business entity with compliance checks.\n */\nclass BusinessEntity {\npublic:\n    /**\n     * @brief Constructor initializing the business entity with a name and an initial value.\n     * @param name The name of the business entity.\n     * @param initialValue The initial value associated with the business entity.\n     */\n    BusinessEntity(const std::string& name, double initialValue)\n        : name(name), value(initialValue) {}\n\n    /**\n     * @brief Applies a set of compliance rules to the business entity.\n     * @param rules A vector of compliance rules as strings.\n     * @return true if all rules are satisfied, false otherwise.\n     */\n    bool applyComplianceRules(const std::vector<std::string>& rules);\n\nprivate:\n    std::string name;\n    double value;\n};\n\n", "suffix": "int main() {\n    BusinessEntity entity(\"TestEntity\", 50);\n    std::vector<std::string> rules = {\"min_value\", \"max_value\"};\n    bool complianceResult = entity.applyComplianceRules(rules);\n    assert(complianceResult == true);\n\n    BusinessEntity entity2(\"TestEntity2\", -10);\n    complianceResult = entity2.applyComplianceRules(rules);\n    assert(complianceResult == false);\n\n    BusinessEntity entity3(\"TestEntity3\", 150);\n    complianceResult = entity3.applyComplianceRules(rules);\n    assert(complianceResult == false);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "\nbool BusinessEntity::applyComplianceRules(const std::vector<std::string>& rules) {\n    for (const auto& rule : rules) {\n        if (rule == \"min_value\" && value < 0) {\n            return false;\n        }\n        if (rule == \"max_value\" && value > 100) {\n            return false;\n        }\n    }\n    return true;\n}", "LLM_justification": "This test case is a good example for code-to-comment translation as it includes a class with a method that has specific business logic for compliance checks. The provided prefix contains the class definition, constructor, and method signature along with partial implementation. The golden completion fills in the detailed Doxygen-style documentation for the method, explaining the business rules it enforces. The suffix includes assertions that verify the correct behavior of the method under different conditions, ensuring the documentation accurately describes the functionality. This scenario tests the LLM's ability to generate detailed documentation from code and verify the accuracy of that documentation through functional assertions.", "assertions": ""}
{"id": "26", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief A class to represent a business entity with compliance checks.\n */\nclass BusinessEntity {\nprivate:\n    std::string name;\n    int complianceScore;\n    bool isCompliant;\n\npublic:\n    /**\n     * @brief Constructor to initialize a BusinessEntity.\n     * @param name The name of the business entity.\n     * @param complianceScore The compliance score of the business entity.\n     */\n    BusinessEntity(const std::string& name, int complianceScore) \n        : name(name), complianceScore(complianceScore), isCompliant(false) {}\n\n    /**\n     * @brief Check compliance based on the compliance score.\n     * @return True if compliant, otherwise false.\n     */\n    bool checkCompliance() {\n        isCompliant = (complianceScore >= 75);\n        return isCompliant;\n    }\n\n    /**\n     * @brief Get the name of the business entity.\n     * @return The name of the business entity.\n     */\n    std::string getName() const { return name; }\n\n    /**\n     * @brief Get the compliance status of the business entity.\n     * @return True if compliant, otherwise false.\n     */\n    bool getComplianceStatus() const { return isCompliant; }\n};\n\n/**\n * @brief A function to validate multiple business entities for compliance.\n * @param entities A vector of BusinessEntity objects to be validated.\n * @return A vector of compliant business entity names.\n */\n", "suffix": "\nint main() {\n    BusinessEntity entity1(\"EntityOne\", 80);\n    BusinessEntity entity2(\"EntityTwo\", 60);\n    BusinessEntity entity3(\"EntityThree\", 90);\n\n    // Check compliance for each entity\n    assert(entity1.checkCompliance() == true);\n    assert(entity2.checkCompliance() == false);\n    assert(entity3.checkCompliance() == true);\n\n    std::vector<BusinessEntity> entities = {entity1, entity2, entity3};\n    std::vector<std::string> compliantEntities = validateEntities(entities);\n\n    // Validate the compliance check results\n    assert(compliantEntities.size() == 2);\n    assert(compliantEntities[0] == \"EntityOne\");\n    assert(compliantEntities[1] == \"EntityThree\");\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "\nstd::vector<std::string> validateEntities(const std::vector<BusinessEntity>& entities) {\n    std::vector<std::string> compliantEntities;\n    for (const auto& entity : entities) {\n        if (entity.getComplianceStatus()) {\n            compliantEntities.push_back(entity.getName());\n        }\n    }\n    return compliantEntities;\n}\n", "LLM_justification": "This scenario tests the model's ability to generate documentation from code and vice versa. The prefix establishes a comprehensive class definition and method implementations, demonstrating realistic business logic with compliance checks. The golden completion provides the documentation for a function that validates multiple business entities. The suffix includes assertions to verify the functionality and correctness of the code, ensuring the documentation matches the implementation and that all assertions pass successfully.", "assertions": ""}
{"id": "27", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Represents a business entity for customer orders.\n */\nclass Order {\npublic:\n    Order(int id, double amount) : id(id), amount(amount) {}\n    int getId() const { return id; }\n    double getAmount() const { return amount; }\nprivate:\n    int id;\n    double amount;\n};\n\n/**\n * @brief Manages a collection of orders and provides business logic for order processing.\n */\nclass OrderManager {\npublic:\n    /**\n     * @brief Adds a new order to the collection.\n     * @param order The order to be added.\n     */\n    void addOrder(const Order& order) {\n        orders.push_back(order);\n    }\n\n    /**\n     * @brief Calculates the total amount of all orders.\n     * @return The total amount as a double.\n     */\n    double calculateTotalAmount() const {\n        double total = 0.0;\n        for (const auto& order : orders) {\n            total += order.getAmount();\n        }\n        return total;\n    }\n\n    /**\n     * @brief Removes orders that have an amount less than the specified threshold.\n     * @param threshold The minimum amount an order must have to be retained.\n     */\n    void removeSmallOrders(double threshold);\n\nprivate:\n    std::vector<Order> orders;\n};\n\n", "suffix": "int main() {\n    OrderManager manager;\n    manager.addOrder(Order(1, 150.0));\n    manager.addOrder(Order(2, 50.0));\n    manager.addOrder(Order(3, 250.0));\n\n    // Expected total amount: 450.0\n    assert(manager.calculateTotalAmount() == 450.0);\n    // Remove orders with amount less than 100.0\n    manager.removeSmallOrders(100.0);\n\n    // Expected total amount after removal: 400.0\n    assert(manager.calculateTotalAmount() == 400.0);\n\n    return 0;\n}\n\n", "golden_completion": "\nvoid OrderManager::removeSmallOrders(double threshold) {\n    orders.erase(std::remove_if(orders.begin(), orders.end(), [threshold](const Order& order) {\n        return order.getAmount() < threshold;\n    }), orders.end());\n}\n", "LLM_justification": "This test case demonstrates a realistic business logic scenario where an OrderManager class manages a collection of Order objects. The task is to provide documentation for a method that removes orders based on a threshold. This scenario tests the LLM's ability to translate between code and comprehensive documentation accurately. The assertions in the suffix ensure that the code functions correctly by verifying the total amount of orders before and after the removal operation.", "assertions": ""}
{"id": "28", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <memory>\n\n/**\n * @brief BusinessEntity class represents an entity in the business domain.\n * It holds information about the entity's ID and name.\n */\nclass BusinessEntity {\npublic:\n    /**\n     * @brief Constructor for BusinessEntity.\n     * @param id The unique identifier for the entity.\n     * @param name The name of the entity.\n     */\n    BusinessEntity(int id, const std::string& name) : id_(id), name_(name) {}\n\n    /**\n     * @brief Gets the ID of the entity.\n     * @return The unique identifier of the entity.\n     */\n    int getId() const { return id_; }\n\n    /**\n     * @brief Gets the name of the entity.\n     * @return The name of the entity.\n     */\n    std::string getName() const { return name_; }\n\n    /**\n     * @brief Sets the ID of the entity.\n     * @param id The new unique identifier for the entity.\n     */\n    void setId(int id) { id_ = id; }\n\n    /**\n     * @brief Sets the name of the entity.\n     * @param name The new name for the entity.\n     */\n    void setName(const std::string& name) { name_ = name; }\n\nprivate:\n    int id_;\n    std::string name_;\n};\n\n/**\n * @brief Validates if the entity complies with the business rules.\n * The rules are:\n * - The ID must be a positive integer.\n * - The name must not be empty and should have at least 3 characters.\n * @param entity The entity to validate.\n * @return True if the entity complies with the rules, otherwise false.\n */\nbool validateEntity(const BusinessEntity& entity) {", "suffix": "    return (entity.getId() > 0) && (entity.getName().length() >= 3);\n}\n\nint main() {\n    BusinessEntity entity1(1, \"Alice\");\n    BusinessEntity entity2(0, \"\");\n    BusinessEntity entity3(2, \"Bo\");\n    BusinessEntity entity4(3, \"Charlie\");\n\n    assert(validateEntity(entity1)); // Valid entity\n    assert(!validateEntity(entity2)); // Invalid: ID is not positive, name is empty\n    assert(!validateEntity(entity3)); // Invalid: name is less than 3 characters\n    assert(validateEntity(entity4)); // Valid entity\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "    if (entity.getId() <= 0) return false;\n    if (entity.getName().empty() || entity.getName().length() < 3) return false;\n    return true;", "LLM_justification": "This test case evaluates both code-to-comment and comment-to-code translation capabilities. The prefix provides detailed Doxygen-style documentation for a class and a function. The golden completion requires implementing the validation logic based on the given documentation, ensuring the entity ID is positive and the name is non-empty with at least 3 characters. The suffix includes assertions to verify the correctness of the implementation, checking various scenarios including valid and invalid entities. This example tests complex business rules validation, ensuring the model can accurately translate between code and documentation while maintaining consistency and correctness.", "assertions": ""}
{"id": "29", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief Represents a product in the inventory system.\n */\nclass Product {\npublic:\n    Product(const std::string& name, double price, int quantity)\n        : name_(name), price_(price), quantity_(quantity) {}\n\n    /**\n     * @brief Get the name of the product.\n     * @return The product name.\n     */\n    std::string getName() const { return name_; }\n\n    /**\n     * @brief Get the price of the product.\n     * @return The product price.\n     */\n    double getPrice() const { return price_; }\n\n    /**\n     * @brief Get the quantity of the product.\n     * @return The product quantity.\n     */\n    int getQuantity() const { return quantity_; }\n\n    /**\n     * @brief Set the quantity of the product.\n     * @param quantity The new quantity.\n     */\n    void setQuantity(int quantity) { quantity_ = quantity; }\n\nprivate:\n    std::string name_;\n    double price_;\n    int quantity_;\n};\n\n/**\n * @brief Manages a collection of products in the inventory.\n */\nclass Inventory {\npublic:\n    /**\n     * @brief Adds a product to the inventory.\n     * @param product The product to add.\n     */\n    void addProduct(const Product& product) { products_.push_back(product); }\n\n    /**\n     * @brief Removes a product from the inventory by name.\n     * @param productName The name of the product to remove.\n     */\n    void removeProduct(const std::string& productName);\n\n    /**\n     * @brief Finds a product by name.\n     * @param productName The name of the product to find.\n     * @return A pointer to the product if found, nullptr otherwise.\n     */\n    Product* findProduct(const std::string& productName);\n\nprivate:\n    std::vector<Product> products_;\n};\n\nvoid Inventory::removeProduct(const std::string& productName) {\n    for (auto it = products_.begin(); it != products_.end(); ++it) {\n        if (it->getName() == productName) {\n            products_.erase(it);\n            return;\n        }\n    }\n}\n", "suffix": "\n\nint main() {\n    Inventory inventory;\n    Product apple(\"Apple\", 0.5, 100);\n    Product banana(\"Banana\", 0.3, 150);\n\n    inventory.addProduct(apple);\n    inventory.addProduct(banana);\n\n    assert(inventory.findProduct(\"Apple\") != nullptr);\n    assert(inventory.findProduct(\"Banana\") != nullptr);\n    assert(inventory.findProduct(\"Orange\") == nullptr);\n\n    inventory.removeProduct(\"Banana\");\n    assert(inventory.findProduct(\"Banana\") == nullptr);\n    assert(inventory.findProduct(\"Apple\") != nullptr);\n\n    return 0;\n}\n", "golden_completion": "\nProduct* Inventory::findProduct(const std::string& productName) {\n    for (auto& product : products_) {\n        if (product.getName() == productName) {\n            return &product;\n        }\n    }\n    return nullptr;\n}\n", "LLM_justification": "This test case demonstrates a realistic scenario involving inventory management. The initial code provides a class structure for managing products and an inventory with detailed Doxygen-style comments. The completion task involves generating the correct implementation of the `findProduct` method based on the provided comments. The assertions in the suffix verify the functionality of the `findProduct` and `removeProduct` methods, ensuring that the implementation matches the documented behavior. This scenario effectively tests an LLM's ability to translate between code and natural language by requiring the generation of both documentation and code.", "assertions": ""}
{"id": "30", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief A class that models a business entity representing a customer.\n */\nclass Customer {\npublic:\n    /**\n     * @brief Constructor to initialize a Customer.\n     * @param name The name of the customer.\n     * @param age The age of the customer.\n     */\n    Customer(const std::string &name, int age) : name(name), age(age) {}\n    \n    /**\n     * @brief Get the name of the customer.\n     * @return The name of the customer.\n     */\n    std::string getName() const { return name; }\n\n    /**\n     * @brief Get the age of the customer.\n     * @return The age of the customer.\n     */\n    int getAge() const { return age; }\n\nprivate:\n    std::string name;\n    int age;\n};\n\n/**\n * @brief A utility function to validate customer data.\n * @param customers A vector of Customer objects.\n * @return true if all customers are valid, false otherwise.\n * @details A customer is considered valid if their age is between 18 and 120.\n */\nbool validateCustomers(const std::vector<Customer> &customers) {\n    for (const auto &customer : customers) {\n        if (customer.getAge() < 18 || customer.getAge() > 120) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @brief A function to demonstrate the usage of Customer class and validation function.\n * @details This function creates a list of customers, validates them, and prints the result.\n */\nvoid demoCustomerValidation() {\n    std::vector<Customer> customers = {Customer(\"Alice\", 25), Customer(\"Bob\", 17), Customer(\"Carol\", 34)};\n    bool isValid = validateCustomers(customers);\n    std::cout << \"Customers are \" << (isValid ? \"valid\" : \"invalid\") << std::endl;\n\n    // Assertions to verify the functionality\n    assert(customers.size() == 3);\n    assert(customers[0].getName() == \"Alice\");\n    assert(customers[1].getAge() == 17);\n    assert(!isValid); // Bob is invalid due to age < 18\n}\n\n", "suffix": "int main() {\n    demoCustomerValidation();\n    return 0;\n}", "golden_completion": "/**\n * @brief Main function to execute the customer validation demo.\n * @return int Exit status.\n */\n", "LLM_justification": "This test case is a good example as it focuses on a realistic business scenario involving a Customer class and a validation function. The prefix provides a comprehensive setup with class definitions, utility functions, and usage examples. The completion requires generating documentation for the main function, ensuring alignment between code and comments. The assertions in the suffix validate the functionality and demonstrate proper resource management with RAII principles.", "assertions": ""}
{"id": "31", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n// A class representing a simple task scheduler for managing and executing tasks.\nclass TaskScheduler {\npublic:\n    struct Task {\n        std::string name;\n        int priority;\n        bool completed;\n\n        Task(const std::string& taskName, int taskPriority)\n            : name(taskName), priority(taskPriority), completed(false) {}\n    };\n\n", "suffix": "\n    void addTask(const std::string& taskName, int priority) {\n        tasks.emplace_back(taskName, priority);\n    }\n\n    // Execute tasks based on priority and mark them as completed.\n    void executeTasks() {\n        // Sort tasks by priority in descending order\n        std::sort(tasks.begin(), tasks.end(), [](const Task& a, const Task& b) {\n            return a.priority > b.priority;\n        });\n\n        // Execute tasks\n        for (auto& task : tasks) {\n            std::cout << \"Executing task: \" << task.name << std::endl;\n            task.completed = true;\n        }\n    }\n\n    // Check if all tasks are completed\n    bool allTasksCompleted() const {\n        for (const auto& task : tasks) {\n            if (!task.completed) {\n                return false;\n            }\n        }\n        return true;\n    }\n\nprivate:\n    std::vector<Task> tasks;\n};\n\nint main() {\n    TaskScheduler scheduler;\n    scheduler.addTask(\"Task1\", 1);\n    scheduler.addTask(\"Task2\", 2);\n    scheduler.addTask(\"Task3\", 3);\n    scheduler.executeTasks();\n    // Assertions to verify the behavior of TaskScheduler\n    assert(scheduler.allTasksCompleted() == true);\n    std::cout << \"All tasks completed successfully.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    /**\n     * @brief Add a new task to the scheduler.\n     * \n     * @param taskName The name of the task to be added.\n     * @param priority The priority of the task. Higher values indicate higher priority.\n     */\n\n", "LLM_justification": "This test case is a good example of translating between code and documentation in both directions. The prefix provides a substantial amount of context with a working implementation of a simple task scheduler, demonstrating realistic business logic for task management. The golden completion adds comprehensive Doxygen-style documentation for the methods within the TaskScheduler class, explaining their purpose, parameters, and behavior. The suffix contains assertions that verify the correctness of the scheduler's functionality, ensuring that all tasks are marked as completed after execution. This scenario effectively tests an LLM's ability to generate accurate documentation for existing code and to understand and implement complex business logic from given documentation.", "assertions": ""}
{"id": "32", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n#include <cassert>\n\n/**\n * @brief Represents a business entity for handling customer information\n */\nclass Customer {\npublic:\n    Customer(int id, const std::string& name, const std::string& email)\n        : id_(id), name_(name), email_(email) {}\n\n    int getId() const { return id_; }\n    const std::string& getName() const { return name_; }\n    const std::string& getEmail() const { return email_; }\n\nprivate:\n    int id_;\n    std::string name_;\n    std::string email_;\n};\n\n/**\n * @brief Handles a collection of customers and performs operations on them\n */\nclass CustomerManager {\npublic:\n    void addCustomer(const Customer& customer) {\n        customers_.push_back(customer);\n    }\n\n    /**\n     * @brief Finds a customer by ID\n     * @param id The ID of the customer to find\n     * @return The customer with the specified ID\n     * @throw std::runtime_error if the customer is not found\n     */\n    Customer findCustomerById(int id) const;\n\nprivate:\n    std::vector<Customer> customers_;\n};\n", "suffix": "int main() {\n    CustomerManager manager;\n    manager.addCustomer(Customer(1, \"John Doe\", \"john.doe@example.com\"));\n    manager.addCustomer(Customer(2, \"Jane Smith\", \"jane.smith@example.com\"));\n\n    try {\n        Customer customer = manager.findCustomerById(1);\n        assert(customer.getId() == 1);\n        assert(customer.getName() == \"John Doe\");\n        assert(customer.getEmail() == \"john.doe@example.com\");\n    } catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    try {\n        manager.findCustomerById(3); // This should throw an error\n        assert(false); // This should never be reached\n    } catch (const std::runtime_error& e) {\n        assert(std::string(e.what()) == \"Customer not found\");\n    }\n\n    return 0;\n}", "golden_completion": "Customer CustomerManager::findCustomerById(int id) const {\n    for (const auto& customer : customers_) {\n        if (customer.getId() == id) {\n            return customer;\n        }\n    }\n    throw std::runtime_error(\"Customer not found\");\n}\n", "LLM_justification": "This scenario tests the translation between code and natural language by providing a detailed class definition with a method that needs to be implemented based on its documentation. The golden completion fills in the method implementation, and the suffix contains assertions to verify the correctness of the implementation. This ensures that the LLM can effectively translate between the documentation and the code, maintaining consistency and functionality.", "assertions": ""}
{"id": "33", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Represents a product in the inventory.\n */\nclass Product {\npublic:\n    std::string name;\n    int quantity;\n    double price;\n\n    Product(const std::string& name, int quantity, double price)\n        : name(name), quantity(quantity), price(price) {}\n};\n\n/**\n * @brief Manages a collection of products and provides operations to update and query the inventory.\n */\nclass InventoryManager {\nprivate:\n    std::vector<Product> products;\n\npublic:\n    /**\n     * @brief Adds a new product to the inventory.\n     * @param product The product to add.\n     */\n    void addProduct(const Product& product) {\n        products.push_back(product);\n    }\n\n    /**\n     * @brief Updates the quantity of an existing product.\n     * @param name The name of the product to update.\n     * @param quantity The new quantity of the product.\n     */\n    void updateQuantity(const std::string& name, int quantity);\n\n    /**\n     * @brief Calculates the total value of the inventory.\n     * @return The total value of the inventory.\n     */\n    double calculateTotalValue() const;\n};\n\nvoid InventoryManager::updateQuantity(const std::string& name, int quantity) {\n    for (auto& product : products) {\n        if (product.name == name) {\n            product.quantity = quantity;\n            return;\n        }\n    }\n    throw std::runtime_error(\"Product not found\");\n}\n", "suffix": "\n\nint main() {\n    InventoryManager manager;\n    manager.addProduct(Product(\"Laptop\", 10, 999.99));\n    manager.addProduct(Product(\"Smartphone\", 5, 499.99));\n    manager.addProduct(Product(\"Tablet\", 20, 299.99));\n\n    // Test updateQuantity\n    manager.updateQuantity(\"Laptop\", 15);\n    assert(manager.calculateTotalValue() == (15 * 999.99 + 5 * 499.99 + 20 * 299.99));\n\n    // Test calculateTotalValue\n    double totalValue = manager.calculateTotalValue();\n    assert(totalValue == (15 * 999.99 + 5 * 499.99 + 20 * 299.99));\n\n    // Test exception for non-existing product\n    try {\n        manager.updateQuantity(\"NonExistingProduct\", 10);\n        assert(false); // Should not reach here\n    } catch (const std::runtime_error& e) {\n        assert(std::string(e.what()) == \"Product not found\");\n    }\n\n    return 0;\n}\n", "golden_completion": "\ndouble InventoryManager::calculateTotalValue() const {\n    double total = 0.0;\n    for (const auto& product : products) {\n        total += product.price * product.quantity;\n    }\n    return total;\n}\n", "LLM_justification": "This test case is a good example for bidirectional translation between code and natural language because it involves complex business logic related to inventory management. The InventoryManager class, along with its methods and the Product class, provides a realistic scenario that requires comprehensive documentation and accurate code implementation. The test case includes detailed Doxygen-style comments, method implementations, error handling, and assertions to verify both the correctness of the code and the completeness of the documentation.", "assertions": ""}
{"id": "34", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <map>\n#include <cassert>\n\n", "suffix": "class ConfigManager {\npublic:\n    // Sets a configuration setting.\n    // @param key The configuration key.\n    // @param value The configuration value.\n    void setConfig(const std::string &key, const std::string &value) {\n        configSettings[key] = value;\n    }\n\n    // Gets a configuration setting.\n    // @param key The configuration key.\n    // @return The configuration value.\n    // @throws std::runtime_error if key does not exist.\n    std::string getConfig(const std::string &key) const {\n        auto it = configSettings.find(key);\n        if (it == configSettings.end()) {\n            throw std::runtime_error(\"Configuration key not found\");\n        }\n        return it->second;\n    }\n\n    // Checks if a feature flag is enabled.\n    // @param feature The feature name.\n    // @return True if the feature is enabled, false otherwise.\n    bool isFeatureEnabled(const std::string &feature) const {\n        auto it = featureFlags.find(feature);\n        return it != featureFlags.end() && it->second;\n    }\n\n    // Enables or disables a feature flag.\n    // @param feature The feature name.\n    // @param enabled True to enable, false to disable.\n    void setFeatureFlag(const std::string &feature, bool enabled) {\n        featureFlags[feature] = enabled;\n    }\n\nprivate:\n    std::map<std::string, std::string> configSettings;\n    std::map<std::string, bool> featureFlags;\n};\n\n// Main function to demonstrate the use of ConfigManager\nint main() {\n    ConfigManager configManager;\n    configManager.setConfig(\"api_url\", \"https://api.example.com\");\n    configManager.setFeatureFlag(\"dark_mode\", true);\n\n    // Assertions to verify the correctness of the implementation\n    assert(configManager.getConfig(\"api_url\") == \"https://api.example.com\");\n    assert(configManager.isFeatureEnabled(\"dark_mode\") == true);\n\n    return 0;\n}\n\n\ntry {\n    assert(configManager.getConfig(\"invalid_key\") == \"\");\n} catch (const std::runtime_error &e) {\n    assert(std::string(e.what()) == \"Configuration key not found\");\n}\n\nconfigManager.setFeatureFlag(\"dark_mode\", false);\nassert(configManager.isFeatureEnabled(\"dark_mode\") == false);\n", "golden_completion": "/**\n * @class ConfigManager\n * @brief Manages dynamic settings and feature flags for the application.\n *\n * This class provides methods to set and get configuration settings,\n * as well as to enable and disable feature flags. It uses std::map\n * to store the settings and flags.\n *\n * @note This class is not thread-safe.\n */\n\n", "LLM_justification": "This test case demonstrates a comprehensive scenario involving dynamic configuration management and feature flag handling, which are common in business applications. The code-to-comment portion documents the entire implementation of the ConfigManager class, including method parameters, return values, and exception handling. The comment-to-code portion ensures that the documentation is accurately translated into working code, with assertions verifying the correctness of the implementation. This scenario effectively tests the LLM's ability to handle complex business logic and technical documentation.", "assertions": ""}
{"id": "35", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Represents a business entity for processing transactions.\n */\nclass Transaction {\npublic:\n    /**\n     * @brief Constructor to initialize transaction with id and amount.\n     * @param id The unique identifier for the transaction.\n     * @param amount The monetary amount of the transaction.\n     */\n    Transaction(int id, double amount) : id(id), amount(amount) {}\n\n    /**\n     * @brief Get the transaction id.\n     * @return The transaction id.\n     */\n    int getId() const { return id; }\n\n    /**\n     * @brief Get the transaction amount.\n     * @return The transaction amount.\n     */\n    double getAmount() const { return amount; }\n\nprivate:\n    int id;\n    double amount;\n};\n\n/**\n * @brief Processes a list of transactions and returns the total amount.\n *\n * @param transactions The list of transactions to process.\n * @return The total amount of all transactions.\n */\n", "suffix": "\nint main() {\n    std::vector<Transaction> transactions = { Transaction(1, 100.0), Transaction(2, 200.0), Transaction(3, -50.0) };\n    double totalAmount = processTransactions(transactions);\n    assert(totalAmount == 250.0);\n    std::cout << \"Total Amount: \" << totalAmount << std::endl;\n    return 0;\n}\n", "golden_completion": "double processTransactions(const std::vector<Transaction>& transactions) {\n    double total = 0.0;\n    for (const auto& transaction : transactions) {\n        total += transaction.getAmount();\n    }\n    return total;\n}", "LLM_justification": "This example demonstrates a realistic business logic scenario involving transaction processing, which includes class definition, constructor, and methods. It tests the model's ability to translate between detailed documentation and accurate C++ code implementation. The assertions validate the functional requirement, ensuring the calculated total amount is correct.", "assertions": ""}
{"id": "36", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\n/**\n * Class representing a product in a store.\n */\nclass Product {\npublic:\n    std::string name;\n    double price;\n    int quantity;\n\n    Product(std::string n, double p, int q) : name(n), price(p), quantity(q) {}\n};\n\n", "suffix": "class ShoppingCart {\nprivate:\n    std::vector<Product> products;\npublic:\n    /**\n     * Adds a product to the shopping cart.\n     * @param product The product to add.\n     */\n    void addProduct(const Product& product) {\n        products.push_back(product);\n    }\n\n    /**\n     * Calculates the total price of all products in the cart.\n     * @return The total price as a double.\n     */\n    double calculateTotalPrice() const {\n        double total = 0.0;\n        for (const auto& product : products) {\n            total += product.price * product.quantity;\n        }\n        return total;\n    }\n\n    /**\n     * Finds the most expensive product in the cart.\n     * @return The most expensive product.\n     */\n    Product findMostExpensiveProduct() const {\n        return *std::max_element(products.begin(), products.end(), [](const Product& a, const Product& b) {\n            return a.price < b.price;\n        });\n    }\n};\nint main() {\n    ShoppingCart cart;\n    cart.addProduct(Product(\"Laptop\", 999.99, 1));\n    cart.addProduct(Product(\"Smartphone\", 599.99, 2));\n    cart.addProduct(Product(\"Headphones\", 199.99, 3));\n\n    double totalPrice = cart.calculateTotalPrice();\n    assert(totalPrice == 2599.94);\n\n    Product mostExpensive = cart.findMostExpensiveProduct();\n    assert(mostExpensive.name == \"Laptop\");\n    assert(mostExpensive.price == 999.99);\n    assert(mostExpensive.quantity == 1);\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "/**\n * The ShoppingCart class provides methods to manage a collection of products.\n *\n * Methods:\n * - void addProduct(const Product& product): Adds a product to the shopping cart.\n * - double calculateTotalPrice() const: Calculates the total price of all products in the cart.\n * - Product findMostExpensiveProduct() const: Finds the most expensive product in the cart.\n *\n * Example Usage:\n * @code\n *   ShoppingCart cart;\n *   cart.addProduct(Product(\"Laptop\", 999.99, 1));\n *   cart.addProduct(Product(\"Smartphone\", 599.99, 2));\n *   cart.addProduct(Product(\"Headphones\", 199.99, 3));\n *   double totalPrice = cart.calculateTotalPrice();\n *   assert(totalPrice == 2599.94);\n *   Product mostExpensive = cart.findMostExpensiveProduct();\n *   assert(mostExpensive.name == \"Laptop\");\n *   assert(mostExpensive.price == 999.99);\n *   assert(mostExpensive.quantity == 1);\n * @endcode\n */\n", "LLM_justification": "This test case is a good example as it involves a realistic scenario of managing a shopping cart in an e-commerce application. It demonstrates the ability to translate between code and natural language effectively by providing comprehensive documentation for a class and its methods. The assertions verify both the correctness of the implementation and the accuracy of the generated documentation. The scenario includes complex business logic and ensures proper handling of data structures and algorithms.", "assertions": ""}
{"id": "37", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Represents a task in the workflow system.\n */\nclass Task {\npublic:\n    Task(const std::string& name, int duration)\n        : name(name), duration(duration) {}\n\n    std::string getName() const { return name; }\n    int getDuration() const { return duration; }\n\nprivate:\n    std::string name;\n    int duration;\n};\n\n/**\n * @brief WorkflowManager manages the execution of tasks in a workflow.\n */\nclass WorkflowManager {\npublic:\n    WorkflowManager() {}\n\n    /**\n     * @brief Adds a task to the workflow.\n     * @param task The task to be added.\n     */\n    void addTask(const Task& task) {\n        tasks.push_back(task);\n    }\n\n    /**\n     * @brief Executes all tasks in the workflow.\n     * @return Total duration of all tasks.\n     */\n    int executeTasks() {\n        int totalDuration = 0;\n        for (const auto& task : tasks) {\n            totalDuration += task.getDuration();\n        }\n        return totalDuration;\n    }\n\nprivate:\n    std::vector<Task> tasks;\n};\n\n", "suffix": "int main() {\n    WorkflowManager wm;\n    wm.addTask(Task(\"Task 1\", 5));\n    wm.addTask(Task(\"Task 2\", 3));\n    wm.addTask(Task(\"Task 3\", 8));\n    int totalDuration = wm.executeTasks();\n    assert(totalDuration == 16);\n    std::cout << \"All tasks executed. Total duration: \" << totalDuration << \" minutes.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Main function to test the WorkflowManager.\n *\n * This function creates a WorkflowManager instance, adds multiple tasks to it,\n * executes all tasks, and then verifies the total duration of all tasks.\n *\n * @return 0 on success.\n */", "LLM_justification": "This example provides a comprehensive test for code-to-comment translation. The prefix establishes a workflow management system with task scheduling and execution. The golden completion requires generating detailed documentation for the main function, ensuring clear alignment between code and comments. The suffix includes assertions to verify the correctness of the task execution logic, making this a robust test case for evaluating an LLM's ability to translate between code and natural language effectively.", "assertions": ""}
{"id": "38", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Represents a User in the business domain with attributes.\n */\nclass User {\npublic:\n    std::string name;\n    int age;\n    std::string role;\n\n    User(const std::string& name, int age, const std::string& role) : name(name), age(age), role(role) {}\n};\n\n/**\n * @brief Manages a collection of users and provides operations on them.\n */\nclass UserManager {\npublic:\n    /**\n     * @brief Adds a user to the collection.\n     * @param user The user to add.\n     */\n    void addUser(const User& user) {\n        users.push_back(user);\n    }\n\n    /**\n     * @brief Gets users above a certain age.\n     * @param age The age to filter users by.\n     * @return A vector of users above the specified age.\n     */\n    std::vector<User> getUsersAboveAge(int age) const {\n        std::vector<User> result;\n        std::copy_if(users.begin(), users.end(), std::back_inserter(result), [age](const User& user) {\n            return user.age > age;\n        });\n        return result;\n    }\n\nprivate:\n    std::vector<User> users;\n};\n\n/**\n * @brief Example usage of the UserManager class.\n */\nvoid exampleUsage() {\n    UserManager manager;\n    manager.addUser(User(\"Alice\", 30, \"Admin\"));\n    manager.addUser(User(\"Bob\", 25, \"User\"));\n    manager.addUser(User(\"Charlie\", 35, \"User\"));\n\n    std::vector<User> usersAbove30 = manager.getUsersAboveAge(30);\n    assert(usersAbove30.size() == 1);\n    assert(usersAbove30[0].name == \"Charlie\");\n}\n", "suffix": "\nint main() {\n    exampleUsage();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Main function to execute the example usage.\n *\n * This function demonstrates the usage of the UserManager class by adding users\n * and then retrieving users above a certain age. It also includes assertions\n * to verify the correctness of the operations.\n */\n", "LLM_justification": "This test case provides a realistic scenario for managing a collection of users and performing operations such as filtering based on age. It demonstrates complex business logic with user management and includes comprehensive documentation that needs to be translated correctly. The assertions verify the correctness of the implementation and ensure that the documentation accurately describes the functionality. The example is realistic and tests the LLM's ability to handle both code-to-comment and comment-to-code translations effectively.", "assertions": ""}
{"id": "39", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief A class representing a basic Task Scheduler.\n *\n * This Task Scheduler manages a list of tasks, each represented by a string.\n * It allows adding, removing, and executing tasks in a FIFO order.\n */\nclass TaskScheduler {\npublic:\n    /**\n     * @brief Adds a task to the scheduler.\n     * @param task The task to be added.\n     */\n    void addTask(const std::string& task) {\n        tasks.push_back(task);\n    }\n\n    /**\n     * @brief Removes the next task from the scheduler.\n     * @return The removed task.\n     * @throws std::runtime_error if there are no tasks to remove.\n     */\n    std::string removeTask() {\n        if (tasks.empty()) {\n            throw std::runtime_error(\"No tasks to remove\");\n        }\n        std::string task = tasks.front();\n        tasks.erase(tasks.begin());\n        return task;\n    }\n\n    /**\n     * @brief Executes all tasks in the scheduler.\n     */\n    void executeAllTasks() {\n        for (const std::string& task : tasks) {\n            executeTask(task);\n        }\n        tasks.clear();\n    }\n\nprivate:\n    std::vector<std::string> tasks;\n\n    /**\n     * @brief Executes a single task.\n     * @param task The task to execute.\n     */\n    void executeTask(const std::string& task) {\n        // Mock execution of task\n        std::cout << \"Executing task: \" << task << std::endl;\n    }\n};\n\nint main() {\n    TaskScheduler scheduler;\n    scheduler.addTask(\"Task 1\");\n    scheduler.addTask(\"Task 2\");\n    scheduler.addTask(\"Task 3\");\n    // Test removing tasks\n", "suffix": "    assert(scheduler.removeTask() == \"Task 1\");\n    assert(scheduler.removeTask() == \"Task 2\");\n\n    // Test exception handling\n    try {\n        scheduler.removeTask();\n        scheduler.removeTask(); // This should throw\n        assert(false); // Should not reach here\n    } catch (const std::runtime_error& e) {\n        assert(std::string(e.what()) == \"No tasks to remove\");\n    }\n\n    // Re-add tasks and execute all\n    scheduler.addTask(\"Task 4\");\n    scheduler.addTask(\"Task 5\");\n    scheduler.executeAllTasks();\n\n    // Check that all tasks have been executed and the list is empty\n    assert(scheduler.removeTask() == \"No tasks to remove\");\n\n    return 0;\n}\n", "golden_completion": "    assert(scheduler.removeTask() == \"Task 3\");\n", "LLM_justification": "This test case covers both code-to-comment and comment-to-code translations by providing detailed class and method documentation, along with realistic task scheduling operations. The golden completion requires generating code to remove a task, demonstrating the LLM's ability to correctly understand and implement the required functionality. The assertions in the suffix verify the correct behavior, exception handling, and state of the TaskScheduler, ensuring comprehensive coverage and validation.", "assertions": ""}
{"id": "40", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// A simple class representing a business entity: Employee\nclass Employee {\nprivate:\n    std::string name;\n    int id;\n    double salary;\n\npublic:\n    Employee(const std::string& name, int id, double salary) : name(name), id(id), salary(salary) {}\n\n    // Get the name of the employee\n    std::string getName() const { return name; }\n\n    // Get the ID of the employee\n    int getId() const { return id; }\n\n    // Get the salary of the employee\n    double getSalary() const { return salary; }\n\n    // Set the salary of the employee\n    void setSalary(double newSalary) { salary = newSalary; }\n};\n\n// A function to calculate the average salary of employees\n", "suffix": "int main() {\n    std::vector<Employee> employees = {\n        Employee(\"John Doe\", 1, 50000),\n        Employee(\"Jane Smith\", 2, 60000),\n        Employee(\"Emily Davis\", 3, 55000)\n    };\n\n    double averageSalary = calculateAverageSalary(employees);\n    std::cout << \"Average Salary: \" << averageSalary << std::endl;\n\n    assert(averageSalary == 55000);\n\n    return 0;\n}", "golden_completion": "double calculateAverageSalary(const std::vector<Employee>& employees) {\n    double totalSalary = 0;\n    for (const auto& employee : employees) {\n        totalSalary += employee.getSalary();\n    }\n    return totalSalary / employees.size();\n}", "LLM_justification": "This example tests the ability of an LLM to generate comprehensive and accurate documentation for a method that calculates the average salary of a list of employees. The prefix provides extensive context with a class definition and multiple method implementations. The golden completion involves implementing the average salary calculation, and the suffix includes assertions to validate the correctness of the implementation. This ensures a thorough test of code-to-comment and comment-to-code translation capabilities, focusing on realistic business logic scenarios.", "assertions": ""}
{"id": "41", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <vector>\n\n/**\n * @brief Represents an employee in the company.\n */\nclass Employee {\npublic:\n    Employee(const std::string& name, int id) : name(name), id(id) {}\n    std::string getName() const { return name; }\n    int getId() const { return id; }\nprivate:\n    std::string name;\n    int id;\n};\n\n/**\n * @brief Manages a list of employees.\n */\nclass EmployeeManager {\npublic:\n    void addEmployee(const Employee& employee) {\n        employees.push_back(employee);\n    }\n\n    /**\n     * @brief Finds an employee by ID.\n     * @param id The ID of the employee to find.\n     * @return The employee with the given ID, or throws an exception if not found.\n     */\n    Employee findEmployeeById(int id);\n\nprivate:\n    std::vector<Employee> employees;\n};\n\nEmployee EmployeeManager::findEmployeeById(int id) {\n    for (const auto& employee : employees) {\n        if (employee.getId() == id) {\n            return employee;\n        }\n    }\n    throw std::runtime_error(\"Employee not found\");\n}\n\nint main() {\n    EmployeeManager manager;\n    manager.addEmployee(Employee(\"John Doe\", 1));\n    manager.addEmployee(Employee(\"Jane Smith\", 2));\n", "suffix": "    // Test cases for the findEmployeeById method\n    try {\n        Employee e = manager.findEmployeeById(1);\n        assert(e.getName() == \"John Doe\");\n        assert(e.getId() == 1);\n    } catch (const std::exception& ex) {\n        assert(false && \"Exception should not be thrown for existing employee\");\n    }\n\n    try {\n        Employee e = manager.findEmployeeById(2);\n        assert(e.getName() == \"Jane Smith\");\n        assert(e.getId() == 2);\n    } catch (const std::exception& ex) {\n        assert(false && \"Exception should not be thrown for existing employee\");\n    }\n\n    try {\n        manager.findEmployeeById(3);\n        assert(false && \"Exception should be thrown for non-existing employee\");\n    } catch (const std::runtime_error& ex) {\n        assert(std::string(ex.what()) == \"Employee not found\");\n    }\n\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Finds an employee by ID.\n * @param id The ID of the employee to find.\n * @return The employee with the given ID, or throws an exception if not found.\n *\n * This method iterates through the list of employees and returns the employee\n * with the matching ID. If no employee is found with the given ID, it throws\n * a std::runtime_error exception with the message \"Employee not found\".\n */\nEmployee EmployeeManager::findEmployeeById(int id) {\n    for (const auto& employee : employees) {\n        if (employee.getId() == id) {\n            return employee;\n        }\n    }\n    throw std::runtime_error(\"Employee not found\");\n}\n", "LLM_justification": "This test case is a good example because it involves a realistic scenario of managing employees in a company. It tests the model's ability to generate comprehensive documentation for a method that includes details on the parameters, return values, and error handling. The assertions in the suffix verify the correct behavior of the method, including handling edge cases where an employee is not found. This ensures that the generated documentation aligns with the code and that the code is functionally correct.", "assertions": ""}
{"id": "42", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n", "suffix": "class LRUCache {\npublic:\n    /**\n     * @brief Constructor to initialize the cache with a given capacity.\n     * @param capacity Maximum number of elements the cache can hold.\n     */\n    LRUCache(size_t capacity) : capacity_(capacity) {}\n\n    /**\n     * @brief Retrieves an element from the cache.\n     * @param key The key of the element to retrieve.\n     * @return The value associated with the key, or -1 if the key is not found.\n     */\n    int get(int key) {\n        auto it = std::find_if(cache_.begin(), cache_.end(), [&key](const std::pair<int, int>& element) {\n            return element.first == key;\n        });\n        if (it != cache_.end()) {\n            // Move the accessed element to the front (most recently used)\n            int value = it->second;\n            cache_.erase(it);\n            cache_.emplace_front(key, value);\n            return value;\n        }\n        return -1;\n    }\n\n    /**\n     * @brief Adds or updates an element in the cache.\n     * @param key The key of the element to add or update.\n     * @param value The value of the element to add or update.\n     */\n    void put(int key, int value) {\n        auto it = std::find_if(cache_.begin(), cache_.end(), [&key](const std::pair<int, int>& element) {\n            return element.first == key;\n        });\n        if (it != cache_.end()) {\n            // Element already exists, update its value and move it to the front\n            cache_.erase(it);\n        } else if (cache_.size() >= capacity_) {\n            // Cache is at capacity, remove the least recently used element\n            cache_.pop_back();\n        }\n        cache_.emplace_front(key, value);\n    }\n\nprivate:\n    size_t capacity_;\n    std::list<std::pair<int, int>> cache_;\n};\n\nint main() {\n    LRUCache cache(2);\n\n    // Test adding elements\n    cache.put(1, 1);\n    cache.put(2, 2);\n    assert(cache.get(1) == 1); // Cache is {1, 2}\n\n    // Test cache eviction\n    cache.put(3, 3); // Evicts key 2, cache is {1, 3}\n    assert(cache.get(2) == -1);\n    assert(cache.get(3) == 3);\n    assert(cache.get(1) == 1);\n\n    // Test updating an element\n    cache.put(1, 10); // Updates key 1, cache is {10, 3}\n    assert(cache.get(1) == 10);\n\n    // Test cache eviction after update\n    cache.put(4, 4); // Evicts key 3, cache is {10, 4}\n    assert(cache.get(3) == -1);\n    assert(cache.get(4) == 4);\n\n    std::cout << \"All tests passed!\\n\";\n    return 0;\n}\n", "golden_completion": "/**\n * @class LRUCache\n * @brief A class implementing a least recently used (LRU) cache mechanism.\n *\n * This class maintains a fixed-size cache and evicts the least recently used\n * element when the capacity is exceeded. It provides methods to add elements\n * to the cache and retrieve elements from the cache.\n *\n * @param capacity The maximum number of elements the cache can hold.\n *\n * @method LRUCache::LRUCache\n * @brief Constructor to initialize the cache with a given capacity.\n *\n * @method LRUCache::get\n * @brief Retrieves an element from the cache.\n * @param key The key of the element to retrieve.\n * @return The value associated with the key, or -1 if the key is not found.\n *\n * @method LRUCache::put\n * @brief Adds or updates an element in the cache.\n * @param key The key of the element to add or update.\n * @param value The value of the element to add or update.\n */\n", "LLM_justification": "This example tests the LLM's ability to both generate comprehensive documentation for a complex C++ class implementing an LRU cache (code-to-comment) and to implement the functionality described in the documentation (comment-to-code). The code includes complex logic for cache eviction and element retrieval, making it a realistic scenario. The assertions verify the correctness of the cache operations, ensuring that the implementation meets the documented behavior.", "assertions": ""}
{"id": "43", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n", "suffix": "class Customer {\nprivate:\n    std::string name;\n    int age;\n    std::string email;\npublic:\n    // Constructor to initialize a customer\n    Customer(const std::string& name, int age, const std::string& email)\n        : name(name), age(age), email(email) {}\n\n    // Method to get the customer's name\n    std::string getName() const { return name; }\n\n    // Method to get the customer's age\n    int getAge() const { return age; }\n\n    // Method to get the customer's email\n    std::string getEmail() const { return email; }\n\n    // Method to check if the customer is an adult\n    bool isAdult() const { return age >= 18; }\n};\n\n// A function to filter out adult customers from a list\nstd::vector<Customer> filterAdults(const std::vector<Customer>& customers) {\n    std::vector<Customer> adults;\n    for (const auto& customer : customers) {\n        if (customer.isAdult()) {\n            adults.push_back(customer);\n        }\n    }\n    return adults;\n}\n\n// A function to print customer details\nvoid printCustomerDetails(const Customer& customer) {\n    std::cout << \"Name: \" << customer.getName() << \"\\n\";\n    std::cout << \"Age: \" << customer.getAge() << \"\\n\";\n    std::cout << \"Email: \" << customer.getEmail() << \"\\n\";\n}\nint main() {\n    std::vector<Customer> customers = {\n        Customer(\"Alice\", 30, \"alice@example.com\"),\n        Customer(\"Bob\", 17, \"bob@example.com\"),\n        Customer(\"Charlie\", 22, \"charlie@example.com\")\n    };\n\n    // Filter adult customers\n    std::vector<Customer> adults = filterAdults(customers);\n\n    // Assertions to verify the filterAdults function\n    assert(adults.size() == 2);\n    assert(adults[0].getName() == \"Alice\");\n    assert(adults[1].getName() == \"Charlie\");\n\n    // Print details of adult customers\n    for (const auto& adult : adults) {\n        printCustomerDetails(adult);\n    }\n\n    return 0;\n}\n", "golden_completion": "/**\n * @brief A class representing a business entity 'Customer' with attributes and methods\n * \n * This class encapsulates the details of a customer including their name, age, and email.\n * It provides methods to retrieve these details and check if the customer is an adult.\n */\n\n", "LLM_justification": "This scenario tests the LLM's ability to generate comprehensive Doxygen-style documentation for a C++ class and its methods. The Customer class and related functions provide a realistic example of business logic involving data encapsulation, filtering, and output. The provided documentation includes detailed descriptions, parameter annotations, and return value explanations. The suffix includes assertions that verify the correctness of the filterAdults function, ensuring that the documentation is consistent with the implemented logic.", "assertions": ""}
{"id": "44", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <stdexcept>\n\n/**\n * @brief A class to manage a collection of business rules for validating user data.\n */\nclass BusinessRulesManager {\npublic:\n    /**\n     * @brief Adds a new rule to the manager.\n     * @param rule A lambda function representing the rule. The lambda takes an integer and returns a boolean.\n     */\n    void addRule(std::function<bool(int)> rule) {\n        rules.push_back(rule);\n    }\n\n    /**\n     * @brief Validates a value against all the business rules.\n     * @param value The value to validate.\n     * @return True if the value passes all rules, false otherwise.\n     */\n    bool validate(int value) const {\n        for (const auto& rule : rules) {\n            if (!rule(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\nprivate:\n    std::vector<std::function<bool(int)>> rules; ///< A collection of business rules.\n};\n\n", "suffix": "int main() {\n    BusinessRulesManager manager;\n    // Adding some rules\n    manager.addRule([](int value) { return value > 0; }); // Rule: value must be positive\n    manager.addRule([](int value) { return value % 2 == 0; }); // Rule: value must be even\n\n    // Validating some values\n    bool result1 = manager.validate(4); // Should be true: 4 is positive and even\n    bool result2 = manager.validate(5); // Should be false: 5 is positive but not even\n    bool result3 = manager.validate(-2); // Should be false: -2 is even but not positive\n    assert(result1 == true);\n    assert(result2 == false);\n    assert(result3 == false);\n\n    // Clean up resources (if any)\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Main function to test the BusinessRulesManager class.\n *\n * This function adds several rules to the BusinessRulesManager and validates\n * a few sample values against these rules. The results are then asserted to\n * ensure the rules are correctly applied.\n */\n", "LLM_justification": "This test case is a good scenario because it involves managing and validating complex business rules, which is a common task in business logic applications. The code demonstrates how to add rules and validate values against them, providing a realistic example for both code-to-comment and comment-to-code translations. The assertions in the suffix validate the functionality of the rules, ensuring that the code works as expected and that the documentation accurately describes the process. This setup will effectively test an LLM's ability to generate comprehensive documentation for existing code and implement code from detailed documentation.", "assertions": ""}
{"id": "45", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n\n/**\n * @brief A simple class to represent a Product in a business domain.\n * \n * This class holds information about a product such as its ID, name, and price.\n */\nclass Product {\npublic:\n    int id;\n    std::string name;\n    double price;\n\n    Product(int id, const std::string& name, double price)\n        : id(id), name(name), price(price) {}\n};\n\n/**\n * @brief A class to manage a collection of products.\n * \n * This class provides methods to add, remove, and search for products in the inventory.\n */\nclass Inventory {\nprivate:\n    std::vector<Product> products;\n\npublic:\n    /**\n     * @brief Adds a new product to the inventory.\n     * \n     * @param product The product to be added.\n     */\n    void addProduct(const Product& product) {\n        products.push_back(product);\n    }\n\n    /**\n     * @brief Removes a product from the inventory by ID.\n     * \n     * @param productId The ID of the product to be removed.\n     * @return true if the product was found and removed, false otherwise.\n     */\n    bool removeProduct(int productId) {\n        auto it = std::remove_if(products.begin(), products.end(),\n                                 [productId](const Product& product) { return product.id == productId; });\n        if (it != products.end()) {\n            products.erase(it, products.end());\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @brief Finds a product in the inventory by ID.\n     * \n     * @param productId The ID of the product to be found.\n     * @return A pointer to the product if found, nullptr otherwise.\n     */\n    Product* findProduct(int productId) {\n        for (auto& product : products) {\n            if (product.id == productId) {\n                return &product;\n            }\n        }\n        return nullptr;\n    }\n};\n\n", "suffix": "int main() {\n    Inventory inventory;\n\n    // Add products\n    inventory.addProduct(Product(1, \"Laptop\", 999.99));\n    inventory.addProduct(Product(2, \"Smartphone\", 499.99));\n\n    // Assertions to verify addProduct\n    assert(inventory.findProduct(1) != nullptr);\n    assert(inventory.findProduct(2) != nullptr);\n    assert(inventory.findProduct(3) == nullptr);\n\n    // Remove product\n    bool removed = inventory.removeProduct(1);\n\n    // Assertions to verify removeProduct\n    assert(removed == true);\n    assert(inventory.findProduct(1) == nullptr);\n    assert(inventory.findProduct(2) != nullptr);\n\n    // Cleanup is not necessary as no dynamic memory allocation is used\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Main function to test the Inventory class.\n * \n * This function adds products to the inventory, verifies their addition, \n * removes a product, and verifies the removal.\n * \n * @return 0 if the tests pass successfully.\n */\n", "LLM_justification": "This test case is a good example because it includes complex business logic for managing an inventory of products. The prefix provides a clear setup with class definitions and methods, while the golden completion requires detailed documentation of the main function. The suffix contains assertions to verify the functionality and correctness of the code, ensuring that the inventory management operations work as expected. This scenario tests the LLM's ability to generate accurate documentation from code and vice versa, including handling business rules and technical features effectively.", "assertions": ""}
{"id": "46", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief Business Entity representing a Customer.\n *\n * This class models a customer entity with basic attributes such as ID, name, and age.\n */\nclass Customer {\nprivate:\n    int id;\n    std::string name;\n    int age;\n\npublic:\n    Customer(int id, const std::string &name, int age) : id(id), name(name), age(age) {}\n\n    int getId() const { return id; }\n    const std::string &getName() const { return name; }\n    int getAge() const { return age; }\n};\n\n", "suffix": "bool validateCustomers(const std::vector<Customer> &customers) {\n    for (const auto &customer : customers) {\n        if (customer.getAge() <= 18 || customer.getName().empty()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @brief Main function to demonstrate validation of customers.\n */\nint main() {\n    std::vector<Customer> customers = {\n        Customer(1, \"Alice\", 30),\n        Customer(2, \"Bob\", 25),\n        Customer(3, \"\", 40),\n        Customer(4, \"Eve\", 17)\n    };\n\n    bool result = validateCustomers(customers);\n    assert(result == false);\n\n    customers[2] = Customer(3, \"Charlie\", 40);\n    customers[3] = Customer(4, \"Dave\", 20);\n\n    result = validateCustomers(customers);\n    assert(result == true);\n\n    std::cout << \"All assertions passed.\\n\";\n    return 0;\n}\n", "golden_completion": "/**\n * @brief Validates a list of customers against business rules.\n *\n * This function checks if all customers in the provided list meet certain criteria:\n * - Age must be above 18\n * - Name must not be empty\n *\n * @param customers The list of customers to validate.\n * @return True if all customers are valid, false otherwise.\n */\n", "LLM_justification": "This example tests the ability of a language model to translate between code and natural language effectively. The prefix provides a comprehensive setup including class definition and business logic functions. The golden completion requires accurate documentation of the validation function, ensuring key terms and structure are present. The suffix includes execution and assertions that verify the correctness of the implementation. This scenario covers complex business rules validation and ensures the model can handle both code-to-comment and comment-to-code translations while maintaining high code quality.", "assertions": ""}
{"id": "47", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stdexcept>\n#include <cassert>\n\n/**\n * @brief A class representing a business entity for an online store.\n *\n * This class manages the product details such as ID, name, price, and inventory count.\n */\nclass Product {\npublic:\n    /**\n     * @brief Constructor to initialize a product with given details.\n     *\n     * @param id The unique identifier for the product.\n     * @param name The name of the product.\n     * @param price The price of the product.\n     * @param inventory The number of items available in stock.\n     */\n    Product(int id, const std::string& name, double price, int inventory)\n        : id_(id), name_(name), price_(price), inventory_(inventory) {}\n\n    /**\n     * @brief Get the product's ID.\n     *\n     * @return The unique identifier of the product.\n     */\n    int getId() const { return id_; }\n\n    /**\n     * @brief Get the product's name.\n     *\n     * @return The name of the product.\n     */\n    std::string getName() const { return name_; }\n\n    /**\n     * @brief Get the product's price.\n     *\n     * @return The price of the product.\n     */\n    double getPrice() const { return price_; }\n\n    /**\n     * @brief Get the product's inventory count.\n     *\n     * @return The number of items available in stock.\n     */\n    int getInventory() const { return inventory_; }\n\n    /**\n     * @brief Set a new price for the product.\n     *\n     * @param newPrice The new price to be set.\n     */\n    void setPrice(double newPrice) { price_ = newPrice; }\n\nprivate:\n    int id_;\n    std::string name_;\n    double price_;\n    int inventory_;\n};\n\n/**\n * @brief A class to manage the product inventory in the store.\n *\n * This class provides functionalities to add, remove, and search for products.\n */\nclass InventoryManager {\npublic:\n    /**\n     * @brief Add a new product to the inventory.\n     *\n     * @param product The product to be added to the inventory.\n     */\n    void addProduct(const Product& product) { products_.push_back(product); }\n\n    /**\n     * @brief Remove a product from the inventory by its ID.\n     *\n     * @param productId The ID of the product to be removed.\n     * @return True if the product was successfully removed, false otherwise.\n     */\n    bool removeProduct(int productId);\n\n    /**\n     * @brief Find a product by its ID.\n     *\n     * @param productId The ID of the product to be found.\n     * @return A pointer to the product if found, nullptr otherwise.\n     */\n    Product* findProduct(int productId);\n\nprivate:\n    std::vector<Product> products_;\n};", "suffix": "bool InventoryManager::removeProduct(int productId) {\n    for (auto it = products_.begin(); it != products_.end(); ++it) {\n        if (it->getId() == productId) {\n            products_.erase(it);\n            return true;\n        }\n    }\n    return false;\n}\n\nProduct* InventoryManager::findProduct(int productId) {\n    for (auto& product : products_) {\n        if (product.getId() == productId) {\n            return &product;\n        }\n    }\n    return nullptr;\n}\n\nint main() {\n    InventoryManager manager;\n    Product p1(1, \"Laptop\", 1000.0, 50);\n    Product p2(2, \"Smartphone\", 500.0, 100);\n\n    manager.addProduct(p1);\n    manager.addProduct(p2);\n\n    assert(manager.findProduct(1) != nullptr);\n    assert(manager.findProduct(2) != nullptr);\n    assert(manager.findProduct(3) == nullptr);\n\n    assert(manager.removeProduct(1) == true);\n    assert(manager.findProduct(1) == nullptr);\n    assert(manager.removeProduct(3) == false);\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "/**\n * @brief Remove a product from the inventory by its ID.\n *\n * @param productId The ID of the product to be removed.\n * @return True if the product was successfully removed, false otherwise.\n */\n\n/**\n * @brief Find a product by its ID.\n *\n * @param productId The ID of the product to be found.\n * @return A pointer to the product if found, nullptr otherwise.\n */", "LLM_justification": "This test case provides a comprehensive example of managing a product inventory in an online store. It includes realistic business logic, such as adding, removing, and finding products. The golden completion focuses on documenting the methods for removing and finding products, which is crucial for understanding the functionality. The suffix includes assertions that verify the correctness of these methods, ensuring that the documentation aligns with the implementation. This scenario effectively tests the LLM's ability to translate between code and documentation.", "assertions": ""}
{"id": "48", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @brief Class representing a Task with priority\n */\nclass Task {\npublic:\n    std::string name;\n    int priority;\n\n    Task(const std::string& name, int priority) : name(name), priority(priority) {}\n};\n\n", "suffix": "\nclass TaskScheduler {\nprivate:\n    std::vector<Task> tasks;\npublic:\n    /**\n     * @brief Add a task to the scheduler\n     * @param task The task to add\n     */\n    void addTask(const Task& task) {\n        tasks.push_back(task);\n    }\n\n    /**\n     * @brief Retrieve tasks sorted by priority\n     * @return A vector of tasks sorted by priority\n     */\n    std::vector<Task> getTasksByPriority() {\n        std::sort(tasks.begin(), tasks.end(), [](const Task& a, const Task& b) {\n            return a.priority > b.priority;\n        });\n        return tasks;\n    }\n};\n\nint main() {\n    TaskScheduler scheduler;\n    scheduler.addTask(Task(\"Task1\", 5));\n    scheduler.addTask(Task(\"Task2\", 1));\n    scheduler.addTask(Task(\"Task3\", 3));\n\n    std::vector<Task> sortedTasks = scheduler.getTasksByPriority();\n\n    assert(sortedTasks[0].name == \"Task1\");\n    assert(sortedTasks[1].name == \"Task3\");\n    assert(sortedTasks[2].name == \"Task2\");\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "/**\n * @class TaskScheduler\n * @brief Manages a collection of tasks and allows them to be sorted by priority.\n *\n * The TaskScheduler class provides functionality to add tasks and retrieve them sorted by priority.\n * This can be useful in scenarios where task execution order needs to be managed based on priority levels.\n *\n * Example usage:\n * @code\n * TaskScheduler scheduler;\n * scheduler.addTask(Task(\"Task1\", 5));\n * scheduler.addTask(Task(\"Task2\", 1));\n * scheduler.addTask(Task(\"Task3\", 3));\n *\n * std::vector<Task> sortedTasks = scheduler.getTasksByPriority();\n * @endcode\n */", "LLM_justification": "This example tests the LLM's ability to generate comprehensive documentation for a class definition and its methods. The TaskScheduler class and its methods are documented to explain their functionality, usage, and behavior. The assertions in the suffix verify the correct behavior of the class methods, ensuring tasks are sorted by priority. This scenario covers business logic related to workflow orchestration, making it a realistic and practical test case.", "assertions": ""}
{"id": "49", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n/**\n * @brief A class representing a business entity: Customer.\n */\nclass Customer {\npublic:\n    Customer(const std::string& name, int age) : name(name), age(age) {}\n    std::string getName() const { return name; }\n    int getAge() const { return age; }\nprivate:\n    std::string name;\n    int age;\n};\n\n/**\n * @brief A class that manages a collection of Customer objects.\n */\nclass CustomerManager {\npublic:\n    void addCustomer(const Customer& customer) {\n        customers.push_back(customer);\n    }\n    /**\n     * @brief Finds a customer by name.\n     * @param name The name of the customer to find.\n     * @return A pointer to the Customer if found, nullptr otherwise.\n     */\n    Customer* findCustomerByName(const std::string& name);\n\n    /**\n     * @brief Validates the age of a customer.\n     * @param customer The customer whose age is to be validated.\n     * @return True if the customer is an adult, false otherwise.\n     */\n    bool validateCustomerAge(const Customer& customer);\n\nprivate:\n    std::vector<Customer> customers;\n};\n\nCustomer* CustomerManager::findCustomerByName(const std::string& name) {\n    for (auto& customer : customers) {\n        if (customer.getName() == name) {\n            return &customer;\n        }\n    }\n    return nullptr;\n}\n", "suffix": "\n\nint main() {\n    CustomerManager manager;\n    Customer alice(\"Alice\", 30);\n    Customer bob(\"Bob\", 15);\n    manager.addCustomer(alice);\n    manager.addCustomer(bob);\n\n    // Validate Alice's age\n    assert(manager.validateCustomerAge(alice) == true);\n    // Validate Bob's age\n    assert(manager.validateCustomerAge(bob) == false);\n\n    // Find Alice by name\n    assert(manager.findCustomerByName(\"Alice\") == &alice);\n    // Find non-existing customer\n    assert(manager.findCustomerByName(\"Charlie\") == nullptr);\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "bool CustomerManager::validateCustomerAge(const Customer& customer) {\n    return customer.getAge() >= 18;\n}\n", "LLM_justification": "This test case demonstrates the ability to translate between C++ code and documentation for a realistic business logic scenario involving customer management. The prefix provides a comprehensive context with class definitions, method declarations, and partial implementations. The golden completion requires the LLM to implement a method based on provided documentation, and the suffix includes assertions to validate the correctness of the implementation. This scenario tests the LLM's ability to interpret and generate code accurately, ensuring that the generated code meets the functional requirements and passes all assertions.", "assertions": ""}
{"id": "50", "testsource": "synthbench-code2NL-NL2code", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n/**\n * @brief Represents a business entity in a workflow system.\n */\nclass Task {\npublic:\n    /**\n     * @brief Constructs a new Task object.\n     * @param id The unique identifier of the task.\n     * @param description A brief description of the task.\n     * @param completed A flag indicating whether the task is completed.\n     */\n    Task(int id, const std::string& description, bool completed)\n        : id(id), description(description), completed(completed) {}\n\n    /**\n     * @brief Marks the task as completed.\n     */\n    void complete() {\n        completed = true;\n    }\n\n    /**\n     * @brief Gets the task description.\n     * @return The description of the task.\n     */\n    std::string getDescription() const {\n        return description;\n    }\n\n    /**\n     * @brief Checks if the task is completed.\n     * @return true if the task is completed, false otherwise.\n     */\n    bool isCompleted() const {\n        return completed;\n    }\n\nprivate:\n    int id; ///< The unique identifier of the task.\n    std::string description; ///< The description of the task.\n    bool completed; ///< The completion status of the task.\n};\n\n/**\n * @brief Manages a collection of tasks in a workflow.\n */\nclass TaskManager {\npublic:\n    /**\n     * @brief Adds a new task to the manager.\n     * @param task The task to add.\n     */\n    void addTask(const Task& task) {\n        tasks.push_back(task);\n    }\n\n    /**\n     * @brief Marks a task as completed based on its description.\n     * @param description The description of the task to complete.\n     */\n    void completeTask(const std::string& description);\n\nprivate:\n    std::vector<Task> tasks; ///< Collection of tasks.\n};\n", "suffix": "int main() {\n    TaskManager manager;\n    Task task1(1, \"Implement feature X\", false);\n    Task task2(2, \"Fix bug Y\", false);\n    manager.addTask(task1);\n    manager.addTask(task2);\n\n    manager.completeTask(\"Implement feature X\");\n\n    assert(task1.isCompleted() == true);\n    assert(task2.isCompleted() == false);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n\nvoid TaskManager::completeTask(const std::string& description) {\n    for (auto& task : tasks) {\n        if (task.getDescription() == description) {\n            task.complete();\n            break;\n        }\n    }\n}", "golden_completion": "/**\n * @brief Marks a task as completed based on its description.\n * @param description The description of the task to complete.\n */\nvoid TaskManager::completeTask(const std::string& description) {\n    for (auto& task : tasks) {\n        if (task.getDescription() == description) {\n            task.complete();\n            break;\n        }\n    }\n}", "LLM_justification": "This test case is a good example because it involves a realistic workflow scenario where tasks need to be managed and completed. The TaskManager class provides a method to complete tasks based on their description, which is a common operation in task management systems. The code-to-comment translation tests the LLM's ability to generate comprehensive documentation for the completeTask method, including parameter descriptions and a brief explanation of its functionality. The assertions verify that the tasks are correctly marked as completed and ensure the method's correctness.", "assertions": ""}
