
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <Eigen/Dense>
#include <iostream>
#include <cassert>

// Define a function to perform matrix multiplication using Eigen
Eigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd& mat1, const Eigen::MatrixXd& mat2) {
    if (mat1.cols() != mat2.rows()) {
        throw std::invalid_argument("Matrix dimensions must agree for multiplication.");
    }
    return mat1 * mat2;
}

// Initialize matrices with random values for testing
Eigen::MatrixXd generateRandomMatrix(int rows, int cols) {
    Eigen::MatrixXd mat = Eigen::MatrixXd::Random(rows, cols);
    return mat;
}

int main() {
    // Generate test matrices
    Eigen::MatrixXd mat1 = generateRandomMatrix(4, 3);
    Eigen::MatrixXd mat2 = generateRandomMatrix(3, 2);

    // Perform matrix multiplication
    Eigen::MatrixXd result;
    try {
        result = multiplyMatrices(mat1, mat2);
    } catch (const std::invalid_argument& e) {
        std::cerr << e.what() << std::endl;
        return -1;
    }

    // Output matrices for verification
    std::cout << "Matrix 1:\n" << mat1 << std::endl;
    std::cout << "Matrix 2:\n" << mat2 << std::endl;
    std::cout << "Resultant Matrix:\n" << result << std::endl;

    // Golden completion placeholder


GOLDEN COMPLETION:
----------------------------------------
    // Verify the correctness of matrix multiplication using a known result
    Eigen::MatrixXd expected = mat1 * mat2;
    assert((result - expected).norm() < 1e-9);


SUFFIX CODE:
----------------------------------------


    // Clean up resources (handled automatically by Eigen)
    std::cout << "Matrix multiplication and verification succeeded." << std::endl;
    return 0;
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a matrix multiplication operation using the Eigen library, which is a less common but highly specialized library for linear algebra in C++. The scenario includes error handling for dimension mismatches, matrix initialization, and verification of results using assertions. This ensures that the model understands the proper usage and validation of uncommon library functions while handling edge cases and maintaining proper parameter ordering.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <openssl/evp.h>

class CryptoHelper {
public:
    CryptoHelper() : ctx(EVP_CIPHER_CTX_new()) {}
    ~CryptoHelper() { if (ctx) EVP_CIPHER_CTX_free(ctx); }

    void init(const unsigned char *key, const unsigned char *iv) {
        EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv);
    }

    int encrypt(const unsigned char *plaintext, int plaintext_len, unsigned char *ciphertext) {
        int len;
        int ciphertext_len;

        if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
            return -1;
        }
        ciphertext_len = len;

        if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {
            return -1;
        }
        ciphertext_len += len;

        return ciphertext_len;
    }

private:
    EVP_CIPHER_CTX *ctx;
};

int main() {
    unsigned char key[32] = {0};
    unsigned char iv[16] = {0};
    unsigned char plaintext[] = "This is a test.";
    unsigned char ciphertext[128];

    CryptoHelper crypto;
    crypto.init(key, iv);
    int ciphertext_len = crypto.encrypt(plaintext, strlen((char *)plaintext), ciphertext);
    assert(ciphertext_len > 0);
    std::cout << "Ciphertext length: " << ciphertext_len << std::endl;

    // Add decryption code here


GOLDEN COMPLETION:
----------------------------------------
    EVP_CIPHER_CTX *ctx_decrypt = EVP_CIPHER_CTX_new();
    EVP_DecryptInit_ex(ctx_decrypt, EVP_aes_256_cbc(), nullptr, key, iv);

    int len;
    int plaintext_len;
    unsigned char decryptedtext[128];

    if(1 != EVP_DecryptUpdate(ctx_decrypt, decryptedtext, &len, ciphertext, ciphertext_len)) {
        EVP_CIPHER_CTX_free(ctx_decrypt);
        return -1;
    }
    plaintext_len = len;

    if(1 != EVP_DecryptFinal_ex(ctx_decrypt, decryptedtext + len, &len)) {
        EVP_CIPHER_CTX_free(ctx_decrypt);
        return -1;
    }
    plaintext_len += len;
    decryptedtext[plaintext_len] = '\0';

    EVP_CIPHER_CTX_free(ctx_decrypt);



SUFFIX CODE:
----------------------------------------


    assert(strcmp((char *)plaintext, (char *)decryptedtext) == 0);
    std::cout << "Decrypted text: " << decryptedtext << std::endl;

    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case is a good example of using the OpenSSL library for encryption and decryption, which involves uncommon API functions such as EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, and EVP_DecryptFinal_ex. It ensures that the LLM can handle complex cryptographic operations, manage resource cleanup, and verify the correctness of the encryption and decryption process using assertions. The prefix establishes the encryption pattern, while the golden completion and suffix focus on the decryption process, ensuring a clear distinction between them.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <harfbuzz/hb.h>
#include <harfbuzz/hb-ft.h>
#include <ft2build.h>
#include FT_FREETYPE_H
#include <cassert>

// Helper function to initialize FreeType library
FT_Library initFreeType() {
    FT_Library ftLibrary;
    if (FT_Init_FreeType(&ftLibrary)) {
        throw std::runtime_error("Failed to initialize FreeType library");
    }
    return ftLibrary;
}

// Helper function to load a font face
FT_Face loadFontFace(FT_Library ftLibrary, const char *fontPath) {
    FT_Face ftFace;
    if (FT_New_Face(ftLibrary, fontPath, 0, &ftFace)) {
        throw std::runtime_error("Failed to load font face");
    }
    return ftFace;
}

// Helper function to create a HarfBuzz buffer
hb_buffer_t* createBuffer(const char *text) {
    hb_buffer_t *buffer = hb_buffer_create();
    hb_buffer_add_utf8(buffer, text, -1, 0, -1);
    hb_buffer_guess_segment_properties(buffer);
    return buffer;
}

// Helper function to create a HarfBuzz font
hb_font_t* createHbFont(FT_Face ftFace) {
    hb_font_t *hbFont = hb_ft_font_create(ftFace, NULL);
    if (!hbFont) {
        throw std::runtime_error("Failed to create HarfBuzz font");
    }
    return hbFont;
}

int main() {
    const char *fontPath = "/path/to/font.ttf";
    const char *text = "Hello, HarfBuzz!";

    FT_Library ftLibrary = initFreeType();
    FT_Face ftFace = loadFontFace(ftLibrary, fontPath);
    hb_buffer_t *buffer = createBuffer(text);
    hb_font_t *hbFont = createHbFont(ftFace);

    // Shape text with HarfBuzz


GOLDEN COMPLETION:
----------------------------------------
    hb_shape(hbFont, buffer, NULL, 0);

    // Retrieve glyph information
    unsigned int glyphCount;
    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);
    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);

    // Assertions to verify the shaping process
    assert(glyphCount > 0);
    assert(glyphInfo != NULL);
    assert(glyphPos != NULL);


SUFFIX CODE:
----------------------------------------


    // Print glyph information
    for (unsigned int i = 0; i < glyphCount; i++) {
        std::cout << "Glyph " << glyphInfo[i].codepoint << " at (" << glyphPos[i].x_offset << ", " << glyphPos[i].y_offset << ") with advance (" << glyphPos[i].x_advance << ", " << glyphPos[i].y_advance << ")\n";
    }

    // Cleanup
    hb_buffer_destroy(buffer);
    hb_font_destroy(hbFont);
    FT_Done_Face(ftFace);
    FT_Done_FreeType(ftLibrary);

    return 0;
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete the usage of the HarfBuzz library for text shaping, which is less common. The prefix includes the setup of FreeType and HarfBuzz, and the golden completion focuses on the shaping process and retrieval of glyph information. The suffix contains assertions to verify the correctness of the shaping process and prints the glyph information. This scenario is comprehensive in testing the model's understanding of text shaping with uncommon libraries.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <vector>
#include <cstdlib>
#include <cassert>
#include <openssl/evp.h>
#include <openssl/rand.h>

// Utility function to initialize OpenSSL library
void init_openssl() {
    OpenSSL_add_all_algorithms();
    ERR_load_crypto_strings();
}

// Utility function to cleanup OpenSSL library
void cleanup_openssl() {
    EVP_cleanup();
    ERR_free_strings();
}

// Function to generate a random key
std::vector<unsigned char> generate_random_key(int length) {
    std::vector<unsigned char> key(length);
    if (!RAND_bytes(key.data(), length)) {
        throw std::runtime_error("Failed to generate random bytes");
    }
    return key;
}

// Function to encrypt data using AES-256-CBC
std::vector<unsigned char> encrypt(const std::vector<unsigned char>& plaintext, const std::vector<unsigned char>& key, const std::vector<unsigned char>& iv) {
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        throw std::runtime_error("Failed to create EVP_CIPHER_CTX");
    }
    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key.data(), iv.data())) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("EVP_EncryptInit_ex failed");
    }
    std::vector<unsigned char> ciphertext(plaintext.size() + EVP_CIPHER_block_size(EVP_aes_256_cbc()));
    int len;
    if (1 != EVP_EncryptUpdate(ctx, ciphertext.data(), &len, plaintext.data(), plaintext.size())) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("EVP_EncryptUpdate failed");
    }
    int ciphertext_len = len;
    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len)) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("EVP_EncryptFinal_ex failed");
    }
    ciphertext_len += len;
    ciphertext.resize(ciphertext_len);
    EVP_CIPHER_CTX_free(ctx);
    return ciphertext;
}

int main() {
    try {
        init_openssl();

        // Test data
        std::vector<unsigned char> plaintext = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};
        std::vector<unsigned char> key = generate_random_key(32);
        std::vector<unsigned char> iv(16, 0);  // Initialization vector


GOLDEN COMPLETION:
----------------------------------------
        std::vector<unsigned char> iv = generate_random_key(16);  // Initialization vector


SUFFIX CODE:
----------------------------------------
        // Encrypt the plaintext
        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);

        // Assertions to verify encryption
        assert(!ciphertext.empty());
        assert(ciphertext.size() > plaintext.size());
        std::cout << "Encryption successful. Ciphertext size: " << ciphertext.size() << std::endl;

        // Cleanup OpenSSL
        cleanup_openssl();
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}


JUSTIFICATION:
----------------------------------------
This test case verifies the LLM's capability to understand and complete a pattern involving the OpenSSL library for cryptographic operations, specifically AES-256-CBC encryption. It checks the model's ability to correctly use less common functions like RAND_bytes for generating random bytes and EVP_EncryptInit_ex, EVP_EncryptUpdate, and EVP_EncryptFinal_ex for encryption. The assertions ensure that the encrypted data is non-empty and larger than the plaintext, validating the encryption process.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <hb.h>
#include <hb-ft.h>
#include <ft2build.h>
#include FT_FREETYPE_H
#include <cassert>

// Helper function to load a font face
FT_Face loadFontFace(FT_Library library, const char* fontFilePath) {
    FT_Face face;
    if (FT_New_Face(library, fontFilePath, 0, &face)) {
        std::cerr << "Failed to load font face." << std::endl;
        exit(EXIT_FAILURE);
    }
    return face;
}

// Helper function to create a HarfBuzz buffer
hb_buffer_t* createHarfBuzzBuffer(const char* text) {
    hb_buffer_t* buffer = hb_buffer_create();
    hb_buffer_add_utf8(buffer, text, -1, 0, -1);
    hb_buffer_guess_segment_properties(buffer);
    return buffer;
}

// Helper function to shape text
void shapeText(hb_font_t* font, hb_buffer_t* buffer) {
    hb_shape(font, buffer, NULL, 0);
}

// Helper function to print shaped text information
void printShapedTextInfo(hb_buffer_t* buffer) {
    unsigned int len = hb_buffer_get_length(buffer);
    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(buffer, NULL);
    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(buffer, NULL);
    for (unsigned int i = 0; i < len; ++i) {
        std::cout << "Glyph ID: " << info[i].codepoint << ", X Offset: " << pos[i].x_offset << ", Y Offset: " << pos[i].y_offset << std::endl;
    }
}

int main() {
    FT_Library ftLibrary;
    if (FT_Init_FreeType(&ftLibrary)) {
        std::cerr << "Failed to initialize FreeType library." << std::endl;
        return EXIT_FAILURE;
    }
    const char* fontFilePath = "path/to/font.ttf";
    FT_Face ftFace = loadFontFace(ftLibrary, fontFilePath);
    hb_font_t* hbFont = hb_ft_font_create(ftFace, NULL);
    const char* text = "Hello, HarfBuzz!";
    hb_buffer_t* hbBuffer = createHarfBuzzBuffer(text);
    shapeText(hbFont, hbBuffer);
    printShapedTextInfo(hbBuffer);
    // Test if the buffer has glyphs and assert the information


GOLDEN COMPLETION:
----------------------------------------

    assert(hb_buffer_get_length(hbBuffer) > 0);


SUFFIX CODE:
----------------------------------------
    // Assertions to verify the shaped text information
    unsigned int len = hb_buffer_get_length(hbBuffer);
    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);
    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(hbBuffer, NULL);
    assert(len > 0);
    for (unsigned int i = 0; i < len; ++i) {
        assert(info[i].codepoint != 0);
        assert(pos[i].x_offset != 0 || pos[i].y_offset != 0);
    }
    // Cleanup resources
    hb_buffer_destroy(hbBuffer);
    hb_font_destroy(hbFont);
    FT_Done_Face(ftFace);
    FT_Done_FreeType(ftLibrary);
    return 0;
}

JUSTIFICATION:
----------------------------------------
This example tests the use of the HarfBuzz library for text shaping, specifically focusing on functions that are less commonly used such as hb_buffer_add_utf8 and hb_shape. The test case verifies if the buffer has glyphs and ensures that the shaped text information is valid. This scenario helps evaluate the LLM's ability to recognize and correctly use rare functions from the HarfBuzz API, handle resource initialization and cleanup, and make assertions on the processed data.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <string>
#include <hb.h>
#include <hb-ft.h>
#include <ft2build.h>
#include FT_FREETYPE_H
#include <cassert>

// This example demonstrates the use of HarfBuzz and FreeType to shape text.
// HarfBuzz is a text shaping library, while FreeType is a font rendering library.

// Initialize FreeType and HarfBuzz
FT_Library ft_library;
FT_Face ft_face;
hb_buffer_t *hb_buffer;
hb_font_t *hb_font;

void initialize() {
    // Initialize FreeType library
    if (FT_Init_FreeType(&ft_library)) {
        std::cerr << "Could not initialize FreeType library" << std::endl;
        exit(1);
    }

    // Load a font
    if (FT_New_Face(ft_library, "path/to/font.ttf", 0, &ft_face)) {
        std::cerr << "Could not open font" << std::endl;
        exit(1);
    }

    // Set the font size
    FT_Set_Pixel_Sizes(ft_face, 0, 16);

    // Initialize HarfBuzz buffer
    hb_buffer = hb_buffer_create();

    // Create HarfBuzz font
    hb_font = hb_ft_font_create(ft_face, NULL);
}

void cleanup() {
    // Cleanup HarfBuzz objects
    hb_font_destroy(hb_font);
    hb_buffer_destroy(hb_buffer);

    // Cleanup FreeType objects
    FT_Done_Face(ft_face);
    FT_Done_FreeType(ft_library);
}

int main() {
    initialize();

    // Set text to be shaped
    const char *text = "Hello, HarfBuzz!";
    hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);

    // Set script, language, and direction
    hb_buffer_set_script(hb_buffer, HB_SCRIPT_LATIN);
    hb_buffer_set_language(hb_buffer, hb_language_from_string("en", -1));
    hb_buffer_set_direction(hb_buffer, HB_DIRECTION_LTR);

    // Shape the text


GOLDEN COMPLETION:
----------------------------------------
    hb_shape(hb_font, hb_buffer, NULL, 0);

SUFFIX CODE:
----------------------------------------


    // Get glyph information and positions
    unsigned int glyph_count;
    hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buffer, &glyph_count);
    hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions(hb_buffer, &glyph_count);

    // Assertions to verify correct shaping
    assert(glyph_count == 14);
    for (unsigned int i = 0; i < glyph_count; ++i) {
        assert(glyph_info[i].codepoint != 0);
    }

    // Print glyph information and positions
    for (unsigned int i = 0; i < glyph_count; ++i) {
        std::cout << "Glyph " << i << ": codepoint=" << glyph_info[i].codepoint
                  << ", x_advance=" << glyph_pos[i].x_advance
                  << ", y_advance=" << glyph_pos[i].y_advance
                  << ", x_offset=" << glyph_pos[i].x_offset
                  << ", y_offset=" << glyph_pos[i].y_offset << std::endl;
    }

    cleanup();
    return 0;
}

JUSTIFICATION:
----------------------------------------
This example demonstrates the use of HarfBuzz and FreeType, which are less common libraries for text and font processing. The prefix sets up the FreeType and HarfBuzz libraries and initializes the necessary objects. The golden completion involves shaping the text with HarfBuzz, which is a critical step in using this API. The suffix includes assertions to verify the correct behavior of the shaping process and prints the glyph information and positions. This scenario tests the LLM's ability to correctly use the HarfBuzz shaping function and handle the less common API usage patterns.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

// A simple function to initialize an Eigen matrix with given values
void initializeMatrix(Eigen::MatrixXd &matrix) {
    matrix(0, 0) = 1.0;
    matrix(1, 0) = 2.0;
    matrix(0, 1) = 3.0;
    matrix(1, 1) = 4.0;
}

// A function to compute the inverse of a 2x2 matrix using Eigen library
Eigen::MatrixXd computeInverse(const Eigen::MatrixXd &matrix) {
    assert(matrix.rows() == 2 && matrix.cols() == 2);
    return matrix.inverse();
}

// Another function to multiply two matrices
Eigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd &matrix1, const Eigen::MatrixXd &matrix2) {
    return matrix1 * matrix2;
}

// A function to add two matrices
Eigen::MatrixXd addMatrices(const Eigen::MatrixXd &matrix1, const Eigen::MatrixXd &matrix2) {
    return matrix1 + matrix2;
}

int main() {
    // Initialize a 2x2 matrix
    Eigen::MatrixXd matrix(2, 2);
    initializeMatrix(matrix);

    // Compute the inverse of the matrix
    Eigen::MatrixXd inverseMatrix = computeInverse(matrix);

    // Print the original and inverse matrices
    std::cout << "Original Matrix:\n" << matrix << std::endl;
    std::cout << "Inverse Matrix:\n" << inverseMatrix << std::endl;

    // Example of multiplying matrices
    Eigen::MatrixXd result = multiplyMatrices(matrix, inverseMatrix);
    std::cout << "Result of multiplication (should be identity matrix):\n" << result << std::endl;

    // Example of adding matrices
    Eigen::MatrixXd sumMatrix = addMatrices(matrix, inverseMatrix);
    std::cout << "Result of addition:\n" << sumMatrix << std::endl;

    // Example of using a less common function from Eigen library
    // Compute the determinant of the matrix using Eigen's determinant() function


GOLDEN COMPLETION:
----------------------------------------

    double determinant = matrix.determinant();
    std::cout << "Determinant of the matrix: " << determinant << std::endl;



SUFFIX CODE:
----------------------------------------


    // Assertions to verify correctness
    assert(determinant == -2.0);

    // Compute the transpose of the matrix
    Eigen::MatrixXd transposeMatrix = matrix.transpose();
    std::cout << "Transpose of the matrix:\n" << transposeMatrix << std::endl;

    // Assertions to verify correctness
    assert(transposeMatrix(0, 0) == matrix(0, 0));
    assert(transposeMatrix(1, 0) == matrix(0, 1));
    assert(transposeMatrix(0, 1) == matrix(1, 0));
    assert(transposeMatrix(1, 1) == matrix(1, 1));

    return 0;
}

JUSTIFICATION:
----------------------------------------
This example focuses on the Eigen library, which is widely used for linear algebra operations but includes some less commonly used functions such as matrix determinant and transpose calculations. The code tests the LLM's understanding of these specific functions, their usage patterns, and correct parameter handling. The prefix sets up various matrix operations, while the golden completion demonstrates the correct usage of Eigen's determinant() and transpose() functions. Assertions are included in the suffix to verify the correctness of the operations and ensure the model correctly implements these uncommon but important functions in the Eigen library.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

// Helper function to initialize matrices
void initializeMatrices(Eigen::MatrixXd& A, Eigen::MatrixXd& B) {
    A << 1, 2, 3, 4,
         5, 6, 7, 8,
         9, 10, 11, 12;
    B << 12, 11, 10, 9,
         8, 7, 6, 5,
         4, 3, 2, 1;
}

// Function to perform matrix multiplication and return the result
Eigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd& A, const Eigen::MatrixXd& B) {
    assert(A.cols() == B.rows() && "Matrix dimensions must be compatible for multiplication.");
    return A * B;
}

// Function to print a matrix
void printMatrix(const Eigen::MatrixXd& matrix) {
    std::cout << matrix << std::endl;
}

// Main function
int main() {
    Eigen::MatrixXd A(3, 4);
    Eigen::MatrixXd B(4, 3);
    initializeMatrices(A, B);
    // Perform uncommon operation: matrix transpose and addition


GOLDEN COMPLETION:
----------------------------------------

    Eigen::MatrixXd D = A.transpose() + B;
    printMatrix(D);

    // Assertions
    Eigen::MatrixXd expectedD(4, 3);
    expectedD << 13, 16, 19,
                 17, 20, 23,
                 21, 24, 27,
                 25, 28, 31;
    assert(D.isApprox(expectedD) && "Matrix transpose and addition result is incorrect.");


SUFFIX CODE:
----------------------------------------
    Eigen::MatrixXd C = multiplyMatrices(A, B);
    printMatrix(C);

    // Assertions
    Eigen::MatrixXd expectedC(3, 3);
    expectedC << 80, 70, 60,
                 224, 198, 172,
                 368, 326, 284;
    assert(C.isApprox(expectedC) && "Matrix multiplication result is incorrect.");

    // Clean up resources (not needed for Eigen objects as they are automatically managed)
    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the Eigen library for matrix operations, including an uncommon combination of matrix transpose and addition. The prefix sets up the matrices and provides utility functions for initialization, multiplication, and printing. The completion involves performing a less common operation (matrix transpose and addition) and then validating the result with assertions. This scenario tests the model's ability to recognize and correctly use Eigen's API for advanced matrix operations while ensuring that the results are accurate through assertions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <openssl/evp.h>

// Utility function to initialize OpenSSL library
void initializeOpenSSL() {
    OpenSSL_add_all_algorithms();
    ERR_load_crypto_strings();
}

// Utility function to cleanup OpenSSL library
void cleanupOpenSSL() {
    EVP_cleanup();
    ERR_free_strings();
}

// Function to encrypt a message using OpenSSL
bool encryptMessage(const std::string& plaintext, std::string& ciphertext, const std::string& key) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        return false;
    }

    const EVP_CIPHER *cipher = EVP_aes_256_cbc();
    if (!EVP_EncryptInit_ex(ctx, cipher, nullptr, reinterpret_cast<const unsigned char*>(key.c_str()), nullptr)) {
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }

    int len;
    int ciphertext_len;
    unsigned char ciphertext_buf[1024];

    if (!EVP_EncryptUpdate(ctx, ciphertext_buf, &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.length())) {
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }
    ciphertext_len = len;

    if (!EVP_EncryptFinal_ex(ctx, ciphertext_buf + len, &len)) {
        EVP_CIPHER_CTX_free(ctx);
        return false;
    }
    ciphertext_len += len;

    ciphertext.assign(reinterpret_cast<const char*>(ciphertext_buf), ciphertext_len);
    EVP_CIPHER_CTX_free(ctx);
    return true;
}

int main() {
    initializeOpenSSL();
    std::string plaintext = "This is a secret message.";
    std::string key = "01234567890123456789012345678901"; // 256-bit key
    std::string ciphertext;

GOLDEN COMPLETION:
----------------------------------------

    bool result = encryptMessage(plaintext, ciphertext, key);
    assert(result);
    assert(!ciphertext.empty());

SUFFIX CODE:
----------------------------------------


    // Decryption code for validation
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    assert(ctx != nullptr);

    const EVP_CIPHER *cipher = EVP_aes_256_cbc();
    assert(EVP_DecryptInit_ex(ctx, cipher, nullptr, reinterpret_cast<const unsigned char*>(key.c_str()), nullptr));

    int len;
    int plaintext_len;
    unsigned char plaintext_buf[1024];

    assert(EVP_DecryptUpdate(ctx, plaintext_buf, &len, reinterpret_cast<const unsigned char*>(ciphertext.c_str()), ciphertext.length()));
    plaintext_len = len;

    assert(EVP_DecryptFinal_ex(ctx, plaintext_buf + len, &len));
    plaintext_len += len;

    std::string decrypted_plaintext(reinterpret_cast<const char*>(plaintext_buf), plaintext_len);
    assert(decrypted_plaintext == plaintext);

    EVP_CIPHER_CTX_free(ctx);
    cleanupOpenSSL();

    std::cout << "Encryption and decryption successful." << std::endl;
    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the OpenSSL EVP (Envelope) API for encryption and decryption of data. The EVP API is a high-level interface to cryptographic functions, which is not commonly used due to its complexity and the need for proper resource management. The example includes the initialization and cleanup of the OpenSSL library, encryption of a message, and validation through decryption. The assertions verify that the encryption was successful, the ciphertext is not empty, and the decrypted text matches the original plaintext. Proper parameter ordering and resource management are crucial for the correct usage of the API.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <vector>
#include <Eigen/Dense>
#include <cassert>

// This example demonstrates the use of Eigen library for linear algebra
// operations. Eigen is a C++ template library for linear algebra: matrices,
// vectors, numerical solvers, and related algorithms.

using namespace Eigen;

// Function to initialize a matrix with some values
MatrixXd initializeMatrix(int rows, int cols) {
    MatrixXd mat(rows, cols);
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            mat(i, j) = i + j;
        }
    }
    return mat;
}

// Function to perform matrix multiplication using Eigen
MatrixXd multiplyMatrices(const MatrixXd& mat1, const MatrixXd& mat2) {
    assert(mat1.cols() == mat2.rows());
    return mat1 * mat2;
}

// Function to perform matrix addition using Eigen
MatrixXd addMatrices(const MatrixXd& mat1, const MatrixXd& mat2) {
    assert(mat1.rows() == mat2.rows() && mat1.cols() == mat2.cols());
    return mat1 + mat2;
}

int main() {
    // Initialize two matrices
    MatrixXd mat1 = initializeMatrix(3, 3);
    MatrixXd mat2 = initializeMatrix(3, 3);

    // Perform matrix multiplication and addition
    MatrixXd resultMul = multiplyMatrices(mat1, mat2);
    MatrixXd resultAdd = addMatrices(mat1, mat2);

    // Print the results
    std::cout << "Matrix Multiplication Result:\n" << resultMul << std::endl;
    std::cout << "Matrix Addition Result:\n" << resultAdd << std::endl;

    // Now, let's test a rare and uncommon function of Eigen: matrix decomposition


GOLDEN COMPLETION:
----------------------------------------
    // Perform LU decomposition
    FullPivLU<MatrixXd> luDecomp(mat1);
    MatrixXd L = luDecomp.matrixLU().triangularView<Lower>();
    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();



SUFFIX CODE:
----------------------------------------


    // Validate the decomposition: A = L * U
    MatrixXd reconstructed = L * U;
    assert((reconstructed - mat1).norm() < 1e-9);

    // Print the L and U matrices
    std::cout << "L matrix:\n" << L << std::endl;
    std::cout << "U matrix:\n" << U << std::endl;

    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case is a good example as it tests the model's ability to recognize and complete a rare API usage pattern involving Eigen library's LU decomposition functions. LU decomposition is not commonly used compared to basic operations like matrix multiplication and addition, and it requires a correct understanding of matrix properties and Eigen's API conventions. The completion demonstrates proper API usage, parameter ordering, and error checking using assertions to validate the correctness of the decomposition.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <harfbuzz/hb.h>
#include <harfbuzz/hb-ft.h>
#include <ft2build.h>
#include FT_FREETYPE_H

void initialize_harfuzz(hb_buffer_t** buffer, hb_font_t** font) {
    FT_Library ft_library;
    FT_Face ft_face;
    hb_blob_t* blob;

    FT_Init_FreeType(&ft_library);
    FT_New_Face(ft_library, "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 0, &ft_face);
    FT_Set_Char_Size(ft_face, 0, 16 * 64, 0, 0);

    *buffer = hb_buffer_create();
    hb_buffer_set_direction(*buffer, HB_DIRECTION_LTR);
    hb_buffer_set_script(*buffer, HB_SCRIPT_LATIN);
    hb_buffer_set_language(*buffer, hb_language_from_string("en", -1));

    blob = hb_blob_create_from_file("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf");
    *font = hb_ft_font_create(ft_face, nullptr);

    hb_buffer_add_utf8(*buffer, "Hello, HarfBuzz!", -1, 0, -1);

    hb_shape(*font, *buffer, nullptr, 0);

    hb_blob_destroy(blob);
    FT_Done_Face(ft_face);
    FT_Done_FreeType(ft_library);
}

void print_glyph_info(hb_buffer_t* buffer) {
    unsigned int glyph_count;
    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);

    for (unsigned int i = 0; i < glyph_count; i++) {
        std::cout << "Glyph ID: " << glyph_info[i].codepoint << std::endl;
    }
}

int main() {
    hb_buffer_t* buffer = nullptr;
    hb_font_t* font = nullptr;
    initialize_harfuzz(&buffer, &font);


GOLDEN COMPLETION:
----------------------------------------
    print_glyph_info(buffer);


SUFFIX CODE:
----------------------------------------
    unsigned int glyph_count;
    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);

    assert(glyph_count > 0);
    assert(glyph_info != nullptr);

    hb_buffer_destroy(buffer);
    hb_font_destroy(font);

    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case involves using the HarfBuzz library for text shaping, which is a complex and less commonly used library in C++. The example sets up a FreeType font and uses HarfBuzz to shape a simple string, then verifies the glyph information. This scenario tests the LLM's ability to understand and correctly use the HarfBuzz API, including creating buffers, setting directions, scripts, languages, and shaping text. The correct usage of these APIs and proper resource management are critical, making this a good test case for uncommon API usage.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

// This program demonstrates the use of Eigen library for scientific computing
// We will define a helper function to initialize matrices and perform some operations.

using namespace Eigen;

void initialize_matrices(MatrixXd &matA, MatrixXd &matB) {
	// Initialize matrix A (3x3)
	matA << 1, 2, 3,
			 4, 5, 6,
			 7, 8, 9;
	// Initialize matrix B (3x3)
	matB << 9, 8, 7,
			 6, 5, 4,
			 3, 2, 1;
}

MatrixXd perform_operations(const MatrixXd &matA, const MatrixXd &matB) {
	MatrixXd result;
	// Perform matrix addition
	result = matA + matB;
	return result;
}

int main() {
	MatrixXd matA(3, 3);
	MatrixXd matB(3, 3);
	initialize_matrices(matA, matB);
	MatrixXd result = perform_operations(matA, matB);
	std::cout << "Result of matrix addition:\n" << result << std::endl;

	// Additional operations will be performed below


GOLDEN COMPLETION:
----------------------------------------
	MatrixXd matC(3, 3);
	matC << 2, 3, 4,
			 5, 6, 7,
			 8, 9, 10;



SUFFIX CODE:
----------------------------------------


	// Perform matrix multiplication
	MatrixXd result_mult = matA * matC;
	std::cout << "Result of matrix multiplication:\n" << result_mult << std::endl;

	// Assertions
	assert(result_mult(0, 0) == 36);
	assert(result_mult(1, 1) == 81);
	assert(result_mult(2, 2) == 126);

	return 0;
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the Eigen library, which is less commonly used compared to standard libraries. The focus is on matrix initialization and operations such as addition and multiplication. The test case ensures the LLM can recognize and correctly complete patterns involving Eigen's matrix operations. Assertions verify the correctness of matrix multiplication results, checking specific elements in the resulting matrix. This is a good test case because it involves scientific computing with clear and uncommon API usage, making it a suitable benchmark for testing LLM capabilities in recognizing and completing advanced C++ code patterns.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <freetype2/ft2build.h>
#include FT_FREETYPE_H

class FontRenderer {
public:
    FontRenderer() : library(nullptr), face(nullptr) {}

    bool initialize() {
        FT_Error error = FT_Init_FreeType(&library);
        if (error) {
            std::cerr << "Failed to initialize FreeType library." << std::endl;
            return false;
        }
        return true;
    }

    bool loadFont(const char* filePath) {
        FT_Error error = FT_New_Face(library, filePath, 0, &face);
        if (error) {
            std::cerr << "Failed to load font." << std::endl;
            return false;
        }
        return true;
    }

    void setFontSize(int pixelWidth, int pixelHeight) {
        FT_Set_Pixel_Sizes(face, pixelWidth, pixelHeight);
    }

    FT_GlyphSlot renderGlyph(char character) {
        FT_UInt glyphIndex = FT_Get_Char_Index(face, character);
        FT_Error error = FT_Load_Glyph(face, glyphIndex, FT_LOAD_DEFAULT);
        if (error) {
            std::cerr << "Failed to load glyph." << std::endl;
            return nullptr;
        }
        error = FT_Render_Glyph(face->glyph, FT_RENDER_MODE_NORMAL);
        if (error) {
            std::cerr << "Failed to render glyph." << std::endl;
            return nullptr;
        }
        return face->glyph;
    }

    ~FontRenderer() {
        if (face) {
            FT_Done_Face(face);
        }
        if (library) {
            FT_Done_FreeType(library);
        }
    }

private:
    FT_Library library;
    FT_Face face;
};

int main() {
    FontRenderer renderer;
    assert(renderer.initialize() && "FreeType library initialization failed.");
    assert(renderer.loadFont("/path/to/font.ttf") && "Font loading failed.");
    renderer.setFontSize(12, 12);


GOLDEN COMPLETION:
----------------------------------------
    FT_GlyphSlot glyph = renderer.renderGlyph('A');
    assert(glyph != nullptr && "Glyph rendering failed.");
    assert(glyph->bitmap.width > 0 && glyph->bitmap.rows > 0 && "Rendered glyph has invalid dimensions.");

SUFFIX CODE:
----------------------------------------

    std::cout << "Glyph rendered successfully." << std::endl;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This example uses the FreeType library, which is commonly used for font rendering but involves a somewhat complex API. The example tests the ability to correctly initialize the FreeType library, load a font, set the font size, and render a glyph. The golden completion focuses on rendering a specific glyph and includes assertions to ensure the glyph is rendered correctly. The suffix includes additional code to verify the rendered glyph and cleanup resources. This scenario is a good test case because it involves several steps that must be done in a specific order, and the API functions used are not commonly seen in more basic text processing examples.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <hb.h>
#include <hb-ft.h>
#include <cassert>
#include <ft2build.h>
#include FT_FREETYPE_H

class HarfBuzzExample {
public:
    HarfBuzzExample() : ft_library(nullptr), ft_face(nullptr), hb_buffer(nullptr), hb_font(nullptr) {}
    ~HarfBuzzExample() { cleanup(); }

    void initialize() {
        // Initialize FreeType library
        if (FT_Init_FreeType(&ft_library)) {
            throw std::runtime_error("Could not initialize FreeType library");
        }

        // Load a font face
        if (FT_New_Face(ft_library, "arial.ttf", 0, &ft_face)) {
            throw std::runtime_error("Could not load font face");
        }

        // Create a HarfBuzz buffer
        hb_buffer = hb_buffer_create();
        if (!hb_buffer) {
            throw std::runtime_error("Could not create HarfBuzz buffer");
        }

        // Create a HarfBuzz font
        hb_font = hb_ft_font_create(ft_face, nullptr);
        if (!hb_font) {
            throw std::runtime_error("Could not create HarfBuzz font");
        }
    }

    void shapeText(const char* text) {
        // Set the text to shape
        hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);
        hb_buffer_guess_segment_properties(hb_buffer);
    }

    void cleanup() {
        if (hb_font) {
            hb_font_destroy(hb_font);
            hb_font = nullptr;
        }
        if (hb_buffer) {
            hb_buffer_destroy(hb_buffer);
            hb_buffer = nullptr;
        }
        if (ft_face) {
            FT_Done_Face(ft_face);
            ft_face = nullptr;
        }
        if (ft_library) {
            FT_Done_FreeType(ft_library);
            ft_library = nullptr;
        }
    }

    hb_buffer_t* getBuffer() const { return hb_buffer; }

private:
    FT_Library ft_library;
    FT_Face ft_face;
    hb_buffer_t* hb_buffer;
    hb_font_t* hb_font;
};

int main() {
    HarfBuzzExample example;
    example.initialize();
    example.shapeText("Hello, world!");


GOLDEN COMPLETION:
----------------------------------------
    hb_shape(example.getBuffer(), example.getFont(), nullptr, 0);


SUFFIX CODE:
----------------------------------------
    hb_buffer_t* buffer = example.getBuffer();
    unsigned int glyph_count;
    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);
    hb_glyph_position_t* glyph_pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);

    // Assertions to verify the shaping results
    assert(glyph_count > 0);
    for (unsigned int i = 0; i < glyph_count; ++i) {
        assert(glyph_info[i].codepoint != 0);
        assert(glyph_pos[i].x_advance != 0 || glyph_pos[i].y_advance != 0);
    }

    // Cleanup and exit
    example.cleanup();
    std::cout << "All assertions passed." << std::endl;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case uses the HarfBuzz library to demonstrate text shaping with FreeType fonts, which is a less common but powerful API for text processing. The example includes initialization, text shaping, and cleanup, ensuring proper resource management. The golden completion involves the `hb_shape` function, which is crucial for text shaping but less commonly known. The suffix includes assertions to verify the behavior of the `hb_shape` function, ensuring the glyph information and positions are correctly populated. This scenario tests the model's ability to recognize and complete uncommon API usage patterns, manage resources, and verify API behavior through assertions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <cstdio>
#include <cstring>

// Utility functions to handle deprecated APIs
void deprecated_fopen_example(const char* filename, const char* mode) {
    FILE* file = fopen(filename, mode);
    if (file) {
        std::cout << "File opened successfully" << std::endl;
        fclose(file);
    } else {
        std::cerr << "Failed to open file" << std::endl;
    }
}

class LegacyFileHandler {
public:
    LegacyFileHandler(const char* filename, const char* mode) {
        file_ = fopen(filename, mode);
        if (!file_) {
            throw std::runtime_error("Failed to open file");
        }
    }

    ~LegacyFileHandler() {
        if (file_) {
            fclose(file_);
        }
    }

    void write(const char* data) {
        if (file_) {
            fwrite(data, sizeof(char), strlen(data), file_);
        }
    }

    void read(char* buffer, size_t size) {
        if (file_) {
            fread(buffer, sizeof(char), size, file_);
        }
    }

private:
    FILE* file_;
};

int main() {
    const char* filename = "test.txt";
    const char* write_data = "Hello, World!";
    char read_buffer[50] = {0};
    try {


GOLDEN COMPLETION:
----------------------------------------
        LegacyFileHandler handler(filename, "w+");
        handler.write(write_data);
        handler.read(read_buffer, sizeof(read_buffer));
        assert(strcmp(read_buffer, write_data) == 0);


SUFFIX CODE:
----------------------------------------
    } catch (const std::exception& ex) {
        std::cerr << "Exception: " << ex.what() << std::endl;
        return 1;
    }

    // Assertions to verify correct behavior
    FILE* file = fopen(filename, "r");
    assert(file != nullptr);
    fread(read_buffer, sizeof(char), strlen(write_data), file);
    assert(strcmp(read_buffer, write_data) == 0);
    fclose(file);

    std::cout << "All assertions passed!" << std::endl;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves deprecated file handling APIs (`fopen`, `fwrite`, `fread`, `fclose`) and demonstrates how to correctly use these APIs within the context of a C++ class. The completion requires the model to recognize the pattern of file operations and use the correct sequence of function calls, parameter ordering, and error handling. The assertions verify that the file operations were performed correctly, ensuring the integrity of the data written and read from the file. This tests the model's ability to understand and complete deprecated API usage patterns, which are still relevant in maintaining legacy codebases.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

/*
 * This example demonstrates the usage of the Eigen library, specifically dealing with SVD (Singular Value Decomposition) and solving systems of linear equations.
 * Eigen is a C++ template library for linear algebra.
 */

void printMatrix(const Eigen::MatrixXd &matrix) {
    for (int i = 0; i < matrix.rows(); ++i) {
        for (int j = 0; j < matrix.cols(); ++j) {
            std::cout << matrix(i, j) << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    // Define a 3x3 matrix
    Eigen::MatrixXd A(3, 3);
    A << 1, 2, 3,
         4, 5, 6,
         7, 8, 9;

    // Define a 3x1 vector
    Eigen::VectorXd b(3);
    b << 1,
         0,
         1;

    // Print matrix A
    std::cout << "Matrix A:" << std::endl;
    printMatrix(A);

    // Print vector b
    std::cout << "Vector b:" << std::endl;
    for (int i = 0; i < b.size(); ++i) {
        std::cout << b(i) << std::endl;
    }

    // Compute the SVD of matrix A
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(A, Eigen::ComputeThinU | Eigen::ComputeThinV);
    std::cout << "Singular values of A:" << std::endl;
    std::cout << svd.singularValues() << std::endl;

    // The SVD solves the system Ax = b
    Eigen::VectorXd x;


GOLDEN COMPLETION:
----------------------------------------
    x = svd.solve(b);


SUFFIX CODE:
----------------------------------------

    std::cout << "Solution x:" << std::endl;
    for (int i = 0; i < x.size(); ++i) {
        std::cout << x(i) << std::endl;
    }

    // Assertions to ensure correctness
    Eigen::VectorXd b_reconstructed = A * x;
    assert((b - b_reconstructed).norm() < 1e-6);
    assert(svd.rank() == 2);
    assert(svd.singularValues()(0) > svd.singularValues()(1));

    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the Eigen library for linear algebra, specifically focusing on Singular Value Decomposition (SVD) and solving a system of linear equations. The example sets up a matrix and a vector, computes the SVD, and solves the system. Assertions are included to verify the correctness of the solution, ensuring that the reconstructed vector matches the original vector, the rank is correctly identified, and the singular values are in descending order. This tests the model's ability to handle a less commonly used library (Eigen) and correctly utilize its API for advanced mathematical operations.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <stdexcept>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <cassert>

class AESCipher {
public:
    AESCipher() : ctx(EVP_CIPHER_CTX_new()) {
        if (!ctx) {
            throw std::runtime_error("Failed to create EVP_CIPHER_CTX");
        }
    }

    ~AESCipher() {
        EVP_CIPHER_CTX_free(ctx);
    }

    void encrypt(const unsigned char *plaintext, int plaintext_len, const unsigned char *key, const unsigned char *iv, unsigned char *ciphertext) {
        int len;
        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv)) {
            throw std::runtime_error("Failed to initialize encryption");
        }
        if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
            throw std::runtime_error("Failed to encrypt data");
        }
        ciphertext_len = len;
    }

    int get_ciphertext_len() const {
        return ciphertext_len;
    }

private:
    EVP_CIPHER_CTX *ctx;
    int ciphertext_len;
};

int main() {
    AESCipher cipher;
    unsigned char key[32];
    unsigned char iv[16];
    unsigned char plaintext[] = "This is a test.";
    unsigned char ciphertext[128];

    if (!RAND_bytes(key, sizeof(key)) || !RAND_bytes(iv, sizeof(iv))) {
        std::cerr << "Failed to generate key/iv" << std::endl;
        return 1;
    }

    try {


GOLDEN COMPLETION:
----------------------------------------
        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);


SUFFIX CODE:
----------------------------------------

        int len;
        if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {
            throw std::runtime_error("Failed to finalize encryption");
        }
        ciphertext_len += len;

        // Verify the length of the ciphertext
        assert(cipher.get_ciphertext_len() > 0);
        std::cout << "Ciphertext length: " << cipher.get_ciphertext_len() << std::endl;
    } catch (const std::exception &e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }

    return 0;
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern involving the OpenSSL EVP encryption API, which is uncommon and complex. The golden completion properly integrates the AES encryption process using the OpenSSL library. The prefix sets up the context with key and IV generation, and the suffix includes the finalization of encryption and assertions to verify the ciphertext length. This scenario effectively tests the LLM's understanding of correct parameter ordering, error handling, and resource management within the OpenSSL API.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <string>
#include <cassert>
#include <unicode/unistr.h>
#include <unicode/ustream.h>
#include <unicode/ucnv.h>

// Utility function to convert UTF-8 string to ICU UnicodeString
UnicodeString utf8ToUnicodeString(const std::string& utf8) {
    UnicodeString ustr;
    ustr = UnicodeString::fromUTF8(StringPiece(utf8.c_str()));
    return ustr;
}

// Utility function to convert ICU UnicodeString to UTF-8 string
std::string unicodeStringToUtf8(const UnicodeString& ustr) {
    std::string utf8;
    ustr.toUTF8String(utf8);
    return utf8;
}

int main() {
    std::string utf8Text = "Hello, world!";
    UnicodeString unicodeText = utf8ToUnicodeString(utf8Text);

    // Pre-completion code
    // Here we should convert the unicodeText to UTF-16 using ICU library



GOLDEN COMPLETION:
----------------------------------------
    std::string utf16Text;
    UErrorCode status = U_ZERO_ERROR;
    int32_t utf16Length = unicodeText.extract(0, unicodeText.length(), (UChar*)nullptr, 0, status);
    std::u16string utf16Str(utf16Length, 0);
    unicodeText.extract(0, unicodeText.length(), reinterpret_cast<UChar*>(&utf16Str[0]), utf16Length, status);
    utf16Text.assign(utf16Str.begin(), utf16Str.end());


SUFFIX CODE:
----------------------------------------

    // Assertions to validate the conversion
    assert(unicodeText.length() == 13);
    assert(unicodeStringToUtf8(unicodeText) == utf8Text);

    // Clean up resources
    // No explicit cleanup needed for ICU UnicodeString
    std::cout << "All assertions passed!" << std::endl;
    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the ICU library for converting between UTF-8 and UTF-16 encodings, which is a less common API usage. The prefix sets up the context with utility functions and initial conversion from UTF-8 to UnicodeString. The golden completion performs the conversion from UnicodeString to UTF-16 string using ICU functions, handling the UErrorCode appropriately. The suffix contains assertions to verify the conversion and ensures that all resources are cleaned up properly. This scenario tests the LLM's ability to recognize and correctly use rare APIs, handle character encoding conversions, and maintain proper resource management.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <openssl/evp.h>
#include <openssl/err.h>

void handleErrors() {
    ERR_print_errors_fp(stderr);
    abort();
}

int main() {
    // Initialize OpenSSL
    ERR_load_crypto_strings();
    OpenSSL_add_all_algorithms();
    OPENSSL_config(NULL);

    // Input data to be hashed
    const char *message = "The quick brown fox jumps over the lazy dog";
    unsigned char md_value[EVP_MAX_MD_SIZE];
    unsigned int md_len;

    // Create a message digest context
    EVP_MD_CTX *mdctx;
    mdctx = EVP_MD_CTX_new();
    if(mdctx == NULL) handleErrors();

    // Initialize the context for MD5
    if(1 != EVP_DigestInit_ex(mdctx, EVP_md5(), NULL)) handleErrors();

    // Provide the message to be hashed
    if(1 != EVP_DigestUpdate(mdctx, message, strlen(message))) handleErrors();


GOLDEN COMPLETION:
----------------------------------------
    // Finalize the digest
    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();

SUFFIX CODE:
----------------------------------------


    // Verify the length of the hash
    assert(md_len == 16); // MD5 hash length is always 16 bytes

    // Clean up
    EVP_MD_CTX_free(mdctx);
    EVP_cleanup();
    ERR_free_strings();

    std::cout << "Hash computed successfully." << std::endl;

    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the OpenSSL EVP API to compute an MD5 hash, which is a less common and somewhat deprecated practice due to security concerns. The test involves initializing the digest context, updating it with data, and finalizing the hash computation. The completion is required to finalize the digest correctly, ensuring proper API usage. The suffix then includes assertions to verify the correct length of the MD5 hash and handles resource cleanup. This scenario tests the LLM's ability to recognize and complete the uncommon API pattern correctly and manage resources properly.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <GL/glew.h>
#include <GLFW/glfw3.h>

class OpenGLContext {
public:
	OpenGLContext(int width, int height) : width(width), height(height) {
		if (!glfwInit()) {
			throw std::runtime_error("Failed to initialize GLFW");
		}
		window = glfwCreateWindow(width, height, "OpenGL Window", nullptr, nullptr);
		if (!window) {
			glfwTerminate();
			throw std::runtime_error("Failed to create GLFW window");
		}
		glfwMakeContextCurrent(window);
		if (glewInit() != GLEW_OK) {
			throw std::runtime_error("Failed to initialize GLEW");
		}
	}

	~OpenGLContext() {
		if (window) {
			glfwDestroyWindow(window);
			window = nullptr;
		}
		glfwTerminate();
	}

	void render() {
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		// render something
		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	bool shouldClose() const {
		return glfwWindowShouldClose(window);
	}

private:
	GLFWwindow* window;
	int width, height;
};

int main() {
	try {
		OpenGLContext context(800, 600);
		while (!context.shouldClose()) {
			context.render();

			

GOLDEN COMPLETION:
----------------------------------------
            glDisable(GL_DEPTH_TEST);
			assert(!glIsEnabled(GL_DEPTH_TEST));



SUFFIX CODE:
----------------------------------------
            glEnable(GL_BLEND);
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

			assert(glIsEnabled(GL_BLEND));
		}
	} catch (const std::exception& e) {
		std::cerr << e.what() << std::endl;
		return -1;
	}
	return 0;
}

JUSTIFICATION:
----------------------------------------
This example tests the ability to recognize and correctly use uncommon OpenGL functions. It involves enabling and disabling specific OpenGL capabilities, which are less commonly used but still important. The test verifies that the model can correctly handle OpenGL state changes and validate them with assertions, ensuring proper API usage.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <harfbuzz/hb.h>
#include <harfbuzz/hb-ft.h>
#include <cassert>

// Helper function to create a font face
FT_Face createFontFace(const char* fontPath) {
    FT_Library library;
    FT_Face face;
    if (FT_Init_FreeType(&library)) {
        std::cerr << "Could not initialize FreeType library." << std::endl;
        exit(1);
    }
    if (FT_New_Face(library, fontPath, 0, &face)) {
        std::cerr << "Could not create font face." << std::endl;
        exit(1);
    }
    return face;
}

// Helper function to create a HarfBuzz font
hb_font_t* createHarfBuzzFont(FT_Face face) {
    hb_font_t* hbFont = hb_ft_font_create(face, nullptr);
    if (!hbFont) {
        std::cerr << "Could not create HarfBuzz font." << std::endl;
        exit(1);
    }
    return hbFont;
}

// Main function demonstrating HarfBuzz usage
int main() {
    const char* fontPath = "/path/to/font.ttf";
    FT_Face face = createFontFace(fontPath);
    hb_font_t* hbFont = createHarfBuzzFont(face);

    // Create a buffer for HarfBuzz
    hb_buffer_t* hbBuffer = hb_buffer_create();
    assert(hbBuffer != nullptr);

    // Set the text to be shaped
    const char* text = "Hello, HarfBuzz!";
    hb_buffer_add_utf8(hbBuffer, text, -1, 0, -1);


GOLDEN COMPLETION:
----------------------------------------
    hb_buffer_set_direction(hbBuffer, HB_DIRECTION_LTR);
    hb_buffer_set_script(hbBuffer, HB_SCRIPT_LATIN);
    hb_buffer_set_language(hbBuffer, hb_language_from_string("en", -1));


SUFFIX CODE:
----------------------------------------
    // Set buffer properties
    hb_buffer_guess_segment_properties(hbBuffer);

    // Shape the text
    hb_shape(hbFont, hbBuffer, nullptr, 0);

    // Get glyph information
    unsigned int glyphCount;
    hb_glyph_info_t* glyphInfo = hb_buffer_get_glyph_infos(hbBuffer, &glyphCount);
    hb_glyph_position_t* glyphPos = hb_buffer_get_glyph_positions(hbBuffer, &glyphCount);
    assert(glyphInfo != nullptr);
    assert(glyphPos != nullptr);

    // Verify the number of glyphs
    assert(glyphCount > 0);

    // Cleanup resources
    hb_buffer_destroy(hbBuffer);
    hb_font_destroy(hbFont);
    FT_Done_Face(face);
    FT_Done_FreeType(library);

    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the HarfBuzz library for text shaping, which is a relatively uncommon API. The scenario includes creating a font face with FreeType, setting up a HarfBuzz font, creating a buffer, adding text to the buffer, configuring the buffer properties, shaping the text, and verifying the results with assertions. The example ensures the model understands the correct sequence of operations and the proper use of HarfBuzz functions, including setting direction, script, and language for the buffer. The assertions verify the correctness of each step, making it a comprehensive test of the model's capability to handle uncommon text processing APIs.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

// Helper function to print a matrix
void printMatrix(const Eigen::MatrixXd &mat) {
    std::cout << mat << std::endl;
}

// Utility function to initialize a matrix
Eigen::MatrixXd initializeMatrix(int rows, int cols) {
    Eigen::MatrixXd mat(rows, cols);
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            mat(i, j) = i * cols + j;
        }
    }
    return mat;
}

// Function to perform matrix operations
void performMatrixOperations() {
    // Initialize two matrices
    Eigen::MatrixXd matA = initializeMatrix(3, 3);
    Eigen::MatrixXd matB = initializeMatrix(3, 3);

    // Print the matrices
    std::cout << "Matrix A:" << std::endl;
    printMatrix(matA);
    std::cout << "Matrix B:" << std::endl;
    printMatrix(matB);

    // Perform matrix addition
    Eigen::MatrixXd matC = matA + matB;
    std::cout << "Matrix C (A + B):" << std::endl;
    printMatrix(matC);

    // Perform matrix multiplication
    Eigen::MatrixXd matD = matA * matB;
    std::cout << "Matrix D (A * B):" << std::endl;
    printMatrix(matD);

    // Check the determinant of a matrix
    double detA = matA.determinant();
    std::cout << "Determinant of Matrix A: " << detA << std::endl;

    // Check the inverse of a matrix if it's invertible
    if (detA != 0) {
        Eigen::MatrixXd matAInv = matA.inverse();
        std::cout << "Inverse of Matrix A:" << std::endl;
        printMatrix(matAInv);
    }
    // Perform matrix rotation (This is where the golden_completion will be inserted)


GOLDEN COMPLETION:
----------------------------------------
    // Create a 2D rotation matrix for 90 degrees
    double angle = M_PI / 2; // 90 degrees in radians
    Eigen::Matrix2d rotationMatrix;
    rotationMatrix << cos(angle), -sin(angle), sin(angle), cos(angle);
    std::cout << "Rotation Matrix (90 degrees):" << std::endl;
    printMatrix(rotationMatrix);


SUFFIX CODE:
----------------------------------------

    // Verify the rotation matrix
    Eigen::MatrixXd expectedRotation(2, 2);
    expectedRotation << 0, -1, 1, 0;
    assert((rotationMatrix - expectedRotation).norm() < 1e-9);

    // Perform another operation
    Eigen::MatrixXd matE = matA.block<2, 2>(0, 0) * rotationMatrix;
    std::cout << "Matrix E (submatrix of A * rotation):" << std::endl;
    printMatrix(matE);

    // Final assertions to ensure correctness
    Eigen::MatrixXd expectedMatE(2, 2);
    expectedMatE << 1, 0, 4, 3;
    assert((matE - expectedMatE).norm() < 1e-9);
}

int main() {
    performMatrixOperations();
    std::cout << "All tests passed!" << std::endl;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This example is a good test case because it demonstrates the use of the Eigen library for matrix operations, including some uncommon functions such as creating a 2D rotation matrix. The test involves initializing matrices, performing basic operations (addition and multiplication), and checking matrix properties (determinant and inverse). The completion focuses on creating a specific type of matrix (rotation matrix), which is a less common but important operation in linear algebra and graphics programming. The assertions verify the correctness of the rotation matrix and subsequent calculations, ensuring the model understands the API's functionality and parameter conventions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

// Define a matrix multiplication function
Eigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd &mat1, const Eigen::MatrixXd &mat2) {
    if (mat1.cols() != mat2.rows()) {
        throw std::invalid_argument("Matrix dimensions are not compatible for multiplication");
    }
    return mat1 * mat2;
}

// Helper function to print matrices
void printMatrix(const Eigen::MatrixXd &matrix) {
    for (int i = 0; i < matrix.rows(); ++i) {
        for (int j = 0; j < matrix.cols(); ++j) {
            std::cout << matrix(i, j) << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    // Define two matrices
    Eigen::MatrixXd mat1(2, 3);
    mat1 << 1, 2, 3,
            4, 5, 6;

    Eigen::MatrixXd mat2(3, 2);
    mat2 << 7, 8,
            9, 10,
            11, 12;

    // Perform matrix multiplication
    Eigen::MatrixXd result = multiplyMatrices(mat1, mat2);

    // Print the result
    std::cout << "Result of matrix multiplication:" << std::endl;
    printMatrix(result);

    // Expected result:
    // 58 64
    // 139 154
    
    // Assert the result
    Eigen::MatrixXd expectedResult(2, 2);
    expectedResult << 58, 64,
                      139, 154;
    assert(result == expectedResult);

    // Modify the result matrix for further processing
    result(0, 0) = 0;
    result(1, 1) = 0;

    // Perform matrix addition with identity matrix
    Eigen::MatrixXd identity = Eigen::MatrixXd::Identity(2, 2);


GOLDEN COMPLETION:
----------------------------------------
    Eigen::MatrixXd modifiedResult = result + identity;



SUFFIX CODE:
----------------------------------------


    // Print the modified result
    std::cout << "Modified result after addition with identity matrix:" << std::endl;
    printMatrix(modifiedResult);

    // Expected modified result:
    // 1 64
    // 139 1
    
    // Assert the modified result
    Eigen::MatrixXd expectedModifiedResult(2, 2);
    expectedModifiedResult << 1, 64,
                              139, 1;
    assert(modifiedResult == expectedModifiedResult);

    return 0;
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a matrix manipulation scenario using the Eigen library, which is an uncommon but powerful library for linear algebra in C++. The prefix includes the setup of matrices and a multiplication function, while the golden completion involves adding an identity matrix to the result and verifying the outcome. The test case ensures that the LLM can follow the correct API usage pattern, handle matrix operations, and maintain proper parameter ordering and usage conventions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <freetype/freetype.h>

class FontManager {
public:
	FontManager() : library(nullptr), face(nullptr) {}
	~FontManager() { cleanup(); }

	bool initialize() {
		FT_Error error = FT_Init_FreeType(&library);
		if (error) {
			std::cerr << "Failed to initialize FreeType library" << std::endl;
			return false;
		}
		return true;
	}

	bool loadFont(const char* filepath) {
		FT_Error error = FT_New_Face(library, filepath, 0, &face);
		if (error) {
			std::cerr << "Failed to load font face" << std::endl;
			return false;
		}
		return true;
	}

	void cleanup() {
		if (face) {
			FT_Done_Face(face);
			face = nullptr;
		}
		if (library) {
			FT_Done_FreeType(library);
			library = nullptr;
		}
	}

	FT_Library getLibrary() const { return library; }
	FT_Face getFace() const { return face; }

private:
	FT_Library library;
	FT_Face face;
};

void renderText(FontManager& fontManager, const char* text) {
	FT_Face face = fontManager.getFace();
	if (!face) {
		std::cerr << "Font face is not loaded" << std::endl;
		return;
	}
	// Set the character size
	FT_Error error = FT_Set_Char_Size(face, 0, 16 * 64, 300, 300);
	if (error) {
		std::cerr << "Failed to set character size" << std::endl;
		return;
	}
	// Load the glyph for each character
	for (const char* p = text; *p; p++) {
		FT_UInt glyph_index = FT_Get_Char_Index(face, *p);
		FT_Error error = FT_Load_Glyph(face, glyph_index, FT_LOAD_DEFAULT);
		if (error) {
			std::cerr << "Failed to load glyph for character " << *p << std::endl;
			continue;
		}
		// Render the glyph
		FT_GlyphSlot slot = face->glyph;
		FT_Render_Glyph(slot, FT_RENDER_MODE_NORMAL);
		// Access the bitmap
		FT_Bitmap bitmap = slot->bitmap;
		// Print the bitmap's dimensions
		std::cout << "Character: " << *p << " Width: " << bitmap.width << " Height: " << bitmap.rows << std::endl;
	}
}

int main() {
	FontManager fontManager;
	assert(fontManager.initialize());
	assert(fontManager.loadFont("/path/to/font.ttf"));
	renderText(fontManager, "Hello, FreeType!");
	// Test edge case: Load an invalid font file


GOLDEN COMPLETION:
----------------------------------------
	assert(!fontManager.loadFont("/invalid/path/to/font.ttf"));


SUFFIX CODE:
----------------------------------------
	// Clean up resources
	fontManager.cleanup();
	return 0;
}


JUSTIFICATION:
----------------------------------------
This test case evaluates the model's ability to recognize and correctly utilize the FreeType library, specifically focusing on initializing the library, loading a font, setting character size, loading glyphs, and rendering text. It also includes an edge case to test the loading of an invalid font file. The example ensures proper resource management and cleanup, and the assertions verify the correct initialization and font loading behavior.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

// Function to compute the cross product of two vectors using Eigen library
Eigen::Vector3d computeCrossProduct(const Eigen::Vector3d& vec1, const Eigen::Vector3d& vec2) {
    // Uncommon usage of Eigen's cross product function
    return vec1.cross(vec2);
}

// Function to compute the dot product of two vectors using Eigen library
Eigen::Vector3d computeDotProduct(const Eigen::Vector3d& vec1, const Eigen::Vector3d& vec2) {
    // Uncommon usage of Eigen's dot product function
    return vec1.dot(vec2);
}

int main() {
    // Initialize vectors
    Eigen::Vector3d vec1(1.0, 2.0, 3.0);
    Eigen::Vector3d vec2(4.0, 5.0, 6.0);

    // Compute the cross product
    Eigen::Vector3d crossProduct = computeCrossProduct(vec1, vec2);

    // Assertions to verify cross product
    assert(crossProduct(0) == -3.0);
    assert(crossProduct(1) == 6.0);
    assert(crossProduct(2) == -3.0);

    // Compute the dot product


GOLDEN COMPLETION:
----------------------------------------

    Eigen::Vector3d dotProduct = computeDotProduct(vec1, vec2);


SUFFIX CODE:
----------------------------------------
    // Assertions to verify dot product
    assert(dotProduct == 32.0);

    // Additional computations
    Eigen::Vector3d sum = vec1 + vec2;
    Eigen::Vector3d difference = vec1 - vec2;

    // Assertions for additional computations
    assert(sum(0) == 5.0);
    assert(sum(1) == 7.0);
    assert(sum(2) == 9.0);

    assert(difference(0) == -3.0);
    assert(difference(1) == -3.0);
    assert(difference(2) == -3.0);

    // Cleanup and end of main
    std::cout << "All assertions passed." << std::endl;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and correctly use uncommon functions from the Eigen library, specifically for vector operations like dot and cross products. The pattern established involves computing and verifying vector operations with assert statements. The uncommon usage of Eigen's dot product function in the context of this example makes it a good test case for evaluating the LLM's understanding of less frequently used library functions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <string>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <cassert>

void handleErrors() {
    ERR_print_errors_fp(stderr);
    abort();
}

std::string generateKey() {
    unsigned char key[EVP_MAX_KEY_LENGTH];
    if (!RAND_bytes(key, sizeof(key))) {
        handleErrors();
    }
    return std::string(reinterpret_cast<char*>(key), sizeof(key));
}

std::string encrypt(const std::string &plaintext, const std::string &key) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) handleErrors();
    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL))
        handleErrors();

    unsigned char ciphertext[plaintext.size() + EVP_MAX_BLOCK_LENGTH];
    int len;
    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.size()))
        handleErrors();

    int ciphertext_len = len;
    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len))
        handleErrors();
    ciphertext_len += len;

    EVP_CIPHER_CTX_free(ctx);

    return std::string(reinterpret_cast<char*>(ciphertext), ciphertext_len);
}

std::string decrypt(const std::string &ciphertext, const std::string &key) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) handleErrors();
    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL))
        handleErrors();

    unsigned char plaintext[ciphertext.size()];
    int len;
    if (1 != EVP_DecryptUpdate(ctx, plaintext, &len, reinterpret_cast<const unsigned char*>(ciphertext.c_str()), ciphertext.size()))
        handleErrors();

    int plaintext_len = len;
    if (1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len))
        handleErrors();
    plaintext_len += len;

    EVP_CIPHER_CTX_free(ctx);

    return std::string(reinterpret_cast<char*>(plaintext), plaintext_len);
}

int main() {
    std::string key = generateKey();
    std::string plaintext = "Hello, world!";
    std::string ciphertext = encrypt(plaintext, key);

GOLDEN COMPLETION:
----------------------------------------

    std::string decryptedtext = decrypt(ciphertext, key);

SUFFIX CODE:
----------------------------------------


    assert(plaintext == decryptedtext);
    assert(!ciphertext.empty());
    assert(!key.empty());

    std::cout << "Original text: " << plaintext << std::endl;
    std::cout << "Decrypted text: " << decryptedtext << std::endl;

    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case uses the OpenSSL library for encryption and decryption, which is a less common but powerful API. The example demonstrates key generation, encryption, and decryption using AES-256-CBC. The pattern includes proper initialization, usage, and cleanup of OpenSSL contexts. Assertions ensure that the decrypted text matches the original plaintext, and that the key and ciphertext are not empty. This scenario tests the LLM's ability to handle complex cryptographic operations and manage resources correctly.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <string>
#include <cassert>
#include <openssl/evp.h>

class CryptoUtil {
public:
    static std::string encrypt(const std::string &plaintext, const std::string &key) {
        EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
        if (!ctx) throw std::runtime_error("Failed to create context");

        const EVP_CIPHER *cipher = EVP_aes_256_cbc();
        if (!cipher) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to get cipher");
        }

        if (EVP_EncryptInit_ex(ctx, cipher, NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to initialize encryption");
        }

        std::string ciphertext;
        ciphertext.resize(plaintext.size() + EVP_CIPHER_block_size(cipher));
        int len;

        if (EVP_EncryptUpdate(ctx, reinterpret_cast<unsigned char*>(&ciphertext[0]), &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to encrypt");
        }

        int ciphertext_len = len;

        if (EVP_EncryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(&ciphertext[0]) + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            throw std::runtime_error("Failed to finalize encryption");
        }
        ciphertext_len += len;
        ciphertext.resize(ciphertext_len);

        EVP_CIPHER_CTX_free(ctx);

        return ciphertext;
    }
};

int main() {
    std::string key = "01234567890123456789012345678901"; // 32 bytes for AES-256
    std::string plaintext = "Hello, World!";


GOLDEN COMPLETION:
----------------------------------------
    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);


SUFFIX CODE:
----------------------------------------

    assert(!ciphertext.empty());
    assert(ciphertext != plaintext);
    std::cout << "Encryption successful, ciphertext size: " << ciphertext.size() << std::endl;

    // Clean up resources if any
    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the OpenSSL library for AES-256 encryption, which is not a common API for basic C++ programming. It involves setting up encryption context, initializing encryption, performing the encryption operation, and then finalizing it. The test case checks if the model can correctly complete the encryption process and handle errors appropriately. Assertions are included to verify that the ciphertext is not empty and differs from the plaintext, ensuring the encryption process was successful.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <vector>
#include <armadillo>
#include <cassert>

// Use the Armadillo library for linear algebra
// This example demonstrates using the uncommon solve function with sparse matrices

// Helper function to create a sparse matrix
arma::sp_mat createSparseMatrix(int rows, int cols) {
    arma::sp_mat mat(rows, cols);
    mat(0, 0) = 1.0;
    mat(1, 1) = 2.0;
    mat(2, 2) = 3.0;
    mat(3, 3) = 4.0;
    mat(4, 4) = 5.0;
    return mat;
}

// Helper function to create a dense vector
arma::vec createDenseVector(int size) {
    arma::vec vec(size);
    vec(0) = 1.0;
    vec(1) = 2.0;
    vec(2) = 3.0;
    vec(3) = 4.0;
    vec(4) = 5.0;
    return vec;
}

int main() {
    arma::sp_mat A = createSparseMatrix(5, 5);
    arma::vec b = createDenseVector(5);
    arma::vec x;

    // Solve the system A * x = b using sparse matrix solve function
    // Note: The sparse matrix solve function is less commonly used
    // compared to dense matrix solve functions
    try {


GOLDEN COMPLETION:
----------------------------------------
        x = arma::spsolve(A, b, "lapack");


SUFFIX CODE:
----------------------------------------
        // Verify the solution by checking if A * x is approximately equal to b
        arma::vec result = A * x;
        for (size_t i = 0; i < b.size(); ++i) {
            assert(std::abs(result[i] - b[i]) < 1e-5);
        }
    } catch (std::runtime_error &e) {
        std::cerr << "Runtime error: " << e.what() << std::endl;
    }

    std::cout << "All assertions passed. Sparse matrix solve verified." << std::endl;
    return 0;
}

JUSTIFICATION:
----------------------------------------
This example uses the Armadillo library's sparse matrix solve function, which is less commonly used compared to its dense matrix counterpart. The test case ensures the model correctly identifies and applies the sparse matrix solve function, handles the parameters accurately, and verifies the solution by checking if the result matches the expected vector. The assertions ensure the accuracy of the solution, making this a robust test of uncommon API usage.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cstdio>
#include <cassert>
#include <cstring>

class FileHandler {
public:
    FileHandler(const char* filename) : file(nullptr) {
        openFile(filename);
    }

    ~FileHandler() {
        closeFile();
    }

    void writeFile(const char* content) {
        if (file) {
            fwrite(content, sizeof(char), strlen(content), file);
        }
    }

    void readFile(char* buffer, size_t size) {
        if (file) {
            fseek(file, 0, SEEK_SET);
            fread(buffer, sizeof(char), size, file);
        }
    }

private:
    FILE* file;

    void openFile(const char* filename) {
        file = fopen(filename, "w+");
    }

    void closeFile() {
        if (file) {
            fclose(file);
        }
    }
};

int main() {
    const char* filename = "testfile.txt";
    FileHandler fileHandler(filename);
    const char* content = "Hello, world!";
    fileHandler.writeFile(content);
    char buffer[50] = {0};


GOLDEN COMPLETION:
----------------------------------------
    fileHandler.readFile(buffer, sizeof(buffer));
    assert(strcmp(buffer, "Hello, world!") == 0);


SUFFIX CODE:
----------------------------------------

    std::cout << "File content: " << buffer << std::endl;

    // Cleanup code
    remove(filename);
    return 0;
}


JUSTIFICATION:
----------------------------------------
This example uses the deprecated C standard library functions fopen, fwrite, fread, and fclose to manipulate files. It tests the LLM's ability to correctly recognize and continue the pattern of file operations using these functions, including proper parameter ordering and error handling. The scenario involves writing to a file, reading back from it, and verifying the content, which is a common use case but with uncommon library functions. Proper cleanup of resources is also demonstrated.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <cstdlib>
#include <libgen.h>
#include <unistd.h>
#include <limits.h>

class PathManipulator {
public:
    PathManipulator(const std::string& path) : originalPath(path) {
        canonicalPath = realpath(originalPath.c_str(), nullptr);
        if (!canonicalPath) {
            throw std::runtime_error("Failed to resolve canonical path");
        }
    }

    ~PathManipulator() {
        if (canonicalPath) {
            free(canonicalPath);
        }
    }

    std::string getCanonicalPath() const {
        return std::string(canonicalPath);
    }

    std::string getBaseName() const {
        char* pathCopy = strdup(canonicalPath);
        if (!pathCopy) {
            throw std::runtime_error("Failed to duplicate path");
        }
        std::string baseName = basename(pathCopy);
        free(pathCopy);
        return baseName;
    }

    std::string getDirName() const {
        char* pathCopy = strdup(canonicalPath);
        if (!pathCopy) {
            throw std::runtime_error("Failed to duplicate path");
        }
        std::string dirName = dirname(pathCopy);
        free(pathCopy);
        return dirName;
    }

private:
    std::string originalPath;
    char* canonicalPath;
};

int main() {
    try {
        PathManipulator pathManip("/usr/local/bin/someapp");
        std::string canonical = pathManip.getCanonicalPath();


GOLDEN COMPLETION:
----------------------------------------
        std::string baseName = pathManip.getBaseName();
        std::string dirName = pathManip.getDirName();



SUFFIX CODE:
----------------------------------------


        // Assertions
        assert(canonical == "/usr/local/bin/someapp");
        assert(baseName == "someapp");
        assert(dirName == "/usr/local/bin");
    } catch (const std::exception& ex) {
        std::cerr << "Exception: " << ex.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and correctly use POSIX functions such as realpath, basename, and dirname. These functions are uncommon in typical C++ usage but are crucial for system-level programming. The example also includes proper memory management and error handling, making it a good test for the LLM's understanding of resource cleanup and exception safety.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <string>
#include <cassert>
#include <sqlite3.h>

class Database {
public:
    Database(const std::string& db_name) : db(nullptr) {
        int rc = sqlite3_open(db_name.c_str(), &db);
        if (rc) {
            std::cerr << "Can't open database: " << sqlite3_errmsg(db) << std::endl;
        } else {
            std::cout << "Opened database successfully" << std::endl;
        }
    }

    ~Database() {
        if (db) {
            sqlite3_close(db);
        }
    }

    bool execute(const std::string& sql) {
        char* errMsg = nullptr;
        int rc = sqlite3_exec(db, sql.c_str(), callback, 0, &errMsg);
        if (rc != SQLITE_OK) {
            std::cerr << "SQL error: " << errMsg << std::endl;
            sqlite3_free(errMsg);
            return false;
        }
        return true;
    }

    static int callback(void* NotUsed, int argc, char** argv, char** azColName) {
        for (int i = 0; i < argc; i++) {
            std::cout << azColName[i] << " = " << (argv[i] ? argv[i] : "NULL") << std::endl;
        }
        return 0;
    }

private:
    sqlite3* db;
};

void test_database() {
    Database db("test.db");
    std::string create_table_sql = "CREATE TABLE COMPANY("  "ID INT PRIMARY KEY     NOT NULL,"  "NAME           TEXT    NOT NULL,"  "AGE            INT     NOT NULL,"  "ADDRESS        CHAR(50),"  "SALARY         REAL );";


GOLDEN COMPLETION:
----------------------------------------
    assert(db.execute(create_table_sql));


SUFFIX CODE:
----------------------------------------
    std::string insert_sql = "INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) "
                              "VALUES (1, 'Paul', 32, 'California', 20000.00 ); ";
    assert(db.execute(insert_sql));

    std::string select_sql = "SELECT * FROM COMPANY;";
    assert(db.execute(select_sql));
}

int main() {
    test_database();
    return 0;
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern using the SQLite database C++ API, which is uncommon and requires correct parameter handling and error checking. The prefix sets up the database connection and defines a function to execute SQL commands, while the completion involves creating a table, which is a critical step in database operations. The suffix continues with inserting and selecting data, and includes assertions to verify correct database interactions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <vector>
#include <cassert>
#include <boost/asio.hpp>

// Helper function to print the endpoint
void print_endpoint(const boost::asio::ip::tcp::endpoint& endpoint) {
    std::cout << "Address: " << endpoint.address().to_string() << ", Port: " << endpoint.port() << std::endl;
}

// Function to create and return a TCP endpoint
boost::asio::ip::tcp::endpoint create_endpoint(const std::string& address, unsigned short port) {
    boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::address::from_string(address), port);
    return endpoint;
}

// Function to resolve an address to an endpoint
boost::asio::ip::tcp::endpoint resolve_endpoint(boost::asio::io_service& io_service, const std::string& host, const std::string& service) {
    boost::asio::ip::tcp::resolver resolver(io_service);
    boost::asio::ip::tcp::resolver::query query(host, service);
    boost::asio::ip::tcp::resolver::iterator iter = resolver.resolve(query);
    boost::asio::ip::tcp::resolver::iterator end;

    if (iter != end) {
        return *iter;
    } else {
        throw std::runtime_error("Could not resolve endpoint");
    }
}

int main() {
    try {
        boost::asio::io_service io_service;
        // Create endpoints
        boost::asio::ip::tcp::endpoint endpoint1 = create_endpoint("127.0.0.1", 8080);
        boost::asio::ip::tcp::endpoint endpoint2 = resolve_endpoint(io_service, "localhost", "80");
        print_endpoint(endpoint1);
        print_endpoint(endpoint2);
        // Deprecated but valid way to resolve endpoint


GOLDEN COMPLETION:
----------------------------------------

        boost::asio::ip::tcp::resolver resolver(io_service);
        boost::asio::ip::tcp::resolver::query query("localhost", "80");
        boost::asio::ip::tcp::resolver::iterator iter = resolver.resolve(query);
        endpoint2 = *iter;


SUFFIX CODE:
----------------------------------------
        // Assertions
        assert(endpoint1.address().to_string() == "127.0.0.1");
        assert(endpoint1.port() == 8080);
        assert(endpoint2.port() == 80);

        // Clean up
        io_service.stop();
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}


JUSTIFICATION:
----------------------------------------
This example tests the model's ability to recognize and complete patterns involving the Boost.Asio library, specifically the deprecated method of resolving endpoints using the resolver. The example includes a substantial prefix to establish context and set up the necessary components. The golden completion demonstrates the correct usage of the deprecated resolver API, while the suffix includes assertions to verify the correct behavior and cleanup code to ensure resources are properly managed.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <nlohmann/json.hpp>
#include <fstream>
#include <string>

using json = nlohmann::json;

class ConfigLoader {
public:
    ConfigLoader(const std::string& filename) : filename(filename) {}

    bool loadConfig() {
        std::ifstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Unable to open file: " << filename << std::endl;
            return false;
        }
        try {
            file >> config;
        } catch (const json::parse_error& e) {
            std::cerr << "Parse error: " << e.what() << std::endl;
            return false;
        }
        return true;
    }

    template <typename T>
    T getValue(const std::string& key) const {
        try {
            return config.at(key).get<T>();
        } catch (const json::out_of_range& e) {
            std::cerr << "Key not found: " << key << std::endl;
            throw;
        }
    }

private:
    std::string filename;
    json config;
};

void testConfigLoader() {
    ConfigLoader loader("config.json");


GOLDEN COMPLETION:
----------------------------------------
    assert(loader.loadConfig() == true);


SUFFIX CODE:
----------------------------------------
    int port = loader.getValue<int>("port");
    std::string host = loader.getValue<std::string>("host");

    assert(port == 8080);
    assert(host == "localhost");

    // Cleanup code
    // Remove the test config file if it exists
    std::remove("config.json");
}

int main() {
    // Create a sample config file for testing
    std::ofstream configFile("config.json");
    configFile << "{\"port\": 8080, \"host\": \"localhost\"}";
    configFile.close();

    // Run the test
    testConfigLoader();

    std::cout << "All tests passed!" << std::endl;
    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case evaluates the model's ability to understand and correctly utilize a less common library function, nlohmann::json, for parsing JSON files. The pattern involves loading a JSON configuration file, accessing specific values, and handling exceptions. The code includes necessary assertions to verify correct API behavior and parameter ordering. The example is realistic and demonstrates practical usage of the library in a configuration loading context. The test ensures that the model can recognize and complete the pattern correctly while handling errors and performing cleanup operations.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <string>
#include <vector>
#include <cassert>
#include <boost/asio.hpp>
#include <boost/asio/steady_timer.hpp>
#include <boost/bind/bind.hpp>

using namespace boost::asio;
using namespace std::chrono_literals;

class TimerManager {
public:
    TimerManager(io_context& io_context) : timer_(io_context, 5s), io_context_(io_context) {}

    void start() {
        timer_.async_wait(boost::bind(&TimerManager::handleTimeout, this, boost::placeholders::_1));
        std::cout << "Timer started for 5 seconds" << std::endl;
    }

private:
    void handleTimeout(const boost::system::error_code& error) {
        if (!error) {
            std::cout << "Timeout occurred!" << std::endl;
        }
    }

    steady_timer timer_;
    io_context& io_context_;
};

int main() {
    io_context io_context;
    TimerManager tm(io_context);
    tm.start();


GOLDEN COMPLETION:
----------------------------------------
    tm.setTimeoutOccurred(false);


SUFFIX CODE:
----------------------------------------
    io_context.run();
    assert(tm.getTimeoutOccurred() == true);
    std::cout << "Assertion passed: Timer expired as expected" << std::endl;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the Boost.Asio library, particularly focusing on the steady_timer class and its asynchronous wait functionality. The example is designed to test the LLM's ability to recognize and correctly complete the pattern of setting and handling a timer using Boost.Asio. By including the timer management within a class and using the async_wait function with a bound handler, it ensures the understanding of asynchronous operations and the correct API usage. Additionally, the assertions in the suffix verify the behavior of the timer, ensuring the correct execution flow.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <sqlite3.h>
#include <cassert>

class DatabaseManager {
public:
    DatabaseManager(const std::string &db_name) : db_name_(db_name), db_(nullptr) {}

    bool openDatabase() {
        int rc = sqlite3_open(db_name_.c_str(), &db_);
        if (rc) {
            std::cerr << "Can't open database: " << sqlite3_errmsg(db_) << std::endl;
            return false;
        }
        return true;
    }

    bool createTable(const std::string &table_sql) {
        char *errmsg = nullptr;
        int rc = sqlite3_exec(db_, table_sql.c_str(), nullptr, nullptr, &errmsg);
        if (rc != SQLITE_OK) {
            std::cerr << "SQL error: " << errmsg << std::endl;
            sqlite3_free(errmsg);
            return false;
        }
        return true;
    }

    bool insertData(const std::string &insert_sql) {
        char *errmsg = nullptr;
        int rc = sqlite3_exec(db_, insert_sql.c_str(), nullptr, nullptr, &errmsg);
        if (rc != SQLITE_OK) {
            std::cerr << "SQL error: " << errmsg << std::endl;
            sqlite3_free(errmsg);
            return false;
        }
        return true;
    }

    bool closeDatabase() {
        if (db_) {
            sqlite3_close(db_);
            db_ = nullptr;
            return true;
        }
        return false;
    }

private:
    std::string db_name_;
    sqlite3 *db_;
};

int main() {
    DatabaseManager dbManager("test.db");
    assert(dbManager.openDatabase());
    std::string create_table_sql = "CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER);";
    assert(dbManager.createTable(create_table_sql));
    std::string insert_sql = "INSERT INTO users (name, age) VALUES ('Alice', 30);";


GOLDEN COMPLETION:
----------------------------------------
    assert(dbManager.insertData(insert_sql));

SUFFIX CODE:
----------------------------------------
    char *errmsg = nullptr;
    std::string select_sql = "SELECT * FROM users;";
    int rc = sqlite3_exec(dbManager.db_, select_sql.c_str(), [](void*, int, char**, char**){ return 0; }, nullptr, &errmsg);
    assert(rc == SQLITE_OK);
    if (errmsg) sqlite3_free(errmsg);
    assert(dbManager.closeDatabase());
    return 0;
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete patterns using the SQLite C++ API, which is less commonly used compared to higher-level database libraries. The prefix sets up a database connection, creates a table, and inserts data, while the completion requires correctly using the insertData method to insert a record into the database. The suffix checks the insertion and selects the data to ensure it was inserted correctly, then closes the database connection. This tests the model's understanding of the API's functions, parameter ordering, error handling, and resource management.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <string>
#include <mysql_driver.h>
#include <mysql_connection.h>
#include <cppconn/statement.h>
#include <cppconn/resultset.h>
#include <cppconn/exception.h>
#include <cassert>

void performDatabaseOperations() {
    sql::mysql::MySQL_Driver *driver;
    sql::Connection *con;
    sql::Statement *stmt;
    sql::ResultSet *res;

    try {
        driver = sql::mysql::get_driver_instance();
        con = driver->connect("tcp://127.0.0.1:3306", "user", "password");
        con->setSchema("testdb");

        stmt = con->createStatement();


GOLDEN COMPLETION:
----------------------------------------
        stmt->execute("INSERT INTO employees (name) VALUES ('John Doe')");


SUFFIX CODE:
----------------------------------------
        res = stmt->executeQuery("SELECT name FROM employees");
        res->next();
        assert(res->getString("name") == "John Doe");

        delete res;
        delete stmt;
        delete con;
    } catch (sql::SQLException &e) {
        std::cerr << "SQL error: " << e.what() << std::endl;
        if (res) delete res;
        if (stmt) delete stmt;
        if (con) delete con;
        throw;
    }
}

int main() {
    performDatabaseOperations();
    return 0;
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to complete a database operation using the MySQL Connector C++ API, which is less commonly used in typical applications compared to other database interfaces. The test includes creating a connection, executing a statement, and verifying the result with an assertion, ensuring the model understands the correct usage and order of operations. The golden completion involves an uncommon API usage of executing an INSERT statement, while the suffix handles the subsequent SELECT query and validation.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <fstream>
#include <boost/algorithm/string.hpp>
#include <vector>
#include <string>
#include <cassert>

class FileProcessor {
public:
    FileProcessor(const std::string &filename) : filename_(filename) {}

    void readFile() {
        std::ifstream file(filename_);
        if (!file.is_open()) {
            throw std::runtime_error("Could not open file");
        }
        std::string line;
        while (std::getline(file, line)) {
            lines_.push_back(line);
        }
        file.close();
    }

    std::vector<std::string> getLines() const {
        return lines_;
    }

private:
    std::string filename_;
    std::vector<std::string> lines_;
};

void processLines(const std::vector<std::string> &lines) {
    for (const auto &line : lines) {
        std::vector<std::string> words;
        boost::split(words, line, boost::is_any_of(" "));
        for (const auto &word : words) {
            std::cout << word << std::endl;
        }
    }
}

int main() {
    try {
        FileProcessor processor("example.txt");
        processor.readFile();
        std::vector<std::string> lines = processor.getLines();

        // Completion expected here


GOLDEN COMPLETION:
----------------------------------------
        boost::to_upper(lines[0]);
        boost::to_upper(lines[1]);


SUFFIX CODE:
----------------------------------------
        processLines(lines);

        // Assertions to verify correct API usage
        assert(!lines.empty());
        assert(lines[0] == "This is the first line of the file.");
        assert(lines[1] == "This is the second line of the file.");
    } catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of uncommon functions from the Boost library, specifically boost::to_upper and boost::split. The completion involves converting lines to uppercase, which is a less common but valid use of the Boost library. The test ensures the model can recognize and correctly use these functions, verifying the changes with assertions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <cassert>
#include <sqlite3.h>

class DatabaseManager {
public:
    DatabaseManager(const std::string &db_name) : db(nullptr) {
        if (sqlite3_open(db_name.c_str(), &db)) {
            std::cerr << "Can't open database: " << sqlite3_errmsg(db) << std::endl;
            db = nullptr;
        }
    }

    ~DatabaseManager() {
        if (db) {
            sqlite3_close(db);
        }
    }

    bool executeQuery(const std::string &query) {
        char *errMsg = nullptr;
        int rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errMsg);
        if (rc != SQLITE_OK) {
            std::cerr << "SQL error: " << errMsg << std::endl;
            sqlite3_free(errMsg);
            return false;
        }
        return true;
    }

    int getNumberOfRows(const std::string &query) {
        sqlite3_stmt *stmt;
        int rc = sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr);
        if (rc != SQLITE_OK) {
            std::cerr << "Failed to prepare statement: " << sqlite3_errmsg(db) << std::endl;
            return -1;
        }
        int rowCount = 0;
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            rowCount++;
        }
        sqlite3_finalize(stmt);
        return rowCount;
    }

private:
    sqlite3 *db;
};

int main() {
    DatabaseManager dbManager("test.db");
    std::string createTableQuery = "CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, value TEXT);";
    assert(dbManager.executeQuery(createTableQuery));
    std::string insertQuery = "INSERT INTO test_table (value) VALUES ('test1'), ('test2'), ('test3');";
    assert(dbManager.executeQuery(insertQuery));
    std::string selectQuery = "SELECT * FROM test_table;";


GOLDEN COMPLETION:
----------------------------------------
    int rowCount = dbManager.getNumberOfRows(selectQuery);


SUFFIX CODE:
----------------------------------------

    assert(rowCount == 3);
    std::string deleteQuery = "DELETE FROM test_table WHERE id = 1;";
    assert(dbManager.executeQuery(deleteQuery));
    rowCount = dbManager.getNumberOfRows(selectQuery);
    assert(rowCount == 2);
    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case is a good example of uncommon API usage involving the SQLite C++ interface. The code tests the ability of the LLM to recognize and complete the pattern of executing SQL queries and counting rows in a table. The completion requires understanding the API functions sqlite3_prepare_v2, sqlite3_step, and sqlite3_finalize, which are less commonly used. The assertions ensure that the database operations are performed correctly, and the row counts match expectations. This scenario tests the model's capability to handle database interfaces and manage resources appropriately.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <cassert>
#include <tinyxml2.h>
#include <iostream>

using namespace tinyxml2;

class XMLHandler {
public:
    XMLHandler(const std::string& xmlContent) {
        doc = new XMLDocument();
        XMLError result = doc->Parse(xmlContent.c_str());
        if (result != XML_SUCCESS) {
            throw std::runtime_error("Failed to parse XML");
        }
    }

    ~XMLHandler() {
        delete doc;
    }

    XMLElement* getElementByName(const std::string& name) {
        return doc->FirstChildElement(name.c_str());
    }

private:
    XMLDocument* doc;
};

void testXML() {
    std::string xmlContent = "<root><child>value</child></root>";
    XMLHandler handler(xmlContent);
    XMLElement* element = handler.getElementByName("child");


GOLDEN COMPLETION:
----------------------------------------
    assert(element != nullptr);
    assert(std::string(element->GetText()) == "value");


SUFFIX CODE:
----------------------------------------


    // Additional assertions to test error conditions
    try {
        XMLHandler invalidHandler("<root><child>value</child>"); // Missing closing tag
        assert(false); // Should not reach here
    } catch (const std::runtime_error& e) {
        assert(std::string(e.what()) == "Failed to parse XML");
    }

    try {
        XMLHandler emptyHandler(""); // Empty content
        assert(false); // Should not reach here
    } catch (const std::runtime_error& e) {
        assert(std::string(e.what()) == "Failed to parse XML");
    }
}

int main() {
    testXML();
    std::cout << "All tests passed!" << std::endl;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This example tests the model's ability to recognize and use the tinyxml2 library for parsing XML data, which is an uncommon library function. The scenario involves creating an XMLHandler class to parse XML content and retrieve elements by name. The golden completion fills in the correct usage of the tinyxml2 API to retrieve the text of an XML element and includes assertions to verify the behavior. The suffix includes additional error handling and assertions to ensure the correctness of the implementation, making it a comprehensive test case for the model's understanding of the tinyxml2 library.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <vector>
#include <cassert>
#include <Eigen/Dense>

// A helper function to initialize a matrix
Eigen::MatrixXd initializeMatrix(int rows, int cols) {
    Eigen::MatrixXd mat(rows, cols);
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            mat(i, j) = i + j;
        }
    }
    return mat;
}

// A helper function to print a matrix
void printMatrix(const Eigen::MatrixXd& mat) {
    std::cout << mat << std::endl;
}

int main() {
    // Initialize two matrices
    Eigen::MatrixXd matA = initializeMatrix(3, 3);
    Eigen::MatrixXd matB = initializeMatrix(3, 3);

    // Print the matrices
    std::cout << "Matrix A:" << std::endl;
    printMatrix(matA);
    std::cout << "Matrix B:" << std::endl;
    printMatrix(matB);

    // Compute the product of the matrices


GOLDEN COMPLETION:
----------------------------------------
    Eigen::MatrixXd matProduct = matA * matB;


SUFFIX CODE:
----------------------------------------
    // Compute the sum of the matrices
    Eigen::MatrixXd matSum = matA + matB;
    
    // Print the result
    std::cout << "Sum of A and B:" << std::endl;
    printMatrix(matSum);

    // Assertions to verify the matrix operations
    assert(matProduct.rows() == 3);
    assert(matProduct.cols() == 3);
    assert(matProduct(0, 0) == 0);
    assert(matProduct(1, 1) == 8);
    assert(matProduct(2, 2) == 20);

    // No resource cleanup needed as Eigen handles it automatically
    return 0;
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete patterns involving the Eigen library, which is commonly used for linear algebra operations in C++. The example includes matrix initialization, printing, and operations like addition and multiplication. It also demonstrates the importance of correct parameter usage and matrix dimension handling. Assertions verify the correctness of matrix operations and dimensions, ensuring that the API is used correctly. The Eigen library's functions are less common compared to standard C++ libraries, making this a good test case for rare API usage capabilities.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <vector>
#include <string>
#include <mysql_driver.h>
#include <mysql_connection.h>
#include <cppconn/driver.h>
#include <cppconn/exception.h>
#include <cppconn/resultset.h>
#include <cppconn/statement.h>
#include <cassert>

// This example demonstrates the use of MySQL Connector/C++ to connect to a MySQL database,
// execute a query, and process the result set. We will focus on establishing the connection
// and executing a query using a deprecated API function.

void initializeDatabase(sql::Connection*& conn) {
    try {
        sql::mysql::MySQL_Driver* driver = sql::mysql::get_mysql_driver_instance();
        conn = driver->connect("tcp://127.0.0.1:3306", "root", "password");
        conn->setSchema("testdb");
    } catch (sql::SQLException &e) {
        std::cerr << "SQLException: " << e.what() << std::endl;
        std::cerr << "MySQL error code: " << e.getErrorCode() << std::endl;
        std::cerr << "SQLState: " << e.getSQLState() << std::endl;
    }
}

void executeQuery(sql::Connection* conn, const std::string& query, std::vector<std::string>& results) {
    try {
        sql::Statement* stmt = conn->createStatement();
        sql::ResultSet* res = stmt->executeQuery(query);
        while (res->next()) {
            results.push_back(res->getString(1));
        }
        delete res;
        delete stmt;
    } catch (sql::SQLException &e) {
        std::cerr << "SQLException: " << e.what() << std::endl;
        std::cerr << "MySQL error code: " << e.getErrorCode() << std::endl;
        std::cerr << "SQLState: " << e.getSQLState() << std::endl;
    }
}

int main() {
    sql::Connection* conn = nullptr;
    initializeDatabase(conn);
    std::vector<std::string> results;

GOLDEN COMPLETION:
----------------------------------------
    executeQuery(conn, "SELECT name FROM users;", results);



SUFFIX CODE:
----------------------------------------


    // Assertions to verify the results
    assert(!results.empty());
    assert(results[0] == "John Doe");

    // Clean up resources
    delete conn;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case uses the MySQL Connector/C++ library to connect to a MySQL database, execute a query, and process the results. It demonstrates the usage of deprecated API functions and ensures the model recognizes and continues the established pattern correctly. The assertions verify the correctness of the query execution and the results obtained from the database.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <stdexcept>
#include <cassert>
#include <Python.h>

class PythonEmbedder {
public:
    PythonEmbedder() {
        Py_Initialize();
        if (!Py_IsInitialized()) {
            throw std::runtime_error("Failed to initialize Python interpreter");
        }
    }
    
    ~PythonEmbedder() {
        if (Py_IsInitialized()) {
            Py_Finalize();
        }
    }

    void executeScript(const std::string &script) {
        PyObject* pGlobals = PyDict_New();
        PyObject* pLocals = PyDict_New();
        PyObject* pValue = PyRun_String(script.c_str(), Py_file_input, pGlobals, pLocals);
        if (pValue == nullptr) {
            PyErr_Print();
            throw std::runtime_error("Python script execution failed");
        }
        Py_DECREF(pValue);
        Py_DECREF(pLocals);
        Py_DECREF(pGlobals);
    }

    int getGlobalVariable(const std::string &name) {
        PyObject* pMain = PyImport_AddModule("__main__");
        PyObject* pDict = PyModule_GetDict(pMain);
        PyObject* pVar = PyDict_GetItemString(pDict, name.c_str());
        if (pVar == nullptr || !PyLong_Check(pVar)) {
            throw std::runtime_error("Failed to retrieve global variable");
        }
        return PyLong_AsLong(pVar);
    }
};

int main() {
    try {
        PythonEmbedder embedder;
        std::string script = "x = 10\ny = 20\nz = x + y";


GOLDEN COMPLETION:
----------------------------------------
        embedder.executeScript(script);


SUFFIX CODE:
----------------------------------------
        int z = embedder.getGlobalVariable("z");
        assert(z == 30);
        std::cout << "Assertion passed, value of z is: " << z << std::endl;
    } catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}


JUSTIFICATION:
----------------------------------------
This example demonstrates the use of the Python C API to embed a Python interpreter within a C++ application. The scenario tests the model's ability to handle uncommon API usage involving Python script execution and variable retrieval. The prefix sets up the context by defining a PythonEmbedder class with methods to initialize and finalize the Python interpreter, execute scripts, and retrieve global variables. The golden completion fills in the critical step of executing the script. The suffix includes assertions to verify the correct execution and retrieval of variables, ensuring the API usage is correct and complete.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

using namespace Eigen;

// Helper function to initialize a matrix with specific values
MatrixXd initializeMatrix(int rows, int cols) {
    MatrixXd mat(rows, cols);
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            mat(i, j) = i + j;
        }
    }
    return mat;
}

// Function to perform a specific matrix operation
MatrixXd performOperation(const MatrixXd &mat1, const MatrixXd &mat2) {
    // Check if matrices are of the same size
    assert(mat1.rows() == mat2.rows() && mat1.cols() == mat2.cols());
    // Perform element-wise multiplication
    return mat1.cwiseProduct(mat2);
}

int main() {
    // Initialize matrices
    MatrixXd mat1 = initializeMatrix(3, 3);
    MatrixXd mat2 = initializeMatrix(3, 3);

    // Perform matrix operation
    MatrixXd result = performOperation(mat1, mat2);

    // Print result
    std::cout << "Result:\n" << result << std::endl;

    // Continue with additional matrix operations
    MatrixXd transposed = result.transpose();
    std::cout << "Transposed Result:\n" << transposed << std::endl;

    // Continue with more matrix operations
    MatrixXd inverse;

GOLDEN COMPLETION:
----------------------------------------
    inverse = result.inverse();

SUFFIX CODE:
----------------------------------------
    std::cout << "Inverse Result:\n" << inverse << std::endl;

    // Assertions to verify correctness
    assert(inverse.rows() == 3);
    assert(inverse.cols() == 3);
    assert(inverse(0, 0) != 0);

    // Clean up resources (not needed for Eigen, but shown here for completeness)
    // No explicit cleanup required as Eigen handles it

    return 0;
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern involving the Eigen library, specifically for matrix operations. The prefix sets up the context by initializing matrices and performing basic operations. The golden completion involves calculating the matrix inverse, which is a less common operation. The suffix includes assertions to verify the correctness of the matrix dimensions and values, ensuring the LLM understands the correct usage and parameter ordering of the Eigen API. This test case is valuable because it involves advanced matrix operations and checks the LLM's ability to handle scientific computing libraries properly.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <mysql_driver.h>
#include <mysql_connection.h>
#include <cppconn/statement.h>
#include <cppconn/resultset.h>
#include <cassert>

void setupDatabase(sql::Connection* conn) {
    try {
        std::unique_ptr<sql::Statement> stmt(conn->createStatement());
        stmt->execute("DROP TABLE IF EXISTS test_table");
        stmt->execute("CREATE TABLE test_table(id INT, data VARCHAR(256))");
        stmt->execute("INSERT INTO test_table(id, data) VALUES (1, 'Hello'), (2, 'World')");
    } catch (sql::SQLException &e) {
        std::cerr << "SQL error: " << e.what() << std::endl;
    }
}

int main() {
    sql::mysql::MySQL_Driver* driver = sql::mysql::get_mysql_driver_instance();
    std::unique_ptr<sql::Connection> conn(driver->connect("tcp://127.0.0.1:3306", "user", "password"));
    conn->setSchema("test");
    setupDatabase(conn.get());

    std::unique_ptr<sql::Statement> stmt(conn->createStatement());


GOLDEN COMPLETION:
----------------------------------------
    stmt->execute("ALTER TABLE test_table ADD COLUMN extra VARCHAR(256)");


SUFFIX CODE:
----------------------------------------
    std::unique_ptr<sql::ResultSet> res(stmt->executeQuery("SELECT * FROM test_table"));
    int rowCount = 0;
    while (res->next()) {
        int id = res->getInt("id");
        std::string data = res->getString("data");
        if (rowCount == 0) {
            assert(id == 1);
            assert(data == "Hello");
        } else if (rowCount == 1) {
            assert(id == 2);
            assert(data == "World");
        }
        rowCount++;
    }
    assert(rowCount == 2);
    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case involves using the MySQL Connector C++ API, specifically to alter a table schema. This API is uncommon in typical C++ programming tasks and involves understanding specific SQL commands and their application through the MySQL Connector API. The scenario sets up a database, creates a table, inserts data, and then alters the table schema. The suffix verifies that the table was modified correctly. This tests the LLM's ability to handle database schema changes and proper API usage within the MySQL Connector C++.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <Eigen/Dense>
#include <cassert>

// Function to initialize a matrix with some values
Eigen::MatrixXd initializeMatrix(int rows, int cols) {
    Eigen::MatrixXd mat(rows, cols);
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            mat(i, j) = i + j;
        }
    }
    return mat;
}

// Function to perform some operations on the matrix
void processMatrix(const Eigen::MatrixXd& mat) {
    std::cout << "Matrix:\n" << mat << std::endl;
    Eigen::MatrixXd matT = mat.transpose();
    std::cout << "Transposed Matrix:\n" << matT << std::endl;
    // Placeholder for more operations
}

int main() {
    int rows = 3;
    int cols = 3;
    // Initialize matrix with values
    Eigen::MatrixXd mat = initializeMatrix(rows, cols);
    // Perform Singular Value Decomposition (SVD)


GOLDEN COMPLETION:
----------------------------------------

    Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);
    Eigen::MatrixXd singularValues = svd.singularValues();
    Eigen::MatrixXd U = svd.matrixU();
    Eigen::MatrixXd V = svd.matrixV();
    std::cout << "Singular values:\n" << singularValues << std::endl;
    std::cout << "U matrix:\n" << U << std::endl;
    std::cout << "V matrix:\n" << V << std::endl;


SUFFIX CODE:
----------------------------------------
    // Perform operations on the matrix
    processMatrix(mat);

    // Verify some properties of the matrix
    assert(mat(0, 0) == 0);
    assert(mat(1, 1) == 2);
    assert(mat(2, 2) == 4);
    assert(mat.transpose()(0, 1) == 1);

    // Clean up resources (if any)

    std::cout << "All assertions passed." << std::endl;
    return 0;
}

JUSTIFICATION:
----------------------------------------
This test case uses the Eigen library for matrix operations, demonstrating the use of Singular Value Decomposition (SVD), an uncommon feature in typical C++ applications. The prefix sets up a matrix and provides utility functions, while the golden completion performs SVD on the matrix. The suffix contains assertions to verify matrix properties and the results of the operations, ensuring the correctness of the code. This scenario tests the LLM's ability to recognize and complete the pattern involving advanced matrix operations with Eigen.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <string>
#include <cassert>
#include <aws/core/Aws.h>
#include <aws/s3/S3Client.h>
#include <aws/s3/model/CreateBucketRequest.h>
#include <aws/s3/model/DeleteBucketRequest.h>

class S3BucketManager {
public:
    S3BucketManager() {
        Aws::SDKOptions options;
        Aws::InitAPI(options);
        client = Aws::MakeShared<Aws::S3::S3Client>("S3Client");
    }

    ~S3BucketManager() {
        Aws::ShutdownAPI(options);
    }

    bool createBucket(const std::string& bucketName) {
        Aws::S3::Model::CreateBucketRequest request;
        request.SetBucket(bucketName.c_str());
        auto outcome = client->CreateBucket(request);
        if (!outcome.IsSuccess()) {
            std::cerr << "Error creating bucket: " << outcome.GetError().GetMessage() << std::endl;
            return false;
        }
        return true;
    }

    bool deleteBucket(const std::string& bucketName) {
        Aws::S3::Model::DeleteBucketRequest request;
        request.SetBucket(bucketName.c_str());
        auto outcome = client->DeleteBucket(request);
        if (!outcome.IsSuccess()) {
            std::cerr << "Error deleting bucket: " << outcome.GetError().GetMessage() << std::endl;
            return false;
        }
        return true;
    }

private:
    Aws::SDKOptions options;
    std::shared_ptr<Aws::S3::S3Client> client;
};

int main() {
    S3BucketManager manager;
    std::string bucketName = "my-test-bucket";


GOLDEN COMPLETION:
----------------------------------------
    bool created = manager.createBucket(bucketName);
    assert(created && "Bucket should be created successfully");
    std::cout << "Bucket created successfully." << std::endl;


SUFFIX CODE:
----------------------------------------
    bool deleted = manager.deleteBucket(bucketName);
    assert(deleted && "Bucket should be deleted successfully");
    std::cout << "Bucket deleted successfully." << std::endl;
    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case evaluates the model's ability to recognize and complete the pattern of using the AWS SDK for C++ to create and delete an S3 bucket. The test demonstrates less common API usage by focusing on the setup, creation, and deletion of an S3 bucket, ensuring proper parameter ordering and handling of API outcomes. The assertions check for successful operations, making it a robust test for understanding and applying the AWS SDK for C++.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <sqlite3.h>
#include <cassert>

class DatabaseManager {
public:
    DatabaseManager(const std::string &db_name) : db(nullptr) {
        int rc = sqlite3_open(db_name.c_str(), &db);
        if (rc) {
            std::cerr << "Can't open database: " << sqlite3_errmsg(db) << std::endl;
            throw std::runtime_error("Failed to open database");
        }
    }

    ~DatabaseManager() {
        if (db) {
            sqlite3_close(db);
        }
    }

    void executeQuery(const std::string &query) {
        char *errmsg = nullptr;
        int rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errmsg);
        if (rc != SQLITE_OK) {
            std::cerr << "SQL error: " << errmsg << std::endl;
            sqlite3_free(errmsg);
            throw std::runtime_error("Failed to execute query");
        }
    }

    sqlite3 *getDB() const { return db; }

private:
    sqlite3 *db;
};

void createTable(DatabaseManager &db_manager) {
    const std::string create_table_query = "CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, value TEXT);";
    db_manager.executeQuery(create_table_query);
}

void insertData(DatabaseManager &db_manager, int id, const std::string &value) {
    std::string insert_query = "INSERT INTO test_table (id, value) VALUES (" + std::to_string(id) + ", '" + value + "');";
    db_manager.executeQuery(insert_query);
}

void fetchData(DatabaseManager &db_manager) {
    const std::string select_query = "SELECT * FROM test_table;";
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(db_manager.getDB(), select_query.c_str(), -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Failed to fetch data: " << sqlite3_errmsg(db_manager.getDB()) << std::endl;
        throw std::runtime_error("Failed to fetch data");
    }

    while (sqlite3_step(stmt) == SQLITE_ROW) {
        int id = sqlite3_column_int(stmt, 0);
        const unsigned char *value = sqlite3_column_text(stmt, 1);
        std::cout << "ID: " << id << ", Value: " << value << std::endl;
    }

    sqlite3_finalize(stmt);
}

int main() {
    try {
        DatabaseManager db_manager("test.db");
        createTable(db_manager);


GOLDEN COMPLETION:
----------------------------------------
        insertData(db_manager, 1, "Test1");
        insertData(db_manager, 2, "Test2");

        // Fetch and verify data
        fetchData(db_manager);


SUFFIX CODE:
----------------------------------------
        // Insert some data into the table
        db_manager.executeQuery("INSERT INTO test_table (id, value) VALUES (1, 'Test1');");
        db_manager.executeQuery("INSERT INTO test_table (id, value) VALUES (2, 'Test2');");

        // Fetch and verify data
        const std::string select_query = "SELECT * FROM test_table;";
        sqlite3_stmt *stmt;
        int rc = sqlite3_prepare_v2(db_manager.getDB(), select_query.c_str(), -1, &stmt, nullptr);
        assert(rc == SQLITE_OK);

        rc = sqlite3_step(stmt);
        assert(rc == SQLITE_ROW);
        assert(sqlite3_column_int(stmt, 0) == 1);
        assert(std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1))) == "Test1");

        rc = sqlite3_step(stmt);
        assert(rc == SQLITE_ROW);
        assert(sqlite3_column_int(stmt, 0) == 2);
        assert(std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1))) == "Test2");

        sqlite3_finalize(stmt);

        // Clean up database
        db_manager.executeQuery("DROP TABLE test_table;");
    } catch (const std::exception &e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case uses the SQLite C++ API to manage a database, create a table, insert data, and fetch data. The use of sqlite3_exec, sqlite3_prepare_v2, sqlite3_step, and sqlite3_finalize demonstrates less common SQLite API functions, including proper resource management and error handling. The assertions check the correctness of the insert and fetch operations, verifying that the correct data is inserted and retrieved. This scenario is a good test case because it covers a comprehensive use of the SQLite API, including setup, execution, and cleanup, while focusing on less common functions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <sqlite3.h>
#include <cassert>

class DatabaseManager {
public:
	DatabaseManager(const std::string& db_name) : db(nullptr) {
		int rc = sqlite3_open(db_name.c_str(), &db);
		if (rc) {
			std::cerr << "Can't open database: " << sqlite3_errmsg(db) << std::endl;
			throw std::runtime_error("Failed to open database");
		}
	}

	~DatabaseManager() {
		if (db) {
			sqlite3_close(db);
		}
	}

	void executeQuery(const std::string& query) {
		char* errmsg = nullptr;
		int rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errmsg);
		if (rc != SQLITE_OK) {
			std::cerr << "SQL error: " << errmsg << std::endl;
			sqlite3_free(errmsg);
			throw std::runtime_error("Failed to execute query");
		}
	}

	int getSingleIntResult(const std::string& query) {
		int result = 0;
		char* errmsg = nullptr;
		int callback(void* data, int argc, char** argv, char** azColName) {
			if (argc > 0) {
				*static_cast<int*>(data) = std::stoi(argv[0]);
			}
			return 0;
		}
		int rc = sqlite3_exec(db, query.c_str(), callback, &result, &errmsg);
		if (rc != SQLITE_OK) {
			std::cerr << "SQL error: " << errmsg << std::endl;
			sqlite3_free(errmsg);
			throw std::runtime_error("Failed to execute query");
		}
		return result;
	}

private:
	sqlite3* db;
};

void setupDatabase(DatabaseManager& dbManager) {
	const std::string createTableQuery = "CREATE TABLE IF NOT EXISTS test (id INT PRIMARY KEY, value INT);";
	const std::string insertDataQuery = "INSERT INTO test (id, value) VALUES (1, 100);";
	dbManager.executeQuery(createTableQuery);
	dbManager.executeQuery(insertDataQuery);
}

int main() {
	try {
		DatabaseManager dbManager("test.db");
		setupDatabase(dbManager);


GOLDEN COMPLETION:
----------------------------------------
		int value = dbManager.getSingleIntResult("SELECT value FROM test WHERE id=1;");


SUFFIX CODE:
----------------------------------------

		assert(value == 100);
	} catch (const std::exception& e) {
		std::cerr << "Exception: " << e.what() << std::endl;
		return 1;
	}
	return 0;
}


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the model's ability to understand and correctly use the SQLite C++ API, specifically focusing on executing SQL queries and retrieving results using callbacks. The prefix sets up a database manager class and initializes a database with a table and data. The golden completion involves writing code to retrieve a value from the database, which is a less common operation involving callback functions. The suffix includes assertions to verify the correctness of the retrieved data, ensuring that the model follows proper API usage and handles exceptions appropriately.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <vector>
#include <armadillo>
#include <cassert>

// Helper function to initialize a matrix
arma::Mat<double> initializeMatrix(int rows, int cols) {
    arma::Mat<double> mat(rows, cols, arma::fill::randu);
    return mat;
}

// Helper function to print matrix
void printMatrix(const arma::Mat<double>& mat) {
    mat.print("Matrix:");
}

int main() {
    // Initialize two matrices using Armadillo
    arma::Mat<double> A = initializeMatrix(3, 3);
    arma::Mat<double> B = initializeMatrix(3, 3);

    // Print initialized matrices
    std::cout << "Matrix A:" << std::endl;
    printMatrix(A);
    std::cout << "Matrix B:" << std::endl;
    printMatrix(B);

    // Perform matrix multiplication
    arma::Mat<double> C;

GOLDEN COMPLETION:
----------------------------------------
    C = A * B;

SUFFIX CODE:
----------------------------------------
    std::cout << "Matrix C (result of multiplication):" << std::endl;
    printMatrix(C);

    // Assertion to verify the size of the result matrix
    assert(C.n_rows == 3);
    assert(C.n_cols == 3);

    // Assertion to verify some properties of the result matrix (example check)
    assert(C(0, 0) > 0);

    // Clean up and exit
    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case is a good benchmark for the LLM's ability to recognize and complete the pattern of using the Armadillo library for scientific computing, specifically matrix operations. Armadillo is a lesser-known library compared to Eigen or BLAS/LAPACK, and using its matrix multiplication function demonstrates proficiency with its API. The prefix sets up the context by initializing and printing matrices, while the suffix includes assertions to verify the correct behavior of the multiplication and properties of the resulting matrix.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: synthbench-api-usage
Language: cpp
================================================================================

PREFIX CODE:
----------------------------------------
#include <iostream>
#include <memory>
#include <opencv2/opencv.hpp>
#include <opencv2/ml.hpp>
#include <cassert>

using namespace cv;
using namespace cv::ml;

class SVMExample {
public:
    SVMExample() {
        // Initialize SVM with some parameters
        svm = SVM::create();
        svm->setKernel(SVM::LINEAR);
        svm->setType(SVM::C_SVC);
        svm->setC(1);
    }

    void train(const Mat& trainingData, const Mat& labels) {
        svm->train(trainingData, ROW_SAMPLE, labels);
    }

    float predict(const Mat& sample) {
        return svm->predict(sample);
    }

private:
    Ptr<SVM> svm;
};

int main() {
    // Create some dummy training data
    Mat trainingData = (Mat_<float>(4, 2) << 1, 2, 2, 3, 3, 4, 4, 5);
    Mat labels = (Mat_<int>(4, 1) << 1, -1, 1, -1);

    SVMExample svmExample;
    svmExample.train(trainingData, labels);

    // Create a sample for prediction
    Mat sample = (Mat_<float>(1, 2) << 3, 4);


GOLDEN COMPLETION:
----------------------------------------
    float response = svmExample.predict(sample);
    assert(response == 1.0f);


SUFFIX CODE:
----------------------------------------


    // Test with another sample
    sample = (Mat_<float>(1, 2) << 1, 2);
    response = svmExample.predict(sample);
    assert(response == 1.0f);

    std::cout << "All assertions passed!" << std::endl;

    return 0;
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of OpenCV's SVM (Support Vector Machine) class, which is part of the machine learning module. The example tests the model's ability to recognize and correctly use the SVM API to train a model and make predictions. The assertions verify that the predictions are as expected based on the given training data. This scenario involves uncommon library functions and requires understanding of parameter ordering and API conventions.

ASSERTIONS:
----------------------------------------

================================================================================
