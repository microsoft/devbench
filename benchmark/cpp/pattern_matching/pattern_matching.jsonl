{"id": "1", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// This example demonstrates algorithm implementation with a focus on higher-order functions\n// Specifically, we are implementing a simple map function and using it in a scientific computing context\n\n// Function to apply a given function to each element of a vector\nstd::vector<double> map(const std::vector<double>& data, double (*func)(double)) {\n    std::vector<double> result;\n    result.reserve(data.size());\n    for (const auto& elem : data) {\n        result.push_back(func(elem));\n    }\n    return result;\n}\n\n// Example function to pass to map: squares a number\ndouble square(double x) {\n    return x * x;\n}\n\n// Example function to pass to map: takes the square root of a number\n#include <cmath>\ndouble sqrt_func(double x) {\n    return std::sqrt(x);\n}\n\n// Example function to pass to map: negates a number\ndouble negate(double x) {\n    return -x;\n}\n\n// Main function demonstrating the usage of map function in scientific computing\nint main() {\n    std::vector<double> data = {1.0, 4.0, 9.0, 16.0};\n\n    // Applying the square function\n    std::vector<double> squared_data = map(data, square);\n    for (const auto& elem : squared_data) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    // Applying the square root function\n    std::vector<double> sqrt_data = map(data, sqrt_func);\n    for (const auto& elem : sqrt_data) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    // Assertions to verify the correctness of the map function\n    assert(squared_data[0] == 1.0);\n    assert(squared_data[1] == 16.0);\n    assert(squared_data[2] == 81.0);\n    assert(squared_data[3] == 256.0);\n\n    assert(sqrt_data[0] == 1.0);\n    assert(sqrt_data[1] == 2.0);\n    assert(sqrt_data[2] == 3.0);\n    assert(sqrt_data[3] == 4.0);\n", "suffix": "    // Assertions to verify the correctness of the negate function\n    assert(negated_data[0] == -1.0);\n    assert(negated_data[1] == -4.0);\n    assert(negated_data[2] == -9.0);\n    assert(negated_data[3] == -16.0);\n\n    return 0;\n}", "golden_completion": "    // Applying the negate function\n    std::vector<double> negated_data = map(data, negate);\n    for (const auto& elem : negated_data) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n", "LLM_justification": "This test case demonstrates the implementation and usage of a higher-order function (map) in a scientific computing context. The map function is used to apply various mathematical transformations to a dataset. The pattern of using the map function with different mathematical operations is established clearly in the prefix. The golden completion maintains this pattern by introducing another mathematical operation and applying it using the map function. This scenario tests the LLM's ability to recognize the established pattern of using the map function and to continue it appropriately.", "assertions": ""}
{"id": "2", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\n// Helper function to calculate mean\ndouble calculateMean(const std::vector<double>& data) {\n    double sum = 0.0;\n    for (double value : data) {\n        sum += value;\n    }\n    return sum / data.size();\n}\n\n// Helper function to calculate variance\ndouble calculateVariance(const std::vector<double>& data, double mean) {\n    double variance = 0.0;\n    for (double value : data) {\n        variance += (value - mean) * (value - mean);\n    }\n    return variance / data.size();\n}\n\n// Function to calculate standard deviation\n", "suffix": "\nint main() {\n    std::vector<double> data = {1.0, 2.0, 3.0, 4.0, 5.0};\n    double mean = calculateMean(data);\n    double variance = calculateVariance(data, mean);\n    double stddev = calculateStandardDeviation(data, mean);\n\n    // Assertions to verify correctness\n    assert(std::abs(mean - 3.0) < 1e-9);\n    assert(std::abs(variance - 2.0) < 1e-9);\n    assert(std::abs(stddev - std::sqrt(2.0)) < 1e-9);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "double calculateStandardDeviation(const std::vector<double>& data, double mean) {\n    double variance = calculateVariance(data, mean);\n    return std::sqrt(variance);\n}", "LLM_justification": "This test case is a good example of pattern matching in algorithm implementation within the context of scientific computing. The prefix establishes a clear pattern by defining functions that calculate mean and variance of a dataset, and the completion logically follows this pattern by defining a function to calculate the standard deviation, using the variance calculated by the previous function. The suffix completes the program by using these functions and includes assertions to verify correctness, ensuring that the completion adheres to the established pattern and produces the expected results.", "assertions": ""}
{"id": "3", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\n// Function to calculate the mean of a vector of doubles\n\ndouble mean(const std::vector<double>& data) {\n    double sum = 0.0;\n    for (double value : data) {\n        sum += value;\n    }\n    return sum / data.size();\n}\n\n// Function to calculate the variance of a vector of doubles\n\ndouble variance(const std::vector<double>& data) {\n    double mean_value = mean(data);\n    double sum = 0.0;\n    for (double value : data) {\n        sum += (value - mean_value) * (value - mean_value);\n    }\n    return sum / data.size();\n}\n\n// Function to calculate the standard deviation of a vector of doubles\n", "suffix": "    return sqrt(variance_value);\n}\n\nint main() {\n    std::vector<double> data = {1.0, 2.0, 3.0, 4.0, 5.0};\n    double std_dev = standard_deviation(data);\n    std::cout << \"Standard Deviation: \" << std_dev << std::endl;\n\n    // Assertions to verify the calculations\n    assert(std::abs(mean(data) - 3.0) < 1e-9);\n    assert(std::abs(variance(data) - 2.0) < 1e-9);\n    assert(std::abs(std_dev - std::sqrt(2.0)) < 1e-9);\n\n    return 0;\n}", "golden_completion": "double standard_deviation(const std::vector<double>& data) {\n    double variance_value = variance(data);", "LLM_justification": "This test case is designed to evaluate the model's ability to recognize and complete a pattern of statistical calculations in C++. The prefix establishes a pattern by defining functions to calculate the mean and variance of a dataset. The golden_completion should follow this pattern by implementing the function to calculate the standard deviation, which naturally builds on the previously defined mean and variance functions. The suffix continues the pattern by using the standard deviation function and adding assertions to verify the correctness of all calculations. This setup tests the model's ability to understand and continue an established pattern in a realistic, domain-specific context.", "assertions": ""}
{"id": "4", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n\nclass Simulation {\npublic:\n    Simulation(int size) : size(size), data(size, 0.0) {}\n\n    void initialize(double value) {\n        std::fill(data.begin(), data.end(), value);\n    }\n\n    void applyTransformation(std::function<double(double)> func) {\n        std::transform(data.begin(), data.end(), data.begin(), func);\n    }\n\n    double computeSum() const {\n        return std::accumulate(data.begin(), data.end(), 0.0);\n    }\n\n    void printData() const {\n        for (double d : data) {\n            std::cout << d << \" \";\n        }\n        std::cout << std::endl;\n    }\n\nprivate:\n    int size;\n    std::vector<double> data;\n};\n\nint main() {\n    Simulation sim(10);\n    sim.initialize(1.0);\n    sim.applyTransformation([](double x) { return x * 2; });\n    double sum = sim.computeSum();\n    assert(sum == 20.0);\n    sim.printData();\n\n    sim.initialize(3.0);\n    sim.applyTransformation([](double x) { return x + 1; });\n", "suffix": "    return 0;\n}\n", "golden_completion": "    sum = sim.computeSum();\n    assert(sum == 40.0);\n    sim.printData();\n", "LLM_justification": "This test case establishes a clear pattern of initializing a simulation, applying a transformation, and computing the sum of the data. The pattern is repeated with different initialization values and transformations, making it easy to identify. The golden completion continues this pattern by computing the sum and asserting its correctness, followed by printing the data. This scenario is realistic for scientific computing, where such transformations and validations are common.", "assertions": ""}
{"id": "5", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\n// Helper function to generate a vector of random numbers\nstd::vector<double> generateRandomNumbers(size_t count, double min, double max) {\n    std::vector<double> numbers(count);\n    std::generate(numbers.begin(), numbers.end(), [min, max]() {\n        return min + static_cast<double>(rand()) / (static_cast<double>(RAND_MAX / (max - min)));\n    });\n    return numbers;\n}\n\n// Function to calculate the mean of a vector of numbers\ndouble calculateMean(const std::vector<double>& numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    return sum / numbers.size();\n}\n\n// Function to calculate the variance of a vector of numbers\ndouble calculateVariance(const std::vector<double>& numbers) {\n    double mean = calculateMean(numbers);\n    double variance = 0.0;\n    for (double num : numbers) {\n        variance += (num - mean) * (num - mean);\n    }\n    return variance / numbers.size();\n}\n\n// Function to calculate the standard deviation of a vector of numbers\n", "suffix": "\n\nint main() {\n    // Generate a vector of random numbers\n    std::vector<double> numbers = generateRandomNumbers(100, 1.0, 100.0);\n\n    // Calculate the mean\n    double mean = calculateMean(numbers);\n    std::cout << \"Mean: \" << mean << std::endl;\n\n    // Calculate the variance\n    double variance = calculateVariance(numbers);\n    std::cout << \"Variance: \" << variance << std::endl;\n\n    // Calculate the standard deviation\n    double stddev = calculateStandardDeviation(numbers);\n    std::cout << \"Standard Deviation: \" << stddev << std::endl;\n\n    // Assertions\n    assert(mean >= 1.0 && mean <= 100.0);\n    assert(variance >= 0.0);\n    assert(stddev >= 0.0);\n\n    return 0;\n}\n", "golden_completion": "double calculateStandardDeviation(const std::vector<double>& numbers) {\n    double variance = calculateVariance(numbers);\n    return std::sqrt(variance);\n}", "LLM_justification": "This test case is a good example for testing pattern matching capabilities as it involves a sequence of functions for statistical calculations (mean, variance, and standard deviation). The pattern of statistical function implementation is evident in the prefix with `calculateMean` and `calculateVariance` functions, and the completion should follow the same pattern to implement `calculateStandardDeviation`. The suffix uses these functions and includes assertions to verify correctness, making it a comprehensive and realistic scenario for scientific computing.", "assertions": ""}
{"id": "6", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n\n// Helper function to generate a sequence of numbers\nstd::vector<int> generate_sequence(int start, int end) {\n    std::vector<int> sequence;\n    for (int i = start; i <= end; ++i) {\n        sequence.push_back(i);\n    }\n    return sequence;\n}\n\n// Function to apply a transformation to each element of the vector\nstd::vector<int> transform_vector(const std::vector<int>& input, std::function<int(int)> transform_func) {\n    std::vector<int> output;\n    for (const auto& elem : input) {\n        output.push_back(transform_func(elem));\n    }\n    return output;\n}\n\n// Function to filter elements of the vector based on a predicate\nstd::vector<int> filter_vector(const std::vector<int>& input, std::function<bool(int)> predicate) {\n    std::vector<int> output;\n    for (const auto& elem : input) {\n        if (predicate(elem)) {\n            output.push_back(elem);\n        }\n    }\n    return output;\n}\n\nint main() {\n    std::vector<int> sequence = generate_sequence(1, 10);\n    std::vector<int> transformed = transform_vector(sequence, [](int x) { return x * 2; });\n    std::vector<int> filtered = filter_vector(transformed, [](int x) { return x % 4 == 0; });\n", "suffix": "    // Apply a new transformation and filter to the sequence\n    std::vector<int> new_transformed = transform_vector(sequence, [](int x) { return x + 5; });\n    std::vector<int> new_filtered = filter_vector(new_transformed, [](int x) { return x > 10; });\n\n    // Assertions to verify the correctness of the transformations and filters\n    assert((new_transformed == std::vector<int>{6, 7, 8, 9, 10, 11, 12, 13, 14, 15}));\n    assert((new_filtered == std::vector<int>{11, 12, 13, 14, 15}));\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    // Apply another transformation and filter to the sequence\n    std::vector<int> more_transformed = transform_vector(sequence, [](int x) { return x - 1; });\n    std::vector<int> more_filtered = filter_vector(more_transformed, [](int x) { return x % 2 == 0; });\n\n    // Assertions to verify the correctness of the transformations and filters\n    assert((more_transformed == std::vector<int>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n    assert((more_filtered == std::vector<int>{0, 2, 4, 6, 8}));\n", "LLM_justification": "This is a good test case because it establishes a clear pattern of using higher-order functions to transform and filter vectors. The golden completion continues this pattern by applying another transformation and filter, and the suffix applies a different transformation and filter. The assertions verify that the transformations and filters are applied correctly, ensuring that the LLM recognizes and continues the pattern appropriately.", "assertions": ""}
{"id": "7", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\n// Function to calculate mean of a vector\nfloat calculate_mean(const std::vector<int>& data) {\n    int sum = 0;\n    for (int value : data) {\n        sum += value;\n    }\n    return static_cast<float>(sum) / data.size();\n}\n\n// Function to calculate variance of a vector\nfloat calculate_variance(const std::vector<int>& data, float mean) {\n    float sum_squared_diff = 0;\n    for (int value : data) {\n        sum_squared_diff += (value - mean) * (value - mean);\n    }\n    return sum_squared_diff / data.size();\n}\n\n// Function to calculate standard deviation of a vector\nfloat calculate_standard_deviation(const std::vector<int>& data, float mean) {\n    float variance = calculate_variance(data, mean);\n    return std::sqrt(variance);\n}\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n    float mean = calculate_mean(data);\n    float standard_deviation = calculate_standard_deviation(data, mean);\n\n    // Assert the calculated mean\n    assert(mean == 3.0f);\n\n    // Assert the calculated standard deviation\n    assert(std::abs(standard_deviation - 1.41421f) < 1e-5f);\n\n    // Further calculations and assertions\n    float variance = calculate_variance(data, mean);\n", "suffix": "    // Calculate the sum of the data\n    int sum = std::accumulate(data.begin(), data.end(), 0);\n    assert(sum == 15);\n\n    // Calculate the maximum value in the data\n    int max_value = *std::max_element(data.begin(), data.end());\n    assert(max_value == 5);\n\n    // Calculate the minimum value in the data\n    int min_value = *std::min_element(data.begin(), data.end());\n    assert(min_value == 1);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    // Assert the calculated variance\n    assert(variance == 2.0f);\n", "LLM_justification": "This test case establishes a pattern of calculating statistical measures of a dataset (mean, variance, standard deviation) and verifying them using assertions. The prefix includes functions to calculate the mean, variance, and standard deviation of a vector of integers. The pattern of calculating a statistical measure and asserting its correctness is repeated multiple times. The golden completion fits this pattern by asserting the correctness of the variance calculation. The suffix continues with additional calculations and assertions, ensuring the pattern is clear and the code is executable.", "assertions": ""}
{"id": "8", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <cassert>\n\n// Logging function\nvoid log(const std::string &message) {\n    std::cout << \"LOG: \" << message << std::endl;\n}\n\n// Template function to apply a higher-order function to each element in a vector\ntemplate <typename T, typename F>\nvoid applyToEach(std::vector<T> &vec, F func) {\n    for (auto &elem : vec) {\n        func(elem);\n    }\n}\n\n// Function to double the value of an integer\nvoid doubleValue(int &n) {\n    n *= 2;\n}\n\n// Function to log the value of an integer\nvoid logValue(int &n) {\n    log(\"Value: \" + std::to_string(n));\n}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    // Applying doubleValue to each element in the vector\n    applyToEach(numbers, doubleValue);\n\n    // Applying logValue to each element in the vector\n    applyToEach(numbers, logValue);\n\n    // Check if the values are correctly doubled\n    assert(numbers[0] == 2);\n    assert(numbers[1] == 4);\n    assert(numbers[2] == 6);\n    assert(numbers[3] == 8);\n    assert(numbers[4] == 10);\n\n    // Apply a lambda function to add 5 to each element\n    applyToEach(numbers, [](int &n) { n += 5; });\n\n    // Check if the values are correctly incremented\n    assert(numbers[0] == 7);\n    assert(numbers[1] == 9);\n    assert(numbers[2] == 11);\n    assert(numbers[3] == 13);\n    assert(numbers[4] == 15);\n\n\n    // Applying another lambda function to subtract 3 from each element\n", "suffix": "\n\n    return 0;\n}", "golden_completion": "\n    applyToEach(numbers, [](int &n) { n -= 3; });\n\n    // Check if the values are correctly decremented\n    assert(numbers[0] == 4);\n    assert(numbers[1] == 6);\n    assert(numbers[2] == 8);\n    assert(numbers[3] == 10);\n    assert(numbers[4] == 12);\n\n    // Clean up and final log\n    applyToEach(numbers, logValue);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of applying higher-order functions to elements in a vector, combined with logging and validation. The established pattern involves using the `applyToEach` function with different operations (doubling values, logging values, modifying values with lambdas). The golden completion follows this pattern by applying another lambda function to further modify the elements and validating the results. The scenario includes realistic system operations (logging) and higher-order function application, making it a practical test for pattern recognition and continuation.", "assertions": ""}
{"id": "9", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// A higher-order function that applies a given function to each element in a vector and returns a new vector\nstd::vector<int> applyFunction(const std::vector<int>& vec, int (*func)(int)) {\n    std::vector<int> result;\n    for (int val : vec) {\n        result.push_back(func(val));\n    }\n    return result;\n}\n\n// A sample function to be used with the higher-order function\nint square(int x) {\n    return x * x;\n}\n\n// Another sample function to be used with the higher-order function\nint cube(int x) {\n    return x * x * x;\n}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    // Apply the square function to each element in the vector\n    std::vector<int> squared = applyFunction(numbers, square);\n\n    // Assertions to verify the correctness of the squared vector\n    assert(squared.size() == numbers.size());\n    assert(squared[0] == 1);\n    assert(squared[1] == 4);\n    assert(squared[2] == 9);\n    assert(squared[3] == 16);\n    assert(squared[4] == 25);\n\n    // Apply the cube function to each element in the vector\n    std::vector<int> cubed = applyFunction(numbers, cube);\n\n    // Assertions to verify the correctness of the cubed vector\n    assert(cubed.size() == numbers.size());\n    assert(cubed[0] == 1);\n    assert(cubed[1] == 8);\n    assert(cubed[2] == 27);\n    assert(cubed[3] == 64);\n    assert(cubed[4] == 125);\n\n    // Apply a custom lambda function to add 10 to each element in the vector\n    std::vector<int> custom;", "suffix": "    std::vector<int> doubled = applyFunction(numbers, [](int x) { return x * 2; });\n\n    // Assertions to verify the correctness of the doubled vector\n    assert(doubled.size() == numbers.size());\n    assert(doubled[0] == 2);\n    assert(doubled[1] == 4);\n    assert(doubled[2] == 6);\n    assert(doubled[3] == 8);\n    assert(doubled[4] == 10);\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    custom = applyFunction(numbers, [](int x) { return x + 10; });\n\n    // Assertions to verify the correctness of the custom vector\n    assert(custom.size() == numbers.size());\n    assert(custom[0] == 11);\n    assert(custom[1] == 12);\n    assert(custom[2] == 13);\n    assert(custom[3] == 14);\n    assert(custom[4] == 15);", "LLM_justification": "This test case demonstrates the use of higher-order functions in C++ for transforming elements in a vector using different functions. The pattern involves applying various functions to a vector using a higher-order function and then verifying the results with assertions. The prefix establishes the pattern by applying both the square and cube functions to a vector and includes assertions to verify the results. The golden completion continues this pattern by applying a custom lambda function to the vector and verifying the results with assertions. This scenario tests the LLM's ability to recognize and continue the established pattern of using higher-order functions and validating their outputs.", "assertions": ""}
{"id": "10", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Function to log messages\nvoid logMessage(const std::string &message) {\n    std::cout << message << std::endl;\n}\n\n// Function to log an error\nvoid logError(const std::string &error) {\n    std::cerr << error << std::endl;\n}\n\n// A generic function to apply logging to another function\nvoid executeWithLogging(const std::function<void()> &func) {\n    try {\n        logMessage(\"Execution started.\");\n        func();\n        logMessage(\"Execution finished.\");\n    } catch (const std::exception &e) {\n        logError(std::string(\"Error: \") + e.what());\n    }\n}\n\n// Sample functions to demonstrate the pattern\nvoid task1() {\n    logMessage(\"Task 1 is running\");\n}\n\nvoid task2() {\n    logMessage(\"Task 2 is running\");\n}\n\nvoid task3() {\n    logMessage(\"Task 3 is running\");\n}\n\nint main() {\n    // Execute tasks with logging\n    executeWithLogging(task1);\n    executeWithLogging(task2);\n", "suffix": "    executeWithLogging([]() { logMessage(\"Task 4 is running\"); });\n\n    // Assertions to verify the pattern\n    assert(true); // If the code reaches here without exceptions, it means the pattern worked correctly\n\n    return 0;\n}\n", "golden_completion": "    executeWithLogging(task3);\n", "LLM_justification": "This test case is a good example of using higher-order functions for logging and error handling in system operations. The pattern involves wrapping task functions with a logging function that logs the start and end of the execution and catches any exceptions. The golden completion continues this pattern by wrapping the third task function with the logging function, ensuring consistency and demonstrating an understanding of the established pattern. The suffix includes an additional example using a lambda function and appropriate assertions to verify that the pattern works as expected.", "assertions": ""}
{"id": "11", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Helper function to print a vector\nvoid printVector(const std::vector<int>& vec) {\n    for (int val : vec) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n}\n\n// Function to apply a transformation to each element\nstd::vector<int> transformVector(const std::vector<int>& input, std::function<int(int)> func) {\n    std::vector<int> result;\n    result.reserve(input.size());\n    for (int val : input) {\n        result.push_back(func(val));\n    }\n    return result;\n}\n\n// Main function\nint main() {\n    // Test data\n    std::vector<int> data = {1, 2, 3, 4, 5};\n\n    // First transformation: doubling values\n    auto doubleFunc = [](int x) { return x * 2; };\n    std::vector<int> doubled = transformVector(data, doubleFunc);\n\n    // Print and assert\n    printVector(doubled);\n    assert(doubled == std::vector<int>({2, 4, 6, 8, 10}));\n\n    // Second transformation: squaring values\n    auto squareFunc = [](int x) { return x * x; };\n    std::vector<int> squared = transformVector(data, squareFunc);\n\n    // Print and assert\n    printVector(squared);\n    assert(squared == std::vector<int>({1, 4, 9, 16, 25}));\n\n    // Third transformation: incrementing values\n    auto incrementFunc = [](int x) { return x + 1; };\n    std::vector<int> incremented = transformVector(data, incrementFunc);\n\n    // Print and assert\n    printVector(incremented);\n    assert(incremented == std::vector<int>({2, 3, 4, 5, 6}));\n\n    // Fourth transformation: halving values\n", "suffix": "\n\n    return 0;\n}\n", "golden_completion": "    auto halveFunc = [](int x) { return x / 2; };\n    std::vector<int> halved = transformVector(data, halveFunc);\n\n    // Print and assert\n    printVector(halved);\n    assert(halved == std::vector<int>({0, 1, 1, 2, 2}));\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue the pattern of applying transformations to a vector using higher-order functions. The prefix establishes a clear pattern of defining a lambda function, passing it to the transformVector function, and then printing and asserting the results. The golden completion requires the LLM to follow this established pattern, while the suffix includes different code that continues the pattern and includes necessary assertions to validate the functionality.", "assertions": ""}
{"id": "12", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// A utility function to print a vector\nvoid printVector(const std::vector<int>& vec) {\n    for (int v : vec) {\n        std::cout << v << \" \";\n    }\n    std::cout << std::endl;\n}\n\n// Example of a higher-order function that takes another function as an argument\nvoid applyFunction(std::vector<int>& vec, std::function<void(int&)> func) {\n    for (int& v : vec) {\n        func(v);\n    }\n}\n\n// A helper function that doubles the input value\nvoid doubleValue(int& val) {\n    val *= 2;\n}\n\n// A helper function that squares the input value\nvoid squareValue(int& val) {\n    val *= val;\n}\n\nint main() {\n    // Initialize a vector of integers\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    // Print the original vector\n    std::cout << \"Original vector: \";\n    printVector(numbers);\n\n    // Apply the doubleValue function to each element in the vector\n    applyFunction(numbers, doubleValue);\n\n    // Print the modified vector\n    std::cout << \"Doubled vector: \";\n    printVector(numbers);\n\n    // Assert that the vector values are doubled\n    assert(numbers[0] == 2);\n    assert(numbers[1] == 4);\n    assert(numbers[2] == 6);\n    assert(numbers[3] == 8);\n    assert(numbers[4] == 10);\n\n    // Apply the squareValue function to each element in the vector\n", "suffix": "    // Print the modified vector after squaring\n    std::cout << \"Squared vector: \";\n    printVector(numbers);\n\n    // Assert that the vector values are squared\n    assert(numbers[0] == 4);\n    assert(numbers[1] == 16);\n    assert(numbers[2] == 36);\n    assert(numbers[3] == 64);\n    assert(numbers[4] == 100);\n\n    return 0;\n}", "golden_completion": "    applyFunction(numbers, squareValue);\n", "LLM_justification": "This example is a good test case for pattern matching in higher-order functions and analytics. It demonstrates the use of a higher-order function to apply different operations on a vector of integers, which is a common scenario in data processing and analytics. The clear pattern is established by the higher-order function `applyFunction` and the subsequent application of specific functions (`doubleValue` and `squareValue`) to transform the data. The golden completion requires the LLM to recognize and continue this pattern by applying another transformation function. The suffix contains assertions to verify that the transformations are correctly applied and the pattern is maintained.", "assertions": ""}
{"id": "13", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Helper function to generate random numbers\nstd::vector<int> generateRandomNumbers(size_t count) {\n    std::vector<int> numbers(count);\n    std::generate(numbers.begin(), numbers.end(), rand);\n    return numbers;\n}\n\n// Function to compute the sum of elements in a vector\nint computeSum(const std::vector<int>& numbers) {\n    int sum = 0;\n    for (int num : numbers) {\n        sum += num;\n    }\n    return sum;\n}\n\n// Higher-order function that applies a given function to each element of a vector\nstd::vector<int> applyFunction(const std::vector<int>& numbers, int (*func)(int)) {\n    std::vector<int> result;\n    result.reserve(numbers.size());\n    for (int num : numbers) {\n        result.push_back(func(num));\n    }\n    return result;\n}\n\n// Example function to be used with applyFunction\nint square(int x) {\n    return x * x;\n}\n\n// Another example function to be used with applyFunction\nint increment(int x) {\n    return x + 1;\n}\n\nint main() {\n    // Generate a vector of random numbers\n    std::vector<int> numbers = generateRandomNumbers(10);\n    \n    // Apply the square function to each element of the vector\n    std::vector<int> squaredNumbers = applyFunction(numbers, square);\n    \n    // Apply the increment function to each element of the vector\n    std::vector<int> incrementedNumbers = applyFunction(numbers, increment);\n\n    // Compute the sum of the original numbers\n    int originalSum = computeSum(numbers);\n    // Compute the sum of the squared numbers\n    int squaredSum = computeSum(squaredNumbers);\n    // Compute the sum of the incremented numbers\n    int incrementedSum = computeSum(incrementedNumbers);\n\n    // Assertions to verify the correctness of the computations\n    assert(originalSum != squaredSum);\n    assert(originalSum != incrementedSum);\n", "suffix": "    assert(squaredSum > originalSum);\n\n    // Clean up resources (if any)\n    // In this case, no dynamic memory allocation is used\n    // so no explicit cleanup is needed\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    assert(incrementedSum > originalSum);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern involving higher-order functions in the context of analytics. The prefix establishes a pattern of generating numbers, applying functions to each element of a vector, and computing the sum of the resulting vectors. The golden completion continues this pattern by adding an assertion that checks the sum of the incremented numbers. The suffix includes additional assertions and ensures that all resources are cleaned up properly. This scenario is realistic and tests the LLM's understanding of higher-order functions and analytics in C++.", "assertions": ""}
{"id": "14", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <cassert>\n\n// Higher-order function that applies a function to each element in a vector\nvoid applyFunction(const std::vector<int>& vec, const std::function<void(int)>& func) {\n    for (int elem : vec) {\n        func(elem);\n    }\n}\n\n// Higher-order function that returns a function to filter elements\nstd::function<bool(int)> createFilter(int threshold) {\n    return [threshold](int value) { return value > threshold; };\n}\n\n// Example higher-order function that returns a function to transform elements\nstd::function<int(int)> createMultiplier(int factor) {\n    return [factor](int value) { return value * factor; };\n}\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n\n    // Apply a lambda function to print each element\n    applyFunction(data, [](int value) {\n        std::cout << value << \" \";\n    });\n    std::cout << std::endl;\n\n    // Create a filter function to filter elements greater than 3\n    std::function<bool(int)> filter = createFilter(3);\n\n    // Create a multiplier function to multiply elements by 2\n    std::function<int(int)> multiplier = createMultiplier(2);\n\n    // Apply the filter function\n    std::vector<int> filteredData;\n    for (int elem : data) {\n        if (filter(elem)) {\n            filteredData.push_back(elem);\n        }\n    }\n\n    // Apply the multiplier function to filtered data\n    std::vector<int> transformedData;\n", "suffix": "\n\n    // Validate the transformed data\n    std::vector<int> expectedData = {8, 10};\n    assert(transformedData == expectedData);\n\n    // Print the transformed data\n    for (int value : transformedData) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n", "golden_completion": "    for (int elem : filteredData) {\n        transformedData.push_back(multiplier(elem));\n    }\n", "LLM_justification": "This test case is a good example of higher-order functions in C++ within the context of data transformation. The prefix establishes a clear pattern of using higher-order functions to create and apply filters and transformations to a dataset. The golden completion follows this pattern by applying the multiplier function to the filtered data, demonstrating the correct continuation of the established pattern. The suffix includes assertions to verify the correct transformation and prints the transformed data, ensuring the code's functionality and adherence to the pattern.", "assertions": ""}
{"id": "15", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Logging function to demonstrate system operations\nvoid log(const std::string& message) {\n    std::cout << \"LOG: \" << message << std::endl;\n}\n\n// A higher-order function that applies a given function to each element of a vector\nvoid applyFunction(std::vector<int>& vec, void(*func)(int&)) {\n    for (int& x : vec) {\n        func(x);\n    }\n}\n\n// Example function to be applied to each element\nvoid increment(int& x) {\n    x += 1;\n}\n\n// Another example function to be applied to each element\nvoid square(int& x) {\n    x *= x;\n}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    log(\"Initial numbers:\");\n    for (int num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    log(\"Incrementing numbers:\");\n    applyFunction(numbers, increment);\n    for (int num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    log(\"Squaring numbers:\");\n    applyFunction(numbers, square);\n    for (int num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n", "suffix": "\n\n    // Assertions to verify the correctness of the transformations\n    assert(numbers[0] == 8);  // 2 incremented to 3, squared to 9, doubled to 18\n    assert(numbers[1] == 18); // 3 incremented to 4, squared to 16, doubled to 32\n    assert(numbers[2] == 32); // 4 incremented to 5, squared to 25, doubled to 50\n    assert(numbers[3] == 50); // 5 incremented to 6, squared to 36, doubled to 72\n    assert(numbers[4] == 72); // 6 incremented to 7, squared to 49, doubled to 98\n\n    log(\"All assertions passed.\");\n    return 0;\n}", "golden_completion": "    log(\"Doubling numbers:\");\n    applyFunction(numbers, [](int& x) { x *= 2; });\n    for (int num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n", "LLM_justification": "This example is a good test case for pattern matching capabilities because it demonstrates the use of higher-order functions in a system operations context. The pattern of applying a function to each element of a vector is clearly established with the 'applyFunction' function and its usage with 'increment' and 'square' functions. The golden completion follows this pattern by introducing another transformation (doubling the numbers) and verifying the results with assertions. This tests the LLM's ability to recognize and continue the established pattern, ensuring consistency and correctness in the application of higher-order functions.", "assertions": ""}
{"id": "16", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// A class to represent a logging system\nclass Logger {\npublic:\n    Logger() {}\n    void log(const std::string &message) {\n        logs.push_back(message);\n    }\n    const std::vector<std::string>& getLogs() const {\n        return logs;\n    }\n    std::vector<std::string>& getLogsForModification() {\n        return logs;\n    }\nprivate:\n    std::vector<std::string> logs;\n};\n\n// A higher-order function that takes another function and applies it to each log entry\nvoid applyToLogs(Logger &logger, void (*func)(std::string&)) {\n    std::vector<std::string>& logs = logger.getLogsForModification();\n    for(auto &log : logs) {\n        func(log);\n    }\n}\n\n// A function to convert log messages to uppercase\nvoid toUpperCase(std::string &str) {\n    std::transform(str.begin(), str.end(), str.begin(), ::toupper);\n}\n\n// A function to add a timestamp prefix to log messages\nvoid addTimestamp(std::string &str) {\n    str = \"[2023-10-01] \" + str;\n}\n\nint main() {\n    Logger logger;\n    logger.log(\"System initialized.\");\n    logger.log(\"User logged in.\");\n    logger.log(\"Error: Invalid password.\");\n\n    // Apply the toUpperCase function to each log entry\n    applyToLogs(logger, toUpperCase);\n\n    // Check if the logs were converted to uppercase\n    const std::vector<std::string>& logs = logger.getLogs();\n    assert(logs[0] == \"SYSTEM INITIALIZED.\");\n    assert(logs[1] == \"USER LOGGED IN.\");\n    assert(logs[2] == \"ERROR: INVALID PASSWORD.\");\n\n    // Apply the addTimestamp function to each log entry\n", "suffix": "\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "    applyToLogs(logger, addTimestamp);\n\n    // Verify if timestamps were added correctly\n    const std::vector<std::string>& logsWithTimestamps = logger.getLogs();\n    assert(logsWithTimestamps[0] == \"[2023-10-01] SYSTEM INITIALIZED.\");\n    assert(logsWithTimestamps[1] == \"[2023-10-01] USER LOGGED IN.\");\n    assert(logsWithTimestamps[2] == \"[2023-10-01] ERROR: INVALID PASSWORD.\");", "LLM_justification": "This test case is a good example of higher-order functions applied to a logging system, which is a common scenario in system operations. The prefix establishes a clear pattern of applying a function to each log entry using the higher-order function `applyToLogs`. The golden completion continues this pattern by correctly applying another transformation function (`addTimestamp`) to the logs. The suffix includes assertions to verify that the pattern was followed correctly and that the log entries were transformed as expected. This scenario tests the model's ability to recognize and continue the pattern of applying functions to log entries.", "assertions": ""}
{"id": "17", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Function to validate email addresses\nbool validate_email(const std::string &email) {\n\t// Simplistic email validation: check for presence of '@' and '.'\n\tsize_t at_pos = email.find('@');\n\tsize_t dot_pos = email.find('.');\n\treturn at_pos != std::string::npos && dot_pos != std::string::npos && at_pos < dot_pos;\n}\n\n// Function to validate phone numbers\nbool validate_phone(const std::string &phone) {\n\t// Simplistic phone validation: check if all characters are digits and the length is 10\n\tif (phone.length() != 10) return false;\n\tfor (char c : phone) {\n\t\tif (!isdigit(c)) return false;\n\t}\n\treturn true;\n}\n\n// Function to validate postal codes\nbool validate_postal_code(const std::string &postal_code) {\n\t// Simplistic postal code validation: check if the length is 5 and all characters are digits\n\tif (postal_code.length() != 5) return false;\n\tfor (char c : postal_code) {\n\t\tif (!isdigit(c)) return false;\n\t}\n\treturn true;\n}\n\n// Main validation function\nbool validate_data(const std::string &email, const std::string &phone, const std::string &postal_code) {\n\treturn validate_email(email) && validate_phone(phone) && ", "suffix": "\n}\n\nint main() {\n\tstd::string email = \"test@example.com\";\n\tstd::string phone = \"1234567890\";\n\tstd::string postal_code = \"12345\";\n\n\tassert(validate_data(email, phone, postal_code) == true);\n\n\tstd::string invalid_email = \"testexample.com\";\n\tstd::string invalid_phone = \"12345abcde\";\n\tstd::string invalid_postal_code = \"1234a\";\n\n\tassert(validate_data(invalid_email, phone, postal_code) == false);\n\tassert(validate_data(email, invalid_phone, postal_code) == false);\n\tassert(validate_data(email, phone, invalid_postal_code) == false);\n\n\tstd::cout << \"All assertions passed.\" << std::endl;\n\treturn 0;\n}\n", "golden_completion": "validate_postal_code(postal_code);", "LLM_justification": "This scenario involves data validation functions for emails, phone numbers, and postal codes, encapsulated in a higher-order function called validate_data. The pattern established is the validation of different data types using specific validation functions. The golden completion correctly follows this pattern by calling the validate_postal_code function within the validate_data function, ensuring all data types are validated. The suffix includes assertions that test various valid and invalid inputs, ensuring the implementation is correct and adheres to the pattern. This provides a robust test case for evaluating pattern recognition and completion capabilities in large language models.", "assertions": ""}
{"id": "18", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Algorithm Implementation for Network Protocols\n// This example demonstrates the implementation of a basic sliding window protocol for reliable data transfer.\n\nclass SlidingWindowProtocol {\npublic:\n    SlidingWindowProtocol(int windowSize) : windowSize(windowSize), nextSeqNum(0), base(0) {}\n\n    bool sendPacket(int packet) {\n        if (nextSeqNum < base + windowSize) {\n            std::cout << \"Sending packet: \" << packet << std::endl;\n            buffer.push_back(packet);\n            nextSeqNum++;\n            return true;\n        } else {\n            std::cerr << \"Window is full. Cannot send packet: \" << packet << std::endl;\n            return false;\n        }\n    }\n\n    bool receiveAck(int ackNum) {\n        if (ackNum >= base) {\n            std::cout << \"Received ACK: \" << ackNum << std::endl;\n            base = ackNum + 1;\n            buffer.erase(buffer.begin(), buffer.begin() + (ackNum - base + 1));\n            return true;\n        } else {\n            std::cerr << \"Received duplicate ACK: \" << ackNum << std::endl;\n            return false;\n        }\n    }\n\n    void printWindow() const {\n        std::cout << \"Current Window: [\";\n        for (int i = base; i < base + windowSize; ++i) {\n            if (i < nextSeqNum) {\n                std::cout << buffer[i - base] << \" \";\n            } else {\n                std::cout << \"_ \";\n            }\n        }\n        std::cout << \"]\\n\";\n    }\n\nprivate:\n    int windowSize;\n    int nextSeqNum;\n    int base;\n    std::vector<int> buffer;\n};\n\nint main() {\n    SlidingWindowProtocol swp(4);\n    swp.sendPacket(1);\n    swp.sendPacket(2);\n    swp.sendPacket(3);\n    swp.sendPacket(4);\n    swp.printWindow();\n    swp.receiveAck(1);\n    swp.printWindow();\n", "suffix": "\n\n    // Assertions to verify correct behavior\n    assert(swp.sendPacket(6) == true);\n    swp.printWindow();\n    assert(swp.receiveAck(3) == true);\n    swp.printWindow();\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    swp.sendPacket(5);\n    swp.printWindow();\n    swp.receiveAck(2);\n    swp.printWindow();\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete the pattern of implementing a sliding window protocol for reliable data transfer in a network context. The pattern includes sending packets, receiving acknowledgments, and managing the window buffer. The golden completion continues the established sequence of sending a packet and updating the window state. The suffix includes assertions to verify the correctness of the implementation, ensuring the LLM follows the pattern accurately. This scenario is realistic for developers working on network protocols and demonstrates the use of C++ features such as classes, vectors, and standard I/O.", "assertions": ""}
{"id": "19", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n\n// Utility function to print vector contents\nvoid printVector(const std::vector<int>& vec) {\n    for (int val : vec) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n}\n\n// Function to apply a transformation to each element of a vector\nstd::vector<int> transformVector(const std::vector<int>& vec, std::function<int(int)> func) {\n    std::vector<int> result;\n    result.reserve(vec.size());\n    std::transform(vec.begin(), vec.end(), std::back_inserter(result), func);\n    return result;\n}\n\n// Higher-order function to generate a lambda that adds a fixed number\nstd::function<int(int)> addGenerator(int toAdd) {\n    return [toAdd](int x) { return x + toAdd; };\n}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    // Apply a transformation to add 5 to each element\n    std::vector<int> addedFive = transformVector(numbers, addGenerator(5));\n    printVector(addedFive);\n    assert(addedFive == std::vector<int>({6, 7, 8, 9, 10}));\n\n    // Apply a transformation to add 10 to each element\n    std::vector<int> addedTen = transformVector(numbers, addGenerator(10));\n    printVector(addedTen);\n    assert(addedTen == std::vector<int>({11, 12, 13, 14, 15}));\n\n    // Apply a transformation to add 20 to each element\n", "suffix": "\n\n    // Clean up resources\n    numbers.clear();\n    addedFive.clear();\n    addedTen.clear();\n    addedTwenty.clear();\n\n    return 0;\n}", "golden_completion": "    std::vector<int> addedTwenty = transformVector(numbers, addGenerator(20));\n    printVector(addedTwenty);\n    assert(addedTwenty == std::vector<int>({21, 22, 23, 24, 25}));\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and continue the pattern of using higher-order functions and lambdas in C++. The prefix establishes a clear pattern with multiple examples of using the transformVector function combined with addGenerator to create lambdas that add a fixed number to each element of a vector. The golden completion follows this pattern by generating a lambda that adds 20, while the suffix provides a different implementation of the same functionality using a direct lambda, ensuring that the code remains executable and all assertions pass.", "assertions": ""}
{"id": "20", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n\n// Function to calculate the sum of a vector\nint sum(const std::vector<int>& v) {\n    return std::accumulate(v.begin(), v.end(), 0);\n}\n\n// Function to calculate the product of a vector\nint product(const std::vector<int>& v) {\n    return std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());\n}\n\n// Higher-order function that applies a given function to each element in a vector\nstd::vector<int> apply_function(const std::vector<int>& v, int (*func)(int)) {\n    std::vector<int> result;\n    result.reserve(v.size());\n    for (int x : v) {\n        result.push_back(func(x));\n    }\n    return result;\n}\n\n// Function to square an integer\nint square(int x) {\n    return x * x;\n}\n\n// Function to double an integer\nint double_value(int x) {\n    return x * 2;\n}\n\n// Analytics functions\nint sum_of_squares(const std::vector<int>& v) {\n    std::vector<int> squared = apply_function(v, square);\n    return sum(squared);\n}\n\nint sum_of_doubles(const std::vector<int>& v) {\n    std::vector<int> doubled = apply_function(v, double_value);\n    return sum(doubled);\n}\n\n", "suffix": "int main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n\n    // Calculate sum of squares\n    int result1 = sum_of_squares(data);\n    assert(result1 == 55); // 1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 55\n\n    // Calculate sum of doubles\n    int result2 = sum_of_doubles(data);\n    assert(result2 == 30); // (1*2) + (2*2) + (3*2) + (4*2) + (5*2) = 30\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "int sum_of_cubes(const std::vector<int>& v) {\n    std::vector<int> cubed = apply_function(v, [](int x) { return x * x * x; });\n    return sum(cubed);\n}\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue the pattern of higher-order functions being used to perform analytics operations on vectors. The prefix establishes a clear pattern of defining functions that transform vectors and then calculate sums of the transformed elements. The golden completion requires the LLM to introduce a similar function, `sum_of_cubes`, which fits naturally within the established pattern. The suffix contains assertions that verify the correctness of the implementation by ensuring the calculated sums match expected values. This scenario is realistic and demonstrates practical usage of higher-order functions in an analytics context.", "assertions": ""}
{"id": "21", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Higher-order function to apply a transformation to each element in a vector\nstd::vector<int> transform(const std::vector<int>& input, int(*func)(int)) {\n    std::vector<int> output;\n    output.reserve(input.size());\n    for (const int& value : input) {\n        output.push_back(func(value));\n    }\n    return output;\n}\n\n// Sample transformation functions\nint square(int x) {\n    return x * x;\n}\n\nint increment(int x) {\n    return x + 1;\n}\n\n// Main function demonstrating the usage of the higher-order transform function\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n\n    // Apply square transformation\n    std::vector<int> squared = transform(data, square);\n    for (const int& value : squared) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n\n    // Apply increment transformation\n    std::vector<int> incremented = transform(data, increment);\n    for (const int& value : incremented) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n\n    // Apply a custom transformation function\n    std::vector<int> customTransformed = transform(data, [](int x) { return x * 2; });\n    for (const int& value : customTransformed) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n\n    // Assertions to verify the transformations\n    assert(squared == std::vector<int>({1, 4, 9, 16, 25}));\n    assert(incremented == std::vector<int>({2, 3, 4, 5, 6}));\n\n    // Custom transformation assertion of multiplication by 3\n", "suffix": "    assert(customTransformed == std::vector<int>({2, 4, 6, 8, 10}));\n\n    // Further transformations to show the pattern\n    std::vector<int> doubled = transform(data, [](int x) { return x * 2; });\n    for (const int& value : doubled) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n\n    assert(doubled == std::vector<int>({2, 4, 6, 8, 10}));\n\n    std::vector<int> halved = transform(data, [](int x) { return x / 2; });\n    for (const int& value : halved) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n\n    assert(halved == std::vector<int>({0, 1, 1, 2, 2}));\n\n    return 0;\n}", "golden_completion": "    assert(customTransformed == std::vector<int>({2, 4, 6, 8, 10}));\n\n    // Additional transformation tests\n    std::vector<int> tripled = transform(data, [](int x) { return x * 3; });\n    for (const int& value : tripled) {\n        std::cout << value << \" \";\n    }\n    std::cout << std::endl;\n\n    assert(tripled == std::vector<int>({3, 6, 9, 12, 15}));\n", "LLM_justification": "This test case is ideal for evaluating an LLM's ability to recognize and complete a pattern involving higher-order functions in C++. The prefix establishes a clear pattern by defining a higher-order function `transform` and using it with different transformation functions. The golden completion extends this pattern by introducing a new transformation, ensuring the model understands how to apply and verify transformations. The suffix continues with additional transformations and assertions, demonstrating the correct pattern continuation and verifying the function's correctness.", "assertions": ""}
{"id": "22", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Function to calculate the sum of squares using a higher-order function pattern\nint sum_of_squares(const std::vector<int>& numbers, std::function<int(int)> transform) {\n    int sum = 0;\n    for (int num : numbers) {\n        sum += transform(num);\n    }\n    return sum;\n}\n\n// Higher-order function to be used\nint square(int x) {\n    return x * x;\n}\n\n// Another higher-order function to be used\nint cube(int x) {\n    return x * x * x;\n}\n\n// Main function demonstrating the pattern\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    \n    // Using sum_of_squares with the square function\n    int sum_squares = sum_of_squares(numbers, square);\n    std::cout << \"Sum of squares: \" << sum_squares << std::endl;\n    assert(sum_squares == 55);\n\n    // Using sum_of_squares with the cube function\n    int sum_cubes = sum_of_squares(numbers, cube);\n    std::cout << \"Sum of cubes: \" << sum_cubes << std::endl;\n    assert(sum_cubes == 225);\n", "suffix": "\n\n    return 0;\n}\n", "golden_completion": "    // Using sum_of_squares with another inline lambda function\n    int sum_quads = sum_of_squares(numbers, [](int x) { return x * x * x * x; });\n    std::cout << \"Sum of fourth powers: \" << sum_quads << std::endl;\n    assert(sum_quads == 979);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern involving higher-order functions in a C++ context. The prefix establishes the use of a higher-order function, `sum_of_squares`, which takes a vector of integers and a transformation function, and applies the transformation to each element. The pattern is clearly demonstrated with two examples using predefined functions `square` and `cube`. The golden completion follows this pattern by using an inline lambda function to compute the sum of fourth powers. The suffix contains a different but similar lambda function to ensure the pattern is continued correctly and includes assertions to validate the results. The example tests the LLM's capability to follow and extend higher-order function usage in a practical scenario.", "assertions": ""}
{"id": "23", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n\n// Higher-order functions example in the context of game mechanics (AI decision making)\n\n// Define a type for AI decision functions\nusing AIDecisionFunc = std::function<bool(int)>;\n\n// A class representing a simple AI entity\nclass AIEntity {\npublic:\n    AIEntity(int health) : health(health) {}\n\n    // Method to add a decision function\n    void addDecisionFunc(AIDecisionFunc func) {\n        decisionFuncs.push_back(func);\n    }\n\n    // Method to make a decision based on the functions added\n    bool makeDecision() {\n        for (const auto& func : decisionFuncs) {\n            if (func(health)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nprivate:\n    int health;\n    std::vector<AIDecisionFunc> decisionFuncs;\n};\n\n// Example decision functions\nbool lowHealthDecision(int health) {\n    return health < 30;\n}\n\nbool highHealthDecision(int health) {\n    return health > 70;\n}\n\nint main() {\n    AIEntity entity(25);\n    entity.addDecisionFunc(lowHealthDecision);\n", "suffix": "    // Add another decision function\n    entity.addDecisionFunc([](int health) { return health == 25; });\n\n    // Make a decision and assert the result\n    assert(entity.makeDecision() == true);\n\n    // Change the health and test again\n    AIEntity entity2(75);\n    entity2.addDecisionFunc(lowHealthDecision);\n    entity2.addDecisionFunc(highHealthDecision);\n    assert(entity2.makeDecision() == true);\n\n    // Test with no matching decision functions\n    AIEntity entity3(50);\n    entity3.addDecisionFunc(lowHealthDecision);\n    entity3.addDecisionFunc(highHealthDecision);\n    assert(entity3.makeDecision() == false);\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    entity.addDecisionFunc(highHealthDecision);\n    assert(entity.makeDecision() == true);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving higher-order functions in the context of game mechanics (AI decision making). The prefix establishes a pattern of adding decision functions to an AI entity and then making decisions based on those functions. The golden completion follows this pattern by adding another decision function and asserting the result, ensuring consistency with the established pattern. The suffix continues testing with different scenarios, ensuring the pattern is maintained and all assertions pass.", "assertions": ""}
{"id": "24", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Function to generate a sequence of numbers\nstd::vector<int> generateSequence(int start, int end) {\n\tstd::vector<int> sequence;\n\tfor(int i = start; i <= end; ++i) {\n\t\tsequence.push_back(i);\n\t}\n\treturn sequence;\n}\n\n// Function to apply a transformation to each element of a vector\nstd::vector<int> transformSequence(const std::vector<int>& sequence, int (*transform)(int)) {\n\tstd::vector<int> transformed;\n\tfor(int num : sequence) {\n\t\ttransformed.push_back(transform(num));\n\t}\n\treturn transformed;\n}\n\n// Example transformations\nint square(int x) {\n\treturn x * x;\n}\n\nint increment(int x) {\n\treturn x + 1;\n}\n\n// Function to print a sequence\nvoid printSequence(const std::vector<int>& sequence) {\n\tfor(int num : sequence) {\n\t\tstd::cout << num << \" \";\n\t}\n\tstd::cout << std::endl;\n}\n\nint main() {\n\tstd::vector<int> sequence = generateSequence(1, 5);\n\tstd::vector<int> squaredSequence = transformSequence(sequence, square);\n\tstd::vector<int> incrementedSequence = transformSequence(sequence, increment);\n\t// Print the sequences", "suffix": "\n\tprintSequence(squaredSequence);\n\tprintSequence(incrementedSequence);\n\t// Assertions\n\tassert((squaredSequence == std::vector<int>{1, 4, 9, 16, 25}));\n\tassert((incrementedSequence == std::vector<int>{2, 3, 4, 5, 6}));\n\t// Cleanup code if any\n\treturn 0;\n}", "golden_completion": "\tprintSequence(sequence);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue a pattern of generating, transforming, and printing sequences. The pattern is established through the functions for generating a sequence, applying transformations, and printing the sequence. The golden completion should insert the missing step of printing the original sequence, while the suffix continues with printing transformed sequences and includes assertions to verify correctness.", "assertions": ""}
{"id": "25", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// A generic higher-order function that applies a given function to each element in the vector\n// and returns a new vector with the results.\ntemplate <typename T, typename Func>\nstd::vector<T> applyFunction(const std::vector<T>& vec, Func func) {\n    std::vector<T> result;\n    result.reserve(vec.size());\n    for (const auto& elem : vec) {\n        result.push_back(func(elem));\n    }\n    return result;\n}\n\n// Example functions to use with applyFunction\nint square(int x) {\n    return x * x;\n}\n\nint increment(int x) {\n    return x + 1;\n}\n\nint negate(int x) {\n    return -x;\n}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    // Apply the square function to each element in the vector\n    std::vector<int> squaredNumbers = applyFunction(numbers, square);\n    // Apply the increment function to each element in the vector\n    std::vector<int> incrementedNumbers = applyFunction(numbers, increment);\n", "suffix": "\n\n    // Assertions to verify the correctness of the operations\n    assert(squaredNumbers == std::vector<int>({1, 4, 9, 16, 25}));\n    assert(incrementedNumbers == std::vector<int>({2, 3, 4, 5, 6}));\n    assert(negatedNumbers == std::vector<int>({-1, -2, -3, -4, -5}));\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    // Apply the negate function to each element in the vector\n    std::vector<int> negatedNumbers = applyFunction(numbers, negate);\n", "LLM_justification": "This test case is a good example for testing pattern matching in higher-order functions within the context of analytics. The prefix establishes a clear pattern of applying different functions to a vector of integers using a higher-order function template. The golden completion follows this pattern by applying another function (negate) to the same vector. The suffix includes assertions that verify the correctness of the operations, ensuring that the pattern is correctly identified and followed.", "assertions": ""}
{"id": "26", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Function to filter even numbers from a vector and apply a transformation\nstd::vector<int> filterAndTransform(const std::vector<int>& input, std::function<int(int)> transform) {\n    std::vector<int> result;\n    for (int num : input) {\n        if (num % 2 == 0) {\n            result.push_back(transform(num));\n        }\n    }\n    return result;\n}\n\n// Helper function to double a number\nint doubleNumber(int x) {\n    return x * 2;\n}\n\n// Another helper function to triple a number\nint tripleNumber(int x) {\n    return x * 3;\n}\n\n// Main function to test the pattern\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5, 6};\n\n    // Applying the doubleNumber transformation\n    std::vector<int> doubled = filterAndTransform(numbers, doubleNumber);\n    for (int num : doubled) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Assertions to verify the pattern\n    assert((doubled == std::vector<int>{4, 8, 12}));\n\n    // Applying the tripleNumber transformation\n", "suffix": "\n\n    return 0;\n}\n", "golden_completion": "    std::vector<int> tripled = filterAndTransform(numbers, tripleNumber);\n    for (int num : tripled) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Assertions to verify the pattern\n    assert((tripled == std::vector<int>{6, 12, 18}));\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving higher-order functions and algorithm implementation in C++. The pattern established is the use of a function to filter and transform elements of a vector based on a given transformation function. The golden completion demonstrates continuing this pattern with a new transformation function, and the suffix includes assertions to verify the correct behavior. This tests the model's understanding of higher-order functions, proper use of STL algorithms, and pattern recognition in function usage.", "assertions": ""}
{"id": "27", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n// Template metaprogramming for a simple fixed-size array\n// Demonstrating the pattern of a fixed-size array with a custom allocator\n\n// Custom allocator for our fixed-size array\ntemplate <typename T, size_t N>\nclass FixedSizeAllocator {\npublic:\n    FixedSizeAllocator() {\n        data_ = new T[N];\n    }\n    ~FixedSizeAllocator() {\n        delete[] data_;\n    }\n    T* allocate(size_t n) {\n        if (n > N) throw std::bad_alloc();\n        return data_;\n    }\n    void deallocate(T* p, size_t n) {}\nprivate:\n    T* data_;\n};\n\n// Fixed-size array implementation\ntemplate <typename T, size_t N, typename Allocator = FixedSizeAllocator<T, N>>\nclass FixedSizeArray {\npublic:\n    FixedSizeArray() : size_(0), allocator_() {\n        data_ = allocator_.allocate(N);\n    }\n    ~FixedSizeArray() {\n        allocator_.deallocate(data_, N);\n    }\n    void push_back(const T& value) {\n        if (size_ >= N) throw std::out_of_range(\"Array is full\");\n        data_[size_++] = value;\n    }\n    T& operator[](size_t index) {\n        if (index >= size_) throw std::out_of_range(\"Index out of range\");\n        return data_[index];\n    }\n    const T& operator[](size_t index) const {\n        if (index >= size_) throw std::out_of_range(\"Index out of range\");\n        return data_[index];\n    }\n    size_t size() const { return size_; }\nprivate:\n    T* data_;\n    size_t size_;\n    Allocator allocator_;\n};\n\nint main() {\n    FixedSizeArray<int, 5> array;\n    array.push_back(1);\n    array.push_back(2);\n    array.push_back(3);\n    array.push_back(4);\n    // The pattern of using push_back to add elements to the array\n    // The pattern of accessing elements using operator[]\n    assert(array.size() == 4);\n    assert(array[0] == 1);\n    assert(array[1] == 2);\n    assert(array[2] == 3);\n    assert(array[3] == 4);\n", "suffix": "\n    // Ensure that adding another element throws an exception\n    try {\n        array.push_back(6);\n        assert(false); // This should not be reached\n    } catch (const std::out_of_range& e) {\n        assert(true); // Exception should be thrown\n    }\n    // Clean up (though in this case, cleanup is automatic)\n    return 0;\n}", "golden_completion": "    array.push_back(5);\n    assert(array.size() == 5);\n    assert(array[4] == 5);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern related to template metaprogramming and fixed-size array management. The pattern involves using a custom allocator with a fixed-size array template, pushing back elements, and accessing them via operator[]. The golden completion should continue the pattern of pushing back elements and asserting their values. The suffix then includes additional pattern usage and ensures exception handling is tested, verifying the robustness of the implementation.", "assertions": ""}
{"id": "28", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n\n// Function to calculate the sum of elements in a vector\nint sum(const std::vector<int>& vec) {\n    return std::accumulate(vec.begin(), vec.end(), 0);\n}\n\n// Function to calculate the product of elements in a vector\nint product(const std::vector<int>& vec) {\n    return std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());\n}\n\n// Function to calculate the maximum element in a vector\nint max_element(const std::vector<int>& vec) {\n    return *std::max_element(vec.begin(), vec.end());\n}\n\n// Function to calculate the minimum element in a vector\nint min_element(const std::vector<int>& vec) {\n    return *std::min_element(vec.begin(), vec.end());\n}\n\n// Function to calculate the average of elements in a vector\n", "suffix": "int main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n\n    // Test the sum function\n    assert(sum(data) == 15);\n\n    // Test the product function\n    assert(product(data) == 120);\n\n    // Test the maximum element function\n    assert(max_element(data) == 5);\n\n    // Test the minimum element function\n    assert(min_element(data) == 1);\n\n    // Test the average function\n    assert(average(data) == 3.0);\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "double average(const std::vector<int>& vec) {\n    return static_cast<double>(sum(vec)) / vec.size();\n}\n", "LLM_justification": "This test case is designed to assess the model's ability to recognize and complete a pattern involving the implementation of simple mathematical operations on vectors using C++ STL algorithms. The prefix establishes a clear pattern with functions calculating sum, product, maximum, and minimum elements of a vector. The golden completion should implement a similar function to calculate the average of elements in a vector, maintaining consistency with the existing pattern. The suffix includes assertions to verify the correctness of all functions, ensuring the model follows the established pattern and best practices.", "assertions": ""}
{"id": "29", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// This class defines a simple AI state machine for a game character\nclass GameCharacter {\npublic:\n    enum class State { IDLE, WALKING, RUNNING, JUMPING };\n\n    GameCharacter() : current_state(State::IDLE) {}\n\n    void setState(State state) {\n        current_state = state;\n    }\n\n    State getState() const {\n        return current_state;\n    }\n\nprivate:\n    State current_state;\n};\n\n// Higher-order function to apply a state change to a vector of game characters\nvoid applyStateChange(std::vector<GameCharacter>& characters, void (*stateChangeFunc)(GameCharacter&)) {\n    for (auto& character : characters) {\n        stateChangeFunc(character);\n    }\n}\n\n// Example state change functions\nvoid makeIdle(GameCharacter& character) {\n    character.setState(GameCharacter::State::IDLE);\n}\n\nvoid makeWalking(GameCharacter& character) {\n    character.setState(GameCharacter::State::WALKING);\n}\n\nvoid makeRunning(GameCharacter& character) {\n    character.setState(GameCharacter::State::RUNNING);\n}\n\nint main() {\n    std::vector<GameCharacter> characters(3);\n\n    // Apply the 'makeWalking' state change to all characters\n    applyStateChange(characters, makeWalking);\n    for (const auto& character : characters) {\n        assert(character.getState() == GameCharacter::State::WALKING);\n    }\n", "suffix": "\n    // Apply the 'makeRunning' state change to all characters\n    applyStateChange(characters, [](GameCharacter& character) { character.setState(GameCharacter::State::RUNNING); });\n    for (const auto& character : characters) {\n        assert(character.getState() == GameCharacter::State::RUNNING);\n    }\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    // Apply the 'makeIdle' state change to all characters\n    applyStateChange(characters, makeIdle);\n    for (const auto& character : characters) {\n        assert(character.getState() == GameCharacter::State::IDLE);\n    }\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue the pattern of applying state changes to a collection of game characters using higher-order functions. The prefix establishes the pattern with multiple examples, and the golden completion should correctly follow this pattern to ensure consistency. The suffix contains assertions that validate the correctness of the state changes applied to the characters, making it a robust test case.", "assertions": ""}
{"id": "30", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n// Class representing a message\nclass Message {\npublic:\n    std::string sender;\n    std::string recipient;\n    std::string content;\n\n    Message(const std::string& sender, const std::string& recipient, const std::string& content)\n        : sender(sender), recipient(recipient), content(content) {}\n};\n\n// Class representing a message queue\nclass MessageQueue {\nprivate:\n    std::vector<Message> queue;\npublic:\n    void addMessage(const Message& msg) {\n        queue.push_back(msg);\n    }\n\n    Message getMessage() {\n        if (queue.empty()) {\n            throw std::out_of_range(\"No messages in queue\");\n        }\n        Message msg = queue.front();\n        queue.erase(queue.begin());\n        return msg;\n    }\n\n    bool isEmpty() const {\n        return queue.empty();\n    }\n};\n\n// Function to simulate sending messages\nvoid simulateSendingMessages(MessageQueue& mq) {\n    mq.addMessage(Message(\"Alice\", \"Bob\", \"Hello Bob!\"));\n    mq.addMessage(Message(\"Bob\", \"Alice\", \"Hi Alice!\"));\n    mq.addMessage(Message(\"Alice\", \"Bob\", \"How are you?\"));\n}\n\n// Function to simulate receiving messages\nvoid simulateReceivingMessages(MessageQueue& mq) {\n    while (!mq.isEmpty()) {\n        Message msg = mq.getMessage();\n        std::cout << \"Message from \" << msg.sender << \" to \" << msg.recipient << \": \" << msg.content << std::endl;\n    }\n}\n\nint main() {\n    MessageQueue mq;\n    simulateSendingMessages(mq);\n    // Simulate receiving messages\n", "suffix": "    try {\n        while (true) {\n            Message msg = mq.getMessage();\n            std::cout << \"Message from \" << msg.sender << \" to \" << msg.recipient << \": \" << msg.content << std::endl;\n        }\n    } catch (const std::out_of_range&) {\n        std::cout << \"No more messages.\" << std::endl;\n    }\n\n    // Assertions\n    assert(mq.isEmpty());\n\n    MessageQueue mq2;\n    simulateSendingMessages(mq2);\n    assert(!mq2.isEmpty());\n    Message msg1 = mq2.getMessage();\n    assert(msg1.sender == \"Alice\");\n    assert(msg1.recipient == \"Bob\");\n    assert(msg1.content == \"Hello Bob!\");\n\n    Message msg2 = mq2.getMessage();\n    assert(msg2.sender == \"Bob\");\n    assert(msg2.recipient == \"Alice\");\n    assert(msg2.content == \"Hi Alice!\");\n\n    Message msg3 = mq2.getMessage();\n    assert(msg3.sender == \"Alice\");\n    assert(msg3.recipient == \"Bob\");\n    assert(msg3.content == \"How are you?\");\n\n    assert(mq2.isEmpty());\n\n    return 0;\n}", "golden_completion": "    simulateReceivingMessages(mq);", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue a pattern involving message queue operations in the context of network protocols. The prefix establishes a clear pattern of sending and receiving messages using a MessageQueue class. The golden completion requires the LLM to recognize this pattern and call the appropriate function to simulate receiving messages. The suffix then includes robust assertions to verify the pattern adherence and functionality, ensuring the message queue is correctly manipulated and the messages are accurately processed.", "assertions": ""}
{"id": "31", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// This is a simple game AI state machine\n// The AI can be in one of several states: Idle, Patrol, Attack\n// Each state has a unique behavior\n\nenum class AIState {\n    Idle,\n    Patrol,\n    Attack\n};\n\nclass AI {\npublic:\n    AI() : state(AIState::Idle) {}\n\n    void update() {\n        switch (state) {\n            case AIState::Idle:\n                idleBehavior();\n                break;\n            case AIState::Patrol:\n                patrolBehavior();\n                break;\n            case AIState::Attack:\n                attackBehavior();\n                break;\n        }\n    }\n\n    void setState(AIState newState) {\n        state = newState;\n    }\n\nprivate:\n    AIState state;\n\n    void idleBehavior() {\n        std::cout << \"AI is idling...\" << std::endl;\n    }\n\n    void patrolBehavior() {\n        std::cout << \"AI is patrolling...\" << std::endl;\n    }\n\n    void attackBehavior() {\n        std::cout << \"AI is attacking!\" << std::endl;\n    }\n};\n\nvoid testAI() {\n    AI ai;\n    ai.setState(AIState::Idle);\n    ai.update();\n    ai.setState(AIState::Patrol);\n    ai.update();\n", "suffix": "\n    // Assertions to verify correct state behavior\n    assert(true); // We would normally check output or state here\n}\n\nint main() {\n    testAI();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    ai.setState(AIState::Attack);\n    ai.update();\n", "LLM_justification": "This example tests the LLM's ability to recognize a pattern in a state machine implementation in a game AI context. The pattern involves setting the AI state and calling the update method, which triggers different behaviors based on the state. The golden completion follows the established pattern of setting a state and updating the AI. Assertions in the suffix verify the correct sequence of state changes and behaviors.", "assertions": ""}
{"id": "32", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <functional>\n#include <cassert>\n\n// Higher-order function to apply an operation multiple times\nstd::function<int(int)> create_multiplier(int factor) {\n    return [factor](int value) {\n        return value * factor;\n    };\n}\n\n// Higher-order function to apply a transformation to each element in an array\nstd::function<void(int*, int, std::function<int(int)>)> apply_transformation = [](int* array, int size, std::function<int(int)> transformation) {\n    for (int i = 0; i < size; ++i) {\n        array[i] = transformation(array[i]);\n    }\n};\n\n// Function to print an array\nvoid print_array(int* array, int size) {\n    for (int i = 0; i < size; ++i) {\n        std::cout << array[i] << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    int data[5] = {1, 2, 3, 4, 5};\n\n    // Create a multiplier function\n    std::function<int(int)> multiply_by_2 = create_multiplier(2);\n\n    // Apply the transformation to the array\n    apply_transformation(data, 5, multiply_by_2);\n\n    // Print the transformed array\n    print_array(data, 5);\n\n    // Assert the transformed values\n    assert(data[0] == 2);\n    assert(data[1] == 4);\n    assert(data[2] == 6);\n    assert(data[3] == 8);\n    assert(data[4] == 10);\n\n    // Create another multiplier function\n    std::function<int(int)> multiply_by_3 = create_multiplier(3);\n\n    // Apply the transformation to the array\n    apply_transformation(data, 5, multiply_by_3);\n\n    // Print the transformed array\n    print_array(data, 5);\n\n    // Assert the transformed values\n    assert(data[0] == 6);\n    assert(data[1] == 12);\n    assert(data[2] == 18);\n    assert(data[3] == 24);\n    assert(data[4] == 30);\n\n    // Reset the array to original values\n    int original_data[5] = {1, 2, 3, 4, 5};\n    for (int i = 0; i < 5; ++i) {\n        data[i] = original_data[i];\n    }\n", "suffix": "    // Create a multiplier function with factor 4\n    std::function<int(int)> multiply_by_4 = create_multiplier(4);\n\n    // Apply the transformation to the array\n    apply_transformation(data, 5, multiply_by_4);\n\n    // Print the transformed array\n    print_array(data, 5);\n\n    // Assert the transformed values\n    assert(data[0] == 4);\n    assert(data[1] == 8);\n    assert(data[2] == 12);\n    assert(data[3] == 16);\n    assert(data[4] == 20);\n\n    return 0;\n}\n", "golden_completion": "    // Create another multiplier function with factor 5\n    std::function<int(int)> multiply_by_5 = create_multiplier(5);\n\n    // Apply the transformation to the array\n    apply_transformation(data, 5, multiply_by_5);\n\n    // Print the transformed array\n    print_array(data, 5);\n\n    // Assert the transformed values\n    assert(data[0] == 5);\n    assert(data[1] == 10);\n    assert(data[2] == 15);\n    assert(data[3] == 20);\n    assert(data[4] == 25);\n\n    // Reset the array to original values\n    for (int i = 0; i < 5; ++i) {\n        data[i] = original_data[i];\n    }\n", "LLM_justification": "This test case establishes a clear pattern of using higher-order functions to create multipliers and apply transformations to an array. The pattern is demonstrated by creating different multiplier functions and applying them to the array, followed by assertions to verify the results. The golden completion follows the established pattern by creating another multiplier function and applying it to the array. This tests the LLM's ability to recognize and continue the pattern correctly. The suffix contains different transformation values and ensures that assertions verify the expected results. The pattern is specific enough that random code wouldn't work, making it a good test case for pattern matching.", "assertions": ""}
{"id": "33", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// A class representing a simple 2D point\nclass Point {\npublic:\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\n// A utility function to print a vector of points\nvoid printPoints(const std::vector<Point>& points) {\n    for (const auto& point : points) {\n        std::cout << '(' << point.x << \", \" << point.y << \")\\n\";\n    }\n}\n\n// A higher-order function to sort points based on a custom comparator\nstd::vector<Point> sortPoints(const std::vector<Point>& points, std::function<bool(const Point&, const Point&)> comparator) {\n    std::vector<Point> sortedPoints = points;\n    std::sort(sortedPoints.begin(), sortedPoints.end(), comparator);\n    return sortedPoints;\n}\n\n// Example usage\nint main() {\n    std::vector<Point> points = { {3, 4}, {1, 2}, {5, 1}, {4, 3} };\n\n    // Sort points by x-coordinate\n    auto sortedByX = sortPoints(points, [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n    printPoints(sortedByX);\n\n    // Sort points by y-coordinate\n    auto sortedByY = sortPoints(points, [](const Point& a, const Point& b) {\n        return a.y < b.y;\n    });\n    printPoints(sortedByY);\n\n    // Sort points by the sum of coordinates", "suffix": "\n    assert(sortedBySum[0].x == 1 && sortedBySum[0].y == 2);\n    assert(sortedBySum[1].x == 5 && sortedBySum[1].y == 1);\n    assert(sortedBySum[2].x == 3 && sortedBySum[2].y == 4);\n    assert(sortedBySum[3].x == 4 && sortedBySum[3].y == 3);\n\n    return 0;\n}", "golden_completion": "\n    auto sortedBySum = sortPoints(points, [](const Point& a, const Point& b) {\n        return (a.x + a.y) < (b.x + b.y);\n    });\n    printPoints(sortedBySum);", "LLM_justification": "This test case is designed to evaluate an LLM's ability to recognize and continue a pattern involving higher-order functions and custom sorting. The prefix establishes a clear pattern of sorting a vector of Points based on different criteria using lambda functions. The golden completion follows this pattern by introducing a new sorting criterion based on the sum of the coordinates. The suffix then continues by adding assertions to verify the correctness of the sorting operation. This scenario is realistic and common in C++ programming, where sorting based on custom criteria is frequently needed.", "assertions": ""}
{"id": "34", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Utility function to calculate the average of a vector of numbers\nfloat calculate_average(const std::vector<int>& numbers) {\n    int sum = 0;\n    for (int num : numbers) {\n        sum += num;\n    }\n    return static_cast<float>(sum) / numbers.size();\n}\n\n// Higher-order function to apply a provided function to each element of a vector\nstd::vector<float> apply_to_each(const std::vector<int>& numbers, float (*func)(const std::vector<int>&)) {\n    std::vector<float> results;\n    for (const int& num : numbers) {\n        results.push_back(func(std::vector<int>{num}));\n    }\n    return results;\n}\n\n// Function to find the maximum value in a vector\nint find_max(const std::vector<int>& numbers) {\n    return *std::max_element(numbers.begin(), numbers.end());\n}\n\n// Function to find the minimum value in a vector\nint find_min(const std::vector<int>& numbers) {\n    return *std::min_element(numbers.begin(), numbers.end());\n}\n\n// Higher-order function to apply a provided function to each element of a vector and calculate differences\nstd::vector<int> apply_and_calculate_difference(const std::vector<int>& numbers, int (*func)(const std::vector<int>&)) {\n    std::vector<int> differences;\n    for (const int& num : numbers) {\n        differences.push_back(num - func(numbers));\n    }\n    return differences;\n}\n\nint main() {\n    std::vector<int> data = {10, 20, 30, 40, 50};\n    \n    // Applying calculate_average function to each element of the vector\n    std::vector<float> averages = apply_to_each(data, calculate_average);\n    for (const auto& avg : averages) {\n        std::cout << \"Average: \" << avg << std::endl;\n    }\n\n", "suffix": "    // Applying find_min function to each element of the vector and calculating differences\n    std::vector<int> min_differences = apply_and_calculate_difference(data, find_min);\n    for (const auto& diff : min_differences) {\n        std::cout << \"Min Difference: \" << diff << std::endl;\n    }\n\n    assert(min_differences.size() == data.size());\n    assert(min_differences[0] == data[0] - 10);\n    assert(min_differences[1] == data[1] - 10);\n    assert(min_differences[2] == data[2] - 10);\n    assert(min_differences[3] == data[3] - 10);\n    assert(min_differences[4] == data[4] - 10);\n\n    return 0;\n}", "golden_completion": "    // Applying find_max function to each element of the vector and calculating differences\n    std::vector<int> max_differences = apply_and_calculate_difference(data, find_max);\n    for (const auto& diff : max_differences) {\n        std::cout << \"Max Difference: \" << diff << std::endl;\n    }\n\n    assert(max_differences.size() == data.size());\n    assert(max_differences[0] == data[0] - 50);\n    assert(max_differences[1] == data[1] - 50);\n    assert(max_differences[2] == data[2] - 50);\n    assert(max_differences[3] == data[3] - 50);\n    assert(max_differences[4] == data[4] - 50);\n", "LLM_justification": "This example demonstrates the use of higher-order functions in C++ and the pattern of applying a function to each element of a vector and calculating differences. The prefix establishes the pattern with multiple examples of higher-order function usage. The golden completion follows the established pattern by applying a different function (find_max) to each element of the vector and calculating differences, which is consistent with the prior pattern. The suffix continues the pattern with another function (find_min) and includes assertions to verify correct behavior.", "assertions": ""}
{"id": "35", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// Function to simulate a network request\nstd::string makeNetworkRequest(const std::string& endpoint) {\n    // Mocked network request response\n    if (endpoint == \"/data\") {\n        return \"{\\\"value\\\": 42}\";\n    }\n    return \"{}\";\n}\n\n// Higher-order function to process network request\nstd::string processRequest(const std::string& endpoint, const std::function<std::string(const std::string&)>& handler) {\n    std::string response = makeNetworkRequest(endpoint);\n    return handler(response);\n}\n\n// Function to extract a value from JSON response (mocked)\nstd::string extractValue(const std::string& jsonResponse) {\n    if (jsonResponse == \"{\\\"value\\\": 42}\") {\n        return \"42\";\n    }\n    return \"0\";\n}\n\n// Function to log a message\nvoid logMessage(const std::string& message) {\n    std::cout << \"Log: \" << message << std::endl;\n}\n\n// Higher-order function pattern usage\nvoid fetchDataAndLog() {\n    std::string endpoint = \"/data\";\n    std::string value = processRequest(endpoint, extractValue);\n    logMessage(\"Fetched value: \" + value);\n}\n\nint main() {\n    fetchDataAndLog();\n", "suffix": "    // Assertion to check if the value fetched is correct\n    std::string expected = \"42\";\n    std::string actual = processRequest(\"/data\", extractValue);\n    assert(actual == expected);\n\n    // Additional request to ensure pattern consistency\n    std::string anotherValue = processRequest(\"/invalid\", extractValue);\n    assert(anotherValue == \"0\");\n\n    // Ensure the log message is correct (mocked)\n    fetchDataAndLog(); // This should print \"Fetched value: 42\"\n\n    return 0;\n}", "golden_completion": "    std::string endpoint = \"/data\";\n    std::string value = processRequest(endpoint, extractValue);\n    logMessage(\"Fetched value: \" + value);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a higher-order function pattern in a network request context. The prefix establishes the pattern by defining functions for making network requests, processing the responses, and using higher-order functions to handle responses. The golden completion continues this pattern by demonstrating the usage of these functions to fetch and log data. The suffix includes assertions to verify the correctness of the function outputs and ensures the higher-order function pattern is correctly implemented.", "assertions": ""}
{"id": "36", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Template metaprogramming example\n// Function to compute factorial at compile time\nconstexpr int factorial(int n) {\n    return (n <= 1) ? 1 : (n * factorial(n - 1));\n}\n\n// Template metaprogramming to compute Fibonacci numbers at compile time\ntemplate <int N>\nstruct Fibonacci {\n    static constexpr int value = Fibonacci<N - 1>::value + Fibonacci<N - 2>::value;\n};\n\ntemplate <>\nstruct Fibonacci<0> {\n    static constexpr int value = 0;\n};\n\ntemplate <>\nstruct Fibonacci<1> {\n    static constexpr int value = 1;\n};\n\n// Template metaprogramming to compute power of a number at compile time\ntemplate <int Base, int Exponent>\nstruct Power {\n    static constexpr int value = Base * Power<Base, Exponent - 1>::value;\n};\n\ntemplate <int Base>\nstruct Power<Base, 0> {\n    static constexpr int value = 1;\n};\n\nint main() {\n    // Compile-time factorial\n    constexpr int fact5 = factorial(5);\n    assert(fact5 == 120);\n\n    // Compile-time Fibonacci\n    constexpr int fib10 = Fibonacci<10>::value;\n    assert(fib10 == 55);\n\n    // Compile-time power\n    constexpr int power3_4 = Power<3, 4>::value;\n    assert(power3_4 == 81);\n", "suffix": "    // Using the factorial function for another number\n    constexpr int fact6 = factorial(6);\n    assert(fact6 == 720);\n\n    // Using the Fibonacci template for another number\n    constexpr int fib15 = Fibonacci<15>::value;\n    assert(fib15 == 610);\n\n    // Using the power template for another number\n    constexpr int power2_10 = Power<2, 10>::value;\n    assert(power2_10 == 1024);\n\n    std::cout << \"All static assertions passed successfully.\" << std::endl;\n    return 0;\n}", "golden_completion": "    // Using the factorial function for another number\n    constexpr int fact7 = factorial(7);\n    assert(fact7 == 5040);\n\n    // Using the Fibonacci template for another number\n    constexpr int fib20 = Fibonacci<20>::value;\n    assert(fib20 == 6765);\n\n    // Using the power template for another number\n    constexpr int power5_3 = Power<5, 3>::value;\n    assert(power5_3 == 125);", "LLM_justification": "This test case demonstrates template metaprogramming in C++ within the context of compile-time computations for factorial, Fibonacci numbers, and power of a number. The prefix establishes a clear pattern of using template metaprogramming to compute values at compile-time. The golden completion follows this pattern by adding further compile-time computations and corresponding assertions. This tests the model's ability to recognize and complete the pattern accurately, ensuring that it can handle complex template metaprogramming scenarios. The suffix continues the pattern with different values and includes robust assertions to validate the results.", "assertions": ""}
{"id": "37", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\n// This function calculates the average of a vector of integers\nfloat calculateAverage(const std::vector<int>& numbers) {\n    if (numbers.empty()) {\n        throw std::invalid_argument(\"The vector is empty\");\n    }\n    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    return static_cast<float>(sum) / numbers.size();\n}\n\n// This function finds the maximum element in a vector of integers\nint findMax(const std::vector<int>& numbers) {\n    if (numbers.empty()) {\n        throw std::invalid_argument(\"The vector is empty\");\n    }\n    return *std::max_element(numbers.begin(), numbers.end());\n}\n\n// This function finds the minimum element in a vector of integers\nint findMin(const std::vector<int>& numbers) {\n    if (numbers.empty()) {\n        throw std::invalid_argument(\"The vector is empty\");\n    }\n    return *std::min_element(numbers.begin(), numbers.end());\n}\n\n// This function calculates the median of a vector of integers\nfloat calculateMedian(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        throw std::invalid_argument(\"The vector is empty\");\n    }\n    std::sort(numbers.begin(), numbers.end());\n    size_t size = numbers.size();\n    if (size % 2 == 0) {\n        return (numbers[size / 2 - 1] + numbers[size / 2]) / 2.0;\n    } else {\n        return numbers[size / 2];\n    }\n}\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    // Calculating average\n    float avg = calculateAverage(data);\n    std::cout << \"Average: \" << avg << std::endl;\n    assert(avg == 5.5);\n\n    // Finding maximum\n    int max = findMax(data);\n    std::cout << \"Max: \" << max << std::endl;\n    assert(max == 10);\n\n    // Finding minimum\n    int min = findMin(data);\n    std::cout << \"Min: \" << min << std::endl;\n    assert(min == 1);\n\n    // Calculating median\n    float median = calculateMedian(data);\n    std::cout << \"Median: \" << median << std::endl;\n    assert(median == 5.5);\n\n", "suffix": "    // Calculating standard deviation\n    float sum = 0;\n    for (int num : data) {\n        sum += (num - avg) * (num - avg);\n    }\n    float stddev = std::sqrt(sum / data.size());\n    std::cout << \"Standard Deviation: \" << stddev << std::endl;\n    assert(std::abs(stddev - std::sqrt(8.25)) < 1e-5f);\n\n    // Cleanup code\n    data.clear();\n    std::cout << \"Data vector size after cleanup: \" << data.size() << std::endl;\n    assert(data.empty());\n    return 0;\n}\n", "golden_completion": "    // Calculating variance\n    float varianceSum = 0;\n    for (int num : data) {\n        varianceSum += (num - avg) * (num - avg);\n    }\n    float variance = varianceSum / data.size();\n    std::cout << \"Variance: \" << variance << std::endl;\n    assert(variance == 8.25);\n\n", "LLM_justification": "This test case is designed to assess the LLM's ability to recognize and continue a pattern of statistical calculations (average, max, min, median) on a vector of integers. The pattern is established through multiple functions that each perform a specific statistical operation, and the golden completion involves continuing this pattern by calculating the variance. The assertions verify the correctness of each statistical calculation and ensure proper functionality. This is a realistic scenario that involves algorithm implementation and analytics, commonly encountered by developers.", "assertions": ""}
{"id": "38", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <cassert>\n\n// A template function that applies a given function to each element of a vector and accumulates the result\n// This pattern demonstrates the use of higher-order functions in the context of analytics\n\n// Function to compute the sum of elements in a vector\nint sum(const std::vector<int>& data) {\n    int result = 0;\n    for (int value : data) {\n        result += value;\n    }\n    return result;\n}\n\n// Function to compute the product of elements in a vector\nint product(const std::vector<int>& data) {\n    int result = 1;\n    for (int value : data) {\n        result *= value;\n    }\n    return result;\n}\n\n// Template function that applies a higher-order function to each element\n// of a vector and returns the accumulated result\ntemplate <typename T, typename Func>\nT accumulate(const std::vector<T>& data, Func func, T init) {\n    T result = init;\n    for (const T& value : data) {\n        result = func(result, value);\n    }\n    return result;\n}\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n\n    // Using the sum function as a higher-order function\n    int total_sum = accumulate(data, [](int a, int b) { return a + b; }, 0);\n    assert(total_sum == 15);\n\n    // Using the product function as a higher-order function\n    int total_product = accumulate(data, [](int a, int b) { return a * b; }, 1);\n    assert(total_product == 120);\n\n    // Applying another higher-order function to find the maximum element\n    int max_value = accumulate(data, [](int a, int b) { return a > b ? a : b; }, data[0]);\n    assert(max_value == 5);\n\n    // Applying another higher-order function to find the minimum element\n", "suffix": "\n\n    // Cleanup code (if any) would go here\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    int min_value = accumulate(data, [](int a, int b) { return a < b ? a : b; }, data[0]);\n    assert(min_value == 1);\n", "LLM_justification": "This example is a good test case because it demonstrates the use of higher-order functions in the context of analytics. The prefix establishes a clear pattern of using a template function to apply various higher-order functions (sum, product, max, min) to a vector of integers. The golden completion follows the established pattern by providing an appropriate lambda function to find the minimum value in the vector. The suffix continues the pattern and includes assertions that validate the correctness of the implementation. This tests the LLM's ability to recognize and continue the higher-order function pattern accurately.", "assertions": ""}
{"id": "39", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\n// A class to represent a simple metric\nclass Metric {\npublic:\n    Metric(const std::string& name, double value) : name_(name), value_(value) {}\n\n    const std::string& getName() const { return name_; }\n    double getValue() const { return value_; }\n\nprivate:\n    std::string name_;\n    double value_;\n};\n\n// A class to represent a collection of metrics\nclass MetricCollection {\npublic:\n    void addMetric(const Metric& metric) {\n        metrics_.push_back(metric);\n    }\n\n    std::vector<Metric> getMetrics() const { return metrics_; }\n\n    // A higher-order function to apply a transformation to all metrics and return a new collection\n    MetricCollection transformMetrics(std::function<Metric(const Metric&)> transformer) const {\n        MetricCollection newCollection;\n        for (const auto& metric : metrics_) {\n            newCollection.addMetric(transformer(metric));\n        }\n        return newCollection;\n    }\n\nprivate:\n    std::vector<Metric> metrics_;\n};\n\n// A function to create a sample collection of metrics\nMetricCollection createSampleMetrics() {\n    MetricCollection collection;\n    collection.addMetric(Metric(\"CPU Usage\", 75.5));\n    collection.addMetric(Metric(\"Memory Usage\", 60.3));\n    collection.addMetric(Metric(\"Disk Usage\", 80.1));\n    return collection;\n}\n\nint main() {\n    MetricCollection collection = createSampleMetrics();\n\n    // Transform metrics by scaling their values by a factor of 2\n    MetricCollection scaledCollection = collection.transformMetrics([](const Metric& metric) { return Metric(metric.getName(), metric.getValue() * 2); });\n\n    // Verify that the transformation is correct\n    std::vector<Metric> scaledMetrics = scaledCollection.getMetrics();\n    assert(scaledMetrics.size() == 3);\n    assert(scaledMetrics[0].getName() == \"CPU Usage\");\n    assert(scaledMetrics[0].getValue() == 151.0);\n    assert(scaledMetrics[1].getName() == \"Memory Usage\");\n    assert(scaledMetrics[1].getValue() == 120.6);\n    assert(scaledMetrics[2].getName() == \"Disk Usage\");\n    assert(scaledMetrics[2].getValue() == 160.2);\n\n    // Transform metrics by converting their names to uppercase\n    MetricCollection uppercaseCollection = collection.transformMetrics([](const Metric& metric) {\n        std::string upperName = metric.getName();\n        std::transform(upperName.begin(), upperName.end(), upperName.begin(), ::toupper);\n        return Metric(upperName, metric.getValue());\n    });\n\n    // Verify that the transformation is correct\n    std::vector<Metric> uppercaseMetrics = uppercaseCollection.getMetrics();\n    assert(uppercaseMetrics.size() == 3);\n    assert(uppercaseMetrics[0].getName() == \"CPU USAGE\");\n    assert(uppercaseMetrics[0].getValue() == 75.5);\n    assert(uppercaseMetrics[1].getName() == \"MEMORY USAGE\");\n    assert(uppercaseMetrics[1].getValue() == 60.3);\n    assert(uppercaseMetrics[2].getName() == \"DISK USAGE\");\n    assert(uppercaseMetrics[2].getValue() == 80.1);\n\n", "suffix": "\n\n    std::cout << \"All assertions passed!\" << std::endl;\n\n    return 0;\n}", "golden_completion": "    // Transform metrics by adding a fixed value to their values\n    MetricCollection offsetCollection = collection.transformMetrics([](const Metric& metric) {\n        return Metric(metric.getName(), metric.getValue() + 10.0);\n    });\n\n    // Verify that the transformation is correct\n    std::vector<Metric> offsetMetrics = offsetCollection.getMetrics();\n    assert(offsetMetrics.size() == 3);\n    assert(offsetMetrics[0].getName() == \"CPU Usage\");\n    assert(offsetMetrics[0].getValue() == 85.5);\n    assert(offsetMetrics[1].getName() == \"Memory Usage\");\n    assert(offsetMetrics[1].getValue() == 70.3);\n    assert(offsetMetrics[2].getName() == \"Disk Usage\");\n    assert(offsetMetrics[2].getValue() == 90.1);\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving higher-order functions in the context of analytics. The prefix establishes a clear pattern of transforming metrics using a higher-order function, with two examples of such transformations provided. The golden completion continues this pattern with another transformation. The suffix contains different code that validates the correctness of the transformation using assertions, ensuring that the pattern is followed correctly.", "assertions": ""}
{"id": "40", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cmath>\n#include <unordered_map>\n\n// Function to calculate the average of a vector\nfloat calculate_average(const std::vector<int>& data) {\n\tif (data.empty()) {\n\t\tthrow std::invalid_argument(\"Vector is empty\");\n\t}\n\tint sum = 0;\n\tfor (int num : data) {\n\t\tsum += num;\n\t}\n\treturn static_cast<float>(sum) / data.size();\n}\n\n// Function to calculate the variance of a vector\nfloat calculate_variance(const std::vector<int>& data) {\n\tif (data.size() < 2) {\n\t\tthrow std::invalid_argument(\"Vector must contain at least two elements\");\n\t}\n\tfloat mean = calculate_average(data);\n\tfloat sum_squared_diff = 0.0;\n\tfor (int num : data) {\n\t\tsum_squared_diff += (num - mean) * (num - mean);\n\t}\n\treturn sum_squared_diff / data.size();\n}\n\n// Function to calculate the standard deviation of a vector\nfloat calculate_standard_deviation(const std::vector<int>& data) {\n\tif (data.size() < 2) {\n\t\tthrow std::invalid_argument(\"Vector must contain at least two elements\");\n\t}\n\tfloat variance = calculate_variance(data);\n\treturn std::sqrt(variance);\n}\n\n// Function to calculate the median of a vector\nfloat calculate_median(std::vector<int> data) {\n\tif (data.empty()) {\n\t\tthrow std::invalid_argument(\"Vector is empty\");\n\t}\n\tstd::sort(data.begin(), data.end());\n\tint n = data.size();\n\tif (n % 2 == 0) {\n\t\treturn (data[n/2 - 1] + data[n/2]) / 2.0;\n\t} else {\n\t\treturn data[n/2];\n\t}\n}\n\n// Function to calculate the mode of a vector\n", "suffix": "int main() {\n\tstd::vector<int> data = {1, 2, 2, 3, 4};\n\n\t// Calculate and assert the average\n\tfloat avg = calculate_average(data);\n\tassert(std::abs(avg - 2.4) < 0.001);\n\n\t// Calculate and assert the variance\n\tfloat variance = calculate_variance(data);\n\tassert(std::abs(variance - 1.04) < 0.001);\n\n\t// Calculate and assert the standard deviation\n\tfloat std_dev = calculate_standard_deviation(data);\n\tassert(std::abs(std_dev - 1.02) < 0.01);\n\n\t// Calculate and assert the median\n\tfloat median = calculate_median(data);\n\tassert(std::abs(median - 2.0) < 0.001);\n\n\treturn 0;\n}", "golden_completion": "\nfloat calculate_mode(const std::vector<int>& data) {\n\tif (data.empty()) {\n\t\tthrow std::invalid_argument(\"Vector is empty\");\n\t}\n\tstd::unordered_map<int, int> frequency;\n\tfor (int num : data) {\n\t\tfrequency[num]++;\n\t}\n\tint mode = data[0];\n\tint max_count = 0;\n\tfor (const auto& pair : frequency) {\n\t\tif (pair.second > max_count) {\n\t\t\tmode = pair.first;\n\t\t\tmax_count = pair.second;\n\t\t}\n\t}\n\treturn mode;\n}\n\n", "LLM_justification": "This test case is a good example for testing an LLM's ability to recognize and continue patterns in C++ code because it involves implementing multiple statistical functions following a clear pattern. Each function is designed to calculate a different statistical measure and follows a similar structure: input validation, calculation, and return of the result. The golden completion involves implementing the 'calculate_mode' function, which fits seamlessly into the established pattern of the other statistical functions. The suffix includes assertions to verify the correctness of the calculations for average, variance, standard deviation, and median, ensuring that the LLM-generated code maintains the pattern and functionality. This scenario requires the LLM to understand and apply concepts such as input validation, iteration, and mathematical calculations, making it a comprehensive test of its pattern recognition capabilities.", "assertions": ""}
{"id": "41", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// A utility class to handle a collection of integers\nclass IntCollection {\npublic:\n    IntCollection() = default;\n\n    // Adds an integer to the collection\n    void add(int value) {\n        data.push_back(value);\n    }\n\n    // Applies a function to each element in the collection\n    void apply(const std::function<void(int&)>& func) {\n        std::for_each(data.begin(), data.end(), func);\n    }\n\n    // Prints all elements in the collection\n    void print() const {\n        for (const auto& val : data) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    // Applies a transformation function to each element\n    void transform(const std::function<int(int)>& func) {\n        std::transform(data.begin(), data.end(), data.begin(), func);\n    }\n\nprivate:\n    std::vector<int> data;\n};\n\n// A function to double the value of an integer\nint doubleValue(int x) {\n    return x * 2;\n}\n\n// A function to increment the value of an integer\nint incrementValue(int x) {\n    return x + 1;\n}\n\nint main() {\n    IntCollection collection;\n    collection.add(1);\n    collection.add(2);\n    collection.add(3);\n    collection.add(4);\n\n    // Applying a transformation to double each value\n    collection.transform(doubleValue);\n    collection.print();\n\n    // Applying a transformation to increment each value\n    ", "suffix": "    collection.print();\n\n    // Assertions to verify the transformations\n    std::vector<int> expected_values = {3, 5, 7, 9};\n    collection.apply([&expected_values](int& val) {\n        assert(val == expected_values.front());\n        expected_values.erase(expected_values.begin());\n    });\n\n    return 0;\n}", "golden_completion": "collection.transform(incrementValue);", "LLM_justification": "This example tests the LLM's ability to recognize and continue a higher-order function pattern within the context of a collection transformation. The prefix sets up a class with methods to add, apply functions, and transform the collection, and demonstrates the use of these methods. The golden completion follows the established pattern by applying another transformation function. The suffix contains assertions that verify the transformations, ensuring the LLM correctly follows the pattern and maintains functionality.", "assertions": ""}
{"id": "42", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <functional>\n#include <cassert>\n\n// Higher-order function for applying an operation on two integers\nint applyOperation(int a, int b, std::function<int(int, int)> op) {\n    return op(a, b);\n}\n\n// Specific operations\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}\n\n// Function to test higher-order function with different operations\nvoid testOperations() {\n    // Using add operation\n    int result = applyOperation(5, 3, add);\n    assert(result == 8);\n\n    // Using subtract operation\n    result = applyOperation(5, 3, subtract);\n    assert(result == 2);\n\n    // Using lambda for multiplication\n    result = applyOperation(5, 3, [](int a, int b) { return a * b; });\n    assert(result == 15);\n\n    // Using lambda for division\n", "suffix": "\n    result = applyOperation(10, 3, [](int a, int b) { return a % b; });\n    assert(result == 1);\n\n    // Using lambda for power\n    result = applyOperation(2, 3, [](int a, int b) { int res = 1; for(int i = 0; i < b; ++i) res *= a; return res; });\n    assert(result == 8);\n}\n\nint main() {\n    testOperations();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    result = applyOperation(10, 2, [](int a, int b) { return a / b; });\n    assert(result == 5);\n\n", "LLM_justification": "This example is an excellent test case for pattern matching capabilities because it involves higher-order functions and demonstrates a clear pattern of using the `applyOperation` function with different operations. The prefix includes multiple examples of applying predefined functions and lambdas, establishing a recognizable pattern. The golden completion continues this pattern with additional operations, ensuring consistency. The suffix then tests these operations with assertions, verifying the correctness of the implementation. This scenario is practical for real-world applications, such as creating flexible APIs or mathematical libraries.", "assertions": ""}
{"id": "43", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n\n// Function template to find the minimum element in a vector\n// demonstrating template metaprogramming for different data types\ntemplate <typename T>\nT findMin(const std::vector<T>& vec) {\n    T minElement = vec[0];\n    for (const T& elem : vec) {\n        if (elem < minElement) {\n            minElement = elem;\n        }\n    }\n    return minElement;\n}\n\n// Function template to find the maximum element in a vector\n// demonstrating template metaprogramming for different data types\ntemplate <typename T>\nT findMax(const std::vector<T>& vec) {\n    T maxElement = vec[0];\n    for (const T& elem : vec) {\n        if (elem > maxElement) {\n            maxElement = elem;\n        }\n    }\n    return maxElement;\n}\n\n// Function template to calculate the average of elements in a vector\n// demonstrating template metaprogramming for different data types\n", "suffix": "int main() {\n    std::vector<int> intVec = {1, 2, 3, 4, 5};\n    std::vector<double> doubleVec = {1.1, 2.2, 3.3, 4.4, 5.5};\n\n    double intAvg = calculateAverage(intVec);\n    double doubleAvg = calculateAverage(doubleVec);\n\n    // Assertions to verify the correctness of the template functions\n    assert(intAvg == 3.0);\n    assert(doubleAvg == 3.3);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "template <typename T>\ndouble calculateAverage(const std::vector<T>& vec) {\n    T sum = std::accumulate(vec.begin(), vec.end(), T(0));\n    return static_cast<double>(sum) / vec.size();\n}\n", "LLM_justification": "This test case focuses on template metaprogramming, a common and advanced feature of C++. The prefix establishes a clear pattern of template functions that operate on vectors of different data types. The golden completion continues this pattern by introducing a function template to calculate the average of elements in a vector. The suffix includes assertions to verify the correctness of the pattern and ensures that the template functions work as intended for different data types. This scenario tests the LLM's ability to recognize and complete patterns in template metaprogramming, which is crucial for writing robust and reusable C++ code.", "assertions": ""}
{"id": "44", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Template metaprogramming example with game mechanics (AI state machine)\n// Define states for AI\nstruct State {\n    virtual void enter() = 0;\n    virtual void update() = 0;\n    virtual void exit() = 0;\n    virtual ~State() {}\n};\n\nstruct IdleState : public State {\n    void enter() override { std::cout << \"Entering Idle State\\n\"; }\n    void update() override { std::cout << \"Updating Idle State\\n\"; }\n    void exit() override { std::cout << \"Exiting Idle State\\n\"; }\n};\n\nstruct PatrolState : public State {\n    void enter() override { std::cout << \"Entering Patrol State\\n\"; }\n    void update() override { std::cout << \"Updating Patrol State\\n\"; }\n    void exit() override { std::cout << \"Exiting Patrol State\\n\"; }\n};\n\n// AI class which uses the states\nclass AI {\nprivate:\n    State* currentState;\npublic:\n    AI() : currentState(nullptr) {}\n    void changeState(State* newState) {\n        if (currentState) {\n            currentState->exit();\n        }\n        currentState = newState;\n        if (currentState) {\n            currentState->enter();\n        }\n    }\n    void update() {\n        if (currentState) {\n            currentState->update();\n        }\n    }\n};\n\n// Define more states to follow the pattern\nstruct AttackState : public State {\n    void enter() override { std::cout << \"Entering Attack State\\n\"; }\n    void update() override { std::cout << \"Updating Attack State\\n\"; }\n    void exit() override { std::cout << \"Exiting Attack State\\n\"; }\n};\n\nint main() {\n    AI ai;\n    IdleState idle;\n    PatrolState patrol;\n    AttackState attack;\n    \n    ai.changeState(&idle);\n    ai.update();\n    ai.changeState(&patrol);\n    ai.update();\n    ai.changeState(&attack);\n    ai.update();\n", "suffix": "\n\n\t// Assertions to verify the pattern and functionality\n\tassert(true); // Ensure no crash and state transitions happen\n\n\t// Clean-up code if needed (none in this simplified example)\n\treturn 0;\n}\n", "golden_completion": "\tai.changeState(&idle);\n\tai.update();\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern in the context of AI state machines using template metaprogramming. The AI class demonstrates a pattern of state transitions, and the golden completion requires recognizing this pattern and continuing it appropriately. The prefix sets up the states and the AI class, and the suffix ensures the pattern is followed with assertions to verify functionality. This tests the LLM's understanding of template metaprogramming, state machines, and following established patterns in C++.", "assertions": ""}
{"id": "45", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <cassert>\n\n// Higher-order function that applies a function to each element in a vector\nvoid applyFunction(const std::vector<int>& vec, const std::function<int(int)>& func, std::vector<int>& result) {\n    for (const auto& elem : vec) {\n        result.push_back(func(elem));\n    }\n}\n\n// Sample functions to be used with applyFunction\nint square(int x) {\n    return x * x;\n}\n\nint increment(int x) {\n    return x + 1;\n}\n\nint halve(int x) {\n    return x / 2;\n}\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5};\n    std::vector<int> results1;\n    std::vector<int> results2;\n    std::vector<int> results3;\n\n    // Apply square function\n    applyFunction(data, square, results1);\n    // Apply increment function\n    applyFunction(data, increment, results2);\n", "suffix": "\n\n    // Assertions for square function\n    assert(results1.size() == 5);\n    assert(results1[0] == 1);\n    assert(results1[1] == 4);\n    assert(results1[2] == 9);\n    assert(results1[3] == 16);\n    assert(results1[4] == 25);\n\n    // Assertions for increment function\n    assert(results2.size() == 5);\n    assert(results2[0] == 2);\n    assert(results2[1] == 3);\n    assert(results2[2] == 4);\n    assert(results2[3] == 5);\n    assert(results2[4] == 6);\n\n    // Assertions for halve function\n    assert(results3.size() == 5);\n    assert(results3[0] == 0);\n    assert(results3[1] == 1);\n    assert(results3[2] == 1);\n    assert(results3[3] == 2);\n    assert(results3[4] == 2);\n\n    // Print results\n    std::cout << \"Results1: \";\n    for (const auto& elem : results1) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Results2: \";\n    for (const auto& elem : results2) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Results3: \";\n    for (const auto& elem : results3) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n", "golden_completion": "    // Apply halve function\n    applyFunction(data, halve, results3);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a higher-order function pattern. The pattern involves applying different functions to a vector of integers and storing the results. The prefix establishes the pattern with two examples (square and increment functions) and the suffix continues with a third example (halve function) and includes assertions to validate the results. This setup ensures that the LLM must understand the higher-order function usage and correctly apply it to maintain consistency.", "assertions": ""}
{"id": "46", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <cassert>\n\n// Prefix: Establishing a pattern of higher-order functions to apply game mechanics\n\n// A simple function that applies gravity to a position\nfloat applyGravity(float position, float gravity) {\n    return position - gravity;\n}\n\n// A function that applies friction to velocity\nfloat applyFriction(float velocity, float friction) {\n    return velocity * (1 - friction);\n}\n\n// Higher-order function that accepts a vector of positions and applies a given mechanic\nvoid applyMechanic(std::vector<float>& positions, std::function<float(float)> mechanic) {\n    for (auto& pos : positions) {\n        pos = mechanic(pos);\n    }\n}\n\nint main() {\n    // Initial positions of objects\n    std::vector<float> positions = {10.0f, 20.0f, 30.0f};\n    // Applying gravity to all positions\n    applyMechanic(positions, [](float pos) { return applyGravity(pos, 9.8f); });\n    // Applying friction to all positions\n    applyMechanic(positions, [](float vel) { return applyFriction(vel, 0.1f); });\n\n    // Assertions to verify the results after gravity and friction mechanics\n    // Applying a custom mechanic that boosts positions\n", "suffix": "    assert(positions[0] < 10.0f);\n    assert(positions[1] < 20.0f);\n    assert(positions[2] < 30.0f);\n\n    // Cleanup code (if any)\n    // No dynamic allocations here, so no cleanup needed\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    applyMechanic(positions, [](float pos) { return pos + 5.0f; });\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of higher-order functions in the context of game mechanics. The prefix establishes a pattern of applying different mechanics (gravity, friction) to a vector of positions using higher-order functions. The golden completion requires the LLM to continue this pattern by introducing a new mechanic (boosting positions). The suffix includes assertions that verify the correct application of the mechanics and ensure that the code is fully executable and meets the expected behavior.", "assertions": ""}
{"id": "47", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// A function to apply a transformation to each element in a vector and accumulate the results\nint transformAndAccumulate(const std::vector<int>& vec, int (*transform)(int), int (*accumulate)(int, int)) {\n\tint result = 0;\n\tfor (int value : vec) {\n\t\tresult = accumulate(result, transform(value));\n\t}\n\treturn result;\n}\n\n// Transformation function: squares the input\nint square(int x) {\n\treturn x * x;\n}\n\n// Accumulation function: sums the inputs\nint sum(int x, int y) {\n\treturn x + y;\n}\n\n// Another transformation function: doubles the input\nint doubleValue(int x) {\n\treturn x * 2;\n}\n\n// Another accumulation function: finds the maximum\nint max(int x, int y) {\n\treturn (x > y) ? x : y;\n}\n\nint main() {\n\tstd::vector<int> numbers = {1, 2, 3, 4, 5};\n\n\t// Using transformAndAccumulate with square and sum\n\tint sumOfSquares = transformAndAccumulate(numbers, square, sum);\n\tstd::cout << \"Sum of squares: \" << sumOfSquares << std::endl;\n\tassert(sumOfSquares == 55);\n\n\t// Using transformAndAccumulate with doubleValue and sum\n\tint sumOfDoubles = transformAndAccumulate(numbers, doubleValue, sum);\n\tstd::cout << \"Sum of doubles: \" << sumOfDoubles << std::endl;\n\tassert(sumOfDoubles == 30);\n\n\t// Using transformAndAccumulate with square and max", "suffix": "\n\n\t// Using transformAndAccumulate with doubleValue and max\n\tint maxOfDoubles = transformAndAccumulate(numbers, doubleValue, max);\n\tstd::cout << \"Max of doubles: \" << maxOfDoubles << std::endl;\n\tassert(maxOfDoubles == 10);\n\n\treturn 0;\n}\n", "golden_completion": "\n\tint maxOfSquares = transformAndAccumulate(numbers, square, max);\n\tstd::cout << \"Max of squares: \" << maxOfSquares << std::endl;\n\tassert(maxOfSquares == 25);\n\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern involving higher-order functions in C++. The pattern of using the transformAndAccumulate function with different transformation and accumulation functions is clearly established in the prefix. The golden completion continues this pattern by applying different transformations and accumulations, which is a common scenario in both functional programming and analytics contexts. The provided assertions ensure that the pattern is correctly followed and the functionality is validated.", "assertions": ""}
{"id": "48", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n\nclass Analytics {\npublic:\n\tstruct Metric {\n\t\tstd::string name;\n\t\tdouble value;\n\t};\n\n\tvoid addMetric(const std::string& name, double value) {\n\t\tmetrics.push_back({name, value});\n\t}\n\n\tstd::vector<Metric> filterMetrics(std::function<bool(const Metric&)> predicate) {\n\t\tstd::vector<Metric> result;\n\t\tfor (const auto& metric : metrics) {\n\t\t\tif (predicate(metric)) {\n\t\t\t\tresult.push_back(metric);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tvoid printMetrics() const {\n\t\tfor (const auto& metric : metrics) {\n\t\t\tstd::cout << metric.name << \": \" << metric.value << std::endl;\n\t\t}\n\t}\n\n\t// Iterator methods to make Analytics behave like a container\n\tauto begin() const { return metrics.begin(); }\n\tauto end() const { return metrics.end(); }\n\tsize_t size() const { return metrics.size(); }\n\nprivate:\n\tstd::vector<Metric> metrics;\n};\n\nint main() {\n\tAnalytics analytics;\n\tanalytics.addMetric(\"CPU Usage\", 75.5);\n\tanalytics.addMetric(\"Memory Usage\", 60.3);\n\tanalytics.addMetric(\"Disk IO\", 40.2);\n\n\t// Filtering metrics with value > 50\n\tstd::vector<Analytics::Metric> highValueMetrics = analytics.filterMetrics([](const Analytics::Metric& metric) {\n\t\treturn metric.value > 50;\n\t});\n\n\t// Checking if filtering works correctly\n\tassert(highValueMetrics.size() == 2);\n\tassert(highValueMetrics[0].name == \"CPU Usage\");\n\tassert(highValueMetrics[1].name == \"Memory Usage\");\n\n\t// Additional functionality to be implemented below\n\t// Calculating average value of metrics\n\tdouble averageValue = ", "suffix": ";\n\n\t// Checking average calculation\n\tassert(averageValue > 0);\n\tassert(averageValue == (75.5 + 60.3 + 40.2) / 3);\n\n\tanalytics.printMetrics();\n\n\treturn 0;\n}\n", "golden_completion": "std::accumulate(analytics.begin(), analytics.end(), 0.0, [](double sum, const Analytics::Metric& metric) { return sum + metric.value; }) / analytics.size()", "LLM_justification": "This example tests the ability to recognize the pattern of higher-order functions used in analytics metrics processing. The golden completion involves using std::accumulate to calculate the average value of metrics, which follows the pattern of using STL algorithms established in the prefix. Assertions verify the correctness of filtering and average value calculation, and the suffix completes the pattern with further functionality and checks.", "assertions": ""}
{"id": "49", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\n// A simple game entity class\nclass Entity {\npublic:\n    int id;\n    std::string name;\n    Entity(int id, const std::string& name) : id(id), name(name) {}\n};\n\n// The Game class holds a collection of entities\nclass Game {\npublic:\n    std::vector<Entity> entities;\n\n    void addEntity(int id, const std::string& name) {\n        entities.emplace_back(id, name);\n    }\n\n    Entity* findEntityById(int id) {\n        for (auto& entity : entities) {\n            if (entity.id == id) {\n                return &entity;\n            }\n        }\n        return nullptr;\n    }\n\n    // A higher-order function that takes a predicate and returns all matching entities\n    std::vector<Entity*> filterEntities(bool (*predicate)(const Entity&)) {\n        std::vector<Entity*> result;\n        for (auto& entity : entities) {\n            if (predicate(entity)) {\n                result.push_back(&entity);\n            }\n        }\n        return result;\n    }\n};\n\n// Predicate function to find entities with names starting with 'A'\nbool nameStartsWithA(const Entity& entity) {\n    return !entity.name.empty() && entity.name[0] == 'A';\n}\n\nint main() {\n    Game game;\n    game.addEntity(1, \"Alice\");\n    game.addEntity(2, \"Bob\");\n    game.addEntity(3, \"Andrew\");\n\n    // Filter entities using the predicate function\n    auto filteredEntities = game.filterEntities(nameStartsWithA);\n", "suffix": "\n\n    // Further test cases with different predicates\n    bool (*predicate)(const Entity&) = [](const Entity& entity) { return entity.name.size() > 3; };\n    auto longNamedEntities = game.filterEntities(predicate);\n    assert(longNamedEntities.size() == 2);\n    assert(longNamedEntities[0]->name == \"Alice\");\n    assert(longNamedEntities[1]->name == \"Andrew\");\n\n    predicate = [](const Entity& entity) { return entity.name.find('o') != std::string::npos; };\n    auto oNamedEntities = game.filterEntities(predicate);\n    assert(oNamedEntities.size() == 1);\n    assert(oNamedEntities[0]->name == \"Bob\");\n\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "    assert(filteredEntities.size() == 2);\n    assert(filteredEntities[0]->name == \"Alice\");\n    assert(filteredEntities[1]->name == \"Andrew\");\n", "LLM_justification": "This test case establishes a higher-order function pattern in the context of a game entity management system. The prefix sets up a clear pattern of filtering entities based on a predicate function. The golden completion demonstrates the appropriate continuation of this pattern by asserting the correct entities were filtered. The suffix extends the pattern with additional predicate functions and corresponding assertions, ensuring that the LLM can recognize and continue the established pattern correctly. This scenario is realistic and practical, commonly encountered in game mechanics and AI where dynamic filtering of game entities is required.", "assertions": ""}
{"id": "50", "testsource": "devbench-pattern-matching", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nclass GameAI {\npublic:\n    using Condition = std::function<bool()>;\n    using Action = std::function<void()>;\n\n    void addState(const std::string& name) {\n        states.push_back(name);\n    }\n\n    void addTransition(const std::string& from, const std::string& to, Condition condition, Action action) {\n        transitions.push_back({from, to, condition, action});\n    }\n\n    void update() {\n        for (const auto& [from, to, condition, action] : transitions) {\n            if (currentState == from && condition()) {\n                action();\n                currentState = to;\n                break;\n            }\n        }\n    }\n\n    const std::string& getCurrentState() const {\n        return currentState;\n    }\n\nprivate:\n    std::string currentState = \"start\";\n    std::vector<std::string> states;\n    struct Transition {\n        std::string from;\n        std::string to;\n        Condition condition;\n        Action action;\n    };\n    std::vector<Transition> transitions;\n};\n\nGameAI ai;\n\nbool isEnemyNear() {\n    // Placeholder for actual game logic\n    return true;\n}\n\nvoid attack() {\n    std::cout << \"Attacking enemy!\" << std::endl;\n}\n\nvoid flee() {\n    std::cout << \"Fleeing from enemy!\" << std::endl;\n}\n\nint main() {\n    ai.addState(\"start\");\n    ai.addState(\"attack\");\n    ai.addState(\"flee\");\n\n    ai.addTransition(\"start\", \"attack\", isEnemyNear, attack);\n    ai.addTransition(\"attack\", \"flee\", []() { return false; }, flee);\n", "suffix": "\n\n    ai.addTransition(\"attack\", \"start\", []() { return true; }, []() { std::cout << \"Returning to start.\" << std::endl; });\n    ai.update();\n    assert(ai.getCurrentState() == \"start\");\n\n    return 0;\n}\n", "golden_completion": "\n    ai.update();\n    assert(ai.getCurrentState() == \"attack\");\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern involving state transitions in a game AI context. The pattern includes adding states and transitions with conditions and actions, and then updating the AI state based on these transitions. The golden completion continues this pattern by adding another transition and updating the state, which is a common task in game AI development. The assertions ensure the transitions are correctly applied and the state changes as expected.", "assertions": ""}
