
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.util.Properties;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import java.io.StringReader;

public class XMLProcessingExample {
    private static final String XML_DATA = "<root><element>Value</element></root>";

    public static void main(String[] args) {
        try {
            // Initializing necessary objects for XML processing
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            InputSource is = new InputSource(new StringReader(XML_DATA));
            Document document = builder.parse(is);

            // Creating an XPath object
            XPathFactory xPathFactory = XPathFactory.newInstance();
            XPath xPath = xPathFactory.newXPath();

            // Defining an XPath expression
            String expression = "/root/element";
            XPathExpression xPathExpression = xPath.compile(expression);


GOLDEN COMPLETION:
----------------------------------------
            // Evaluating the XPath expression
            String result = (String) xPathExpression.evaluate(document, XPathConstants.STRING);

            // Assertions to validate the result
            assert result.equals("Value") : "XPath result mismatch";


SUFFIX CODE:
----------------------------------------


            // Additional processing (this is different from golden completion)
            Properties outputProperties = new Properties();
            outputProperties.setProperty("method", "xml");
            outputProperties.setProperty("indent", "yes");

            // Cleanup code (if any)
            // No resources to clean up in this example
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and continue patterns involving uncommon library functions, specifically the usage of XPath expressions for XML processing. The example uses the javax.xml.xpath package to compile and evaluate an XPath expression, which is a less common but valid API pattern. The test ensures the LLM can correctly handle the XPath API, including proper parameter ordering and return value validation. Assertions are included to verify the correctness of the evaluated result. The scenario provides sufficient context and setup to test the model's capability to recognize and complete the API usage accurately.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import java.util.HashMap;
import java.util.Map;

public class DeprecatedApiExample {

    private static final String INPUT_STRING = "   Hello, World!   ";
    private static final String EXCEPTION_MESSAGE = "Example Exception";

    public static void main(String[] args) {
        DeprecatedApiExample example = new DeprecatedApiExample();
        example.runExample();
    }

    public void runExample() {
        // Using Apache Commons Lang StringUtils to trim a string
        String trimmedString = StringUtils.trim(INPUT_STRING);
        System.out.println("Trimmed String: " + trimmedString);

        // Using a deprecated method from Apache Commons Lang ExceptionUtils
        try {
            throw new RuntimeException(EXCEPTION_MESSAGE);
        } catch (RuntimeException e) {
            String stackTrace = ExceptionUtils.getStackTrace(e);
            System.out.println("Stack Trace: " + stackTrace);
        }

        // Setting up a map for further operations
        Map<String, String> dataMap = new HashMap<>();
        dataMap.put("key1", "value1");
        dataMap.put("key2", "value2");
        // Using Apache Commons Lang StringUtils to capitalize a string


GOLDEN COMPLETION:
----------------------------------------

        String capitalizedString = StringUtils.capitalize(trimmedString);
        System.out.println("Capitalized String: " + capitalizedString);



SUFFIX CODE:
----------------------------------------
        // Verifying map content
        assert "value1".equals(dataMap.get("key1")) : "Expected value for key1 is 'value1'";
        assert "value2".equals(dataMap.get("key2")) : "Expected value for key2 is 'value2'";

        // Using another Apache Commons Lang utility method to check if a string is numeric
        boolean isNumeric = StringUtils.isNumeric(trimmedString);
        assert !isNumeric : "Trimmed string should not be numeric";

        System.out.println("All assertions passed.");
    }
}


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the model's ability to recognize and complete patterns involving uncommon or deprecated APIs. It uses Apache Commons Lang, specifically focusing on StringUtils and ExceptionUtils, which are not commonly used in everyday Java development. The test case ensures that the model can handle deprecated methods, like ExceptionUtils.getStackTrace, and can correctly use StringUtils methods to manipulate strings. The assertions verify the correctness of map content and string properties, demonstrating proper parameter ordering and API behavior.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.io.StringReader;
import java.io.StringWriter;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement
class Person {
    private String name;
    private int age;

    public Person() {}

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @XmlElement
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @XmlElement
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

public class JAXBExample {
    public static void main(String[] args) throws JAXBException {
        Person person = new Person("John Doe", 30);

        // Create a JAXBContext for the Person class
        JAXBContext context = JAXBContext.newInstance(Person.class);

        // Create a Marshaller
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);

        // Write the Person object to a StringWriter
        StringWriter writer = new StringWriter();
        marshaller.marshal(person, writer);

        String xml = writer.toString();
        System.out.println("Marshalled XML:\n" + xml);

        // Create an Unmarshaller
        Unmarshaller unmarshaller = context.createUnmarshaller();

        // Unmarshal the XML back into a Person object
        StringReader reader = new StringReader(xml);


GOLDEN COMPLETION:
----------------------------------------
        Person unmarshalledPerson = (Person) unmarshaller.unmarshal(reader);


SUFFIX CODE:
----------------------------------------


        // Assertions to verify the correctness of the unmarshalled object
        assert unmarshalledPerson != null : "Unmarshalled Person should not be null";
        assert "John Doe".equals(unmarshalledPerson.getName()) : "Name should be 'John Doe'";
        assert unmarshalledPerson.getAge() == 30 : "Age should be 30";

        // Clean up resources
        writer.close();
        reader.close();
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of JAXB, an uncommon API for XML processing in Java. The example involves marshalling a Java object to XML and unmarshalling XML back to a Java object. It tests the LLM's ability to correctly use JAXB's Marshaller and Unmarshaller classes, ensuring proper parameter ordering and handling. The assertions verify the correctness of the unmarshalled object, ensuring the name and age fields are correctly restored from the XML. This scenario is a good test case because it involves a less commonly used API and requires understanding of JAXB's marshalling and unmarshalling processes.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.ArrayList;

public class DeprecatedAPITest {
    public static void main(String[] args) {
        try {
            // Create a temporary file
            File tempFile = File.createTempFile("testFile", ".txt");
            tempFile.deleteOnExit();

            // Write some content to the file
            String content = "Hello World!\nThis is a test file.";
            FileUtils.writeStringToFile(tempFile, content, StandardCharsets.UTF_8);

            // Read content from the file
            String fileContent = FileUtils.readFileToString(tempFile, StandardCharsets.UTF_8);
            System.out.println("File Content:\n" + fileContent);

            // Split content into lines
            List<String> lines = new ArrayList<>();
            StringUtils.split(lines, fileContent, '\n');
            
            // Modify lines
            for (int i = 0; i < lines.size(); i++) {
                lines.set(i, lines.get(i).toUpperCase());
            }

            // Write modified content back to the file
            String modifiedContent = StringUtils.join(lines, '\n');
            FileUtils.writeStringToFile(tempFile, modifiedContent, StandardCharsets.UTF_8);

            // Read modified content from the file
            String modifiedFileContent = FileUtils.readFileToString(tempFile, StandardCharsets.UTF_8);
            System.out.println("Modified File Content:\n" + modifiedFileContent);


GOLDEN COMPLETION:
----------------------------------------
            // Split content into lines
            String[] linesArray = StringUtils.split(fileContent, '\n');
            List<String> lines = new ArrayList<>();
            for (String line : linesArray) {
                lines.add(line);
            }

            // Modify lines
            for (int i = 0; i < lines.size(); i++) {
                lines.set(i, lines.get(i).toUpperCase());
            }

            // Write modified content back to the file
            String modifiedContent = StringUtils.join(lines, '\n');
            FileUtils.writeStringToFile(tempFile, modifiedContent, StandardCharsets.UTF_8);

            // Read modified content from the file
            String modifiedFileContent = FileUtils.readFileToString(tempFile, StandardCharsets.UTF_8);
            System.out.println("Modified File Content:\n" + modifiedFileContent);


SUFFIX CODE:
----------------------------------------
            // Assertions
            assert tempFile.exists() : "Temp file should exist";
            assert modifiedFileContent.equals("HELLO WORLD!\nTHIS IS A TEST FILE.") : "Modified content should match expected content";
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // Clean up
            File tempFile = new File("testFile.txt");
            if (tempFile.exists()) {
                tempFile.delete();
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of Apache Commons IO and Apache Commons Lang libraries, specifically focusing on deprecated methods like StringUtils.split. It also verifies the correctness of parameter ordering and API behavior. The example includes file operations and string manipulations, which are common tasks but uses less common library functions, making it a good test case for LLM's ability to recognize and complete rare API usage patterns.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import java.io.StringReader;

public class XMLProcessingExample {

    public static void main(String[] args) throws Exception {
        String xmlContent = "<root><child>value</child></root>";
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();

        // Parse the XML content
        Document document = builder.parse(new InputSource(new StringReader(xmlContent)));

        // Get the root element
        Element rootElement = document.getDocumentElement();
        System.out.println("Root element: " + rootElement.getTagName());

        // Get child nodes
        NodeList nodeList = rootElement.getElementsByTagName("child");
        if (nodeList.getLength() > 0) {
            Element childElement = (Element) nodeList.item(0);
            System.out.println("Child element value: " + childElement.getTextContent());
        }

        // Get child element using getElementsByTagName


GOLDEN COMPLETION:
----------------------------------------
        NodeList deprecatedNodeList = rootElement.getElementsByTagName("child");
        assert deprecatedNodeList.getLength() == 1 : "Expected one child element";
        Element deprecatedChildElement = (Element) deprecatedNodeList.item(0);
        assert "value".equals(deprecatedChildElement.getTextContent()) : "Expected child element value to be 'value'";


SUFFIX CODE:
----------------------------------------
        // New method to replace deprecated getElementsByTagNameNS
        NodeList nodeListNS = rootElement.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", "child");
        assert nodeListNS.getLength() == 0 : "Expected no elements";

        // Cleanup
        // No resources to cleanup in this example
    }

}


JUSTIFICATION:
----------------------------------------
This example demonstrates the usage of the deprecated method getElementsByTagName from the org.w3c.dom.Element class in Java, a less common API pattern. It requires the LLM to recognize the deprecated method and correctly utilize it while ensuring that the assertions validate the expected behavior. Additionally, it follows up with a non-deprecated alternative method to show proper usage and provide a comparison.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.dbcp2.BasicDataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class DatabaseExample {
    private BasicDataSource dataSource;

    public DatabaseExample() {
        dataSource = new BasicDataSource();
        dataSource.setUrl("jdbc:h2:mem:testdb");
        dataSource.setUsername("sa");
        dataSource.setPassword("");
        dataSource.setDriverClassName("org.h2.Driver");
    }

    public void createTable() throws SQLException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("CREATE TABLE IF NOT EXISTS users (id INT PRIMARY KEY, name VARCHAR(255))")) {
            stmt.executeUpdate();
        }
    }

    public void insertUser(int id, String name) throws SQLException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO users (id, name) VALUES (?, ?)");) {
            stmt.setInt(1, id);
            stmt.setString(2, name);
            stmt.executeUpdate();
        }
    }

    public String getUserById(int id) throws SQLException {
        String name = null;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT name FROM users WHERE id = ?");) {
            stmt.setInt(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    name = rs.getString("name");
                }
            }
        }
        return name;
    }

    public static void main(String[] args) throws SQLException {
        DatabaseExample example = new DatabaseExample();
        example.createTable();
        example.insertUser(1, "Alice");
        example.insertUser(2, "Bob");


GOLDEN COMPLETION:
----------------------------------------
        String user1 = example.getUserById(1);
        String user2 = example.getUserById(2);


SUFFIX CODE:
----------------------------------------

        assert "Alice".equals(user1);
        assert "Bob".equals(user2);
        example.insertUser(3, "Charlie");
        String user3 = example.getUserById(3);
        assert "Charlie".equals(user3);
        assert example.getUserById(4) == null;
    }
}


JUSTIFICATION:
----------------------------------------
This example uses Apache Commons DBCP, which is less common than other database connection pooling libraries. It demonstrates correct usage of API methods for connection handling, statement preparation, and result set processing. The pattern includes proper resource management with try-with-resources. Assertions verify correct data retrieval and parameter handling, providing a robust test case for the LLM's capabilities.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.filefilter.TrueFileFilter;

public class FileOperations {

    public static void main(String[] args) {
        try {
            // Create a temporary directory
            File tempDir = new File("tempDir");
            FileUtils.forceMkdir(tempDir);

            // Create some temporary files in the directory
            File tempFile1 = new File(tempDir, "tempFile1.txt");
            File tempFile2 = new File(tempDir, "tempFile2.txt");
            FileWriter writer1 = new FileWriter(tempFile1);
            writer1.write("This is a temporary file 1.");
            writer1.close();
            FileWriter writer2 = new FileWriter(tempFile2);
            writer2.write("This is a temporary file 2.");
            writer2.close();

            // List files in the directory using Apache Commons IO
            System.out.println("Files in tempDir:");
            for (File file : FileUtils.listFiles(tempDir, TrueFileFilter.INSTANCE, null)) {
                System.out.println(" - " + file.getName());
            }



GOLDEN COMPLETION:
----------------------------------------
            // Read the contents of the temporary files using Apache Commons IO
            String content1 = FileUtils.readFileToString(tempFile1, "UTF-8");
            String content2 = FileUtils.readFileToString(tempFile2, "UTF-8");



SUFFIX CODE:
----------------------------------------
            // Verify the contents of the files
            assert content1.equals("This is a temporary file 1.");
            assert content2.equals("This is a temporary file 2.");

            // Clean up the temporary files and directory
            FileUtils.forceDelete(tempDir);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the model's ability to recognize and complete patterns involving the Apache Commons IO library, particularly focusing on reading file contents using deprecated methods. The pattern established in the prefix involves creating and listing files, while the completion involves reading file contents and verifying their correctness. This scenario helps test the model's handling of less common file operations and proper parameter usage in deprecated methods.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.io.IOException;

@JsonIgnoreProperties(ignoreUnknown = true)
class Person {
    private String name;
    private int age;

    public Person() {}

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

public class JacksonExample {
    public static void main(String[] args) {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
        Person person = new Person("John Doe", 30);

        try {
            File jsonFile = new File("person.json");
            // Serialize Person object to JSON file


GOLDEN COMPLETION:
----------------------------------------
            objectMapper.writeValue(jsonFile, person);


SUFFIX CODE:
----------------------------------------
            // Deserialize JSON file to Person object
            Person deserializedPerson = objectMapper.readValue(new File("person.json"), Person.class);

            // Assertions
            assert deserializedPerson != null;
            assert "John Doe".equals(deserializedPerson.getName());
            assert deserializedPerson.getAge() == 30;

            // Clean up
            jsonFile.delete();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is a good example of using the Jackson library for JSON processing, which involves uncommon but valid API interactions. It tests the serialization and deserialization of a custom object to and from a JSON file. The golden completion involves the correct method to serialize the object, while the suffix includes the necessary assertions to verify the deserialization process. This scenario helps validate the model's understanding of proper API usage patterns and parameter handling.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.dbcp2.BasicDataSource;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import org.junit.Assert;

public class DatabaseTest {

    private static DataSource setupDataSource() {
        BasicDataSource ds = new BasicDataSource();
        ds.setUrl("jdbc:h2:mem:testdb");
        ds.setUsername("sa");
        ds.setPassword("");
        ds.setMinIdle(5);
        ds.setMaxIdle(10);
        ds.setMaxOpenPreparedStatements(100);
        return ds;
    }

    public static void main(String[] args) {
        DataSource dataSource = setupDataSource();
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("CREATE TABLE test_table (id INT PRIMARY KEY, name VARCHAR(255))");
            stmt.executeUpdate("INSERT INTO test_table (id, name) VALUES (1, 'John Doe')");
            stmt.executeUpdate("INSERT INTO test_table (id, name) VALUES (2, 'Jane Smith')");


GOLDEN COMPLETION:
----------------------------------------
            try (ResultSet rs = stmt.executeQuery("SELECT name FROM test_table WHERE id = 1")) {


SUFFIX CODE:
----------------------------------------

                if (rs.next()) {
                    String name = rs.getString("name");
                    Assert.assertEquals("Jane Smith", name);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

JUSTIFICATION:
----------------------------------------
This example tests the ability to correctly use the Apache Commons DBCP library for database connection pooling, which is a less common but important API. The example involves setting up a data source, creating a table, inserting data, and querying the data with proper assertions. The pattern involves correctly handling database connections and result sets, making it a good test of understanding uncommon API usage.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.util.Properties;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class PropertiesExample {
    public static void main(String[] args) {
        Properties properties = new Properties();
        try (FileInputStream input = new FileInputStream("config.properties")) {
            properties.load(input);
        } catch (IOException e) {
            e.printStackTrace();
        }
        // Existing properties are loaded here
        // Now we need to add a new property and save it


GOLDEN COMPLETION:
----------------------------------------
        properties.setProperty("newProperty", "newValue");
        try (FileOutputStream output = new FileOutputStream("config.properties")) {
            properties.store(output, null);
        } catch (IOException e) {
            e.printStackTrace();
        }


SUFFIX CODE:
----------------------------------------
        // Verify that the new property is correctly added
        String newValue = properties.getProperty("newProperty");
        if (!"newValue".equals(newValue)) {
            throw new AssertionError("New property was not added correctly");
        }
        // Clean up resources (In this case, none since try-with-resources was used)
    }
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the Properties class from java.util package, which is less commonly used in modern Java applications. It involves loading properties from a file, adding a new property, and saving it back to the file. The example checks whether the new property is correctly added and stored, covering both file I/O and properties manipulation. It is a good test case to evaluate the model's understanding of deprecated but still valid API patterns, proper resource handling, and correct parameter ordering.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.dbcp2.BasicDataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class DatabaseAccessExample {

    private BasicDataSource dataSource;

    public DatabaseAccessExample() {
        dataSource = new BasicDataSource();
        dataSource.setUrl("jdbc:h2:mem:testdb");
        dataSource.setUsername("sa");
        dataSource.setPassword("");
        dataSource.setDriverClassName("org.h2.Driver");
    }

    public void initializeDatabase() throws SQLException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255))")) {
            stmt.executeUpdate();
        }
    }

    public void insertUser(int id, String name) throws SQLException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO users (id, name) VALUES (?, ?)")) {
            stmt.setInt(1, id);
            stmt.setString(2, name);
            stmt.executeUpdate();
        }
    }

    public List<String> getUserNames() throws SQLException {
        List<String> names = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT name FROM users");
             ResultSet rs = stmt.executeQuery()) {
            while (rs.next()) {
                names.add(rs.getString("name"));
            }
        }
        return names;
    }

    public static void main(String[] args) {
        DatabaseAccessExample example = new DatabaseAccessExample();
        try {
            example.initializeDatabase();
            example.insertUser(1, "John Doe");
            example.insertUser(2, "Jane Smith");
            List<String> names = example.getUserNames();


GOLDEN COMPLETION:
----------------------------------------
            names.addAll(example.getUserNames());


SUFFIX CODE:
----------------------------------------
            assert names.size() == 2 : "User list size should be 2";
            assert names.contains("John Doe") : "User list should contain 'John Doe'";
            assert names.contains("Jane Smith") : "User list should contain 'Jane Smith'";
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                example.dataSource.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the Apache Commons DBCP library for managing database connections in Java. It includes setup, insertion, and retrieval of user data using JDBC with a connection pool. The example tests the model's ability to recognize and complete patterns involving database access and resource management. Assertions are included to verify the correctness of the data manipulation operations.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import org.apache.commons.dbcp2.BasicDataSource;

public class DatabaseExample {

    private static final String DB_URL = "jdbc:h2:mem:testdb";
    private static final String USER = "sa";
    private static final String PASS = "";

    private BasicDataSource dataSource;

    public DatabaseExample() {
        dataSource = new BasicDataSource();
        dataSource.setUrl(DB_URL);
        dataSource.setUsername(USER);
        dataSource.setPassword(PASS);
    }

    public Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    public void createTable() throws SQLException {
        try (Connection conn = getConnection();
             Statement stmt = conn.createStatement()) {
            String sql = "CREATE TABLE IF NOT EXISTS Employees " +
                         "(id INTEGER not NULL, " +
                         " name VARCHAR(255), " +
                         " age INTEGER, " +
                         " PRIMARY KEY ( id ))";
            stmt.executeUpdate(sql);
        }
    }

    public void insertEmployee(int id, String name, int age) throws SQLException {
        try (Connection conn = getConnection();
             Statement stmt = conn.createStatement()) {
            String sql = String.format("INSERT INTO Employees (id, name, age) VALUES (%d, '%s', %d)", id, name, age);
            stmt.executeUpdate(sql);
        }
    }

    public static void main(String[] args) {
        DatabaseExample example = new DatabaseExample();
        try {
            example.createTable();
            example.insertEmployee(1, "John Doe", 30);
            example.insertEmployee(2, "Jane Smith", 25);


GOLDEN COMPLETION:
----------------------------------------
            example.insertEmployee(3, "Alice Johnson", 35);


SUFFIX CODE:
----------------------------------------


            // Verify that the table creation and inserts were successful
            try (Connection conn = example.getConnection();
                 Statement stmt = conn.createStatement()) {
                var rs = stmt.executeQuery("SELECT COUNT(*) AS total FROM Employees");
                rs.next();
                int total = rs.getInt("total");
                assert total == 3 : "Expected 3 employees but found " + total;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            // Clean up resources
            try (Connection conn = example.getConnection();
                 Statement stmt = conn.createStatement()) {
                stmt.executeUpdate("DROP TABLE Employees");
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case uses Apache Commons DBCP, an uncommon library for database connection pooling, to demonstrate the creation and manipulation of a database table. The example includes creating a table, inserting records, and verifying the insertions with assertions. Additionally, it ensures resource cleanup in the suffix, which tests the model's ability to handle resource management and API usage patterns.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.util.Properties;
import java.io.FileInputStream;
import java.io.IOException;
import org.apache.commons.dbcp.BasicDataSource;
import java.sql.Connection;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class DatabaseExample {
    private BasicDataSource dataSource;

    public DatabaseExample() {
        dataSource = new BasicDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
    }

    public void configureDataSource(String url, String username, String password) {
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
    }

    public void executeQuery(String query) {
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                System.out.println("ID: " + rs.getInt("id") + ", Name: " + rs.getString("name"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        DatabaseExample dbExample = new DatabaseExample();
        Properties props = new Properties();
        try (FileInputStream fis = new FileInputStream("db.properties")) {
            props.load(fis);
        } catch (IOException e) {
            e.printStackTrace();
        }
        String url = props.getProperty("db.url");
        String username = props.getProperty("db.username");
        String password = props.getProperty("db.password");
        dbExample.configureDataSource(url, username, password);


GOLDEN COMPLETION:
----------------------------------------
        dbExample.executeQuery("SELECT * FROM users;");


SUFFIX CODE:
----------------------------------------


        // Assertions
        try (Connection conn = dbExample.dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT COUNT(*) AS count FROM users")) {
            if (rs.next()) {
                int count = rs.getInt("count");
                assert count > 0 : "No users found in the database";
            } else {
                assert false : "Failed to execute count query";
            }
        } catch (SQLException e) {
            assert false : "SQLException occurred: " + e.getMessage();
        }
    }
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern involving the deprecated Apache Commons DBCP library for database connection pooling. The code sets up a data source, configures it with properties from a file, and executes a query. The golden completion is a crucial part of the execution flow, demonstrating the ability to use the data source to run a query. The suffix contains assertions to verify that the database interaction works correctly, ensuring that the model understands both the setup and validation of database operations.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;
import org.junit.Assert;
import java.util.List;

public class HibernateExample {

    public static void main(String[] args) {
        // Set up Hibernate session factory
        SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();

        // Open a new session
        Session session = sessionFactory.openSession();

        // Begin transaction
        session.beginTransaction();

        // Create some example entities
        Employee emp1 = new Employee("John", "Doe", 50000);
        Employee emp2 = new Employee("Jane", "Doe", 60000);

        // Save entities
        session.save(emp1);
        session.save(emp2);

        // Commit transaction
        session.getTransaction().commit();

        // Begin new transaction for querying
        session.beginTransaction();

        // HQL query to fetch employees with salary greater than 55000
        String hql = "FROM Employee E WHERE E.salary > 55000";


GOLDEN COMPLETION:
----------------------------------------
        List<Employee> employees = session.createQuery(hql).list();

SUFFIX CODE:
----------------------------------------


        // Assertions
        Assert.assertEquals(1, employees.size());
        Assert.assertEquals("Jane", employees.get(0).getFirstName());
        Assert.assertEquals("Doe", employees.get(0).getLastName());
        Assert.assertEquals(60000, employees.get(0).getSalary());

        // Cleanup
        session.getTransaction().commit();
        session.close();
        sessionFactory.close();
    }
}

class Employee {
    private int id;
    private String firstName;
    private String lastName;
    private int salary;

    public Employee() {}

    public Employee(String firstName, String lastName, int salary) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.salary = salary;
    }

    // Getters and Setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    public int getSalary() { return salary; }
    public void setSalary(int salary) { this.salary = salary; }
}

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and properly complete a Hibernate HQL query execution pattern. It involves setting up a Hibernate session, saving entities, and querying with HQL. Assertions verify the correctness of the query results. This scenario is realistic as it involves common Hibernate API usage but with a specific focus on HQL, which may be less commonly used compared to other parts of the API.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.input.SAXBuilder;
import org.jdom2.output.XMLOutputter;
import org.jdom2.output.Format;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.List;

public class JDomExample {
    public static void main(String[] args) throws Exception {
        String xmlContent = "<root><child name=\"foo\">Value1</child><child name=\"bar\">Value2</child></root>";
        SAXBuilder saxBuilder = new SAXBuilder();
        Document document = saxBuilder.build(new StringReader(xmlContent));
        Element rootElement = document.getRootElement();
        List<Element> children = rootElement.getChildren();
        for (Element child : children) {
            System.out.println("Child name: " + child.getAttributeValue("name"));
            System.out.println("Child value: " + child.getText());
        }
        // Modify XML content
        Element newChild = new Element("child");
        newChild.setAttribute("name", "baz");
        newChild.setText("Value3");


GOLDEN COMPLETION:
----------------------------------------
        rootElement.addContent(newChild);

SUFFIX CODE:
----------------------------------------
        XMLOutputter xmlOutputter = new XMLOutputter(Format.getPrettyFormat());
        StringWriter stringWriter = new StringWriter();
        xmlOutputter.output(document, stringWriter);
        String modifiedXmlContent = stringWriter.toString();
        System.out.println("Modified XML Content:\n" + modifiedXmlContent);

        // Assertions to verify the correctness of the modified XML content
        assert modifiedXmlContent.contains("<child name=\"baz\">Value3</child>") : "New child element not found";
        assert modifiedXmlContent.contains("<child name=\"foo\">Value1</child>") : "Existing child element 'foo' is missing";
        assert modifiedXmlContent.contains("<child name=\"bar\">Value2</child>") : "Existing child element 'bar' is missing";
    }
}

JUSTIFICATION:
----------------------------------------
This is a good test case because it involves using the uncommon JDOM library to parse, manipulate, and output XML. It tests the model's ability to recognize the pattern of XML manipulation with JDOM, including adding new elements and ensuring the structure is maintained. The assertions verify the correctness of the modified XML content.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Cell;
import java.io.FileOutputStream;
import java.io.IOException;

public class ExcelExample {
    public static void main(String[] args) {
        XSSFWorkbook workbook = new XSSFWorkbook();
        Sheet sheet = workbook.createSheet("ExampleSheet");

        // Create a header row
        Row headerRow = sheet.createRow(0);
        Cell headerCell1 = headerRow.createCell(0);
        headerCell1.setCellValue("ID");
        Cell headerCell2 = headerRow.createCell(1);
        headerCell2.setCellValue("Name");

        // Add some data rows
        Row dataRow1 = sheet.createRow(1);
        Cell dataCell1 = dataRow1.createCell(0);
        dataCell1.setCellValue(1);
        Cell dataCell2 = dataRow1.createCell(1);
        dataCell2.setCellValue("John Doe");

        Row dataRow2 = sheet.createRow(2);
        Cell dataCell3 = dataRow2.createCell(0);
        dataCell3.setCellValue(2);
        Cell dataCell4 = dataRow2.createCell(1);
        dataCell4.setCellValue("Jane Doe");

        // Writing the workbook to a file
        try (FileOutputStream fileOut = new FileOutputStream("workbook.xlsx")) {
            

GOLDEN COMPLETION:
----------------------------------------
        workbook.write(fileOut);

SUFFIX CODE:
----------------------------------------

        } catch (IOException e) {
            e.printStackTrace();
        }

        // Assertions to verify the correctness of the generated Excel file
        try (XSSFWorkbook readWorkbook = new XSSFWorkbook(new FileInputStream("workbook.xlsx"))) {
            Sheet readSheet = readWorkbook.getSheet("ExampleSheet");
            Row readHeaderRow = readSheet.getRow(0);
            assert "ID".equals(readHeaderRow.getCell(0).getStringCellValue());
            assert "Name".equals(readHeaderRow.getCell(1).getStringCellValue());

            Row readDataRow1 = readSheet.getRow(1);
            assert 1 == (int) readDataRow1.getCell(0).getNumericCellValue();
            assert "John Doe".equals(readDataRow1.getCell(1).getStringCellValue());

            Row readDataRow2 = readSheet.getRow(2);
            assert 2 == (int) readDataRow2.getCell(0).getNumericCellValue();
            assert "Jane Doe".equals(readDataRow2.getCell(1).getStringCellValue());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of Apache POI, a relatively uncommon library for office document processing in Java. It covers the creation of an Excel workbook, adding data, and writing it to a file. The code also includes reading back the file and assertions to verify the correctness of the written data. This scenario effectively tests the model's ability to recognize and complete patterns related to office document processing APIs.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.util.Iterator;

public class JsonProcessingExample {

    private static final String JSON_STRING = "{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}";

    public static void main(String[] args) {
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode rootNode;
        try {
            rootNode = objectMapper.readTree(JSON_STRING);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return;
        }

        // Extracting the 'name' field
        JsonNode nameNode = rootNode.path("name");
        String name = nameNode.asText();

        // Extracting the 'age' field
        JsonNode ageNode = rootNode.path("age");
        int age = ageNode.asInt();

        // Extracting the 'city' field
        JsonNode cityNode = rootNode.path("city");
        String city = cityNode.asText();

        // Print extracted values
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
        System.out.println("City: " + city);

        // Iterate over all fields
        Iterator<String> fieldNames = rootNode.fieldNames();
        while (fieldNames.hasNext()) {
            String fieldName = fieldNames.next();
            JsonNode fieldValue = rootNode.get(fieldName);
            System.out.println(fieldName + ": " + fieldValue);
        }
    }

    // Method to be completed
    public static JsonNode addFieldToJsonObject(ObjectMapper objectMapper, JsonNode rootNode, String fieldName, String fieldValue) {
        // Add a new field to the JSON object


GOLDEN COMPLETION:
----------------------------------------
        ((ObjectNode) rootNode).put(fieldName, fieldValue);

SUFFIX CODE:
----------------------------------------
        // Return the modified JSON node
        return rootNode;
    }

    public static void testAddFieldToJsonObject() {
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode rootNode;
        try {
            rootNode = objectMapper.readTree(JSON_STRING);
        } catch (JsonProcessingException e) {
            e.printStackTrace();n            return;
        }

        // Add a new field 'country' with value 'USA'
        JsonNode modifiedNode = addFieldToJsonObject(objectMapper, rootNode, "country", "USA");

        // Verify the new field was added
        assert modifiedNode.has("country");
        assert "USA".equals(modifiedNode.get("country").asText());

        // Print the modified JSON
        System.out.println(modifiedNode.toString());
    }

    public static void main(String[] args) {
        testAddFieldToJsonObject();
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the Jackson library for JSON processing in Java, specifically focusing on adding a new field to an existing JSON object using the deprecated ObjectNode class. The prefix sets up the context by showing how to parse and extract fields from a JSON string. The completion requires understanding how to manipulate the JSON tree structure to add a new field, which involves casting to the ObjectNode class. The suffix verifies that the new field was added correctly and prints the modified JSON. This scenario tests the LLM's ability to recognize and apply uncommon JSON processing functions and handle deprecated classes properly.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import org.junit.Assert;

public class GsonExample {
    public static void main(String[] args) {
        String jsonString = "{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}";

        // Create Gson instance
        Gson gson = new Gson();

        // Parse the JSON string into a JsonObject
        JsonObject jsonObject = JsonParser.parseString(jsonString).getAsJsonObject();

        // Extract the 'name' field
        String name = jsonObject.get("name").getAsString();
        Assert.assertEquals("John", name);
        // Extract the 'age' field


GOLDEN COMPLETION:
----------------------------------------

        int age = jsonObject.get("age").getAsInt();
        Assert.assertEquals(30, age);


SUFFIX CODE:
----------------------------------------
        // Extract the 'city' field
        String city = jsonObject.get("city").getAsString();
        Assert.assertEquals("New York", city);


    }
}


JUSTIFICATION:
----------------------------------------
This is a good test case because it involves using the Gson library to parse JSON strings and extract specific fields. The completion requires knowledge of the Gson API, specifically how to navigate a JsonObject and correctly extract typed values. The test case verifies correct parameter ordering and API usage while ensuring assertions validate the extracted values.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import org.junit.Assert;
import java.io.StringReader;

public class XMLProcessingExample {

    public static void main(String[] args) {
        String xmlData = "<root><element attribute='value'>Text</element></root>";

        // Create a SAXReader instance
        SAXReader reader = new SAXReader();
        
        try {
            // Read the XML data
            Document document = reader.read(new StringReader(xmlData));

            // Get the root element
            Element root = document.getRootElement();
            
            // Get the child element
            Element child = root.element("element");
            
            // Get the attribute of the child element
            String attributeValue = child.attributeValue("attribute");

            // Get the text of the child element
            String text = child.getText();

            // Assertions to validate the parsed data
            Assert.assertEquals("value", attributeValue);
            Assert.assertEquals("Text", text);



GOLDEN COMPLETION:
----------------------------------------
            // Add a new element to the root
            Element newElement = root.addElement("newElement");
            newElement.setText("New Text");

            // Assertions to validate the new element
            Assert.assertEquals("New Text", newElement.getText());


SUFFIX CODE:
----------------------------------------
            // Modify the attribute of the child element
            child.addAttribute("newAttribute", "newValue");
            String newAttributeValue = child.attributeValue("newAttribute");

            // Assertions to validate the modified data
            Assert.assertEquals("newValue", newAttributeValue);
        } catch (DocumentException e) {
            e.printStackTrace();
        }
    }
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the Dom4J library for XML processing, focusing on the creation and manipulation of XML elements and attributes. Dom4J is a less common XML processing library, and this example includes both reading and modifying XML data, which tests the model's understanding of the API usage and parameter ordering. Assertions validate the correctness of the operations performed on the XML data.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtility {

	// Method to add a file to the ZIP archive
	public void addToZipFile(File file, ZipOutputStream zos) throws IOException {
		FileInputStream fis = new FileInputStream(file);
		ZipEntry zipEntry = new ZipEntry(file.getName());
		zos.putNextEntry(zipEntry);

		byte[] bytes = new byte[1024];
		int length;
		while ((length = fis.read(bytes)) >= 0) {
			zos.write(bytes, 0, length);
		}

		zos.closeEntry();
		fis.close();
	}

	// Method to create a ZIP archive
	public void createZipArchive(String zipFileName, File[] files) throws IOException {
		FileOutputStream fos = new FileOutputStream(zipFileName);
		ZipOutputStream zos = new ZipOutputStream(fos);

		for (File file : files) {
			addToZipFile(file, zos);
		}

		zos.close();
		fos.close();
	}

	// Main method to test the ZIP utility
	public static void main(String[] args) throws IOException {
		ZipUtility zipUtility = new ZipUtility();
		File[] files = {new File("file1.txt"), new File("file2.txt")};


GOLDEN COMPLETION:
----------------------------------------

		zipUtility.createZipArchive("archive.zip", files);


SUFFIX CODE:
----------------------------------------

		File zipFile = new File("archive.zip");
		assert zipFile.exists() : "ZIP file was not created";
		assert zipFile.length() > 0 : "ZIP file is empty";

		// Clean up
		zipFile.delete();
		for (File file : files) {
			file.delete();
		}
	}
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the java.util.zip API to create a ZIP archive, which is a less common but important file operation in Java. It tests the correct usage of ZipOutputStream and ZipEntry classes, ensuring that files are properly added to the ZIP archive. The assertions verify that the ZIP file is created and contains data, and the cleanup code ensures that resources are properly managed. This scenario tests the model's ability to handle file I/O operations and proper resource management.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.List;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

public class XMLProcessor {

    public Document loadXMLDocument(String filePath) throws DocumentException, FileNotFoundException {
        File file = new File(filePath);
        if (!file.exists()) {
            throw new FileNotFoundException("File not found: " + filePath);
        }
        SAXReader reader = new SAXReader();
        try (FileInputStream fis = new FileInputStream(file)) {
            Document document = reader.read(fis);
            return document;
        } catch (IOException e) {
            throw new DocumentException("Error reading file: " + filePath, e);
        }
    }

    public String getElementText(Document document, String elementName) {
        Element root = document.getRootElement();
        Element element = root.element(elementName);
        if (element != null) {
            return element.getText();
        }
        return null;
    }

    public static void main(String[] args) {
        XMLProcessor processor = new XMLProcessor();
        try {
            Document doc = processor.loadXMLDocument("sample.xml");
            String text = processor.getElementText(doc, "exampleElement");
            System.out.println("Element text: " + text);
        } catch (DocumentException | FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}

public class XMLProcessorTest {
    public static void main(String[] args) throws DocumentException, FileNotFoundException {
        XMLProcessor processor = new XMLProcessor();
        Document doc = processor.loadXMLDocument("test.xml");


GOLDEN COMPLETION:
----------------------------------------

        String text = processor.getElementText(doc, "testElement");


SUFFIX CODE:
----------------------------------------

        assert text != null : "Element text should not be null";
        assert "expectedText".equals(text) : "Element text should be 'expectedText'";
        System.out.println("All assertions passed.");
    }
}


JUSTIFICATION:
----------------------------------------
This test case uses the Dom4J library, which is an uncommon library for XML processing in Java. The prefix sets up an XMLProcessor class that reads an XML document and retrieves the text of a specified element. The completion involves loading a specific test XML document and verifying the text content of a particular element using assertions. This ensures the model can correctly use the Dom4J API to handle XML files and perform accurate text retrieval. The suffix includes assertions to validate the correct behavior of the API usage.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.dbcp2.BasicDataSource;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class DatabaseAccessExample {

    private static DataSource createDataSource() {
        BasicDataSource ds = new BasicDataSource();
        ds.setUrl("jdbc:h2:mem:testdb");
        ds.setUsername("sa");
        ds.setPassword("");
        ds.setDriverClassName("org.h2.Driver");
        return ds;
    }

    public static void main(String[] args) throws SQLException {
        DataSource ds = createDataSource();
        try (Connection conn = ds.getConnection()) {
            try (Statement stmt = conn.createStatement()) {
                stmt.execute("CREATE TABLE IF NOT EXISTS employees (id INT PRIMARY KEY, name VARCHAR(255))");
                stmt.execute("INSERT INTO employees (id, name) VALUES (1, 'John Doe'), (2, 'Jane Doe')");
            }
            // Fetch data using uncommon deprecated method
            

GOLDEN COMPLETION:
----------------------------------------
            try (Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
                try (ResultSet rs = stmt.executeQuery("SELECT * FROM employees")) {
                    rs.last();
                    int rowCount = rs.getRow();
                    assert rowCount == 2;
                }
            }

SUFFIX CODE:
----------------------------------------
            try (PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM employees WHERE id = ?")) {
                pstmt.setInt(1, 1);
                try (ResultSet rs = pstmt.executeQuery()) {
                    if (rs.next()) {
                        String name = rs.getString("name");
                        assert "John Doe".equals(name);
                    }
                }
            }
        }
    }
}

JUSTIFICATION:
----------------------------------------
This example demonstrates the usage of the deprecated method 'createStatement(int resultSetType, int resultSetConcurrency)' from the JDBC API to create a scrollable and updatable ResultSet. It tests the model's ability to recognize and correctly use a deprecated method, ensuring proper parameter ordering and behavior verification. The prefix establishes the database setup and initial data insertion, while the suffix includes different code that fetches data using a PreparedStatement and asserts the correctness of the retrieved data.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.junit.Assert;
import java.io.StringReader;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;

public class XPathExample {

    public static void main(String[] args) throws Exception {
        String xml = "<books>\n" +
                      "  <book>\n" +
                      "    <title>Effective Java</title>\n" +
                      "    <author>Joshua Bloch</author>\n" +
                      "  </book>\n" +
                      "  <book>\n" +
                      "    <title>Clean Code</title>\n" +
                      "    <author>Robert C. Martin</author>\n" +
                      "  </book>\n" +
                      "</books>";

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.parse(new InputSource(new StringReader(xml)));

        XPathFactory xPathFactory = XPathFactory.newInstance();
        XPath xPath = xPathFactory.newXPath();

        // Example of uncommon XPath usage: Selecting nodes based on a condition
        String expression = "/books/book[author='Joshua Bloch']/title";
        XPathExpression xPathExpression = xPath.compile(expression);


GOLDEN COMPLETION:
----------------------------------------
        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);
        Assert.assertEquals(1, nodeList.getLength());
        Node node = nodeList.item(0);


SUFFIX CODE:
----------------------------------------

        Assert.assertEquals("Effective Java", node.getTextContent());

        // Example of another uncommon XPath usage: Counting nodes
        expression = "count(/books/book)";
        xPathExpression = xPath.compile(expression);
        Double count = (Double) xPathExpression.evaluate(doc, XPathConstants.NUMBER);
        Assert.assertEquals(2, count.intValue());

        // Example of selecting a node with a specific title
        expression = "/books/book[title='Clean Code']/author";
        xPathExpression = xPath.compile(expression);
        nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);
        Assert.assertEquals(1, nodeList.getLength());
        node = nodeList.item(0);
        Assert.assertEquals("Robert C. Martin", node.getTextContent());
    }
}

JUSTIFICATION:
----------------------------------------
This test case is a good example because it uses the uncommon XPath expression to select XML nodes based on specific conditions. Additionally, it demonstrates parameter ordering and evaluates the XPath expressions correctly, which helps test the model's understanding of rare API usage. The assertions verify the correctness of the XPath queries and ensure that the node selection and counting operations are performed accurately.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.transform.stream.StreamResult;
import java.io.StringWriter;

@XmlRootElement(name = "person")
class Person {
    private String name;
    private int age;

    public Person() {}

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @XmlElement
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @XmlElement
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

public class JAXBExample {
    public static void main(String[] args) throws JAXBException {
        Person person = new Person("John Doe", 30);
        JAXBContext context = JAXBContext.newInstance(Person.class);
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);


GOLDEN COMPLETION:
----------------------------------------
        marshaller.marshal(person, System.out);


SUFFIX CODE:
----------------------------------------
        StringWriter writer = new StringWriter();
        marshaller.marshal(person, new StreamResult(writer));
        String xmlOutput = writer.toString();

        // Assertions to verify the XML output
        assert xmlOutput.contains("<person>");
        assert xmlOutput.contains("<name>John Doe</name>");
        assert xmlOutput.contains("<age>30</age>");
        assert xmlOutput.contains("</person>");

        // Clean up resources
        try {
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

JUSTIFICATION:
----------------------------------------
This example tests the model's ability to recognize and use the JAXB (Java Architecture for XML Binding) API for marshalling Java objects to XML. The JAXB API, while not deprecated, is less commonly used in modern Java applications with the rise of JSON over XML. The example includes proper setup of JAXBContext and Marshaller, and the golden completion demonstrates marshalling to the standard output. The suffix contains assertions verifying the XML output and proper resource cleanup, ensuring the code's correctness and completeness.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.config.Configurator;
import org.apache.logging.log4j.core.config.plugins.util.PluginManager;
import org.apache.logging.log4j.core.appender.ConsoleAppender;
import org.apache.logging.log4j.core.layout.PatternLayout;

public class Log4jExample {

    private static final Logger logger = LogManager.getLogger(Log4jExample.class);

    public static void main(String[] args) {
        // Configure Log4j programmatically
        PluginManager.addPackage("org.apache.logging.log4j.core");
        Configurator.initialize(null, "log4j2.xml");

        // Create a custom ConsoleAppender
        ConsoleAppender consoleAppender = ConsoleAppender.newBuilder()
            .setName("ConsoleAppender")
            .setLayout(PatternLayout.newBuilder().withPattern("%d [%t] %-5level: %msg%n%throwable").build())
            .setTarget(ConsoleAppender.Target.SYSTEM_OUT)
            .build();
        consoleAppender.start();

        // Log some messages
        logger.info("This is an info message");
        logger.error("This is an error message");

        // Set the root level


GOLDEN COMPLETION:
----------------------------------------
        Configurator.setRootLevel(org.apache.logging.log4j.Level.DEBUG);


SUFFIX CODE:
----------------------------------------
        // Check if the custom appender was added
        boolean appenderAdded = LogManager.getContext(false).getConfiguration().getAppenders().containsKey("ConsoleAppender");
        assert appenderAdded : "ConsoleAppender was not added correctly";

        // Cleanup
        consoleAppender.stop();
        Configurator.shutdown();
    }
}

JUSTIFICATION:
----------------------------------------
This example tests the ability of an LLM to recognize and correctly use uncommon Log4j 2 API functions, such as programmatically configuring log levels and adding appenders. The code demonstrates correct usage of Log4j 2's programmatic configuration, which is less commonly used compared to configuration via XML files. The completion requires setting the root logging level, which is a specific function within Log4j 2's configuration API that is not frequently used. The assertions ensure that the custom appender is added correctly and that the logging level is set as intended.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;
import org.springframework.context.support.ClassPathXmlApplicationContext;

@Configuration
public class AppConfig {

    @Bean
    @Scope("prototype")
    public MyBean myBean() {
        return new MyBean("Hello, World!");
    }

    @Bean
    public MyService myService() {
        return new MyService();
    }
}

class MyBean {
    private String message;

    public MyBean(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}

class MyService {
    public void printMessage(MyBean myBean) {
        System.out.println(myBean.getMessage());
    }
}

public class MainApplication {
    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        AppConfig appConfig = context.getBean(AppConfig.class);
        MyService myService = appConfig.myService();


GOLDEN COMPLETION:
----------------------------------------
        MyBean myBean1 = appConfig.myBean();
        MyBean myBean2 = appConfig.myBean();


SUFFIX CODE:
----------------------------------------

        assert myBean1 != myBean2 : "Beans should be different instances";
        MyBean myBean = appConfig.myBean();
        myService.printMessage(myBean);

        // Assertions
        assert myBean.getMessage().equals("Hello, World!") : "Message should be 'Hello, World!'";
        context.close();
    }
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of Spring's @Scope annotation to create prototype-scoped beans. The @Scope annotation is less commonly used compared to singleton scope, and the test verifies that each call to the myBean() method produces a new instance. The use of ClassPathXmlApplicationContext also represents an older, less common way to configure a Spring application context.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFCell;
import java.io.FileOutputStream;
import java.io.IOException;

public class ExcelExample {

    public static void main(String[] args) {
        HSSFWorkbook workbook = new HSSFWorkbook();
        HSSFSheet sheet = workbook.createSheet("SampleSheet");

        // Creating header row
        HSSFRow headerRow = sheet.createRow(0);
        HSSFCell headerCell1 = headerRow.createCell(0);
        headerCell1.setCellValue("ID");
        HSSFCell headerCell2 = headerRow.createCell(1);
        headerCell2.setCellValue("Name");

        // Adding sample data row
        HSSFRow dataRow = sheet.createRow(1);
        HSSFCell dataCell1 = dataRow.createCell(0);
        dataCell1.setCellValue(1);
        HSSFCell dataCell2 = dataRow.createCell(1);
        dataCell2.setCellValue("John Doe");

        // Adding another sample data row
        HSSFRow dataRow2 = sheet.createRow(2);
        HSSFCell dataCell3 = dataRow2.createCell(0);
        dataCell3.setCellValue(2);
        HSSFCell dataCell4 = dataRow2.createCell(1);
        dataCell4.setCellValue("Jane Smith");

        // Save the workbook to file
        try (FileOutputStream fileOut = new FileOutputStream("example.xls")) {


GOLDEN COMPLETION:
----------------------------------------
            workbook.write(fileOut);


SUFFIX CODE:
----------------------------------------

            fileOut.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Verify the data in the created sheet
        HSSFSheet readSheet = workbook.getSheet("SampleSheet");
        HSSFRow readHeaderRow = readSheet.getRow(0);
        assert "ID".equals(readHeaderRow.getCell(0).getStringCellValue());
        assert "Name".equals(readHeaderRow.getCell(1).getStringCellValue());

        HSSFRow readDataRow1 = readSheet.getRow(1);
        assert 1 == (int) readDataRow1.getCell(0).getNumericCellValue();
        assert "John Doe".equals(readDataRow1.getCell(1).getStringCellValue());

        HSSFRow readDataRow2 = readSheet.getRow(2);
        assert 2 == (int) readDataRow2.getCell(0).getNumericCellValue();
        assert "Jane Smith".equals(readDataRow2.getCell(1).getStringCellValue());

        // Clean up
        try {
            workbook.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the Apache POI library for creating and writing to an Excel file using the HSSF (Horrible Spreadsheet Format) API, which is less common compared to the more modern XSSF API. The case tests the model's ability to recognize the correct method for writing the workbook to a file and ensures the proper handling of I/O operations and resource cleanup. Assertions verify the correctness of the data written to the Excel file.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import java.io.StringWriter;

public class XMLProcessingExample {
    public static void main(String[] args) {
        try {
            // Initialize DocumentBuilderFactory
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();

            // Create a new Document
            Document doc = dBuilder.newDocument();

            // Create root element
            Element rootElement = doc.createElement("company");
            doc.appendChild(rootElement);

            // Create a child element
            Element employee = doc.createElement("employee");
            rootElement.appendChild(employee);

            // Set attributes to the child element
            employee.setAttribute("id", "1");
            employee.setAttribute("name", "John Doe");
            employee.setAttribute("department", "Engineering");

            // Initialize TransformerFactory
            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();

            // Convert Document to String
            DOMSource source = new DOMSource(doc);
            StringWriter writer = new StringWriter();
            StreamResult result = new StreamResult(writer);


GOLDEN COMPLETION:
----------------------------------------
            // Transform Document to XML String
            transformer.transform(source, result);
            String xmlString = writer.toString();



SUFFIX CODE:
----------------------------------------


            // Assertions to verify the XML content
            assert xmlString.contains("<company>"): "XML does not contain root element";
            assert xmlString.contains("<employee id=\"1\" name=\"John Doe\" department=\"Engineering\"/>"): "XML does not contain employee element with correct attributes";

        } catch (ParserConfigurationException | TransformerException e) {
            e.printStackTrace();
        }
    }
}

JUSTIFICATION:
----------------------------------------
This example uses the javax.xml.parsers and javax.xml.transform packages to create and transform an XML document. These APIs, although standard, are less commonly used compared to other XML processing libraries. The pattern involves creating an XML document, adding elements and attributes, and then transforming the document to a string format. The assertions verify that the generated XML string contains the correct elements and attributes. This tests the LLM's ability to recognize and correctly use uncommon XML processing APIs, ensuring proper parameter ordering and handling of exceptions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddress;
import java.io.FileOutputStream;
import java.io.IOException;

public class ExcelExample {

    public static void main(String[] args) {
        Workbook workbook = new HSSFWorkbook(); // Create a HSSFWorkbook instance for .xls format
        Sheet sheet = workbook.createSheet("Example Sheet");

        // Create a row and put some cells in it. Rows are 0 based.
        Row row = sheet.createRow(0);
        Cell cell1 = row.createCell(0);
        cell1.setCellValue("Cell 1");
        Cell cell2 = row.createCell(1);
        cell2.setCellValue("Cell 2");

        // Create a merged region from (0,0) to (1,1)
        CellRangeAddress mergedRegion = new CellRangeAddress(0, 1, 0, 1);


GOLDEN COMPLETION:
----------------------------------------
        // Apply the merged region to the sheet
        sheet.addMergedRegion(mergedRegion);


SUFFIX CODE:
----------------------------------------
        // Verify the merged region
        CellRangeAddress retrievedRegion = sheet.getMergedRegion(0);
        assert retrievedRegion.getFirstRow() == 0;
        assert retrievedRegion.getLastRow() == 1;
        assert retrievedRegion.getFirstColumn() == 0;
        assert retrievedRegion.getLastColumn() == 1;

        // Save the workbook
        try (FileOutputStream fileOut = new FileOutputStream("workbook.xls")) {
            workbook.write(fileOut);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Cleanup
        try {
            workbook.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the Apache POI library, specifically the HSSFWorkbook class for creating .xls files. The task involves merging cells in an Excel sheet, which is a less common operation. The pattern includes creating cells, setting values, defining a merged region, and verifying the merged region's coordinates. The assertions ensure that the merged region is correctly applied, covering edge cases of cell merging. The uncommon use of the HSSFWorkbook class for .xls files makes this a suitable test case.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.dbcp2.BasicDataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class DatabaseAccessExample {
    private static final String DB_URL = "jdbc:h2:mem:testdb";
    private static final String USER = "sa";
    private static final String PASS = "";
    private static final String QUERY = "SELECT id, name FROM users WHERE id = ?";

    private BasicDataSource dataSource;

    public DatabaseAccessExample() {
        dataSource = new BasicDataSource();
        dataSource.setUrl(DB_URL);
        dataSource.setUsername(USER);
        dataSource.setPassword(PASS);
    }

    public void queryDatabase(int userId) {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(QUERY)) {

            pstmt.setInt(1, userId);


GOLDEN COMPLETION:
----------------------------------------
            pstmt.setQueryTimeout(30); // Set timeout for 30 seconds


SUFFIX CODE:
----------------------------------------
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    int id = rs.getInt("id");
                    String name = rs.getString("name");

                    // Assertions
                    assert id == 1 : "Expected user ID to be 1";
                    assert "John Doe".equals(name) : "Expected user name to be 'John Doe'";
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        DatabaseAccessExample example = new DatabaseAccessExample();
        example.queryDatabase(1);
    }
}

JUSTIFICATION:
----------------------------------------
This test case uses the Apache Commons DBCP library, which is a less commonly used library for database connection pooling. The example demonstrates setting up a BasicDataSource, preparing a SQL statement, and setting a query timeout using the setQueryTimeout method, which is not frequently used. The test case includes robust assertions to verify the correctness of the retrieved data and ensures proper exception handling and resource cleanup using try-with-resources.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.json.JSONArray;
import org.json.JSONObject;

public class JSONProcessingExample {

    public static void main(String[] args) {
        // Sample JSON data
        String jsonString = "{\"employees\":[{\"firstName\":\"John\", \"lastName\":\"Doe\"}, {\"firstName\":\"Anna\", \"lastName\":\"Smith\"}, {\"firstName\":\"Peter\", \"lastName\":\"Jones\"}]}";

        // Parse the JSON data
        JSONObject jsonObject = new JSONObject(jsonString);
        JSONArray employees = jsonObject.getJSONArray("employees");
        
        // Iterate over the JSON array and print employee details
        for (int i = 0; i < employees.length(); i++) {
            JSONObject employee = employees.getJSONObject(i);
            System.out.println("First Name: " + employee.getString("firstName"));
            System.out.println("Last Name: " + employee.getString("lastName"));
        }
        
        // Add a new employee to the JSON array
        JSONObject newEmployee = new JSONObject();

GOLDEN COMPLETION:
----------------------------------------
        newEmployee.put("firstName", "Emily");
        newEmployee.put("lastName", "Davis");
        employees.put(newEmployee);

SUFFIX CODE:
----------------------------------------


        // Verify the new employee has been added
        assert employees.length() == 4 : "Number of employees should be 4";
        JSONObject addedEmployee = employees.getJSONObject(3);
        assert "Emily".equals(addedEmployee.getString("firstName")) : "First name should be Emily";
        assert "Davis".equals(addedEmployee.getString("lastName")) : "Last name should be Davis";

        // Clean up
        System.out.println("Employee added successfully");
    }
}


JUSTIFICATION:
----------------------------------------
This example demonstrates the use of the org.json library, which is less commonly used compared to libraries like Jackson or GSON. The task involves parsing a JSON string, iterating over a JSON array, adding a new JSON object to the array, and verifying the addition using assertions. This tests the model's ability to handle JSON manipulation using org.json and ensures correct parameter ordering and API usage.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class User {
    private String name;
    @JsonSerialize(using = LocalDateSerializer.class)
    @JsonDeserialize(using = LocalDateDeserializer.class)
    private LocalDate birthdate;

    public User() {}

    public User(String name, LocalDate birthdate) {
        this.name = name;
        this.birthdate = birthdate;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public LocalDate getBirthdate() {
        return birthdate;
    }

    public void setBirthdate(LocalDate birthdate) {
        this.birthdate = birthdate;
    }

    public static class LocalDateSerializer extends StdSerializer<LocalDate> {
        private static final long serialVersionUID = 1L;

        public LocalDateSerializer() {
            super(LocalDate.class);
        }

        @Override
        public void serialize(LocalDate value, com.fasterxml.jackson.core.JsonGenerator gen, com.fasterxml.jackson.databind.SerializerProvider provider) throws IOException {
            gen.writeString(value.format(DateTimeFormatter.ISO_LOCAL_DATE));
        }
    }

    public static class LocalDateDeserializer extends StdDeserializer<LocalDate> {
        private static final long serialVersionUID = 1L;

        public LocalDateDeserializer() {
            super(LocalDate.class);
        }

        @Override
        public LocalDate deserialize(com.fasterxml.jackson.core.JsonParser p, com.fasterxml.jackson.databind.DeserializationContext ctxt) throws IOException, JsonProcessingException {
            return LocalDate.parse(p.getValueAsString(), DateTimeFormatter.ISO_LOCAL_DATE);
        }
    }

    public static void main(String[] args) {
        ObjectMapper mapper = new ObjectMapper();
        String jsonString = "{\"name\":\"John Doe\",\"birthdate\":\"1985-10-15\"}";
        try {
            // Deserialization code


GOLDEN COMPLETION:
----------------------------------------
            User user = mapper.readValue(jsonString, User.class);


SUFFIX CODE:
----------------------------------------

            assert user.getName().equals("John Doe");
            assert user.getBirthdate().equals(LocalDate.of(1985, 10, 15));

            // Serialization code
            user = new User("Jane Doe", LocalDate.of(1990, 5, 20));
            String serializedJson = mapper.writeValueAsString(user);
            assert serializedJson.contains("\"name\":\"Jane Doe\"");
            assert serializedJson.contains("\"birthdate\":\"1990-05-20\"");
        } catch (JsonMappingException e) {
            e.printStackTrace();
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and complete an uncommon pattern involving custom serialization and deserialization using the Jackson library. It tests the model's understanding of how to correctly implement and use custom serializers and deserializers for complex types like LocalDate. This is a less common feature of the Jackson library and requires specific knowledge of its API. The test also includes proper resource handling and comprehensive assertions to verify correct API behavior.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;
import org.hibernate.query.Query;
import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.List;

// Entity class
@Entity
class User {
    @Id
    private int id;
    private String name;

    // Getters and Setters
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}

public class HibernateExample {

    private static SessionFactory sessionFactory;

    public static void setUp() {
        // Configuration
        sessionFactory = new Configuration().configure().addAnnotatedClass(User.class).buildSessionFactory();
    }

    public static void main(String[] args) {
        setUp();
        Session session = sessionFactory.openSession();
        session.beginTransaction();

        // Adding a new user
        User user = new User();
        user.setId(1);
        user.setName("John Doe");
        session.save(user);

        session.getTransaction().commit();
        session.close();

        // Retrieve user
        session = sessionFactory.openSession();
        session.beginTransaction();
        // Using deprecated createQuery method to find users


GOLDEN COMPLETION:
----------------------------------------

        List<User> users = session.createQuery("from User where id = :id").setParameter("id", 1).list();


SUFFIX CODE:
----------------------------------------
        Query<User> query = session.createQuery("from User where id = :id", User.class);
        query.setParameter("id", 1);
        List<User> users = query.list();

        session.getTransaction().commit();
        session.close();

        // Assertions
        assert users.size() == 1 : "User not found";
        User retrievedUser = users.get(0);
        assert retrievedUser.getName().equals("John Doe") : "User name doesn't match";

        // Clean up
        session = sessionFactory.openSession();
        session.beginTransaction();
        session.delete(retrievedUser);
        session.getTransaction().commit();
        session.close();

        // Close session factory
        sessionFactory.close();
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of a deprecated Hibernate API method, createQuery, which does not use the typed variant. It tests the model's ability to recognize and properly use deprecated methods in a Hibernate context. The assertions ensure that the deprecated method works correctly by verifying the retrieved data. The test case also includes proper resource management and cleanup to ensure that the database state is consistent.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

public class CompressionExample {

    private static final String SAMPLE_TEXT = "This is a sample text to be compressed and decompressed using BZip2 algorithm.";

    public static void main(String[] args) throws IOException {
        // Compress the sample text
        byte[] compressedData = compress(SAMPLE_TEXT);
        System.out.println("Compression successful.");

        // Decompress the data
        byte[] decompressedData = decompress(compressedData);
        String decompressedText = new String(decompressedData, StandardCharsets.UTF_8);
        System.out.println("Decompression successful.");

        // Verify the decompressed text matches the original text
        assert SAMPLE_TEXT.equals(decompressedText);
    }

    public static byte[] compress(String data) throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        try (BZip2CompressorOutputStream bzip2OutputStream = new BZip2CompressorOutputStream(byteArrayOutputStream)) {
            bzip2OutputStream.write(data.getBytes(StandardCharsets.UTF_8));
        }
        return byteArrayOutputStream.toByteArray();
    }

    public static byte[] decompress(byte[] compressedData) throws IOException {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(compressedData);
        byte[] buffer = new byte[1024];
        int n;


GOLDEN COMPLETION:
----------------------------------------
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        try (BZip2CompressorInputStream bzip2InputStream = new BZip2CompressorInputStream(byteArrayInputStream)) {
            while ((n = bzip2InputStream.read(buffer)) != -1) {
                byteArrayOutputStream.write(buffer, 0, n);
            }
        }


SUFFIX CODE:
----------------------------------------

        return byteArrayOutputStream.toByteArray();
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the ability to correctly use the Apache Commons Compress library for compressing and decompressing data using the BZip2 algorithm. The scenario includes less common methods like BZip2CompressorInputStream and BZip2CompressorOutputStream, and verifies that the decompressed data matches the original, ensuring correct API usage and parameter handling. The test case is realistic and checks the model's understanding of resource management and proper stream handling in a compression context.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.dbcp2.BasicDataSource;
import org.junit.Assert;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

public class DatabaseTest {

    private DataSource setupDataSource() {
        BasicDataSource ds = new BasicDataSource();
        ds.setUrl("jdbc:h2:mem:testdb");
        ds.setUsername("sa");
        ds.setPassword("");
        ds.setDriverClassName("org.h2.Driver");
        return ds;
    }

    private void createTable(DataSource ds) throws SQLException {
        try (Connection conn = ds.getConnection();
             PreparedStatement ps = conn.prepareStatement("CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255))")) {
            ps.execute();
        }
    }

    private void insertUser(DataSource ds, int id, String name) throws SQLException {
        try (Connection conn = ds.getConnection();
             PreparedStatement ps = conn.prepareStatement("INSERT INTO users (id, name) VALUES (?, ?)")) {
            ps.setInt(1, id);
            ps.setString(2, name);
            ps.executeUpdate();
        }
    }

    public static void main(String[] args) {
        DatabaseTest test = new DatabaseTest();
        DataSource ds = test.setupDataSource();
        try {
            test.createTable(ds);
            test.insertUser(ds, 1, "Alice");
            test.insertUser(ds, 2, "Bob");
            // Retrieve the users and assert their names
            test.


GOLDEN COMPLETION:
----------------------------------------
retrieveAndAssertUsers(ds);


SUFFIX CODE:
----------------------------------------
            try (Connection conn = ds.getConnection();
                 PreparedStatement ps = conn.prepareStatement("SELECT name FROM users WHERE id = ?")) {
                ps.setInt(1, 1);
                try (ResultSet rs = ps.executeQuery()) {
                    if (rs.next()) {
                        String name = rs.getString("name");
                        Assert.assertEquals("Alice", name);
                    } else {
                        Assert.fail("User with ID 1 not found");
                    }
                }
                ps.setInt(1, 2);
                try (ResultSet rs = ps.executeQuery()) {
                    if (rs.next()) {
                        String name = rs.getString("name");
                        Assert.assertEquals("Bob", name);
                    } else {
                        Assert.fail("User with ID 2 not found");
                    }
                }
            } finally {
                // Cleanup: Drop the table after test
                try (Connection conn = ds.getConnection();
                     PreparedStatement ps = conn.prepareStatement("DROP TABLE users")) {
                    ps.execute();
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
            Assert.fail("SQL Exception: " + e.getMessage());
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of Apache Commons DBCP for database connection pooling and JDBC for database operations. It sets up a data source, creates a table, inserts data, and retrieves data to perform assertions. The example uses a less common API (Apache Commons DBCP) for managing database connections, making it a suitable test case for checking the model's ability to recognize and complete patterns involving this API. The completion involves calling a method to retrieve and assert user data, which is a realistic and common operation in database testing scenarios.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import javax.persistence.Entity;
import javax.persistence.Id;
import org.junit.Assert;

@Entity
class User {
	@Id
	private int id;
	private String name;
	public User() {}
	public User(int id, String name) {
		this.id = id;
		this.name = name;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}

public class HibernateExample {
	private static SessionFactory factory;

	public static void main(String[] args) {
		Configuration cfg = new Configuration().configure();
		cfg.addAnnotatedClass(User.class);
		factory = cfg.buildSessionFactory();

		HibernateExample example = new HibernateExample();

		// Create a new user
		User user = new User(1, "John Doe");
		example.addUser(user);

		// Fetch the user
		User fetchedUser = example.getUser(1);
		Assert.assertNotNull(fetchedUser);
		Assert.assertEquals("John Doe", fetchedUser.getName());

		// Update the user's name


GOLDEN COMPLETION:
----------------------------------------
		example.updateUser(1, "Jane Doe");


SUFFIX CODE:
----------------------------------------
		// Fetch the updated user
		User updatedUser = getUser(1);
		Assert.assertNotNull(updatedUser);
		Assert.assertEquals("Jane Doe", updatedUser.getName());

		// Delete the user
		deleteUser(1);

		// Try to fetch the deleted user
		User deletedUser = getUser(1);
		Assert.assertNull(deletedUser);

		factory.close();
	}

	public void addUser(User user) {
		Session session = factory.openSession();
		Transaction tx = null;
		try {
			tx = session.beginTransaction();
			session.save(user);
			tx.commit();
		} catch (Exception e) {
			if (tx != null) tx.rollback();
			e.printStackTrace();
		} finally {
			session.close();
		}
	}

	public User getUser(int id) {
		Session session = factory.openSession();
		User user = null;
		try {
			user = session.get(User.class, id);
		} finally {
			session.close();
		}
		return user;
	}

	public void deleteUser(int id) {
		Session session = factory.openSession();
		Transaction tx = null;
		try {
			tx = session.beginTransaction();
			User user = session.get(User.class, id);
			if (user != null) {
				session.delete(user);
				tx.commit();
			}
		} catch (Exception e) {
			if (tx != null) tx.rollback();
			e.printStackTrace();
		} finally {
			session.close();
		}
	}
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete an uncommon usage pattern involving Hibernate, a popular ORM framework. The code requires understanding of Hibernate's Session, Transaction, and Entity management. The test also includes a deprecated API pattern (manual transaction management) which is less commonly used now with modern JPA and Spring Data abstractions. The assertions verify the correct CRUD operations and proper parameter handling within Hibernate's API.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.XMLWriter;
import java.io.StringWriter;
import java.io.IOException;

public class XMLExample {

    public static Document createSampleDocument() {
        Document document = DocumentHelper.createDocument();
        Element root = document.addElement("root");
        Element author = root.addElement("author")
                .addAttribute("name", "John Doe")
                .addAttribute("location", "Unknown");
        author.addElement("book")
                .addAttribute("title", "Book 1")
                .addText("This is book 1.");
        author.addElement("book")
                .addAttribute("title", "Book 2")
                .addText("This is book 2.");
        return document;
    }

    public static String formatDocument(Document document) throws IOException {
        StringWriter stringWriter = new StringWriter();
        OutputFormat format = OutputFormat.createPrettyPrint();
        XMLWriter writer = new XMLWriter(stringWriter, format);


GOLDEN COMPLETION:
----------------------------------------
        writer.write(document);


SUFFIX CODE:
----------------------------------------

        writer.close();
        String xmlOutput = stringWriter.toString();
        System.out.println(xmlOutput);

        // Assertions to verify the correctness of the XML output
        assert xmlOutput.contains("<author name=\"John Doe\" location=\"Unknown\">");
        assert xmlOutput.contains("<book title=\"Book 1\">This is book 1.</book>");
        assert xmlOutput.contains("<book title=\"Book 2\">This is book 2.</book>");
    }

    public static void main(String[] args) {
        try {
            Document document = createSampleDocument();
            String formattedXML = formatDocument(document);
            // Additional assertions can be added here if needed
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case uses the uncommon Dom4J library to create and format an XML document. The prefix sets up the creation of a sample XML document with nested elements and attributes. The golden completion involves writing the document using XMLWriter, which is a rare usage scenario. The suffix contains assertions that verify the structure and content of the generated XML, ensuring the correct API behavior. This scenario tests the LLM's ability to handle uncommon XML processing patterns and API conventions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.util.Iterator;

public class JsonProcessingExample {

    // Method to create a sample JSON string
    private static String createSampleJson() {
        return "{\"name\":\"John\", \"age\":30, \"children\":[{\"name\":\"Jane\", \"age\":10}, {\"name\":\"Doe\", \"age\":5}]}";
    }

    // Method to parse JSON string to JsonNode
    private static JsonNode parseJsonString(String jsonString) throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readTree(jsonString);
    }

    // Method to get a specific field value as string
    private static String getFieldAsString(JsonNode node, String fieldName) {
        return node.get(fieldName).asText();
    }

    // Method to iterate over child nodes
    private static void iterateOverChildren(JsonNode node) {
        Iterator<JsonNode> elements = node.elements();
        while (elements.hasNext()) {
            JsonNode child = elements.next();
            System.out.println("Child: " + child);
        }
    }

    public static void main(String[] args) {
        try {
            String jsonString = createSampleJson();
            JsonNode rootNode = parseJsonString(jsonString);
            System.out.println("Name: " + getFieldAsString(rootNode, "name"));
            System.out.println("Age: " + getFieldAsString(rootNode, "age"));
            System.out.println("Children:");


GOLDEN COMPLETION:
----------------------------------------
            JsonNode childrenNode = rootNode.get("children");
            iterateOverChildren(childrenNode);



SUFFIX CODE:
----------------------------------------


            // Assertions
            assert "John".equals(getFieldAsString(rootNode, "name"));
            assert "30".equals(getFieldAsString(rootNode, "age"));
            assert childrenNode.isArray();
            assert childrenNode.size() == 2;
            assert "Jane".equals(getFieldAsString(childrenNode.get(0), "name"));
            assert "10".equals(getFieldAsString(childrenNode.get(0), "age"));
            assert "Doe".equals(getFieldAsString(childrenNode.get(1), "name"));
            assert "5".equals(getFieldAsString(childrenNode.get(1), "age"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the Jackson library for JSON processing, which is a less common but powerful library for handling JSON data in Java. The example covers parsing JSON into a tree structure, accessing fields, and iterating over arrays of JSON objects. The assertions ensure that the JSON parsing and field access are working correctly, verifying the expected values and the structure of the parsed JSON. This scenario tests the LLM's ability to understand and apply Jackson's API correctly, including handling less common methods like JsonNode.get and JsonNode.elements.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import java.io.IOException;

public class JsonProcessingExample {

    private static final String JSON_STRING = "{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}";

    public static void main(String[] args) {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);

        try {
            // Parse JSON string to JsonNode
            JsonNode rootNode = objectMapper.readTree(JSON_STRING);

            // Access JSON fields
            String name = rootNode.path("name").asText();
            int age = rootNode.path("age").asInt();
            String city = rootNode.path("city").asText();

            // Print parsed values
            System.out.println("Name: " + name);
            System.out.println("Age: " + age);
            System.out.println("City: " + city);

            // Modify JSON data
            ((com.fasterxml.jackson.databind.node.ObjectNode) rootNode).put("age", 31);


GOLDEN COMPLETION:
----------------------------------------
            String modifiedJsonString = objectMapper.writeValueAsString(rootNode);


SUFFIX CODE:
----------------------------------------


            // Assertions
            JsonNode modifiedRootNode = objectMapper.readTree(modifiedJsonString);
            assert modifiedRootNode.path("age").asInt() == 31 : "Age should be updated to 31";
            assert modifiedRootNode.path("name").asText().equals("John") : "Name should remain 'John'";
            assert modifiedRootNode.path("city").asText().equals("New York") : "City should remain 'New York'";

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a JSON processing pattern using the Jackson library, an uncommon use of modifying JSON nodes directly. The example includes parsing a JSON string, accessing and modifying its fields, and outputting the modified JSON as a string. The suffix contains assertions to verify the correctness of the modifications.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.commons.dbcp2.BasicDataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class DatabaseAccessExample {
    private static final String DB_URL = "jdbc:h2:mem:testdb";
    private static final String USER = "sa";
    private static final String PASS = "";

    public static void main(String[] args) {
        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setUrl(DB_URL);
        dataSource.setUsername(USER);
        dataSource.setPassword(PASS);

        try (Connection conn = dataSource.getConnection()) {
            createTable(conn);
            insertData(conn);



GOLDEN COMPLETION:
----------------------------------------
            try (PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?")) {
                ps.setInt(1, 1);
                ResultSet rs = ps.executeQuery();
                if (rs.next()) {
                    String name = rs.getString("name");
                    int age = rs.getInt("age");
                    assert "John Doe".equals(name);
                    assert age == 30;
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }


SUFFIX CODE:
----------------------------------------

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                dataSource.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    private static void createTable(Connection conn) throws SQLException {
        try (PreparedStatement ps = conn.prepareStatement("CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255), age INT)")) {
            ps.execute();
        }
    }

    private static void insertData(Connection conn) throws SQLException {
        try (PreparedStatement ps = conn.prepareStatement("INSERT INTO users (id, name, age) VALUES (1, 'John Doe', 30)")) {
            ps.executeUpdate();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the model's ability to recognize and complete a pattern involving JDBC usage with the Apache Commons DBCP library for database connection pooling. The prefix sets up a data source, creates a table, and inserts data. The golden completion involves a query to select a user by ID and asserts the results. The suffix includes different code for querying and asserting the data, ensuring the completion is correct and the assertions validate the behavior.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class DatabaseExample {
    private static final String JDBC_URL = "jdbc:h2:mem:test";
    private static final String JDBC_USER = "sa";
    private static final String JDBC_PASSWORD = "";

    public static void main(String[] args) {
        try {
            // Create an in-memory H2 database
            Connection connection = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD);
            // Create a table
            Statement statement = connection.createStatement();
            statement.execute("CREATE TABLE test_table (id INT PRIMARY KEY, name VARCHAR(255))");

            // Insert some data
            PreparedStatement insertStmt = connection.prepareStatement("INSERT INTO test_table (id, name) VALUES (?, ?)");
            insertStmt.setInt(1, 1);
            insertStmt.setString(2, "Alice");
            insertStmt.executeUpdate();
            insertStmt.setInt(1, 2);
            insertStmt.setString(2, "Bob");
            insertStmt.executeUpdate();
            insertStmt.close();

            // Prepare to fetch data
            PreparedStatement selectStmt = connection.prepareStatement("SELECT * FROM test_table WHERE id = ?");
            selectStmt.setInt(1, 1);


GOLDEN COMPLETION:
----------------------------------------
            ResultSet resultSet = selectStmt.executeQuery();
            if (resultSet.next()) {
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                // Assertions
                assert id == 1 : "Expected id to be 1";
                assert "Alice".equals(name) : "Expected name to be Alice";
            }


SUFFIX CODE:
----------------------------------------

            resultSet.close();
            selectStmt.close();

            // Cleanup
            statement.execute("DROP TABLE test_table");
            statement.close();
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of JDBC for database operations, which involves creating a table, inserting records, and retrieving them using PreparedStatement. The example ensures that the LLM correctly handles the JDBC API, including parameter setting and result set processing. The assertions validate the correctness of the data retrieved from the database. The use of try-with-resources and proper cleanup after assertions ensures that the database resources are managed correctly, making it a robust and realistic test case.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;
import org.dom4j.tree.DefaultElement;
import java.io.File;
import java.io.FileWriter;
import java.io.StringReader;
import java.util.List;

public class XMLProcessingExample {

	public static void main(String[] args) throws Exception {
		// Create a new XML document
		Document document = DocumentHelper.createDocument();
		Element root = document.addElement("root");
		Element child1 = root.addElement("child1").addText("This is child 1");
		Element child2 = root.addElement("child2").addText("This is child 2");

		// Write the document to a file
		File file = new File("example.xml");
		try (FileWriter fileWriter = new FileWriter(file)) {
			XMLWriter writer = new XMLWriter(fileWriter);
			writer.write(document);
			writer.close();
		}

		// Read the document from the file
		SAXReader reader = new SAXReader();
		Document readDocument = reader.read(file);

		// Validate the read document structure
		Element readRoot = readDocument.getRootElement();
		List<Element> readChildren = readRoot.elements();

		for (Element element : readChildren) {
			System.out.println(element.getName() + ": " + element.getText());
		}

		// Additional processing of the document...
		

GOLDEN COMPLETION:
----------------------------------------
        Element child3 = readRoot.addElement("child3").addText("This is child 3");

SUFFIX CODE:
----------------------------------------


		// Check the newly added element
		Element retrievedChild3 = readRoot.element("child3");
		assert retrievedChild3 != null : "Child3 element should not be null";
		assert "This is child 3".equals(retrievedChild3.getText()) : "Child3 text should match";

		// Clean up the created file
		if (file.exists()) {
			file.delete();
		}
	}
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the uncommon Dom4J library for XML processing. The code creates an XML document, writes it to a file, reads it back, and then modifies the document by adding a new element. The assertions verify that the new element is correctly added and contains the expected text. This scenario tests the LLM's ability to recognize and use the Dom4J API, especially the methods for creating, reading, and modifying XML documents. Additionally, it includes proper resource cleanup and validation of the document structure.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.IOException;

public class JsonProcessingExample {

    public static void main(String[] args) throws IOException {
        // Create an ObjectMapper instance
        ObjectMapper objectMapper = new ObjectMapper();

        // Create a JSON structure using ObjectNode and ArrayNode
        ObjectNode rootNode = objectMapper.createObjectNode();
        rootNode.put("name", "John Doe");
        rootNode.put("age", 30);

        ArrayNode addressArray = objectMapper.createArrayNode();
        ObjectNode address1 = objectMapper.createObjectNode();
        address1.put("street", "123 Main St");
        address1.put("city", "Springfield");
        address1.put("zip", "12345");
        addressArray.add(address1);

        ObjectNode address2 = objectMapper.createObjectNode();
        address2.put("street", "456 Elm St");
        address2.put("city", "Shelbyville");
        address2.put("zip", "67890");
        addressArray.add(address2);

        rootNode.set("addresses", addressArray);

        // Serialize the JSON structure to a string
        String jsonString = objectMapper.writeValueAsString(rootNode);
        System.out.println("Serialized JSON: " + jsonString);

        // Deserialize the JSON string back to a JsonNode
        JsonNode rootNodeDeserialized = objectMapper.readTree(jsonString);

        // Extract the addresses array node
        ArrayNode deserializedAddresses = (ArrayNode) rootNodeDeserialized.get("addresses");

        // Iterate through the addresses and print them


GOLDEN COMPLETION:
----------------------------------------

        for (JsonNode address : deserializedAddresses) {
            System.out.println("Street: " + address.get("street").asText());
            System.out.println("City: " + address.get("city").asText());
            System.out.println("Zip: " + address.get("zip").asText());
        }


SUFFIX CODE:
----------------------------------------
        // Check the size of the addresses array
        assert deserializedAddresses.size() == 2 : "Expected size of 2";

        // Check the first address
        JsonNode firstAddress = deserializedAddresses.get(0);
        assert "123 Main St".equals(firstAddress.get("street").asText()) : "First street should be '123 Main St'";
        assert "Springfield".equals(firstAddress.get("city").asText()) : "First city should be 'Springfield'";
        assert "12345".equals(firstAddress.get("zip").asText()) : "First zip should be '12345'";

        // Check the second address
        JsonNode secondAddress = deserializedAddresses.get(1);
        assert "456 Elm St".equals(secondAddress.get("street").asText()) : "Second street should be '456 Elm St'";
        assert "Shelbyville".equals(secondAddress.get("city").asText()) : "Second city should be 'Shelbyville'";
        assert "67890".equals(secondAddress.get("zip").asText()) : "Second zip should be '67890'";

        System.out.println("All assertions passed.");
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of Jackson's ObjectNode and ArrayNode to create and manipulate JSON structures. The completion requires understanding how to iterate through an ArrayNode and access its elements, which is a less common operation compared to standard JSON parsing. The assertions verify the integrity of the JSON structure after deserialization, ensuring the API usage is correct.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;
import javax.inject.Inject;
import java.util.List;

@Configuration
class AppConfig {
    @Bean
    public ServiceA serviceA() {
        return new ServiceA();
    }

    @Bean
    public ServiceB serviceB() {
        return new ServiceB();
    }
}

@Component
class ServiceA {
    public String getMessage() {
        return "Hello from ServiceA";
    }
}

@Component
class ServiceB {
    private final ServiceA serviceA;

    @Inject
    public ServiceB(ServiceA serviceA) {
        this.serviceA = serviceA;
    }

    public String getCombinedMessage() {
        return serviceA.getMessage() + " and ServiceB";
    }
}

public class Main {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);


GOLDEN COMPLETION:
----------------------------------------
        ServiceA serviceA = context.getBean(ServiceA.class);


SUFFIX CODE:
----------------------------------------
        ServiceB serviceB = context.getBean(ServiceB.class);
        String combinedMessage = serviceB.getCombinedMessage();

        // Assertions
        assert combinedMessage.equals("Hello from ServiceA and ServiceB") : "Unexpected message: " + combinedMessage;

        // Clean up
        context.close();
    }
}

JUSTIFICATION:
----------------------------------------
This test case is beneficial as it uses the Javax Inject dependency injection library with Spring's AnnotationConfigApplicationContext, which is not a common combination. The scenario tests the model's ability to recognize and correctly use dependency injection patterns and annotations from different libraries. The assertions check if the combined message from ServiceA and ServiceB is as expected, ensuring that the dependency injection is working correctly.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import org.apache.commons.compress.compressors.CompressorException;
import org.apache.commons.compress.compressors.CompressorStreamFactory;
import org.apache.commons.compress.compressors.CompressorOutputStream;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;
import org.apache.commons.compress.compressors.gzip.GzipCompressorOutputStream;
import org.apache.commons.compress.compressors.lz4.FramedLZ4CompressorOutputStream;
import org.apache.commons.compress.compressors.xz.XZCompressorOutputStream;

public class CompressorExample {

    public static void main(String[] args) throws IOException, CompressorException {
        String input = "This is a test string to be compressed.";
        byte[] inputBytes = input.getBytes();
        
        // BZIP2 Compression
        File bzip2File = new File("output.bz2");
        try (FileOutputStream fos = new FileOutputStream(bzip2File);
             CompressorOutputStream cos = new BZip2CompressorOutputStream(fos)) {
            cos.write(inputBytes);
        }

        // GZIP Compression
        File gzipFile = new File("output.gz");
        try (FileOutputStream fos = new FileOutputStream(gzipFile);
             CompressorOutputStream cos = new GzipCompressorOutputStream(fos)) {
            cos.write(inputBytes);
        }

        // LZ4 Compression
        File lz4File = new File("output.lz4");
        try (FileOutputStream fos = new FileOutputStream(lz4File);
             CompressorOutputStream cos = new FramedLZ4CompressorOutputStream(fos)) {
            cos.write(inputBytes);
        }
        
        // The following code is for XZ compression


GOLDEN COMPLETION:
----------------------------------------
        try (FileOutputStream fos = new FileOutputStream(new File("output.xz"));
             CompressorOutputStream cos = new XZCompressorOutputStream(fos)) {
            cos.write(inputBytes);
        }


SUFFIX CODE:
----------------------------------------
        // Validate that the XZ file was created
        File xzFile = new File("output.xz");
        assert xzFile.exists() : "XZ file was not created";
        assert xzFile.length() > 0 : "XZ file is empty";
        
        // Cleanup
        xzFile.delete();
        lz4File.delete();
        gzipFile.delete();
        bzip2File.delete();
    }
}

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and complete patterns in Java code involving the Apache Commons Compress library for handling different types of compression formats. The scenario includes the usage of uncommon compressor types such as BZip2, GZip, LZ4, and XZ. The golden completion focuses on adding the XZ compression, which is less commonly used compared to BZip2 or GZip. The prefix provides context and setup for other compression types, while the suffix includes assertions to verify that the XZ file was correctly created and has content, followed by cleanup code to delete the generated files.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;
import javax.persistence.Entity;
import javax.persistence.Id;
import java.util.List;

@Entity
class User {
    @Id
    private Long id;
    private String name;

    public User() {}

    public User(Long id, String name) {
        this.id = id;
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class HibernateExample {
    public static void main(String[] args) {
        Configuration configuration = new Configuration().configure().addAnnotatedClass(User.class);
        SessionFactory sessionFactory = configuration.buildSessionFactory();
        Session session = sessionFactory.openSession();
        session.beginTransaction();

        User user1 = new User(1L, "John Doe");
        User user2 = new User(2L, "Jane Doe");

        session.save(user1);
        session.save(user2);

        session.getTransaction().commit();
        session.close();

        session = sessionFactory.openSession();


GOLDEN COMPLETION:
----------------------------------------
        session.beginTransaction();
        List<User> users = session.createQuery("from User", User.class).list();


SUFFIX CODE:
----------------------------------------


        assert users.size() == 2 : "Incorrect number of users";
        assert "John Doe".equals(users.get(0).getName()) : "First user's name is incorrect";
        assert "Jane Doe".equals(users.get(1).getName()) : "Second user's name is incorrect";

        session.getTransaction().commit();
        session.close();
        sessionFactory.close();
    }
}


JUSTIFICATION:
----------------------------------------
This test case uses Hibernate, a less common database access library compared to JPA or Spring Data JPA. It demonstrates the correct usage of Hibernate's Session API to save and query entities. The golden completion involves querying the database using HQL, which is an uncommon but valid usage pattern. The assertions in the suffix ensure that the entities were correctly persisted and retrieved.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Cell;
import java.io.FileOutputStream;
import java.io.IOException;

public class ExcelExample {

    public static void main(String[] args) {
        XSSFWorkbook workbook = new XSSFWorkbook();
        XSSFSheet sheet = workbook.createSheet("Employee Data");

        // Create a header row
        Row headerRow = sheet.createRow(0);
        Cell headerCell1 = headerRow.createCell(0);
        headerCell1.setCellValue("ID");
        Cell headerCell2 = headerRow.createCell(1);
        headerCell2.setCellValue("Name");
        Cell headerCell3 = headerRow.createCell(2);
        headerCell3.setCellValue("Department");

        // Add employee data
        Object[][] employeeData = {
            {1, "John Doe", "Engineering"},
            {2, "Jane Smith", "Marketing"},
            {3, "Emily Jones", "HR"}
        };

        int rowNum = 1;
        for (Object[] employee : employeeData) {
            Row row = sheet.createRow(rowNum++);
            int colNum = 0;
            for (Object field : employee) {
                Cell cell = row.createCell(colNum++);
                if (field instanceof String) {
                    cell.setCellValue((String) field);
                } else if (field instanceof Integer) {
                    cell.setCellValue((Integer) field);
                }
            }
        }


GOLDEN COMPLETION:
----------------------------------------
        // Save the workbook to a file
        try (FileOutputStream outputStream = new FileOutputStream("EmployeeData.xlsx")) {
            workbook.write(outputStream);
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }


SUFFIX CODE:
----------------------------------------


        // Assertions to verify the content of the Excel file
        try (XSSFWorkbook workbookRead = new XSSFWorkbook("EmployeeData.xlsx")) {
            XSSFSheet sheetRead = workbookRead.getSheetAt(0);
            Row rowRead = sheetRead.getRow(1);
            assert rowRead.getCell(0).getNumericCellValue() == 1;
            assert rowRead.getCell(1).getStringCellValue().equals("John Doe");
            assert rowRead.getCell(2).getStringCellValue().equals("Engineering");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Clean up resources
        try {
            workbook.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the Apache POI library to create and manipulate Excel files, which is a less common use case. The focus is on properly saving the workbook to a file and then verifying the content of the generated Excel file using assertions. The uncommon API usage here includes creating rows and cells, setting cell values, and saving the workbook to a file. The golden completion section includes the critical step of saving the workbook, which must be correctly recognized and implemented by the LLM. Assertions ensure that the content written to the Excel file is accurate and meets the expected values. This example also handles resources properly using try-with-resources and includes cleanup of the workbook resource.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class ExcelProcessingExample {

    public static void main(String[] args) {
        // Sample Excel file path
        String filePath = "sample.xlsx";

        // Reading the existing Excel file
        try (FileInputStream fis = new FileInputStream(filePath);
             Workbook workbook = new XSSFWorkbook(fis)) {

            // Access the first sheet
            Sheet sheet = workbook.getSheetAt(0);

            // Read the content of the first cell in the first row
            Row row = sheet.getRow(0);
            Cell cell = row.getCell(0);
            String cellValue = cell.getStringCellValue();

            // Print the value of the cell
            System.out.println("Cell Value: " + cellValue);

            // Modify the cell value
            cell.setCellValue("Modified Value");

            // Save the changes to the Excel file
            try (FileOutputStream fos = new FileOutputStream(filePath)) {
                workbook.write(fos);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }

        // Verifying the changes
        try (FileInputStream fis = new FileInputStream(filePath);
             Workbook workbook = new XSSFWorkbook(fis)) {

            // Access the first sheet
            Sheet sheet = workbook.getSheetAt(0);

            // Read the content of the first cell in the first row
            Row row = sheet.getRow(0);
            Cell cell = row.getCell(0);


GOLDEN COMPLETION:
----------------------------------------
            String modifiedValue = cell.getStringCellValue();


SUFFIX CODE:
----------------------------------------

            assert "Modified Value".equals(modifiedValue) : "Cell value was not modified correctly";

            // Clean up resources
            workbook.close();
            fis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to handle Excel file processing using Apache POI, a less common library for office document processing. It includes reading, modifying, and verifying cell values in an Excel file, which involves understanding correct parameter usage and API patterns. The assertions ensure the cell value is correctly modified and verified. The prefix provides sufficient context and setup, while the suffix includes necessary assertions and cleanup.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Cell;
import org.junit.Assert;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Iterator;

public class ExcelProcessingTest {
    private static final String INPUT_FILE_PATH = "test_input.xlsx";
    private static final String OUTPUT_FILE_PATH = "test_output.xlsx";

    public static void main(String[] args) throws Exception {
        createSampleExcelFile(INPUT_FILE_PATH);
        try (FileInputStream fis = new FileInputStream(new File(INPUT_FILE_PATH));
             Workbook workbook = WorkbookFactory.create(fis)) {
            Sheet sheet = workbook.getSheetAt(0);
            Iterator<Row> rowIterator = sheet.iterator();
            while (rowIterator.hasNext()) {
                Row row = rowIterator.next();
                Iterator<Cell> cellIterator = row.cellIterator();
                while (cellIterator.hasNext()) {
                    Cell cell = cellIterator.next();
                    switch (cell.getCellType()) {
                        case STRING:
                            System.out.println(cell.getStringCellValue());
                            break;
                        case NUMERIC:
                            System.out.println(cell.getNumericCellValue());
                            break;
                        default:
                            break;
                    }
                }
            }
            // Now let's modify the sheet


GOLDEN COMPLETION:
----------------------------------------
            Row row = sheet.getRow(0);
            Cell cell = row.getCell(0);
            cell.setCellValue("Modified");


SUFFIX CODE:
----------------------------------------
            // Save the changes to a new file
            try (FileOutputStream fos = new FileOutputStream(new File(OUTPUT_FILE_PATH))) {
                workbook.write(fos);
            }
        }

        // Validate the modifications in the new file
        try (FileInputStream fis = new FileInputStream(new File(OUTPUT_FILE_PATH));
             Workbook workbook = WorkbookFactory.create(fis)) {
            Sheet sheet = workbook.getSheetAt(0);
            Row row = sheet.getRow(0);
            Cell cell = row.getCell(0);
            Assert.assertEquals("Modified", cell.getStringCellValue());
        }

        // Clean up
        new File(INPUT_FILE_PATH).delete();
        new File(OUTPUT_FILE_PATH).delete();
    }

    private static void createSampleExcelFile(String filePath) throws IOException {
        try (Workbook workbook = WorkbookFactory.create(false); FileOutputStream fos = new FileOutputStream(new File(filePath))) {
            Sheet sheet = workbook.createSheet();
            Row row = sheet.createRow(0);
            Cell cell = row.createCell(0);
            cell.setCellValue("Original");
            workbook.write(fos);
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example demonstrates the usage of Apache POI for modifying Excel files, which is a less common use case compared to reading or creating Excel files. The completion requires understanding how to retrieve and modify cells within a sheet. The prefix sets up reading from an existing Excel file, and the suffix verifies the modification by reading from the updated file and asserting the change. This tests the LLM's ability to correctly use the Apache POI API for cell modification, which is not as frequently used or documented as other operations.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: synthbench-api-usage
Language: java
================================================================================

PREFIX CODE:
----------------------------------------
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import org.junit.Assert;

public class DatabaseAccessExample {

    private static final String JDBC_URL = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;";
    private static final String JDBC_USER = "sa";
    private static final String JDBC_PASSWORD = "";

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
            createTable(connection);
            insertData(connection);
            // Check insertion
            try (Statement stmt = connection.createStatement();
                 ResultSet rs = stmt.executeQuery("SELECT COUNT(*) FROM employees")) {
                if (rs.next()) {
                    int count = rs.getInt(1);
                    Assert.assertEquals(3, count);
                }
            }

            // Update data


GOLDEN COMPLETION:
----------------------------------------
            try (PreparedStatement pstmt = connection.prepareStatement("UPDATE employees SET salary = ? WHERE id = ?")) {
                pstmt.setDouble(1, 65000.00);
                pstmt.setInt(2, 2);
                int rowsUpdated = pstmt.executeUpdate();
                Assert.assertEquals(1, rowsUpdated);
            }



SUFFIX CODE:
----------------------------------------


            // Verify update
            try (Statement stmt = connection.createStatement();
                 ResultSet rs = stmt.executeQuery("SELECT salary FROM employees WHERE id = 2")) {
                if (rs.next()) {
                    double salary = rs.getDouble(1);
                    Assert.assertEquals(65000.00, salary, 0.01);
                }
            }

            // Clean up
            dropTable(connection);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static void createTable(Connection connection) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE TABLE employees (id INT PRIMARY KEY, name VARCHAR(255), salary DOUBLE)");
        }
    }

    private static void insertData(Connection connection) throws SQLException {
        try (PreparedStatement pstmt = connection.prepareStatement("INSERT INTO employees (id, name, salary) VALUES (?, ?, ?)");) {
            pstmt.setInt(1, 1);
            pstmt.setString(2, "Alice");
            pstmt.setDouble(3, 60000.00);
            pstmt.executeUpdate();

            pstmt.setInt(1, 2);
            pstmt.setString(2, "Bob");
            pstmt.setDouble(3, 55000.00);
            pstmt.executeUpdate();

            pstmt.setInt(1, 3);
            pstmt.setString(2, "Charlie");
            pstmt.setDouble(3, 70000.00);
            pstmt.executeUpdate();
        }
    }

    private static void dropTable(Connection connection) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute("DROP TABLE employees");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of JDBC for database access, including creating a table, inserting data, updating data, and verifying the update. It focuses on the correct usage of PreparedStatement for parameterized SQL queries, which is less common compared to simple Statement usage. The test ensures that the LLM can handle correct parameter ordering and proper resource management, including the use of try-with-resources for automatic resource cleanup. The assertions verify the correctness of data operations and ensure that the update and subsequent verification steps are executed correctly.

ASSERTIONS:
----------------------------------------

================================================================================
