{"id": "1", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <vector>\n#include <cassert>\n\nstd::vector<int> filter_even(const std::vector<int>& input) {\n    std::vector<int> result;\n    for (int num : input) {\n        if (num % 2 == 0) {\n", "suffix": "        }\n    }\n    return result;\n}\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4, 5, 6};\n    std::vector<int> result = filter_even(data);\n    assert(result == std::vector<int>({2, 4, 6}));\n    return 0;\n}", "golden_completion": "            result.push_back(num);", "LLM_justification": "This example tests the LLM's ability to recognize a common pattern in filtering elements from a vector based on a condition. The prefix provides enough context to identify the pattern of iterating over a vector and applying a conditional check. The completion should insert the code that adds even numbers to the result vector. The suffix verifies the result with an assertion.", "assertions": "", "gpt-4o": "            result.push_back(num);"}
{"id": "2", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n\nint main() {\n\tstd::vector<int> numbers = {1, 2, 3, 4, 5};\n\tint sum = 0;", "suffix": "\n\tstd::cout << \"Sum: \" << sum << std::endl;\n\tassert(sum == 15);\n\treturn 0;\n}", "golden_completion": "\n\tfor (int num : numbers) {\n\t\tsum += num;\n\t}", "LLM_justification": "This test case is based on a common pattern of iterating over a container (std::vector) to compute a sum. The pattern of using a range-based for loop to iterate through elements is widely recognized and should be identifiable with minimal context. The prefix establishes the container and the sum variable, while the suffix shows the final output. This tests the LLM's ability to complete the iteration pattern correctly.", "assertions": "", "gpt-4o": "\tfor(int num : numbers) {\n\t\tsum += num;\n\t}"}
{"id": "3", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <vector>\n#include <cassert>\n\nstd::vector<int> doubleElements(const std::vector<int>& input) {\n    std::vector<int> result;\n    for (int elem : input) {\n", "suffix": "    }\n    return result;\n}\n\nint main() {\n    std::vector<int> data = {1, 2, 3, 4};\n    std::vector<int> doubled = doubleElements(data);\n    assert(doubled.size() == 4);\n    assert(doubled[0] == 2);\n    assert(doubled[1] == 4);\n    assert(doubled[2] == 6);\n    assert(doubled[3] == 8);\n    return 0;\n}", "golden_completion": "        result.push_back(elem * 2);", "LLM_justification": "This is a good test case because it focuses on a common data structure manipulation pattern, specifically iterating over a vector and modifying its elements. The pattern is easily recognizable due to the presence of a for-each loop and a push_back operation on a result vector. The minimal context provided in the prefix should be sufficient for a language model to infer that the missing code involves doubling the elements and adding them to the result vector. The suffix includes code that continues the pattern and finalizes the function, along with assertions that verify the correctness of the implementation.", "assertions": "", "gpt-4o": "        result.push_back(elem * 2);"}
{"id": "4", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <vector>\n#include <cassert>\n\nint main() {\n\tstd::vector<int> vec = {1, 2, 3, 4};\n\t// Insert code to manipulate vector\n", "suffix": "\n\t// Check if vector manipulation is correct\n\tassert(vec[0] == 1);\n\tassert(vec[1] == 5);\n\tassert(vec[2] == 3);\n\tassert(vec[3] == 4);\n\treturn 0;\n}", "golden_completion": "\tvec[1] = 5;", "LLM_justification": "This test case is a good example for evaluating the LLM's ability to recognize a common pattern in vector manipulation. The prefix sets up a vector with initial values, and the suffix includes assertions to verify the correct modification of the vector. The completion involves a simple and common task of updating a specific element in the vector, which should be easily recognizable with minimal context.", "assertions": "", "gpt-4o": "\tvec[1] = 5;"}
{"id": "5", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n\nvoid useSmartPointer() {\n    std::unique_ptr<int> ptr = std::make_unique<int>(42);\n", "suffix": "    std::cout << \"Pointer value: \" << *ptr << std::endl;\n}\n\nint main() {\n    useSmartPointer();\n    return 0;\n}", "golden_completion": "    *ptr += 8;\n    assert(*ptr == 50);\n", "LLM_justification": "This test case checks the model's ability to recognize and complete a common pattern involving the manipulation of smart pointers in C++. The context provided is minimal, but the pattern of using `std::unique_ptr` is well-established and should be easily identifiable. The completion requires the model to correctly manipulate the pointer value, which is a standard operation in C++ programming.", "assertions": "", "gpt-4o": "    std::cout << \"Pointer value: \" << *ptr << std::endl;"}
{"id": "6", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n\tstd::vector<int> vec = {1, 2, 3, 4, 5};\n", "suffix": "\tassert(it != vec.end() && *it == 3);\n\tstd::cout << \"Element found: \" << *it << std::endl;\n\treturn 0;\n}", "golden_completion": "\tauto it = std::find(vec.begin(), vec.end(), 3);\n", "LLM_justification": "This scenario tests the model's ability to recognize and complete a common C++ pattern for searching elements in a vector using the STL algorithm std::find. The context includes a vector initialization and a partial search code, making it a low-context pattern completion task. The correct completion demonstrates understanding of iterator usage and STL functions.", "assertions": "", "gpt-4o": "\tauto it = std::find(vec.begin(), vec.end(), 3);"}
{"id": "7", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid testVectorSize() {\n    std::vector<int> vec = {1, 2, 3};\n", "suffix": "    assert(vec.size() == 4);\n    std::cout << \"Vector size test passed.\" << std::endl;\n}\n\nint main() {\n    testVectorSize();\n    return 0;\n}", "golden_completion": "    vec.push_back(4);\n", "LLM_justification": "This test case checks the model's ability to recognize a common vector manipulation pattern in C++, specifically adding an element to a vector and verifying the size. The prefix sets up a vector and the suffix includes assertions to check the vector's size after the completion code. The pattern is recognizable with minimal context, making it an effective low-context scenario.", "assertions": "", "gpt-4o": "    vec.push_back(4);"}
{"id": "8", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <vector>\n#include <algorithm>\n#include <cassert>\n\nvoid test_sort() {\n\tstd::vector<int> data = {3, 1, 4, 1, 5};\n", "suffix": "\n\tassert(data[0] == 1);\n\tassert(data[1] == 1);\n\tassert(data[2] == 3);\n\tassert(data[3] == 4);\n\tassert(data[4] == 5);\n}\n\nint main() {\n\ttest_sort();\n\treturn 0;\n}", "golden_completion": "\tstd::sort(data.begin(), data.end());\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common sorting pattern using the C++ STL. The prefix establishes a vector and its initialization, while the suffix verifies the sorting operation with assertions. The low-context nature of the task ensures that the LLM must infer the correct use of std::sort based on minimal surrounding context.", "assertions": "", "gpt-4o": "\tstd::sort(data.begin(), data.end());"}
{"id": "9", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <vector>\n#include <cassert>\n\nvoid process_vector(std::vector<int>& vec) {\n\tvec.push_back(10);\n", "suffix": "\tassert(vec.size() == 4);\n\tassert(vec[3] == 10);\n}\n\nint main() {\n\tstd::vector<int> my_vec = {1, 2, 3};\n\tprocess_vector(my_vec);\n\treturn 0;\n}", "golden_completion": "\tvec.push_back(10);", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common pattern in C++ which involves manipulating a vector by adding an element to it. The pattern is clear and recognizable with minimal context, and the completion demonstrates standard library usage and basic vector operations. The assertions ensure that the vector size and contents are as expected after the operation.", "assertions": "", "gpt-4o": "\tvec.push_back(20);"}
{"id": "10", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid add_element(std::vector<int>& vec, int element) {\n", "suffix": "}\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3};\n    add_element(numbers, 4);\n    assert(numbers.size() == 4);\n    assert(numbers[3] == 4);\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    vec.push_back(element);\n", "LLM_justification": "This test case is good because it requires the model to recognize and complete a common pattern of adding an element to a vector. The prefix establishes the context of a function that modifies a vector, while the suffix contains assertions to verify the correct implementation. The pattern is universally recognizable and involves standard library usage.", "assertions": "", "gpt-4o": "    vec.push_back(element);"}
{"id": "11", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5};\n    // Sort the vector in descending order\n", "suffix": "    assert(vec[0] == 5);\n    assert(vec[1] == 4);\n    assert(vec[2] == 3);\n    assert(vec[3] == 2);\n    assert(vec[4] == 1);\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    std::sort(vec.begin(), vec.end(), std::greater<int>());", "LLM_justification": "This scenario tests the model's ability to recognize a common algorithm implementation pattern in C++: sorting a vector in descending order. The prefix establishes a vector and indicates sorting in descending order, while the suffix includes assertions to verify the correctness of the sorting operation. The pattern is universally recognizable and the assertions ensure the code's functionality.", "assertions": "", "gpt-4o": "    std::sort(vec.begin(), vec.end(), std::greater<int>());"}
{"id": "12", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <vector>\n\nint findMax(const std::vector<int>& nums) {\n\tint max_val = nums[0];\n\tfor (int i = 1; i < nums.size(); ++i) {", "suffix": "\n\t}\n\treturn max_val;\n}\n\nint main() {\n\tstd::vector<int> testVec = {1, 3, 2, 5, 4};\n\tint result = findMax(testVec);\n\tassert(result == 5);\n\tstd::cout << \"All assertions passed.\" << std::endl;\n\treturn 0;\n}", "golden_completion": "\n\t\tif (nums[i] > max_val) {\n\t\t\tmax_val = nums[i];\n\t\t}\n", "LLM_justification": "This test case is a good example of algorithm implementation and STL usage. The task is to complete the function that finds the maximum element in a vector. The prefix sets up the loop to iterate through the vector, and the golden completion involves a simple if-statement to update the maximum value. The suffix includes the main function that tests this pattern, ensuring the algorithm is correctly implemented, and asserts the result. This scenario tests the model's ability to recognize and complete a common algorithmic pattern with minimal context.", "assertions": "", "gpt-4o": "\t\tif (nums[i] > max_val) {\n\t\t\tmax_val = nums[i];\n\t\t}"}
{"id": "13", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n\nvoid reverseString(std::string &str) {\n", "suffix": "}\n\nint main() {\n    std::string testStr = \"hello\";\n    reverseString(testStr);\n    assert(testStr == \"olleh\");\n    std::string anotherStr = \"world\";\n    reverseString(anotherStr);\n    assert(anotherStr == \"dlrow\");\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    int n = str.size();\n    for (int i = 0; i < n / 2; ++i) {\n        std::swap(str[i], str[n - i - 1]);\n    }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common string manipulation pattern: reversing a string in place. The context is minimal, requiring the LLM to infer the correct implementation from the function signature and usage in the suffix. Assertions verify the correct behavior without repeating the completion code.", "assertions": "", "gpt-4o": "    std::reverse(str.begin(), str.end());"}
{"id": "14", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <vector>\n\nclass Widget {\npublic:\n    Widget(int value) : value_(value) {}\n    int getValue() const { return value_; }\nprivate:\n    int value_;\n};\n\nclass WidgetManager {\npublic:\n    void addWidget(const Widget& widget) {\n        widgets_.push_back(widget);\n    }\n    Widget getMaxWidget() const {\n", "suffix": "    }\nprivate:\n    std::vector<Widget> widgets_;\n};\n\nint main() {\n    WidgetManager manager;\n    manager.addWidget(Widget(1));\n    manager.addWidget(Widget(3));\n    manager.addWidget(Widget(2));\n    Widget maxWidget = manager.getMaxWidget();\n    assert(maxWidget.getValue() == 3);\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "        if (widgets_.empty()) throw std::runtime_error(\"No widgets available\");\n        return *std::max_element(widgets_.begin(), widgets_.end(), [](const Widget& a, const Widget& b) { return a.getValue() < b.getValue(); });\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving object-oriented programming and STL usage. The WidgetManager class is partially defined, with a method that needs to find the maximum element in a vector of Widget objects. The completion requires understanding of exception handling, lambda functions, and std::max_element, making it non-trivial and requiring genuine understanding of advanced C++ features.", "assertions": "", "gpt-4o": "        assert(!widgets_.empty());\n        return *std::max_element(widgets_.begin(), widgets_.end(), [](const Widget& a, const Widget& b) {\n            return a.getValue() < b.getValue();\n        });"}
{"id": "15", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nclass Resource {\npublic:\n    Resource() { std::cout << \"Resource acquired\\n\"; }\n    ~Resource() { std::cout << \"Resource released\\n\"; }\n};\n\nvoid useResource(std::unique_ptr<Resource> res) {\n    assert(res != nullptr);\n    // Perform some operation with res\n}\n\nint main() {\n    std::unique_ptr<Resource> res = ", "suffix": "    useResource(std::move(res));\n    assert(!res);\n    return 0;\n}", "golden_completion": "std::make_unique<Resource>();", "LLM_justification": "This example demonstrates the use of smart pointers, specifically std::unique_ptr, in managing resource acquisition and release. It also checks the proper use of std::move to transfer ownership and ensures that assertions validate the resource state before and after the transfer. The context is minimal but establishes a clear pattern of RAII and smart pointer usage.", "assertions": "", "gpt-4o": "std::make_unique<Resource>();"}
{"id": "16", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nclass Resource {\npublic:\n    void use() const { std::cout << \"Resource in use\" << std::endl; }\n};\n\nclass ResourceManager {\nprivate:\n    std::unique_ptr<Resource> resource;\npublic:\n    ResourceManager() : resource(std::make_unique<Resource>()) {}\n    void manage() {", "suffix": "    }\n};\n\nint main() {\n    ResourceManager rm;\n    rm.manage();\n    assert(true);  // Ensure execution reached this point without issues\n    return 0;\n}", "golden_completion": "resource->use();", "LLM_justification": "This example demonstrates the RAII pattern using smart pointers. The ResourceManager class manages a Resource object, ensuring proper resource management and cleanup. The pattern is identifiable with minimal context, challenging the LLM to understand the use of smart pointers and resource management in C++.", "assertions": "", "gpt-4o": "        resource->use();"}
{"id": "17", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nclass Resource {\npublic:\n    Resource() { std::cout << \"Resource acquired\\n\"; }\n    ~Resource() { std::cout << \"Resource released\\n\"; }\n    void use() { std::cout << \"Resource in use\\n\"; }\n};\n\nvoid manage_resource() {\n    std::unique_ptr<Resource> res_ptr;", "suffix": "    assert(res_ptr != nullptr);\n    res_ptr->use();\n}\n\nint main() {\n    manage_resource();\n    return 0;\n}", "golden_completion": "    res_ptr = std::make_unique<Resource>();", "LLM_justification": "This test case checks the model's ability to recognize and complete a pattern involving RAII and smart pointers. The prefix sets up a class with a constructor and destructor, indicating resource management. The task is to correctly initialize the unique_ptr using std::make_unique, which is a common but non-trivial pattern. The suffix includes assertions to ensure the resource is properly acquired and used, and then the resource is automatically released when the unique_ptr goes out of scope. This example is complex enough to challenge an LLM's understanding of smart pointer usage and RAII in C++.", "assertions": "", "gpt-4o": "    res_ptr = std::make_unique<Resource>();"}
{"id": "18", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\nclass Resource {\npublic:\n    Resource() { std::cout << \"Resource acquired\\n\"; }\n    ~Resource() { std::cout << \"Resource released\\n\"; }\n};\nvoid func() {\n    std::unique_ptr<Resource> res;\n", "suffix": "    assert(res != nullptr);\n    std::cout << \"Resource is managed\\n\";\n}\nint main() {\n    func();\n    std::cout << \"Function executed\\n\";\n    return 0;\n}", "golden_completion": "    res = std::make_unique<Resource>();\n", "LLM_justification": "This example tests the LLM's ability to recognize a pattern involving memory management with smart pointers (specifically std::unique_ptr). The correct completion requires the model to understand that the resource should be allocated using std::make_unique. The suffix includes an assertion to check that the resource is indeed managed, ensuring the completion is correct. The pattern is a common idiom in modern C++ for resource management, making it a good test case for low-context pattern recognition.", "assertions": "", "gpt-4o": "    res = std::make_unique<Resource>();"}
{"id": "19", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nclass Resource {\npublic:\n    Resource() { std::cout << \"Resource acquired\\n\"; }\n    ~Resource() { std::cout << \"Resource released\\n\"; }\n};\n\nvoid processResource(std::unique_ptr<Resource>& res) {", "suffix": "    assert(res != nullptr); // Ensure the resource is still valid\n}\n\nint main() {\n    std::unique_ptr<Resource> res = std::make_unique<Resource>();\n    processResource(res);\n    assert(res != nullptr); // Ensure the resource has not been released\n    return 0;\n}", "golden_completion": "    res.reset(new Resource()); // Reset resource to a new instance", "LLM_justification": "This example tests the model's understanding of advanced memory management patterns using smart pointers, specifically std::unique_ptr. It requires the model to recognize the pattern of resetting a unique pointer to manage the lifecycle of a resource. The inclusion of assertions ensures that the resource is valid before and after resetting, which tests the model's ability to handle resource management correctly. This scenario is complex enough to challenge a senior C++ developer and requires genuine understanding of C++ language semantics, making it a good test case for low-context pattern recognition.", "assertions": "", "gpt-4o": "    res.reset(); // Release the resource"}
{"id": "20", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nclass Widget {\npublic:\n    Widget(int id) : id(id) {}\n    int getId() const { return id; }\nprivate:\n    int id;\n};\n\nstd::vector<Widget> createWidgets(int n) {\n    std::vector<Widget> widgets;\n", "suffix": "    for (int i = 0; i < 5; ++i) {\n        widgets.push_back(Widget(i));\n    }\n    return widgets;\n}\n\nint main() {\n    auto widgets = createWidgets(5);\n    assert(widgets.size() == 5);\n    for (int i = 0; i < 5; ++i) {\n        assert(widgets[i].getId() == i);\n    }\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "    widgets.reserve(n);\n", "LLM_justification": "This example tests the model's ability to recognize a common performance optimization pattern in C++: pre-allocating memory for a vector using reserve(). The pattern is identifiable with minimal context as it follows the creation of a vector and a loop to populate it. The golden completion demonstrates best practices by reserving the necessary capacity before filling the vector, which is crucial for efficient memory management and avoiding multiple reallocations. The suffix includes assertions to verify that the vector has been correctly populated and adheres to the expected size and content.", "assertions": "", "gpt-4o": "    for (int i = 0; i < n; ++i) {"}
{"id": "21", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n\nclass Resource {\npublic:\n    Resource() { std::cout << \"Resource acquired\\n\"; }\n    ~Resource() { std::cout << \"Resource destroyed\\n\"; }\n};\n\nvoid acquireResource(std::shared_ptr<Resource>& res) {\n    res = std::make_shared<Resource>();\n}\n\nint main() {\n    std::shared_ptr<Resource> res;", "suffix": "\n    assert(res != nullptr);\n    std::cout << \"Resource is valid\\n\";\n    res.reset();\n    assert(res == nullptr);\n    std::cout << \"Resource has been reset\\n\";\n    return 0;\n}", "golden_completion": "    acquireResource(res);", "LLM_justification": "This test case evaluates the model's capability to recognize and complete a pattern involving smart pointers and resource management in C++. The prefix sets up a scenario where a shared_ptr needs to be initialized with a resource, and the suffix includes assertions to check the validity and state of the shared_ptr before and after resetting it. This pattern is common in RAII and resource management, and the model needs to understand the context to insert the correct function call to acquire the resource.", "assertions": "", "gpt-4o": "    acquireResource(res);"}
{"id": "22", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nclass MyClass {\npublic:\n\tMyClass() { std::cout << \"MyClass constructed\\n\"; }\n\t~MyClass() { std::cout << \"MyClass destroyed\\n\"; }\n};\n\nvoid useResource(std::unique_ptr<MyClass> ptr) {\n\tassert(ptr != nullptr);\n\tstd::cout << \"Using resource\\n\";\n}\n\nint main() {\n\tstd::unique_ptr<MyClass> ptr(new MyClass);\n\tuseResource(", "suffix": ");\n\tstd::cout << \"Resource used\\n\";\n\tassert(ptr == nullptr);\n\treturn 0;\n}\n", "golden_completion": "std::move(ptr)", "LLM_justification": "This example demonstrates the use of std::unique_ptr with move semantics. The pattern of moving a unique pointer is critical in C++ for resource management and ensuring no double deletions occur. The code tests if the unique pointer is correctly moved to the function, and the subsequent assertion checks if the original unique pointer is null, indicating successful transfer of ownership. This scenario tests the model's understanding of move semantics and resource management in C++.", "assertions": "", "gpt-4o": "std::move(ptr)"}
{"id": "23", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nclass Resource {\npublic:\n    Resource() { std::cout << \"Resource acquired\\n\"; }\n    ~Resource() { std::cout << \"Resource released\\n\"; }\n    void use() const { std::cout << \"Resource used\\n\"; }\n};\n\nstd::unique_ptr<Resource> createResource() {\n", "suffix": "}\n\nint main() {\n    auto res = createResource();\n    assert(res != nullptr);\n    res->use();\n    // Resource will be automatically released here when `res` goes out of scope\n    return 0;\n}", "golden_completion": "    return std::make_unique<Resource>();\n", "LLM_justification": "This example demonstrates the use of smart pointers for resource management using the RAII pattern. The prefix establishes the creation of a Resource object, and the golden completion requires returning a std::unique_ptr to that Resource. The suffix verifies that the resource is correctly created, used, and released, testing the model's ability to recognize and complete the RAII pattern with minimal context.", "assertions": "", "gpt-4o": "    return std::make_unique<Resource>();"}
{"id": "24", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nclass Resource {\npublic:\n    Resource(int value) : value_(value) {}\n    int getValue() const { return value_; }\nprivate:\n    int value_;\n};\n\nclass ResourceManager {\npublic:\n    ResourceManager() : resource_(nullptr) {}\n    void acquireResource(int value) {\n", "suffix": "    }\n    void releaseResource() {\n        resource_.reset();\n    }\n    std::shared_ptr<Resource> getResource() const {\n        return resource_;\n    }\nprivate:\n    std::shared_ptr<Resource> resource_;\n};\n\nint main() {\n    ResourceManager manager;\n    manager.acquireResource(42);\n    assert(manager.getResource() && manager.getResource()->getValue() == 42);\n    manager.releaseResource();\n    assert(!manager.getResource());\n    return 0;\n}", "golden_completion": "        resource_ = std::make_shared<Resource>(value);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving custom resource management with smart pointers. The prefix sets up a class with a smart pointer, and the completion requires instantiating this pointer correctly. The suffix includes assertions that validate the correct behavior of acquiring and releasing the resource, ensuring the LLM understands the pattern and manages resources properly.", "assertions": "", "gpt-4o": "        resource_ = std::make_shared<Resource>(value);"}
{"id": "25", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <memory>\nclass MemoryPool {\npublic:\n    MemoryPool(std::size_t size) : pool(new char[size]), poolSize(size), offset(0) {}\n    ~MemoryPool() { delete[] pool; }\n    void* allocate(std::size_t size);\nprivate:\n    char* pool;\n    std::size_t poolSize;\n    std::size_t offset;\n};\n\nclass MyClass {\npublic:\n    MyClass(int a, int b) : x(a), y(b) {}\n    int sum() const { return x + y; }\nprivate:\n    int x, y;\n};\n", "suffix": "int main() {\n    MemoryPool pool(1024);\n    void* mem1 = pool.allocate(sizeof(MyClass));\n    void* mem2 = pool.allocate(sizeof(MyClass));\n    MyClass* obj1 = new (mem1) MyClass(1, 2);\n    MyClass* obj2 = new (mem2) MyClass(3, 4);\n    assert(obj1->sum() == 3);\n    assert(obj2->sum() == 7);\n    obj1->~MyClass();\n    obj2->~MyClass();\n    return 0;\n}", "golden_completion": "void* MemoryPool::allocate(std::size_t size) {\n    if (offset + size > poolSize) throw std::bad_alloc();\n    void* ptr = pool + offset;\n    offset += size;\n    return ptr;\n}\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving custom memory management using a memory pool and placement new. The prefix sets up a MemoryPool class and a MyClass class, leaving the implementation of the MemoryPool::allocate function as the completion task. The suffix contains code that uses the memory pool to allocate memory for MyClass instances and verifies their correct behavior using assertions. This scenario requires understanding advanced C++ features like custom memory allocation, placement new, and object lifetime management, making it a good test for low-context pattern recognition.", "assertions": "", "gpt-4o": "void* MemoryPool::allocate(std::size_t size) {\n    if (offset + size > poolSize) {\n        throw std::bad_alloc();\n    }\n    void* ptr = pool + offset;\n    offset += size;\n    return ptr;\n}\n\nint main() {"}
{"id": "26", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nstruct Resource {\n    Resource() { std::cout << \"Resource acquired\\n\"; }\n    ~Resource() { std::cout << \"Resource destroyed\\n\"; }\n    void use() { std::cout << \"Resource used\\n\"; }\n};\n\nvoid manageResource() {\n    std::unique_ptr<Resource> res1(new Resource());\n    std::unique_ptr<Resource> res2;", "suffix": "    assert(res2);\n    res2->use();\n    res1.reset();\n    assert(!res1);\n    // Confirming resource release and reassignment\n    res2.reset(new Resource());\n    assert(res2);\n    res2->use();\n}\n\nint main() {\n    manageResource();\n    return 0;\n}\n", "golden_completion": "res2 = std::move(res1);", "LLM_justification": "This example tests the model's ability to understand and correctly use unique_ptr for resource management, including move semantics with std::move. The task is to transfer ownership of the resource from res1 to res2. The assertions ensure that the resource is managed correctly by checking the state of the unique_ptrs after the move operation and that resources are properly released and reassigned.", "assertions": "", "gpt-4o": "    res2 = std::move(res1);"}
{"id": "27", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <cassert>\n\nclass Resource {\npublic:\n    Resource() { std::cout << \"Resource acquired\\n\"; }\n    ~Resource() { std::cout << \"Resource destroyed\\n\"; }\n    void use() { std::cout << \"Resource used\\n\"; }\n};\n\nvoid manageResource() {\n", "suffix": "    assert(resource != nullptr);\n    resource->use();\n    std::cout << \"Exiting manageResource function\\n\";\n}\n\nint main() {\n    manageResource();\n    std::cout << \"Program complete\\n\";\n    return 0;\n}", "golden_completion": "    std::unique_ptr<Resource> resource = std::make_unique<Resource>();\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving RAII and smart pointers for resource management. The pattern is common in C++ for managing dynamic resources with automatic cleanup. The prefix establishes the context of a Resource class and a function where a smart pointer is expected to be used. The suffix contains assertions and additional code that follow the expected pattern, ensuring that the resource is correctly managed and used. The golden completion involves creating a unique_ptr to manage the Resource object, which fits the RAII pattern and completes the function appropriately.", "assertions": "", "gpt-4o": "    std::unique_ptr<Resource> resource = std::make_unique<Resource>();"}
{"id": "28", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n#include <cassert>\nclass ThreadPool {\npublic:\n\tThreadPool(size_t numThreads);\n\t~ThreadPool();\n\tvoid enqueue(std::function<void()> task);\nprivate:\n\tstd::vector<std::thread> workers;\n\tstd::mutex queueMutex;\n\tbool stop;\n};\n", "suffix": "void ThreadPool::enqueue(std::function<void()> task) {\n\t{\n\t\tstd::unique_lock<std::mutex> lock(queueMutex);\n\t\t// Add task to the queue (mocked for simplicity)\n\t}\n\t// Mock thread processing\n\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n}\nThreadPool::~ThreadPool() {\n\tstop = true;\n\tfor (std::thread &worker : workers)\n\t\tworker.join();\n}\nint main() {\n\tThreadPool pool(2);\n\tpool.enqueue([] { std::cout << \"Task 1\" << std::endl; });\n\tpool.enqueue([] { std::cout << \"Task 2\" << std::endl; });\n\tassert(pool.workers.size() == 2); // Validate number of threads\n\tassert(!pool.stop); // Ensure pool is not stopped prematurely\n\treturn 0;\n}\n", "golden_completion": "ThreadPool::ThreadPool(size_t numThreads) : stop(false) {\n\tfor (size_t i = 0; i < numThreads; ++i) {\n\t\tworkers.emplace_back([this] {\n\t\t\twhile (!stop) {\n\t\t\t\t// Worker thread logic (mocked for simplicity)\n\t\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\t\t}\n\t\t});\n\t}\n}", "LLM_justification": "This example demonstrates a complex multi-threading pattern with a custom thread pool implementation. It requires understanding of thread lifecycle management, mutex for synchronization, and proper resource cleanup. The assertions check the number of threads and ensure the thread pool is not stopped prematurely, verifying correct behavior under concurrent operations. This tests the LLM's ability to infer and complete intricate threading logic with minimal context.", "assertions": "", "gpt-4o": "ThreadPool::ThreadPool(size_t numThreads) : stop(false) {\n\tfor (size_t i = 0; i < numThreads; ++i) {\n\t\tworkers.emplace_back([this] {\n\t\t\twhile (!this->stop) {\n\t\t\t\tstd::function<void()> task;\n\t\t\t\t{\n\t\t\t\t\tstd::unique_lock<std::mutex> lock(this->queueMutex);\n\t\t\t\t\t// Fetch task from the queue (mocked for simplicity)\n\t\t\t\t}\n\t\t\t\tif (task) task();\n\t\t\t}\n\t\t});\n\t}\n}"}
{"id": "29", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n#include <cassert>\n\nclass ThreadSafeCounter {\npublic:\n    ThreadSafeCounter() : value(0) {}\n    void increment() {\n", "suffix": "    }\n    int get() const {\n        std::lock_guard<std::mutex> lock(mtx);\n        return value;\n    }\nprivate:\n    mutable std::mutex mtx;\n    int value;\n};\n\nint main() {\n    ThreadSafeCounter counter;\n    std::vector<std::thread> threads;\n    for (int i = 0; i < 100; ++i) {\n        threads.push_back(std::thread(&ThreadSafeCounter::increment, &counter));\n    }\n    for (auto& t : threads) {\n        t.join();\n    }\n    assert(counter.get() == 100);\n    std::cout << \"Test passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "        std::lock_guard<std::mutex> lock(mtx);\n        ++value;\n", "LLM_justification": "This example tests the model's ability to recognize and complete a thread-safe increment operation within a class using a mutex. The pattern involves using std::lock_guard to ensure mutual exclusion, which is a common C++ idiom for managing concurrent access to shared resources. The prefix and suffix establish the context of a multithreaded environment, and the correct completion requires understanding of mutex locking mechanisms and proper use of C++ synchronization primitives.", "assertions": "", "gpt-4o": "        std::lock_guard<std::mutex> lock(mtx);\n        ++value;"}
{"id": "30", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <atomic>\n#include <cassert>\n\nstd::atomic<int> counter(0);\n\nvoid worker(int id, int increments) {\n    for (int i = 0; i < increments; ++i) {\n", "suffix": "    }\n}\n\nint main() {\n    const int num_threads = 4;\n    const int increments = 1000;\n    std::vector<std::thread> threads;\n    for (int i = 0; i < num_threads; ++i) {\n        threads.emplace_back(worker, i, increments);\n    }\n    for (auto& t : threads) {\n        t.join();\n    }\n    assert(counter == num_threads * increments);\n    std::cout << \"Counter: \" << counter << std::endl;\n    return 0;\n}\n", "golden_completion": "        counter.fetch_add(1, std::memory_order_relaxed);", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving multi-threading and atomic operations in C++. The prefix sets up a multi-threaded environment with a shared atomic counter. The golden completion correctly uses `fetch_add` with memory order to increment the counter in a thread-safe manner. The suffix includes assertions and output to verify correct behavior, ensuring that the counter value matches the expected result after all threads complete their execution.", "assertions": "", "gpt-4o": "        ++counter;"}
{"id": "31", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t numThreads) {\n        for (size_t i = 0; i < numThreads; ++i) {\n            workers.emplace_back([this] {", "suffix": "            });\n        }\n    }\n\n    ~ThreadPool() {\n        for (std::thread &worker : workers) {\n            if (worker.joinable()) {\n                worker.join();\n            }\n        }\n    }\n\n    void enqueue(std::function<void()> task) {\n        {\n            std::lock_guard<std::mutex> lock(queueMutex);\n            tasks.push_back(task);\n        }\n        condition.notify_one();\n    }\n\n    void workerFunction() {\n        while (true) {\n            std::function<void()> task;\n            {\n                std::unique_lock<std::mutex> lock(queueMutex);\n                condition.wait(lock, [this] { return !tasks.empty(); });\n                task = tasks.front();\n                tasks.erase(tasks.begin());\n            }\n            task();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> workers;\n    std::vector<std::function<void()>> tasks;\n    std::mutex queueMutex;\n    std::condition_variable condition;\n};\n\nint main() {\n    ThreadPool pool(4);\n    bool taskExecuted = false;\n    pool.enqueue([&taskExecuted] { taskExecuted = true; });\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    assert(taskExecuted);\n    return 0;\n}", "golden_completion": "                workerFunction();", "LLM_justification": "This example tests the LLM's ability to recognize and complete a complex multi-threading pattern involving a thread pool. The pattern includes thread creation, task enqueuing, and synchronization mechanisms using mutexes and condition variables. The required completion is non-trivial and involves correctly identifying the need to call the worker function within the thread's execution context. This tests advanced C++ concurrency features and proper resource management.", "assertions": "", "gpt-4o": "                workerFunction();"}
{"id": "32", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t numThreads);\n    ~ThreadPool();\n    void enqueue(std::function<void()> task);\nprivate:\n    std::vector<std::thread> workers;\n    std::deque<std::function<void()>> tasks;\n    std::mutex queueMutex;\n    std::condition_variable condition;\n    bool stop;\n};\n\nThreadPool::ThreadPool(size_t numThreads) : stop(false) {", "suffix": "}\n\nThreadPool::~ThreadPool() {\n    {\n        std::unique_lock<std::mutex> lock(queueMutex);\n        stop = true;\n    }\n    condition.notify_all();\n    for(std::thread &worker: workers)\n        worker.join();\n}\n\nvoid ThreadPool::enqueue(std::function<void()> task) {\n    {\n        std::unique_lock<std::mutex> lock(queueMutex);\n        tasks.push_back(task);\n    }\n    condition.notify_one();\n}\n\nint main() {\n    ThreadPool pool(4);\n    bool taskExecuted = false;\n    pool.enqueue([&taskExecuted] { taskExecuted = true; });\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    assert(taskExecuted == true);\n    return 0;\n}\n", "golden_completion": "    for(size_t i = 0; i < numThreads; ++i) {\n        workers.emplace_back([this] {\n            for(;;) {\n                std::function<void()> task;\n                {\n                    std::unique_lock<std::mutex> lock(this->queueMutex);\n                    this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); });\n                    if(this->stop && this->tasks.empty())\n                        return;\n                    task = std::move(this->tasks.front());\n                    this->tasks.pop_front();\n                }\n                task();\n            }\n        });\n    }\n", "LLM_justification": "This example tests the LLM's ability to complete a complex multi-threading pattern involving a thread pool design. The correct completion involves recognizing the need to initialize threads and handle task execution within a critical section. The pattern is recognizable by C++ developers familiar with concurrency and synchronization primitives. The use of mutexes, condition variables, and thread management demonstrates advanced C++ features. The suffix contains assertions to ensure that tasks are executed correctly and verifies the proper functioning of the thread pool.", "assertions": "", "gpt-4o": "    for(size_t i = 0; i < numThreads; ++i)\n        workers.emplace_back([this] {\n            while(true) {\n                std::function<void()> task;\n                {\n                    std::unique_lock<std::mutex> lock(this->queueMutex);\n                    this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); });\n                    if(this->stop && this->tasks.empty())\n                        return;\n                    task = std::move(this->tasks.front());\n                    this->tasks.pop_front();\n                }\n                task();\n            }\n        });"}
{"id": "33", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <atomic>\n#include <thread>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t);\n    ~ThreadPool();\n    void enqueue(std::function<void()>);\nprivate:\n    std::vector<std::thread> workers;\n    std::atomic<bool> stop;\n};\n\nThreadPool::ThreadPool(size_t threads) : stop(false) {\n    for(size_t i = 0; i < threads; ++i) {\n        workers.emplace_back([this] {\n            while(!this->stop) {\n                // Simulate task execution\n", "suffix": "            }\n        });\n    }\n}\n\nThreadPool::~ThreadPool() {\n    stop = true;\n    for(std::thread &worker: workers) {\n        if(worker.joinable()) {\n            worker.join();\n        }\n    }\n}\n\nvoid ThreadPool::enqueue(std::function<void()> task) {\n    // Enqueue task logic\n}\n\nint main() {\n    ThreadPool pool(4);\n    bool task_executed = false;\n    pool.enqueue([&task_executed] { task_executed = true; });\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    assert(task_executed == true);\n    return 0;\n}", "golden_completion": "                std::this_thread::sleep_for(std::chrono::milliseconds(10));\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a multi-threading pattern involving a thread pool. The prefix establishes the thread pool class, its constructor, and begins the worker thread logic. The golden completion involves simulating task execution within the worker threads. The suffix finalizes the worker thread loop, ensures proper cleanup in the destructor, and includes assertions to verify task execution. This pattern is complex and requires understanding of threading, atomic operations, and synchronization, making it a good test case for advanced C++ pattern recognition.", "assertions": "", "gpt-4o": "                std::this_thread::sleep_for(std::chrono::milliseconds(10));"}
{"id": "34", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <thread>\n#include <vector>\n#include <atomic>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t numThreads);\n    void enqueue(std::function<void()> task);\n    ~ThreadPool();\nprivate:\n    std::vector<std::thread> workers;\n    std::atomic<bool> stop;\n};\n\nThreadPool::ThreadPool(size_t numThreads) : stop(false) {\n    for (size_t i = 0; i < numThreads; ++i) {\n", "suffix": "    }\n}\n\nThreadPool::~ThreadPool() {\n    stop.store(true);\n    for (std::thread &worker : workers) {\n        if (worker.joinable()) {\n            worker.join();\n        }\n    }\n}\n\nvoid ThreadPool::enqueue(std::function<void()> task) {\n    if (!stop.load()) {\n        // Normally, a task queue would be used here\n        workers.emplace_back(std::thread(task));\n    }\n}\n\nint main() {\n    ThreadPool pool(4);\n    std::atomic<int> counter(0);\n    for (int i = 0; i < 10; ++i) {\n        pool.enqueue([&counter]() { counter.fetch_add(1); });\n    }\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    assert(counter.load() == 10);\n    return 0;\n}\n", "golden_completion": "        workers.emplace_back([this] {\n            while (!stop.load()) {\n                std::this_thread::yield();\n            }\n        });", "LLM_justification": "This example tests the model's ability to recognize and complete a complex multi-threading pattern involving a thread pool. The pattern includes thread creation, atomic operations, and proper resource cleanup using RAII. The completion involves correctly initializing worker threads to continuously check for a stop condition, demonstrating understanding of thread management and synchronization.", "assertions": "", "gpt-4o": "        workers.emplace_back([this] {\n            while (!stop.load()) {\n                // Normally, a task queue would be used here\n                std::this_thread::yield();\n            }\n        });"}
{"id": "35", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n\tThreadPool(size_t numThreads) {\n\t\tfor (size_t i = 0; i < numThreads; ++i) {\n\t\t\tthreads.emplace_back([this]() { this->worker(); });\n\t\t}\n\t}\n\n\t~ThreadPool() {\n\t\tfor (auto &thread : threads) {\n\t\t\tif (thread.joinable()) {\n\t\t\t\tthread.join();\n\t\t\t}\n\t\t}\n\t}\n\nprivate:\n\tvoid worker() {\n\t\t// Worker thread function\n\t}\n\n\tstd::vector<std::thread> threads;\n};\n\nint main() {\n\tThreadPool pool(4);\n", "suffix": "\tstd::cout << \"All assertions passed!\" << std::endl;\n\treturn 0;\n}\n    // Check thread count\n", "golden_completion": "\tassert(pool.getThreadCount() == 4);\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern for a thread pool implementation with minimal context. It includes managing threads in a vector and joining them in the destructor. The completion requires understanding the pattern of thread management and how to assert its correctness.", "assertions": "", "gpt-4o": "\tassert(pool.threads.size() == 4);"}
{"id": "36", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <thread>\n#include <atomic>\n#include <cassert>\n\nclass ThreadSafeQueue {\npublic:\n    void push(int value) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        queue_.push_back(value);\n    }\n    bool pop(int &value) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        if (queue_.empty()) {\n            return false;\n        }\n        value = queue_.front();\n        queue_.erase(queue_.begin());\n        return true;\n    }\nprivate:\n    std::vector<int> queue_;\n    std::mutex mutex_;\n};\n\nvoid worker(ThreadSafeQueue &queue, std::atomic<int> &counter) {\n    int value;\n    while (counter > 0) {", "suffix": "    }\n}\n\nint main() {\n    ThreadSafeQueue queue;\n    std::atomic<int> counter(10);\n    std::thread t1(worker, std::ref(queue), std::ref(counter));\n    std::thread t2(worker, std::ref(queue), std::ref(counter));\n    for (int i = 0; i < 10; ++i) {\n        queue.push(i);\n    }\n    t1.join();\n    t2.join();\n    assert(counter == 0);\n    int value;\n    assert(!queue.pop(value));\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "        if (queue.pop(value)) {\n            counter--;\n        }\n", "LLM_justification": "This example tests the model's ability to handle complex multi-threading patterns involving atomic operations, thread synchronization, and a thread-safe queue. The pattern requires understanding of mutexes, atomic counters, and thread management, which are advanced C++ features. The assertions verify that the atomic counter correctly decrements to zero and that the queue is empty after all operations, ensuring proper synchronization and thread safety.", "assertions": "", "gpt-4o": "        if (queue.pop(value)) {\n            --counter;\n        }"}
{"id": "37", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <atomic>\n#include <cassert>\n\nclass WorkStealingQueue {\npublic:\n    WorkStealingQueue(size_t size) : buffer(size), head(0), tail(0) {}\n    bool steal(int &task);\nprivate:\n    std::vector<int> buffer;\n    std::atomic<size_t> head;\n    std::atomic<size_t> tail;\n};\n", "suffix": "void testWorkStealingQueue() {\n    WorkStealingQueue queue(10);\n    int task;\n    assert(queue.steal(task) == false);\n}\n\nint main() {\n    testWorkStealingQueue();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "bool WorkStealingQueue::steal(int &task) {\n    size_t local_tail = tail.load(std::memory_order_relaxed);\n    size_t local_head = head.load(std::memory_order_acquire);\n    if (local_head >= local_tail) {\n        return false;\n    }\n    task = buffer[local_head % buffer.size()];\n    head.store(local_head + 1, std::memory_order_release);\n    return true;\n}", "LLM_justification": "This example tests the LLM's ability to recognize and complete a work-stealing queue pattern, which is a non-trivial multi-threading pattern. The prefix provides the class definition and necessary member variables, while the suffix includes the test function and assertions. The golden completion requires knowledge of atomic operations and memory ordering, making it a good test case for advanced C++ understanding.", "assertions": "", "gpt-4o": "bool WorkStealingQueue::steal(int &task) {\n    size_t old_head = head.load(std::memory_order_acquire);\n    if (old_head >= tail.load(std::memory_order_acquire)) {\n        return false; // Queue is empty\n    }\n    task = buffer[old_head];\n    head.store(old_head + 1, std::memory_order_release);\n    return true;\n}"}
{"id": "38", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <thread>\n#include <shared_mutex>\n\nclass ThreadSafeVector {\nprivate:\n    std::vector<int> data;\n    mutable std::shared_mutex mutex;\npublic:", "suffix": "    void remove(int value) {\n        std::unique_lock lock(mutex);\n        data.erase(std::remove(data.begin(), data.end(), value), data.end());\n    }\n\n    void print() const {\n        std::shared_lock lock(mutex);\n        for (int val : data) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    ThreadSafeVector tsVector;\n    tsVector.add(1);\n    tsVector.add(2);\n    tsVector.add(3);\n    tsVector.remove(2);\n    tsVector.print();\n    assert(tsVector.contains(1));\n    assert(!tsVector.contains(2));\n    assert(tsVector.contains(3));\n    return 0;\n}", "golden_completion": "    void add(int value) {\n        std::unique_lock lock(mutex);\n        data.push_back(value);\n    }\n\n    bool contains(int value) const {\n        std::shared_lock lock(mutex);\n        return std::find(data.begin(), data.end(), value) != data.end();\n    }\n", "LLM_justification": "This example challenges an LLM to complete a multi-threaded class that uses a shared_mutex to manage concurrent access to a vector. The golden completion requires the LLM to correctly add elements to the vector and check for their existence while adhering to thread safety. The suffix includes assertions to verify that the add and contains methods work correctly, ensuring the LLM understands the use of unique_lock and shared_lock for thread-safe operations.", "assertions": "", "gpt-4o": "public:\n    void add(int value) {\n        std::unique_lock lock(mutex);\n        data.push_back(value);\n    }\n\n    bool contains(int value) const {\n        std::shared_lock lock(mutex);\n        return std::find(data.begin(), data.end(), value) != data.end();\n    }"}
{"id": "39", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <atomic>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t numThreads) : stop(false) {\n        for (size_t i = 0; i < numThreads; ++i)\n            workers.emplace_back([this] {\n                while (!stop) {\n                    // Worker thread task\n", "suffix": "                }\n            });\n    }\n\n    ~ThreadPool() {\n        stop = true;\n        for (std::thread &worker : workers)\n            worker.join();\n    }\n\nprivate:\n    std::vector<std::thread> workers;\n    std::atomic<bool> stop;\n};\n\nint main() {\n    ThreadPool pool(4);\n    assert(pool.workers.size() == 4);\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "                    std::this_thread::yield();", "LLM_justification": "This example tests the model's ability to recognize and complete a thread pool implementation pattern, specifically focusing on complex synchronization patterns. The completion involves adding a yielding mechanism within the worker thread loop, which is a common practice to avoid busy-waiting when there are no tasks to process. The assertions verify that the thread pool is correctly initialized with the expected number of worker threads. This pattern is non-trivial and requires understanding of advanced multi-threading concepts, making it a good test for evaluating the model's low-context pattern matching capabilities.", "assertions": "", "gpt-4o": "                    std::this_thread::yield();"}
{"id": "40", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <atomic>\n#include <thread>\n#include <vector>\n#include <cassert>\n\nclass LockFreeQueue {\npublic:\n    LockFreeQueue(size_t size) : size(size), front(0), back(0) {\n        buffer.resize(size);\n    }\n    bool enqueue(int value);\nprivate:\n    std::vector<int> buffer;\n    std::atomic<size_t> front;\n    std::atomic<size_t> back;\n    size_t size;\n};\n\nbool LockFreeQueue::enqueue(int value) {\n", "suffix": "\n    buffer[pos] = value;\n    back.store((pos + 1) % size, std::memory_order_release);\n    return true;\n}\n\nint main() {\n    LockFreeQueue queue(10);\n    assert(queue.enqueue(1) == true);\n    assert(queue.enqueue(2) == true);\n    assert(queue.enqueue(3) == true);\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "    size_t pos = back.load(std::memory_order_relaxed);\n    if ((pos + 1) % size == front.load(std::memory_order_acquire)) {\n        return false;  // queue is full\n    }\n", "LLM_justification": "This example demonstrates a lock-free queue implementation using atomic operations and memory ordering specifications. It is complex enough to challenge a senior C++ developer, requiring understanding of memory order semantics and lock-free data structures. The pattern involves atomic load/store operations with specific memory orders, which are critical for correct synchronization in concurrent programming. The assertions verify the correct functionality of the enqueue operation within the constraints of a lock-free queue, ensuring the queue behaves as expected in a multi-threaded environment.", "assertions": "", "gpt-4o": "    size_t pos = back.load(std::memory_order_relaxed);\n    if ((pos + 1) % size == front.load(std::memory_order_acquire)) {\n        return false; // Queue is full\n    }"}
{"id": "41", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <atomic>\n#include <thread>\n#include <vector>\n#include <cassert>\n\nclass LockFreeQueue {\npublic:\n    LockFreeQueue() : head(0), tail(0) {}\n    void enqueue(int value);\n    int dequeue();\nprivate:\n    std::atomic<int> head;\n    std::atomic<int> tail;\n    std::vector<int> buffer{100};\n};\n", "suffix": "int main() {\n    LockFreeQueue queue;\n    queue.enqueue(42);\n    queue.enqueue(43);\n    assert(queue.dequeue() == 42);\n    assert(queue.dequeue() == 43);\n    return 0;\n}", "golden_completion": "void LockFreeQueue::enqueue(int value) {\n    int current_tail = tail.load(std::memory_order_relaxed);\n    buffer[current_tail % buffer.size()] = value;\n    tail.store(current_tail + 1, std::memory_order_release);\n}\n\nint LockFreeQueue::dequeue() {\n    int current_head = head.load(std::memory_order_relaxed);\n    if (current_head == tail.load(std::memory_order_acquire)) {\n        throw std::runtime_error(\"Queue is empty\");\n    }\n    int value = buffer[current_head % buffer.size()];\n    head.store(current_head + 1, std::memory_order_release);\n    return value;\n}", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete the implementation of a lock-free queue using atomic operations. The pattern involves correct usage of std::atomic and memory order specifications, which are advanced C++ features. The assertions in the suffix validate the enqueue and dequeue operations, ensuring they work correctly in a multi-threaded context. This example requires understanding of atomic operations, memory ordering, and handling potential race conditions, making it complex and suitable for testing advanced C++ knowledge.", "assertions": "", "gpt-4o": "void LockFreeQueue::enqueue(int value) {\n    int current_tail = tail.load(std::memory_order_relaxed);\n    buffer[current_tail % buffer.size()] = value;\n    tail.store(current_tail + 1, std::memory_order_release);\n}\n\nint LockFreeQueue::dequeue() {\n    int current_head = head.load(std::memory_order_relaxed);\n    int value = buffer[current_head % buffer.size()];\n    head.store(current_head + 1, std::memory_order_release);\n    return value;\n}"}
{"id": "42", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <cassert>\n\nclass ThreadSafeQueue {\npublic:\n\tvoid enqueue(int value) {\n\t\tstd::unique_lock<std::mutex> lock(mtx);\n\t\tqueue.push_back(value);\n\t\tcv.notify_one();\n\t}\n\n\tint dequeue() {\n\t\tstd::unique_lock<std::mutex> lock(mtx);\n\t\tcv.wait(lock, [this]{ return !queue.empty(); });\n\t\tint value = queue.front();\n\t\tqueue.erase(queue.begin());\n\t\treturn value;\n\t}\n\nprivate:\n\tstd::vector<int> queue;\n\tstd::mutex mtx;\n\tstd::condition_variable cv;\n};\n\nvoid producer(ThreadSafeQueue &q) {\n\tfor (int i = 0; i < 10; ++i) {", "suffix": "\t}\n}\n\nvoid consumer(ThreadSafeQueue &q) {\n\tfor (int i = 0; i < 10; ++i) {\n\t\tint value = q.dequeue();\n\t\tassert(value == i);\n\t}\n}\n\nint main() {\n\tThreadSafeQueue q;\n\tstd::thread prod(producer, std::ref(q));\n\tstd::thread cons(consumer, std::ref(q));\n\tprod.join();\n\tcons.join();\n\tstd::cout << \"All assertions passed.\\n\";\n\treturn 0;\n}\n", "golden_completion": "\n\t\tq.enqueue(i);\n", "LLM_justification": "This example tests the model's ability to recognize and complete a producer-consumer pattern using a thread-safe queue with mutexes and condition variables. The pattern is clear and identifiable with minimal context, and the complexity lies in understanding thread synchronization and proper use of C++ concurrency primitives. The assertions in the suffix ensure the queue operates correctly under concurrent access.", "assertions": "", "gpt-4o": "\t\tq.enqueue(i);"}
{"id": "43", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <atomic>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t numThreads) : stop(false) {\n        for (size_t i = 0; i < numThreads; ++i) {\n            workers.emplace_back([this] {\n                for (;;) {\n                    std::function<void()> task;\n                    {", "suffix": "                    }\n                    if (task) task();\n                    else if (stop.load()) return;\n                }\n            });\n        }\n    }\n    ~ThreadPool() {\n        stop.store(true);\n        for (std::thread &worker : workers)\n            worker.join();\n    }\nprivate:\n    std::vector<std::thread> workers;\n    std::atomic<bool> stop;\n};\n\nint main() {\n    ThreadPool pool(4);\n    std::cout << \"ThreadPool created with 4 threads\" << std::endl;\n    assert(pool.workers.size() == 4);\n    assert(!pool.stop.load());\n    return 0;\n}", "golden_completion": "                        std::unique_lock<std::mutex> lock(this->queueMutex);\n                        this->condition.wait(lock, [this] { return this->stop.load(); });", "LLM_justification": "This example challenges the LLM to complete the pattern of a complex synchronization mechanism in a thread pool implementation. It requires understanding of mutexes, condition variables, and atomic operations. The context provided is minimal but sufficient for a knowledgeable developer to recognize the pattern and complete it correctly. The assertions in the suffix verify the creation of threads and ensure the stop flag is not set, which are key aspects of the ThreadPool's initialization logic. The golden completion should demonstrate correct use of synchronization primitives to wait for tasks or shutdown signal, which is a non-trivial task requiring proper understanding of concurrency controls in C++.", "assertions": "", "gpt-4o": "                    std::unique_lock<std::mutex> lock(this->queue_mutex);\n                    this->condition.wait(lock, [this] { return this->stop.load() || !this->tasks.empty(); });\n                    if (this->stop.load() && this->tasks.empty()) return;\n                    task = std::move(this->tasks.front());\n                    this->tasks.pop();"}
{"id": "44", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <atomic>\n\nstd::atomic<int> counter(0);\n\nvoid increment() {\n    for (int i = 0; i < 1000; ++i) {", "suffix": "    }\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n    t1.join();\n    t2.join();\n    assert(counter.load() == 2000);\n    std::cout << \"Counter: \" << counter.load() << std::endl;\n    return 0;\n}", "golden_completion": "        ++counter;", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving multi-threaded atomic operations. The prefix sets up an atomic counter and a loop that should increment this counter. The correct completion involves recognizing that the operation should be atomic to maintain thread safety. The suffix contains the execution and assertion code to ensure the counter has been incremented correctly by both threads, making it a good low-context test case.", "assertions": "", "gpt-4o": "        counter.fetch_add(1, std::memory_order_relaxed);"}
{"id": "45", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <cassert>\n\nclass ThreadSafeVector {\npublic:\n    void push_back(int value) {\n        std::lock_guard<std::mutex> lock(mtx_);\n", "suffix": "    }\n    \n    int at(size_t index) {\n        std::lock_guard<std::mutex> lock(mtx_);\n        return data_.at(index);\n    }\n\nprivate:\n    std::vector<int> data_;\n    std::mutex mtx_;\n};\n\nint main() {\n    ThreadSafeVector ts_vec;\n    std::thread t1([&]() { ts_vec.push_back(1); });\n    std::thread t2([&]() { ts_vec.push_back(2); });\n    t1.join();\n    t2.join();\n    assert(ts_vec.at(0) == 1 || ts_vec.at(0) == 2);\n    assert(ts_vec.at(1) == 1 || ts_vec.at(1) == 2);\n    assert(ts_vec.at(0) != ts_vec.at(1));\n    return 0;\n}", "golden_completion": "        data_.push_back(value);", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving a thread-safe data structure manipulation. The prefix establishes a class with a mutex-protected vector and a push_back method, but the critical operation of adding an element to the vector is missing. The suffix contains a method to retrieve elements and a main function that uses multiple threads to push elements into the vector, followed by assertions to verify the correct behavior. This requires understanding of mutexes, thread safety, and C++ standard library containers.", "assertions": "", "gpt-4o": "        data_.push_back(value);"}
{"id": "46", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <atomic>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t numThreads) : stop(false) {\n        for(size_t i = 0; i < numThreads; ++i) {\n            workers.emplace_back([this] {\n                while(!this->stop) {\n                    std::function<void()> task;\n                    {\n                        std::unique_lock<std::mutex> lock(this->queueMutex);\n                        this->condition.wait(lock, [this]{ return this->stop || !this->tasks.empty(); });\n                        if(this->stop && this->tasks.empty())\n                            return;\n                        task = std::move(this->tasks.front());\n                        this->tasks.pop();\n                    }\n                    task();\n                }\n            });\n        }\n    }\n    void enqueue(std::function<void()> task) {\n        {\n            std::unique_lock<std::mutex> lock(queueMutex);\n            tasks.push(std::move(task));\n        }\n        condition.notify_one();\n    }\n    ~ThreadPool() {\n        {\n            std::unique_lock<std::mutex> lock(queueMutex);\n            stop = true;\n        }\n        condition.notify_all();\n        for(std::thread &worker: workers)\n            worker.join();\n    }\nprivate:\n    std::vector<std::thread> workers;\n    std::queue<std::function<void()>> tasks;\n    std::mutex queueMutex;\n    std::condition_variable condition;\n    bool stop;\n};\n\nint main() {\n    ThreadPool pool(4);\n    std::atomic<int> counter(0);\n    for(int i = 0; i < 8; ++i) {\n        pool.enqueue([&counter] {\n            counter.fetch_add(1, std::memory_order_relaxed);\n        });\n    }\n", "suffix": "\n    assert(counter.load(std::memory_order_relaxed) == 8);\n    std::cout << \"All tasks completed successfully.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    std::this_thread::sleep_for(std::chrono::seconds(1));\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving a thread pool implementation and synchronization using atomic operations and condition variables. The pattern is complex and requires an understanding of thread management, synchronization, and atomic operations, making it a good test case for advanced C++ features.", "assertions": "", "gpt-4o": "    std::this_thread::sleep_for(std::chrono::seconds(1));"}
{"id": "47", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <atomic>\n\nclass WorkStealingQueue {\npublic:\n\tvoid push(int data);\n\tbool try_pop(int &data);\n\tbool empty() const;\nprivate:\n\tstd::vector<int> queue;\n\tstd::atomic<size_t> head{0};\n\tstd::atomic<size_t> tail{0};\n};\n", "suffix": "int main() {\n\tWorkStealingQueue wsq;\n\tstd::thread t1([&wsq]() {\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\twsq.push(i);\n\t\t}\n\t});\n\n\tstd::thread t2([&wsq]() {\n\t\tint data;\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\twhile (!wsq.try_pop(data)) {}\n\t\t\tassert(data >= 0 && data < 10);\n\t\t}\n\t});\n\n\tt1.join();\n\tt2.join();\n\tassert(wsq.empty());\n\treturn 0;\n}", "golden_completion": "void WorkStealingQueue::push(int data) {\n\tqueue.push_back(data);\n\ttail.fetch_add(1, std::memory_order_release);\n}\n\nbool WorkStealingQueue::try_pop(int &data) {\n\tsize_t old_head = head.load(std::memory_order_relaxed);\n\tif (old_head >= tail.load(std::memory_order_acquire)) {\n\t\treturn false;\n\t}\n\tdata = queue[old_head];\n\thead.fetch_add(1, std::memory_order_release);\n\treturn true;\n}\n\nbool WorkStealingQueue::empty() const {\n\treturn head.load(std::memory_order_acquire) >= tail.load(std::memory_order_acquire);\n}", "LLM_justification": "This example tests the model's ability to recognize and complete a complex multi-threading pattern involving work-stealing queues. The key operations in the queue, push and try_pop, use atomic operations and memory orders to ensure thread safety. The example also includes a verification step that checks the correctness of the queue operations and ensures that the queue is empty at the end. This scenario requires understanding advanced C++ features such as atomic operations, memory ordering, and multi-threading, making it a good test case for low-context pattern matching.", "assertions": "", "gpt-4o": "void WorkStealingQueue::push(int data) {\n    size_t current_tail = tail.load(std::memory_order_relaxed);\n    if (current_tail < queue.size()) {\n        queue[current_tail] = data;\n    } else {\n        queue.push_back(data);\n    }\n    tail.store(current_tail + 1, std::memory_order_release);\n}\n\nbool WorkStealingQueue::try_pop(int &data) {\n    size_t current_head = head.load(std::memory_order_relaxed);\n    if (current_head >= tail.load(std::memory_order_acquire)) {\n        return false;\n    }\n    data = queue[current_head];\n    head.store(current_head + 1, std::memory_order_release);\n    return true;\n}\n\nbool WorkStealingQueue::empty() const {\n    return head.load(std::memory_order_acquire) >= tail.load(std::memory_order_acquire);\n}"}
{"id": "48", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <atomic>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t num_threads) : done(false), work_queue(num_threads), current_index(0) {\n        for(size_t i = 0; i < num_threads; ++i) {\n            workers.emplace_back(&ThreadPool::worker_thread, this);\n        }\n    }\n    ~ThreadPool() {\n        done = true;\n        for(auto& worker : workers) {\n            worker.join();\n        }\n    }\n    void submit(std::function<void()> func) {\n        // Submission logic here\n", "suffix": "    }\n\nprivate:\n    void worker_thread() {\n        while(!done) {\n            size_t index = current_index++ % work_queue.size();\n            if(work_queue[index]) {\n                std::function<void()> task;\n                if(work_queue[index].compare_exchange_strong(task, nullptr)) {\n                    task();\n                }\n            }\n        }\n    }\n\n    std::atomic<bool> done;\n    std::vector<std::atomic<std::function<void()>>> work_queue;\n    std::atomic<size_t> current_index;\n    std::vector<std::thread> workers;\n};\n\nint main() {\n    ThreadPool pool(4);\n    std::atomic<int> counter{0};\n    for(int i = 0; i < 10; ++i) {\n        pool.submit([&counter] { counter++; });\n    }\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    assert(counter == 10);\n    std::cout << \"All tasks completed successfully.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "        size_t index = current_index++ % work_queue.size();\n        while(work_queue[index]) {\n            index = current_index++ % work_queue.size();\n        }\n        work_queue[index] = func;\n", "LLM_justification": "This example demonstrates a complex synchronization pattern in a thread pool implementation. The task submission and worker thread coordination involve atomic operations and memory ordering, which are advanced C++ topics. The golden completion fills in the task submission logic, ensuring no race conditions occur. The suffix contains assertions that verify the correct execution of the thread pool, ensuring all tasks are completed as expected.", "assertions": "", "gpt-4o": "        size_t index = current_index++ % work_queue.size();\n        std::function<void()> expected = nullptr;\n        while (!work_queue[index].compare_exchange_weak(expected, func)) {\n            expected = nullptr;\n        }"}
{"id": "49", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <cassert>\nstd::mutex mtx;\nvoid workerFunction(std::vector<int>& data) {\n    for (int i = 0; i < 1000; ++i) {\n        std::lock_guard<std::mutex> lock(mtx);", "suffix": "    }\n}\nint main() {\n    std::vector<int> data;\n    std::thread t1(workerFunction, std::ref(data));\n    std::thread t2(workerFunction, std::ref(data));\n    t1.join();\n    t2.join();\n    assert(data.size() == 2000);\n    assert(std::all_of(data.begin(), data.end(), [](int n){ return n >= 0 && n < 1000; }));\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "        data.push_back(i);", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving multi-threading with mutex locks. The workerFunction pushes back elements into a shared vector within a critical section protected by a mutex. The assertions verify that the vector contains the correct number of elements and that all elements are within the expected range. This scenario challenges the model to understand and complete code involving thread synchronization and shared data management.", "assertions": "", "gpt-4o": "        data.push_back(i);"}
{"id": "50", "testsource": "synthbench-low-context", "language": "cpp", "prefix": "#include <iostream>\n#include <thread>\n#include <vector>\n#include <atomic>\n#include <cassert>\n\nclass ThreadPool {\npublic:\n    ThreadPool(size_t numThreads) : stop(false) {", "suffix": "    }\n\n    void addTask(std::function<void()> task) {\n        std::unique_lock<std::mutex> lock(queueMutex);\n        tasks.push_back(task);\n        condition.notify_one();\n    }\n\n    void waitForCompletion() {\n        for (std::thread &worker : workers) {\n            worker.join();\n        }\n    }\n\nprivate:\n    std::vector<std::thread> workers;\n    std::vector<std::function<void()>> tasks;\n    std::mutex queueMutex;\n    std::condition_variable condition;\n    std::atomic<bool> stop;\n\n    void workerThread() {\n        while (!stop) {\n            std::function<void()> task;\n            {\n                std::unique_lock<std::mutex> lock(queueMutex);\n                condition.wait(lock, [this] { return stop || !tasks.empty(); });\n                if (stop && tasks.empty())\n                    return;\n                task = std::move(tasks.back());\n                tasks.pop_back();\n            }\n            task();\n        }\n    }\n};\n\nint main() {\n    ThreadPool pool(4);\n    std::atomic<int> counter(0);\n\n    for (int i = 0; i < 10; ++i) {\n        pool.addTask([&counter] { counter.fetch_add(1, std::memory_order_relaxed); });\n    }\n\n    pool.waitForCompletion();\n    assert(counter == 10);\n    return 0;\n}\n", "golden_completion": "        for (size_t i = 0; i < numThreads; ++i) {\n            workers.emplace_back(&ThreadPool::workerThread, this);\n        }", "LLM_justification": "This example tests the LLM's ability to recognize and complete a thread pool pattern with minimal context. The pool initializes a set number of worker threads and tasks are distributed among them. This requires understanding of thread management, synchronization, and atomic operations, which are advanced C++ concepts. The assertions verify that all tasks have been executed correctly by the worker threads.", "assertions": "", "gpt-4o": "        for (size_t i = 0; i < numThreads; ++i) {\n            workers.emplace_back([this] { workerThread(); });\n        }"}
