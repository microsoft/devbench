{"id": "1", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <Eigen/Dense>\n#include <iostream>\n#include <cassert>\n\n// Define a function to perform matrix multiplication using Eigen\nEigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd& mat1, const Eigen::MatrixXd& mat2) {\n    if (mat1.cols() != mat2.rows()) {\n        throw std::invalid_argument(\"Matrix dimensions must agree for multiplication.\");\n    }\n    return mat1 * mat2;\n}\n\n// Initialize matrices with random values for testing\nEigen::MatrixXd generateRandomMatrix(int rows, int cols) {\n    Eigen::MatrixXd mat = Eigen::MatrixXd::Random(rows, cols);\n    return mat;\n}\n\nint main() {\n    // Generate test matrices\n    Eigen::MatrixXd mat1 = generateRandomMatrix(4, 3);\n    Eigen::MatrixXd mat2 = generateRandomMatrix(3, 2);\n\n    // Perform matrix multiplication\n    Eigen::MatrixXd result;\n    try {\n        result = multiplyMatrices(mat1, mat2);\n    } catch (const std::invalid_argument& e) {\n        std::cerr << e.what() << std::endl;\n        return -1;\n    }\n\n    // Output matrices for verification\n    std::cout << \"Matrix 1:\\n\" << mat1 << std::endl;\n    std::cout << \"Matrix 2:\\n\" << mat2 << std::endl;\n    std::cout << \"Resultant Matrix:\\n\" << result << std::endl;\n\n    // Golden completion placeholder\n", "suffix": "\n\n    // Clean up resources (handled automatically by Eigen)\n    std::cout << \"Matrix multiplication and verification succeeded.\" << std::endl;\n    return 0;\n}", "golden_completion": "    // Verify the correctness of matrix multiplication using a known result\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert((result - expected).norm() < 1e-9);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a matrix multiplication operation using the Eigen library, which is a less common but highly specialized library for linear algebra in C++. The scenario includes error handling for dimension mismatches, matrix initialization, and verification of results using assertions. This ensures that the model understands the proper usage and validation of uncommon library functions while handling edge cases and maintaining proper parameter ordering.", "assertions": "", "DeepSeek-R1": "    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(expected.isApprox(result));"}
{"id": "2", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <openssl/evp.h>\n\nclass CryptoHelper {\npublic:\n    CryptoHelper() : ctx(EVP_CIPHER_CTX_new()) {}\n    ~CryptoHelper() { if (ctx) EVP_CIPHER_CTX_free(ctx); }\n\n    void init(const unsigned char *key, const unsigned char *iv) {\n        EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv);\n    }\n\n    int encrypt(const unsigned char *plaintext, int plaintext_len, unsigned char *ciphertext) {\n        int len;\n        int ciphertext_len;\n\n        if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {\n            return -1;\n        }\n        ciphertext_len = len;\n\n        if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {\n            return -1;\n        }\n        ciphertext_len += len;\n\n        return ciphertext_len;\n    }\n\nprivate:\n    EVP_CIPHER_CTX *ctx;\n};\n\nint main() {\n    unsigned char key[32] = {0};\n    unsigned char iv[16] = {0};\n    unsigned char plaintext[] = \"This is a test.\";\n    unsigned char ciphertext[128];\n\n    CryptoHelper crypto;\n    crypto.init(key, iv);\n    int ciphertext_len = crypto.encrypt(plaintext, strlen((char *)plaintext), ciphertext);\n    assert(ciphertext_len > 0);\n    std::cout << \"Ciphertext length: \" << ciphertext_len << std::endl;\n\n    // Add decryption code here\n", "suffix": "\n\n    assert(strcmp((char *)plaintext, (char *)decryptedtext) == 0);\n    std::cout << \"Decrypted text: \" << decryptedtext << std::endl;\n\n    return 0;\n}", "golden_completion": "    EVP_CIPHER_CTX *ctx_decrypt = EVP_CIPHER_CTX_new();\n    EVP_DecryptInit_ex(ctx_decrypt, EVP_aes_256_cbc(), nullptr, key, iv);\n\n    int len;\n    int plaintext_len;\n    unsigned char decryptedtext[128];\n\n    if(1 != EVP_DecryptUpdate(ctx_decrypt, decryptedtext, &len, ciphertext, ciphertext_len)) {\n        EVP_CIPHER_CTX_free(ctx_decrypt);\n        return -1;\n    }\n    plaintext_len = len;\n\n    if(1 != EVP_DecryptFinal_ex(ctx_decrypt, decryptedtext + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx_decrypt);\n        return -1;\n    }\n    plaintext_len += len;\n    decryptedtext[plaintext_len] = '\\0';\n\n    EVP_CIPHER_CTX_free(ctx_decrypt);\n\n", "LLM_justification": "This test case is a good example of using the OpenSSL library for encryption and decryption, which involves uncommon API functions such as EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, and EVP_DecryptFinal_ex. It ensures that the LLM can handle complex cryptographic operations, manage resource cleanup, and verify the correctness of the encryption and decryption process using assertions. The prefix establishes the encryption pattern, while the golden completion and suffix focus on the decryption process, ensuring a clear distinction between them.", "assertions": "", "DeepSeek-R1": "    unsigned char decryptedtext[128];\n    EVP_CIPHER_CTX *decrypt_ctx = EVP_CIPHER_CTX_new();\n    EVP_DecryptInit_ex(decrypt_ctx, EVP_aes_256_cbc(), nullptr, key, iv);\n    int len, decrypted_len;\n    EVP_DecryptUpdate(decrypt_ctx, decryptedtext, &len, ciphertext, ciphertext_len);\n    decrypted_len = len;\n    EVP_DecryptFinal_ex(decrypt_ctx, decryptedtext + decrypted_len, &len);\n    decrypted_len += len;\n    decryptedtext[decrypted_len] = '\\0';\n    EVP_CIPHER_CTX_free(decrypt_ctx);"}
{"id": "3", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <harfbuzz/hb.h>\n#include <harfbuzz/hb-ft.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include <cassert>\n\n// Helper function to initialize FreeType library\nFT_Library initFreeType() {\n    FT_Library ftLibrary;\n    if (FT_Init_FreeType(&ftLibrary)) {\n        throw std::runtime_error(\"Failed to initialize FreeType library\");\n    }\n    return ftLibrary;\n}\n\n// Helper function to load a font face\nFT_Face loadFontFace(FT_Library ftLibrary, const char *fontPath) {\n    FT_Face ftFace;\n    if (FT_New_Face(ftLibrary, fontPath, 0, &ftFace)) {\n        throw std::runtime_error(\"Failed to load font face\");\n    }\n    return ftFace;\n}\n\n// Helper function to create a HarfBuzz buffer\nhb_buffer_t* createBuffer(const char *text) {\n    hb_buffer_t *buffer = hb_buffer_create();\n    hb_buffer_add_utf8(buffer, text, -1, 0, -1);\n    hb_buffer_guess_segment_properties(buffer);\n    return buffer;\n}\n\n// Helper function to create a HarfBuzz font\nhb_font_t* createHbFont(FT_Face ftFace) {\n    hb_font_t *hbFont = hb_ft_font_create(ftFace, NULL);\n    if (!hbFont) {\n        throw std::runtime_error(\"Failed to create HarfBuzz font\");\n    }\n    return hbFont;\n}\n\nint main() {\n    const char *fontPath = \"/path/to/font.ttf\";\n    const char *text = \"Hello, HarfBuzz!\";\n\n    FT_Library ftLibrary = initFreeType();\n    FT_Face ftFace = loadFontFace(ftLibrary, fontPath);\n    hb_buffer_t *buffer = createBuffer(text);\n    hb_font_t *hbFont = createHbFont(ftFace);\n\n    // Shape text with HarfBuzz\n", "suffix": "\n\n    // Print glyph information\n    for (unsigned int i = 0; i < glyphCount; i++) {\n        std::cout << \"Glyph \" << glyphInfo[i].codepoint << \" at (\" << glyphPos[i].x_offset << \", \" << glyphPos[i].y_offset << \") with advance (\" << glyphPos[i].x_advance << \", \" << glyphPos[i].y_advance << \")\\n\";\n    }\n\n    // Cleanup\n    hb_buffer_destroy(buffer);\n    hb_font_destroy(hbFont);\n    FT_Done_Face(ftFace);\n    FT_Done_FreeType(ftLibrary);\n\n    return 0;\n}\n", "golden_completion": "    hb_shape(hbFont, buffer, NULL, 0);\n\n    // Retrieve glyph information\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);\n\n    // Assertions to verify the shaping process\n    assert(glyphCount > 0);\n    assert(glyphInfo != NULL);\n    assert(glyphPos != NULL);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete the usage of the HarfBuzz library for text shaping, which is less common. The prefix includes the setup of FreeType and HarfBuzz, and the golden completion focuses on the shaping process and retrieval of glyph information. The suffix contains assertions to verify the correctness of the shaping process and prints the glyph information. This scenario is comprehensive in testing the model's understanding of text shaping with uncommon libraries.", "assertions": "", "DeepSeek-R1": "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount = hb_buffer_get_length(buffer);\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, NULL);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, NULL);"}
{"id": "4", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cassert>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n\n// Utility function to initialize OpenSSL library\nvoid init_openssl() {\n    OpenSSL_add_all_algorithms();\n    ERR_load_crypto_strings();\n}\n\n// Utility function to cleanup OpenSSL library\nvoid cleanup_openssl() {\n    EVP_cleanup();\n    ERR_free_strings();\n}\n\n// Function to generate a random key\nstd::vector<unsigned char> generate_random_key(int length) {\n    std::vector<unsigned char> key(length);\n    if (!RAND_bytes(key.data(), length)) {\n        throw std::runtime_error(\"Failed to generate random bytes\");\n    }\n    return key;\n}\n\n// Function to encrypt data using AES-256-CBC\nstd::vector<unsigned char> encrypt(const std::vector<unsigned char>& plaintext, const std::vector<unsigned char>& key, const std::vector<unsigned char>& iv) {\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n    }\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key.data(), iv.data())) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_EncryptInit_ex failed\");\n    }\n    std::vector<unsigned char> ciphertext(plaintext.size() + EVP_CIPHER_block_size(EVP_aes_256_cbc()));\n    int len;\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext.data(), &len, plaintext.data(), plaintext.size())) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_EncryptUpdate failed\");\n    }\n    int ciphertext_len = len;\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_EncryptFinal_ex failed\");\n    }\n    ciphertext_len += len;\n    ciphertext.resize(ciphertext_len);\n    EVP_CIPHER_CTX_free(ctx);\n    return ciphertext;\n}\n\nint main() {\n    try {\n        init_openssl();\n\n        // Test data\n        std::vector<unsigned char> plaintext = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        std::vector<unsigned char> key = generate_random_key(32);\n        std::vector<unsigned char> iv(16, 0);  // Initialization vector\n", "suffix": "        // Encrypt the plaintext\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);\n\n        // Assertions to verify encryption\n        assert(!ciphertext.empty());\n        assert(ciphertext.size() > plaintext.size());\n        std::cout << \"Encryption successful. Ciphertext size: \" << ciphertext.size() << std::endl;\n\n        // Cleanup OpenSSL\n        cleanup_openssl();\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n", "golden_completion": "        std::vector<unsigned char> iv = generate_random_key(16);  // Initialization vector\n", "LLM_justification": "This test case verifies the LLM's capability to understand and complete a pattern involving the OpenSSL library for cryptographic operations, specifically AES-256-CBC encryption. It checks the model's ability to correctly use less common functions like RAND_bytes for generating random bytes and EVP_EncryptInit_ex, EVP_EncryptUpdate, and EVP_EncryptFinal_ex for encryption. The assertions ensure that the encrypted data is non-empty and larger than the plaintext, validating the encryption process.", "assertions": "", "DeepSeek-R1": "        iv = generate_random_key(16);"}
{"id": "5", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <hb.h>\n#include <hb-ft.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include <cassert>\n\n// Helper function to load a font face\nFT_Face loadFontFace(FT_Library library, const char* fontFilePath) {\n    FT_Face face;\n    if (FT_New_Face(library, fontFilePath, 0, &face)) {\n        std::cerr << \"Failed to load font face.\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    return face;\n}\n\n// Helper function to create a HarfBuzz buffer\nhb_buffer_t* createHarfBuzzBuffer(const char* text) {\n    hb_buffer_t* buffer = hb_buffer_create();\n    hb_buffer_add_utf8(buffer, text, -1, 0, -1);\n    hb_buffer_guess_segment_properties(buffer);\n    return buffer;\n}\n\n// Helper function to shape text\nvoid shapeText(hb_font_t* font, hb_buffer_t* buffer) {\n    hb_shape(font, buffer, NULL, 0);\n}\n\n// Helper function to print shaped text information\nvoid printShapedTextInfo(hb_buffer_t* buffer) {\n    unsigned int len = hb_buffer_get_length(buffer);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(buffer, NULL);\n    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(buffer, NULL);\n    for (unsigned int i = 0; i < len; ++i) {\n        std::cout << \"Glyph ID: \" << info[i].codepoint << \", X Offset: \" << pos[i].x_offset << \", Y Offset: \" << pos[i].y_offset << std::endl;\n    }\n}\n\nint main() {\n    FT_Library ftLibrary;\n    if (FT_Init_FreeType(&ftLibrary)) {\n        std::cerr << \"Failed to initialize FreeType library.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n    const char* fontFilePath = \"path/to/font.ttf\";\n    FT_Face ftFace = loadFontFace(ftLibrary, fontFilePath);\n    hb_font_t* hbFont = hb_ft_font_create(ftFace, NULL);\n    const char* text = \"Hello, HarfBuzz!\";\n    hb_buffer_t* hbBuffer = createHarfBuzzBuffer(text);\n    shapeText(hbFont, hbBuffer);\n    printShapedTextInfo(hbBuffer);\n    // Test if the buffer has glyphs and assert the information\n", "suffix": "    // Assertions to verify the shaped text information\n    unsigned int len = hb_buffer_get_length(hbBuffer);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(hbBuffer, NULL);\n    assert(len > 0);\n    for (unsigned int i = 0; i < len; ++i) {\n        assert(info[i].codepoint != 0);\n        assert(pos[i].x_offset != 0 || pos[i].y_offset != 0);\n    }\n    // Cleanup resources\n    hb_buffer_destroy(hbBuffer);\n    hb_font_destroy(hbFont);\n    FT_Done_Face(ftFace);\n    FT_Done_FreeType(ftLibrary);\n    return 0;\n}", "golden_completion": "\n    assert(hb_buffer_get_length(hbBuffer) > 0);\n", "LLM_justification": "This example tests the use of the HarfBuzz library for text shaping, specifically focusing on functions that are less commonly used such as hb_buffer_add_utf8 and hb_shape. The test case verifies if the buffer has glyphs and ensures that the shaped text information is valid. This scenario helps evaluate the LLM's ability to recognize and correctly use rare functions from the HarfBuzz API, handle resource initialization and cleanup, and make assertions on the processed data.", "assertions": "", "DeepSeek-R1": "unsigned int len = hb_buffer_get_length(hbBuffer);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(hbBuffer, NULL);\n    assert(len > 0);\n    for (unsigned int i = 0; i < len; ++i) {\n        assert(info[i].codepoint != 0);\n        assert(pos[i].x_offset != 0 || pos[i].y_offset != 0);\n    }"}
{"id": "6", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <hb.h>\n#include <hb-ft.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n#include <cassert>\n\n// This example demonstrates the use of HarfBuzz and FreeType to shape text.\n// HarfBuzz is a text shaping library, while FreeType is a font rendering library.\n\n// Initialize FreeType and HarfBuzz\nFT_Library ft_library;\nFT_Face ft_face;\nhb_buffer_t *hb_buffer;\nhb_font_t *hb_font;\n\nvoid initialize() {\n    // Initialize FreeType library\n    if (FT_Init_FreeType(&ft_library)) {\n        std::cerr << \"Could not initialize FreeType library\" << std::endl;\n        exit(1);\n    }\n\n    // Load a font\n    if (FT_New_Face(ft_library, \"path/to/font.ttf\", 0, &ft_face)) {\n        std::cerr << \"Could not open font\" << std::endl;\n        exit(1);\n    }\n\n    // Set the font size\n    FT_Set_Pixel_Sizes(ft_face, 0, 16);\n\n    // Initialize HarfBuzz buffer\n    hb_buffer = hb_buffer_create();\n\n    // Create HarfBuzz font\n    hb_font = hb_ft_font_create(ft_face, NULL);\n}\n\nvoid cleanup() {\n    // Cleanup HarfBuzz objects\n    hb_font_destroy(hb_font);\n    hb_buffer_destroy(hb_buffer);\n\n    // Cleanup FreeType objects\n    FT_Done_Face(ft_face);\n    FT_Done_FreeType(ft_library);\n}\n\nint main() {\n    initialize();\n\n    // Set text to be shaped\n    const char *text = \"Hello, HarfBuzz!\";\n    hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);\n\n    // Set script, language, and direction\n    hb_buffer_set_script(hb_buffer, HB_SCRIPT_LATIN);\n    hb_buffer_set_language(hb_buffer, hb_language_from_string(\"en\", -1));\n    hb_buffer_set_direction(hb_buffer, HB_DIRECTION_LTR);\n\n    // Shape the text\n", "suffix": "\n\n    // Get glyph information and positions\n    unsigned int glyph_count;\n    hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buffer, &glyph_count);\n    hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions(hb_buffer, &glyph_count);\n\n    // Assertions to verify correct shaping\n    assert(glyph_count == 14);\n    for (unsigned int i = 0; i < glyph_count; ++i) {\n        assert(glyph_info[i].codepoint != 0);\n    }\n\n    // Print glyph information and positions\n    for (unsigned int i = 0; i < glyph_count; ++i) {\n        std::cout << \"Glyph \" << i << \": codepoint=\" << glyph_info[i].codepoint\n                  << \", x_advance=\" << glyph_pos[i].x_advance\n                  << \", y_advance=\" << glyph_pos[i].y_advance\n                  << \", x_offset=\" << glyph_pos[i].x_offset\n                  << \", y_offset=\" << glyph_pos[i].y_offset << std::endl;\n    }\n\n    cleanup();\n    return 0;\n}", "golden_completion": "    hb_shape(hb_font, hb_buffer, NULL, 0);", "LLM_justification": "This example demonstrates the use of HarfBuzz and FreeType, which are less common libraries for text and font processing. The prefix sets up the FreeType and HarfBuzz libraries and initializes the necessary objects. The golden completion involves shaping the text with HarfBuzz, which is a critical step in using this API. The suffix includes assertions to verify the correct behavior of the shaping process and prints the glyph information and positions. This scenario tests the LLM's ability to correctly use the HarfBuzz shaping function and handle the less common API usage patterns.", "assertions": "", "DeepSeek-R1": "    hb_shape(hb_font, hb_buffer, NULL, 0);"}
{"id": "7", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// A simple function to initialize an Eigen matrix with given values\nvoid initializeMatrix(Eigen::MatrixXd &matrix) {\n    matrix(0, 0) = 1.0;\n    matrix(1, 0) = 2.0;\n    matrix(0, 1) = 3.0;\n    matrix(1, 1) = 4.0;\n}\n\n// A function to compute the inverse of a 2x2 matrix using Eigen library\nEigen::MatrixXd computeInverse(const Eigen::MatrixXd &matrix) {\n    assert(matrix.rows() == 2 && matrix.cols() == 2);\n    return matrix.inverse();\n}\n\n// Another function to multiply two matrices\nEigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd &matrix1, const Eigen::MatrixXd &matrix2) {\n    return matrix1 * matrix2;\n}\n\n// A function to add two matrices\nEigen::MatrixXd addMatrices(const Eigen::MatrixXd &matrix1, const Eigen::MatrixXd &matrix2) {\n    return matrix1 + matrix2;\n}\n\nint main() {\n    // Initialize a 2x2 matrix\n    Eigen::MatrixXd matrix(2, 2);\n    initializeMatrix(matrix);\n\n    // Compute the inverse of the matrix\n    Eigen::MatrixXd inverseMatrix = computeInverse(matrix);\n\n    // Print the original and inverse matrices\n    std::cout << \"Original Matrix:\\n\" << matrix << std::endl;\n    std::cout << \"Inverse Matrix:\\n\" << inverseMatrix << std::endl;\n\n    // Example of multiplying matrices\n    Eigen::MatrixXd result = multiplyMatrices(matrix, inverseMatrix);\n    std::cout << \"Result of multiplication (should be identity matrix):\\n\" << result << std::endl;\n\n    // Example of adding matrices\n    Eigen::MatrixXd sumMatrix = addMatrices(matrix, inverseMatrix);\n    std::cout << \"Result of addition:\\n\" << sumMatrix << std::endl;\n\n    // Example of using a less common function from Eigen library\n    // Compute the determinant of the matrix using Eigen's determinant() function\n", "suffix": "\n\n    // Assertions to verify correctness\n    assert(determinant == -2.0);\n\n    // Compute the transpose of the matrix\n    Eigen::MatrixXd transposeMatrix = matrix.transpose();\n    std::cout << \"Transpose of the matrix:\\n\" << transposeMatrix << std::endl;\n\n    // Assertions to verify correctness\n    assert(transposeMatrix(0, 0) == matrix(0, 0));\n    assert(transposeMatrix(1, 0) == matrix(0, 1));\n    assert(transposeMatrix(0, 1) == matrix(1, 0));\n    assert(transposeMatrix(1, 1) == matrix(1, 1));\n\n    return 0;\n}", "golden_completion": "\n    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;\n\n", "LLM_justification": "This example focuses on the Eigen library, which is widely used for linear algebra operations but includes some less commonly used functions such as matrix determinant and transpose calculations. The code tests the LLM's understanding of these specific functions, their usage patterns, and correct parameter handling. The prefix sets up various matrix operations, while the golden completion demonstrates the correct usage of Eigen's determinant() and transpose() functions. Assertions are included in the suffix to verify the correctness of the operations and ensure the model correctly implements these uncommon but important functions in the Eigen library.", "assertions": "", "DeepSeek-R1": "    double determinant = matrix.determinant();"}
{"id": "8", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Helper function to initialize matrices\nvoid initializeMatrices(Eigen::MatrixXd& A, Eigen::MatrixXd& B) {\n    A << 1, 2, 3, 4,\n         5, 6, 7, 8,\n         9, 10, 11, 12;\n    B << 12, 11, 10, 9,\n         8, 7, 6, 5,\n         4, 3, 2, 1;\n}\n\n// Function to perform matrix multiplication and return the result\nEigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd& A, const Eigen::MatrixXd& B) {\n    assert(A.cols() == B.rows() && \"Matrix dimensions must be compatible for multiplication.\");\n    return A * B;\n}\n\n// Function to print a matrix\nvoid printMatrix(const Eigen::MatrixXd& matrix) {\n    std::cout << matrix << std::endl;\n}\n\n// Main function\nint main() {\n    Eigen::MatrixXd A(3, 4);\n    Eigen::MatrixXd B(4, 3);\n    initializeMatrices(A, B);\n    // Perform uncommon operation: matrix transpose and addition\n", "suffix": "    Eigen::MatrixXd C = multiplyMatrices(A, B);\n    printMatrix(C);\n\n    // Assertions\n    Eigen::MatrixXd expectedC(3, 3);\n    expectedC << 80, 70, 60,\n                 224, 198, 172,\n                 368, 326, 284;\n    assert(C.isApprox(expectedC) && \"Matrix multiplication result is incorrect.\");\n\n    // Clean up resources (not needed for Eigen objects as they are automatically managed)\n    return 0;\n}", "golden_completion": "\n    Eigen::MatrixXd D = A.transpose() + B;\n    printMatrix(D);\n\n    // Assertions\n    Eigen::MatrixXd expectedD(4, 3);\n    expectedD << 13, 16, 19,\n                 17, 20, 23,\n                 21, 24, 27,\n                 25, 28, 31;\n    assert(D.isApprox(expectedD) && \"Matrix transpose and addition result is incorrect.\");\n", "LLM_justification": "This test case demonstrates the use of the Eigen library for matrix operations, including an uncommon combination of matrix transpose and addition. The prefix sets up the matrices and provides utility functions for initialization, multiplication, and printing. The completion involves performing a less common operation (matrix transpose and addition) and then validating the result with assertions. This scenario tests the model's ability to recognize and correctly use Eigen's API for advanced matrix operations while ensuring that the results are accurate through assertions.", "assertions": "", "DeepSeek-R1": "Eigen::MatrixXd C = A.transpose() + B;"}
{"id": "9", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <openssl/evp.h>\n\n// Utility function to initialize OpenSSL library\nvoid initializeOpenSSL() {\n    OpenSSL_add_all_algorithms();\n    ERR_load_crypto_strings();\n}\n\n// Utility function to cleanup OpenSSL library\nvoid cleanupOpenSSL() {\n    EVP_cleanup();\n    ERR_free_strings();\n}\n\n// Function to encrypt a message using OpenSSL\nbool encryptMessage(const std::string& plaintext, std::string& ciphertext, const std::string& key) {\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        return false;\n    }\n\n    const EVP_CIPHER *cipher = EVP_aes_256_cbc();\n    if (!EVP_EncryptInit_ex(ctx, cipher, nullptr, reinterpret_cast<const unsigned char*>(key.c_str()), nullptr)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n\n    int len;\n    int ciphertext_len;\n    unsigned char ciphertext_buf[1024];\n\n    if (!EVP_EncryptUpdate(ctx, ciphertext_buf, &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.length())) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n    ciphertext_len = len;\n\n    if (!EVP_EncryptFinal_ex(ctx, ciphertext_buf + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n    ciphertext_len += len;\n\n    ciphertext.assign(reinterpret_cast<const char*>(ciphertext_buf), ciphertext_len);\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n}\n\nint main() {\n    initializeOpenSSL();\n    std::string plaintext = \"This is a secret message.\";\n    std::string key = \"01234567890123456789012345678901\"; // 256-bit key\n    std::string ciphertext;", "suffix": "\n\n    // Decryption code for validation\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    assert(ctx != nullptr);\n\n    const EVP_CIPHER *cipher = EVP_aes_256_cbc();\n    assert(EVP_DecryptInit_ex(ctx, cipher, nullptr, reinterpret_cast<const unsigned char*>(key.c_str()), nullptr));\n\n    int len;\n    int plaintext_len;\n    unsigned char plaintext_buf[1024];\n\n    assert(EVP_DecryptUpdate(ctx, plaintext_buf, &len, reinterpret_cast<const unsigned char*>(ciphertext.c_str()), ciphertext.length()));\n    plaintext_len = len;\n\n    assert(EVP_DecryptFinal_ex(ctx, plaintext_buf + len, &len));\n    plaintext_len += len;\n\n    std::string decrypted_plaintext(reinterpret_cast<const char*>(plaintext_buf), plaintext_len);\n    assert(decrypted_plaintext == plaintext);\n\n    EVP_CIPHER_CTX_free(ctx);\n    cleanupOpenSSL();\n\n    std::cout << \"Encryption and decryption successful.\" << std::endl;\n    return 0;\n}", "golden_completion": "\n    bool result = encryptMessage(plaintext, ciphertext, key);\n    assert(result);\n    assert(!ciphertext.empty());", "LLM_justification": "This test case demonstrates the usage of the OpenSSL EVP (Envelope) API for encryption and decryption of data. The EVP API is a high-level interface to cryptographic functions, which is not commonly used due to its complexity and the need for proper resource management. The example includes the initialization and cleanup of the OpenSSL library, encryption of a message, and validation through decryption. The assertions verify that the encryption was successful, the ciphertext is not empty, and the decrypted text matches the original plaintext. Proper parameter ordering and resource management are crucial for the correct usage of the API.", "assertions": "", "DeepSeek-R1": "    assert(encryptMessage(plaintext, ciphertext, key));"}
{"id": "10", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <Eigen/Dense>\n#include <cassert>\n\n// This example demonstrates the use of Eigen library for linear algebra\n// operations. Eigen is a C++ template library for linear algebra: matrices,\n// vectors, numerical solvers, and related algorithms.\n\nusing namespace Eigen;\n\n// Function to initialize a matrix with some values\nMatrixXd initializeMatrix(int rows, int cols) {\n    MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i + j;\n        }\n    }\n    return mat;\n}\n\n// Function to perform matrix multiplication using Eigen\nMatrixXd multiplyMatrices(const MatrixXd& mat1, const MatrixXd& mat2) {\n    assert(mat1.cols() == mat2.rows());\n    return mat1 * mat2;\n}\n\n// Function to perform matrix addition using Eigen\nMatrixXd addMatrices(const MatrixXd& mat1, const MatrixXd& mat2) {\n    assert(mat1.rows() == mat2.rows() && mat1.cols() == mat2.cols());\n    return mat1 + mat2;\n}\n\nint main() {\n    // Initialize two matrices\n    MatrixXd mat1 = initializeMatrix(3, 3);\n    MatrixXd mat2 = initializeMatrix(3, 3);\n\n    // Perform matrix multiplication and addition\n    MatrixXd resultMul = multiplyMatrices(mat1, mat2);\n    MatrixXd resultAdd = addMatrices(mat1, mat2);\n\n    // Print the results\n    std::cout << \"Matrix Multiplication Result:\\n\" << resultMul << std::endl;\n    std::cout << \"Matrix Addition Result:\\n\" << resultAdd << std::endl;\n\n    // Now, let's test a rare and uncommon function of Eigen: matrix decomposition\n", "suffix": "\n\n    // Validate the decomposition: A = L * U\n    MatrixXd reconstructed = L * U;\n    assert((reconstructed - mat1).norm() < 1e-9);\n\n    // Print the L and U matrices\n    std::cout << \"L matrix:\\n\" << L << std::endl;\n    std::cout << \"U matrix:\\n\" << U << std::endl;\n\n    return 0;\n}\n", "golden_completion": "    // Perform LU decomposition\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = luDecomp.matrixLU().triangularView<Lower>();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();\n\n", "LLM_justification": "This test case is a good example as it tests the model's ability to recognize and complete a rare API usage pattern involving Eigen library's LU decomposition functions. LU decomposition is not commonly used compared to basic operations like matrix multiplication and addition, and it requires a correct understanding of matrix properties and Eigen's API conventions. The completion demonstrates proper API usage, parameter ordering, and error checking using assertions to validate the correctness of the decomposition.", "assertions": "", "DeepSeek-R1": "    PartialPivLU<MatrixXd> lu(mat1);\n    MatrixXd L = lu.matrixL();\n    MatrixXd U = lu.matrixU();"}
{"id": "11", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <harfbuzz/hb.h>\n#include <harfbuzz/hb-ft.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n\nvoid initialize_harfuzz(hb_buffer_t** buffer, hb_font_t** font) {\n    FT_Library ft_library;\n    FT_Face ft_face;\n    hb_blob_t* blob;\n\n    FT_Init_FreeType(&ft_library);\n    FT_New_Face(ft_library, \"/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf\", 0, &ft_face);\n    FT_Set_Char_Size(ft_face, 0, 16 * 64, 0, 0);\n\n    *buffer = hb_buffer_create();\n    hb_buffer_set_direction(*buffer, HB_DIRECTION_LTR);\n    hb_buffer_set_script(*buffer, HB_SCRIPT_LATIN);\n    hb_buffer_set_language(*buffer, hb_language_from_string(\"en\", -1));\n\n    blob = hb_blob_create_from_file(\"/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf\");\n    *font = hb_ft_font_create(ft_face, nullptr);\n\n    hb_buffer_add_utf8(*buffer, \"Hello, HarfBuzz!\", -1, 0, -1);\n\n    hb_shape(*font, *buffer, nullptr, 0);\n\n    hb_blob_destroy(blob);\n    FT_Done_Face(ft_face);\n    FT_Done_FreeType(ft_library);\n}\n\nvoid print_glyph_info(hb_buffer_t* buffer) {\n    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n\n    for (unsigned int i = 0; i < glyph_count; i++) {\n        std::cout << \"Glyph ID: \" << glyph_info[i].codepoint << std::endl;\n    }\n}\n\nint main() {\n    hb_buffer_t* buffer = nullptr;\n    hb_font_t* font = nullptr;\n    initialize_harfuzz(&buffer, &font);\n", "suffix": "    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n\n    assert(glyph_count > 0);\n    assert(glyph_info != nullptr);\n\n    hb_buffer_destroy(buffer);\n    hb_font_destroy(font);\n\n    return 0;\n}", "golden_completion": "    print_glyph_info(buffer);\n", "LLM_justification": "This test case involves using the HarfBuzz library for text shaping, which is a complex and less commonly used library in C++. The example sets up a FreeType font and uses HarfBuzz to shape a simple string, then verifies the glyph information. This scenario tests the LLM's ability to understand and correctly use the HarfBuzz API, including creating buffers, setting directions, scripts, languages, and shaping text. The correct usage of these APIs and proper resource management are critical, making this a good test case for uncommon API usage.", "assertions": "", "DeepSeek-R1": "    print_glyph_info(buffer);"}
{"id": "12", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// This program demonstrates the use of Eigen library for scientific computing\n// We will define a helper function to initialize matrices and perform some operations.\n\nusing namespace Eigen;\n\nvoid initialize_matrices(MatrixXd &matA, MatrixXd &matB) {\n\t// Initialize matrix A (3x3)\n\tmatA << 1, 2, 3,\n\t\t\t 4, 5, 6,\n\t\t\t 7, 8, 9;\n\t// Initialize matrix B (3x3)\n\tmatB << 9, 8, 7,\n\t\t\t 6, 5, 4,\n\t\t\t 3, 2, 1;\n}\n\nMatrixXd perform_operations(const MatrixXd &matA, const MatrixXd &matB) {\n\tMatrixXd result;\n\t// Perform matrix addition\n\tresult = matA + matB;\n\treturn result;\n}\n\nint main() {\n\tMatrixXd matA(3, 3);\n\tMatrixXd matB(3, 3);\n\tinitialize_matrices(matA, matB);\n\tMatrixXd result = perform_operations(matA, matB);\n\tstd::cout << \"Result of matrix addition:\\n\" << result << std::endl;\n\n\t// Additional operations will be performed below\n", "suffix": "\n\n\t// Perform matrix multiplication\n\tMatrixXd result_mult = matA * matC;\n\tstd::cout << \"Result of matrix multiplication:\\n\" << result_mult << std::endl;\n\n\t// Assertions\n\tassert(result_mult(0, 0) == 36);\n\tassert(result_mult(1, 1) == 81);\n\tassert(result_mult(2, 2) == 126);\n\n\treturn 0;\n}\n", "golden_completion": "\tMatrixXd matC(3, 3);\n\tmatC << 2, 3, 4,\n\t\t\t 5, 6, 7,\n\t\t\t 8, 9, 10;\n\n", "LLM_justification": "This test case demonstrates the use of the Eigen library, which is less commonly used compared to standard libraries. The focus is on matrix initialization and operations such as addition and multiplication. The test case ensures the LLM can recognize and correctly complete patterns involving Eigen's matrix operations. Assertions verify the correctness of matrix multiplication results, checking specific elements in the resulting matrix. This is a good test case because it involves scientific computing with clear and uncommon API usage, making it a suitable benchmark for testing LLM capabilities in recognizing and completing advanced C++ code patterns.", "assertions": "", "DeepSeek-R1": "MatrixXd matC(3,3);\n\tmatC << 12, 0, 0,\n\t\t\t12, 9, 0,\n\t\t\t0, 6, 14;"}
{"id": "13", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <freetype2/ft2build.h>\n#include FT_FREETYPE_H\n\nclass FontRenderer {\npublic:\n    FontRenderer() : library(nullptr), face(nullptr) {}\n\n    bool initialize() {\n        FT_Error error = FT_Init_FreeType(&library);\n        if (error) {\n            std::cerr << \"Failed to initialize FreeType library.\" << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool loadFont(const char* filePath) {\n        FT_Error error = FT_New_Face(library, filePath, 0, &face);\n        if (error) {\n            std::cerr << \"Failed to load font.\" << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    void setFontSize(int pixelWidth, int pixelHeight) {\n        FT_Set_Pixel_Sizes(face, pixelWidth, pixelHeight);\n    }\n\n    FT_GlyphSlot renderGlyph(char character) {\n        FT_UInt glyphIndex = FT_Get_Char_Index(face, character);\n        FT_Error error = FT_Load_Glyph(face, glyphIndex, FT_LOAD_DEFAULT);\n        if (error) {\n            std::cerr << \"Failed to load glyph.\" << std::endl;\n            return nullptr;\n        }\n        error = FT_Render_Glyph(face->glyph, FT_RENDER_MODE_NORMAL);\n        if (error) {\n            std::cerr << \"Failed to render glyph.\" << std::endl;\n            return nullptr;\n        }\n        return face->glyph;\n    }\n\n    ~FontRenderer() {\n        if (face) {\n            FT_Done_Face(face);\n        }\n        if (library) {\n            FT_Done_FreeType(library);\n        }\n    }\n\nprivate:\n    FT_Library library;\n    FT_Face face;\n};\n\nint main() {\n    FontRenderer renderer;\n    assert(renderer.initialize() && \"FreeType library initialization failed.\");\n    assert(renderer.loadFont(\"/path/to/font.ttf\") && \"Font loading failed.\");\n    renderer.setFontSize(12, 12);\n", "suffix": "\n    std::cout << \"Glyph rendered successfully.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    FT_GlyphSlot glyph = renderer.renderGlyph('A');\n    assert(glyph != nullptr && \"Glyph rendering failed.\");\n    assert(glyph->bitmap.width > 0 && glyph->bitmap.rows > 0 && \"Rendered glyph has invalid dimensions.\");", "LLM_justification": "This example uses the FreeType library, which is commonly used for font rendering but involves a somewhat complex API. The example tests the ability to correctly initialize the FreeType library, load a font, set the font size, and render a glyph. The golden completion focuses on rendering a specific glyph and includes assertions to ensure the glyph is rendered correctly. The suffix includes additional code to verify the rendered glyph and cleanup resources. This scenario is a good test case because it involves several steps that must be done in a specific order, and the API functions used are not commonly seen in more basic text processing examples.", "assertions": "", "DeepSeek-R1": "    FT_GlyphSlot glyph = renderer.renderGlyph('A');\n    assert(glyph && \"Glyph rendering failed.\");"}
{"id": "14", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <hb.h>\n#include <hb-ft.h>\n#include <cassert>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n\nclass HarfBuzzExample {\npublic:\n    HarfBuzzExample() : ft_library(nullptr), ft_face(nullptr), hb_buffer(nullptr), hb_font(nullptr) {}\n    ~HarfBuzzExample() { cleanup(); }\n\n    void initialize() {\n        // Initialize FreeType library\n        if (FT_Init_FreeType(&ft_library)) {\n            throw std::runtime_error(\"Could not initialize FreeType library\");\n        }\n\n        // Load a font face\n        if (FT_New_Face(ft_library, \"arial.ttf\", 0, &ft_face)) {\n            throw std::runtime_error(\"Could not load font face\");\n        }\n\n        // Create a HarfBuzz buffer\n        hb_buffer = hb_buffer_create();\n        if (!hb_buffer) {\n            throw std::runtime_error(\"Could not create HarfBuzz buffer\");\n        }\n\n        // Create a HarfBuzz font\n        hb_font = hb_ft_font_create(ft_face, nullptr);\n        if (!hb_font) {\n            throw std::runtime_error(\"Could not create HarfBuzz font\");\n        }\n    }\n\n    void shapeText(const char* text) {\n        // Set the text to shape\n        hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);\n        hb_buffer_guess_segment_properties(hb_buffer);\n    }\n\n    void cleanup() {\n        if (hb_font) {\n            hb_font_destroy(hb_font);\n            hb_font = nullptr;\n        }\n        if (hb_buffer) {\n            hb_buffer_destroy(hb_buffer);\n            hb_buffer = nullptr;\n        }\n        if (ft_face) {\n            FT_Done_Face(ft_face);\n            ft_face = nullptr;\n        }\n        if (ft_library) {\n            FT_Done_FreeType(ft_library);\n            ft_library = nullptr;\n        }\n    }\n\n    hb_buffer_t* getBuffer() const { return hb_buffer; }\n\nprivate:\n    FT_Library ft_library;\n    FT_Face ft_face;\n    hb_buffer_t* hb_buffer;\n    hb_font_t* hb_font;\n};\n\nint main() {\n    HarfBuzzExample example;\n    example.initialize();\n    example.shapeText(\"Hello, world!\");\n", "suffix": "    hb_buffer_t* buffer = example.getBuffer();\n    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n    hb_glyph_position_t* glyph_pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);\n\n    // Assertions to verify the shaping results\n    assert(glyph_count > 0);\n    for (unsigned int i = 0; i < glyph_count; ++i) {\n        assert(glyph_info[i].codepoint != 0);\n        assert(glyph_pos[i].x_advance != 0 || glyph_pos[i].y_advance != 0);\n    }\n\n    // Cleanup and exit\n    example.cleanup();\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    hb_shape(example.getBuffer(), example.getFont(), nullptr, 0);\n", "LLM_justification": "This test case uses the HarfBuzz library to demonstrate text shaping with FreeType fonts, which is a less common but powerful API for text processing. The example includes initialization, text shaping, and cleanup, ensuring proper resource management. The golden completion involves the `hb_shape` function, which is crucial for text shaping but less commonly known. The suffix includes assertions to verify the behavior of the `hb_shape` function, ensuring the glyph information and positions are correctly populated. This scenario tests the model's ability to recognize and complete uncommon API usage patterns, manage resources, and verify API behavior through assertions.", "assertions": "", "DeepSeek-R1": "    hb_shape(example.hb_font, example.getBuffer(), NULL, 0);"}
{"id": "15", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n\n// Utility functions to handle deprecated APIs\nvoid deprecated_fopen_example(const char* filename, const char* mode) {\n    FILE* file = fopen(filename, mode);\n    if (file) {\n        std::cout << \"File opened successfully\" << std::endl;\n        fclose(file);\n    } else {\n        std::cerr << \"Failed to open file\" << std::endl;\n    }\n}\n\nclass LegacyFileHandler {\npublic:\n    LegacyFileHandler(const char* filename, const char* mode) {\n        file_ = fopen(filename, mode);\n        if (!file_) {\n            throw std::runtime_error(\"Failed to open file\");\n        }\n    }\n\n    ~LegacyFileHandler() {\n        if (file_) {\n            fclose(file_);\n        }\n    }\n\n    void write(const char* data) {\n        if (file_) {\n            fwrite(data, sizeof(char), strlen(data), file_);\n        }\n    }\n\n    void read(char* buffer, size_t size) {\n        if (file_) {\n            fread(buffer, sizeof(char), size, file_);\n        }\n    }\n\nprivate:\n    FILE* file_;\n};\n\nint main() {\n    const char* filename = \"test.txt\";\n    const char* write_data = \"Hello, World!\";\n    char read_buffer[50] = {0};\n    try {\n", "suffix": "    } catch (const std::exception& ex) {\n        std::cerr << \"Exception: \" << ex.what() << std::endl;\n        return 1;\n    }\n\n    // Assertions to verify correct behavior\n    FILE* file = fopen(filename, \"r\");\n    assert(file != nullptr);\n    fread(read_buffer, sizeof(char), strlen(write_data), file);\n    assert(strcmp(read_buffer, write_data) == 0);\n    fclose(file);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "        LegacyFileHandler handler(filename, \"w+\");\n        handler.write(write_data);\n        handler.read(read_buffer, sizeof(read_buffer));\n        assert(strcmp(read_buffer, write_data) == 0);\n", "LLM_justification": "This test case is a good example because it involves deprecated file handling APIs (`fopen`, `fwrite`, `fread`, `fclose`) and demonstrates how to correctly use these APIs within the context of a C++ class. The completion requires the model to recognize the pattern of file operations and use the correct sequence of function calls, parameter ordering, and error handling. The assertions verify that the file operations were performed correctly, ensuring the integrity of the data written and read from the file. This tests the model's ability to understand and complete deprecated API usage patterns, which are still relevant in maintaining legacy codebases.", "assertions": "", "DeepSeek-R1": "        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);"}
{"id": "16", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n/*\n * This example demonstrates the usage of the Eigen library, specifically dealing with SVD (Singular Value Decomposition) and solving systems of linear equations.\n * Eigen is a C++ template library for linear algebra.\n */\n\nvoid printMatrix(const Eigen::MatrixXd &matrix) {\n    for (int i = 0; i < matrix.rows(); ++i) {\n        for (int j = 0; j < matrix.cols(); ++j) {\n            std::cout << matrix(i, j) << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    // Define a 3x3 matrix\n    Eigen::MatrixXd A(3, 3);\n    A << 1, 2, 3,\n         4, 5, 6,\n         7, 8, 9;\n\n    // Define a 3x1 vector\n    Eigen::VectorXd b(3);\n    b << 1,\n         0,\n         1;\n\n    // Print matrix A\n    std::cout << \"Matrix A:\" << std::endl;\n    printMatrix(A);\n\n    // Print vector b\n    std::cout << \"Vector b:\" << std::endl;\n    for (int i = 0; i < b.size(); ++i) {\n        std::cout << b(i) << std::endl;\n    }\n\n    // Compute the SVD of matrix A\n    Eigen::JacobiSVD<Eigen::MatrixXd> svd(A, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values of A:\" << std::endl;\n    std::cout << svd.singularValues() << std::endl;\n\n    // The SVD solves the system Ax = b\n    Eigen::VectorXd x;\n", "suffix": "\n    std::cout << \"Solution x:\" << std::endl;\n    for (int i = 0; i < x.size(); ++i) {\n        std::cout << x(i) << std::endl;\n    }\n\n    // Assertions to ensure correctness\n    Eigen::VectorXd b_reconstructed = A * x;\n    assert((b - b_reconstructed).norm() < 1e-6);\n    assert(svd.rank() == 2);\n    assert(svd.singularValues()(0) > svd.singularValues()(1));\n\n    return 0;\n}\n", "golden_completion": "    x = svd.solve(b);\n", "LLM_justification": "This test case demonstrates the usage of the Eigen library for linear algebra, specifically focusing on Singular Value Decomposition (SVD) and solving a system of linear equations. The example sets up a matrix and a vector, computes the SVD, and solves the system. Assertions are included to verify the correctness of the solution, ensuring that the reconstructed vector matches the original vector, the rank is correctly identified, and the singular values are in descending order. This tests the model's ability to handle a less commonly used library (Eigen) and correctly utilize its API for advanced mathematical operations.", "assertions": "", "DeepSeek-R1": "    x = svd.solve(b);"}
{"id": "17", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <stdexcept>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <cassert>\n\nclass AESCipher {\npublic:\n    AESCipher() : ctx(EVP_CIPHER_CTX_new()) {\n        if (!ctx) {\n            throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n        }\n    }\n\n    ~AESCipher() {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n\n    void encrypt(const unsigned char *plaintext, int plaintext_len, const unsigned char *key, const unsigned char *iv, unsigned char *ciphertext) {\n        int len;\n        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv)) {\n            throw std::runtime_error(\"Failed to initialize encryption\");\n        }\n        if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {\n            throw std::runtime_error(\"Failed to encrypt data\");\n        }\n        ciphertext_len = len;\n    }\n\n    int get_ciphertext_len() const {\n        return ciphertext_len;\n    }\n\nprivate:\n    EVP_CIPHER_CTX *ctx;\n    int ciphertext_len;\n};\n\nint main() {\n    AESCipher cipher;\n    unsigned char key[32];\n    unsigned char iv[16];\n    unsigned char plaintext[] = \"This is a test.\";\n    unsigned char ciphertext[128];\n\n    if (!RAND_bytes(key, sizeof(key)) || !RAND_bytes(iv, sizeof(iv))) {\n        std::cerr << \"Failed to generate key/iv\" << std::endl;\n        return 1;\n    }\n\n    try {\n", "suffix": "\n        int len;\n        if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {\n            throw std::runtime_error(\"Failed to finalize encryption\");\n        }\n        ciphertext_len += len;\n\n        // Verify the length of the ciphertext\n        assert(cipher.get_ciphertext_len() > 0);\n        std::cout << \"Ciphertext length: \" << cipher.get_ciphertext_len() << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n", "golden_completion": "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving the OpenSSL EVP encryption API, which is uncommon and complex. The golden completion properly integrates the AES encryption process using the OpenSSL library. The prefix sets up the context with key and IV generation, and the suffix includes the finalization of encryption and assertions to verify the ciphertext length. This scenario effectively tests the LLM's understanding of correct parameter ordering, error handling, and resource management within the OpenSSL API.", "assertions": "", "DeepSeek-R1": "        cipher.encrypt(plaintext, sizeof(plaintext), key, iv, ciphertext);\n        int len = cipher.get_ciphertext_len();"}
{"id": "18", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <unicode/unistr.h>\n#include <unicode/ustream.h>\n#include <unicode/ucnv.h>\n\n// Utility function to convert UTF-8 string to ICU UnicodeString\nUnicodeString utf8ToUnicodeString(const std::string& utf8) {\n    UnicodeString ustr;\n    ustr = UnicodeString::fromUTF8(StringPiece(utf8.c_str()));\n    return ustr;\n}\n\n// Utility function to convert ICU UnicodeString to UTF-8 string\nstd::string unicodeStringToUtf8(const UnicodeString& ustr) {\n    std::string utf8;\n    ustr.toUTF8String(utf8);\n    return utf8;\n}\n\nint main() {\n    std::string utf8Text = \"Hello, world!\";\n    UnicodeString unicodeText = utf8ToUnicodeString(utf8Text);\n\n    // Pre-completion code\n    // Here we should convert the unicodeText to UTF-16 using ICU library\n\n", "suffix": "\n    // Assertions to validate the conversion\n    assert(unicodeText.length() == 13);\n    assert(unicodeStringToUtf8(unicodeText) == utf8Text);\n\n    // Clean up resources\n    // No explicit cleanup needed for ICU UnicodeString\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    std::string utf16Text;\n    UErrorCode status = U_ZERO_ERROR;\n    int32_t utf16Length = unicodeText.extract(0, unicodeText.length(), (UChar*)nullptr, 0, status);\n    std::u16string utf16Str(utf16Length, 0);\n    unicodeText.extract(0, unicodeText.length(), reinterpret_cast<UChar*>(&utf16Str[0]), utf16Length, status);\n    utf16Text.assign(utf16Str.begin(), utf16Str.end());\n", "LLM_justification": "This test case demonstrates the use of the ICU library for converting between UTF-8 and UTF-16 encodings, which is a less common API usage. The prefix sets up the context with utility functions and initial conversion from UTF-8 to UnicodeString. The golden completion performs the conversion from UnicodeString to UTF-16 string using ICU functions, handling the UErrorCode appropriately. The suffix contains assertions to verify the conversion and ensures that all resources are cleaned up properly. This scenario tests the LLM's ability to recognize and correctly use rare APIs, handle character encoding conversions, and maintain proper resource management.", "assertions": "", "DeepSeek-R1": "UChar* utf16Buffer = unicodeText.getBuffer();"}
{"id": "19", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\nvoid handleErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nint main() {\n    // Initialize OpenSSL\n    ERR_load_crypto_strings();\n    OpenSSL_add_all_algorithms();\n    OPENSSL_config(NULL);\n\n    // Input data to be hashed\n    const char *message = \"The quick brown fox jumps over the lazy dog\";\n    unsigned char md_value[EVP_MAX_MD_SIZE];\n    unsigned int md_len;\n\n    // Create a message digest context\n    EVP_MD_CTX *mdctx;\n    mdctx = EVP_MD_CTX_new();\n    if(mdctx == NULL) handleErrors();\n\n    // Initialize the context for MD5\n    if(1 != EVP_DigestInit_ex(mdctx, EVP_md5(), NULL)) handleErrors();\n\n    // Provide the message to be hashed\n    if(1 != EVP_DigestUpdate(mdctx, message, strlen(message))) handleErrors();\n", "suffix": "\n\n    // Verify the length of the hash\n    assert(md_len == 16); // MD5 hash length is always 16 bytes\n\n    // Clean up\n    EVP_MD_CTX_free(mdctx);\n    EVP_cleanup();\n    ERR_free_strings();\n\n    std::cout << \"Hash computed successfully.\" << std::endl;\n\n    return 0;\n}", "golden_completion": "    // Finalize the digest\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "LLM_justification": "This test case demonstrates the usage of the OpenSSL EVP API to compute an MD5 hash, which is a less common and somewhat deprecated practice due to security concerns. The test involves initializing the digest context, updating it with data, and finalizing the hash computation. The completion is required to finalize the digest correctly, ensuring proper API usage. The suffix then includes assertions to verify the correct length of the MD5 hash and handles resource cleanup. This scenario tests the LLM's ability to recognize and complete the uncommon API pattern correctly and manage resources properly.", "assertions": "", "DeepSeek-R1": "    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();"}
{"id": "20", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\n\nclass OpenGLContext {\npublic:\n\tOpenGLContext(int width, int height) : width(width), height(height) {\n\t\tif (!glfwInit()) {\n\t\t\tthrow std::runtime_error(\"Failed to initialize GLFW\");\n\t\t}\n\t\twindow = glfwCreateWindow(width, height, \"OpenGL Window\", nullptr, nullptr);\n\t\tif (!window) {\n\t\t\tglfwTerminate();\n\t\t\tthrow std::runtime_error(\"Failed to create GLFW window\");\n\t\t}\n\t\tglfwMakeContextCurrent(window);\n\t\tif (glewInit() != GLEW_OK) {\n\t\t\tthrow std::runtime_error(\"Failed to initialize GLEW\");\n\t\t}\n\t}\n\n\t~OpenGLContext() {\n\t\tif (window) {\n\t\t\tglfwDestroyWindow(window);\n\t\t\twindow = nullptr;\n\t\t}\n\t\tglfwTerminate();\n\t}\n\n\tvoid render() {\n\t\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\t\t// render something\n\t\tglfwSwapBuffers(window);\n\t\tglfwPollEvents();\n\t}\n\n\tbool shouldClose() const {\n\t\treturn glfwWindowShouldClose(window);\n\t}\n\nprivate:\n\tGLFWwindow* window;\n\tint width, height;\n};\n\nint main() {\n\ttry {\n\t\tOpenGLContext context(800, 600);\n\t\twhile (!context.shouldClose()) {\n\t\t\tcontext.render();\n\n\t\t\t", "suffix": "            glEnable(GL_BLEND);\n\t\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n\t\t\tassert(glIsEnabled(GL_BLEND));\n\t\t}\n\t} catch (const std::exception& e) {\n\t\tstd::cerr << e.what() << std::endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "golden_completion": "            glDisable(GL_DEPTH_TEST);\n\t\t\tassert(!glIsEnabled(GL_DEPTH_TEST));\n\n", "LLM_justification": "This example tests the ability to recognize and correctly use uncommon OpenGL functions. It involves enabling and disabling specific OpenGL capabilities, which are less commonly used but still important. The test verifies that the model can correctly handle OpenGL state changes and validate them with assertions, ensuring proper API usage.", "assertions": "", "DeepSeek-R1": "glEnable(GL_BLEND);\n\t\t\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);"}
{"id": "21", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <harfbuzz/hb.h>\n#include <harfbuzz/hb-ft.h>\n#include <cassert>\n\n// Helper function to create a font face\nFT_Face createFontFace(const char* fontPath) {\n    FT_Library library;\n    FT_Face face;\n    if (FT_Init_FreeType(&library)) {\n        std::cerr << \"Could not initialize FreeType library.\" << std::endl;\n        exit(1);\n    }\n    if (FT_New_Face(library, fontPath, 0, &face)) {\n        std::cerr << \"Could not create font face.\" << std::endl;\n        exit(1);\n    }\n    return face;\n}\n\n// Helper function to create a HarfBuzz font\nhb_font_t* createHarfBuzzFont(FT_Face face) {\n    hb_font_t* hbFont = hb_ft_font_create(face, nullptr);\n    if (!hbFont) {\n        std::cerr << \"Could not create HarfBuzz font.\" << std::endl;\n        exit(1);\n    }\n    return hbFont;\n}\n\n// Main function demonstrating HarfBuzz usage\nint main() {\n    const char* fontPath = \"/path/to/font.ttf\";\n    FT_Face face = createFontFace(fontPath);\n    hb_font_t* hbFont = createHarfBuzzFont(face);\n\n    // Create a buffer for HarfBuzz\n    hb_buffer_t* hbBuffer = hb_buffer_create();\n    assert(hbBuffer != nullptr);\n\n    // Set the text to be shaped\n    const char* text = \"Hello, HarfBuzz!\";\n    hb_buffer_add_utf8(hbBuffer, text, -1, 0, -1);\n", "suffix": "    // Set buffer properties\n    hb_buffer_guess_segment_properties(hbBuffer);\n\n    // Shape the text\n    hb_shape(hbFont, hbBuffer, nullptr, 0);\n\n    // Get glyph information\n    unsigned int glyphCount;\n    hb_glyph_info_t* glyphInfo = hb_buffer_get_glyph_infos(hbBuffer, &glyphCount);\n    hb_glyph_position_t* glyphPos = hb_buffer_get_glyph_positions(hbBuffer, &glyphCount);\n    assert(glyphInfo != nullptr);\n    assert(glyphPos != nullptr);\n\n    // Verify the number of glyphs\n    assert(glyphCount > 0);\n\n    // Cleanup resources\n    hb_buffer_destroy(hbBuffer);\n    hb_font_destroy(hbFont);\n    FT_Done_Face(face);\n    FT_Done_FreeType(library);\n\n    return 0;\n}\n", "golden_completion": "    hb_buffer_set_direction(hbBuffer, HB_DIRECTION_LTR);\n    hb_buffer_set_script(hbBuffer, HB_SCRIPT_LATIN);\n    hb_buffer_set_language(hbBuffer, hb_language_from_string(\"en\", -1));\n", "LLM_justification": "This test case demonstrates the usage of the HarfBuzz library for text shaping, which is a relatively uncommon API. The scenario includes creating a font face with FreeType, setting up a HarfBuzz font, creating a buffer, adding text to the buffer, configuring the buffer properties, shaping the text, and verifying the results with assertions. The example ensures the model understands the correct sequence of operations and the proper use of HarfBuzz functions, including setting direction, script, and language for the buffer. The assertions verify the correctness of each step, making it a comprehensive test of the model's capability to handle uncommon text processing APIs.", "assertions": "", "DeepSeek-R1": "    hb_buffer_guess_segment_properties(hbBuffer);"}
{"id": "22", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Helper function to print a matrix\nvoid printMatrix(const Eigen::MatrixXd &mat) {\n    std::cout << mat << std::endl;\n}\n\n// Utility function to initialize a matrix\nEigen::MatrixXd initializeMatrix(int rows, int cols) {\n    Eigen::MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i * cols + j;\n        }\n    }\n    return mat;\n}\n\n// Function to perform matrix operations\nvoid performMatrixOperations() {\n    // Initialize two matrices\n    Eigen::MatrixXd matA = initializeMatrix(3, 3);\n    Eigen::MatrixXd matB = initializeMatrix(3, 3);\n\n    // Print the matrices\n    std::cout << \"Matrix A:\" << std::endl;\n    printMatrix(matA);\n    std::cout << \"Matrix B:\" << std::endl;\n    printMatrix(matB);\n\n    // Perform matrix addition\n    Eigen::MatrixXd matC = matA + matB;\n    std::cout << \"Matrix C (A + B):\" << std::endl;\n    printMatrix(matC);\n\n    // Perform matrix multiplication\n    Eigen::MatrixXd matD = matA * matB;\n    std::cout << \"Matrix D (A * B):\" << std::endl;\n    printMatrix(matD);\n\n    // Check the determinant of a matrix\n    double detA = matA.determinant();\n    std::cout << \"Determinant of Matrix A: \" << detA << std::endl;\n\n    // Check the inverse of a matrix if it's invertible\n    if (detA != 0) {\n        Eigen::MatrixXd matAInv = matA.inverse();\n        std::cout << \"Inverse of Matrix A:\" << std::endl;\n        printMatrix(matAInv);\n    }\n    // Perform matrix rotation (This is where the golden_completion will be inserted)\n", "suffix": "\n    // Verify the rotation matrix\n    Eigen::MatrixXd expectedRotation(2, 2);\n    expectedRotation << 0, -1, 1, 0;\n    assert((rotationMatrix - expectedRotation).norm() < 1e-9);\n\n    // Perform another operation\n    Eigen::MatrixXd matE = matA.block<2, 2>(0, 0) * rotationMatrix;\n    std::cout << \"Matrix E (submatrix of A * rotation):\" << std::endl;\n    printMatrix(matE);\n\n    // Final assertions to ensure correctness\n    Eigen::MatrixXd expectedMatE(2, 2);\n    expectedMatE << 1, 0, 4, 3;\n    assert((matE - expectedMatE).norm() < 1e-9);\n}\n\nint main() {\n    performMatrixOperations();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    // Create a 2D rotation matrix for 90 degrees\n    double angle = M_PI / 2; // 90 degrees in radians\n    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << cos(angle), -sin(angle), sin(angle), cos(angle);\n    std::cout << \"Rotation Matrix (90 degrees):\" << std::endl;\n    printMatrix(rotationMatrix);\n", "LLM_justification": "This example is a good test case because it demonstrates the use of the Eigen library for matrix operations, including some uncommon functions such as creating a 2D rotation matrix. The test involves initializing matrices, performing basic operations (addition and multiplication), and checking matrix properties (determinant and inverse). The completion focuses on creating a specific type of matrix (rotation matrix), which is a less common but important operation in linear algebra and graphics programming. The assertions verify the correctness of the rotation matrix and subsequent calculations, ensuring the model understands the API's functionality and parameter conventions.", "assertions": "", "DeepSeek-R1": "    Eigen::MatrixXd rotationMatrix(2, 2);\n    rotationMatrix << 0, -1, 1, 0;"}
{"id": "23", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Define a matrix multiplication function\nEigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd &mat1, const Eigen::MatrixXd &mat2) {\n    if (mat1.cols() != mat2.rows()) {\n        throw std::invalid_argument(\"Matrix dimensions are not compatible for multiplication\");\n    }\n    return mat1 * mat2;\n}\n\n// Helper function to print matrices\nvoid printMatrix(const Eigen::MatrixXd &matrix) {\n    for (int i = 0; i < matrix.rows(); ++i) {\n        for (int j = 0; j < matrix.cols(); ++j) {\n            std::cout << matrix(i, j) << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    // Define two matrices\n    Eigen::MatrixXd mat1(2, 3);\n    mat1 << 1, 2, 3,\n            4, 5, 6;\n\n    Eigen::MatrixXd mat2(3, 2);\n    mat2 << 7, 8,\n            9, 10,\n            11, 12;\n\n    // Perform matrix multiplication\n    Eigen::MatrixXd result = multiplyMatrices(mat1, mat2);\n\n    // Print the result\n    std::cout << \"Result of matrix multiplication:\" << std::endl;\n    printMatrix(result);\n\n    // Expected result:\n    // 58 64\n    // 139 154\n    \n    // Assert the result\n    Eigen::MatrixXd expectedResult(2, 2);\n    expectedResult << 58, 64,\n                      139, 154;\n    assert(result == expectedResult);\n\n    // Modify the result matrix for further processing\n    result(0, 0) = 0;\n    result(1, 1) = 0;\n\n    // Perform matrix addition with identity matrix\n    Eigen::MatrixXd identity = Eigen::MatrixXd::Identity(2, 2);\n", "suffix": "\n\n    // Print the modified result\n    std::cout << \"Modified result after addition with identity matrix:\" << std::endl;\n    printMatrix(modifiedResult);\n\n    // Expected modified result:\n    // 1 64\n    // 139 1\n    \n    // Assert the modified result\n    Eigen::MatrixXd expectedModifiedResult(2, 2);\n    expectedModifiedResult << 1, 64,\n                              139, 1;\n    assert(modifiedResult == expectedModifiedResult);\n\n    return 0;\n}", "golden_completion": "    Eigen::MatrixXd modifiedResult = result + identity;\n\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a matrix manipulation scenario using the Eigen library, which is an uncommon but powerful library for linear algebra in C++. The prefix includes the setup of matrices and a multiplication function, while the golden completion involves adding an identity matrix to the result and verifying the outcome. The test case ensures that the LLM can follow the correct API usage pattern, handle matrix operations, and maintain proper parameter ordering and usage conventions.", "assertions": "", "DeepSeek-R1": "    Eigen::MatrixXd modifiedResult = result + identity;"}
{"id": "24", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <freetype/freetype.h>\n\nclass FontManager {\npublic:\n\tFontManager() : library(nullptr), face(nullptr) {}\n\t~FontManager() { cleanup(); }\n\n\tbool initialize() {\n\t\tFT_Error error = FT_Init_FreeType(&library);\n\t\tif (error) {\n\t\t\tstd::cerr << \"Failed to initialize FreeType library\" << std::endl;\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool loadFont(const char* filepath) {\n\t\tFT_Error error = FT_New_Face(library, filepath, 0, &face);\n\t\tif (error) {\n\t\t\tstd::cerr << \"Failed to load font face\" << std::endl;\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid cleanup() {\n\t\tif (face) {\n\t\t\tFT_Done_Face(face);\n\t\t\tface = nullptr;\n\t\t}\n\t\tif (library) {\n\t\t\tFT_Done_FreeType(library);\n\t\t\tlibrary = nullptr;\n\t\t}\n\t}\n\n\tFT_Library getLibrary() const { return library; }\n\tFT_Face getFace() const { return face; }\n\nprivate:\n\tFT_Library library;\n\tFT_Face face;\n};\n\nvoid renderText(FontManager& fontManager, const char* text) {\n\tFT_Face face = fontManager.getFace();\n\tif (!face) {\n\t\tstd::cerr << \"Font face is not loaded\" << std::endl;\n\t\treturn;\n\t}\n\t// Set the character size\n\tFT_Error error = FT_Set_Char_Size(face, 0, 16 * 64, 300, 300);\n\tif (error) {\n\t\tstd::cerr << \"Failed to set character size\" << std::endl;\n\t\treturn;\n\t}\n\t// Load the glyph for each character\n\tfor (const char* p = text; *p; p++) {\n\t\tFT_UInt glyph_index = FT_Get_Char_Index(face, *p);\n\t\tFT_Error error = FT_Load_Glyph(face, glyph_index, FT_LOAD_DEFAULT);\n\t\tif (error) {\n\t\t\tstd::cerr << \"Failed to load glyph for character \" << *p << std::endl;\n\t\t\tcontinue;\n\t\t}\n\t\t// Render the glyph\n\t\tFT_GlyphSlot slot = face->glyph;\n\t\tFT_Render_Glyph(slot, FT_RENDER_MODE_NORMAL);\n\t\t// Access the bitmap\n\t\tFT_Bitmap bitmap = slot->bitmap;\n\t\t// Print the bitmap's dimensions\n\t\tstd::cout << \"Character: \" << *p << \" Width: \" << bitmap.width << \" Height: \" << bitmap.rows << std::endl;\n\t}\n}\n\nint main() {\n\tFontManager fontManager;\n\tassert(fontManager.initialize());\n\tassert(fontManager.loadFont(\"/path/to/font.ttf\"));\n\trenderText(fontManager, \"Hello, FreeType!\");\n\t// Test edge case: Load an invalid font file\n", "suffix": "\t// Clean up resources\n\tfontManager.cleanup();\n\treturn 0;\n}\n", "golden_completion": "\tassert(!fontManager.loadFont(\"/invalid/path/to/font.ttf\"));\n", "LLM_justification": "This test case evaluates the model's ability to recognize and correctly utilize the FreeType library, specifically focusing on initializing the library, loading a font, setting character size, loading glyphs, and rendering text. It also includes an edge case to test the loading of an invalid font file. The example ensures proper resource management and cleanup, and the assertions verify the correct initialization and font loading behavior.", "assertions": "", "DeepSeek-R1": "\tassert(!fontManager.loadFont(\"invalid_font.ttf\"));"}
{"id": "25", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Function to compute the cross product of two vectors using Eigen library\nEigen::Vector3d computeCrossProduct(const Eigen::Vector3d& vec1, const Eigen::Vector3d& vec2) {\n    // Uncommon usage of Eigen's cross product function\n    return vec1.cross(vec2);\n}\n\n// Function to compute the dot product of two vectors using Eigen library\nEigen::Vector3d computeDotProduct(const Eigen::Vector3d& vec1, const Eigen::Vector3d& vec2) {\n    // Uncommon usage of Eigen's dot product function\n    return vec1.dot(vec2);\n}\n\nint main() {\n    // Initialize vectors\n    Eigen::Vector3d vec1(1.0, 2.0, 3.0);\n    Eigen::Vector3d vec2(4.0, 5.0, 6.0);\n\n    // Compute the cross product\n    Eigen::Vector3d crossProduct = computeCrossProduct(vec1, vec2);\n\n    // Assertions to verify cross product\n    assert(crossProduct(0) == -3.0);\n    assert(crossProduct(1) == 6.0);\n    assert(crossProduct(2) == -3.0);\n\n    // Compute the dot product\n", "suffix": "    // Assertions to verify dot product\n    assert(dotProduct == 32.0);\n\n    // Additional computations\n    Eigen::Vector3d sum = vec1 + vec2;\n    Eigen::Vector3d difference = vec1 - vec2;\n\n    // Assertions for additional computations\n    assert(sum(0) == 5.0);\n    assert(sum(1) == 7.0);\n    assert(sum(2) == 9.0);\n\n    assert(difference(0) == -3.0);\n    assert(difference(1) == -3.0);\n    assert(difference(2) == -3.0);\n\n    // Cleanup and end of main\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "\n    Eigen::Vector3d dotProduct = computeDotProduct(vec1, vec2);\n", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use uncommon functions from the Eigen library, specifically for vector operations like dot and cross products. The pattern established involves computing and verifying vector operations with assert statements. The uncommon usage of Eigen's dot product function in the context of this example makes it a good test case for evaluating the LLM's understanding of less frequently used library functions.", "assertions": "", "DeepSeek-R1": "    double dotProduct = vec1.dot(vec2);"}
{"id": "26", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <cassert>\n\nvoid handleErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nstd::string generateKey() {\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    if (!RAND_bytes(key, sizeof(key))) {\n        handleErrors();\n    }\n    return std::string(reinterpret_cast<char*>(key), sizeof(key));\n}\n\nstd::string encrypt(const std::string &plaintext, const std::string &key) {\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) handleErrors();\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL))\n        handleErrors();\n\n    unsigned char ciphertext[plaintext.size() + EVP_MAX_BLOCK_LENGTH];\n    int len;\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.size()))\n        handleErrors();\n\n    int ciphertext_len = len;\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len))\n        handleErrors();\n    ciphertext_len += len;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return std::string(reinterpret_cast<char*>(ciphertext), ciphertext_len);\n}\n\nstd::string decrypt(const std::string &ciphertext, const std::string &key) {\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) handleErrors();\n    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL))\n        handleErrors();\n\n    unsigned char plaintext[ciphertext.size()];\n    int len;\n    if (1 != EVP_DecryptUpdate(ctx, plaintext, &len, reinterpret_cast<const unsigned char*>(ciphertext.c_str()), ciphertext.size()))\n        handleErrors();\n\n    int plaintext_len = len;\n    if (1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len))\n        handleErrors();\n    plaintext_len += len;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return std::string(reinterpret_cast<char*>(plaintext), plaintext_len);\n}\n\nint main() {\n    std::string key = generateKey();\n    std::string plaintext = \"Hello, world!\";\n    std::string ciphertext = encrypt(plaintext, key);", "suffix": "\n\n    assert(plaintext == decryptedtext);\n    assert(!ciphertext.empty());\n    assert(!key.empty());\n\n    std::cout << \"Original text: \" << plaintext << std::endl;\n    std::cout << \"Decrypted text: \" << decryptedtext << std::endl;\n\n    return 0;\n}", "golden_completion": "\n    std::string decryptedtext = decrypt(ciphertext, key);", "LLM_justification": "This test case uses the OpenSSL library for encryption and decryption, which is a less common but powerful API. The example demonstrates key generation, encryption, and decryption using AES-256-CBC. The pattern includes proper initialization, usage, and cleanup of OpenSSL contexts. Assertions ensure that the decrypted text matches the original plaintext, and that the key and ciphertext are not empty. This scenario tests the LLM's ability to handle complex cryptographic operations and manage resources correctly.", "assertions": "", "DeepSeek-R1": "    std::string decryptedtext = decrypt(ciphertext, key);"}
{"id": "27", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <openssl/evp.h>\n\nclass CryptoUtil {\npublic:\n    static std::string encrypt(const std::string &plaintext, const std::string &key) {\n        EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n        if (!ctx) throw std::runtime_error(\"Failed to create context\");\n\n        const EVP_CIPHER *cipher = EVP_aes_256_cbc();\n        if (!cipher) {\n            EVP_CIPHER_CTX_free(ctx);\n            throw std::runtime_error(\"Failed to get cipher\");\n        }\n\n        if (EVP_EncryptInit_ex(ctx, cipher, NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL) != 1) {\n            EVP_CIPHER_CTX_free(ctx);\n            throw std::runtime_error(\"Failed to initialize encryption\");\n        }\n\n        std::string ciphertext;\n        ciphertext.resize(plaintext.size() + EVP_CIPHER_block_size(cipher));\n        int len;\n\n        if (EVP_EncryptUpdate(ctx, reinterpret_cast<unsigned char*>(&ciphertext[0]), &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.size()) != 1) {\n            EVP_CIPHER_CTX_free(ctx);\n            throw std::runtime_error(\"Failed to encrypt\");\n        }\n\n        int ciphertext_len = len;\n\n        if (EVP_EncryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(&ciphertext[0]) + len, &len) != 1) {\n            EVP_CIPHER_CTX_free(ctx);\n            throw std::runtime_error(\"Failed to finalize encryption\");\n        }\n        ciphertext_len += len;\n        ciphertext.resize(ciphertext_len);\n\n        EVP_CIPHER_CTX_free(ctx);\n\n        return ciphertext;\n    }\n};\n\nint main() {\n    std::string key = \"01234567890123456789012345678901\"; // 32 bytes for AES-256\n    std::string plaintext = \"Hello, World!\";\n", "suffix": "\n    assert(!ciphertext.empty());\n    assert(ciphertext != plaintext);\n    std::cout << \"Encryption successful, ciphertext size: \" << ciphertext.size() << std::endl;\n\n    // Clean up resources if any\n    return 0;\n}", "golden_completion": "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);\n", "LLM_justification": "This test case demonstrates the use of the OpenSSL library for AES-256 encryption, which is not a common API for basic C++ programming. It involves setting up encryption context, initializing encryption, performing the encryption operation, and then finalizing it. The test case checks if the model can correctly complete the encryption process and handle errors appropriately. Assertions are included to verify that the ciphertext is not empty and differs from the plaintext, ensuring the encryption process was successful.", "assertions": "", "DeepSeek-R1": "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);"}
{"id": "28", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <armadillo>\n#include <cassert>\n\n// Use the Armadillo library for linear algebra\n// This example demonstrates using the uncommon solve function with sparse matrices\n\n// Helper function to create a sparse matrix\narma::sp_mat createSparseMatrix(int rows, int cols) {\n    arma::sp_mat mat(rows, cols);\n    mat(0, 0) = 1.0;\n    mat(1, 1) = 2.0;\n    mat(2, 2) = 3.0;\n    mat(3, 3) = 4.0;\n    mat(4, 4) = 5.0;\n    return mat;\n}\n\n// Helper function to create a dense vector\narma::vec createDenseVector(int size) {\n    arma::vec vec(size);\n    vec(0) = 1.0;\n    vec(1) = 2.0;\n    vec(2) = 3.0;\n    vec(3) = 4.0;\n    vec(4) = 5.0;\n    return vec;\n}\n\nint main() {\n    arma::sp_mat A = createSparseMatrix(5, 5);\n    arma::vec b = createDenseVector(5);\n    arma::vec x;\n\n    // Solve the system A * x = b using sparse matrix solve function\n    // Note: The sparse matrix solve function is less commonly used\n    // compared to dense matrix solve functions\n    try {\n", "suffix": "        // Verify the solution by checking if A * x is approximately equal to b\n        arma::vec result = A * x;\n        for (size_t i = 0; i < b.size(); ++i) {\n            assert(std::abs(result[i] - b[i]) < 1e-5);\n        }\n    } catch (std::runtime_error &e) {\n        std::cerr << \"Runtime error: \" << e.what() << std::endl;\n    }\n\n    std::cout << \"All assertions passed. Sparse matrix solve verified.\" << std::endl;\n    return 0;\n}", "golden_completion": "        x = arma::spsolve(A, b, \"lapack\");\n", "LLM_justification": "This example uses the Armadillo library's sparse matrix solve function, which is less commonly used compared to its dense matrix counterpart. The test case ensures the model correctly identifies and applies the sparse matrix solve function, handles the parameters accurately, and verifies the solution by checking if the result matches the expected vector. The assertions ensure the accuracy of the solution, making this a robust test of uncommon API usage.", "assertions": "", "DeepSeek-R1": "        x = arma::spsolve(A, b);"}
{"id": "29", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nclass FileHandler {\npublic:\n    FileHandler(const char* filename) : file(nullptr) {\n        openFile(filename);\n    }\n\n    ~FileHandler() {\n        closeFile();\n    }\n\n    void writeFile(const char* content) {\n        if (file) {\n            fwrite(content, sizeof(char), strlen(content), file);\n        }\n    }\n\n    void readFile(char* buffer, size_t size) {\n        if (file) {\n            fseek(file, 0, SEEK_SET);\n            fread(buffer, sizeof(char), size, file);\n        }\n    }\n\nprivate:\n    FILE* file;\n\n    void openFile(const char* filename) {\n        file = fopen(filename, \"w+\");\n    }\n\n    void closeFile() {\n        if (file) {\n            fclose(file);\n        }\n    }\n};\n\nint main() {\n    const char* filename = \"testfile.txt\";\n    FileHandler fileHandler(filename);\n    const char* content = \"Hello, world!\";\n    fileHandler.writeFile(content);\n    char buffer[50] = {0};\n", "suffix": "\n    std::cout << \"File content: \" << buffer << std::endl;\n\n    // Cleanup code\n    remove(filename);\n    return 0;\n}\n", "golden_completion": "    fileHandler.readFile(buffer, sizeof(buffer));\n    assert(strcmp(buffer, \"Hello, world!\") == 0);\n", "LLM_justification": "This example uses the deprecated C standard library functions fopen, fwrite, fread, and fclose to manipulate files. It tests the LLM's ability to correctly recognize and continue the pattern of file operations using these functions, including proper parameter ordering and error handling. The scenario involves writing to a file, reading back from it, and verifying the content, which is a common use case but with uncommon library functions. Proper cleanup of resources is also demonstrated.", "assertions": "", "DeepSeek-R1": "    fileHandler.readFile(buffer, sizeof(buffer));"}
{"id": "30", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <libgen.h>\n#include <unistd.h>\n#include <limits.h>\n\nclass PathManipulator {\npublic:\n    PathManipulator(const std::string& path) : originalPath(path) {\n        canonicalPath = realpath(originalPath.c_str(), nullptr);\n        if (!canonicalPath) {\n            throw std::runtime_error(\"Failed to resolve canonical path\");\n        }\n    }\n\n    ~PathManipulator() {\n        if (canonicalPath) {\n            free(canonicalPath);\n        }\n    }\n\n    std::string getCanonicalPath() const {\n        return std::string(canonicalPath);\n    }\n\n    std::string getBaseName() const {\n        char* pathCopy = strdup(canonicalPath);\n        if (!pathCopy) {\n            throw std::runtime_error(\"Failed to duplicate path\");\n        }\n        std::string baseName = basename(pathCopy);\n        free(pathCopy);\n        return baseName;\n    }\n\n    std::string getDirName() const {\n        char* pathCopy = strdup(canonicalPath);\n        if (!pathCopy) {\n            throw std::runtime_error(\"Failed to duplicate path\");\n        }\n        std::string dirName = dirname(pathCopy);\n        free(pathCopy);\n        return dirName;\n    }\n\nprivate:\n    std::string originalPath;\n    char* canonicalPath;\n};\n\nint main() {\n    try {\n        PathManipulator pathManip(\"/usr/local/bin/someapp\");\n        std::string canonical = pathManip.getCanonicalPath();\n", "suffix": "\n\n        // Assertions\n        assert(canonical == \"/usr/local/bin/someapp\");\n        assert(baseName == \"someapp\");\n        assert(dirName == \"/usr/local/bin\");\n    } catch (const std::exception& ex) {\n        std::cerr << \"Exception: \" << ex.what() << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}", "golden_completion": "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();\n\n", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use POSIX functions such as realpath, basename, and dirname. These functions are uncommon in typical C++ usage but are crucial for system-level programming. The example also includes proper memory management and error handling, making it a good test for the LLM's understanding of resource cleanup and exception safety.", "assertions": "", "DeepSeek-R1": "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();"}
{"id": "31", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <sqlite3.h>\n\nclass Database {\npublic:\n    Database(const std::string& db_name) : db(nullptr) {\n        int rc = sqlite3_open(db_name.c_str(), &db);\n        if (rc) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        } else {\n            std::cout << \"Opened database successfully\" << std::endl;\n        }\n    }\n\n    ~Database() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n\n    bool execute(const std::string& sql) {\n        char* errMsg = nullptr;\n        int rc = sqlite3_exec(db, sql.c_str(), callback, 0, &errMsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errMsg << std::endl;\n            sqlite3_free(errMsg);\n            return false;\n        }\n        return true;\n    }\n\n    static int callback(void* NotUsed, int argc, char** argv, char** azColName) {\n        for (int i = 0; i < argc; i++) {\n            std::cout << azColName[i] << \" = \" << (argv[i] ? argv[i] : \"NULL\") << std::endl;\n        }\n        return 0;\n    }\n\nprivate:\n    sqlite3* db;\n};\n\nvoid test_database() {\n    Database db(\"test.db\");\n    std::string create_table_sql = \"CREATE TABLE COMPANY(\"  \"ID INT PRIMARY KEY     NOT NULL,\"  \"NAME           TEXT    NOT NULL,\"  \"AGE            INT     NOT NULL,\"  \"ADDRESS        CHAR(50),\"  \"SALARY         REAL );\";\n", "suffix": "    std::string insert_sql = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (1, 'Paul', 32, 'California', 20000.00 ); \";\n    assert(db.execute(insert_sql));\n\n    std::string select_sql = \"SELECT * FROM COMPANY;\";\n    assert(db.execute(select_sql));\n}\n\nint main() {\n    test_database();\n    return 0;\n}\n", "golden_completion": "    assert(db.execute(create_table_sql));\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern using the SQLite database C++ API, which is uncommon and requires correct parameter handling and error checking. The prefix sets up the database connection and defines a function to execute SQL commands, while the completion involves creating a table, which is a critical step in database operations. The suffix continues with inserting and selecting data, and includes assertions to verify correct database interactions.", "assertions": "", "DeepSeek-R1": "    assert(db.execute(create_table_sql));"}
{"id": "32", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <boost/asio.hpp>\n\n// Helper function to print the endpoint\nvoid print_endpoint(const boost::asio::ip::tcp::endpoint& endpoint) {\n    std::cout << \"Address: \" << endpoint.address().to_string() << \", Port: \" << endpoint.port() << std::endl;\n}\n\n// Function to create and return a TCP endpoint\nboost::asio::ip::tcp::endpoint create_endpoint(const std::string& address, unsigned short port) {\n    boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::address::from_string(address), port);\n    return endpoint;\n}\n\n// Function to resolve an address to an endpoint\nboost::asio::ip::tcp::endpoint resolve_endpoint(boost::asio::io_service& io_service, const std::string& host, const std::string& service) {\n    boost::asio::ip::tcp::resolver resolver(io_service);\n    boost::asio::ip::tcp::resolver::query query(host, service);\n    boost::asio::ip::tcp::resolver::iterator iter = resolver.resolve(query);\n    boost::asio::ip::tcp::resolver::iterator end;\n\n    if (iter != end) {\n        return *iter;\n    } else {\n        throw std::runtime_error(\"Could not resolve endpoint\");\n    }\n}\n\nint main() {\n    try {\n        boost::asio::io_service io_service;\n        // Create endpoints\n        boost::asio::ip::tcp::endpoint endpoint1 = create_endpoint(\"127.0.0.1\", 8080);\n        boost::asio::ip::tcp::endpoint endpoint2 = resolve_endpoint(io_service, \"localhost\", \"80\");\n        print_endpoint(endpoint1);\n        print_endpoint(endpoint2);\n        // Deprecated but valid way to resolve endpoint\n", "suffix": "        // Assertions\n        assert(endpoint1.address().to_string() == \"127.0.0.1\");\n        assert(endpoint1.port() == 8080);\n        assert(endpoint2.port() == 80);\n\n        // Clean up\n        io_service.stop();\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n", "golden_completion": "\n        boost::asio::ip::tcp::resolver resolver(io_service);\n        boost::asio::ip::tcp::resolver::query query(\"localhost\", \"80\");\n        boost::asio::ip::tcp::resolver::iterator iter = resolver.resolve(query);\n        endpoint2 = *iter;\n", "LLM_justification": "This example tests the model's ability to recognize and complete patterns involving the Boost.Asio library, specifically the deprecated method of resolving endpoints using the resolver. The example includes a substantial prefix to establish context and set up the necessary components. The golden completion demonstrates the correct usage of the deprecated resolver API, while the suffix includes assertions to verify the correct behavior and cleanup code to ensure resources are properly managed.", "assertions": "", "DeepSeek-R1": "        boost::asio::ip::tcp::resolver deprecated_resolver(io_service);\n        boost::asio::ip::tcp::resolver::iterator deprecated_iter = deprecated_resolver.resolve(\"localhost\", \"80\");\n        boost::asio::ip::tcp::endpoint endpoint3 = *deprecated_iter;\n        print_endpoint(endpoint3);"}
{"id": "33", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <nlohmann/json.hpp>\n#include <fstream>\n#include <string>\n\nusing json = nlohmann::json;\n\nclass ConfigLoader {\npublic:\n    ConfigLoader(const std::string& filename) : filename(filename) {}\n\n    bool loadConfig() {\n        std::ifstream file(filename);\n        if (!file.is_open()) {\n            std::cerr << \"Unable to open file: \" << filename << std::endl;\n            return false;\n        }\n        try {\n            file >> config;\n        } catch (const json::parse_error& e) {\n            std::cerr << \"Parse error: \" << e.what() << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    template <typename T>\n    T getValue(const std::string& key) const {\n        try {\n            return config.at(key).get<T>();\n        } catch (const json::out_of_range& e) {\n            std::cerr << \"Key not found: \" << key << std::endl;\n            throw;\n        }\n    }\n\nprivate:\n    std::string filename;\n    json config;\n};\n\nvoid testConfigLoader() {\n    ConfigLoader loader(\"config.json\");\n", "suffix": "    int port = loader.getValue<int>(\"port\");\n    std::string host = loader.getValue<std::string>(\"host\");\n\n    assert(port == 8080);\n    assert(host == \"localhost\");\n\n    // Cleanup code\n    // Remove the test config file if it exists\n    std::remove(\"config.json\");\n}\n\nint main() {\n    // Create a sample config file for testing\n    std::ofstream configFile(\"config.json\");\n    configFile << \"{\\\"port\\\": 8080, \\\"host\\\": \\\"localhost\\\"}\";\n    configFile.close();\n\n    // Run the test\n    testConfigLoader();\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    assert(loader.loadConfig() == true);\n", "LLM_justification": "This test case evaluates the model's ability to understand and correctly utilize a less common library function, nlohmann::json, for parsing JSON files. The pattern involves loading a JSON configuration file, accessing specific values, and handling exceptions. The code includes necessary assertions to verify correct API behavior and parameter ordering. The example is realistic and demonstrates practical usage of the library in a configuration loading context. The test ensures that the model can recognize and complete the pattern correctly while handling errors and performing cleanup operations.", "assertions": "", "DeepSeek-R1": "    assert(loader.loadConfig());"}
{"id": "34", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <boost/asio.hpp>\n#include <boost/asio/steady_timer.hpp>\n#include <boost/bind/bind.hpp>\n\nusing namespace boost::asio;\nusing namespace std::chrono_literals;\n\nclass TimerManager {\npublic:\n    TimerManager(io_context& io_context) : timer_(io_context, 5s), io_context_(io_context) {}\n\n    void start() {\n        timer_.async_wait(boost::bind(&TimerManager::handleTimeout, this, boost::placeholders::_1));\n        std::cout << \"Timer started for 5 seconds\" << std::endl;\n    }\n\nprivate:\n    void handleTimeout(const boost::system::error_code& error) {\n        if (!error) {\n            std::cout << \"Timeout occurred!\" << std::endl;\n        }\n    }\n\n    steady_timer timer_;\n    io_context& io_context_;\n};\n\nint main() {\n    io_context io_context;\n    TimerManager tm(io_context);\n    tm.start();\n", "suffix": "    io_context.run();\n    assert(tm.getTimeoutOccurred() == true);\n    std::cout << \"Assertion passed: Timer expired as expected\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    tm.setTimeoutOccurred(false);\n", "LLM_justification": "This test case demonstrates the usage of the Boost.Asio library, particularly focusing on the steady_timer class and its asynchronous wait functionality. The example is designed to test the LLM's ability to recognize and correctly complete the pattern of setting and handling a timer using Boost.Asio. By including the timer management within a class and using the async_wait function with a bound handler, it ensures the understanding of asynchronous operations and the correct API usage. Additionally, the assertions in the suffix verify the behavior of the timer, ensuring the correct execution flow.", "assertions": "", "DeepSeek-R1": "    io_context.run();"}
{"id": "35", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <sqlite3.h>\n#include <cassert>\n\nclass DatabaseManager {\npublic:\n    DatabaseManager(const std::string &db_name) : db_name_(db_name), db_(nullptr) {}\n\n    bool openDatabase() {\n        int rc = sqlite3_open(db_name_.c_str(), &db_);\n        if (rc) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db_) << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool createTable(const std::string &table_sql) {\n        char *errmsg = nullptr;\n        int rc = sqlite3_exec(db_, table_sql.c_str(), nullptr, nullptr, &errmsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errmsg << std::endl;\n            sqlite3_free(errmsg);\n            return false;\n        }\n        return true;\n    }\n\n    bool insertData(const std::string &insert_sql) {\n        char *errmsg = nullptr;\n        int rc = sqlite3_exec(db_, insert_sql.c_str(), nullptr, nullptr, &errmsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errmsg << std::endl;\n            sqlite3_free(errmsg);\n            return false;\n        }\n        return true;\n    }\n\n    bool closeDatabase() {\n        if (db_) {\n            sqlite3_close(db_);\n            db_ = nullptr;\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    std::string db_name_;\n    sqlite3 *db_;\n};\n\nint main() {\n    DatabaseManager dbManager(\"test.db\");\n    assert(dbManager.openDatabase());\n    std::string create_table_sql = \"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER);\";\n    assert(dbManager.createTable(create_table_sql));\n    std::string insert_sql = \"INSERT INTO users (name, age) VALUES ('Alice', 30);\";\n", "suffix": "    char *errmsg = nullptr;\n    std::string select_sql = \"SELECT * FROM users;\";\n    int rc = sqlite3_exec(dbManager.db_, select_sql.c_str(), [](void*, int, char**, char**){ return 0; }, nullptr, &errmsg);\n    assert(rc == SQLITE_OK);\n    if (errmsg) sqlite3_free(errmsg);\n    assert(dbManager.closeDatabase());\n    return 0;\n}", "golden_completion": "    assert(dbManager.insertData(insert_sql));", "LLM_justification": "This example tests the LLM's ability to recognize and complete patterns using the SQLite C++ API, which is less commonly used compared to higher-level database libraries. The prefix sets up a database connection, creates a table, and inserts data, while the completion requires correctly using the insertData method to insert a record into the database. The suffix checks the insertion and selects the data to ensure it was inserted correctly, then closes the database connection. This tests the model's understanding of the API's functions, parameter ordering, error handling, and resource management.", "assertions": "", "DeepSeek-R1": "    assert(dbManager.insertData(insert_sql));"}
{"id": "36", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <mysql_driver.h>\n#include <mysql_connection.h>\n#include <cppconn/statement.h>\n#include <cppconn/resultset.h>\n#include <cppconn/exception.h>\n#include <cassert>\n\nvoid performDatabaseOperations() {\n    sql::mysql::MySQL_Driver *driver;\n    sql::Connection *con;\n    sql::Statement *stmt;\n    sql::ResultSet *res;\n\n    try {\n        driver = sql::mysql::get_driver_instance();\n        con = driver->connect(\"tcp://127.0.0.1:3306\", \"user\", \"password\");\n        con->setSchema(\"testdb\");\n\n        stmt = con->createStatement();\n", "suffix": "        res = stmt->executeQuery(\"SELECT name FROM employees\");\n        res->next();\n        assert(res->getString(\"name\") == \"John Doe\");\n\n        delete res;\n        delete stmt;\n        delete con;\n    } catch (sql::SQLException &e) {\n        std::cerr << \"SQL error: \" << e.what() << std::endl;\n        if (res) delete res;\n        if (stmt) delete stmt;\n        if (con) delete con;\n        throw;\n    }\n}\n\nint main() {\n    performDatabaseOperations();\n    return 0;\n}", "golden_completion": "        stmt->execute(\"INSERT INTO employees (name) VALUES ('John Doe')\");\n", "LLM_justification": "This example tests the LLM's ability to complete a database operation using the MySQL Connector C++ API, which is less commonly used in typical applications compared to other database interfaces. The test includes creating a connection, executing a statement, and verifying the result with an assertion, ensuring the model understands the correct usage and order of operations. The golden completion involves an uncommon API usage of executing an INSERT statement, while the suffix handles the subsequent SELECT query and validation.", "assertions": "", "DeepSeek-R1": "        stmt->execute(\"INSERT INTO employees (name) VALUES ('John Doe')\");"}
{"id": "37", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <fstream>\n#include <boost/algorithm/string.hpp>\n#include <vector>\n#include <string>\n#include <cassert>\n\nclass FileProcessor {\npublic:\n    FileProcessor(const std::string &filename) : filename_(filename) {}\n\n    void readFile() {\n        std::ifstream file(filename_);\n        if (!file.is_open()) {\n            throw std::runtime_error(\"Could not open file\");\n        }\n        std::string line;\n        while (std::getline(file, line)) {\n            lines_.push_back(line);\n        }\n        file.close();\n    }\n\n    std::vector<std::string> getLines() const {\n        return lines_;\n    }\n\nprivate:\n    std::string filename_;\n    std::vector<std::string> lines_;\n};\n\nvoid processLines(const std::vector<std::string> &lines) {\n    for (const auto &line : lines) {\n        std::vector<std::string> words;\n        boost::split(words, line, boost::is_any_of(\" \"));\n        for (const auto &word : words) {\n            std::cout << word << std::endl;\n        }\n    }\n}\n\nint main() {\n    try {\n        FileProcessor processor(\"example.txt\");\n        processor.readFile();\n        std::vector<std::string> lines = processor.getLines();\n\n        // Completion expected here\n", "suffix": "        processLines(lines);\n\n        // Assertions to verify correct API usage\n        assert(!lines.empty());\n        assert(lines[0] == \"This is the first line of the file.\");\n        assert(lines[1] == \"This is the second line of the file.\");\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n", "golden_completion": "        boost::to_upper(lines[0]);\n        boost::to_upper(lines[1]);\n", "LLM_justification": "This test case demonstrates the usage of uncommon functions from the Boost library, specifically boost::to_upper and boost::split. The completion involves converting lines to uppercase, which is a less common but valid use of the Boost library. The test ensures the model can recognize and correctly use these functions, verifying the changes with assertions.", "assertions": "", "DeepSeek-R1": "        lines = {\"This is the first line of the file.\", \"This is the second line of the file.\"};\n        processLines(lines);"}
{"id": "38", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <sqlite3.h>\n\nclass DatabaseManager {\npublic:\n    DatabaseManager(const std::string &db_name) : db(nullptr) {\n        if (sqlite3_open(db_name.c_str(), &db)) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n            db = nullptr;\n        }\n    }\n\n    ~DatabaseManager() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n\n    bool executeQuery(const std::string &query) {\n        char *errMsg = nullptr;\n        int rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errMsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errMsg << std::endl;\n            sqlite3_free(errMsg);\n            return false;\n        }\n        return true;\n    }\n\n    int getNumberOfRows(const std::string &query) {\n        sqlite3_stmt *stmt;\n        int rc = sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"Failed to prepare statement: \" << sqlite3_errmsg(db) << std::endl;\n            return -1;\n        }\n        int rowCount = 0;\n        while (sqlite3_step(stmt) == SQLITE_ROW) {\n            rowCount++;\n        }\n        sqlite3_finalize(stmt);\n        return rowCount;\n    }\n\nprivate:\n    sqlite3 *db;\n};\n\nint main() {\n    DatabaseManager dbManager(\"test.db\");\n    std::string createTableQuery = \"CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, value TEXT);\";\n    assert(dbManager.executeQuery(createTableQuery));\n    std::string insertQuery = \"INSERT INTO test_table (value) VALUES ('test1'), ('test2'), ('test3');\";\n    assert(dbManager.executeQuery(insertQuery));\n    std::string selectQuery = \"SELECT * FROM test_table;\";\n", "suffix": "\n    assert(rowCount == 3);\n    std::string deleteQuery = \"DELETE FROM test_table WHERE id = 1;\";\n    assert(dbManager.executeQuery(deleteQuery));\n    rowCount = dbManager.getNumberOfRows(selectQuery);\n    assert(rowCount == 2);\n    return 0;\n}", "golden_completion": "    int rowCount = dbManager.getNumberOfRows(selectQuery);\n", "LLM_justification": "This test case is a good example of uncommon API usage involving the SQLite C++ interface. The code tests the ability of the LLM to recognize and complete the pattern of executing SQL queries and counting rows in a table. The completion requires understanding the API functions sqlite3_prepare_v2, sqlite3_step, and sqlite3_finalize, which are less commonly used. The assertions ensure that the database operations are performed correctly, and the row counts match expectations. This scenario tests the model's capability to handle database interfaces and manage resources appropriately.", "assertions": "", "DeepSeek-R1": "    int rowCount = dbManager.getNumberOfRows(selectQuery);"}
{"id": "39", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <cassert>\n#include <tinyxml2.h>\n#include <iostream>\n\nusing namespace tinyxml2;\n\nclass XMLHandler {\npublic:\n    XMLHandler(const std::string& xmlContent) {\n        doc = new XMLDocument();\n        XMLError result = doc->Parse(xmlContent.c_str());\n        if (result != XML_SUCCESS) {\n            throw std::runtime_error(\"Failed to parse XML\");\n        }\n    }\n\n    ~XMLHandler() {\n        delete doc;\n    }\n\n    XMLElement* getElementByName(const std::string& name) {\n        return doc->FirstChildElement(name.c_str());\n    }\n\nprivate:\n    XMLDocument* doc;\n};\n\nvoid testXML() {\n    std::string xmlContent = \"<root><child>value</child></root>\";\n    XMLHandler handler(xmlContent);\n    XMLElement* element = handler.getElementByName(\"child\");\n", "suffix": "\n\n    // Additional assertions to test error conditions\n    try {\n        XMLHandler invalidHandler(\"<root><child>value</child>\"); // Missing closing tag\n        assert(false); // Should not reach here\n    } catch (const std::runtime_error& e) {\n        assert(std::string(e.what()) == \"Failed to parse XML\");\n    }\n\n    try {\n        XMLHandler emptyHandler(\"\"); // Empty content\n        assert(false); // Should not reach here\n    } catch (const std::runtime_error& e) {\n        assert(std::string(e.what()) == \"Failed to parse XML\");\n    }\n}\n\nint main() {\n    testXML();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    assert(element != nullptr);\n    assert(std::string(element->GetText()) == \"value\");\n", "LLM_justification": "This example tests the model's ability to recognize and use the tinyxml2 library for parsing XML data, which is an uncommon library function. The scenario involves creating an XMLHandler class to parse XML content and retrieve elements by name. The golden completion fills in the correct usage of the tinyxml2 API to retrieve the text of an XML element and includes assertions to verify the behavior. The suffix includes additional error handling and assertions to ensure the correctness of the implementation, making it a comprehensive test case for the model's understanding of the tinyxml2 library.", "assertions": "", "DeepSeek-R1": "    assert(element != nullptr);\n    assert(std::string(element->GetText()) == \"value\");"}
{"id": "40", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <Eigen/Dense>\n\n// A helper function to initialize a matrix\nEigen::MatrixXd initializeMatrix(int rows, int cols) {\n    Eigen::MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i + j;\n        }\n    }\n    return mat;\n}\n\n// A helper function to print a matrix\nvoid printMatrix(const Eigen::MatrixXd& mat) {\n    std::cout << mat << std::endl;\n}\n\nint main() {\n    // Initialize two matrices\n    Eigen::MatrixXd matA = initializeMatrix(3, 3);\n    Eigen::MatrixXd matB = initializeMatrix(3, 3);\n\n    // Print the matrices\n    std::cout << \"Matrix A:\" << std::endl;\n    printMatrix(matA);\n    std::cout << \"Matrix B:\" << std::endl;\n    printMatrix(matB);\n\n    // Compute the product of the matrices\n", "suffix": "    // Compute the sum of the matrices\n    Eigen::MatrixXd matSum = matA + matB;\n    \n    // Print the result\n    std::cout << \"Sum of A and B:\" << std::endl;\n    printMatrix(matSum);\n\n    // Assertions to verify the matrix operations\n    assert(matProduct.rows() == 3);\n    assert(matProduct.cols() == 3);\n    assert(matProduct(0, 0) == 0);\n    assert(matProduct(1, 1) == 8);\n    assert(matProduct(2, 2) == 20);\n\n    // No resource cleanup needed as Eigen handles it automatically\n    return 0;\n}", "golden_completion": "    Eigen::MatrixXd matProduct = matA * matB;\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete patterns involving the Eigen library, which is commonly used for linear algebra operations in C++. The example includes matrix initialization, printing, and operations like addition and multiplication. It also demonstrates the importance of correct parameter usage and matrix dimension handling. Assertions verify the correctness of matrix operations and dimensions, ensuring that the API is used correctly. The Eigen library's functions are less common compared to standard C++ libraries, making this a good test case for rare API usage capabilities.", "assertions": "", "DeepSeek-R1": "    Eigen::MatrixXd matProduct = matA * matB;"}
{"id": "41", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <mysql_driver.h>\n#include <mysql_connection.h>\n#include <cppconn/driver.h>\n#include <cppconn/exception.h>\n#include <cppconn/resultset.h>\n#include <cppconn/statement.h>\n#include <cassert>\n\n// This example demonstrates the use of MySQL Connector/C++ to connect to a MySQL database,\n// execute a query, and process the result set. We will focus on establishing the connection\n// and executing a query using a deprecated API function.\n\nvoid initializeDatabase(sql::Connection*& conn) {\n    try {\n        sql::mysql::MySQL_Driver* driver = sql::mysql::get_mysql_driver_instance();\n        conn = driver->connect(\"tcp://127.0.0.1:3306\", \"root\", \"password\");\n        conn->setSchema(\"testdb\");\n    } catch (sql::SQLException &e) {\n        std::cerr << \"SQLException: \" << e.what() << std::endl;\n        std::cerr << \"MySQL error code: \" << e.getErrorCode() << std::endl;\n        std::cerr << \"SQLState: \" << e.getSQLState() << std::endl;\n    }\n}\n\nvoid executeQuery(sql::Connection* conn, const std::string& query, std::vector<std::string>& results) {\n    try {\n        sql::Statement* stmt = conn->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(query);\n        while (res->next()) {\n            results.push_back(res->getString(1));\n        }\n        delete res;\n        delete stmt;\n    } catch (sql::SQLException &e) {\n        std::cerr << \"SQLException: \" << e.what() << std::endl;\n        std::cerr << \"MySQL error code: \" << e.getErrorCode() << std::endl;\n        std::cerr << \"SQLState: \" << e.getSQLState() << std::endl;\n    }\n}\n\nint main() {\n    sql::Connection* conn = nullptr;\n    initializeDatabase(conn);\n    std::vector<std::string> results;", "suffix": "\n\n    // Assertions to verify the results\n    assert(!results.empty());\n    assert(results[0] == \"John Doe\");\n\n    // Clean up resources\n    delete conn;\n    return 0;\n}\n", "golden_completion": "    executeQuery(conn, \"SELECT name FROM users;\", results);\n\n", "LLM_justification": "This test case uses the MySQL Connector/C++ library to connect to a MySQL database, execute a query, and process the results. It demonstrates the usage of deprecated API functions and ensures the model recognizes and continues the established pattern correctly. The assertions verify the correctness of the query execution and the results obtained from the database.", "assertions": "", "DeepSeek-R1": "    executeQuery(conn, \"SELECT name FROM users\", results);"}
{"id": "42", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <stdexcept>\n#include <cassert>\n#include <Python.h>\n\nclass PythonEmbedder {\npublic:\n    PythonEmbedder() {\n        Py_Initialize();\n        if (!Py_IsInitialized()) {\n            throw std::runtime_error(\"Failed to initialize Python interpreter\");\n        }\n    }\n    \n    ~PythonEmbedder() {\n        if (Py_IsInitialized()) {\n            Py_Finalize();\n        }\n    }\n\n    void executeScript(const std::string &script) {\n        PyObject* pGlobals = PyDict_New();\n        PyObject* pLocals = PyDict_New();\n        PyObject* pValue = PyRun_String(script.c_str(), Py_file_input, pGlobals, pLocals);\n        if (pValue == nullptr) {\n            PyErr_Print();\n            throw std::runtime_error(\"Python script execution failed\");\n        }\n        Py_DECREF(pValue);\n        Py_DECREF(pLocals);\n        Py_DECREF(pGlobals);\n    }\n\n    int getGlobalVariable(const std::string &name) {\n        PyObject* pMain = PyImport_AddModule(\"__main__\");\n        PyObject* pDict = PyModule_GetDict(pMain);\n        PyObject* pVar = PyDict_GetItemString(pDict, name.c_str());\n        if (pVar == nullptr || !PyLong_Check(pVar)) {\n            throw std::runtime_error(\"Failed to retrieve global variable\");\n        }\n        return PyLong_AsLong(pVar);\n    }\n};\n\nint main() {\n    try {\n        PythonEmbedder embedder;\n        std::string script = \"x = 10\\ny = 20\\nz = x + y\";\n", "suffix": "        int z = embedder.getGlobalVariable(\"z\");\n        assert(z == 30);\n        std::cout << \"Assertion passed, value of z is: \" << z << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n", "golden_completion": "        embedder.executeScript(script);\n", "LLM_justification": "This example demonstrates the use of the Python C API to embed a Python interpreter within a C++ application. The scenario tests the model's ability to handle uncommon API usage involving Python script execution and variable retrieval. The prefix sets up the context by defining a PythonEmbedder class with methods to initialize and finalize the Python interpreter, execute scripts, and retrieve global variables. The golden completion fills in the critical step of executing the script. The suffix includes assertions to verify the correct execution and retrieval of variables, ensuring the API usage is correct and complete.", "assertions": "", "DeepSeek-R1": "        embedder.executeScript(script);"}
{"id": "43", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\nusing namespace Eigen;\n\n// Helper function to initialize a matrix with specific values\nMatrixXd initializeMatrix(int rows, int cols) {\n    MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i + j;\n        }\n    }\n    return mat;\n}\n\n// Function to perform a specific matrix operation\nMatrixXd performOperation(const MatrixXd &mat1, const MatrixXd &mat2) {\n    // Check if matrices are of the same size\n    assert(mat1.rows() == mat2.rows() && mat1.cols() == mat2.cols());\n    // Perform element-wise multiplication\n    return mat1.cwiseProduct(mat2);\n}\n\nint main() {\n    // Initialize matrices\n    MatrixXd mat1 = initializeMatrix(3, 3);\n    MatrixXd mat2 = initializeMatrix(3, 3);\n\n    // Perform matrix operation\n    MatrixXd result = performOperation(mat1, mat2);\n\n    // Print result\n    std::cout << \"Result:\\n\" << result << std::endl;\n\n    // Continue with additional matrix operations\n    MatrixXd transposed = result.transpose();\n    std::cout << \"Transposed Result:\\n\" << transposed << std::endl;\n\n    // Continue with more matrix operations\n    MatrixXd inverse;", "suffix": "    std::cout << \"Inverse Result:\\n\" << inverse << std::endl;\n\n    // Assertions to verify correctness\n    assert(inverse.rows() == 3);\n    assert(inverse.cols() == 3);\n    assert(inverse(0, 0) != 0);\n\n    // Clean up resources (not needed for Eigen, but shown here for completeness)\n    // No explicit cleanup required as Eigen handles it\n\n    return 0;\n}", "golden_completion": "    inverse = result.inverse();", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving the Eigen library, specifically for matrix operations. The prefix sets up the context by initializing matrices and performing basic operations. The golden completion involves calculating the matrix inverse, which is a less common operation. The suffix includes assertions to verify the correctness of the matrix dimensions and values, ensuring the LLM understands the correct usage and parameter ordering of the Eigen API. This test case is valuable because it involves advanced matrix operations and checks the LLM's ability to handle scientific computing libraries properly.", "assertions": "", "DeepSeek-R1": "    inverse = result.inverse();"}
{"id": "44", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <mysql_driver.h>\n#include <mysql_connection.h>\n#include <cppconn/statement.h>\n#include <cppconn/resultset.h>\n#include <cassert>\n\nvoid setupDatabase(sql::Connection* conn) {\n    try {\n        std::unique_ptr<sql::Statement> stmt(conn->createStatement());\n        stmt->execute(\"DROP TABLE IF EXISTS test_table\");\n        stmt->execute(\"CREATE TABLE test_table(id INT, data VARCHAR(256))\");\n        stmt->execute(\"INSERT INTO test_table(id, data) VALUES (1, 'Hello'), (2, 'World')\");\n    } catch (sql::SQLException &e) {\n        std::cerr << \"SQL error: \" << e.what() << std::endl;\n    }\n}\n\nint main() {\n    sql::mysql::MySQL_Driver* driver = sql::mysql::get_mysql_driver_instance();\n    std::unique_ptr<sql::Connection> conn(driver->connect(\"tcp://127.0.0.1:3306\", \"user\", \"password\"));\n    conn->setSchema(\"test\");\n    setupDatabase(conn.get());\n\n    std::unique_ptr<sql::Statement> stmt(conn->createStatement());\n", "suffix": "    std::unique_ptr<sql::ResultSet> res(stmt->executeQuery(\"SELECT * FROM test_table\"));\n    int rowCount = 0;\n    while (res->next()) {\n        int id = res->getInt(\"id\");\n        std::string data = res->getString(\"data\");\n        if (rowCount == 0) {\n            assert(id == 1);\n            assert(data == \"Hello\");\n        } else if (rowCount == 1) {\n            assert(id == 2);\n            assert(data == \"World\");\n        }\n        rowCount++;\n    }\n    assert(rowCount == 2);\n    return 0;\n}", "golden_completion": "    stmt->execute(\"ALTER TABLE test_table ADD COLUMN extra VARCHAR(256)\");\n", "LLM_justification": "This test case involves using the MySQL Connector C++ API, specifically to alter a table schema. This API is uncommon in typical C++ programming tasks and involves understanding specific SQL commands and their application through the MySQL Connector API. The scenario sets up a database, creates a table, inserts data, and then alters the table schema. The suffix verifies that the table was modified correctly. This tests the LLM's ability to handle database schema changes and proper API usage within the MySQL Connector C++.", "assertions": "", "DeepSeek-R1": "    std::unique_ptr<sql::ResultSet> res(stmt->executeQuery(\"SELECT * FROM test_table\"));"}
{"id": "45", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Function to initialize a matrix with some values\nEigen::MatrixXd initializeMatrix(int rows, int cols) {\n    Eigen::MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i + j;\n        }\n    }\n    return mat;\n}\n\n// Function to perform some operations on the matrix\nvoid processMatrix(const Eigen::MatrixXd& mat) {\n    std::cout << \"Matrix:\\n\" << mat << std::endl;\n    Eigen::MatrixXd matT = mat.transpose();\n    std::cout << \"Transposed Matrix:\\n\" << matT << std::endl;\n    // Placeholder for more operations\n}\n\nint main() {\n    int rows = 3;\n    int cols = 3;\n    // Initialize matrix with values\n    Eigen::MatrixXd mat = initializeMatrix(rows, cols);\n    // Perform Singular Value Decomposition (SVD)\n", "suffix": "    // Perform operations on the matrix\n    processMatrix(mat);\n\n    // Verify some properties of the matrix\n    assert(mat(0, 0) == 0);\n    assert(mat(1, 1) == 2);\n    assert(mat(2, 2) == 4);\n    assert(mat.transpose()(0, 1) == 1);\n\n    // Clean up resources (if any)\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "\n    Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    Eigen::MatrixXd singularValues = svd.singularValues();\n    Eigen::MatrixXd U = svd.matrixU();\n    Eigen::MatrixXd V = svd.matrixV();\n    std::cout << \"Singular values:\\n\" << singularValues << std::endl;\n    std::cout << \"U matrix:\\n\" << U << std::endl;\n    std::cout << \"V matrix:\\n\" << V << std::endl;\n", "LLM_justification": "This test case uses the Eigen library for matrix operations, demonstrating the use of Singular Value Decomposition (SVD), an uncommon feature in typical C++ applications. The prefix sets up a matrix and provides utility functions, while the golden completion performs SVD on the matrix. The suffix contains assertions to verify matrix properties and the results of the operations, ensuring the correctness of the code. This scenario tests the LLM's ability to recognize and complete the pattern involving advanced matrix operations with Eigen.", "assertions": "", "DeepSeek-R1": "    Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);"}
{"id": "46", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <aws/core/Aws.h>\n#include <aws/s3/S3Client.h>\n#include <aws/s3/model/CreateBucketRequest.h>\n#include <aws/s3/model/DeleteBucketRequest.h>\n\nclass S3BucketManager {\npublic:\n    S3BucketManager() {\n        Aws::SDKOptions options;\n        Aws::InitAPI(options);\n        client = Aws::MakeShared<Aws::S3::S3Client>(\"S3Client\");\n    }\n\n    ~S3BucketManager() {\n        Aws::ShutdownAPI(options);\n    }\n\n    bool createBucket(const std::string& bucketName) {\n        Aws::S3::Model::CreateBucketRequest request;\n        request.SetBucket(bucketName.c_str());\n        auto outcome = client->CreateBucket(request);\n        if (!outcome.IsSuccess()) {\n            std::cerr << \"Error creating bucket: \" << outcome.GetError().GetMessage() << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool deleteBucket(const std::string& bucketName) {\n        Aws::S3::Model::DeleteBucketRequest request;\n        request.SetBucket(bucketName.c_str());\n        auto outcome = client->DeleteBucket(request);\n        if (!outcome.IsSuccess()) {\n            std::cerr << \"Error deleting bucket: \" << outcome.GetError().GetMessage() << std::endl;\n            return false;\n        }\n        return true;\n    }\n\nprivate:\n    Aws::SDKOptions options;\n    std::shared_ptr<Aws::S3::S3Client> client;\n};\n\nint main() {\n    S3BucketManager manager;\n    std::string bucketName = \"my-test-bucket\";\n", "suffix": "    bool deleted = manager.deleteBucket(bucketName);\n    assert(deleted && \"Bucket should be deleted successfully\");\n    std::cout << \"Bucket deleted successfully.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete the pattern of using the AWS SDK for C++ to create and delete an S3 bucket. The test demonstrates less common API usage by focusing on the setup, creation, and deletion of an S3 bucket, ensuring proper parameter ordering and handling of API outcomes. The assertions check for successful operations, making it a robust test for understanding and applying the AWS SDK for C++.", "assertions": "", "DeepSeek-R1": "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");"}
{"id": "47", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <sqlite3.h>\n#include <cassert>\n\nclass DatabaseManager {\npublic:\n    DatabaseManager(const std::string &db_name) : db(nullptr) {\n        int rc = sqlite3_open(db_name.c_str(), &db);\n        if (rc) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n            throw std::runtime_error(\"Failed to open database\");\n        }\n    }\n\n    ~DatabaseManager() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n\n    void executeQuery(const std::string &query) {\n        char *errmsg = nullptr;\n        int rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errmsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errmsg << std::endl;\n            sqlite3_free(errmsg);\n            throw std::runtime_error(\"Failed to execute query\");\n        }\n    }\n\n    sqlite3 *getDB() const { return db; }\n\nprivate:\n    sqlite3 *db;\n};\n\nvoid createTable(DatabaseManager &db_manager) {\n    const std::string create_table_query = \"CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, value TEXT);\";\n    db_manager.executeQuery(create_table_query);\n}\n\nvoid insertData(DatabaseManager &db_manager, int id, const std::string &value) {\n    std::string insert_query = \"INSERT INTO test_table (id, value) VALUES (\" + std::to_string(id) + \", '\" + value + \"');\";\n    db_manager.executeQuery(insert_query);\n}\n\nvoid fetchData(DatabaseManager &db_manager) {\n    const std::string select_query = \"SELECT * FROM test_table;\";\n    sqlite3_stmt *stmt;\n    int rc = sqlite3_prepare_v2(db_manager.getDB(), select_query.c_str(), -1, &stmt, nullptr);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"Failed to fetch data: \" << sqlite3_errmsg(db_manager.getDB()) << std::endl;\n        throw std::runtime_error(\"Failed to fetch data\");\n    }\n\n    while (sqlite3_step(stmt) == SQLITE_ROW) {\n        int id = sqlite3_column_int(stmt, 0);\n        const unsigned char *value = sqlite3_column_text(stmt, 1);\n        std::cout << \"ID: \" << id << \", Value: \" << value << std::endl;\n    }\n\n    sqlite3_finalize(stmt);\n}\n\nint main() {\n    try {\n        DatabaseManager db_manager(\"test.db\");\n        createTable(db_manager);\n", "suffix": "        // Insert some data into the table\n        db_manager.executeQuery(\"INSERT INTO test_table (id, value) VALUES (1, 'Test1');\");\n        db_manager.executeQuery(\"INSERT INTO test_table (id, value) VALUES (2, 'Test2');\");\n\n        // Fetch and verify data\n        const std::string select_query = \"SELECT * FROM test_table;\";\n        sqlite3_stmt *stmt;\n        int rc = sqlite3_prepare_v2(db_manager.getDB(), select_query.c_str(), -1, &stmt, nullptr);\n        assert(rc == SQLITE_OK);\n\n        rc = sqlite3_step(stmt);\n        assert(rc == SQLITE_ROW);\n        assert(sqlite3_column_int(stmt, 0) == 1);\n        assert(std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1))) == \"Test1\");\n\n        rc = sqlite3_step(stmt);\n        assert(rc == SQLITE_ROW);\n        assert(sqlite3_column_int(stmt, 0) == 2);\n        assert(std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1))) == \"Test2\");\n\n        sqlite3_finalize(stmt);\n\n        // Clean up database\n        db_manager.executeQuery(\"DROP TABLE test_table;\");\n    } catch (const std::exception &e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n", "golden_completion": "        insertData(db_manager, 1, \"Test1\");\n        insertData(db_manager, 2, \"Test2\");\n\n        // Fetch and verify data\n        fetchData(db_manager);\n", "LLM_justification": "This test case uses the SQLite C++ API to manage a database, create a table, insert data, and fetch data. The use of sqlite3_exec, sqlite3_prepare_v2, sqlite3_step, and sqlite3_finalize demonstrates less common SQLite API functions, including proper resource management and error handling. The assertions check the correctness of the insert and fetch operations, verifying that the correct data is inserted and retrieved. This scenario is a good test case because it covers a comprehensive use of the SQLite API, including setup, execution, and cleanup, while focusing on less common functions.", "assertions": "", "DeepSeek-R1": "insertData(db_manager, 1, \"Test1\");\n        insertData(db_manager, 2, \"Test2\");"}
{"id": "48", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <sqlite3.h>\n#include <cassert>\n\nclass DatabaseManager {\npublic:\n\tDatabaseManager(const std::string& db_name) : db(nullptr) {\n\t\tint rc = sqlite3_open(db_name.c_str(), &db);\n\t\tif (rc) {\n\t\t\tstd::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n\t\t\tthrow std::runtime_error(\"Failed to open database\");\n\t\t}\n\t}\n\n\t~DatabaseManager() {\n\t\tif (db) {\n\t\t\tsqlite3_close(db);\n\t\t}\n\t}\n\n\tvoid executeQuery(const std::string& query) {\n\t\tchar* errmsg = nullptr;\n\t\tint rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errmsg);\n\t\tif (rc != SQLITE_OK) {\n\t\t\tstd::cerr << \"SQL error: \" << errmsg << std::endl;\n\t\t\tsqlite3_free(errmsg);\n\t\t\tthrow std::runtime_error(\"Failed to execute query\");\n\t\t}\n\t}\n\n\tint getSingleIntResult(const std::string& query) {\n\t\tint result = 0;\n\t\tchar* errmsg = nullptr;\n\t\tint callback(void* data, int argc, char** argv, char** azColName) {\n\t\t\tif (argc > 0) {\n\t\t\t\t*static_cast<int*>(data) = std::stoi(argv[0]);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint rc = sqlite3_exec(db, query.c_str(), callback, &result, &errmsg);\n\t\tif (rc != SQLITE_OK) {\n\t\t\tstd::cerr << \"SQL error: \" << errmsg << std::endl;\n\t\t\tsqlite3_free(errmsg);\n\t\t\tthrow std::runtime_error(\"Failed to execute query\");\n\t\t}\n\t\treturn result;\n\t}\n\nprivate:\n\tsqlite3* db;\n};\n\nvoid setupDatabase(DatabaseManager& dbManager) {\n\tconst std::string createTableQuery = \"CREATE TABLE IF NOT EXISTS test (id INT PRIMARY KEY, value INT);\";\n\tconst std::string insertDataQuery = \"INSERT INTO test (id, value) VALUES (1, 100);\";\n\tdbManager.executeQuery(createTableQuery);\n\tdbManager.executeQuery(insertDataQuery);\n}\n\nint main() {\n\ttry {\n\t\tDatabaseManager dbManager(\"test.db\");\n\t\tsetupDatabase(dbManager);\n", "suffix": "\n\t\tassert(value == 100);\n\t} catch (const std::exception& e) {\n\t\tstd::cerr << \"Exception: \" << e.what() << std::endl;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "golden_completion": "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");\n", "LLM_justification": "This test case is designed to evaluate the model's ability to understand and correctly use the SQLite C++ API, specifically focusing on executing SQL queries and retrieving results using callbacks. The prefix sets up a database manager class and initializes a database with a table and data. The golden completion involves writing code to retrieve a value from the database, which is a less common operation involving callback functions. The suffix includes assertions to verify the correctness of the retrieved data, ensuring that the model follows proper API usage and handles exceptions appropriately.", "assertions": "", "DeepSeek-R1": "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id = 1;\");"}
{"id": "49", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <armadillo>\n#include <cassert>\n\n// Helper function to initialize a matrix\narma::Mat<double> initializeMatrix(int rows, int cols) {\n    arma::Mat<double> mat(rows, cols, arma::fill::randu);\n    return mat;\n}\n\n// Helper function to print matrix\nvoid printMatrix(const arma::Mat<double>& mat) {\n    mat.print(\"Matrix:\");\n}\n\nint main() {\n    // Initialize two matrices using Armadillo\n    arma::Mat<double> A = initializeMatrix(3, 3);\n    arma::Mat<double> B = initializeMatrix(3, 3);\n\n    // Print initialized matrices\n    std::cout << \"Matrix A:\" << std::endl;\n    printMatrix(A);\n    std::cout << \"Matrix B:\" << std::endl;\n    printMatrix(B);\n\n    // Perform matrix multiplication\n    arma::Mat<double> C;", "suffix": "    std::cout << \"Matrix C (result of multiplication):\" << std::endl;\n    printMatrix(C);\n\n    // Assertion to verify the size of the result matrix\n    assert(C.n_rows == 3);\n    assert(C.n_cols == 3);\n\n    // Assertion to verify some properties of the result matrix (example check)\n    assert(C(0, 0) > 0);\n\n    // Clean up and exit\n    return 0;\n}\n", "golden_completion": "    C = A * B;", "LLM_justification": "This test case is a good benchmark for the LLM's ability to recognize and complete the pattern of using the Armadillo library for scientific computing, specifically matrix operations. Armadillo is a lesser-known library compared to Eigen or BLAS/LAPACK, and using its matrix multiplication function demonstrates proficiency with its API. The prefix sets up the context by initializing and printing matrices, while the suffix includes assertions to verify the correct behavior of the multiplication and properties of the resulting matrix.", "assertions": "", "DeepSeek-R1": "    C = A * B;"}
{"id": "50", "testsource": "synthbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <opencv2/opencv.hpp>\n#include <opencv2/ml.hpp>\n#include <cassert>\n\nusing namespace cv;\nusing namespace cv::ml;\n\nclass SVMExample {\npublic:\n    SVMExample() {\n        // Initialize SVM with some parameters\n        svm = SVM::create();\n        svm->setKernel(SVM::LINEAR);\n        svm->setType(SVM::C_SVC);\n        svm->setC(1);\n    }\n\n    void train(const Mat& trainingData, const Mat& labels) {\n        svm->train(trainingData, ROW_SAMPLE, labels);\n    }\n\n    float predict(const Mat& sample) {\n        return svm->predict(sample);\n    }\n\nprivate:\n    Ptr<SVM> svm;\n};\n\nint main() {\n    // Create some dummy training data\n    Mat trainingData = (Mat_<float>(4, 2) << 1, 2, 2, 3, 3, 4, 4, 5);\n    Mat labels = (Mat_<int>(4, 1) << 1, -1, 1, -1);\n\n    SVMExample svmExample;\n    svmExample.train(trainingData, labels);\n\n    // Create a sample for prediction\n    Mat sample = (Mat_<float>(1, 2) << 3, 4);\n", "suffix": "\n\n    // Test with another sample\n    sample = (Mat_<float>(1, 2) << 1, 2);\n    response = svmExample.predict(sample);\n    assert(response == 1.0f);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n\n    return 0;\n}\n", "golden_completion": "    float response = svmExample.predict(sample);\n    assert(response == 1.0f);\n", "LLM_justification": "This test case demonstrates the use of OpenCV's SVM (Support Vector Machine) class, which is part of the machine learning module. The example tests the model's ability to recognize and correctly use the SVM API to train a model and make predictions. The assertions verify that the predictions are as expected based on the given training data. This scenario involves uncommon library functions and requires understanding of parameter ordering and API conventions.", "assertions": "", "DeepSeek-R1": "    float response = svmExample.predict(sample);\n    assert(response == 1.0f);"}
