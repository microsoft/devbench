{"id": "1", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <Eigen/Dense>\n#include <iostream>\n#include <cassert>\n\n// Define a function to perform matrix multiplication using Eigen\nEigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd& mat1, const Eigen::MatrixXd& mat2) {\n    if (mat1.cols() != mat2.rows()) {\n        throw std::invalid_argument(\"Matrix dimensions must agree for multiplication.\");\n    }\n    return mat1 * mat2;\n}\n\n// Initialize matrices with random values for testing\nEigen::MatrixXd generateRandomMatrix(int rows, int cols) {\n    Eigen::MatrixXd mat = Eigen::MatrixXd::Random(rows, cols);\n    return mat;\n}\n\nint main() {\n    // Generate test matrices\n    Eigen::MatrixXd mat1 = generateRandomMatrix(4, 3);\n    Eigen::MatrixXd mat2 = generateRandomMatrix(3, 2);\n\n    // Perform matrix multiplication\n    Eigen::MatrixXd result;\n    try {\n        result = multiplyMatrices(mat1, mat2);\n    } catch (const std::invalid_argument& e) {\n        std::cerr << e.what() << std::endl;\n        return -1;\n    }\n\n    // Output matrices for verification\n    std::cout << \"Matrix 1:\\n\" << mat1 << std::endl;\n    std::cout << \"Matrix 2:\\n\" << mat2 << std::endl;\n    std::cout << \"Resultant Matrix:\\n\" << result << std::endl;\n\n    // Golden completion placeholder\n", "suffix": "\n\n    // Clean up resources (handled automatically by Eigen)\n    std::cout << \"Matrix multiplication and verification succeeded.\" << std::endl;\n    return 0;\n}", "golden_completion": "    // Verify the correctness of matrix multiplication using a known result\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert((result - expected).norm() < 1e-9);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a matrix multiplication operation using the Eigen library, which is a less common but highly specialized library for linear algebra in C++. The scenario includes error handling for dimension mismatches, matrix initialization, and verification of results using assertions. This ensures that the model understands the proper usage and validation of uncommon library functions while handling edge cases and maintaining proper parameter ordering.", "assertions": "", "DeepSeek-V3.1_completion_0": "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    assert(result.isApprox(expected));", "DeepSeek-V3.1_completion_1": "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    for (int i = 0; i < result.rows(); ++i) {\n        for (int j = 0; j < result.cols(); ++j) {\n            assert(std::abs(result(i, j) - expected(i, j)) < 1e-10);\n        }\n    }", "DeepSeek-V3.1_completion_2": "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    for (int i = 0; i < result.rows(); ++i) {\n        for (int j = 0; j < result.cols(); ++j) {\n            assert(std::abs(result(i, j) - expected(i, j)) < 1e-10);\n        }\n    }", "DeepSeek-V3.1_completion_3": "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    for (int i = 0; i < result.rows(); ++i) {\n        for (int j = 0; j < result.cols(); ++j) {\n            assert(std::abs(result(i, j) - expected(i, j)) < 1e-10);\n        }\n    }", "DeepSeek-V3.1_completion_4": "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    for (int i = 0; i < result.rows(); ++i) {\n        for (int j = 0; j < result.cols(); ++j) {\n            assert(std::abs(result(i, j) - expected(i, j)) < 1e-10);\n        }\n    }", "DeepSeek-V3.1_completions": ["    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    assert(result.isApprox(expected));", "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    for (int i = 0; i < result.rows(); ++i) {\n        for (int j = 0; j < result.cols(); ++j) {\n            assert(std::abs(result(i, j) - expected(i, j)) < 1e-10);\n        }\n    }", "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    for (int i = 0; i < result.rows(); ++i) {\n        for (int j = 0; j < result.cols(); ++j) {\n            assert(std::abs(result(i, j) - expected(i, j)) < 1e-10);\n        }\n    }", "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    for (int i = 0; i < result.rows(); ++i) {\n        for (int j = 0; j < result.cols(); ++j) {\n            assert(std::abs(result(i, j) - expected(i, j)) < 1e-10);\n        }\n    }", "    // Verify the result by comparing with direct multiplication\n    Eigen::MatrixXd expected = mat1 * mat2;\n    assert(result.rows() == expected.rows() && result.cols() == expected.cols());\n    for (int i = 0; i < result.rows(); ++i) {\n        for (int j = 0; j < result.cols(); ++j) {\n            assert(std::abs(result(i, j) - expected(i, j)) < 1e-10);\n        }\n    }"]}
{"id": "2", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <openssl/evp.h>\n\nclass CryptoHelper {\npublic:\n    CryptoHelper() : ctx(EVP_CIPHER_CTX_new()) {}\n    ~CryptoHelper() { if (ctx) EVP_CIPHER_CTX_free(ctx); }\n\n    void init(const unsigned char *key, const unsigned char *iv) {\n        EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv);\n    }\n\n    int encrypt(const unsigned char *plaintext, int plaintext_len, unsigned char *ciphertext) {\n        int len;\n        int ciphertext_len;\n\n        if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {\n            return -1;\n        }\n        ciphertext_len = len;\n\n        if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {\n            return -1;\n        }\n        ciphertext_len += len;\n\n        return ciphertext_len;\n    }\n\nprivate:\n    EVP_CIPHER_CTX *ctx;\n};\n\nint main() {\n    unsigned char key[32] = {0};\n    unsigned char iv[16] = {0};\n    unsigned char plaintext[] = \"This is a test.\";\n    unsigned char ciphertext[128];\n\n    CryptoHelper crypto;\n    crypto.init(key, iv);\n    int ciphertext_len = crypto.encrypt(plaintext, strlen((char *)plaintext), ciphertext);\n    assert(ciphertext_len > 0);\n    std::cout << \"Ciphertext length: \" << ciphertext_len << std::endl;\n\n    // Add decryption code here\n", "suffix": "\n\n    assert(strcmp((char *)plaintext, (char *)decryptedtext) == 0);\n    std::cout << \"Decrypted text: \" << decryptedtext << std::endl;\n\n    return 0;\n}", "golden_completion": "    EVP_CIPHER_CTX *ctx_decrypt = EVP_CIPHER_CTX_new();\n    EVP_DecryptInit_ex(ctx_decrypt, EVP_aes_256_cbc(), nullptr, key, iv);\n\n    int len;\n    int plaintext_len;\n    unsigned char decryptedtext[128];\n\n    if(1 != EVP_DecryptUpdate(ctx_decrypt, decryptedtext, &len, ciphertext, ciphertext_len)) {\n        EVP_CIPHER_CTX_free(ctx_decrypt);\n        return -1;\n    }\n    plaintext_len = len;\n\n    if(1 != EVP_DecryptFinal_ex(ctx_decrypt, decryptedtext + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx_decrypt);\n        return -1;\n    }\n    plaintext_len += len;\n    decryptedtext[plaintext_len] = '\\0';\n\n    EVP_CIPHER_CTX_free(ctx_decrypt);\n\n", "LLM_justification": "This test case is a good example of using the OpenSSL library for encryption and decryption, which involves uncommon API functions such as EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate, and EVP_DecryptFinal_ex. It ensures that the LLM can handle complex cryptographic operations, manage resource cleanup, and verify the correctness of the encryption and decryption process using assertions. The prefix establishes the encryption pattern, while the golden completion and suffix focus on the decryption process, ensuring a clear distinction between them.", "assertions": "", "DeepSeek-V3.1_completion_0": "    unsigned char decryptedtext[128];\n    int decryptedtext_len;\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv);\n    EVP_DecryptUpdate(ctx, decryptedtext, &decryptedtext_len, ciphertext, ciphertext_len);\n    int len;\n    EVP_DecryptFinal_ex(ctx, decryptedtext + decryptedtext_len, &len);\n    decryptedtext_len += len;\n    decryptedtext[decryptedtext_len] = '\\0';\n    EVP_CIPHER_CTX_free(ctx);", "DeepSeek-V3.1_completion_1": "    unsigned char decryptedtext[128];\n    CryptoHelper decryptor;\n    decryptor.init(key, iv);\n    int decryptedtext_len = decryptor.decrypt(ciphertext, ciphertext_len, decryptedtext);\n    decryptedtext[decryptedtext_len] = '\\0';", "DeepSeek-V3.1_completion_2": "    unsigned char decryptedtext[128];\n    CryptoHelper decrypto;\n    decrypto.init(key, iv);\n    int decryptedtext_len = decrypto.encrypt(ciphertext, ciphertext_len, decryptedtext);\n    decryptedtext[decryptedtext_len] = '\\0';", "DeepSeek-V3.1_completion_3": "    unsigned char decryptedtext[128];\n    CryptoHelper decrypto;\n    decrypto.init(key, iv);\n    int decryptedtext_len = decrypto.encrypt(ciphertext, ciphertext_len, decryptedtext);\n    decryptedtext[decryptedtext_len] = '\\0';", "DeepSeek-V3.1_completion_4": "    unsigned char decryptedtext[128];\n    CryptoHelper decrypto;\n    decrypto.init(key, iv);\n    int decryptedtext_len = decrypto.encrypt(ciphertext, ciphertext_len, decryptedtext);\n    decryptedtext[decryptedtext_len] = '\\0';", "DeepSeek-V3.1_completions": ["    unsigned char decryptedtext[128];\n    int decryptedtext_len;\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv);\n    EVP_DecryptUpdate(ctx, decryptedtext, &decryptedtext_len, ciphertext, ciphertext_len);\n    int len;\n    EVP_DecryptFinal_ex(ctx, decryptedtext + decryptedtext_len, &len);\n    decryptedtext_len += len;\n    decryptedtext[decryptedtext_len] = '\\0';\n    EVP_CIPHER_CTX_free(ctx);", "    unsigned char decryptedtext[128];\n    CryptoHelper decryptor;\n    decryptor.init(key, iv);\n    int decryptedtext_len = decryptor.decrypt(ciphertext, ciphertext_len, decryptedtext);\n    decryptedtext[decryptedtext_len] = '\\0';", "    unsigned char decryptedtext[128];\n    CryptoHelper decrypto;\n    decrypto.init(key, iv);\n    int decryptedtext_len = decrypto.encrypt(ciphertext, ciphertext_len, decryptedtext);\n    decryptedtext[decryptedtext_len] = '\\0';", "    unsigned char decryptedtext[128];\n    CryptoHelper decrypto;\n    decrypto.init(key, iv);\n    int decryptedtext_len = decrypto.encrypt(ciphertext, ciphertext_len, decryptedtext);\n    decryptedtext[decryptedtext_len] = '\\0';", "    unsigned char decryptedtext[128];\n    CryptoHelper decrypto;\n    decrypto.init(key, iv);\n    int decryptedtext_len = decrypto.encrypt(ciphertext, ciphertext_len, decryptedtext);\n    decryptedtext[decryptedtext_len] = '\\0';"]}
{"id": "3", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <harfbuzz/hb.h>\n#include <cassert>\n\n// Helper function to create a HarfBuzz buffer\nhb_buffer_t* createBuffer(const char *text) {\n    hb_buffer_t *buffer = hb_buffer_create();\n    if (!buffer) {\n        throw std::runtime_error(\"Failed to create HarfBuzz buffer\");\n    }\n    hb_buffer_add_utf8(buffer, text, -1, 0, -1);\n    hb_buffer_guess_segment_properties(buffer);\n    return buffer;\n}\n\n// Helper function to create a HarfBuzz font without external dependencies\nhb_font_t* createHbFont() {\n    // Create an empty HarfBuzz font for API testing\n    hb_font_t *hbFont = hb_font_create(hb_face_get_empty());\n    if (!hbFont) {\n        throw std::runtime_error(\"Failed to create HarfBuzz font\");\n    }\n    // Set basic font properties for testing\n    hb_font_set_scale(hbFont, 1000, 1000);\n    return hbFont;\n}\n\nint main() {\n    const char *text = \"Hello HarfBuzz!\";\n\n    // Test HarfBuzz API without external font dependencies\n    hb_buffer_t *buffer = createBuffer(text);\n    hb_font_t *hbFont = createHbFont();\n\n    // Shape text with HarfBuzz\n", "suffix": "\n\n    // Print glyph information if available\n    if (glyphCount > 0 && glyphInfo && glyphPos) {\n        for (unsigned int i = 0; i < glyphCount; i++) {\n            std::cout << \"Glyph \" << glyphInfo[i].codepoint << \" at (\" << glyphPos[i].x_offset << \", \" << glyphPos[i].y_offset << \") with advance (\" << glyphPos[i].x_advance << \", \" << glyphPos[i].y_advance << \")\\n\";\n        }\n    } else {\n        std::cout << \"HarfBuzz API test completed. Glyph count: \" << glyphCount << std::endl;\n    }\n\n    // Cleanup\n    hb_buffer_destroy(buffer);\n    hb_font_destroy(hbFont);\n\n    std::cout << \"HarfBuzz test completed successfully.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    hb_shape(hbFont, buffer, NULL, 0);\n\n    // Retrieve glyph information\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);\n\n    // Basic assertions to verify the HarfBuzz API is working\n    assert(glyphInfo != NULL);\n    assert(glyphPos != NULL);\n    \n    std::cout << \"HarfBuzz shaping completed. Glyph count: \" << glyphCount << std::endl;\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete the usage of the HarfBuzz library for text shaping, which is less common. The test focuses on the core HarfBuzz API functions without dependencies on external font files, making it self-contained and robust. The golden completion demonstrates proper usage of hb_shape, hb_buffer_get_glyph_infos, and hb_buffer_get_glyph_positions functions. This scenario comprehensively tests the model's understanding of text shaping with uncommon libraries while being practical and reliable.", "assertions": "", "DeepSeek-V3.1_completion_0": "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "DeepSeek-V3.1_completion_1": "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "DeepSeek-V3.1_completion_2": "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "DeepSeek-V3.1_completion_3": "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "DeepSeek-V3.1_completion_4": "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "DeepSeek-V3.1_completions": ["    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);", "    hb_shape(hbFont, buffer, NULL, 0);\n    unsigned int glyphCount;\n    hb_glyph_info_t *glyphInfo = hb_buffer_get_glyph_infos(buffer, &glyphCount);\n    hb_glyph_position_t *glyphPos = hb_buffer_get_glyph_positions(buffer, &glyphCount);"]}
{"id": "4", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cassert>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <openssl/err.h>\n\n// Utility function to initialize OpenSSL library\nvoid init_openssl() {\n    // OpenSSL 3.x automatically initializes, these functions are deprecated\n    // OpenSSL_add_all_algorithms() and ERR_load_crypto_strings() are no longer needed\n}\n\n// Utility function to cleanup OpenSSL library\nvoid cleanup_openssl() {\n    // EVP_cleanup() and ERR_free_strings() are deprecated in OpenSSL 3.x\n    // Cleanup is automatic\n}\n\n// Function to generate a random key\nstd::vector<unsigned char> generate_random_key(int length) {\n    std::vector<unsigned char> key(length);\n    if (!RAND_bytes(key.data(), length)) {\n        throw std::runtime_error(\"Failed to generate random bytes\");\n    }\n    return key;\n}\n\n// Function to encrypt data using AES-256-CBC\nstd::vector<unsigned char> encrypt(const std::vector<unsigned char>& plaintext, const std::vector<unsigned char>& key, const std::vector<unsigned char>& iv) {\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n    }\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key.data(), iv.data())) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_EncryptInit_ex failed\");\n    }\n    std::vector<unsigned char> ciphertext(plaintext.size() + EVP_CIPHER_block_size(EVP_aes_256_cbc()));\n    int len;\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext.data(), &len, plaintext.data(), plaintext.size())) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_EncryptUpdate failed\");\n    }\n    int ciphertext_len = len;\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_EncryptFinal_ex failed\");\n    }\n    ciphertext_len += len;\n    ciphertext.resize(ciphertext_len);\n    EVP_CIPHER_CTX_free(ctx);\n    return ciphertext;\n}\n\n// Function to decrypt data using AES-256-CBC\nstd::vector<unsigned char> decrypt(const std::vector<unsigned char>& ciphertext, const std::vector<unsigned char>& key, const std::vector<unsigned char>& iv) {\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n    }\n    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key.data(), iv.data())) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_DecryptInit_ex failed\");\n    }\n    std::vector<unsigned char> plaintext(ciphertext.size());\n    int len;\n    if (1 != EVP_DecryptUpdate(ctx, plaintext.data(), &len, ciphertext.data(), ciphertext.size())) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_DecryptUpdate failed\");\n    }\n    int plaintext_len = len;\n    if (1 != EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        throw std::runtime_error(\"EVP_DecryptFinal_ex failed\");\n    }\n    plaintext_len += len;\n    plaintext.resize(plaintext_len);\n    EVP_CIPHER_CTX_free(ctx);\n    return plaintext;\n}\n\nint main() {\n    try {\n        init_openssl();\n\n        // Test data\n        std::vector<unsigned char> plaintext = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!'};\n        std::vector<unsigned char> key = generate_random_key(32);\n", "suffix": "        // Decrypt and verify\n        std::vector<unsigned char> decrypted = decrypt(ciphertext, key, iv);\n        \n        // Assertions to verify encryption/decryption round-trip\n        assert(!ciphertext.empty());\n        assert(ciphertext.size() > plaintext.size());\n        assert(decrypted.size() == plaintext.size());\n        assert(std::equal(plaintext.begin(), plaintext.end(), decrypted.begin()));\n        \n        std::cout << \"Encryption/Decryption successful. Ciphertext size: \" << ciphertext.size() << std::endl;\n        std::cout << \"Decrypted text matches original: \" << std::string(decrypted.begin(), decrypted.end()) << std::endl;\n\n        // Cleanup OpenSSL\n        cleanup_openssl();\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n", "golden_completion": "        std::vector<unsigned char> iv = generate_random_key(16);  // Initialization vector\n        \n        // Encrypt the plaintext\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);\n", "LLM_justification": "This test case verifies the LLM's capability to understand and complete a pattern involving the OpenSSL library for cryptographic operations, specifically AES-256-CBC encryption and decryption. It checks the model's ability to correctly use less common functions like RAND_bytes for generating random bytes, EVP_EncryptInit_ex, EVP_EncryptUpdate, EVP_EncryptFinal_ex for encryption, and the corresponding decrypt functions. The test includes a complete encryption/decryption round-trip with assertions to verify the process works correctly.", "assertions": "", "DeepSeek-V3.1_completion_0": "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "DeepSeek-V3.1_completion_1": "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "DeepSeek-V3.1_completion_2": "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "DeepSeek-V3.1_completion_3": "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "DeepSeek-V3.1_completion_4": "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "DeepSeek-V3.1_completions": ["        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);", "        std::vector<unsigned char> iv = generate_random_key(16);\n        std::vector<unsigned char> ciphertext = encrypt(plaintext, key, iv);"]}
{"id": "5", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <harfbuzz/hb.h>\n#include <cassert>\n\n// Helper function to create a HarfBuzz buffer\nhb_buffer_t* createHarfBuzzBuffer(const char* text) {\n    hb_buffer_t* buffer = hb_buffer_create();\n    if (!buffer) {\n        std::cerr << \"Failed to create HarfBuzz buffer.\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    hb_buffer_add_utf8(buffer, text, -1, 0, -1);\n    hb_buffer_guess_segment_properties(buffer);\n    return buffer;\n}\n\n// Helper function to create a HarfBuzz font without external dependencies\nhb_font_t* createHarfBuzzFont() {\n    hb_font_t* font = hb_font_create(hb_face_get_empty());\n    if (!font) {\n        std::cerr << \"Failed to create HarfBuzz font.\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    // Set basic font properties for testing\n    hb_font_set_scale(font, 1000, 1000);\n    return font;\n}\n\n// Helper function to shape text\nvoid shapeText(hb_font_t* font, hb_buffer_t* buffer) {\n    hb_shape(font, buffer, NULL, 0);\n}\n\n// Helper function to print shaped text information\nvoid printShapedTextInfo(hb_buffer_t* buffer) {\n    unsigned int len = hb_buffer_get_length(buffer);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(buffer, NULL);\n    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(buffer, NULL);\n    for (unsigned int i = 0; i < len; ++i) {\n        std::cout << \"Glyph ID: \" << info[i].codepoint << \", X Offset: \" << pos[i].x_offset << \", Y Offset: \" << pos[i].y_offset << std::endl;\n    }\n}\n\nint main() {\n    // Test HarfBuzz API without external font dependencies\n    const char* text = \"Hello, HarfBuzz!\";\n    hb_font_t* hbFont = createHarfBuzzFont();\n    hb_buffer_t* hbBuffer = createHarfBuzzBuffer(text);\n    shapeText(hbFont, hbBuffer);\n    printShapedTextInfo(hbBuffer);\n    // Test if the buffer has glyphs and assert the information\n", "suffix": "    \n    // Cleanup resources\n    hb_buffer_destroy(hbBuffer);\n    hb_font_destroy(hbFont);\n    \n    std::cout << \"HarfBuzz test completed successfully.\" << std::endl;\n    return 0;\n}", "golden_completion": "    // Verify the shaped text information using HarfBuzz API\n    unsigned int len = hb_buffer_get_length(hbBuffer);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(hbBuffer, NULL);\n    \n    // Assertions to verify the shaped text information\n    assert(len > 0);\n    assert(info != NULL);\n    assert(pos != NULL);\n    \n    // Verify each glyph has valid properties\n    for (unsigned int i = 0; i < len; ++i) {\n        assert(info[i].codepoint != 0);\n        // Note: advance values may be 0 for synthetic/empty fonts\n    }\n    \n    std::cout << \"HarfBuzz shaping validation completed. Found \" << len << \" glyphs.\" << std::endl;\n", "LLM_justification": "This example tests the use of the HarfBuzz library for text shaping, specifically focusing on functions that are less commonly used such as hb_buffer_add_utf8, hb_shape, hb_buffer_get_glyph_infos, and hb_buffer_get_glyph_positions. The test case has been made self-contained by removing external font dependencies and using HarfBuzz's built-in empty face functionality. This ensures that the test verifies the buffer has glyphs and that the shaped text information is valid through comprehensive API usage including glyph information retrieval and validation. This scenario helps evaluate the LLM's ability to recognize and correctly use rare functions from the HarfBuzz API while being robust and reliable.", "assertions": "", "DeepSeek-V3.1_completion_0": "    unsigned int len = hb_buffer_get_length(hbBuffer);\n    assert(len > 0 && \"Buffer should contain glyphs\");\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(hbBuffer, NULL);\n    for (unsigned int i = 0; i < len; ++i) {\n        assert(info[i].codepoint != 0 && \"Glyph ID should not be zero\");\n        assert(pos[i].x_advance >= 0 && \"X advance should be non-negative\");\n    }", "DeepSeek-V3.1_completion_1": "    assert(hb_buffer_get_length(hbBuffer) > 0);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    assert(info != NULL);", "DeepSeek-V3.1_completion_2": "    assert(hb_buffer_get_length(hbBuffer) > 0);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    assert(info != NULL);", "DeepSeek-V3.1_completion_3": "    unsigned int len = hb_buffer_get_length(hbBuffer);\n    assert(len > 0 && \"Buffer should contain glyphs\");\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    for (unsigned int i = 0; i < len; ++i) {\n        assert(info[i].codepoint != 0 && \"Glyph ID should not be zero\");\n    }", "DeepSeek-V3.1_completion_4": "    assert(hb_buffer_get_length(hbBuffer) > 0);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    assert(info != NULL);", "DeepSeek-V3.1_completions": ["    unsigned int len = hb_buffer_get_length(hbBuffer);\n    assert(len > 0 && \"Buffer should contain glyphs\");\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(hbBuffer, NULL);\n    for (unsigned int i = 0; i < len; ++i) {\n        assert(info[i].codepoint != 0 && \"Glyph ID should not be zero\");\n        assert(pos[i].x_advance >= 0 && \"X advance should be non-negative\");\n    }", "    assert(hb_buffer_get_length(hbBuffer) > 0);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    assert(info != NULL);", "    assert(hb_buffer_get_length(hbBuffer) > 0);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    assert(info != NULL);", "    unsigned int len = hb_buffer_get_length(hbBuffer);\n    assert(len > 0 && \"Buffer should contain glyphs\");\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    for (unsigned int i = 0; i < len; ++i) {\n        assert(info[i].codepoint != 0 && \"Glyph ID should not be zero\");\n    }", "    assert(hb_buffer_get_length(hbBuffer) > 0);\n    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(hbBuffer, NULL);\n    assert(info != NULL);"]}
{"id": "6", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <harfbuzz/hb.h>\n#include <cassert>\n\n// This example demonstrates the use of HarfBuzz for text shaping.\n// HarfBuzz is a text shaping library for complex text layout.\n\n// Global HarfBuzz objects\nhb_buffer_t *hb_buffer;\nhb_font_t *hb_font;\n\nvoid initialize() {\n    // Initialize HarfBuzz buffer\n    hb_buffer = hb_buffer_create();\n    if (!hb_buffer) {\n        std::cerr << \"Could not create HarfBuzz buffer\" << std::endl;\n        exit(1);\n    }\n\n    // Create HarfBuzz font using empty face for API testing\n    hb_font = hb_font_create(hb_face_get_empty());\n    if (!hb_font) {\n        std::cerr << \"Could not create HarfBuzz font\" << std::endl;\n        exit(1);\n    }\n\n    // Set basic font properties for testing\n    hb_font_set_scale(hb_font, 1000, 1000);\n}\n\nvoid cleanup() {\n    // Cleanup HarfBuzz objects\n    if (hb_font) {\n        hb_font_destroy(hb_font);\n    }\n    if (hb_buffer) {\n        hb_buffer_destroy(hb_buffer);\n    }\n}\n\nint main() {\n    initialize();\n\n    // Set text to be shaped\n    const char *text = \"Hello, HarfBuzz!\";\n    hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);\n\n    // Set script, language, and direction\n    hb_buffer_set_script(hb_buffer, HB_SCRIPT_LATIN);\n    hb_buffer_set_language(hb_buffer, hb_language_from_string(\"en\", -1));\n    hb_buffer_set_direction(hb_buffer, HB_DIRECTION_LTR);\n\n    // Shape the text\n", "suffix": "    std::cout << \"HarfBuzz text shaping completed successfully. Found \" << glyph_count << \" glyphs.\" << std::endl;\n\n    cleanup();\n    return 0;\n}", "golden_completion": "    hb_shape(hb_font, hb_buffer, NULL, 0);\n\n    // Get glyph information and positions using HarfBuzz API\n    unsigned int glyph_count;\n    hb_glyph_info_t *glyph_info = hb_buffer_get_glyph_infos(hb_buffer, &glyph_count);\n    hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions(hb_buffer, &glyph_count);\n\n    // Assertions to verify correct shaping\n    assert(glyph_count > 0);\n    assert(glyph_info != NULL);\n    assert(glyph_pos != NULL);\n    \n    // Verify each glyph has valid properties\n    for (unsigned int i = 0; i < glyph_count; ++i) {\n        assert(glyph_info[i].codepoint != 0);\n        // Print detailed glyph information\n        std::cout << \"Glyph \" << i << \": codepoint=\" << glyph_info[i].codepoint\n                  << \", x_advance=\" << glyph_pos[i].x_advance\n                  << \", y_advance=\" << glyph_pos[i].y_advance\n                  << \", x_offset=\" << glyph_pos[i].x_offset\n                  << \", y_offset=\" << glyph_pos[i].y_offset << std::endl;\n    }\n", "LLM_justification": "This example demonstrates the use of HarfBuzz for text shaping, which is a less common but powerful library for complex text layout. The test has been made self-contained by removing external font dependencies and using HarfBuzz's built-in empty face functionality. The prefix sets up the HarfBuzz library and initializes the necessary objects using a structured approach with separate initialization and cleanup functions. The golden completion involves comprehensive HarfBuzz API usage including text shaping, glyph information retrieval, position data extraction, and detailed validation with assertions. This scenario tests the LLM's ability to correctly use the complete HarfBuzz shaping workflow and handle the less common API usage patterns including glyph enumeration and property validation while being robust and reliable.", "assertions": "", "DeepSeek-V3.1_completion_0": "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "DeepSeek-V3.1_completion_1": "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "DeepSeek-V3.1_completion_2": "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "DeepSeek-V3.1_completion_3": "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "DeepSeek-V3.1_completion_4": "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "DeepSeek-V3.1_completions": ["    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);", "    hb_shape(hb_font, hb_buffer, NULL, 0);\n    unsigned int glyph_count = hb_buffer_get_length(hb_buffer);"]}
{"id": "7", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// A simple function to initialize an Eigen matrix with given values\nvoid initializeMatrix(Eigen::MatrixXd &matrix) {\n    matrix(0, 0) = 1.0;\n    matrix(1, 0) = 2.0;\n    matrix(0, 1) = 3.0;\n    matrix(1, 1) = 4.0;\n}\n\n// A function to compute the inverse of a 2x2 matrix using Eigen library\nEigen::MatrixXd computeInverse(const Eigen::MatrixXd &matrix) {\n    assert(matrix.rows() == 2 && matrix.cols() == 2);\n    return matrix.inverse();\n}\n\n// Another function to multiply two matrices\nEigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd &matrix1, const Eigen::MatrixXd &matrix2) {\n    return matrix1 * matrix2;\n}\n\n// A function to add two matrices\nEigen::MatrixXd addMatrices(const Eigen::MatrixXd &matrix1, const Eigen::MatrixXd &matrix2) {\n    return matrix1 + matrix2;\n}\n\nint main() {\n    // Initialize a 2x2 matrix\n    Eigen::MatrixXd matrix(2, 2);\n    initializeMatrix(matrix);\n\n    // Compute the inverse of the matrix\n    Eigen::MatrixXd inverseMatrix = computeInverse(matrix);\n\n    // Print the original and inverse matrices\n    std::cout << \"Original Matrix:\\n\" << matrix << std::endl;\n    std::cout << \"Inverse Matrix:\\n\" << inverseMatrix << std::endl;\n\n    // Example of multiplying matrices\n    Eigen::MatrixXd result = multiplyMatrices(matrix, inverseMatrix);\n    std::cout << \"Result of multiplication (should be identity matrix):\\n\" << result << std::endl;\n\n    // Example of adding matrices\n    Eigen::MatrixXd sumMatrix = addMatrices(matrix, inverseMatrix);\n    std::cout << \"Result of addition:\\n\" << sumMatrix << std::endl;\n\n    // Example of using a less common function from Eigen library\n    // Compute the determinant of the matrix using Eigen's determinant() function\n", "suffix": "\n\n    // Assertions to verify correctness\n    assert(determinant == -2.0);\n\n    // Compute the transpose of the matrix\n    Eigen::MatrixXd transposeMatrix = matrix.transpose();\n    std::cout << \"Transpose of the matrix:\\n\" << transposeMatrix << std::endl;\n\n    // Assertions to verify correctness\n    assert(transposeMatrix(0, 0) == matrix(0, 0));\n    assert(transposeMatrix(1, 0) == matrix(0, 1));\n    assert(transposeMatrix(0, 1) == matrix(1, 0));\n    assert(transposeMatrix(1, 1) == matrix(1, 1));\n\n    return 0;\n}", "golden_completion": "\n    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;\n\n", "LLM_justification": "This example focuses on the Eigen library, which is widely used for linear algebra operations but includes some less commonly used functions such as matrix determinant and transpose calculations. The code tests the LLM's understanding of these specific functions, their usage patterns, and correct parameter handling. The prefix sets up various matrix operations, while the golden completion demonstrates the correct usage of Eigen's determinant() and transpose() functions. Assertions are included in the suffix to verify the correctness of the operations and ensure the model correctly implements these uncommon but important functions in the Eigen library.", "assertions": "", "DeepSeek-V3.1_completion_0": "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "DeepSeek-V3.1_completion_1": "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "DeepSeek-V3.1_completion_2": "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "DeepSeek-V3.1_completion_3": "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "DeepSeek-V3.1_completion_4": "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "DeepSeek-V3.1_completions": ["    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;", "    double determinant = matrix.determinant();\n    std::cout << \"Determinant of the matrix: \" << determinant << std::endl;"]}
{"id": "8", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Helper function to initialize matrices\nvoid initializeMatrices(Eigen::MatrixXd& A, Eigen::MatrixXd& B) {\n    A << 1, 2, 3, 4,\n         5, 6, 7, 8,\n         9, 10, 11, 12;\n    B << 12, 11, 10, 9,\n         8, 7, 6, 5,\n         4, 3, 2, 1;\n}\n\n// Function to perform matrix multiplication and return the result\nEigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd& A, const Eigen::MatrixXd& B) {\n    assert(A.cols() == B.rows() && \"Matrix dimensions must be compatible for multiplication.\");\n    return A * B;\n}\n\n// Function to print a matrix\nvoid printMatrix(const Eigen::MatrixXd& matrix) {\n    std::cout << matrix << std::endl;\n}\n\n// Main function\nint main() {\n    Eigen::MatrixXd A(3, 4);\n    Eigen::MatrixXd B(4, 3);\n    initializeMatrices(A, B);\n    // Perform uncommon operation: matrix transpose and addition\n", "suffix": "    Eigen::MatrixXd C = multiplyMatrices(A, B);\n    printMatrix(C);\n\n    // Assertions\n    Eigen::MatrixXd expectedC(3, 3);\n    expectedC << 60, 50, 40,\n                 180, 154, 128,\n                 300, 258, 216;\n    assert(C.isApprox(expectedC) && \"Matrix multiplication result is incorrect.\");\n\n    // Clean up resources (not needed for Eigen objects as they are automatically managed)\n    return 0;\n}", "golden_completion": "\n    Eigen::MatrixXd D = A.transpose() + B;\n    printMatrix(D);\n\n    // Assertions\n    Eigen::MatrixXd expectedD(4, 3);\n    expectedD << 13, 16, 19,\n                 11, 14, 17,\n                 9, 12, 15,\n                 7, 10, 13;\n    assert(D.isApprox(expectedD) && \"Matrix transpose and addition result is incorrect.\");\n", "LLM_justification": "This test case demonstrates the use of the Eigen library for matrix operations, including an uncommon combination of matrix transpose and addition. The prefix sets up the matrices and provides utility functions for initialization, multiplication, and printing. The completion involves performing a less common operation (matrix transpose and addition) and then validating the result with assertions. This scenario tests the model's ability to recognize and correctly use Eigen's API for advanced matrix operations while ensuring that the results are accurate through assertions.", "assertions": "", "DeepSeek-V3.1_completion_0": "    Eigen::MatrixXd D = A.transpose() + B;", "DeepSeek-V3.1_completion_1": "    Eigen::MatrixXd D = A.transpose() + B;", "DeepSeek-V3.1_completion_2": "Eigen::MatrixXd D = A.transpose() + B.transpose();\n    printMatrix(D);", "DeepSeek-V3.1_completion_3": "    Eigen::MatrixXd D = A.transpose() + B;", "DeepSeek-V3.1_completion_4": "    Eigen::MatrixXd D = A.transpose() + B;", "DeepSeek-V3.1_completions": ["    Eigen::MatrixXd D = A.transpose() + B;", "    Eigen::MatrixXd D = A.transpose() + B;", "Eigen::MatrixXd D = A.transpose() + B.transpose();\n    printMatrix(D);", "    Eigen::MatrixXd D = A.transpose() + B;", "    Eigen::MatrixXd D = A.transpose() + B;"]}
{"id": "9", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <string>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\n// Utility function to initialize OpenSSL library\nvoid initializeOpenSSL() {\n    // OpenSSL 3.x automatically initializes, these functions are deprecated\n    // OpenSSL_add_all_algorithms() and ERR_load_crypto_strings() are no longer needed\n}\n\n// Utility function to cleanup OpenSSL library\nvoid cleanupOpenSSL() {\n    // EVP_cleanup() and ERR_free_strings() are deprecated in OpenSSL 3.x\n    // Cleanup is automatic\n}\n\n// Function to encrypt a message using OpenSSL\nbool encryptMessage(const std::string& plaintext, std::string& ciphertext, const std::string& key) {\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) {\n        return false;\n    }\n\n    const EVP_CIPHER *cipher = EVP_aes_256_cbc();\n    if (!EVP_EncryptInit_ex(ctx, cipher, nullptr, reinterpret_cast<const unsigned char*>(key.c_str()), nullptr)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n\n    int len;\n    int ciphertext_len;\n    unsigned char ciphertext_buf[1024];\n\n    if (!EVP_EncryptUpdate(ctx, ciphertext_buf, &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.length())) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n    ciphertext_len = len;\n\n    if (!EVP_EncryptFinal_ex(ctx, ciphertext_buf + len, &len)) {\n        EVP_CIPHER_CTX_free(ctx);\n        return false;\n    }\n    ciphertext_len += len;\n\n    ciphertext.assign(reinterpret_cast<const char*>(ciphertext_buf), ciphertext_len);\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n}\n\nint main() {\n    initializeOpenSSL();\n    std::string plaintext = \"This is a secret message.\";\n    std::string key = \"01234567890123456789012345678901\"; // 256-bit key\n    std::string ciphertext;", "suffix": "    \n    cleanupOpenSSL();\n    std::cout << \"Encryption and decryption successful.\" << std::endl;\n    return 0;\n}", "golden_completion": "    bool result = encryptMessage(plaintext, ciphertext, key);\n    assert(result);\n    assert(!ciphertext.empty());\n\n    // Decryption code for validation using OpenSSL EVP API\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    assert(ctx != nullptr);\n\n    const EVP_CIPHER *cipher = EVP_aes_256_cbc();\n    assert(EVP_DecryptInit_ex(ctx, cipher, nullptr, reinterpret_cast<const unsigned char*>(key.c_str()), nullptr));\n\n    int len;\n    int plaintext_len;\n    unsigned char plaintext_buf[1024];\n\n    assert(EVP_DecryptUpdate(ctx, plaintext_buf, &len, reinterpret_cast<const unsigned char*>(ciphertext.c_str()), ciphertext.length()));\n    plaintext_len = len;\n\n    assert(EVP_DecryptFinal_ex(ctx, plaintext_buf + len, &len));\n    plaintext_len += len;\n\n    std::string decrypted_plaintext(reinterpret_cast<const char*>(plaintext_buf), plaintext_len);\n    assert(decrypted_plaintext == plaintext);\n\n    EVP_CIPHER_CTX_free(ctx);\n", "LLM_justification": "This test case demonstrates comprehensive usage of the OpenSSL EVP (Envelope) API for both encryption and decryption of data. The EVP API is a high-level interface to cryptographic functions, which is not commonly used due to its complexity and the need for proper resource management. The example includes the initialization and cleanup of the OpenSSL library, encryption of a message, and validation through complete decryption workflow. The golden completion contains substantial API usage including EVP context creation, decryption initialization, update and finalization steps. The assertions verify that the encryption was successful, the ciphertext is not empty, and the decrypted text matches the original plaintext. Proper parameter ordering and resource management are crucial for the correct usage of the API.", "assertions": "", "DeepSeek-V3.1_completion_0": "if (encryptMessage(plaintext, ciphertext, key)) {\n        std::cout << \"Ciphertext: \" << ciphertext << std::endl;\n    } else {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "DeepSeek-V3.1_completion_1": "std::string decryptedtext;\n    if (!encryptMessage(plaintext, ciphertext, key)) {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "DeepSeek-V3.1_completion_2": "if (encryptMessage(plaintext, ciphertext, key)) {\n        std::cout << \"Ciphertext: \" << ciphertext << std::endl;\n    } else {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "DeepSeek-V3.1_completion_3": "std::string decryptedtext;\n    if (encryptMessage(plaintext, ciphertext, key)) {\n        // Decryption code would go here if needed\n    } else {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "DeepSeek-V3.1_completion_4": "    if (encryptMessage(plaintext, ciphertext, key)) {\n        std::cout << \"Ciphertext: \" << ciphertext << std::endl;\n    } else {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "DeepSeek-V3.1_completions": ["if (encryptMessage(plaintext, ciphertext, key)) {\n        std::cout << \"Ciphertext: \" << ciphertext << std::endl;\n    } else {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "std::string decryptedtext;\n    if (!encryptMessage(plaintext, ciphertext, key)) {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "if (encryptMessage(plaintext, ciphertext, key)) {\n        std::cout << \"Ciphertext: \" << ciphertext << std::endl;\n    } else {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "std::string decryptedtext;\n    if (encryptMessage(plaintext, ciphertext, key)) {\n        // Decryption code would go here if needed\n    } else {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }", "    if (encryptMessage(plaintext, ciphertext, key)) {\n        std::cout << \"Ciphertext: \" << ciphertext << std::endl;\n    } else {\n        std::cerr << \"Encryption failed.\" << std::endl;\n        return 1;\n    }"]}
{"id": "10", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <Eigen/Dense>\n#include <cassert>\n\n// This example demonstrates the use of Eigen library for linear algebra\n// operations. Eigen is a C++ template library for linear algebra: matrices,\n// vectors, numerical solvers, and related algorithms.\n\nusing namespace Eigen;\n\n// Function to initialize a matrix with some values\nMatrixXd initializeMatrix(int rows, int cols) {\n    MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i + j;\n        }\n    }\n    return mat;\n}\n\n// Function to perform matrix multiplication using Eigen\nMatrixXd multiplyMatrices(const MatrixXd& mat1, const MatrixXd& mat2) {\n    assert(mat1.cols() == mat2.rows());\n    return mat1 * mat2;\n}\n\n// Function to perform matrix addition using Eigen\nMatrixXd addMatrices(const MatrixXd& mat1, const MatrixXd& mat2) {\n    assert(mat1.rows() == mat2.rows() && mat1.cols() == mat2.cols());\n    return mat1 + mat2;\n}\n\nint main() {\n    // Initialize two matrices\n    MatrixXd mat1 = initializeMatrix(3, 3);\n    MatrixXd mat2 = initializeMatrix(3, 3);\n\n    // Perform matrix multiplication and addition\n    MatrixXd resultMul = multiplyMatrices(mat1, mat2);\n    MatrixXd resultAdd = addMatrices(mat1, mat2);\n\n    // Print the results\n    std::cout << \"Matrix Multiplication Result:\\n\" << resultMul << std::endl;\n    std::cout << \"Matrix Addition Result:\\n\" << resultAdd << std::endl;\n\n    // Now, let's test a rare and uncommon function of Eigen: matrix decomposition\n", "suffix": "\n\n    // Validate the decomposition: P * A = L * U, so A = P^(-1) * L * U\n    MatrixXd reconstructed = luDecomp.permutationP().inverse() * L * U;\n    assert((reconstructed - mat1).norm() < 1e-9);\n\n    // Print the L and U matrices\n    std::cout << \"L matrix:\\n\" << L << std::endl;\n    std::cout << \"U matrix:\\n\" << U << std::endl;\n\n    return 0;\n}\n", "golden_completion": "    // Perform LU decomposition with partial pivoting\n    PartialPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.cols());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU().triangularView<StrictlyLower>();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();\n\n", "LLM_justification": "This test case is a good example as it tests the model's ability to recognize and complete a rare API usage pattern involving Eigen library's LU decomposition functions. LU decomposition is not commonly used compared to basic operations like matrix multiplication and addition, and it requires a correct understanding of matrix properties and Eigen's API conventions. The completion demonstrates proper API usage, parameter ordering, and error checking using assertions to validate the correctness of the decomposition.", "assertions": "", "DeepSeek-V3.1_completion_0": "    // Perform LU decomposition with full pivoting\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.cols());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();", "DeepSeek-V3.1_completion_1": "    // Perform LU decomposition with full pivoting\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.rows());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();", "DeepSeek-V3.1_completion_2": "    // Perform LU decomposition with partial pivoting\n    PartialPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = luDecomp.matrixLU().triangularView<StrictlyLower>();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();\n    L.diagonal().setOnes();", "DeepSeek-V3.1_completion_3": "    // Perform LU decomposition with full pivoting\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.rows());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();", "DeepSeek-V3.1_completion_4": "    // Perform LU decomposition with full pivoting\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.cols());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();", "DeepSeek-V3.1_completions": ["    // Perform LU decomposition with full pivoting\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.cols());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();", "    // Perform LU decomposition with full pivoting\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.rows());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();", "    // Perform LU decomposition with partial pivoting\n    PartialPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = luDecomp.matrixLU().triangularView<StrictlyLower>();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();\n    L.diagonal().setOnes();", "    // Perform LU decomposition with full pivoting\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.rows());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();", "    // Perform LU decomposition with full pivoting\n    FullPivLU<MatrixXd> luDecomp(mat1);\n    MatrixXd L = MatrixXd::Identity(mat1.rows(), mat1.cols());\n    L.triangularView<StrictlyLower>() = luDecomp.matrixLU();\n    MatrixXd U = luDecomp.matrixLU().triangularView<Upper>();"]}
{"id": "11", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <harfbuzz/hb.h>\n\nvoid initialize_harfuzz(hb_buffer_t** buffer, hb_font_t** font) {\n    // Create HarfBuzz buffer and set properties\n    *buffer = hb_buffer_create();\n    if (!*buffer) {\n        std::cerr << \"Failed to create HarfBuzz buffer\" << std::endl;\n        return;\n    }\n    \n    hb_buffer_set_direction(*buffer, HB_DIRECTION_LTR);\n    hb_buffer_set_script(*buffer, HB_SCRIPT_LATIN);\n    hb_buffer_set_language(*buffer, hb_language_from_string(\"en\", -1));\n\n    // Create HarfBuzz font using empty face for API testing\n    *font = hb_font_create(hb_face_get_empty());\n    if (!*font) {\n        std::cerr << \"Failed to create HarfBuzz font\" << std::endl;\n        hb_buffer_destroy(*buffer);\n        return;\n    }\n    \n    // Set basic font properties for testing\n    hb_font_set_scale(*font, 1000, 1000);\n\n    // Add text and shape it\n    hb_buffer_add_utf8(*buffer, \"Hello, HarfBuzz!\", -1, 0, -1);\n    hb_shape(*font, *buffer, nullptr, 0);\n}\n\nvoid print_glyph_info(hb_buffer_t* buffer) {\n    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n\n    for (unsigned int i = 0; i < glyph_count; i++) {\n        std::cout << \"Glyph ID: \" << glyph_info[i].codepoint << std::endl;\n    }\n}\n\nint main() {\n    hb_buffer_t* buffer = nullptr;\n    hb_font_t* font = nullptr;\n    initialize_harfuzz(&buffer, &font);\n", "suffix": "    assert(glyph_count > 0);\n    assert(glyph_info != nullptr);\n    assert(glyph_positions != nullptr);\n\n    hb_buffer_destroy(buffer);\n    hb_font_destroy(font);\n\n    return 0;\n}", "golden_completion": "    print_glyph_info(buffer);\n    \n    // Extract glyph positioning information using HarfBuzz API\n    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n    hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);\n    \n    std::cout << \"Glyph count: \" << glyph_count << std::endl;\n    for (unsigned int i = 0; i < glyph_count; i++) {\n        std::cout << \"Glyph \" << i << \": ID=\" << glyph_info[i].codepoint \n                  << \", x_advance=\" << glyph_positions[i].x_advance \n                  << \", y_advance=\" << glyph_positions[i].y_advance \n                  << \", x_offset=\" << glyph_positions[i].x_offset \n                  << \", y_offset=\" << glyph_positions[i].y_offset << std::endl;\n    }\n", "LLM_justification": "This test case involves using the HarfBuzz library for text shaping, which is a complex and less commonly used library in C++. The example has been made self-contained by removing external font dependencies and using HarfBuzz's built-in empty face functionality. This scenario tests the LLM's ability to understand and correctly use the HarfBuzz API, including creating buffers, setting directions, scripts, languages, and shaping text. The correct usage of these APIs and proper resource management are critical, making this a good test case for uncommon API usage while being robust and reliable.", "assertions": "", "DeepSeek-V3.1_completion_0": "    if (buffer && font) {\n        unsigned int glyph_count;\n        hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n        hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);", "DeepSeek-V3.1_completion_1": "    if (buffer && font) {\n        unsigned int glyph_count;\n        hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n        hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);\n        \n        print_glyph_info(buffer);", "DeepSeek-V3.1_completion_2": "    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n    hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);", "DeepSeek-V3.1_completion_3": "    if (buffer && font) {\n        unsigned int glyph_count;\n        hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n        hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);", "DeepSeek-V3.1_completion_4": "    if (buffer && font) {\n        unsigned int glyph_count;\n        hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n        hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);", "DeepSeek-V3.1_completions": ["    if (buffer && font) {\n        unsigned int glyph_count;\n        hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n        hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);", "    if (buffer && font) {\n        unsigned int glyph_count;\n        hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n        hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);\n        \n        print_glyph_info(buffer);", "    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n    hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);", "    if (buffer && font) {\n        unsigned int glyph_count;\n        hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n        hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);", "    if (buffer && font) {\n        unsigned int glyph_count;\n        hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n        hb_glyph_position_t* glyph_positions = hb_buffer_get_glyph_positions(buffer, &glyph_count);"]}
{"id": "12", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// This program demonstrates the use of Eigen library for scientific computing\n// We will define a helper function to initialize matrices and perform some operations.\n\nusing namespace Eigen;\n\nvoid initialize_matrices(MatrixXd &matA, MatrixXd &matB) {\n\t// Initialize matrix A (3x3)\n\tmatA << 1, 2, 3,\n\t\t\t 4, 5, 6,\n\t\t\t 7, 8, 9;\n\t// Initialize matrix B (3x3)\n\tmatB << 9, 8, 7,\n\t\t\t 6, 5, 4,\n\t\t\t 3, 2, 1;\n}\n\nMatrixXd perform_operations(const MatrixXd &matA, const MatrixXd &matB) {\n\tMatrixXd result;\n\t// Perform matrix addition\n\tresult = matA + matB;\n\treturn result;\n}\n\nint main() {\n\tMatrixXd matA(3, 3);\n\tMatrixXd matB(3, 3);\n\tinitialize_matrices(matA, matB);\n\tMatrixXd result = perform_operations(matA, matB);\n\tstd::cout << \"Result of matrix addition:\\n\" << result << std::endl;\n\n\t// Additional operations will be performed below\n", "suffix": "\n\t// Assertions to verify correctness\n\tassert(result_mult(0, 0) == 8);\n\tassert(result_mult(1, 1) == 30);\n\tassert(result_mult(2, 2) == 60);\n\n\t// Additional Eigen operations for testing\n\tassert(matC.determinant() > 0);\n\tassert(matC.trace() == 12);\n\n\treturn 0;\n}\n", "golden_completion": "\tMatrixXd matC(3, 3);\n\tmatC << 3, 1, 1,\n\t\t\t 1, 4, 1,\n\t\t\t 1, 1, 5;\n\n\t// Perform comprehensive Eigen matrix operations\n\tMatrixXd result_mult = matA * matC;\n\tstd::cout << \"Result of matrix multiplication:\\n\" << result_mult << std::endl;\n\n\t// Test advanced Eigen features: matrix decomposition\n\tJacobiSVD<MatrixXd> svd(matA, ComputeFullU | ComputeFullV);\n\tstd::cout << \"Singular values of matA:\\n\" << svd.singularValues() << std::endl;\n\n\t// Test matrix norms and properties\n\tdouble frobenius_norm = matA.norm();\n\tdouble trace_value = matC.trace();\n\tdouble determinant_value = matC.determinant();\n\tstd::cout << \"Frobenius norm of matA: \" << frobenius_norm << std::endl;\n\tstd::cout << \"Trace of matC: \" << trace_value << std::endl;\n\tstd::cout << \"Determinant of matC: \" << determinant_value << std::endl;\n\n", "LLM_justification": "This test case demonstrates the use of the Eigen library, which is less commonly used compared to standard libraries. The focus is on matrix initialization and operations such as addition and multiplication. The test case ensures the LLM can recognize and correctly complete patterns involving Eigen's matrix operations. Assertions verify the correctness of matrix multiplication results, checking specific elements in the resulting matrix. This is a good test case because it involves scientific computing with clear and uncommon API usage, making it a suitable benchmark for testing LLM capabilities in recognizing and completing advanced C++ code patterns.", "assertions": "", "DeepSeek-V3.1_completion_0": "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA + MatrixXd::Identity(3,3);", "DeepSeek-V3.1_completion_1": "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA + MatrixXd::Identity(3,3);", "DeepSeek-V3.1_completion_2": "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA.transpose() * matB;", "DeepSeek-V3.1_completion_3": "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA + MatrixXd::Identity(3,3);", "DeepSeek-V3.1_completion_4": "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA.transpose() * matB;", "DeepSeek-V3.1_completions": ["\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA + MatrixXd::Identity(3,3);", "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA + MatrixXd::Identity(3,3);", "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA.transpose() * matB;", "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA + MatrixXd::Identity(3,3);", "\tMatrixXd result_mult = matA * matB;\n\tMatrixXd matC = matA.transpose() * matB;"]}
{"id": "13", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n\nclass FontRenderer {\npublic:\n    FontRenderer() : library(nullptr), face(nullptr), initialized(false) {}\n\n    bool initialize() {\n        FT_Error error = FT_Init_FreeType(&library);\n        if (error) {\n            std::cerr << \"Failed to initialize FreeType library.\" << std::endl;\n            return false;\n        }\n        initialized = true;\n        return true;\n    }\n\n    bool createSyntheticFont() {\n        if (!initialized) {\n            std::cerr << \"FreeType library not initialized.\" << std::endl;\n            return false;\n        }\n        \n        // For API testing purposes, we'll create a simple synthetic approach\n        // This tests the FreeType API without requiring external font files\n        std::cout << \"Creating synthetic font for FreeType API testing...\" << std::endl;\n        \n        // Note: In a real implementation, you would load actual font data\n        // For testing, we'll simulate successful font loading\n        return true;\n    }\n\n    void setFontSize(int pixelWidth, int pixelHeight) {\n        if (face) {\n            FT_Set_Pixel_Sizes(face, pixelWidth, pixelHeight);\n        }\n        std::cout << \"Font size set to \" << pixelWidth << \"x\" << pixelHeight << \" pixels.\" << std::endl;\n    }\n\n    bool renderGlyph(char character) {\n        if (!initialized) {\n            std::cerr << \"FreeType library not initialized.\" << std::endl;\n            return false;\n        }\n        \n        std::cout << \"Simulating glyph rendering for character '\" << character << \"'\" << std::endl;\n        \n        // For API testing without actual font data, we simulate successful rendering\n        // In real usage, this would involve FT_Load_Glyph and FT_Render_Glyph\n        return true;\n    }\n\n    FT_Library getLibrary() const { return library; }\n    bool isInitialized() const { return initialized; }\n\n    ~FontRenderer() {\n        if (face) {\n            FT_Done_Face(face);\n        }\n        if (library) {\n            FT_Done_FreeType(library);\n        }\n    }\n\nprivate:\n    FT_Library library;\n    FT_Face face;\n    bool initialized;\n};\n\nint main() {\n    FontRenderer renderer;\n    assert(renderer.initialize() && \"FreeType library initialization failed.\");\n    assert(renderer.createSyntheticFont() && \"Synthetic font creation failed.\");\n    renderer.setFontSize(12, 12);\n", "suffix": "\n    std::cout << \"FreeType API test completed successfully.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    bool glyphResult = renderer.renderGlyph('A');\n    assert(glyphResult && \"Glyph rendering failed.\");\n    \n    // Test FreeType library API functions\n    assert(renderer.getLibrary() != nullptr && \"FreeType library is null.\");\n    assert(renderer.isInitialized() && \"FreeType library not properly initialized.\");\n    \n    std::cout << \"FreeType glyph rendering test completed successfully.\" << std::endl;\n", "LLM_justification": "This example uses the FreeType library, which is commonly used for font rendering but involves a somewhat complex API. The example has been made self-contained by removing external font dependencies and focusing on the core FreeType API testing. The test demonstrates proper initialization of the FreeType library, font handling concepts, and basic rendering workflow without requiring actual font files. This scenario is a good test case because it involves several FreeType API functions in the correct sequence while being robust and reliable for testing environments.", "assertions": "", "DeepSeek-V3.1_completion_0": "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "DeepSeek-V3.1_completion_1": "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "DeepSeek-V3.1_completion_2": "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "DeepSeek-V3.1_completion_3": "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "DeepSeek-V3.1_completion_4": "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "DeepSeek-V3.1_completions": ["    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");", "    assert(renderer.renderGlyph('A') && \"Glyph rendering failed.\");"]}
{"id": "14", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <harfbuzz/hb.h>\n#include <cassert>\n\nclass HarfBuzzExample {\npublic:\n    HarfBuzzExample() : hb_buffer(nullptr), hb_font(nullptr) {}\n    ~HarfBuzzExample() { cleanup(); }\n\n    void initialize() {\n        // Create a HarfBuzz buffer\n        hb_buffer = hb_buffer_create();\n        if (!hb_buffer) {\n            throw std::runtime_error(\"Could not create HarfBuzz buffer\");\n        }\n\n        // Create a HarfBuzz font using empty face for API testing\n        hb_font = hb_font_create(hb_face_get_empty());\n        if (!hb_font) {\n            throw std::runtime_error(\"Could not create HarfBuzz font\");\n        }\n        \n        // Set basic font properties for testing\n        hb_font_set_scale(hb_font, 1000, 1000);\n    }\n\n    void shapeText(const char* text) {\n        // Set the text to shape\n        hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);\n        hb_buffer_guess_segment_properties(hb_buffer);\n    }\n\n    void cleanup() {\n        if (hb_font) {\n            hb_font_destroy(hb_font);\n            hb_font = nullptr;\n        }\n        if (hb_buffer) {\n            hb_buffer_destroy(hb_buffer);\n            hb_buffer = nullptr;\n        }\n    }\n\n    hb_buffer_t* getBuffer() const { return hb_buffer; }\n    hb_font_t* getFont() const { return hb_font; }\n\nprivate:\n    hb_buffer_t* hb_buffer;\n    hb_font_t* hb_font;\n};\n\nint main() {\n    HarfBuzzExample example;\n    example.initialize();\n    example.shapeText(\"Hello, world!\");\n", "suffix": "    hb_buffer_t* buffer = example.getBuffer();\n    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n    hb_glyph_position_t* glyph_pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);\n\n    // Assertions to verify the shaping results\n    assert(glyph_count > 0);\n    for (unsigned int i = 0; i < glyph_count; ++i) {\n        assert(glyph_info[i].codepoint != 0);\n        // Note: advance values may be 0 for synthetic fonts\n    }\n\n    // Cleanup and exit\n    example.cleanup();\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    hb_shape(example.getFont(), example.getBuffer(), nullptr, 0);\n", "LLM_justification": "This test case uses the HarfBuzz library to demonstrate text shaping, which is a less common but powerful API for text processing. The example has been made self-contained by removing external font dependencies and using HarfBuzz's built-in empty face functionality. The example includes initialization, text shaping, and cleanup, ensuring proper resource management. The golden completion involves the `hb_shape` function, which is crucial for text shaping but less commonly known. The suffix includes assertions to verify the behavior of the `hb_shape` function, ensuring the glyph information and positions are correctly populated. This scenario tests the model's ability to recognize and complete uncommon API usage patterns, manage resources, and verify API behavior through assertions while being robust and reliable.", "assertions": "", "DeepSeek-V3.1_completion_0": "    hb_shape(example.getFont(), buffer, nullptr, 0);", "DeepSeek-V3.1_completion_1": "    hb_shape(example.getFont(), buffer, nullptr, 0);", "DeepSeek-V3.1_completion_2": "    hb_shape(example.getFont(), buffer, nullptr, 0);", "DeepSeek-V3.1_completion_3": "    hb_buffer_t* buffer = example.getBuffer();\n    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n    hb_glyph_position_t* glyph_pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);\n\n    // Assertions to verify the shaping results\n    assert(glyph_count > 0);\n    for (unsigned int i = 0; i < glyph_count; ++i) {\n        assert(glyph_info[i].codepoint != 0);\n        // Note: advance values may be 0 for synthetic fonts\n    }\n\n    // Cleanup and exit\n    example.cleanup();\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;", "DeepSeek-V3.1_completion_4": "    hb_shape(example.getFont(), buffer, nullptr, 0);", "DeepSeek-V3.1_completions": ["    hb_shape(example.getFont(), buffer, nullptr, 0);", "    hb_shape(example.getFont(), buffer, nullptr, 0);", "    hb_shape(example.getFont(), buffer, nullptr, 0);", "    hb_buffer_t* buffer = example.getBuffer();\n    unsigned int glyph_count;\n    hb_glyph_info_t* glyph_info = hb_buffer_get_glyph_infos(buffer, &glyph_count);\n    hb_glyph_position_t* glyph_pos = hb_buffer_get_glyph_positions(buffer, &glyph_count);\n\n    // Assertions to verify the shaping results\n    assert(glyph_count > 0);\n    for (unsigned int i = 0; i < glyph_count; ++i) {\n        assert(glyph_info[i].codepoint != 0);\n        // Note: advance values may be 0 for synthetic fonts\n    }\n\n    // Cleanup and exit\n    example.cleanup();\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;", "    hb_shape(example.getFont(), buffer, nullptr, 0);"]}
{"id": "15", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n\n// Utility functions to handle deprecated APIs\nvoid deprecated_fopen_example(const char* filename, const char* mode) {\n    FILE* file = fopen(filename, mode);\n    if (file) {\n        std::cout << \"File opened successfully\" << std::endl;\n        fclose(file);\n    } else {\n        std::cerr << \"Failed to open file\" << std::endl;\n    }\n}\n\nclass LegacyFileHandler {\npublic:\n    LegacyFileHandler(const char* filename, const char* mode) {\n        file_ = fopen(filename, mode);\n        if (!file_) {\n            throw std::runtime_error(\"Failed to open file\");\n        }\n    }\n\n    ~LegacyFileHandler() {\n        if (file_) {\n            fclose(file_);\n        }\n    }\n\n    void write(const char* data) {\n        if (file_) {\n            fwrite(data, sizeof(char), strlen(data), file_);\n        }\n    }\n\n    void read(char* buffer, size_t size) {\n        if (file_) {\n            fread(buffer, sizeof(char), size, file_);\n        }\n    }\n\nprivate:\n    FILE* file_;\n};\n\nint main() {\n    const char* filename = \"test.txt\";\n    const char* write_data = \"Hello, World!\";\n    char read_buffer[50] = {0};\n    try {\n", "suffix": "    } catch (const std::exception& ex) {\n        std::cerr << \"Exception: \" << ex.what() << std::endl;\n        return 1;\n    }\n\n    // Assertions to verify correct behavior\n    FILE* file = fopen(filename, \"r\");\n    assert(file != nullptr);\n    fread(read_buffer, sizeof(char), strlen(write_data), file);\n    assert(strcmp(read_buffer, write_data) == 0);\n    fclose(file);\n\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "        {\n            LegacyFileHandler writer(filename, \"w\");\n            writer.write(write_data);\n        }\n        {\n            LegacyFileHandler reader(filename, \"r\");\n            reader.read(read_buffer, sizeof(read_buffer));\n        }\n        assert(strcmp(read_buffer, write_data) == 0);\n", "LLM_justification": "This test case is a good example because it involves deprecated file handling APIs (`fopen`, `fwrite`, `fread`, `fclose`) and demonstrates how to correctly use these APIs within the context of a C++ class. The completion requires the model to recognize the pattern of file operations and use the correct sequence of function calls, parameter ordering, and error handling. The assertions verify that the file operations were performed correctly, ensuring the integrity of the data written and read from the file. This tests the model's ability to understand and complete deprecated API usage patterns, which are still relevant in maintaining legacy codebases.", "assertions": "", "DeepSeek-V3.1_completion_0": "        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }\n    {\n        LegacyFileHandler handler(filename, \"r\");\n        handler.read(read_buffer, sizeof(read_buffer));", "DeepSeek-V3.1_completion_1": "        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }\n    try {\n        LegacyFileHandler handler(filename, \"r\");\n        handler.read(read_buffer, sizeof(read_buffer));", "DeepSeek-V3.1_completion_2": "{\n        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }", "DeepSeek-V3.1_completion_3": "        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }\n    try {\n        LegacyFileHandler handler(filename, \"r\");\n        handler.read(read_buffer, sizeof(read_buffer));", "DeepSeek-V3.1_completion_4": "        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }\n    {\n        LegacyFileHandler handler(filename, \"r\");\n        handler.read(read_buffer, sizeof(read_buffer));", "DeepSeek-V3.1_completions": ["        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }\n    {\n        LegacyFileHandler handler(filename, \"r\");\n        handler.read(read_buffer, sizeof(read_buffer));", "        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }\n    try {\n        LegacyFileHandler handler(filename, \"r\");\n        handler.read(read_buffer, sizeof(read_buffer));", "{\n        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }", "        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }\n    try {\n        LegacyFileHandler handler(filename, \"r\");\n        handler.read(read_buffer, sizeof(read_buffer));", "        LegacyFileHandler handler(filename, \"w\");\n        handler.write(write_data);\n    }\n    {\n        LegacyFileHandler handler(filename, \"r\");\n        handler.read(read_buffer, sizeof(read_buffer));"]}
{"id": "16", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n/*\n * This example demonstrates the usage of the Eigen library, specifically dealing with SVD (Singular Value Decomposition) and solving systems of linear equations.\n * Eigen is a C++ template library for linear algebra.\n */\n\nvoid printMatrix(const Eigen::MatrixXd &matrix) {\n    for (int i = 0; i < matrix.rows(); ++i) {\n        for (int j = 0; j < matrix.cols(); ++j) {\n            std::cout << matrix(i, j) << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    // Define a 3x3 matrix\n    Eigen::MatrixXd A(3, 3);\n    A << 1, 2, 3,\n         4, 5, 7,\n         8, 9, 10;\n\n    // Define a 3x1 vector\n    Eigen::VectorXd b(3);\n    b << 1,\n         0,\n         1;\n\n    // Print matrix A\n    std::cout << \"Matrix A:\" << std::endl;\n    printMatrix(A);\n\n    // Print vector b\n    std::cout << \"Vector b:\" << std::endl;\n    for (int i = 0; i < b.size(); ++i) {\n        std::cout << b(i) << std::endl;\n    }\n\n    // Compute the SVD of matrix A\n    Eigen::JacobiSVD<Eigen::MatrixXd> svd(A, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values of A:\" << std::endl;\n    std::cout << svd.singularValues() << std::endl;\n\n    // The SVD solves the system Ax = b\n    Eigen::VectorXd x;\n", "suffix": "\n    std::cout << \"Solution x:\" << std::endl;\n    for (int i = 0; i < x.size(); ++i) {\n        std::cout << x(i) << std::endl;\n    }\n\n    // Assertions to ensure correctness\n    Eigen::VectorXd b_reconstructed = A * x;\n    assert((b - b_reconstructed).norm() < 1e-6);\n    assert(svd.rank() == 3);\n    assert(svd.singularValues()(0) > svd.singularValues()(1));\n\n    return 0;\n}\n", "golden_completion": "    x = svd.solve(b);\n", "LLM_justification": "This test case demonstrates the usage of the Eigen library for linear algebra, specifically focusing on Singular Value Decomposition (SVD) and solving a system of linear equations. The example sets up a matrix and a vector, computes the SVD, and solves the system. Assertions are included to verify the correctness of the solution, ensuring that the reconstructed vector matches the original vector, the rank is correctly identified, and the singular values are in descending order. This tests the model's ability to handle a less commonly used library (Eigen) and correctly utilize its API for advanced mathematical operations.", "assertions": "", "DeepSeek-V3.1_completion_0": "    x = svd.solve(b);", "DeepSeek-V3.1_completion_1": "    x = svd.solve(b);", "DeepSeek-V3.1_completion_2": "    x = svd.solve(b);", "DeepSeek-V3.1_completion_3": "    x = svd.solve(b);", "DeepSeek-V3.1_completion_4": "    x = svd.solve(b);", "DeepSeek-V3.1_completions": ["    x = svd.solve(b);", "    x = svd.solve(b);", "    x = svd.solve(b);", "    x = svd.solve(b);", "    x = svd.solve(b);"]}
{"id": "17", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <stdexcept>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <cassert>\n\nclass AESCipher {\npublic:\n    AESCipher() : ctx(EVP_CIPHER_CTX_new()), ciphertext_len(0) {\n        if (!ctx) {\n            throw std::runtime_error(\"Failed to create EVP_CIPHER_CTX\");\n        }\n    }\n\n    ~AESCipher() {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n\n    void encrypt(const unsigned char *plaintext, int plaintext_len, const unsigned char *key, const unsigned char *iv, unsigned char *ciphertext) {\n        int len;\n        if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv)) {\n            throw std::runtime_error(\"Failed to initialize encryption\");\n        }\n        if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {\n            throw std::runtime_error(\"Failed to encrypt data\");\n        }\n        ciphertext_len = len;\n        \n        int final_len;\n        if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &final_len)) {\n            throw std::runtime_error(\"Failed to finalize encryption\");\n        }\n        ciphertext_len += final_len;\n    }\n\n    int get_ciphertext_len() const {\n        return ciphertext_len;\n    }\n\nprivate:\n    EVP_CIPHER_CTX *ctx;\n    int ciphertext_len;\n};\n\nint main() {\n    AESCipher cipher;\n    unsigned char key[32];\n    unsigned char iv[16];\n    unsigned char plaintext[] = \"This is a test.\";\n    unsigned char ciphertext[128];\n\n    if (!RAND_bytes(key, sizeof(key)) || !RAND_bytes(iv, sizeof(iv))) {\n        std::cerr << \"Failed to generate key/iv\" << std::endl;\n        return 1;\n    }\n\n    try {\n", "suffix": "\n        // Verify the length of the ciphertext\n        assert(cipher.get_ciphertext_len() > 0);\n        std::cout << \"Ciphertext length: \" << cipher.get_ciphertext_len() << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n", "golden_completion": "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving the OpenSSL EVP encryption API, which is uncommon and complex. The golden completion properly integrates the AES encryption process using the OpenSSL library. The prefix sets up the context with key and IV generation, and the suffix includes the verification of the ciphertext length. This scenario effectively tests the LLM's understanding of correct parameter ordering, error handling, and resource management within the OpenSSL API.", "assertions": "", "DeepSeek-V3.1_completion_0": "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "DeepSeek-V3.1_completion_1": "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "DeepSeek-V3.1_completion_2": "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "DeepSeek-V3.1_completion_3": "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "DeepSeek-V3.1_completion_4": "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "DeepSeek-V3.1_completions": ["        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);", "        cipher.encrypt(plaintext, sizeof(plaintext) - 1, key, iv, ciphertext);"]}
{"id": "18", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <openssl/bio.h>\n#include <openssl/evp.h>\n#include <openssl/buffer.h>\n\nclass Base64Encoder {\npublic:\n    Base64Encoder() : bio(nullptr), b64(nullptr) {}\n    \n    ~Base64Encoder() {\n        if (bio) {\n            BIO_free_all(bio);\n        }\n    }\n    \n    std::string encode(const std::string& input) {\n        BIO* b64 = BIO_new(BIO_f_base64());\n        BIO* bmem = BIO_new(BIO_s_mem());\n        bio = BIO_push(b64, bmem);\n        \n        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);\n        BIO_write(bio, input.c_str(), input.length());\n        BIO_flush(bio);\n        \n        BUF_MEM* bptr;\n        BIO_get_mem_ptr(bio, &bptr);\n        \n        std::string result(bptr->data, bptr->length);\n        return result;\n    }\n    \n    std::string decode(const std::string& encoded) {\n        BIO* b64 = BIO_new(BIO_f_base64());\n        BIO* bmem = BIO_new_mem_buf(encoded.c_str(), encoded.length());\n        bio = BIO_push(b64, bmem);\n        \n        BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);\n        \n        char buffer[1024];\n        int decoded_length = BIO_read(bio, buffer, sizeof(buffer));\n        \n        return std::string(buffer, decoded_length);\n    }\n    \nprivate:\n    BIO* bio;\n    BIO* b64;\n};\n\nint main() {\n    std::string original_text = \"Hello, world!\";\n    Base64Encoder encoder;\n    \n", "suffix": "    \n    // Decode the base64 string\n    std::string decoded_text = encoder.decode(encoded_text);\n    \n    // Assertions to validate the encoding/decoding\n    assert(!encoded_text.empty());\n    assert(decoded_text == original_text);\n    assert(encoded_text != original_text);\n    \n    std::cout << \"Original: \" << original_text << std::endl;\n    std::cout << \"Encoded: \" << encoded_text << std::endl;\n    std::cout << \"Decoded: \" << decoded_text << std::endl;\n    std::cout << \"All assertions passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    // Encode the text to base64\n    std::string encoded_text = encoder.encode(original_text);", "LLM_justification": "This test case demonstrates the use of OpenSSL's BIO functions for base64 encoding and decoding, which is a less common but important API usage pattern. The test involves creating a Base64Encoder class that uses OpenSSL's BIO (Basic Input/Output) abstraction to handle base64 transformations. The golden completion requires the model to understand the proper sequence of encoding before decoding, and the suffix includes assertions to verify that the encoding/decoding process works correctly. This scenario tests the LLM's ability to recognize and correctly use OpenSSL BIO functions, handle resource management, and understand the relationship between encoding and decoding operations.", "assertions": "", "DeepSeek-V3.1_completion_0": "    std::string encoded_text = encoder.encode(original_text);", "DeepSeek-V3.1_completion_1": "    std::string encoded_text = encoder.encode(original_text);", "DeepSeek-V3.1_completion_2": "    std::string encoded_text = encoder.encode(original_text);", "DeepSeek-V3.1_completion_3": "    std::string encoded_text = encoder.encode(original_text);", "DeepSeek-V3.1_completion_4": "    std::string encoded_text = encoder.encode(original_text);", "DeepSeek-V3.1_completions": ["    std::string encoded_text = encoder.encode(original_text);", "    std::string encoded_text = encoder.encode(original_text);", "    std::string encoded_text = encoder.encode(original_text);", "    std::string encoded_text = encoder.encode(original_text);", "    std::string encoded_text = encoder.encode(original_text);"]}
{"id": "19", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\nvoid handleErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nint main() {\n    // Input data to be hashed\n    const char *message = \"The quick brown fox jumps over the lazy dog\";\n    unsigned char md_value[EVP_MAX_MD_SIZE];\n    unsigned int md_len;\n\n    // Create a message digest context\n    EVP_MD_CTX *mdctx;\n    mdctx = EVP_MD_CTX_new();\n    if(mdctx == NULL) handleErrors();\n\n    // Initialize the context for MD5\n    if(1 != EVP_DigestInit_ex(mdctx, EVP_md5(), NULL)) handleErrors();\n\n    // Provide the message to be hashed\n    if(1 != EVP_DigestUpdate(mdctx, message, strlen(message))) handleErrors();\n", "suffix": "\n\n    // Verify the length of the hash\n    assert(md_len == 16); // MD5 hash length is always 16 bytes\n\n    // Clean up\n    EVP_MD_CTX_free(mdctx);\n\n    std::cout << \"Hash computed successfully.\" << std::endl;\n\n    return 0;\n}", "golden_completion": "    // Finalize the digest\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "LLM_justification": "This test case demonstrates the usage of the OpenSSL EVP API to compute an MD5 hash, which is a less common but important API usage pattern. The test involves creating a digest context, initializing it for MD5, updating it with data, and finalizing the hash computation. The golden completion requires the model to understand the proper sequence of EVP digest operations and correctly finalize the hash. The suffix includes assertions to verify the correct length of the MD5 hash and proper resource cleanup. This scenario tests the LLM's ability to recognize and complete the OpenSSL EVP digest API pattern correctly and manage resources properly.", "assertions": "", "DeepSeek-V3.1_completion_0": "    // Finalize the hash\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "DeepSeek-V3.1_completion_1": "    // Finalize the hash and get the result\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "DeepSeek-V3.1_completion_2": "    // Finalize the hash and get the value\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "DeepSeek-V3.1_completion_3": "    // Finalize the hash\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "DeepSeek-V3.1_completion_4": "    // Finalize the hash\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "DeepSeek-V3.1_completions": ["    // Finalize the hash\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "    // Finalize the hash and get the result\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "    // Finalize the hash and get the value\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "    // Finalize the hash\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();", "    // Finalize the hash\n    if(1 != EVP_DigestFinal_ex(mdctx, md_value, &md_len)) handleErrors();"]}
{"id": "20", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <openssl/hmac.h>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n\nclass HMACVerifier {\npublic:\n    HMACVerifier() : ctx(nullptr) {\n        ctx = HMAC_CTX_new();\n        if (!ctx) {\n            throw std::runtime_error(\"Failed to create HMAC context\");\n        }\n    }\n    \n    ~HMACVerifier() {\n        if (ctx) {\n            HMAC_CTX_free(ctx);\n        }\n    }\n    \n    bool initialize(const unsigned char* key, int key_len) {\n        return HMAC_Init_ex(ctx, key, key_len, EVP_sha256(), nullptr) == 1;\n    }\n    \n    bool update(const unsigned char* data, size_t data_len) {\n        return HMAC_Update(ctx, data, data_len) == 1;\n    }\n    \n    bool finalize(unsigned char* digest, unsigned int* digest_len) {\n        return HMAC_Final(ctx, digest, digest_len) == 1;\n    }\n    \n    bool verify(const unsigned char* expected_digest, unsigned int expected_len, const unsigned char* actual_digest, unsigned int actual_len) {\n        if (expected_len != actual_len) return false;\n        return CRYPTO_memcmp(expected_digest, actual_digest, expected_len) == 0;\n    }\n    \nprivate:\n    HMAC_CTX* ctx;\n};\n\nint main() {\n    try {\n        HMACVerifier verifier;\n        const char* key = \"secret_key\";\n        const char* message = \"Hello, HMAC!\";\n        unsigned char digest[EVP_MAX_MD_SIZE];\n        unsigned int digest_len;\n        \n        // Initialize HMAC with key\n        assert(verifier.initialize(reinterpret_cast<const unsigned char*>(key), strlen(key)));\n        \n        // Update with message data\n        assert(verifier.update(reinterpret_cast<const unsigned char*>(message), strlen(message)));\n        \n", "suffix": "        \n        // Create a second verifier for comparison\n        HMACVerifier verifier2;\n        unsigned char digest2[EVP_MAX_MD_SIZE];\n        unsigned int digest2_len;\n        \n        assert(verifier2.initialize(reinterpret_cast<const unsigned char*>(key), strlen(key)));\n        assert(verifier2.update(reinterpret_cast<const unsigned char*>(message), strlen(message)));\n        assert(verifier2.finalize(digest2, &digest2_len));\n        \n        // Verify both digests are identical\n        assert(verifier.verify(digest, digest_len, digest2, digest2_len));\n        assert(digest_len == 32); // SHA-256 output size\n        \n        std::cout << \"HMAC verification successful!\" << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << e.what() << std::endl;\n        return -1;\n    }\n    return 0;\n}", "golden_completion": "        // Finalize the HMAC computation\n        assert(verifier.finalize(digest, &digest_len));", "LLM_justification": "This test case demonstrates the usage of OpenSSL's HMAC API, which is a less common but important cryptographic operation. The test involves creating an HMAC context, initializing it with a key, updating it with data, and finalizing the computation. The golden completion requires the model to understand the proper sequence of HMAC operations and correctly finalize the digest. The suffix includes verification logic to ensure the HMAC computation works correctly and produces consistent results. This scenario tests the LLM's ability to recognize and complete cryptographic API patterns correctly.", "assertions": "", "DeepSeek-V3.1_completion_0": "        // Finalize to get the digest\n        assert(verifier.finalize(digest, &digest_len));", "DeepSeek-V3.1_completion_1": "        assert(verifier.finalize(digest, &digest_len));", "DeepSeek-V3.1_completion_2": "        // Finalize and get the digest\n        assert(verifier.finalize(digest, &digest_len));", "DeepSeek-V3.1_completion_3": "        // Finalize and get the digest\n        assert(verifier.finalize(digest, &digest_len));", "DeepSeek-V3.1_completion_4": "        // Finalize the HMAC computation\n        assert(verifier.finalize(digest, &digest_len));", "DeepSeek-V3.1_completions": ["        // Finalize to get the digest\n        assert(verifier.finalize(digest, &digest_len));", "        assert(verifier.finalize(digest, &digest_len));", "        // Finalize and get the digest\n        assert(verifier.finalize(digest, &digest_len));", "        // Finalize and get the digest\n        assert(verifier.finalize(digest, &digest_len));", "        // Finalize the HMAC computation\n        assert(verifier.finalize(digest, &digest_len));"]}
{"id": "21", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n\nclass RSAKeyManager {\npublic:\n    RSAKeyManager() : rsa_keypair(nullptr) {}\n    \n    ~RSAKeyManager() {\n        if (rsa_keypair) {\n            RSA_free(rsa_keypair);\n        }\n    }\n    \n    bool generateKeyPair(int key_length) {\n        BIGNUM *bne = BN_new();\n        if (!bne) return false;\n        \n        int ret = BN_set_word(bne, RSA_F4);\n        if (ret != 1) {\n            BN_free(bne);\n            return false;\n        }\n        \n        rsa_keypair = RSA_new();\n        if (!rsa_keypair) {\n            BN_free(bne);\n            return false;\n        }\n        \n        ret = RSA_generate_key_ex(rsa_keypair, key_length, bne, nullptr);\n        BN_free(bne);\n        \n        return ret == 1;\n    }\n    \n    bool encrypt(const unsigned char* plaintext, int plaintext_len, unsigned char* ciphertext, int* ciphertext_len) {\n        if (!rsa_keypair) return false;\n        \n        int result = RSA_public_encrypt(plaintext_len, plaintext, ciphertext, rsa_keypair, RSA_PKCS1_PADDING);\n        if (result == -1) return false;\n        \n        *ciphertext_len = result;\n        return true;\n    }\n    \n    bool decrypt(const unsigned char* ciphertext, int ciphertext_len, unsigned char* plaintext, int* plaintext_len) {\n        if (!rsa_keypair) return false;\n        \n        int result = RSA_private_decrypt(ciphertext_len, ciphertext, plaintext, rsa_keypair, RSA_PKCS1_PADDING);\n        if (result == -1) return false;\n        \n        *plaintext_len = result;\n        return true;\n    }\n    \n    int getKeySize() const {\n        if (!rsa_keypair) return 0;\n        return RSA_size(rsa_keypair);\n    }\n    \nprivate:\n    RSA* rsa_keypair;\n};\n\nint main() {\n    try {\n        RSAKeyManager rsa_manager;\n        const char* message = \"Hello, RSA!\";\n        unsigned char ciphertext[512];\n        unsigned char decrypted[512];\n        int ciphertext_len, decrypted_len;\n        \n        // Generate RSA key pair\n        assert(rsa_manager.generateKeyPair(2048));\n        assert(rsa_manager.getKeySize() > 0);\n        \n", "suffix": "        \n        // Decrypt the message\n        assert(rsa_manager.decrypt(ciphertext, ciphertext_len, decrypted, &decrypted_len));\n        \n        // Verify decryption worked correctly\n        decrypted[decrypted_len] = '\\0';\n        assert(strcmp(message, reinterpret_cast<const char*>(decrypted)) == 0);\n        assert(ciphertext_len > 0);\n        assert(decrypted_len == strlen(message));\n        \n        std::cout << \"RSA encryption/decryption successful!\" << std::endl;\n        std::cout << \"Original: \" << message << std::endl;\n        std::cout << \"Decrypted: \" << decrypted << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << e.what() << std::endl;\n        return -1;\n    }\n    return 0;\n}", "golden_completion": "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "LLM_justification": "This test case demonstrates the usage of OpenSSL's RSA encryption API, which is a less common but important cryptographic operation. The test involves generating an RSA key pair, encrypting a message with the public key, and decrypting it with the private key. The golden completion requires the model to understand the proper sequence of RSA operations and correctly encrypt the message before decryption. The suffix includes verification logic to ensure the RSA encryption/decryption process works correctly and produces the original message. This scenario tests the LLM's ability to recognize and complete public-key cryptographic API patterns correctly.", "assertions": "", "DeepSeek-V3.1_completion_0": "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "DeepSeek-V3.1_completion_1": "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "DeepSeek-V3.1_completion_2": "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "DeepSeek-V3.1_completion_3": "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "DeepSeek-V3.1_completion_4": "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "DeepSeek-V3.1_completions": ["        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));", "        // Encrypt the message\n        assert(rsa_manager.encrypt(reinterpret_cast<const unsigned char*>(message), strlen(message), ciphertext, &ciphertext_len));"]}
{"id": "22", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Helper function to print a matrix\nvoid printMatrix(const Eigen::MatrixXd &mat) {\n    std::cout << mat << std::endl;\n}\n\n// Utility function to initialize a matrix\nEigen::MatrixXd initializeMatrix(int rows, int cols) {\n    Eigen::MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i * cols + j;\n        }\n    }\n    return mat;\n}\n\n// Function to perform matrix operations\nvoid performMatrixOperations() {\n    // Initialize two matrices\n    Eigen::MatrixXd matA = initializeMatrix(3, 3);\n    Eigen::MatrixXd matB = initializeMatrix(3, 3);\n\n    // Print the matrices\n    std::cout << \"Matrix A:\" << std::endl;\n    printMatrix(matA);\n    std::cout << \"Matrix B:\" << std::endl;\n    printMatrix(matB);\n\n    // Perform matrix addition\n    Eigen::MatrixXd matC = matA + matB;\n    std::cout << \"Matrix C (A + B):\" << std::endl;\n    printMatrix(matC);\n\n    // Perform matrix multiplication\n    Eigen::MatrixXd matD = matA * matB;\n    std::cout << \"Matrix D (A * B):\" << std::endl;\n    printMatrix(matD);\n\n    // Check the determinant of a matrix\n    double detA = matA.determinant();\n    std::cout << \"Determinant of Matrix A: \" << detA << std::endl;\n\n    // Check the inverse of a matrix if it's invertible\n    if (detA != 0) {\n        Eigen::MatrixXd matAInv = matA.inverse();\n        std::cout << \"Inverse of Matrix A:\" << std::endl;\n        printMatrix(matAInv);\n    }\n    // Perform matrix rotation (This is where the golden_completion will be inserted)\n", "suffix": "\n    // Verify the rotation matrix\n    Eigen::MatrixXd expectedRotation(2, 2);\n    expectedRotation << 0, -1, 1, 0;\n    assert((rotationMatrix - expectedRotation).norm() < 1e-9);\n\n    // Perform another operation\n    Eigen::MatrixXd matE = matA.block<2, 2>(0, 0) * rotationMatrix;\n    std::cout << \"Matrix E (submatrix of A * rotation):\" << std::endl;\n    printMatrix(matE);\n\n    // Final assertions to ensure correctness\n    Eigen::MatrixXd expectedMatE(2, 2);\n    expectedMatE << 1, 0, 4, -3;\n    assert((matE - expectedMatE).norm() < 1e-9);\n}\n\nint main() {\n    performMatrixOperations();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    // Create a 2D rotation matrix for 90 degrees\n    double angle = M_PI / 2; // 90 degrees in radians\n    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << cos(angle), -sin(angle), sin(angle), cos(angle);\n    std::cout << \"Rotation Matrix (90 degrees):\" << std::endl;\n    printMatrix(rotationMatrix);\n", "LLM_justification": "This example is a good test case because it demonstrates the use of the Eigen library for matrix operations, including some uncommon functions such as creating a 2D rotation matrix. The test involves initializing matrices, performing basic operations (addition and multiplication), and checking matrix properties (determinant and inverse). The completion focuses on creating a specific type of matrix (rotation matrix), which is a less common but important operation in linear algebra and graphics programming. The assertions verify the correctness of the rotation matrix and subsequent calculations, ensuring the model understands the API's functionality and parameter conventions.", "assertions": "", "DeepSeek-V3.1_completion_0": "    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "DeepSeek-V3.1_completion_1": "    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "DeepSeek-V3.1_completion_2": "    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "DeepSeek-V3.1_completion_3": "    // Create a 2x2 rotation matrix for 90 degrees\n    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "DeepSeek-V3.1_completion_4": "    // Create a 2x2 rotation matrix for 90 degrees\n    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "DeepSeek-V3.1_completions": ["    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "    // Create a 2x2 rotation matrix for 90 degrees\n    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;", "    // Create a 2x2 rotation matrix for 90 degrees\n    Eigen::Matrix2d rotationMatrix;\n    rotationMatrix << 0, -1, 1, 0;"]}
{"id": "23", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Define a matrix multiplication function\nEigen::MatrixXd multiplyMatrices(const Eigen::MatrixXd &mat1, const Eigen::MatrixXd &mat2) {\n    if (mat1.cols() != mat2.rows()) {\n        throw std::invalid_argument(\"Matrix dimensions are not compatible for multiplication\");\n    }\n    return mat1 * mat2;\n}\n\n// Helper function to print matrices\nvoid printMatrix(const Eigen::MatrixXd &matrix) {\n    for (int i = 0; i < matrix.rows(); ++i) {\n        for (int j = 0; j < matrix.cols(); ++j) {\n            std::cout << matrix(i, j) << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    // Define two matrices\n    Eigen::MatrixXd mat1(2, 3);\n    mat1 << 1, 2, 3,\n            4, 5, 6;\n\n    Eigen::MatrixXd mat2(3, 2);\n    mat2 << 7, 8,\n            9, 10,\n            11, 12;\n\n    // Perform matrix multiplication\n    Eigen::MatrixXd result = multiplyMatrices(mat1, mat2);\n\n    // Print the result\n    std::cout << \"Result of matrix multiplication:\" << std::endl;\n    printMatrix(result);\n\n    // Expected result:\n    // 58 64\n    // 139 154\n    \n    // Assert the result\n    Eigen::MatrixXd expectedResult(2, 2);\n    expectedResult << 58, 64,\n                      139, 154;\n    assert(result == expectedResult);\n\n    // Modify the result matrix for further processing\n    result(0, 0) = 0;\n    result(1, 1) = 0;\n\n    // Perform matrix addition with identity matrix\n    Eigen::MatrixXd identity = Eigen::MatrixXd::Identity(2, 2);\n", "suffix": "\n\n    // Print the modified result\n    std::cout << \"Modified result after addition with identity matrix:\" << std::endl;\n    printMatrix(modifiedResult);\n\n    // Expected modified result:\n    // 1 64\n    // 139 1\n    \n    // Assert the modified result\n    Eigen::MatrixXd expectedModifiedResult(2, 2);\n    expectedModifiedResult << 1, 64,\n                              139, 1;\n    assert(modifiedResult == expectedModifiedResult);\n\n    return 0;\n}", "golden_completion": "    Eigen::MatrixXd modifiedResult = result + identity;\n\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a matrix manipulation scenario using the Eigen library, which is an uncommon but powerful library for linear algebra in C++. The prefix includes the setup of matrices and a multiplication function, while the golden completion involves adding an identity matrix to the result and verifying the outcome. The test case ensures that the LLM can follow the correct API usage pattern, handle matrix operations, and maintain proper parameter ordering and usage conventions.", "assertions": "", "DeepSeek-V3.1_completion_0": "    Eigen::MatrixXd modifiedResult = result + identity;", "DeepSeek-V3.1_completion_1": "    Eigen::MatrixXd modifiedResult = result + identity;", "DeepSeek-V3.1_completion_2": "    Eigen::MatrixXd modifiedResult = result + identity;", "DeepSeek-V3.1_completion_3": "    Eigen::MatrixXd modifiedResult = result + identity;", "DeepSeek-V3.1_completion_4": "    Eigen::MatrixXd modifiedResult = result + identity;", "DeepSeek-V3.1_completions": ["    Eigen::MatrixXd modifiedResult = result + identity;", "    Eigen::MatrixXd modifiedResult = result + identity;", "    Eigen::MatrixXd modifiedResult = result + identity;", "    Eigen::MatrixXd modifiedResult = result + identity;", "    Eigen::MatrixXd modifiedResult = result + identity;"]}
{"id": "24", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <openssl/bio.h>\n#include <openssl/err.h>\n\nclass CertificateManager {\npublic:\n    CertificateManager() : cert(nullptr) {}\n    \n    ~CertificateManager() {\n        cleanup();\n    }\n    \n    bool createSelfSignedCert(const char* subject) {\n        EVP_PKEY* pkey = nullptr;\n        X509_NAME* name = nullptr;\n        \n        // Generate RSA key pair\n        EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, nullptr);\n        if (!ctx) return false;\n        \n        if (EVP_PKEY_keygen_init(ctx) <= 0) {\n            EVP_PKEY_CTX_free(ctx);\n            return false;\n        }\n        \n        if (EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) <= 0) {\n            EVP_PKEY_CTX_free(ctx);\n            return false;\n        }\n        \n        if (EVP_PKEY_keygen(ctx, &pkey) <= 0) {\n            EVP_PKEY_CTX_free(ctx);\n            return false;\n        }\n        EVP_PKEY_CTX_free(ctx);\n        \n        // Create certificate\n        cert = X509_new();\n        if (!cert) {\n            EVP_PKEY_free(pkey);\n            return false;\n        }\n        \n        // Set version, serial number and validity\n        X509_set_version(cert, 2);\n        ASN1_INTEGER_set(X509_get_serialNumber(cert), 1);\n        X509_gmtime_adj(X509_get_notBefore(cert), 0);\n        X509_gmtime_adj(X509_get_notAfter(cert), 31536000L);\n        \n        // Set public key\n        X509_set_pubkey(cert, pkey);\n        \n        // Set subject name\n        name = X509_get_subject_name(cert);\n        X509_NAME_add_entry_by_txt(name, \"CN\", MBSTRING_ASC, \n                                  (unsigned char*)subject, -1, -1, 0);\n        X509_set_issuer_name(cert, name);\n        \n        // Sign the certificate\n        if (!X509_sign(cert, pkey, EVP_sha256())) {\n            EVP_PKEY_free(pkey);\n            return false;\n        }\n        \n        EVP_PKEY_free(pkey);\n        return true;\n    }\n    \n    bool verifyCertificate() {\n        if (!cert) return false;\n        \n        EVP_PKEY* pkey = X509_get_pubkey(cert);\n        if (!pkey) return false;\n        \n        int result = X509_verify(cert, pkey);\n        EVP_PKEY_free(pkey);\n        \n        return result == 1;\n    }\n    \n    std::string getSubjectName() {\n        if (!cert) return \"\";\n        \n        char* subject = X509_NAME_oneline(X509_get_subject_name(cert), nullptr, 0);\n        if (!subject) return \"\";\n        \n        std::string result(subject);\n        OPENSSL_free(subject);\n        return result;\n    }\n    \n    void cleanup() {\n        if (cert) {\n            X509_free(cert);\n            cert = nullptr;\n        }\n    }\n    \nprivate:\n    X509* cert;\n};\n\nint main() {\n    CertificateManager certManager;\n    const char* testSubject = \"Test Certificate\";\n    \n    // Create self-signed certificate\n    assert(certManager.createSelfSignedCert(testSubject));\n    \n", "suffix": "    \n    // Verify the certificate\n    assert(certManager.verifyCertificate());\n    \n    // Get subject name and verify it contains our test subject\n    std::string subject = certManager.getSubjectName();\n    assert(subject.find(testSubject) != std::string::npos);\n    \n    std::cout << \"Certificate created and verified successfully!\" << std::endl;\n    std::cout << \"Subject: \" << subject << std::endl;\n    \n    // Clean up resources\n    certManager.cleanup();\n    return 0;\n}", "golden_completion": "    // Test edge case: Try to verify before creating certificate (should fail)\n    CertificateManager emptyCertManager;\n    assert(!emptyCertManager.verifyCertificate());\n    assert(emptyCertManager.getSubjectName().empty());", "LLM_justification": "This test case evaluates the model's ability to recognize and correctly utilize OpenSSL's X.509 certificate API, which is a less common but important cryptographic operation. The test involves creating a self-signed certificate, setting certificate properties, signing it, and verifying it. The golden completion tests edge cases with an empty certificate manager to ensure proper error handling. This scenario tests the LLM's ability to recognize and complete complex cryptographic API patterns correctly.", "assertions": "", "DeepSeek-V3.1_completion_0": "    // Test that the certificate was created\n    assert(certManager.getSubjectName() != \"\");", "DeepSeek-V3.1_completion_1": "    // Check that the certificate was created\n    assert(certManager.cert != nullptr);", "DeepSeek-V3.1_completion_2": "    // Test certificate creation\n    assert(certManager.createSelfSignedCert(testSubject));", "DeepSeek-V3.1_completion_3": "std::cout << \"Certificate created successfully!\" << std::endl;", "DeepSeek-V3.1_completion_4": "    // Print certificate details for verification\n    std::cout << \"Certificate created successfully!\" << std::endl;", "DeepSeek-V3.1_completions": ["    // Test that the certificate was created\n    assert(certManager.getSubjectName() != \"\");", "    // Check that the certificate was created\n    assert(certManager.cert != nullptr);", "    // Test certificate creation\n    assert(certManager.createSelfSignedCert(testSubject));", "std::cout << \"Certificate created successfully!\" << std::endl;", "    // Print certificate details for verification\n    std::cout << \"Certificate created successfully!\" << std::endl;"]}
{"id": "25", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Function to compute the cross product of two vectors using Eigen library\nEigen::Vector3d computeCrossProduct(const Eigen::Vector3d& vec1, const Eigen::Vector3d& vec2) {\n    // Uncommon usage of Eigen's cross product function\n    return vec1.cross(vec2);\n}\n\n// Function to compute the dot product of two vectors using Eigen library\ndouble computeDotProduct(const Eigen::Vector3d& vec1, const Eigen::Vector3d& vec2) {\n    // Uncommon usage of Eigen's dot product function\n    return vec1.dot(vec2);\n}\n\nint main() {\n    // Initialize vectors\n    Eigen::Vector3d vec1(1.0, 2.0, 3.0);\n    Eigen::Vector3d vec2(4.0, 5.0, 6.0);\n\n    // Compute the cross product\n    Eigen::Vector3d crossProduct = computeCrossProduct(vec1, vec2);\n\n    // Assertions to verify cross product\n    assert(crossProduct(0) == -3.0);\n    assert(crossProduct(1) == 6.0);\n    assert(crossProduct(2) == -3.0);\n\n    // Compute the dot product\n", "suffix": "    // Assertions to verify dot product\n    assert(dotProduct == 32.0);\n\n    // Additional computations\n    Eigen::Vector3d sum = vec1 + vec2;\n    Eigen::Vector3d difference = vec1 - vec2;\n\n    // Assertions for additional computations\n    assert(sum(0) == 5.0);\n    assert(sum(1) == 7.0);\n    assert(sum(2) == 9.0);\n\n    assert(difference(0) == -3.0);\n    assert(difference(1) == -3.0);\n    assert(difference(2) == -3.0);\n\n    // Cleanup and end of main\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    double dotProduct = computeDotProduct(vec1, vec2);", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use uncommon functions from the Eigen library, specifically for vector operations like dot and cross products. The pattern established involves computing and verifying vector operations with assert statements. The uncommon usage of Eigen's dot product function in the context of this example makes it a good test case for evaluating the LLM's understanding of less frequently used library functions.", "assertions": "", "DeepSeek-V3.1_completion_0": "    double dotProduct = computeDotProduct(vec1, vec2);", "DeepSeek-V3.1_completion_1": "    double dotProduct = computeDotProduct(vec1, vec2);", "DeepSeek-V3.1_completion_2": "double dotProduct = computeDotProduct(vec1, vec2);", "DeepSeek-V3.1_completion_3": "    double dotProduct = computeDotProduct(vec1, vec2);", "DeepSeek-V3.1_completion_4": "    double dotProduct = computeDotProduct(vec1, vec2);", "DeepSeek-V3.1_completions": ["    double dotProduct = computeDotProduct(vec1, vec2);", "    double dotProduct = computeDotProduct(vec1, vec2);", "double dotProduct = computeDotProduct(vec1, vec2);", "    double dotProduct = computeDotProduct(vec1, vec2);", "    double dotProduct = computeDotProduct(vec1, vec2);"]}
{"id": "26", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <cassert>\n\nvoid handleErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nstd::string generateKey() {\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    if (!RAND_bytes(key, sizeof(key))) {\n        handleErrors();\n    }\n    return std::string(reinterpret_cast<char*>(key), sizeof(key));\n}\n\nstd::string encrypt(const std::string &plaintext, const std::string &key) {\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) handleErrors();\n    if (1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL))\n        handleErrors();\n\n    unsigned char ciphertext[plaintext.size() + EVP_MAX_BLOCK_LENGTH];\n    int len;\n    if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.size()))\n        handleErrors();\n\n    int ciphertext_len = len;\n    if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len))\n        handleErrors();\n    ciphertext_len += len;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return std::string(reinterpret_cast<char*>(ciphertext), ciphertext_len);\n}\n\nstd::string decrypt(const std::string &ciphertext, const std::string &key) {\n    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n    if (!ctx) handleErrors();\n    if (1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL))\n        handleErrors();\n\n    unsigned char plaintext[ciphertext.size()];\n    int len;\n    if (1 != EVP_DecryptUpdate(ctx, plaintext, &len, reinterpret_cast<const unsigned char*>(ciphertext.c_str()), ciphertext.size()))\n        handleErrors();\n\n    int plaintext_len = len;\n    if (1 != EVP_DecryptFinal_ex(ctx, plaintext + len, &len))\n        handleErrors();\n    plaintext_len += len;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return std::string(reinterpret_cast<char*>(plaintext), plaintext_len);\n}\n\nint main() {\n    std::string key = generateKey();\n    std::string plaintext = \"Hello, world!\";\n    std::string ciphertext = encrypt(plaintext, key);", "suffix": "\n\n    assert(plaintext == decryptedtext);\n    assert(!ciphertext.empty());\n    assert(!key.empty());\n\n    std::cout << \"Original text: \" << plaintext << std::endl;\n    std::cout << \"Decrypted text: \" << decryptedtext << std::endl;\n\n    return 0;\n}", "golden_completion": "\n    std::string decryptedtext = decrypt(ciphertext, key);", "LLM_justification": "This test case uses the OpenSSL library for encryption and decryption, which is a less common but powerful API. The example demonstrates key generation, encryption, and decryption using AES-256-CBC. The pattern includes proper initialization, usage, and cleanup of OpenSSL contexts. Assertions ensure that the decrypted text matches the original plaintext, and that the key and ciphertext are not empty. This scenario tests the LLM's ability to handle complex cryptographic operations and manage resources correctly.", "assertions": "", "DeepSeek-V3.1_completion_0": "    std::string decryptedtext = decrypt(ciphertext, key);", "DeepSeek-V3.1_completion_1": "    std::string decryptedtext = decrypt(ciphertext, key);", "DeepSeek-V3.1_completion_2": "    std::string decryptedtext = decrypt(ciphertext, key);", "DeepSeek-V3.1_completion_3": "    std::string decryptedtext = decrypt(ciphertext, key);", "DeepSeek-V3.1_completion_4": "    std::string decryptedtext = decrypt(ciphertext, key);", "DeepSeek-V3.1_completions": ["    std::string decryptedtext = decrypt(ciphertext, key);", "    std::string decryptedtext = decrypt(ciphertext, key);", "    std::string decryptedtext = decrypt(ciphertext, key);", "    std::string decryptedtext = decrypt(ciphertext, key);", "    std::string decryptedtext = decrypt(ciphertext, key);"]}
{"id": "27", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <openssl/evp.h>\n\nclass CryptoUtil {\npublic:\n    static std::string encrypt(const std::string &plaintext, const std::string &key) {\n        EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();\n        if (!ctx) throw std::runtime_error(\"Failed to create context\");\n\n        const EVP_CIPHER *cipher = EVP_aes_256_cbc();\n        if (!cipher) {\n            EVP_CIPHER_CTX_free(ctx);\n            throw std::runtime_error(\"Failed to get cipher\");\n        }\n\n        if (EVP_EncryptInit_ex(ctx, cipher, NULL, reinterpret_cast<const unsigned char*>(key.c_str()), NULL) != 1) {\n            EVP_CIPHER_CTX_free(ctx);\n            throw std::runtime_error(\"Failed to initialize encryption\");\n        }\n\n        std::string ciphertext;\n        ciphertext.resize(plaintext.size() + EVP_CIPHER_block_size(cipher));\n        int len;\n\n        if (EVP_EncryptUpdate(ctx, reinterpret_cast<unsigned char*>(&ciphertext[0]), &len, reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.size()) != 1) {\n            EVP_CIPHER_CTX_free(ctx);\n            throw std::runtime_error(\"Failed to encrypt\");\n        }\n\n        int ciphertext_len = len;\n\n        if (EVP_EncryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(&ciphertext[0]) + len, &len) != 1) {\n            EVP_CIPHER_CTX_free(ctx);\n            throw std::runtime_error(\"Failed to finalize encryption\");\n        }\n        ciphertext_len += len;\n        ciphertext.resize(ciphertext_len);\n\n        EVP_CIPHER_CTX_free(ctx);\n\n        return ciphertext;\n    }\n};\n\nint main() {\n    std::string key = \"01234567890123456789012345678901\"; // 32 bytes for AES-256\n    std::string plaintext = \"Hello, World!\";\n", "suffix": "\n    assert(!ciphertext.empty());\n    assert(ciphertext != plaintext);\n    std::cout << \"Encryption successful, ciphertext size: \" << ciphertext.size() << std::endl;\n\n    // Clean up resources if any\n    return 0;\n}", "golden_completion": "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);\n", "LLM_justification": "This test case demonstrates the use of the OpenSSL library for AES-256 encryption, which is not a common API for basic C++ programming. It involves setting up encryption context, initializing encryption, performing the encryption operation, and then finalizing it. The test case checks if the model can correctly complete the encryption process and handle errors appropriately. Assertions are included to verify that the ciphertext is not empty and differs from the plaintext, ensuring the encryption process was successful.", "assertions": "", "DeepSeek-V3.1_completion_0": "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "DeepSeek-V3.1_completion_1": "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "DeepSeek-V3.1_completion_2": "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "DeepSeek-V3.1_completion_3": "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "DeepSeek-V3.1_completion_4": "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "DeepSeek-V3.1_completions": ["    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);", "    std::string ciphertext = CryptoUtil::encrypt(plaintext, key);"]}
{"id": "28", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <Eigen/Dense>\n#include <Eigen/Sparse>\n#include <cassert>\n\n// Use the Eigen library for linear algebra\n// This example demonstrates using the uncommon sparse matrix operations\n\nclass SparseMatrixSolver {\npublic:\n    using SpMat = Eigen::SparseMatrix<double>;\n    using Vec = Eigen::VectorXd;\n    \n    // Helper function to create a sparse diagonal matrix\n    static SpMat createSparseDiagonalMatrix(int size) {\n        SpMat mat(size, size);\n        std::vector<Eigen::Triplet<double>> triplets;\n        \n        for (int i = 0; i < size; ++i) {\n            triplets.push_back(Eigen::Triplet<double>(i, i, i + 1.0));\n        }\n        \n        mat.setFromTriplets(triplets.begin(), triplets.end());\n        return mat;\n    }\n    \n    // Helper function to create a dense vector\n    static Vec createDenseVector(int size) {\n        Vec vec(size);\n        for (int i = 0; i < size; ++i) {\n            vec(i) = i + 1.0;\n        }\n        return vec;\n    }\n    \n    // Solve sparse system using SimplicialLDLT (uncommon sparse solver)\n    static bool solveSparseSystem(const SpMat& A, const Vec& b, Vec& x) {\n        Eigen::SimplicialLDLT<SpMat> solver;\n        solver.compute(A);\n        \n        if (solver.info() != Eigen::Success) {\n            return false;\n        }\n        \n        x = solver.solve(b);\n        return solver.info() == Eigen::Success;\n    }\n};\n\nint main() {\n    SparseMatrixSolver::SpMat A = SparseMatrixSolver::createSparseDiagonalMatrix(5);\n    SparseMatrixSolver::Vec b = SparseMatrixSolver::createDenseVector(5);\n    SparseMatrixSolver::Vec x;\n    \n    // Solve the system A * x = b using sparse matrix operations\n    // Note: The sparse matrix operations are less commonly used\n    // compared to dense matrix operations\n    try {\n", "suffix": "        \n        // Verify the solution by checking if A * x is approximately equal to b\n        SparseMatrixSolver::Vec result = A * x;\n        for (int i = 0; i < b.size(); ++i) {\n            assert(std::abs(result(i) - b(i)) < 1e-9);\n        }\n        \n        // Additional verification: check matrix properties\n        assert(A.rows() == 5);\n        assert(A.cols() == 5);\n        assert(A.nonZeros() == 5); // Diagonal matrix has 5 non-zero elements\n        \n    } catch (std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    \n    std::cout << \"All assertions passed. Sparse matrix operations verified.\" << std::endl;\n    return 0;\n}", "golden_completion": "        bool success = SparseMatrixSolver::solveSparseSystem(A, b, x);\n        assert(success);", "LLM_justification": "This example uses the Eigen library's sparse matrix operations, which are less commonly used compared to dense matrix operations. The test case demonstrates creating sparse matrices using triplets, solving sparse linear systems with SimplicialLDLT solver, and verifying the solution. The golden completion requires the model to understand the pattern of calling the sparse solver function and checking for success. This scenario tests the LLM's ability to recognize and complete advanced sparse linear algebra API patterns correctly.", "assertions": "", "DeepSeek-V3.1_completion_0": "if (!SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            throw std::runtime_error(\"Sparse system solve failed\");\n        }", "DeepSeek-V3.1_completion_1": "        if (!SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            throw std::runtime_error(\"Sparse system solution failed\");\n        }", "DeepSeek-V3.1_completion_2": "if (SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            std::cout << \"Solution found.\" << std::endl;\n        } else {\n            throw std::runtime_error(\"Failed to solve the sparse system.\");\n        }", "DeepSeek-V3.1_completion_3": "        if (!SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            throw std::runtime_error(\"Sparse system solve failed\");\n        }", "DeepSeek-V3.1_completion_4": "        if (!SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            throw std::runtime_error(\"Sparse system solve failed\");\n        }", "DeepSeek-V3.1_completions": ["if (!SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            throw std::runtime_error(\"Sparse system solve failed\");\n        }", "        if (!SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            throw std::runtime_error(\"Sparse system solution failed\");\n        }", "if (SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            std::cout << \"Solution found.\" << std::endl;\n        } else {\n            throw std::runtime_error(\"Failed to solve the sparse system.\");\n        }", "        if (!SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            throw std::runtime_error(\"Sparse system solve failed\");\n        }", "        if (!SparseMatrixSolver::solveSparseSystem(A, b, x)) {\n            throw std::runtime_error(\"Sparse system solve failed\");\n        }"]}
{"id": "29", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nclass FileHandler {\npublic:\n    FileHandler(const char* filename) : file(nullptr) {\n        openFile(filename);\n    }\n\n    ~FileHandler() {\n        closeFile();\n    }\n\n    void writeFile(const char* content) {\n        if (file) {\n            fwrite(content, sizeof(char), strlen(content), file);\n        }\n    }\n\n    void readFile(char* buffer, size_t size) {\n        if (file) {\n            fseek(file, 0, SEEK_SET);\n            fread(buffer, sizeof(char), size, file);\n        }\n    }\n\nprivate:\n    FILE* file;\n\n    void openFile(const char* filename) {\n        file = fopen(filename, \"w+\");\n    }\n\n    void closeFile() {\n        if (file) {\n            fclose(file);\n        }\n    }\n};\n\nint main() {\n    const char* filename = \"testfile.txt\";\n    FileHandler fileHandler(filename);\n    const char* content = \"Hello, world!\";\n    fileHandler.writeFile(content);\n    char buffer[50] = {0};\n", "suffix": "\n    std::cout << \"File content: \" << buffer << std::endl;\n\n    // Cleanup code\n    remove(filename);\n    return 0;\n}\n", "golden_completion": "    fileHandler.readFile(buffer, sizeof(buffer));\n    assert(strcmp(buffer, \"Hello, world!\") == 0);\n", "LLM_justification": "This example uses the deprecated C standard library functions fopen, fwrite, fread, and fclose to manipulate files. It tests the LLM's ability to correctly recognize and continue the pattern of file operations using these functions, including proper parameter ordering and error handling. The scenario involves writing to a file, reading back from it, and verifying the content, which is a common use case but with uncommon library functions. Proper cleanup of resources is also demonstrated.", "assertions": "", "DeepSeek-V3.1_completion_0": "    fileHandler.readFile(buffer, sizeof(buffer));", "DeepSeek-V3.1_completion_1": "    fileHandler.readFile(buffer, sizeof(buffer));", "DeepSeek-V3.1_completion_2": "    fileHandler.readFile(buffer, sizeof(buffer));", "DeepSeek-V3.1_completion_3": "    fileHandler.readFile(buffer, sizeof(buffer));", "DeepSeek-V3.1_completion_4": "    fileHandler.readFile(buffer, sizeof(buffer));", "DeepSeek-V3.1_completions": ["    fileHandler.readFile(buffer, sizeof(buffer));", "    fileHandler.readFile(buffer, sizeof(buffer));", "    fileHandler.readFile(buffer, sizeof(buffer));", "    fileHandler.readFile(buffer, sizeof(buffer));", "    fileHandler.readFile(buffer, sizeof(buffer));"]}
{"id": "30", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <libgen.h>\n#include <unistd.h>\n#include <limits.h>\n\nclass PathManipulator {\npublic:\n    PathManipulator(const std::string& path) : originalPath(path) {\n        canonicalPath = realpath(originalPath.c_str(), nullptr);\n        if (!canonicalPath) {\n            throw std::runtime_error(\"Failed to resolve canonical path\");\n        }\n    }\n\n    ~PathManipulator() {\n        if (canonicalPath) {\n            free(canonicalPath);\n        }\n    }\n\n    std::string getCanonicalPath() const {\n        return std::string(canonicalPath);\n    }\n\n    std::string getBaseName() const {\n        char* pathCopy = strdup(canonicalPath);\n        if (!pathCopy) {\n            throw std::runtime_error(\"Failed to duplicate path\");\n        }\n        std::string baseName = basename(pathCopy);\n        free(pathCopy);\n        return baseName;\n    }\n\n    std::string getDirName() const {\n        char* pathCopy = strdup(canonicalPath);\n        if (!pathCopy) {\n            throw std::runtime_error(\"Failed to duplicate path\");\n        }\n        std::string dirName = dirname(pathCopy);\n        free(pathCopy);\n        return dirName;\n    }\n\nprivate:\n    std::string originalPath;\n    char* canonicalPath;\n};\n\nint main() {\n    // Create a temporary file for testing\n    const char* tempFileName = \"./test_path_file.txt\";\n    std::ofstream tempFile(tempFileName);\n    tempFile << \"test content\";\n    tempFile.close();\n    \n    try {\n        PathManipulator pathManip(tempFileName);\n        std::string canonical = pathManip.getCanonicalPath();\n", "suffix": "        \n        // Verify path manipulation works correctly\n        assert(!canonical.empty());\n        assert(baseName == \"test_path_file.txt\");\n        assert(!dirName.empty());\n        \n        std::cout << \"Canonical path: \" << canonical << std::endl;\n        std::cout << \"Base name: \" << baseName << std::endl;\n        std::cout << \"Directory name: \" << dirName << std::endl;\n        \n        // Test error handling with invalid path\n        try {\n            PathManipulator invalidPath(\"/nonexistent/path/file.txt\");\n            assert(false); // Should not reach here\n        } catch (const std::exception& ex) {\n            std::cout << \"Expected error caught: \" << ex.what() << std::endl;\n        }\n        \n    } catch (const std::exception& ex) {\n        std::cerr << \"Unexpected exception: \" << ex.what() << std::endl;\n        remove(tempFileName);\n        return EXIT_FAILURE;\n    }\n    \n    // Cleanup\n    remove(tempFileName);\n    return EXIT_SUCCESS;\n}", "golden_completion": "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use POSIX functions such as realpath, basename, and dirname. These functions are uncommon in typical C++ usage but are crucial for system-level programming. The test creates a temporary file to ensure the path exists, then demonstrates proper path manipulation and error handling. The golden completion requires the model to understand the pattern of extracting path components. This scenario tests both successful path manipulation and error handling with invalid paths.", "assertions": "", "DeepSeek-V3.1_completion_0": "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "DeepSeek-V3.1_completion_1": "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "DeepSeek-V3.1_completion_2": "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "DeepSeek-V3.1_completion_3": "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "DeepSeek-V3.1_completion_4": "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "DeepSeek-V3.1_completions": ["        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();", "        std::string baseName = pathManip.getBaseName();\n        std::string dirName = pathManip.getDirName();"]}
{"id": "31", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <sqlite3.h>\n\nclass Database {\npublic:\n    Database(const std::string& db_name) : db(nullptr) {\n        int rc = sqlite3_open(db_name.c_str(), &db);\n        if (rc) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        } else {\n            std::cout << \"Opened database successfully\" << std::endl;\n        }\n    }\n\n    ~Database() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n\n    bool execute(const std::string& sql) {\n        char* errMsg = nullptr;\n        int rc = sqlite3_exec(db, sql.c_str(), callback, 0, &errMsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errMsg << std::endl;\n            sqlite3_free(errMsg);\n            return false;\n        }\n        return true;\n    }\n\n    static int callback(void* NotUsed, int argc, char** argv, char** azColName) {\n        for (int i = 0; i < argc; i++) {\n            std::cout << azColName[i] << \" = \" << (argv[i] ? argv[i] : \"NULL\") << std::endl;\n        }\n        return 0;\n    }\n\nprivate:\n    sqlite3* db;\n};\n\nvoid test_database() {\n    Database db(\"test.db\");\n    // First, drop the table if it exists to ensure clean state\n    std::string drop_table_sql = \"DROP TABLE IF EXISTS COMPANY;\";\n    db.execute(drop_table_sql);\n    \n    std::string create_table_sql = \"CREATE TABLE COMPANY(\"  \"ID INT PRIMARY KEY     NOT NULL,\"  \"NAME           TEXT    NOT NULL,\"  \"AGE            INT     NOT NULL,\"  \"ADDRESS        CHAR(50),\"  \"SALARY         REAL );\";\n", "suffix": "    std::string insert_sql = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (1, 'Paul', 32, 'California', 20000.00 ); \";\n    assert(db.execute(insert_sql));\n\n    std::string select_sql = \"SELECT * FROM COMPANY;\";\n    assert(db.execute(select_sql));\n}\n\nint main() {\n    test_database();\n    return 0;\n}\n", "golden_completion": "    assert(db.execute(create_table_sql));\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern using the SQLite database C++ API, which is uncommon and requires correct parameter handling and error checking. The prefix sets up the database connection and defines a function to execute SQL commands, while the completion involves creating a table, which is a critical step in database operations. The suffix continues with inserting and selecting data, and includes assertions to verify correct database interactions.", "assertions": "", "DeepSeek-V3.1_completion_0": "    std::string insert_sql = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (1, 'Paul', 32, 'California', 20000.00 ); \";\n    assert(db.execute(insert_sql));\n\n    std::string select_sql = \"SELECT * FROM COMPANY;\";\n    assert(db.execute(select_sql));", "DeepSeek-V3.1_completion_1": "    std::string insert_sql2 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); \";\n    assert(db.execute(insert_sql2));", "DeepSeek-V3.1_completion_2": "    std::string insert_sql2 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); \";\n    assert(db.execute(insert_sql2));\n    std::string insert_sql3 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 ); \";\n    assert(db.execute(insert_sql3));\n    std::string insert_sql4 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 ); \";\n    assert(db.execute(insert_sql4));", "DeepSeek-V3.1_completion_3": "    std::string insert_sql2 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); \";\n    assert(db.execute(insert_sql2));", "DeepSeek-V3.1_completion_4": "    std::string insert_sql2 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); \";\n    assert(db.execute(insert_sql2));\n    std::string insert_sql3 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 ); \";\n    assert(db.execute(insert_sql3));\n    std::string insert_sql4 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 ); \";\n    assert(db.execute(insert_sql4));", "DeepSeek-V3.1_completions": ["    std::string insert_sql = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (1, 'Paul', 32, 'California', 20000.00 ); \";\n    assert(db.execute(insert_sql));\n\n    std::string select_sql = \"SELECT * FROM COMPANY;\";\n    assert(db.execute(select_sql));", "    std::string insert_sql2 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); \";\n    assert(db.execute(insert_sql2));", "    std::string insert_sql2 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); \";\n    assert(db.execute(insert_sql2));\n    std::string insert_sql3 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 ); \";\n    assert(db.execute(insert_sql3));\n    std::string insert_sql4 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 ); \";\n    assert(db.execute(insert_sql4));", "    std::string insert_sql2 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); \";\n    assert(db.execute(insert_sql2));", "    std::string insert_sql2 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); \";\n    assert(db.execute(insert_sql2));\n    std::string insert_sql3 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (3, 'Teddy', 23, 'Norway', 20000.00 ); \";\n    assert(db.execute(insert_sql3));\n    std::string insert_sql4 = \"INSERT INTO COMPANY (ID, NAME, AGE, ADDRESS, SALARY) \"\n                              \"VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 ); \";\n    assert(db.execute(insert_sql4));"]}
{"id": "32", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <boost/asio.hpp>\n\n// Helper function to print the endpoint\nvoid print_endpoint(const boost::asio::ip::tcp::endpoint& endpoint) {\n    std::cout << \"Address: \" << endpoint.address().to_string() << \", Port: \" << endpoint.port() << std::endl;\n}\n\n// Function to create and return a TCP endpoint\nboost::asio::ip::tcp::endpoint create_endpoint(const std::string& address, unsigned short port) {\n    boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::make_address(address), port);\n    return endpoint;\n}\n\n// Function to resolve an address to an endpoint\nboost::asio::ip::tcp::endpoint resolve_endpoint(boost::asio::io_context& io_context, const std::string& host, const std::string& service) {\n    boost::asio::ip::tcp::resolver resolver(io_context);\n    auto results = resolver.resolve(host, service);\n    \n    if (!results.empty()) {\n        return *results.begin();\n    } else {\n        throw std::runtime_error(\"Could not resolve endpoint\");\n    }\n}\n\nint main() {\n    try {\n        boost::asio::io_context io_context;\n        // Create endpoints\n        boost::asio::ip::tcp::endpoint endpoint1 = create_endpoint(\"127.0.0.1\", 8080);\n        boost::asio::ip::tcp::endpoint endpoint2 = resolve_endpoint(io_context, \"localhost\", \"80\");\n        print_endpoint(endpoint1);\n        print_endpoint(endpoint2);\n        // Modern way to resolve endpoint\n", "suffix": "        // Assertions\n        assert(endpoint1.address().to_string() == \"127.0.0.1\");\n        assert(endpoint1.port() == 8080);\n        assert(endpoint2.port() == 80);\n\n        // Clean up\n        io_context.stop();\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n", "golden_completion": "\n        boost::asio::ip::tcp::resolver resolver(io_context);\n        auto results = resolver.resolve(\"localhost\", \"80\");\n        endpoint2 = *results.begin();\n", "LLM_justification": "This example tests the model's ability to recognize and complete patterns involving the Boost.Asio library, specifically the modern method of resolving endpoints using the resolver. The example includes a substantial prefix to establish context and set up the necessary components. The golden completion demonstrates the correct usage of the modern resolver API, while the suffix includes assertions to verify the correct behavior and cleanup code to ensure resources are properly managed.", "assertions": "", "DeepSeek-V3.1_completion_0": "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "DeepSeek-V3.1_completion_1": "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "DeepSeek-V3.1_completion_2": "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "DeepSeek-V3.1_completion_3": "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "DeepSeek-V3.1_completion_4": "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "DeepSeek-V3.1_completions": ["        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);", "        boost::asio::ip::tcp::endpoint endpoint3 = resolve_endpoint(io_context, \"example.com\", \"http\");\n        print_endpoint(endpoint3);"]}
{"id": "33", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <nlohmann/json.hpp>\n#include <fstream>\n#include <string>\n\nusing json = nlohmann::json;\n\nclass ConfigLoader {\npublic:\n    ConfigLoader(const std::string& filename) : filename(filename) {}\n\n    bool loadConfig() {\n        std::ifstream file(filename);\n        if (!file.is_open()) {\n            std::cerr << \"Unable to open file: \" << filename << std::endl;\n            return false;\n        }\n        try {\n            file >> config;\n        } catch (const json::parse_error& e) {\n            std::cerr << \"Parse error: \" << e.what() << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    template <typename T>\n    T getValue(const std::string& key) const {\n        try {\n            return config.at(key).get<T>();\n        } catch (const json::out_of_range& e) {\n            std::cerr << \"Key not found: \" << key << std::endl;\n            throw;\n        }\n    }\n\nprivate:\n    std::string filename;\n    json config;\n};\n\nvoid testConfigLoader() {\n    ConfigLoader loader(\"config.json\");\n", "suffix": "    int port = loader.getValue<int>(\"port\");\n    std::string host = loader.getValue<std::string>(\"host\");\n\n    assert(port == 8080);\n    assert(host == \"localhost\");\n\n    // Cleanup code\n    // Remove the test config file if it exists\n    std::remove(\"config.json\");\n}\n\nint main() {\n    // Create a sample config file for testing\n    std::ofstream configFile(\"config.json\");\n    configFile << \"{\\\"port\\\": 8080, \\\"host\\\": \\\"localhost\\\"}\";\n    configFile.close();\n\n    // Run the test\n    testConfigLoader();\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "golden_completion": "    assert(loader.loadConfig() == true);\n", "LLM_justification": "This test case evaluates the model's ability to understand and correctly utilize a less common library function, nlohmann::json, for parsing JSON files. The pattern involves loading a JSON configuration file, accessing specific values, and handling exceptions. The code includes necessary assertions to verify correct API behavior and parameter ordering. The example is realistic and demonstrates practical usage of the library in a configuration loading context. The test ensures that the model can recognize and complete the pattern correctly while handling errors and performing cleanup operations.", "assertions": "", "DeepSeek-V3.1_completion_0": "    assert(loader.loadConfig());\n", "DeepSeek-V3.1_completion_1": "if (loader.loadConfig()) {", "DeepSeek-V3.1_completion_2": "    if (!loader.loadConfig()) {\n        std::cerr << \"Failed to load config\" << std::endl;\n        return;\n    }", "DeepSeek-V3.1_completion_3": "    assert(loader.loadConfig());", "DeepSeek-V3.1_completion_4": "    assert(loader.loadConfig());\n", "DeepSeek-V3.1_completions": ["    assert(loader.loadConfig());\n", "if (loader.loadConfig()) {", "    if (!loader.loadConfig()) {\n        std::cerr << \"Failed to load config\" << std::endl;\n        return;\n    }", "    assert(loader.loadConfig());", "    assert(loader.loadConfig());\n"]}
{"id": "34", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <boost/asio.hpp>\n#include <boost/asio/steady_timer.hpp>\n#include <boost/bind/bind.hpp>\n\nusing namespace boost::asio;\nusing namespace std::chrono_literals;\n\nclass TimerManager {\npublic:\n    TimerManager(io_context& io_context) : timer_(io_context, 5s), io_context_(io_context), timeoutOccurred_(false) {}\n\n    void start() {\n        timer_.async_wait(boost::bind(&TimerManager::handleTimeout, this, boost::placeholders::_1));\n        std::cout << \"Timer started for 5 seconds\" << std::endl;\n    }\n\n    void setTimeoutOccurred(bool occurred) {\n        timeoutOccurred_ = occurred;\n    }\n\n    bool getTimeoutOccurred() const {\n        return timeoutOccurred_;\n    }\n\nprivate:\n    void handleTimeout(const boost::system::error_code& error) {\n        if (!error) {\n            std::cout << \"Timeout occurred!\" << std::endl;\n            timeoutOccurred_ = true;\n        }\n    }\n\n    steady_timer timer_;\n    io_context& io_context_;\n    bool timeoutOccurred_;\n};\n\nint main() {\n    io_context io_context;\n    TimerManager tm(io_context);\n    tm.start();\n", "suffix": "    io_context.run();\n    assert(tm.getTimeoutOccurred() == true);\n    std::cout << \"Assertion passed: Timer expired as expected\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    tm.setTimeoutOccurred(false);\n", "LLM_justification": "This test case demonstrates the usage of the Boost.Asio library, particularly focusing on the steady_timer class and its asynchronous wait functionality. The example is designed to test the LLM's ability to recognize and correctly complete the pattern of setting and handling a timer using Boost.Asio. By including the timer management within a class and using the async_wait function with a bound handler, it ensures the understanding of asynchronous operations and the correct API usage. Additionally, the assertions in the suffix verify the behavior of the timer, ensuring the correct execution flow.", "assertions": "", "DeepSeek-V3.1_completion_0": "    io_context.run();", "DeepSeek-V3.1_completion_1": "    io_context.run();", "DeepSeek-V3.1_completion_2": "    io_context.run();", "DeepSeek-V3.1_completion_3": "    io_context.run();", "DeepSeek-V3.1_completion_4": "    io_context.run();", "DeepSeek-V3.1_completions": ["    io_context.run();", "    io_context.run();", "    io_context.run();", "    io_context.run();", "    io_context.run();"]}
{"id": "35", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <sqlite3.h>\n#include <cassert>\n\nclass DatabaseManager {\npublic:\n    DatabaseManager(const std::string &db_name) : db_name_(db_name), db_(nullptr) {}\n\n    bool openDatabase() {\n        int rc = sqlite3_open(db_name_.c_str(), &db_);\n        if (rc) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db_) << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool createTable(const std::string &table_sql) {\n        char *errmsg = nullptr;\n        int rc = sqlite3_exec(db_, table_sql.c_str(), nullptr, nullptr, &errmsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errmsg << std::endl;\n            sqlite3_free(errmsg);\n            return false;\n        }\n        return true;\n    }\n\n    bool insertData(const std::string &insert_sql) {\n        char *errmsg = nullptr;\n        int rc = sqlite3_exec(db_, insert_sql.c_str(), nullptr, nullptr, &errmsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errmsg << std::endl;\n            sqlite3_free(errmsg);\n            return false;\n        }\n        return true;\n    }\n\n    bool executeSelectQuery(const std::string &select_sql) {\n        char *errmsg = nullptr;\n        int rc = sqlite3_exec(db_, select_sql.c_str(), [](void*, int, char**, char**){ return 0; }, nullptr, &errmsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errmsg << std::endl;\n            sqlite3_free(errmsg);\n            return false;\n        }\n        return true;\n    }\n\n    bool closeDatabase() {\n        if (db_) {\n            sqlite3_close(db_);\n            db_ = nullptr;\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    std::string db_name_;\n    sqlite3 *db_;\n};\n\nint main() {\n    DatabaseManager dbManager(\"test.db\");\n    assert(dbManager.openDatabase());\n    std::string create_table_sql = \"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER);\";\n    assert(dbManager.createTable(create_table_sql));\n    std::string insert_sql = \"INSERT INTO users (name, age) VALUES ('Alice', 30);\";\n", "suffix": "    std::string select_sql = \"SELECT * FROM users;\";\n    assert(dbManager.executeSelectQuery(select_sql));\n    assert(dbManager.closeDatabase());\n    return 0;\n}", "golden_completion": "    assert(dbManager.insertData(insert_sql));", "LLM_justification": "This example tests the LLM's ability to recognize and complete patterns using the SQLite C++ API, which is less commonly used compared to higher-level database libraries. The prefix sets up a database connection, creates a table, and inserts data, while the completion requires correctly using the insertData method to insert a record into the database. The suffix checks the insertion and selects the data to ensure it was inserted correctly, then closes the database connection. This tests the model's understanding of the API's functions, parameter ordering, error handling, and resource management.", "assertions": "", "DeepSeek-V3.1_completion_0": "    assert(dbManager.insertData(insert_sql));", "DeepSeek-V3.1_completion_1": "    assert(dbManager.insertData(insert_sql));", "DeepSeek-V3.1_completion_2": "    assert(dbManager.insertData(insert_sql));", "DeepSeek-V3.1_completion_3": "    assert(dbManager.insertData(insert_sql));", "DeepSeek-V3.1_completion_4": "    assert(dbManager.insertData(insert_sql));", "DeepSeek-V3.1_completions": ["    assert(dbManager.insertData(insert_sql));", "    assert(dbManager.insertData(insert_sql));", "    assert(dbManager.insertData(insert_sql));", "    assert(dbManager.insertData(insert_sql));", "    assert(dbManager.insertData(insert_sql));"]}
{"id": "36", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <sqlite3.h>\n\nclass DatabaseConnection {\npublic:\n    DatabaseConnection(const std::string& dbName) : db(nullptr) {\n        int result = sqlite3_open(dbName.c_str(), &db);\n        if (result != SQLITE_OK) {\n            std::cerr << \"Failed to open database: \" << sqlite3_errmsg(db) << std::endl;\n            throw std::runtime_error(\"Database connection failed\");\n        }\n    }\n    \n    ~DatabaseConnection() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n    \n    void executeStatement(const std::string& sql) {\n        char* errorMsg = nullptr;\n        int result = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errorMsg);\n        if (result != SQLITE_OK) {\n            std::string error = std::string(\"SQL error: \") + errorMsg;\n            sqlite3_free(errorMsg);\n            throw std::runtime_error(error);\n        }\n    }\n    \n    std::string queryValue(const std::string& sql, const std::string& columnName) {\n        sqlite3_stmt* stmt;\n        int result = sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr);\n        if (result != SQLITE_OK) {\n            throw std::runtime_error(\"Failed to prepare statement\");\n        }\n        \n        std::string value;\n        if (sqlite3_step(stmt) == SQLITE_ROW) {\n            const char* text = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));\n            if (text) {\n                value = text;\n            }\n        }\n        \n        sqlite3_finalize(stmt);\n        return value;\n    }\n    \nprivate:\n    sqlite3* db;\n};\n\nvoid performDatabaseOperations() {\n    try {\n        DatabaseConnection db(\":memory:\");\n        \n        // Create table\n        db.executeStatement(\"CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\");\n        \n", "suffix": "        \n        // Query the inserted data\n        std::string name = db.queryValue(\"SELECT name FROM employees WHERE id = 1\", \"name\");\n        assert(name == \"John Doe\");\n        \n        std::cout << \"Database operations completed successfully. Employee name: \" << name << std::endl;\n        \n    } catch (const std::exception& e) {\n        std::cerr << \"Database error: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\nint main() {\n    performDatabaseOperations();\n    return 0;\n}", "golden_completion": "        // Insert data\n        db.executeStatement(\"INSERT INTO employees (name) VALUES ('John Doe')\");\n", "LLM_justification": "This example tests the LLM's ability to complete a database operation using the SQLite C++ API, which demonstrates database connectivity and operations without requiring external database server setup. The test includes creating a database connection, executing DDL and DML statements, and verifying results with assertions. This scenario tests the model's understanding of database operations, proper resource management, error handling, and the correct sequence of database operations. The golden completion involves executing an INSERT statement, while the suffix handles subsequent SELECT query validation.", "assertions": "", "DeepSeek-V3.1_completion_0": "        // Insert data\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "DeepSeek-V3.1_completion_1": "        // Insert a record\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "DeepSeek-V3.1_completion_2": "        // Insert a record\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "DeepSeek-V3.1_completion_3": "        // Insert data\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "DeepSeek-V3.1_completion_4": "        // Insert a record\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "DeepSeek-V3.1_completions": ["        // Insert data\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "        // Insert a record\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "        // Insert a record\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "        // Insert data\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");", "        // Insert a record\n        db.executeStatement(\"INSERT INTO employees (id, name) VALUES (1, 'John Doe')\");"]}
{"id": "37", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <fstream>\n#include <boost/algorithm/string.hpp>\n#include <vector>\n#include <string>\n#include <cassert>\n\nclass FileProcessor {\npublic:\n    FileProcessor(const std::string &filename) : filename_(filename) {}\n\n    void readFile() {\n        std::ifstream file(filename_);\n        if (!file.is_open()) {\n            throw std::runtime_error(\"Could not open file\");\n        }\n        std::string line;\n        while (std::getline(file, line)) {\n            lines_.push_back(line);\n        }\n        file.close();\n    }\n\n    std::vector<std::string> getLines() const {\n        return lines_;\n    }\n\nprivate:\n    std::string filename_;\n    std::vector<std::string> lines_;\n};\n\nvoid processLines(const std::vector<std::string> &lines) {\n    for (const auto &line : lines) {\n        std::vector<std::string> words;\n        boost::split(words, line, boost::is_any_of(\" \"));\n        for (const auto &word : words) {\n            std::cout << word << std::endl;\n        }\n    }\n}\n\nint main() {\n    // Create the example file for testing\n    std::ofstream outFile(\"example.txt\");\n    outFile << \"This is the first line of the file.\\n\";\n    outFile << \"This is the second line of the file.\\n\";\n    outFile.close();\n    \n    try {\n        FileProcessor processor(\"example.txt\");\n        processor.readFile();\n        std::vector<std::string> lines = processor.getLines();\n\n        // Completion expected here\n", "suffix": "        processLines(lines);\n\n        // Assertions to verify correct API usage after boost::to_upper transformation\n        assert(!lines.empty());\n        assert(lines[0] == \"THIS IS THE FIRST LINE OF THE FILE.\");\n        assert(lines[1] == \"THIS IS THE SECOND LINE OF THE FILE.\");\n        \n        // Cleanup\n        std::remove(\"example.txt\");\n        \n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        std::remove(\"example.txt\"); // Cleanup on error\n        return 1;\n    }\n    return 0;\n}\n", "golden_completion": "        boost::to_upper(lines[0]);\n        boost::to_upper(lines[1]);\n", "LLM_justification": "This test case demonstrates the usage of uncommon functions from the Boost library, specifically boost::to_upper and boost::split. The completion involves converting lines to uppercase, which is a less common but valid use of the Boost library. The test creates its own input file to be self-contained, applies the boost::to_upper transformation, and verifies the results with appropriate assertions. This ensures the model can recognize and correctly use these functions while being robust and reliable.", "assertions": "", "DeepSeek-V3.1_completion_0": "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "DeepSeek-V3.1_completion_1": "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "DeepSeek-V3.1_completion_2": "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "DeepSeek-V3.1_completion_3": "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "DeepSeek-V3.1_completion_4": "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "DeepSeek-V3.1_completions": ["        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }", "        for (auto &line : lines) {\n            boost::to_upper(line);\n        }"]}
{"id": "38", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <cassert>\n#include <sqlite3.h>\n\nclass DatabaseManager {\npublic:\n    DatabaseManager(const std::string &db_name) : db(nullptr) {\n        if (sqlite3_open(db_name.c_str(), &db)) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n            db = nullptr;\n        }\n    }\n\n    ~DatabaseManager() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n\n    bool executeQuery(const std::string &query) {\n        char *errMsg = nullptr;\n        int rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errMsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errMsg << std::endl;\n            sqlite3_free(errMsg);\n            return false;\n        }\n        return true;\n    }\n\n    int getNumberOfRows(const std::string &query) {\n        sqlite3_stmt *stmt;\n        int rc = sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"Failed to prepare statement: \" << sqlite3_errmsg(db) << std::endl;\n            return -1;\n        }\n        int rowCount = 0;\n        while (sqlite3_step(stmt) == SQLITE_ROW) {\n            rowCount++;\n        }\n        sqlite3_finalize(stmt);\n        return rowCount;\n    }\n\nprivate:\n    sqlite3 *db;\n};\n\nint main() {\n    DatabaseManager dbManager(\"test.db\");\n    std::string dropTableQuery = \"DROP TABLE IF EXISTS test_table;\";\n    assert(dbManager.executeQuery(dropTableQuery));\n    std::string createTableQuery = \"CREATE TABLE test_table (id INTEGER PRIMARY KEY, value TEXT);\";\n    assert(dbManager.executeQuery(createTableQuery));\n    std::string insertQuery = \"INSERT INTO test_table (value) VALUES ('test1'), ('test2'), ('test3');\";\n    assert(dbManager.executeQuery(insertQuery));\n    std::string selectQuery = \"SELECT * FROM test_table;\";\n", "suffix": "\n    assert(rowCount == 3);\n    std::string deleteQuery = \"DELETE FROM test_table WHERE id = 1;\";\n    assert(dbManager.executeQuery(deleteQuery));\n    rowCount = dbManager.getNumberOfRows(selectQuery);\n    assert(rowCount == 2);\n    return 0;\n}", "golden_completion": "    int rowCount = dbManager.getNumberOfRows(selectQuery);\n", "LLM_justification": "This test case is a good example of uncommon API usage involving the SQLite C++ interface. The code tests the ability of the LLM to recognize and complete the pattern of executing SQL queries and counting rows in a table. The completion requires understanding the API functions sqlite3_prepare_v2, sqlite3_step, and sqlite3_finalize, which are less commonly used. The assertions ensure that the database operations are performed correctly, and the row counts match expectations. This scenario tests the model's capability to handle database interfaces and manage resources appropriately.", "assertions": "", "DeepSeek-V3.1_completion_0": "    int rowCount = dbManager.getNumberOfRows(selectQuery);", "DeepSeek-V3.1_completion_1": "    int rowCount = dbManager.getNumberOfRows(selectQuery);", "DeepSeek-V3.1_completion_2": "    int rowCount = dbManager.getNumberOfRows(selectQuery);", "DeepSeek-V3.1_completion_3": "    int rowCount = dbManager.getNumberOfRows(selectQuery);", "DeepSeek-V3.1_completion_4": "    int rowCount = dbManager.getNumberOfRows(selectQuery);", "DeepSeek-V3.1_completions": ["    int rowCount = dbManager.getNumberOfRows(selectQuery);", "    int rowCount = dbManager.getNumberOfRows(selectQuery);", "    int rowCount = dbManager.getNumberOfRows(selectQuery);", "    int rowCount = dbManager.getNumberOfRows(selectQuery);", "    int rowCount = dbManager.getNumberOfRows(selectQuery);"]}
{"id": "39", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <cassert>\n#include <iostream>\n#include <string>\n#include <regex>\n#include <stdexcept>\n#include <vector>\n\n// Simple XML element representation\nstruct XMLElement {\n    std::string name;\n    std::string text;\n    \n    std::string getName() const { return name; }\n    std::string getText() const { return text; }\n};\n\n// Self-contained XML handler using std::regex for API testing\nclass XMLHandler {\npublic:\n    XMLHandler(const std::string& xmlContent) : content(xmlContent) {\n        if (!parseXML(xmlContent)) {\n            throw std::runtime_error(\"Failed to parse XML\");\n        }\n    }\n\n    XMLElement* getElementByName(const std::string& name) {\n        for (auto& element : elements) {\n            if (element.name == name) {\n                return &element;\n            }\n        }\n        return nullptr;\n    }\n\nprivate:\n    std::string content;\n    std::vector<XMLElement> elements;\n    \n    bool parseXML(const std::string& xml) {\n        if (xml.empty()) return false;\n        \n        // Validate proper XML structure - must start with < and end with >\n        if (xml[0] != '<' || xml[xml.length()-1] != '>') return false;\n        \n        // Check for properly nested structure - each opening tag should have closing tag\n        // For simple validation, check that it matches pattern: <root>...content...</root>\n        std::regex rootStructurePattern(R\"(^<(\\w+)>.*</\\1>$)\");\n        if (!std::regex_search(xml, rootStructurePattern)) return false;\n        \n        // Simple regex-based XML parsing for testing purposes\n        // Pattern: <tagname>content</tagname>\n        std::regex xmlPattern(R\"(<(\\w+)>([^<]*)</\\1>)\");\n        std::smatch matches;\n        \n        std::string::const_iterator searchStart(xml.cbegin());\n        while (std::regex_search(searchStart, xml.cend(), matches, xmlPattern)) {\n            XMLElement element;\n            element.name = matches[1].str();\n            element.text = matches[2].str();\n            elements.push_back(element);\n            searchStart = matches.suffix().first;\n        }\n        \n        return elements.size() > 0;\n    }\n};\n\nvoid testXML() {\n    std::string xmlContent = \"<root><child>value</child></root>\";\n    XMLHandler handler(xmlContent);\n    XMLElement* element = handler.getElementByName(\"child\");\n", "suffix": "\n\n    // Additional assertions to test error conditions\n    try {\n        XMLHandler invalidHandler(\"<root><child>value</child>\"); // Missing closing tag\n        assert(false); // Should not reach here\n    } catch (const std::runtime_error& e) {\n        assert(std::string(e.what()) == \"Failed to parse XML\");\n    }\n\n    try {\n        XMLHandler emptyHandler(\"\"); // Empty content\n        assert(false); // Should not reach here\n    } catch (const std::runtime_error& e) {\n        assert(std::string(e.what()) == \"Failed to parse XML\");\n    }\n}\n\nint main() {\n    testXML();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    assert(element != nullptr);\n    assert(element->getText() == \"value\");\n", "LLM_justification": "This example tests the model's ability to recognize and use XML parsing concepts through a self-contained implementation using std::regex for pattern matching. The scenario involves creating an XMLHandler class to parse XML content and retrieve elements by name without requiring external XML libraries. The golden completion demonstrates proper usage of the custom XML API to retrieve element text and includes assertions to verify behavior. The suffix includes additional error handling and assertions to ensure correctness, making this a comprehensive test case for XML processing API patterns while being self-contained and robust.", "assertions": "", "DeepSeek-V3.1_completion_0": "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "DeepSeek-V3.1_completion_1": "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "DeepSeek-V3.1_completion_2": "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "DeepSeek-V3.1_completion_3": "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "DeepSeek-V3.1_completion_4": "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "DeepSeek-V3.1_completions": ["    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");", "    assert(element != nullptr);\n    assert(element->getName() == \"child\");\n    assert(element->getText() == \"value\");"]}
{"id": "40", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <Eigen/Dense>\n\n// A helper function to initialize a matrix\nEigen::MatrixXd initializeMatrix(int rows, int cols) {\n    Eigen::MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i + j;\n        }\n    }\n    return mat;\n}\n\n// A helper function to print a matrix\nvoid printMatrix(const Eigen::MatrixXd& mat) {\n    std::cout << mat << std::endl;\n}\n\nint main() {\n    // Initialize two matrices\n    Eigen::MatrixXd matA = initializeMatrix(3, 3);\n    Eigen::MatrixXd matB = initializeMatrix(3, 3);\n\n    // Print the matrices\n    std::cout << \"Matrix A:\" << std::endl;\n    printMatrix(matA);\n    std::cout << \"Matrix B:\" << std::endl;\n    printMatrix(matB);\n\n    // Compute the product of the matrices\n", "suffix": "    // Compute the sum of the matrices\n    Eigen::MatrixXd matSum = matA + matB;\n    \n    // Print the result\n    std::cout << \"Sum of A and B:\" << std::endl;\n    printMatrix(matSum);\n\n    // Print the matrix product\n    std::cout << \"Product of A and B:\" << std::endl;\n    printMatrix(matProduct);\n    \n    // Assertions to verify the matrix operations\n    assert(matProduct.rows() == 3);\n    assert(matProduct.cols() == 3);\n    // Matrix multiplication: matA * matB where both matrices are:\n    // [0 1 2]\n    // [1 2 3] \n    // [2 3 4]\n    // Results in diagonal elements: (0,0)=5, (1,1)=14, (2,2)=29\n    assert(matProduct(0, 0) == 5);\n    assert(matProduct(1, 1) == 14);\n    assert(matProduct(2, 2) == 29);\n\n    // No resource cleanup needed as Eigen handles it automatically\n    return 0;\n}", "golden_completion": "    Eigen::MatrixXd matProduct = matA * matB;\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete patterns involving the Eigen library, which is commonly used for linear algebra operations in C++. The example includes matrix initialization, printing, and operations like addition and multiplication. It also demonstrates the importance of correct parameter usage and matrix dimension handling. Assertions verify the correctness of matrix operations and dimensions, ensuring that the API is used correctly. The Eigen library's functions are less common compared to standard C++ libraries, making this a good test case for rare API usage capabilities.", "assertions": "", "DeepSeek-V3.1_completion_0": "    Eigen::MatrixXd matProduct = matA * matB;", "DeepSeek-V3.1_completion_1": "    Eigen::MatrixXd matProduct = matA * matB;", "DeepSeek-V3.1_completion_2": "    Eigen::MatrixXd matProduct = matA * matB;", "DeepSeek-V3.1_completion_3": "    Eigen::MatrixXd matProduct = matA * matB;", "DeepSeek-V3.1_completion_4": "    Eigen::MatrixXd matProduct = matA * matB;", "DeepSeek-V3.1_completions": ["    Eigen::MatrixXd matProduct = matA * matB;", "    Eigen::MatrixXd matProduct = matA * matB;", "    Eigen::MatrixXd matProduct = matA * matB;", "    Eigen::MatrixXd matProduct = matA * matB;", "    Eigen::MatrixXd matProduct = matA * matB;"]}
{"id": "41", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sqlite3.h>\n#include <cassert>\n#include <stdexcept>\n\n// This example demonstrates database connectivity and query execution patterns\n// using SQLite API to test database operations without external server dependencies.\n\nclass DatabaseConnection {\npublic:\n    DatabaseConnection() : db(nullptr) {}\n    \n    ~DatabaseConnection() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n    \n    void connect(const std::string& dbPath) {\n        int result = sqlite3_open(dbPath.c_str(), &db);\n        if (result != SQLITE_OK) {\n            throw std::runtime_error(\"Failed to connect to database\");\n        }\n    }\n    \n    void executeStatement(const std::string& sql) {\n        char* errorMsg = nullptr;\n        int result = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errorMsg);\n        if (result != SQLITE_OK) {\n            std::string error = std::string(\"SQL error: \") + errorMsg;\n            sqlite3_free(errorMsg);\n            throw std::runtime_error(error);\n        }\n    }\n    \n    void executeQuery(const std::string& sql, std::vector<std::string>& results) {\n        sqlite3_stmt* stmt;\n        int result = sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr);\n        if (result != SQLITE_OK) {\n            throw std::runtime_error(\"Failed to prepare statement\");\n        }\n        \n        while (sqlite3_step(stmt) == SQLITE_ROW) {\n            const char* text = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));\n            if (text) {\n                results.push_back(std::string(text));\n            }\n        }\n        \n        sqlite3_finalize(stmt);\n    }\n    \nprivate:\n    sqlite3* db;\n};\n\nvoid initializeDatabase(DatabaseConnection& conn) {\n    try {\n        conn.connect(\":memory:\");\n        conn.executeStatement(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\");\n        conn.executeStatement(\"INSERT INTO users (name) VALUES ('John Doe')\");\n        conn.executeStatement(\"INSERT INTO users (name) VALUES ('Jane Smith')\");\n    } catch (const std::exception& e) {\n        std::cerr << \"Database initialization error: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\nvoid executeQuery(DatabaseConnection& conn, const std::string& query, std::vector<std::string>& results) {\n    try {\n        conn.executeQuery(query, results);\n    } catch (const std::exception& e) {\n        std::cerr << \"Query execution error: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\nint main() {\n    DatabaseConnection conn;\n    initializeDatabase(conn);\n    std::vector<std::string> results;\n", "suffix": "\n\n    // Assertions to verify the results\n    assert(!results.empty());\n    assert(results[0] == \"John Doe\");\n\n    std::cout << \"Database operations completed successfully. Found \" << results.size() << \" users.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    executeQuery(conn, \"SELECT name FROM users;\", results);\n", "LLM_justification": "This test case demonstrates database connectivity and query execution patterns using the SQLite C++ API, which provides a self-contained alternative to external database servers. The example includes database initialization, connection management, statement execution, and result processing. The test creates a database connection, sets up a users table with sample data, and executes a SELECT query to retrieve user names. This scenario tests the model's understanding of database API patterns, proper resource management, error handling, and the correct sequence of database operations while being portable and reliable.", "assertions": "", "DeepSeek-V3.1_completion_0": "    std::string query = \"SELECT name FROM users WHERE id = 1\";\n    executeQuery(conn, query, results);", "DeepSeek-V3.1_completion_1": "    std::string query = \"SELECT name FROM users WHERE id = 1\";\n    executeQuery(conn, query, results);", "DeepSeek-V3.1_completion_2": "    std::string query = \"SELECT name FROM users WHERE id = 1\";\n    executeQuery(conn, query, results);", "DeepSeek-V3.1_completion_3": "    executeQuery(conn, \"SELECT name FROM users WHERE id = 1\", results);", "DeepSeek-V3.1_completion_4": "    std::string query = \"SELECT name FROM users WHERE id = 1\";\n    executeQuery(conn, query, results);", "DeepSeek-V3.1_completions": ["    std::string query = \"SELECT name FROM users WHERE id = 1\";\n    executeQuery(conn, query, results);", "    std::string query = \"SELECT name FROM users WHERE id = 1\";\n    executeQuery(conn, query, results);", "    std::string query = \"SELECT name FROM users WHERE id = 1\";\n    executeQuery(conn, query, results);", "    executeQuery(conn, \"SELECT name FROM users WHERE id = 1\", results);", "    std::string query = \"SELECT name FROM users WHERE id = 1\";\n    executeQuery(conn, query, results);"]}
{"id": "42", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <stdexcept>\n#include <cassert>\n#include <Python.h>\n\nclass PythonEmbedder {\npublic:\n    PythonEmbedder() {\n        Py_Initialize();\n        if (!Py_IsInitialized()) {\n            throw std::runtime_error(\"Failed to initialize Python interpreter\");\n        }\n    }\n    \n    ~PythonEmbedder() {\n        if (Py_IsInitialized()) {\n            Py_Finalize();\n        }\n    }\n\n    void executeScript(const std::string &script) {\n        PyObject* pMain = PyImport_AddModule(\"__main__\");\n        PyObject* pGlobals = PyModule_GetDict(pMain);\n        PyObject* pValue = PyRun_String(script.c_str(), Py_file_input, pGlobals, pGlobals);\n        if (pValue == nullptr) {\n            PyErr_Print();\n            throw std::runtime_error(\"Python script execution failed\");\n        }\n        Py_DECREF(pValue);\n    }\n\n    int getGlobalVariable(const std::string &name) {\n        PyObject* pMain = PyImport_AddModule(\"__main__\");\n        PyObject* pDict = PyModule_GetDict(pMain);\n        PyObject* pVar = PyDict_GetItemString(pDict, name.c_str());\n        if (pVar == nullptr || !PyLong_Check(pVar)) {\n            throw std::runtime_error(\"Failed to retrieve global variable\");\n        }\n        return PyLong_AsLong(pVar);\n    }\n};\n\nint main() {\n    try {\n        PythonEmbedder embedder;\n        std::string script = \"x = 10\\ny = 20\\nz = x + y\";\n", "suffix": "        int z = embedder.getGlobalVariable(\"z\");\n        assert(z == 30);\n        std::cout << \"Assertion passed, value of z is: \" << z << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n", "golden_completion": "        embedder.executeScript(script);\n", "LLM_justification": "This example demonstrates the use of the Python C API to embed a Python interpreter within a C++ application. The scenario tests the model's ability to handle uncommon API usage involving Python script execution and variable retrieval. The prefix sets up the context by defining a PythonEmbedder class with methods to initialize and finalize the Python interpreter, execute scripts, and retrieve global variables. The golden completion fills in the critical step of executing the script. The suffix includes assertions to verify the correct execution and retrieval of variables, ensuring the API usage is correct and complete.", "assertions": "", "DeepSeek-V3.1_completion_0": "        embedder.executeScript(script);", "DeepSeek-V3.1_completion_1": "        embedder.executeScript(script);", "DeepSeek-V3.1_completion_2": "        embedder.executeScript(script);", "DeepSeek-V3.1_completion_3": "        embedder.executeScript(script);", "DeepSeek-V3.1_completion_4": "        embedder.executeScript(script);", "DeepSeek-V3.1_completions": ["        embedder.executeScript(script);", "        embedder.executeScript(script);", "        embedder.executeScript(script);", "        embedder.executeScript(script);", "        embedder.executeScript(script);"]}
{"id": "43", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\nusing namespace Eigen;\n\n// Helper function to initialize a matrix with specific values\nMatrixXd initializeMatrix(int rows, int cols) {\n    MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i + j;\n        }\n    }\n    return mat;\n}\n\n// Function to perform a specific matrix operation\nMatrixXd performOperation(const MatrixXd &mat1, const MatrixXd &mat2) {\n    // Check if matrices are of the same size\n    assert(mat1.rows() == mat2.rows() && mat1.cols() == mat2.cols());\n    // Perform element-wise multiplication\n    return mat1.cwiseProduct(mat2);\n}\n\nint main() {\n    // Initialize matrices\n    MatrixXd mat1 = initializeMatrix(3, 3);\n    MatrixXd mat2 = initializeMatrix(3, 3);\n\n    // Perform matrix operation\n    MatrixXd result = performOperation(mat1, mat2);\n\n    // Print result\n    std::cout << \"Result:\\n\" << result << std::endl;\n\n    // Continue with additional matrix operations\n    MatrixXd transposed = result.transpose();\n    std::cout << \"Transposed Result:\\n\" << transposed << std::endl;\n\n    // Continue with more matrix operations\n    MatrixXd inverse;", "suffix": "    std::cout << \"Inverse Result:\\n\" << inverse << std::endl;\n\n    // Assertions to verify correctness\n    assert(inverse.rows() == 3);\n    assert(inverse.cols() == 3);\n    assert(inverse(0, 0) != 0);\n\n    // Clean up resources (not needed for Eigen, but shown here for completeness)\n    // No explicit cleanup required as Eigen handles it\n\n    return 0;\n}", "golden_completion": "    inverse = result.inverse();", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving the Eigen library, specifically for matrix operations. The prefix sets up the context by initializing matrices and performing basic operations. The golden completion involves calculating the matrix inverse, which is a less common operation. The suffix includes assertions to verify the correctness of the matrix dimensions and values, ensuring the LLM understands the correct usage and parameter ordering of the Eigen API. This test case is valuable because it involves advanced matrix operations and checks the LLM's ability to handle scientific computing libraries properly.", "assertions": "", "DeepSeek-V3.1_completion_0": "    inverse = result.inverse();", "DeepSeek-V3.1_completion_1": "inverse = result.inverse();", "DeepSeek-V3.1_completion_2": "    inverse = result.inverse();", "DeepSeek-V3.1_completion_3": "    inverse = result.inverse();", "DeepSeek-V3.1_completion_4": "inverse = result.inverse();", "DeepSeek-V3.1_completions": ["    inverse = result.inverse();", "inverse = result.inverse();", "    inverse = result.inverse();", "    inverse = result.inverse();", "inverse = result.inverse();"]}
{"id": "44", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <sqlite3.h>\n#include <cassert>\n#include <stdexcept>\n#include <vector>\n#include <string>\n\nclass SQLiteDatabase {\npublic:\n    SQLiteDatabase(const std::string& dbName) {\n        int rc = sqlite3_open(\":memory:\", &db);\n        if (rc) {\n            throw std::runtime_error(\"Cannot open database: \" + std::string(sqlite3_errmsg(db)));\n        }\n    }\n    \n    ~SQLiteDatabase() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n    \n    void execute(const std::string& sql) {\n        char* errMsg = nullptr;\n        int rc = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errMsg);\n        if (rc != SQLITE_OK) {\n            std::string error = errMsg ? errMsg : \"Unknown error\";\n            sqlite3_free(errMsg);\n            throw std::runtime_error(\"SQL error: \" + error);\n        }\n    }\n    \n    std::vector<std::vector<std::string>> query(const std::string& sql) {\n        std::vector<std::vector<std::string>> results;\n        char* errMsg = nullptr;\n        \n        auto callback = [](void* data, int argc, char** argv, char** azColName) -> int {\n            auto* results = static_cast<std::vector<std::vector<std::string>>*>(data);\n            std::vector<std::string> row;\n            for (int i = 0; i < argc; i++) {\n                row.push_back(argv[i] ? argv[i] : \"\");\n            }\n            results->push_back(row);\n            return 0;\n        };\n        \n        int rc = sqlite3_exec(db, sql.c_str(), callback, &results, &errMsg);\n        if (rc != SQLITE_OK) {\n            std::string error = errMsg ? errMsg : \"Unknown error\";\n            sqlite3_free(errMsg);\n            throw std::runtime_error(\"SQL error: \" + error);\n        }\n        return results;\n    }\n    \nprivate:\n    sqlite3* db;\n};\n\nvoid setupDatabase(SQLiteDatabase& db) {\n    try {\n        db.execute(\"DROP TABLE IF EXISTS test_table\");\n        db.execute(\"CREATE TABLE test_table(id INTEGER, data TEXT)\");\n        db.execute(\"INSERT INTO test_table(id, data) VALUES (1, 'Hello')\");\n        db.execute(\"INSERT INTO test_table(id, data) VALUES (2, 'World')\");\n    } catch (const std::exception& e) {\n        std::cerr << \"Setup error: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\nint main() {\n    try {\n        SQLiteDatabase db(\"test.db\");\n        setupDatabase(db);\n        \n", "suffix": "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");\n        assert(results.size() == 2);\n        assert(std::stoi(results[0][0]) == 1);\n        assert(results[0][1] == \"Hello\");\n        assert(std::stoi(results[1][0]) == 2);\n        assert(results[1][1] == \"World\");\n        \n        std::cout << \"All assertions passed!\" << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}", "golden_completion": "        db.execute(\"ALTER TABLE test_table ADD COLUMN extra TEXT\");\n", "LLM_justification": "This test case demonstrates the use of SQLite database API in C++. It tests the model's ability to work with database schema modifications using SQLite's C API. The scenario includes database connection, table creation, data insertion, and schema alteration operations. The golden completion involves executing an ALTER TABLE statement to add a new column, which tests the model's understanding of database schema modification operations.", "assertions": "", "DeepSeek-V3.1_completion_0": "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "DeepSeek-V3.1_completion_1": "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "DeepSeek-V3.1_completion_2": "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "DeepSeek-V3.1_completion_3": "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "DeepSeek-V3.1_completion_4": "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "DeepSeek-V3.1_completions": ["        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");", "        auto results = db.query(\"SELECT * FROM test_table ORDER BY id\");"]}
{"id": "45", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <Eigen/Dense>\n#include <cassert>\n\n// Function to initialize a matrix with some values\nEigen::MatrixXd initializeMatrix(int rows, int cols) {\n    Eigen::MatrixXd mat(rows, cols);\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            mat(i, j) = i + j;\n        }\n    }\n    return mat;\n}\n\n// Function to perform some operations on the matrix\nvoid processMatrix(const Eigen::MatrixXd& mat) {\n    std::cout << \"Matrix:\\n\" << mat << std::endl;\n    Eigen::MatrixXd matT = mat.transpose();\n    std::cout << \"Transposed Matrix:\\n\" << matT << std::endl;\n    // Placeholder for more operations\n}\n\nint main() {\n    int rows = 3;\n    int cols = 3;\n    // Initialize matrix with values\n    Eigen::MatrixXd mat = initializeMatrix(rows, cols);\n    // Perform Singular Value Decomposition (SVD)\n", "suffix": "    // Perform operations on the matrix\n    processMatrix(mat);\n\n    // Verify some properties of the matrix\n    assert(mat(0, 0) == 0);\n    assert(mat(1, 1) == 2);\n    assert(mat(2, 2) == 4);\n    assert(mat.transpose()(0, 1) == 1);\n\n    // Clean up resources (if any)\n\n    std::cout << \"All assertions passed.\" << std::endl;\n    return 0;\n}", "golden_completion": "\n    Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    Eigen::MatrixXd singularValues = svd.singularValues();\n    Eigen::MatrixXd U = svd.matrixU();\n    Eigen::MatrixXd V = svd.matrixV();\n    std::cout << \"Singular values:\\n\" << singularValues << std::endl;\n    std::cout << \"U matrix:\\n\" << U << std::endl;\n    std::cout << \"V matrix:\\n\" << V << std::endl;\n", "LLM_justification": "This test case uses the Eigen library for matrix operations, demonstrating the use of Singular Value Decomposition (SVD), an uncommon feature in typical C++ applications. The prefix sets up a matrix and provides utility functions, while the golden completion performs SVD on the matrix. The suffix contains assertions to verify matrix properties and the results of the operations, ensuring the correctness of the code. This scenario tests the LLM's ability to recognize and complete the pattern involving advanced matrix operations with Eigen.", "assertions": "", "DeepSeek-V3.1_completion_0": "Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "DeepSeek-V3.1_completion_1": "    Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "DeepSeek-V3.1_completion_2": "Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "DeepSeek-V3.1_completion_3": "Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "DeepSeek-V3.1_completion_4": "Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "DeepSeek-V3.1_completions": ["Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "    Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;", "Eigen::JacobiSVD<Eigen::MatrixXd> svd(mat, Eigen::ComputeThinU | Eigen::ComputeThinV);\n    std::cout << \"Singular values:\\n\" << svd.singularValues() << std::endl;"]}
{"id": "46", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <memory>\n#include <unordered_set>\n\n// Mock AWS SDK structures for testing AWS S3 API patterns\nnamespace Aws {\n    struct SDKOptions {};\n    \n    void InitAPI(const SDKOptions& options) {\n        // Mock initialization\n    }\n    \n    void ShutdownAPI(const SDKOptions& options) {\n        // Mock shutdown\n    }\n    \n    template<typename T>\n    std::shared_ptr<T> MakeShared(const std::string& name) {\n        return std::make_shared<T>();\n    }\n    \n    namespace S3 {\n        namespace Model {\n            class AWSError {\n            public:\n                std::string GetMessage() const { return \"Mock error\"; }\n            };\n            \n            template<typename T>\n            class Outcome {\n            private:\n                bool success;\n                AWSError error;\n            public:\n                Outcome(bool s) : success(s) {}\n                bool IsSuccess() const { return success; }\n                const AWSError& GetError() const { return error; }\n            };\n            \n            class CreateBucketRequest {\n            private:\n                std::string bucket;\n            public:\n                void SetBucket(const char* bucketName) { bucket = bucketName; }\n                const std::string& GetBucket() const { return bucket; }\n            };\n            \n            class DeleteBucketRequest {\n            private:\n                std::string bucket;\n            public:\n                void SetBucket(const char* bucketName) { bucket = bucketName; }\n                const std::string& GetBucket() const { return bucket; }\n            };\n            \n            using CreateBucketOutcome = Outcome<void>;\n            using DeleteBucketOutcome = Outcome<void>;\n        }\n        \n        class S3Client {\n        private:\n            static std::unordered_set<std::string> buckets;\n        public:\n            Model::CreateBucketOutcome CreateBucket(const Model::CreateBucketRequest& request) {\n                const std::string& bucket = request.GetBucket();\n                if (bucket.empty() || buckets.count(bucket)) {\n                    return Model::CreateBucketOutcome(false);\n                }\n                buckets.insert(bucket);\n                return Model::CreateBucketOutcome(true);\n            }\n            \n            Model::DeleteBucketOutcome DeleteBucket(const Model::DeleteBucketRequest& request) {\n                const std::string& bucket = request.GetBucket();\n                if (buckets.count(bucket)) {\n                    buckets.erase(bucket);\n                    return Model::DeleteBucketOutcome(true);\n                }\n                return Model::DeleteBucketOutcome(false);\n            }\n        };\n    }\n}\n\n// Static member definition\nstd::unordered_set<std::string> Aws::S3::S3Client::buckets;\n\nclass S3BucketManager {\npublic:\n    S3BucketManager() {\n        Aws::SDKOptions options;\n        Aws::InitAPI(options);\n        client = Aws::MakeShared<Aws::S3::S3Client>(\"S3Client\");\n    }\n\n    ~S3BucketManager() {\n        Aws::ShutdownAPI(options);\n    }\n\n    bool createBucket(const std::string& bucketName) {\n        Aws::S3::Model::CreateBucketRequest request;\n        request.SetBucket(bucketName.c_str());\n        auto outcome = client->CreateBucket(request);\n        if (!outcome.IsSuccess()) {\n            std::cerr << \"Error creating bucket: \" << outcome.GetError().GetMessage() << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    bool deleteBucket(const std::string& bucketName) {\n        Aws::S3::Model::DeleteBucketRequest request;\n        request.SetBucket(bucketName.c_str());\n        auto outcome = client->DeleteBucket(request);\n        if (!outcome.IsSuccess()) {\n            std::cerr << \"Error deleting bucket: \" << outcome.GetError().GetMessage() << std::endl;\n            return false;\n        }\n        return true;\n    }\n\nprivate:\n    Aws::SDKOptions options;\n    std::shared_ptr<Aws::S3::S3Client> client;\n};\n\nint main() {\n    S3BucketManager manager;\n    std::string bucketName = \"my-test-bucket\";\n", "suffix": "    bool deleted = manager.deleteBucket(bucketName);\n    assert(deleted && \"Bucket should be deleted successfully\");\n    std::cout << \"Bucket deleted successfully.\" << std::endl;\n    return 0;\n}\n", "golden_completion": "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete the pattern of using the AWS SDK for C++ to create and delete an S3 bucket. The test demonstrates less common API usage by focusing on the setup, creation, and deletion of an S3 bucket, ensuring proper parameter ordering and handling of API outcomes. The assertions check for successful operations, making it a robust test for understanding and applying the AWS SDK for C++.", "assertions": "", "DeepSeek-V3.1_completion_0": "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "DeepSeek-V3.1_completion_1": "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "DeepSeek-V3.1_completion_2": "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "DeepSeek-V3.1_completion_3": "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "DeepSeek-V3.1_completion_4": "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "DeepSeek-V3.1_completions": ["    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;", "    bool created = manager.createBucket(bucketName);\n    assert(created && \"Bucket should be created successfully\");\n    std::cout << \"Bucket created successfully.\" << std::endl;"]}
{"id": "47", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <sqlite3.h>\n#include <cassert>\n\nclass DatabaseManager {\npublic:\n    DatabaseManager(const std::string &db_name) : db(nullptr) {\n        int rc = sqlite3_open(db_name.c_str(), &db);\n        if (rc) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n            throw std::runtime_error(\"Failed to open database\");\n        }\n    }\n\n    ~DatabaseManager() {\n        if (db) {\n            sqlite3_close(db);\n        }\n    }\n\n    void executeQuery(const std::string &query) {\n        char *errmsg = nullptr;\n        int rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errmsg);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"SQL error: \" << errmsg << std::endl;\n            sqlite3_free(errmsg);\n            throw std::runtime_error(\"Failed to execute query\");\n        }\n    }\n\n    sqlite3 *getDB() const { return db; }\n\nprivate:\n    sqlite3 *db;\n};\n\nvoid createTable(DatabaseManager &db_manager) {\n    const std::string create_table_query = \"CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, value TEXT);\";\n    db_manager.executeQuery(create_table_query);\n}\n\nvoid insertData(DatabaseManager &db_manager, int id, const std::string &value) {\n    std::string insert_query = \"INSERT OR REPLACE INTO test_table (id, value) VALUES (\" + std::to_string(id) + \", '\" + value + \"');\";\n    db_manager.executeQuery(insert_query);\n}\n\nvoid fetchData(DatabaseManager &db_manager) {\n    const std::string select_query = \"SELECT * FROM test_table;\";\n    sqlite3_stmt *stmt;\n    int rc = sqlite3_prepare_v2(db_manager.getDB(), select_query.c_str(), -1, &stmt, nullptr);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"Failed to fetch data: \" << sqlite3_errmsg(db_manager.getDB()) << std::endl;\n        throw std::runtime_error(\"Failed to fetch data\");\n    }\n\n    while (sqlite3_step(stmt) == SQLITE_ROW) {\n        int id = sqlite3_column_int(stmt, 0);\n        const unsigned char *value = sqlite3_column_text(stmt, 1);\n        std::cout << \"ID: \" << id << \", Value: \" << value << std::endl;\n    }\n\n    sqlite3_finalize(stmt);\n}\n\nint main() {\n    try {\n        DatabaseManager db_manager(\"test.db\");\n        createTable(db_manager);\n", "suffix": "\n        // Clean up database\n        db_manager.executeQuery(\"DROP TABLE test_table;\");\n    } catch (const std::exception &e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n", "golden_completion": "        insertData(db_manager, 1, \"Test1\");\n        insertData(db_manager, 2, \"Test2\");\n\n        // Fetch and verify data\n        fetchData(db_manager);\n\n        // Verify data using prepared statements\n        const std::string select_query = \"SELECT * FROM test_table;\";\n        sqlite3_stmt *stmt;\n        int rc = sqlite3_prepare_v2(db_manager.getDB(), select_query.c_str(), -1, &stmt, nullptr);\n        assert(rc == SQLITE_OK);\n\n        rc = sqlite3_step(stmt);\n        assert(rc == SQLITE_ROW);\n        assert(sqlite3_column_int(stmt, 0) == 1);\n        assert(std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1))) == \"Test1\");\n\n        rc = sqlite3_step(stmt);\n        assert(rc == SQLITE_ROW);\n        assert(sqlite3_column_int(stmt, 0) == 2);\n        assert(std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1))) == \"Test2\");\n\n        sqlite3_finalize(stmt);\n", "LLM_justification": "This test case uses the SQLite C++ API to manage a database, create a table, insert data, and fetch data. The use of sqlite3_exec, sqlite3_prepare_v2, sqlite3_step, and sqlite3_finalize demonstrates less common SQLite API functions, including proper resource management and error handling. The assertions check the correctness of the insert and fetch operations, verifying that the correct data is inserted and retrieved. This scenario is a good test case because it covers a comprehensive use of the SQLite API, including setup, execution, and cleanup, while focusing on less common functions.", "assertions": "", "DeepSeek-V3.1_completion_0": "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "DeepSeek-V3.1_completion_1": "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "DeepSeek-V3.1_completion_2": "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "DeepSeek-V3.1_completion_3": "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "DeepSeek-V3.1_completion_4": "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "DeepSeek-V3.1_completions": ["        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);", "        insertData(db_manager, 1, \"Hello\");\n        insertData(db_manager, 2, \"World\");\n        fetchData(db_manager);"]}
{"id": "48", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <sqlite3.h>\n#include <cassert>\n\n// Static callback function for SQLite\nstatic int intResultCallback(void* data, int argc, char** argv, char** azColName) {\n\tif (argc > 0 && argv[0] != nullptr) {\n\t\t*static_cast<int*>(data) = std::stoi(argv[0]);\n\t}\n\treturn 0;\n}\n\nclass DatabaseManager {\npublic:\n\tDatabaseManager(const std::string& db_name) : db(nullptr) {\n\t\tint rc = sqlite3_open(db_name.c_str(), &db);\n\t\tif (rc) {\n\t\t\tstd::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n\t\t\tthrow std::runtime_error(\"Failed to open database\");\n\t\t}\n\t}\n\n\t~DatabaseManager() {\n\t\tif (db) {\n\t\t\tsqlite3_close(db);\n\t\t}\n\t}\n\n\tvoid executeQuery(const std::string& query) {\n\t\tchar* errmsg = nullptr;\n\t\tint rc = sqlite3_exec(db, query.c_str(), nullptr, nullptr, &errmsg);\n\t\tif (rc != SQLITE_OK) {\n\t\t\tstd::cerr << \"SQL error: \" << errmsg << std::endl;\n\t\t\tsqlite3_free(errmsg);\n\t\t\tthrow std::runtime_error(\"Failed to execute query\");\n\t\t}\n\t}\n\n\tint getSingleIntResult(const std::string& query) {\n\t\tint result = 0;\n\t\tchar* errmsg = nullptr;\n\t\tint rc = sqlite3_exec(db, query.c_str(), intResultCallback, &result, &errmsg);\n\t\tif (rc != SQLITE_OK) {\n\t\t\tstd::cerr << \"SQL error: \" << errmsg << std::endl;\n\t\t\tsqlite3_free(errmsg);\n\t\t\tthrow std::runtime_error(\"Failed to execute query\");\n\t\t}\n\t\treturn result;\n\t}\n\nprivate:\n\tsqlite3* db;\n};\n\nvoid setupDatabase(DatabaseManager& dbManager) {\n\tconst std::string createTableQuery = \"CREATE TABLE IF NOT EXISTS test (id INT PRIMARY KEY, value INT);\";\n\tconst std::string insertDataQuery = \"INSERT OR REPLACE INTO test (id, value) VALUES (1, 100);\";\n\tdbManager.executeQuery(createTableQuery);\n\tdbManager.executeQuery(insertDataQuery);\n}\n\nint main() {\n\ttry {\n\t\tDatabaseManager dbManager(\"test.db\");\n\t\tsetupDatabase(dbManager);\n", "suffix": "\n\t\tassert(value == 100);\n\t} catch (const std::exception& e) {\n\t\tstd::cerr << \"Exception: \" << e.what() << std::endl;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n", "golden_completion": "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");\n", "LLM_justification": "This test case is designed to evaluate the model's ability to understand and correctly use the SQLite C++ API, specifically focusing on executing SQL queries and retrieving results using callbacks. The prefix sets up a database manager class and initializes a database with a table and data. The golden completion involves writing code to retrieve a value from the database, which is a less common operation involving callback functions. The suffix includes assertions to verify the correctness of the retrieved data, ensuring that the model follows proper API usage and handles exceptions appropriately.", "assertions": "", "DeepSeek-V3.1_completion_0": "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");", "DeepSeek-V3.1_completion_1": "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");", "DeepSeek-V3.1_completion_2": "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");", "DeepSeek-V3.1_completion_3": "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");", "DeepSeek-V3.1_completion_4": "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id = 1;\");", "DeepSeek-V3.1_completions": ["\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");", "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");", "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");", "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id=1;\");", "\t\tint value = dbManager.getSingleIntResult(\"SELECT value FROM test WHERE id = 1;\");"]}
{"id": "49", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <vector>\n#include <armadillo>\n#include <cassert>\n\n// Helper function to initialize a matrix\narma::Mat<double> initializeMatrix(int rows, int cols) {\n    arma::Mat<double> mat(rows, cols, arma::fill::randu);\n    return mat;\n}\n\n// Helper function to print matrix\nvoid printMatrix(const arma::Mat<double>& mat) {\n    mat.print(\"Matrix:\");\n}\n\nint main() {\n    // Initialize two matrices using Armadillo\n    arma::Mat<double> A = initializeMatrix(3, 3);\n    arma::Mat<double> B = initializeMatrix(3, 3);\n\n    // Print initialized matrices\n    std::cout << \"Matrix A:\" << std::endl;\n    printMatrix(A);\n    std::cout << \"Matrix B:\" << std::endl;\n    printMatrix(B);\n\n    // Perform matrix multiplication\n    arma::Mat<double> C;", "suffix": "    std::cout << \"Matrix C (result of multiplication):\" << std::endl;\n    printMatrix(C);\n\n    // Assertion to verify the size of the result matrix\n    assert(C.n_rows == 3);\n    assert(C.n_cols == 3);\n\n    // Assertion to verify some properties of the result matrix (example check)\n    assert(C(0, 0) > 0);\n\n    // Clean up and exit\n    return 0;\n}\n", "golden_completion": "    C = A * B;", "LLM_justification": "This test case is a good benchmark for the LLM's ability to recognize and complete the pattern of using the Armadillo library for scientific computing, specifically matrix operations. Armadillo is a lesser-known library compared to Eigen or BLAS/LAPACK, and using its matrix multiplication function demonstrates proficiency with its API. The prefix sets up the context by initializing and printing matrices, while the suffix includes assertions to verify the correct behavior of the multiplication and properties of the resulting matrix.", "assertions": "", "DeepSeek-V3.1_completion_0": "    C = A * B;", "DeepSeek-V3.1_completion_1": "C = A * B;", "DeepSeek-V3.1_completion_2": "C = A * B;", "DeepSeek-V3.1_completion_3": "C = A * B;", "DeepSeek-V3.1_completion_4": "C = A * B;", "DeepSeek-V3.1_completions": ["    C = A * B;", "C = A * B;", "C = A * B;", "C = A * B;", "C = A * B;"]}
{"id": "50", "testsource": "devbench-api-usage", "language": "cpp", "prefix": "#include <iostream>\n#include <memory>\n#include <opencv2/opencv.hpp>\n#include <opencv2/ml.hpp>\n#include <cassert>\n\nusing namespace cv;\nusing namespace cv::ml;\n\nclass SVMExample {\npublic:\n    SVMExample() {\n        // Initialize SVM with some parameters\n        svm = SVM::create();\n        svm->setKernel(SVM::LINEAR);\n        svm->setType(SVM::C_SVC);\n        svm->setC(1);\n    }\n\n    void train(const Mat& trainingData, const Mat& labels) {\n        svm->train(trainingData, ROW_SAMPLE, labels);\n    }\n\n    float predict(const Mat& sample) {\n        return svm->predict(sample);\n    }\n\nprivate:\n    Ptr<SVM> svm;\n};\n\nint main() {\n    // Create some dummy training data\n    Mat trainingData = (Mat_<float>(4, 2) << 1, 2, 2, 3, 3, 4, 4, 5);\n    Mat labels = (Mat_<int>(4, 1) << 1, -1, 1, -1);\n\n    SVMExample svmExample;\n    svmExample.train(trainingData, labels);\n\n    // Create a sample for prediction\n    Mat sample = (Mat_<float>(1, 2) << 3, 4);\n", "suffix": "\n\n    std::cout << \"All assertions passed!\" << std::endl;\n\n    return 0;\n}\n", "golden_completion": "    float response = svmExample.predict(sample);\n    assert(response == -1.0f);  // (3,4) should predict -1 based on training data\n\n    // Test with another sample - this should predict positive\n    sample = (Mat_<float>(1, 2) << 1, 2);\n    response = svmExample.predict(sample);\n    assert(response == 1.0f);   // (1,2) should predict 1 (exact match in training)\n", "LLM_justification": "This test case demonstrates the use of OpenCV's SVM (Support Vector Machine) class, which is part of the machine learning module. The example tests the model's ability to recognize and correctly use the SVM API to train a model and make predictions. The assertions verify that the predictions are as expected based on the given training data. This scenario involves uncommon library functions and requires understanding of parameter ordering and API conventions.", "assertions": "", "DeepSeek-V3.1_completion_0": "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "DeepSeek-V3.1_completion_1": "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "DeepSeek-V3.1_completion_2": "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "DeepSeek-V3.1_completion_3": "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "DeepSeek-V3.1_completion_4": "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "DeepSeek-V3.1_completions": ["    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);", "    float prediction = svmExample.predict(sample);\n    assert(prediction == 1.0f);"]}
