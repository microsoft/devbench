{"id": "1", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    return `Hello, my name is ${this.name}`;\n  }\n}\n\nclass Employee extends Person {\n  constructor(name, age, jobTitle) {\n    super(name, age);\n    this.jobTitle = jobTitle;\n  }\n", "suffix": "  getJobTitle() {\n    return this.jobTitle;\n  }\n}\n\nconst emp = new Employee('Alice', 30, 'Engineer');\nconsole.assert(emp.getJobTitle() === 'Engineer', 'Job title should be Engineer');\nconsole.assert(emp.greet() === 'Hello, my name is Alice', 'Greeting should mention name');", "golden_completion": "  greet() {\n    return `Hello, my name is ${this.name} and I am an ${this.jobTitle}`;\n  }\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a pattern of method overriding in a class inheritance context. The prefix establishes a base class and a derived class, and the completion involves overriding a method in the derived class. The suffix provides different functionality, ensuring clear distinction and testing for correct behavior of both inherited and overridden methods.", "assertions": "console.assert(emp.greet() === 'Hello, my name is Alice and I am an Engineer', 'Greeting should include name and job title');", "Ministral-3B": "getJobTitle() {\n    return this.jobTitle;\n  }"}
{"id": "2", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Calculator {\n  add(a, b) {\n    return a + b;\n  }\n\n  subtract(a, b) {\n", "suffix": "    return a * b;\n  }\n}\n\nconst calc = new Calculator();\nconsole.assert(calc.add(5, 3) === 8, 'Add method failed');\nconsole.assert(calc.subtract(9, 4) === 5, 'Subtract method failed');\nconsole.assert(calc.multiply(4, 5) === 20, 'Multiply method failed');", "golden_completion": "    return a - b;\n  }\n\n  multiply(a, b) {", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete object-oriented patterns in JavaScript, specifically class methods. The prefix defines a class with an 'add' method, and the suffix calls these methods and includes assertions. The completion requires the LLM to identify the missing 'subtract' and 'multiply' methods. This scenario focuses on clear, minimal context to test the model's pattern recognition capabilities.", "assertions": "console.assert(calc.add(5, 3) === 8, 'Add method failed');\nconsole.assert(calc.subtract(9, 4) === 5, 'Subtract method failed');\nconsole.assert(calc.multiply(4, 5) === 20, 'Multiply method failed');", "Ministral-3B": "  subtract(a, b) {\n    return a - b;\n  }"}
{"id": "3", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n", "suffix": "}\n\nconst d = new Dog('Mitzie');\nd.speak();\n\n// Cleanup code\nconsole.log('Test completed.');", "golden_completion": "  speak() {\n    console.log(`${this.name} barks.`);\n  }", "LLM_justification": "This is a good test case for recognizing object-oriented patterns, specifically inheritance and method overriding. The prefix establishes a base class Animal with a method speak(). The golden completion requires the LLM to recognize that the derived class Dog should override the speak() method to provide a specific behavior. The suffix demonstrates the usage of the Dog class and verifies that the overridden method works correctly.", "assertions": "const assert = require('assert');\nconst capturedLogs = [];\nconst originalLog = console.log;\nconsole.log = (msg) => capturedLogs.push(msg);\n\nconst d = new Dog('Mitzie');\nd.speak();\n\nassert.strictEqual(capturedLogs[0], 'Mitzie barks.');\n\nconsole.log = originalLog;", "Ministral-3B": "class Dog extends Animal {\n  constructor(name) {\n    super(name);\n  }\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}"}
{"id": "4", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(function(num) {\n", "suffix": "});\n\nconsole.log(doubled); // Output: [2, 4, 6, 8, 10]\n\n// Assertions\nconst assert = require('assert');\nassert.deepStrictEqual(doubled, [2, 4, 6, 8, 10]);", "golden_completion": "  return num * 2;\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete a functional programming pattern using the map function on an array. The pattern of transforming each element in an array is common and should be easily identifiable with minimal context. The prefix and suffix combined are concise, ensuring a low-context scenario while the golden completion demonstrates a clear and expected transformation function. Assertions verify the correct transformation of the array.", "assertions": "const assert = require('assert');\nassert.deepStrictEqual(doubled, [2, 4, 6, 8, 10]);", "Ministral-3B": "const doubled = numbers.map(function(num) {\n    return num * 2;\n});"}
{"id": "5", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function processNumbers(numbers) {\n    return numbers.map(num =>", "suffix": " * 2);\n}\n\nconst result = processNumbers([1, 2, 3, 4]);\nconsole.log(result);\n\n// Clean up if needed", "golden_completion": " num", "LLM_justification": "This test case is a good example of low-context pattern matching because it requires the LLM to recognize the functional programming pattern of using the `map` method to transform an array. The completion involves a simple yet common operation within the map function, which is often seen in JavaScript code. The minimal context provided by the prefix should be sufficient for the LLM to infer the correct continuation.", "assertions": "const assert = require('assert');\nconst result = processNumbers([1, 2, 3, 4]);\nassert.deepStrictEqual(result, [2, 4, 6, 8]);\nconsole.log('All assertions passed.');", "Ministral-3B": "function processNumbers(numbers) {\n    return numbers.map(num => num * 2);\n}\n\nconst result = processNumbers([1, 2, 3, 4]);\nconsole.log(result);"}
{"id": "6", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Rectangle {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n  }\n\n", "suffix": "}\n\nconst rect = new Rectangle(10, 20);\nconsole.assert(rect.area() === 200, 'Area should be 200');\nconsole.assert(rect.perimeter() === 60, 'Perimeter should be 60');", "golden_completion": "  area() {\n    return this.width * this.height;\n  }\n\n  perimeter() {\n    return 2 * (this.width + this.height);\n  }\n", "LLM_justification": "This test case examines the model's ability to recognize and complete object-oriented patterns, specifically adding methods to a class. The prefix provides a class definition with a constructor, and the suffix includes assertions that test the expected behavior of the methods. The minimal context provided should be sufficient for the model to infer the correct implementation of the area and perimeter methods, which are standard geometric calculations.", "assertions": "console.assert(rect.area() === 200, 'Area should be 200');\nconsole.assert(rect.perimeter() === 60, 'Perimeter should be 60');", "Ministral-3B": "  area() {\n    return this.width * this.height;\n  },\n  perimeter() {\n    return 2 * (this.width + this.height);\n  }"}
{"id": "7", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "const numbers = [1, 2, 3, 4, 5];\n\nfunction doubleNumbers(arr) {", "suffix": "}\n\nconst result = doubleNumbers(numbers);\nconsole.assert(result.length === 5, 'Result should have 5 elements');\nconsole.assert(result[0] === 2, 'First element should be 2');\nconsole.assert(result[4] === 10, 'Last element should be 10');", "golden_completion": "\n  return arr.map(num => num * 2);", "LLM_justification": "This test case evaluates the model's ability to recognize a common array manipulation pattern (using map to transform array elements) with minimal context. The prefix sets up an array and a function definition, while the suffix contains assertions that check the correctness of the transformation.", "assertions": "console.assert(doubleNumbers([1, 2, 3, 4, 5]).length === 5, 'Result should have 5 elements');\nconsole.assert(doubleNumbers([1, 2, 3, 4, 5])[0] === 2, 'First element should be 2');\nconsole.assert(doubleNumbers([1, 2, 3, 4, 5])[4] === 10, 'Last element should be 10');", "Ministral-3B": "return arr.map(num => num * 2);"}
{"id": "8", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function processArray(arr) {\n  if (!Array.isArray(arr)) {\n    throw new Error('Input must be an array');\n  }\n  return arr.map((item, index) => {\n    if (typeof item !== 'number') {\n      throw new Error('Array elements must be numbers');\n    }\n", "suffix": "    return item * 2;\n  });\n}\n\ntry {\n  const result = processArray([1, 2, 3]);\n  console.assert(JSON.stringify(result) === JSON.stringify([2, 4, 6]), 'Test Case 1 Failed');\n  console.log('All test cases passed');\n} catch (e) {\n  console.error(e);\n}", "golden_completion": "    if (item < 0) {\n      throw new Error('Array elements must be non-negative');\n    }\n", "LLM_justification": "This test case checks the model's ability to recognize a pattern in validating and processing array elements. The prefix establishes checks for array type and numeric elements, while the golden completion adds a logical check for non-negative numbers. The suffix completes the map function and includes assertions to verify the expected behavior.", "assertions": "console.assert(JSON.stringify(processArray([1, 2, 3])) === JSON.stringify([2, 4, 6]), 'Positive numbers test failed');\ntry {\n  processArray([-1, 2, 3]);\n} catch (e) {\n  console.assert(e.message === 'Array elements must be non-negative', 'Negative number test failed');\n}", "Ministral-3B": "  return item * 2;"}
{"id": "9", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    return `Hello, my name is ${this.name}`;\n  }\n}\n\nclass Student extends Person {\n  constructor(name, age, grade) {\n    super(name, age);\n    this.grade = grade;\n  }\n\n  study() {\n    return `${this.name} is studying.`;\n  }\n", "suffix": "  getGrade() {\n    return `${this.name} is in grade ${this.grade}`;\n  }\n}\n\nconst student = new Student('Alice', 20, 'A');\nconsole.assert(student.greet() === 'Hello, my name is Alice');\nconsole.assert(student.study() === 'Alice is studying.');\nconsole.assert(student.getGrade() === 'Alice is in grade A');", "golden_completion": "  introduce() {\n    return `Hi, I'm ${this.name}, ${this.age} years old, and in grade ${this.grade}.`;\n  }\n", "LLM_justification": "This test case evaluates the model's ability to recognize and extend class inheritance patterns in JavaScript. The minimal context ensures the model must infer the appropriate class method structure and usage based on the given class hierarchy and methods. The provided assertions verify that the extended class behaves correctly, ensuring the model's completion is both syntactically and functionally accurate.", "assertions": "console.assert(student.introduce() === \"Hi, I'm Alice, 20 years old, and in grade A\");", "Ministral-3B": "getGrade() {\n    return `${this.name} is in grade ${this.grade}`;\n  }"}
{"id": "10", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Dog extends Animal {\n", "suffix": "  bark() {\n    return `${this.name} says woof!`;\n  }\n}\n\nconst myDog = new Dog('Rex');\nconsole.assert(myDog.bark() === 'Rex says woof!', 'Dog should bark correctly');", "golden_completion": "  constructor(name) {\n    super(name);\n  }\n", "LLM_justification": "This is a good test case because it checks the model's ability to recognize and complete a class inheritance pattern with minimal context. The completion involves extending a base class constructor using 'super()', which is a common and standardized pattern in object-oriented programming.", "assertions": "console.assert(new Dog('Max').name === 'Max', 'Dog name should be initialized correctly');", "Ministral-3B": "  bark() {\n    return `${this.name} says woof!`;\n  }"}
{"id": "11", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function processData(input) {\n    try {\n        if (!input) {\n            throw new Error('No input provided');\n        }\n", "suffix": "    } catch (e) {\n        console.error(e.message);\n        return null;\n    }\n    return input;\n}\n\n// Test cases\nconsole.assert(processData('data') === 'data', 'Test Case 1 Failed');\nconsole.assert(processData() === null, 'Test Case 2 Failed');\n", "golden_completion": "        // Process the input\n        input = input.trim();\n", "LLM_justification": "This test case is designed to check the model's ability to recognize and complete a pattern involving error handling and input processing. The prefix sets up a function with a try/catch block, and the completion should involve processing the input within the try block before the catch block handles any errors. This pattern is common in JavaScript and should be recognizable with minimal context.", "assertions": "console.assert(processData('  data  ') === 'data', 'Test Case 3 Failed');", "Ministral-3B": "    return input;"}
{"id": "12", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Counter {\n  constructor() {\n    this.count = 0;\n  }\n  increment() {", "suffix": "    return this.count;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment();\nconsole.assert(counter.count === 1, 'Counter should increment to 1');\ncounter.increment();\nconsole.assert(counter.count === 2, 'Counter should increment to 2');", "golden_completion": "    this.count += 1;", "LLM_justification": "This is a good test case for low-context pattern matching because it involves a simple class with a method that follows a universal pattern for incrementing a value. The context is minimal, yet the pattern of incrementing a counter is widely recognizable. The prefix and suffix provide enough information to identify and complete the pattern correctly.", "assertions": "console.assert(counter.count === 1, 'Counter should increment to 1');\ncounter.increment();\nconsole.assert(counter.count === 2, 'Counter should increment to 2');", "Ministral-3B": "this.count++;"}
{"id": "13", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n\n  speak() {", "suffix": "    console.log(`${this.name} barks.`);\n  }\n}\n\nconst dog = new Dog('Rex', 'German Shepherd');\ndog.speak(); // Expected output: 'Rex barks.'\n\nconst animal = new Animal('Generic Animal');\nanimal.speak(); // Expected output: 'Generic Animal makes a noise.'", "golden_completion": "    super.speak();\n", "LLM_justification": "This is a good test case for low-context pattern matching as it involves object-oriented patterns with classes and inheritance, where the model needs to recognize the `super` keyword usage in a subclass method. The completion requires adding a call to the parent class's method, which is a common pattern in object-oriented programming. The pattern should be recognizable with minimal context provided by the class definitions and method overrides.", "assertions": "const assert = require('assert');\nlet output = '';\nconst originalLog = console.log;\nconsole.log = (msg) => { output += msg + '\\n'; };\ntry {\n  const dog = new Dog('Rex', 'German Shepherd');\n  dog.speak();\n  assert(output.includes('Rex makes a noise.'));\n  assert(output.includes('Rex barks.'));\n  output = '';\n  const animal = new Animal('Generic Animal');\n  animal.speak();\n  assert.strictEqual(output, 'Generic Animal makes a noise.\\n');\n} finally {\n  console.log = originalLog;\n}", "Ministral-3B": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\nconst dog = new Dog('Rex', 'German Shepherd');\ndog.speak(); // Expected output: 'Rex barks.'\n\nconst animal = new Animal('Generic Animal');\nanimal.speak(); // Expected output: 'Generic Animal makes a noise.'"}
{"id": "14", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function processData(input) {\n    const result = input.map(item => item.trim());\n    const filtered = result.filter(item => item.length > 0);", "suffix": "    return filtered;\n}\n\nconst data = [\" apple \", \"\", \" banana \", \"  \", \" cherry  \"];\nconst output = processData(data);\n\nconsole.assert(output.length === 3, 'Filtered array should have 3 elements');\nconsole.assert(output.includes(\"apple\"), 'Output should include \"apple\"');\nconsole.assert(output.includes(\"banana\"), 'Output should include \"banana\"');\nconsole.assert(output.includes(\"cherry\"), 'Output should include \"cherry\"');", "golden_completion": "    const unique = [...new Set(filtered)];", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern in data structure manipulation, specifically working with arrays. The pattern involves mapping, filtering, and removing duplicates from an array. The completion requires understanding array methods and the Set object. The minimal context provided ensures that the model needs to understand the array processing pattern with limited lines of code.", "assertions": "console.assert(output.length === 3, 'Filtered array should have 3 elements');\nconsole.assert(output.includes(\"apple\"), 'Output should include \"apple\"');\nconsole.assert(output.includes(\"banana\"), 'Output should include \"banana\"');\nconsole.assert(output.includes(\"cherry\"), 'Output should include \"cherry\"');", "Ministral-3B": "const filtered = result.filter(item => item.length > 0);"}
{"id": "15", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function processData(data) {\n  const result = data.map(item => item * 2);\n", "suffix": "  return result.reduce((acc, curr) => acc + curr, 0);\n}\n\nconst data = [1, 2, 3, 4];\nconst output = processData(data);\nconsole.assert(output === 20, `Expected 20, but got ${output}`);\n", "golden_completion": "  // Filter out odd numbers\n  const filtered = result.filter(item => item % 2 === 0);\n", "LLM_justification": "This example tests the LLM's ability to recognize a common array manipulation pattern in JavaScript: mapping, filtering, and reducing. The completion involves filtering the mapped array, which is a recognizable and standard operation in functional programming. The prefix and suffix provide minimal context but enough to identify the pattern.", "assertions": "console.assert(JSON.stringify(processData([1, 2, 3, 4])) === '[4, 8]', 'Expected [4, 8] after filtering even numbers');", "Ministral-3B": "return result.reduce((acc, curr) => acc + curr, 0);"}
{"id": "16", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "const numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(number =>", "suffix": ");\nconsole.log(evens);\nconsole.assert(evens.length === 2, 'Should contain two elements');\nconsole.assert(evens[0] === 2, 'First element should be 2');\nconsole.assert(evens[1] === 4, 'Second element should be 4');", "golden_completion": " number % 2 === 0", "LLM_justification": "This is a good test case because it checks the LLM's ability to recognize and complete a common functional programming pattern in JavaScript: filtering an array based on a condition. The prefix provides minimal context by showing the beginning of a filter operation, and the suffix completes the pattern and includes assertions to verify correctness. The pattern is universally recognizable and requires minimal context to identify.", "assertions": "console.assert(evens.length === 2, 'Should contain two elements');\nconsole.assert(evens[0] === 2, 'First element should be 2');\nconsole.assert(evens[1] === 4, 'Second element should be 4');", "Ministral-3B": "number % 2 === 0"}
{"id": "17", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  sound() {", "suffix": "  }\n}\n\nconst dog = new Animal('Dog');\nconsole.assert(dog.name === 'Dog');\nconsole.assert(typeof dog.sound === 'function');\nconsole.assert(dog.sound() === '');", "golden_completion": "    return '';", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete a method inside a class. The prefix provides the class and method structure, while the suffix verifies the class instantiation and method functionality. The completion involves returning an empty string from the sound method, a simple and common pattern in object-oriented programming.", "assertions": "console.assert(dog.name === 'Dog');\nconsole.assert(typeof dog.sound === 'function');\nconsole.assert(dog.sound() === '');", "Ministral-3B": "  sound() {\n    return '';\n  }"}
{"id": "18", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function processStrings(strings) {\n    return strings.map(str => ", "suffix": ");\n}\n\nconst input = ['hello', 'world'];\nconst output = processStrings(input);\nconsole.assert(output[0] === 'HELLO', 'First string should be uppercased');\nconsole.assert(output[1] === 'WORLD', 'Second string should be uppercased');", "golden_completion": "str.toUpperCase()", "LLM_justification": "This test case evaluates the model's ability to complete a common string manipulation pattern (mapping an array to uppercase strings) with minimal context. The pattern is recognizable through the use of the map function and the common method toUpperCase. The prefix and suffix combined are concise, yet sufficient to establish the pattern and test correctness.", "assertions": "console.assert(output[0] === 'HELLO', 'First string should be uppercased');\nconsole.assert(output[1] === 'WORLD', 'Second string should be uppercased');", "Ministral-3B": "str.toUpperCase()"}
{"id": "19", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Vehicle {\n  constructor(type, speed) {\n    this.type = type;\n    this.speed = speed;\n  }\n  describe() {\n    return `This ${this.type} moves at ${this.speed} mph`;\n  }\n}\n\nclass Car extends Vehicle {\n  constructor(speed) {\n    super('car', speed);\n  }\n", "suffix": "const bike = new Bike(15);\nconsole.assert(bike.describe() === 'This bike moves at 15 mph', 'Bike description failed');\nconst car = new Car(120);\nconsole.assert(car.describe() === 'This car moves at 120 mph', 'Car description failed');\n", "golden_completion": "}\n\nclass Bike extends Vehicle {\n  constructor(speed) {\n    super('bike', speed);\n  }\n}\n", "LLM_justification": "This test case demonstrates inheritance in object-oriented programming with JavaScript classes. The low-context scenario tests the LLM's ability to recognize and extend a pattern where subclasses inherit properties and methods from a parent class. The prefix establishes the pattern with the Vehicle and Car classes, and the golden completion requires creating a similar Bike class. The assertions ensure that the describe method works correctly for both Car and Bike instances, validating the inheritance pattern.", "assertions": "const car = new Car(120);\nconsole.assert(car.describe() === 'This car moves at 120 mph', 'Car description failed');\nconst bike = new Bike(15);\nconsole.assert(bike.describe() === 'This bike moves at 15 mph', 'Bike description failed');", "Ministral-3B": "class Bike extends Vehicle {\n  constructor(speed) {\n    super('bike', speed);\n  }\n}"}
{"id": "20", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n", "suffix": "  bark() {\n    return `${this.name} barks!`;\n  }\n}\n\nconst myDog = new Dog('Fido', 'Labrador');\n", "golden_completion": "  getBreed() {\n    return this.breed;\n  }\n", "LLM_justification": "This is a good test case for recognizing and completing object-oriented patterns, specifically inheritance and method definition within a subclass. The prefix establishes a clear pattern of class extension and method definition, and the golden completion requires the model to recognize and extend this pattern by adding a new method. The minimal context tests the model's ability to infer appropriate class methods based on the established pattern.", "assertions": "const assert = require('assert');\nassert.strictEqual(myDog.getBreed(), 'Labrador');\nassert.strictEqual(myDog.bark(), 'Fido barks!');", "Ministral-3B": "  bark() {\n    return `${this.name} barks!`;\n  }"}
{"id": "21", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Animal {\n    constructor(name) {\n        this.name = name;\n    }\n    speak() {\n        console.log(`${this.name} makes a noise.`);\n    }\n}\nclass Dog extends Animal {\n    speak() {\n", "suffix": "        console.log(`${this.name} barks.`);\n    }\n}\nconst d = new Dog('Rex');\nd.speak();\n", "golden_completion": "        super.speak();\n", "LLM_justification": "This test case checks the LLM's ability to recognize and continue a common object-oriented pattern in JavaScript, specifically method overriding with super calls in class inheritance. The minimal context provided should be sufficient for the model to infer that the super call is necessary to maintain the pattern.", "assertions": "const output = [];\nconsole.log = (msg) => output.push(msg);\nconst d = new Dog('Rex');\nd.speak();\nconsole.assert(output.includes('Rex makes a noise.'), 'Base class method not called');\nconsole.assert(output.includes('Rex barks.'), 'Derived class method not called');\n", "Ministral-3B": "console.log(`${this.name} barks.`);"}
{"id": "22", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    return `Hello, my name is ${this.name}.`;\n  }\n}\n\nclass Student extends Person {\n  constructor(name, age, grade) {\n    super(name, age);\n    this.grade = grade;\n  }\n\n  ", "suffix": "study() {\n    return `${this.name} is studying.`;\n  }\n}\n\nconst student = new Student('Alice', 20, 'A');\nconsole.assert(student.greet() === 'Hello, my name is Alice.');\nconsole.assert(student.study() === 'Alice is studying.');\n", "golden_completion": "introduce() {\n    return `I am ${this.name}, a ${this.grade} grade student.`;\n  }", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a class-based inheritance pattern in JavaScript. The completion involves adding a method to the `Student` class, which is a subclass of `Person`. The pattern is clear and follows standard object-oriented conventions, making it a good test case for low-context recognition.", "assertions": "console.assert(student.introduce() === 'I am Alice, a A grade student.');", "Ministral-3B": "study() {\n  return `${this.name} is studying.`;\n}"}
{"id": "23", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "const arr = [1, 2, 3, 4, 5];\nconst doubled = arr.map(", "suffix": ");\nconsole.log(doubled);\n// Output should be [2, 4, 6, 8, 10]", "golden_completion": "x => x * 2", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common array manipulation pattern using the map function in JavaScript. The pattern of doubling elements in an array is simple, yet requires understanding of higher-order functions and arrow functions. The context is minimal but sufficient to infer the expected transformation.", "assertions": "const assert = require('assert');\nassert.deepStrictEqual(doubled, [2, 4, 6, 8, 10]);", "Ministral-3B": "const doubled = arr.map(num => num * 2);"}
{"id": "24", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "const myMap = new Map();\nmyMap.set('key1', 'value1');\nmyMap.set('key2', 'value2');\n\nfunction getValueFromMap(key) {", "suffix": "}\n\nconst result1 = getValueFromMap('key1');\nconst result2 = getValueFromMap('key2');\n\nconsole.assert(result1 === 'value1', 'Test 1 Failed');\nconsole.assert(result2 === 'value2', 'Test 2 Failed');", "golden_completion": "  return myMap.get(key);", "LLM_justification": "This example tests the LLM's ability to recognize a common pattern of retrieving values from a Map object in JavaScript. The prefix sets up the Map and the function definition, and the suffix contains the function calls and assertions to check correctness. The pattern of using Map's get method is universally recognizable and requires minimal context.", "assertions": "console.assert(getValueFromMap('key1') === 'value1', 'Assertion Failed: key1 should return value1');\nconsole.assert(getValueFromMap('key2') === 'value2', 'Assertion Failed: key2 should return value2');", "Ministral-3B": "return myMap.get(key);"}
{"id": "25", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "const data = [1, 2, 3, 4, 5];\n\nfunction processData(arr) {\n    return arr.map(x => x * 2);\n}\n\nconst result = ", "suffix": ";\n\nconsole.log(result);\n\n// Assertions\nconst assert = require('assert');\nassert.deepStrictEqual(result, [2, 4, 6, 8, 10]);", "golden_completion": "processData(data)", "LLM_justification": "This scenario involves data structure manipulation, specifically array processing. The prefix sets up a recognizable pattern of using the `map` function to transform an array. The low-context nature of the task is evident as the completion requires the model to correctly identify the use of the `processData` function with the `data` array to produce the expected result. This tests the model's ability to recognize and continue the pattern of functional programming constructs with minimal context.", "assertions": "const assert = require('assert');\nassert.deepStrictEqual(result, [2, 4, 6, 8, 10]);", "Ministral-3B": "result = processData(data);"}
{"id": "26", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function processData(array) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected an array');\n  }\n\n  let result = array.map(item => item * 2);\n", "suffix": "  return result.filter(item => item > 10);\n}\n\nconst input = [3, 5, 7, 10, 12];\nconst output = processData(input);\nconsole.assert(Array.isArray(output), 'Output should be an array');\nconsole.assert(output.length === 2, 'Output array should have two elements');\nconsole.assert(output[0] === 14, 'First element should be 14');\nconsole.assert(output[1] === 24, 'Second element should be 24');", "golden_completion": "  result = result.map(item => item + 1);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize a common pattern in array manipulation. The pattern involves mapping an array, applying a transformation, and then filtering based on a condition. The minimal context provides enough information to infer that another transformation should be applied before filtering. The assertions ensure that the correct transformations and filtering are applied to the array elements.", "assertions": "console.assert(Array.isArray(output), 'Output should be an array');\nconsole.assert(output.length === 2, 'Output array should have two elements');\nconsole.assert(output[0] === 14, 'First element should be 14');\nconsole.assert(output[1] === 24, 'Second element should be 24');", "Ministral-3B": "return result.filter(item => item > 10);"}
{"id": "27", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class DataFetcher {\n  constructor(url) {\n    this.url = url;\n  }\n\n  async fetchData() {\n    const response = await fetch(this.url);\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    return await response.json();\n  }\n\n  static async fetchAll(urls) {", "suffix": "    return await Promise.all(promises);\n  }\n}\n\nconst urls = ['https://api.example.com/data1', 'https://api.example.com/data2'];\nDataFetcher.fetchAll(urls).then(results => {\n  console.log(results);\n}).catch(error => {\n  console.error(error);\n});", "golden_completion": "    const promises = urls.map(url => new DataFetcher(url).fetchData());", "LLM_justification": "This example tests the LLM's ability to recognize and complete an advanced async pattern involving Promise.all with a custom class method. The context provided is minimal but sufficient to establish the need for mapping over URLs and fetching data asynchronously. The LLM must understand how to create promises for each URL and handle them using Promise.all.", "assertions": "const assert = require('assert');\n(async () => {\n  class DataFetcher {\n    constructor(url) {\n      this.url = url;\n    }\n\n    async fetchData() {\n      const response = await fetch(this.url);\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return await response.json();\n    }\n\n    static async fetchAll(urls) {\n      const promises = urls.map(url => new DataFetcher(url).fetchData());\n      return await Promise.all(promises);\n    }\n  }\n\n  const mockFetch = url => {\n    return Promise.resolve({\n      ok: true,\n      json: () => Promise.resolve({ data: url })\n    });\n  };\n\n  global.fetch = mockFetch;\n\n  const urls = ['https://api.example.com/data1', 'https://api.example.com/data2'];\n  const results = await DataFetcher.fetchAll(urls);\n  assert.deepStrictEqual(results, [{ data: 'https://api.example.com/data1' }, { data: 'https://api.example.com/data2' }]);\n})();", "Ministral-3B": "    const promises = urls.map(url => DataFetcher.fetchData(url));\n    return await Promise.all(promises);"}
{"id": "28", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class DataFetcher {\n  constructor() {\n    this.cache = new Map();\n  }\n\n  async fetchData(url) {\n    if (this.cache.has(url)) {\n      return this.cache.get(url);\n    }\n    const response = await fetch(url);\n    const data = await response.json();\n", "suffix": "    this.cache.set(url, data);\n    return data;\n  }\n}\n\n// Test the DataFetcher class\n(async () => {\n  const fetcher = new DataFetcher();\n  const data = await fetcher.fetchData('https://api.example.com/data');\n  console.assert(data !== null, 'Data should not be null');\n})();", "golden_completion": "    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete an async pattern within a class method. The pattern involves fetching data from a URL, handling potential errors, and caching the results. The low-context nature of the code snippet requires the model to understand async/await, error handling, and Map usage within a class structure. This scenario is non-trivial and requires genuine understanding of JavaScript language semantics.", "assertions": "const assert = require('assert');\nconst fetch = require('node-fetch');\n\n(async () => {\n  const fetcher = new DataFetcher();\n  try {\n    const data = await fetcher.fetchData('https://api.example.com/data');\n    assert(data !== null, 'Data should not be null');\n  } catch (error) {\n    assert(error.message.includes('HTTP error!'), 'Should throw an HTTP error on fetch failure');\n  }\n})();\n", "Ministral-3B": "  this.cache.set(url, data);"}
{"id": "29", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.running = false;\n  }\n\n  async runTask(task) {\n    this.running = true;\n    await task();\n    this.running = false;\n    this.next();\n  }\n\n  next() {\n    if (this.queue.length > 0 && !this.running) {\n      const nextTask = this.queue.shift();\n      this.runTask(nextTask);\n    }\n  }\n", "suffix": "}\n\nconst queue = new AsyncQueue();\nqueue.enqueue(async () => {\n  await new Promise(resolve => setTimeout(resolve, 100));\n  console.log('Task 1 done');\n});\nqueue.enqueue(async () => {\n  await new Promise(resolve => setTimeout(resolve, 50));\n  console.log('Task 2 done');\n});\nqueue.enqueue(async () => {\n  await new Promise(resolve => setTimeout(resolve, 150));\n  console.log('Task 3 done');\n});", "golden_completion": "  enqueue(task) {\n    this.queue.push(task);\n    this.next();\n  }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete an async pattern involving an asynchronous queue implementation. The pattern includes managing a task queue, handling async execution, and ensuring tasks are run sequentially without overlap. The minimal context requires understanding of async/await, queue management, and method implementation in a class.", "assertions": "const assert = require('assert');\nconst log = console.log;\nconsole.log = () => {};\nconst logs = [];\nconsole.log = (msg) => logs.push(msg);\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n(async () => {\n  await delay(400); // Wait enough time for all tasks to complete\n  assert.strictEqual(logs[0], 'Task 1 done');\n  assert.strictEqual(logs[1], 'Task 2 done');\n  assert.strictEqual(logs[2], 'Task 3 done');\n  console.log = log; // Restore original console.log\n})();", "Ministral-3B": "enqueue(task) {\n  this.queue.push(task);\n}"}
{"id": "30", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class RateLimiter {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.activeCount = 0;\n  }\n\n  enqueue(promiseFn) {\n    return new Promise((resolve, reject) => {", "suffix": "      this.queue.push({ promiseFn, resolve, reject });\n      this.dequeue();\n    });\n  }\n\n  dequeue() {\n    if (this.activeCount < this.limit && this.queue.length > 0) {\n      const { promiseFn, resolve, reject } = this.queue.shift();\n      this.activeCount++;\n      promiseFn().then(resolve, reject).finally(() => {\n        this.activeCount--;\n        this.dequeue();\n      });\n    }\n  }\n}\n\nconst limiter = new RateLimiter(2);\n\nconst task = (id) => () => new Promise(resolve => {\n  console.log(`Task ${id} started`);\n  setTimeout(() => {\n    console.log(`Task ${id} finished`);\n    resolve(id);\n  }, 1000);\n});\n\nPromise.all([\n  limiter.enqueue(task(1)),\n  limiter.enqueue(task(2)),\n  limiter.enqueue(task(3)),\n  limiter.enqueue(task(4)),\n]).then(results => {\n  console.log('All tasks finished:', results);\n});", "golden_completion": "      if (this.activeCount < this.limit) {\n        const { promiseFn, resolve, reject } = this.queue.shift();\n        this.activeCount++;\n        promiseFn().then(resolve, reject).finally(() => {\n          this.activeCount--;\n          this.dequeue();\n        });\n      }", "LLM_justification": "This example is a good test case for low-context pattern recognition because it requires understanding of advanced async patterns, specifically a custom rate limiter using Promises. The model must recognize the enqueue-dequeue logic and correctly implement the rate limiting control flow. This scenario involves executing Promises in a controlled manner, ensuring only a limited number of Promises run concurrently. This requires deeper comprehension of JavaScript's async capabilities and proper handling of Promise resolution and rejection.", "assertions": "const assert = require('assert');\nconst limiter = new RateLimiter(2);\nconst results = [];\nconst task = (id) => () => new Promise(resolve => {\n  setTimeout(() => resolve(id), 1000);\n});\nPromise.all([\n  limiter.enqueue(task(1)),\n  limiter.enqueue(task(2)),\n  limiter.enqueue(task(3)),\n  limiter.enqueue(task(4)),\n]).then(res => {\n  results.push(...res);\n  assert.deepStrictEqual(results, [1, 2, 3, 4], 'All tasks should complete in order');\n});", "Ministral-3B": "  this.queue.push({ promiseFn, resolve, reject });"}
{"id": "31", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.processing = false;\n  }\n\n  enqueue(promiseFunction) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ promiseFunction, resolve, reject });\n      this.process();\n    });\n  }\n\n  async process() {\n    if (this.processing) return;\n    this.processing = true;\n    while (this.queue.length > 0) {", "suffix": "      const { resolve, reject } = this.queue.shift();\n      try {\n        const result = await promiseFunction();\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    }\n    this.processing = false;\n  }\n}\n\n// Test the AsyncQueue\nconst delay = (ms) => new Promise((res) => setTimeout(res, ms));\nconst queue = new AsyncQueue();\n\nqueue.enqueue(() => delay(100).then(() => 'Task 1')).then(console.log);\nqueue.enqueue(() => delay(50).then(() => 'Task 2')).then(console.log);\nqueue.enqueue(() => delay(150).then(() => 'Task 3')).then(console.log);\n", "golden_completion": "      const { promiseFunction, resolve, reject } = this.queue.shift();", "LLM_justification": "This example tests the model's ability to recognize and complete an advanced async pattern involving a custom asynchronous queue. The pattern involves managing a queue of promise-returning functions and processing them sequentially. The challenge lies in correctly extracting and invoking the promise function from the queue with proper error handling. This is a realistic scenario that requires understanding of both async/await and promise mechanics, making it a good test case for low-context pattern matching.", "assertions": "const assert = require('assert');\n\n(async () => {\n  const results = [];\n  const originalLog = console.log;\n  console.log = (msg) => results.push(msg);\n\n  await queue.enqueue(() => delay(100).then(() => 'Task 1'));\n  await queue.enqueue(() => delay(50).then(() => 'Task 2'));\n  await queue.enqueue(() => delay(150).then(() => 'Task 3'));\n\n  console.log = originalLog;\n\n  assert.deepStrictEqual(results, ['Task 1', 'Task 2', 'Task 3']);\n})();", "Ministral-3B": "    const { promiseFunction, resolve, reject } = this.queue.shift();\n    try {\n      const result = await promiseFunction();\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }"}
{"id": "32", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class RateLimiter {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.activeCount = 0;\n  }\n\n  async _next() {\n    if (this.queue.length === 0) return;\n    if (this.activeCount >= this.limit) return;\n\n    const { fn, resolve, reject } = this.queue.shift();\n    this.activeCount++;\n    try {\n      const result = await fn();\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    } finally {\n      this.activeCount--;\n      this._next();\n    }\n  }\n\n  enqueue(fn) {", "suffix": "  }\n}\n\nasync function testRateLimiter() {\n  const limiter = new RateLimiter(2);\n  let results = [];\n  for (let i = 0; i < 5; i++) {\n    results.push(limiter.enqueue(() => new Promise((resolve) => setTimeout(() => resolve(i), 100))));\n  }\n  results = await Promise.all(results);\n  console.assert(results.length === 5, 'Expected 5 results');\n  console.assert(results.every((val, index) => val === index), 'Results should match indices');\n}\ntestRateLimiter();", "golden_completion": "    return new Promise((resolve, reject) => {\n      this.queue.push({ fn, resolve, reject });\n      this._next();\n    });", "LLM_justification": "This example demonstrates an advanced async pattern with a custom implementation of a rate limiter using promises. The pattern involves enqueuing functions and processing them with a concurrency limit, which is non-trivial and requires understanding of promises, async/await, and control flow. The minimal context tests the model's ability to complete the implementation of the `enqueue` method correctly.", "assertions": "console.assert(typeof RateLimiter === 'function', 'RateLimiter should be a function');\nconsole.assert(typeof RateLimiter.prototype.enqueue === 'function', 'RateLimiter should have an enqueue method');\nconsole.assert(RateLimiter.prototype._next.length === 0, '_next method should not take any arguments');", "Ministral-3B": "enqueue(fn) {\n  return new Promise((resolve, reject) => {\n    this.queue.push({ fn, resolve, reject });\n    this._next();\n  });\n}"}
{"id": "33", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class RateLimiter {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.activeCount = 0;\n  }\n\n  _next() {\n    if (this.queue.length > 0 && this.activeCount < this.limit) {\n      const { fn, resolve, reject } = this.queue.shift();\n      this.activeCount++;\n      fn().then(resolve).catch(reject).finally(() => {\n        this.activeCount--;\n        this._next();\n      });\n    }\n  }\n\n  schedule(fn) {\n    return new Promise((resolve, reject) => {", "suffix": "    });\n  }\n}\n\nconst limiter = new RateLimiter(2);\n\nconst asyncTask = (taskName, delay) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(taskName);\n    }, delay);\n  });\n};\n\nconst tasks = [\n  () => asyncTask('task1', 100),\n  () => asyncTask('task2', 200),\n  () => asyncTask('task3', 300),\n  () => asyncTask('task4', 400)\n];\n\n(async () => {\n  const results = await Promise.all(tasks.map(task => limiter.schedule(task)));\n  console.log(results); // Should print ['task1', 'task2', 'task3', 'task4']\n})();", "golden_completion": "      this.queue.push({ fn, resolve, reject });\n      this._next();", "LLM_justification": "This example tests the LLM's ability to recognize and complete a rate limiting pattern using Promises and async control flow. The RateLimiter class is designed to handle concurrent tasks with a limit, pushing tasks into a queue and processing them as slots become available. The golden completion involves correctly enqueuing a task and invoking the _next method to process the queue. This scenario requires understanding of advanced JavaScript features like Promises, async control flow, and method binding, making it a challenging and realistic test case.", "assertions": "const assert = require('assert');\n\n(async () => {\n  const limiter = new RateLimiter(2);\n\n  const asyncTask = (taskName, delay) => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(taskName);\n      }, delay);\n    });\n  };\n\n  const tasks = [\n    () => asyncTask('task1', 100),\n    () => asyncTask('task2', 200),\n    () => asyncTask('task3', 300),\n    () => asyncTask('task4', 400)\n  ];\n\n  const results = await Promise.all(tasks.map(task => limiter.schedule(task)));\n  assert.deepStrictEqual(results, ['task1', 'task2', 'task3', 'task4']);\n})();", "Ministral-3B": "  this.queue.push({ fn, resolve, reject });\n  this._next();"}
{"id": "34", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n  }\n\n  enqueue(promiseFunc) {\n    this.queue.push(promiseFunc);\n    this.processQueue();\n  }\n\n  async processQueue() {\n    if (this.isProcessing) return;\n    this.isProcessing = true;\n\n    while (this.queue.length > 0) {\n      const promiseFunc = this.queue.shift();\n", "suffix": "\n    }\n\n    this.isProcessing = false;\n  }\n}\n\n// Test the AsyncQueue\nconst queue = new AsyncQueue();\nlet result = 0;\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => { result += 1; resolve(); }, 100)));\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => { result += 2; resolve(); }, 50)));\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => { result += 3; resolve(); }, 10)));\n\nsetTimeout(() => { console.assert(result === 6, 'Result should be 6'); }, 200);", "golden_completion": "      try {\n        await promiseFunc();\n      } catch (error) {\n        console.error('Error processing queue item:', error);\n      }", "LLM_justification": "This test case demonstrates a custom async queue implementation using advanced JavaScript features such as async functions and queue management. The minimal context provided in the prefix and suffix requires the model to understand the pattern of processing asynchronous tasks in a queue, handling errors, and ensuring proper execution flow. The complexity of managing asynchronous control flow and error handling within the queue makes this a suitable test for low-context pattern recognition.", "assertions": "console.assert(result === 6, 'Result should be 6');", "Ministral-3B": "    await promiseFunc();\n  }"}
{"id": "35", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.pendingPromise = false;\n  }\n\n  enqueue(task) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ task, resolve, reject });\n      this.dequeue();\n    });\n  }\n\n  async dequeue() {\n    if (this.pendingPromise || this.queue.length === 0) return;\n    this.pendingPromise = true;\n    const { task, resolve, reject } = this.queue.shift();\n", "suffix": "    } catch (error) {\n      reject(error);\n    } finally {\n      this.pendingPromise = false;\n      this.dequeue();\n    }\n  }\n}\n\nconst queue = new AsyncQueue();\n\nqueue.enqueue(async () => {\n  return 'Task 1';\n}).then(result => console.log(result));\n\nqueue.enqueue(async () => {\n  throw new Error('Task 2 failed');\n}).catch(error => console.log(error.message));\n\nsetTimeout(() => {\n  queue.enqueue(async () => {\n    return 'Task 3';\n  }).then(result => console.log(result));\n}, 100);", "golden_completion": "    try {\n      const result = await task();\n      resolve(result);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete an advanced async pattern in JavaScript. The `AsyncQueue` class is designed to handle enqueuing and dequeuing tasks with proper async control flow, error handling, and resource management. The completion requires understanding of promises, async/await, and queue management. The context provided is minimal but sufficient for a senior developer to infer the correct pattern. The suffix demonstrates usage and testing of the pattern, ensuring the completion must fit seamlessly.", "assertions": "const assert = require('assert');\n(async () => {\n  const queue = new AsyncQueue();\n  const results = [];\n  queue.enqueue(async () => 'Task 1').then(result => results.push(result));\n  queue.enqueue(async () => { throw new Error('Task 2 failed'); }).catch(error => results.push(error.message));\n  await new Promise(resolve => setTimeout(resolve, 150));\n  queue.enqueue(async () => 'Task 3').then(result => results.push(result));\n  await new Promise(resolve => setTimeout(resolve, 150));\n  assert.deepStrictEqual(results, ['Task 1', 'Task 2 failed', 'Task 3']);\n})();", "Ministral-3B": "  try {\n    await task();\n    resolve();\n  } catch (error) {\n    reject(error);\n  }"}
{"id": "36", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function asyncRateLimit(fn, limit) {\n  let calls = [];\n  let active = 0;\n  async function executeNext() {\n    if (active < limit && calls.length > 0) {\n      active++;\n      const { resolve, reject, args } = calls.shift();\n      try {", "suffix": "      } catch (error) {\n        reject(error);\n      } finally {\n        active--;\n        executeNext();\n      }\n    }\n  }\n  return function(...args) {\n    return new Promise((resolve, reject) => {\n      calls.push({ resolve, reject, args });\n      executeNext();\n    });\n  };\n}\n\n// Test cases\nconst limitedFn = asyncRateLimit(async (x) => x * 2, 2);\n(async () => {\n  let results = await Promise.all([limitedFn(1), limitedFn(2), limitedFn(3), limitedFn(4)]);\n  console.log(results); // Should be [2, 4, 6, 8]\n})();\n", "golden_completion": "        const result = await fn(...args);\n        resolve(result);", "LLM_justification": "This example tests the model's ability to complete a complex async pattern involving rate limiting with a custom Promise implementation. It includes advanced async control flow and requires understanding of how to manage concurrency with async/await. The pattern is non-trivial and recognizable to experienced JavaScript developers, making it a good test for low-context pattern matching. The completion demonstrates correct usage of async/await within a custom executor function, and the assertions validate the rate limiting behavior.", "assertions": "const assert = require('assert');\n(async () => {\n  const limitedFn = asyncRateLimit(async (x) => x * 2, 2);\n  let results = await Promise.all([limitedFn(1), limitedFn(2), limitedFn(3), limitedFn(4)]);\n  assert.deepStrictEqual(results, [2, 4, 6, 8]);\n})();", "Ministral-3B": "  try {\n    const result = await fn(...args);\n    resolve(result);\n  }"}
{"id": "37", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.pendingPromise = false;\n  }\n\n  enqueue(task) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ task, resolve, reject });\n      this.processQueue();\n    });\n  }\n\n  async processQueue() {\n    if (this.pendingPromise) return;\n    if (this.queue.length === 0) return;\n    const { task, resolve, reject } = this.queue.shift();\n    this.pendingPromise = true;\n    try {\n      const result = await task();\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    } finally {", "suffix": "    }\n  }\n}\n\n// Test case\n(async () => {\n  const queue = new AsyncQueue();\n  const results = [];\n  results.push(await queue.enqueue(() => Promise.resolve(1)));\n  results.push(await queue.enqueue(() => Promise.resolve(2)));\n  console.assert(results[0] === 1, 'First task should resolve to 1');\n  console.assert(results[1] === 2, 'Second task should resolve to 2');\n})();", "golden_completion": "      this.pendingPromise = false;\n      this.processQueue();", "LLM_justification": "This example tests the LLM's ability to understand and complete an async pattern involving an async queue implementation. The pattern involves maintaining state across asynchronous operations and ensuring tasks are processed in sequence. This requires understanding of Promises, async/await, and queue management, which are advanced JavaScript concepts.", "assertions": "console.assert(results[0] === 1, 'First task should resolve to 1');\nconsole.assert(results[1] === 2, 'Second task should resolve to 2');", "Ministral-3B": "this.pendingPromise = false;"}
{"id": "38", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.processing = false;\n  }\n\n  async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n    while (this.queue.length > 0) {\n      const task = this.queue.shift();\n      await task();\n    }\n    this.processing = false;\n  }\n\n  enqueue(task) {", "suffix": "    this.processQueue();\n  }\n}\n\nconst queue = new AsyncQueue();\nlet result = [];\nqueue.enqueue(async () => { result.push(1); });\nqueue.enqueue(async () => { result.push(2); });\nqueue.enqueue(async () => { result.push(3); });\n\nsetTimeout(() => {\n  console.log(result); // Expect [1, 2, 3]\n  console.assert(JSON.stringify(result) === JSON.stringify([1, 2, 3]), 'Tasks did not execute in order');\n}, 1000);", "golden_completion": "    this.queue.push(task);", "LLM_justification": "This is a good test case because it involves an advanced async pattern, specifically implementing an asynchronous queue. The task demonstrates understanding of async/await, queue data structure, and proper handling of async control flow. The minimal context provided should be enough to recognize the pattern of enqueuing tasks and processing them sequentially.", "assertions": "setTimeout(() => { console.assert(JSON.stringify(result) === JSON.stringify([1, 2, 3]), 'Tasks did not execute in order'); }, 1000);", "Ministral-3B": "this.queue.push(task);"}
{"id": "39", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class RateLimiter {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.activeCount = 0;\n  }\n\n  async _next() {\n    if (this.queue.length === 0 || this.activeCount >= this.limit) {\n      return;\n    }\n    this.activeCount++;\n    const { resolve } = this.queue.shift();\n    resolve();\n  }\n\n  async run(task) {\n", "suffix": "    this.activeCount--;\n    this._next();\n  }\n}\n\nconst limiter = new RateLimiter(2);\n\nconst task = async (id) => {\n  console.log(`Starting task ${id}`);\n  await new Promise(resolve => setTimeout(resolve, 100));\n  console.log(`Finished task ${id}`);\n};\n\n(async () => {\n  await Promise.all([\n    limiter.run(() => task(1)),\n    limiter.run(() => task(2)),\n    limiter.run(() => task(3)),\n    limiter.run(() => task(4))\n  ]);\n})();", "golden_completion": "    await new Promise(resolve => {\n      this.queue.push({ resolve });\n      this._next();\n    });\n    await task();", "LLM_justification": "This example tests the ability to recognize and complete an async pattern involving custom rate limiting. The task involves understanding how to queue tasks and manage concurrency limits using Promises. This requires a deep understanding of JavaScript's async/await and Promise mechanisms, making it a good test case for advanced pattern recognition.", "assertions": "const assert = require('assert');\nlet taskOrder = [];\nconst originalConsoleLog = console.log;\nconsole.log = (msg) => taskOrder.push(msg);\n\n(async () => {\n  await Promise.all([\n    limiter.run(() => task(1)),\n    limiter.run(() => task(2)),\n    limiter.run(() => task(3)),\n    limiter.run(() => task(4))\n  ]);\n\n  assert.strictEqual(taskOrder.length, 8, 'Expected 8 log entries');\n  assert.strictEqual(taskOrder.filter(msg => msg.startsWith('Starting')).length, 4, 'Expected 4 Starting log entries');\n  assert.strictEqual(taskOrder.filter(msg => msg.startsWith('Finished')).length, 4, 'Expected 4 Finished log entries');\n  console.log = originalConsoleLog;\n})();", "Ministral-3B": "this.activeCount--;"}
{"id": "40", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class Queue {\n  constructor() {\n    this.items = [];\n  }\n  enqueue(element) {\n    this.items.push(element);\n  }\n", "suffix": "  dequeue() {\n    if(this.isEmpty()) {\n      throw new Error('Queue is empty');\n    }\n    return this.items.shift();\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\n// Test the Queue implementation\nconst q = new Queue();\nq.enqueue(1);\nq.enqueue(2);\nq.enqueue(3);\nconsole.assert(q.dequeue() === 1, 'Dequeue should return 1');\nconsole.assert(q.dequeue() === 2, 'Dequeue should return 2');\nconsole.assert(q.dequeue() === 3, 'Dequeue should return 3');\nconsole.assert(q.isEmpty(), 'Queue should be empty after dequeuing all items');", "golden_completion": "  peek() {\n    if(this.isEmpty()) {\n      throw new Error('Queue is empty');\n    }\n    return this.items[0];\n  }\n", "LLM_justification": "This test case challenges the LLM to recognize the pattern of a queue data structure and implement a 'peek' method that returns the first element without removing it. The context is minimal, but the pattern of a queue class with enqueue, dequeue, and isEmpty methods is clear. The completion requires understanding of class methods, error handling, and array operations.", "assertions": "console.assert((new Queue()).peek === undefined, 'peek method should be defined');", "Ministral-3B": "  dequeue() {\n    if(this.isEmpty()) {\n      throw new Error('Queue is empty');\n    }\n    return this.items.shift();\n  }"}
{"id": "41", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.processing = false;\n  }\n\n  async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const { task, resolve, reject } = this.queue.shift();\n      try {\n        const result = await task();\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      }\n    }\n\n    this.processing = false;\n  }\n\n  enqueue(task) {\n", "suffix": "    this.processQueue();\n  }\n}\n\nconst q = new AsyncQueue();\nq.enqueue(async () => 'Task 1 complete').then(console.log).catch(console.error);\nq.enqueue(async () => { throw new Error('Task 2 failed'); }).then(console.log).catch(console.error);\n\nsetTimeout(() => {\n  q.enqueue(async () => 'Task 3 complete').then(console.log).catch(console.error);\n}, 1000);", "golden_completion": "    return new Promise((resolve, reject) => {\n      this.queue.push({ task, resolve, reject });\n    });", "LLM_justification": "This example tests the LLM's ability to recognize and complete a custom async pattern involving a queue, Promises, and async/await. The prefix sets up an AsyncQueue class with a processQueue method and an incomplete enqueue method. The completion involves adding tasks to the queue and returning a Promise. This requires understanding of asynchronous control flow, Promises, and task scheduling. The suffix demonstrates the usage and handling of the queue with assertions verifying correct task processing and error handling. The combined length of prefix and suffix is within the 10-20 lines limit, providing low-context yet challenging scenario.", "assertions": "const assert = require('assert');\nconst q = new AsyncQueue();\n\nq.enqueue(async () => 'Task 1').then(result => assert.strictEqual(result, 'Task 1')).catch(() => assert.fail('Task 1 should not fail'));\nq.enqueue(async () => { throw new Error('Task 2'); }).then(() => assert.fail('Task 2 should fail')).catch(err => assert.strictEqual(err.message, 'Task 2'));\n\nsetTimeout(() => {\n  q.enqueue(async () => 'Task 3').then(result => assert.strictEqual(result, 'Task 3')).catch(() => assert.fail('Task 3 should not fail'));\n}, 1000);", "Ministral-3B": "this.processQueue();"}
{"id": "42", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.processing = false;\n  }\n\n  enqueue(promiseFactory) {\n    this.queue.push(promiseFactory);\n    if (!this.processing) {\n      this.processing = true;\n      this.processQueue();\n    }\n  }\n\n  async processQueue() {\n", "suffix": "    this.processing = false;\n  }\n}\n\n// Test the AsyncQueue with a mock async function\nconst queue = new AsyncQueue();\nconst results = [];\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve(1), 100)));\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve(2), 50)));\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve(3), 150)));\n\nsetTimeout(() => {\n  assert.deepStrictEqual(results, [1, 2, 3], 'Queue did not process items in order');\n  console.log('All tests passed.');\n}, 400);", "golden_completion": "    while (this.queue.length > 0) {\n      const promiseFactory = this.queue.shift();\n      try {\n        const result = await promiseFactory();\n        results.push(result);\n      } catch (error) {\n        console.error('Error processing queue item:', error);\n      }\n    }", "LLM_justification": "This test case challenges the LLM with a custom async pattern implementation using promises and an async queue. It requires understanding of async control flow, proper error handling, and queue management. The pattern is complex and realistic, demonstrating advanced JavaScript features. The low-context nature is maintained by keeping the prefix and suffix concise while ensuring the completion requires genuine understanding of the pattern.", "assertions": "assert.deepStrictEqual(results, [1, 2, 3], 'Queue did not process items in order');", "Ministral-3B": "this.processing = false;"}
{"id": "43", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n  }\n\n  emit(event, ...args) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => listener(...args));\n    }\n  }\n\n  off(event, listenerToRemove) {", "suffix": "  }\n}\n\nconst emitter = new EventEmitter();\nconst listener = (msg) => console.log(msg);\nemitter.on('message', listener);\nemitter.emit('message', 'Hello, World!');\nemitter.off('message', listener);\nemitter.emit('message', 'This should not be logged');\n\nconsole.log('All tests passed');", "golden_completion": "    if (!this.events[event]) return;\n    this.events[event] = this.events[event].filter(listener => listener !== listenerToRemove);", "LLM_justification": "This example tests the LLM's ability to recognize and complete an object-oriented pattern involving an EventEmitter class with methods for adding and removing event listeners. The 'off' method's correct implementation requires understanding advanced JavaScript concepts like array filtering and event handling. The low context provided ensures the LLM must infer the correct pattern from minimal code.", "assertions": "const assert = require('assert');\nconst emitter = new EventEmitter();\nconst listener = (msg) => console.log(msg);\nemitter.on('message', listener);\nemitter.emit('message', 'Hello, World!');\nemitter.off('message', listener);\nassert.strictEqual(emitter.events['message'].length, 0);\nemitter.emit('message', 'This should not be logged');\nassert.ok(true, 'No message should be logged after listener is removed');", "Ministral-3B": "off(event, listenerToRemove) {\n  if (this.events[event]) {\n    this.events[event] = this.events[event].filter(listener => listener !== listenerToRemove);\n  }\n}"}
{"id": "44", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class RateLimiter {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.activeCount = 0;\n  }\n\n  async enqueue(task) {\n    if (this.activeCount < this.limit) {\n      this.activeCount++;\n      task().finally(() => {\n        this.activeCount--;\n        if (this.queue.length > 0) {\n          const nextTask = this.queue.shift();\n          this.enqueue(nextTask);\n        }\n      });\n    } else {\n", "suffix": "      this.queue.push(task);\n    }\n  }\n}\n\nasync function taskFn(taskName) {\n  console.log(`${taskName} started`);\n  return new Promise(resolve => setTimeout(() => {\n    console.log(`${taskName} completed`);\n    resolve();\n  }, 1000));\n}\n\nconst limiter = new RateLimiter(2);\nlimiter.enqueue(() => taskFn('Task 1'));\nlimiter.enqueue(() => taskFn('Task 2'));\nlimiter.enqueue(() => taskFn('Task 3'));\nlimiter.enqueue(() => taskFn('Task 4'));\n\nsetTimeout(() => { limiter.enqueue(() => taskFn('Task 5')); }, 2000);", "golden_completion": "      await task();\n      this.activeCount--;\n      if (this.queue.length > 0) {\n        const nextTask = this.queue.shift();\n        this.enqueue(nextTask);\n      }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete an async pattern involving a custom rate limiter implementation. The prefix sets up a class with methods for handling task queuing and concurrency control, while the suffix contains usage examples that test the rate limiter. The pattern involves managing task execution limits and enqueuing additional tasks as necessary, which requires understanding of async control flow, promises, and task queuing.", "assertions": "const assert = require('assert');\nasync function runTests() {\n  const results = [];\n  const limiter = new RateLimiter(2);\n  const taskNames = ['Task 1', 'Task 2', 'Task 3', 'Task 4', 'Task 5'];\n  for (const name of taskNames) {\n    results.push(limiter.enqueue(() => taskFn(name)));\n  }\n  await Promise.all(results);\n  assert.strictEqual(results.length, 5, 'All tasks should be enqueued and processed');\n  console.log('All assertions passed');\n}\nrunTests().catch(err => console.error('Test failed', err));", "Ministral-3B": "this.queue.push(task);"}
{"id": "45", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class RateLimiter {\n  constructor(maxRequests, interval) {\n    this.maxRequests = maxRequests;\n    this.interval = interval;\n    this.queue = [];\n    this.currentRequests = 0;\n    setInterval(() => {\n      this.currentRequests = 0;\n    }, this.interval);\n  }\n\n  async request(fn) {\n    if (this.currentRequests < this.maxRequests) {", "suffix": "    } else {\n      return new Promise((resolve) => {\n        this.queue.push(() => resolve(this.request(fn)));\n      });\n    }\n  }\n}\n\n// Test the RateLimiter class\nconst limiter = new RateLimiter(2, 1000);\nasync function testLimiter() {\n  let results = [];\n  for (let i = 0; i < 5; i++) {\n    results.push(await limiter.request(() => i));\n  }\n  return results;\n}\n\n(async () => {\n  const results = await testLimiter();\n  console.assert(results.length === 5, 'Should have 5 results');\n  console.assert(results[0] === 0, 'First result should be 0');\n  console.assert(results[1] === 1, 'Second result should be 1');\n  console.assert(results[2] === 2, 'Third result should be 2');\n  console.assert(results[3] === 3, 'Fourth result should be 3');\n  console.assert(results[4] === 4, 'Fifth result should be 4');\n})();", "golden_completion": "      this.currentRequests++;\n      return fn();", "LLM_justification": "This example tests the LLM's ability to recognize and complete an advanced async pattern involving rate limiting with a custom implementation of request queuing. The prefix sets up the RateLimiter class with a request method that manages the number of concurrent requests within a given interval. The suffix demonstrates the use of this class and verifies its behavior with assertions. The golden completion fills in the logic to increment the request count and execute the provided function, which is a crucial part of the rate limiting logic. This requires understanding of async patterns, queue handling, and interval-based logic.", "assertions": "console.assert(results.length === 5, 'Should have 5 results');\nconsole.assert(results[0] === 0, 'First result should be 0');\nconsole.assert(results[1] === 1, 'Second result should be 1');\nconsole.assert(results[2] === 2, 'Third result should be 2');\nconsole.assert(results[3] === 3, 'Fourth result should be 3');\nconsole.assert(results[4] === 4, 'Fifth result should be 4');", "Ministral-3B": "  this.currentRequests++;"}
{"id": "46", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.processing = false;\n  }\n\n  enqueue(promiseFunc) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ promiseFunc, resolve, reject });\n      this.processQueue();\n    });\n  }\n\n  async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n", "suffix": "    this.processing = false;\n  }\n}\n\nconst queue = new AsyncQueue();\n\nasync function testQueue() {\n  const results = await Promise.all([\n    queue.enqueue(() => Promise.resolve(1)),\n    queue.enqueue(() => new Promise(res => setTimeout(() => res(2), 100))),\n    queue.enqueue(() => Promise.resolve(3))\n  ]);\n  return results;\n}\n\n(async () => {\n  const results = await testQueue();\n  console.assert(results[0] === 1, 'First result should be 1');\n  console.assert(results[1] === 2, 'Second result should be 2');\n  console.assert(results[2] === 3, 'Third result should be 3');\n})();", "golden_completion": "    while (this.queue.length > 0) {\n      const { promiseFunc, resolve, reject } = this.queue.shift();\n      try {\n        const result = await promiseFunc();\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete an advanced async pattern involving a custom async queue with proper error handling and control flow. The pattern is recognizable with minimal context but requires understanding of async/await, Promises, and queue processing logic. The completion involves processing a queue of promise-returning functions, ensuring each is executed in sequence, with proper error handling.", "assertions": "const queue = new AsyncQueue();\n\nasync function testQueue() {\n  const results = await Promise.all([\n    queue.enqueue(() => Promise.resolve(1)),\n    queue.enqueue(() => new Promise(res => setTimeout(() => res(2), 100))),\n    queue.enqueue(() => Promise.resolve(3))\n  ]);\n  return results;\n}\n\n(async () => {\n  const results = await testQueue();\n  console.assert(results[0] === 1, 'First result should be 1');\n  console.assert(results[1] === 2, 'Second result should be 2');\n  console.assert(results[2] === 3, 'Third result should be 3');\n})();", "Ministral-3B": "    this.queue.forEach(item => {\n      item.promiseFunc().then(item.resolve, item.reject);\n    });\n  }"}
{"id": "47", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "const timeoutPromise = (ms) => {\n  return new Promise((_, reject) => {\n    setTimeout(() => reject(new Error('Timeout')), ms);\n  });\n};\n\nconst fetchData = async (url) => {\n  const controller = new AbortController();\n  const signal = controller.signal;\n  const fetchPromise = fetch(url, { signal });\n", "suffix": "\n  try {\n    const response = await Promise.race([fetchPromise, timeoutPromise(5000)]);\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Fetch error:', error);\n  }\n};\n\nfetchData('https://api.example.com/data');", "golden_completion": "  setTimeout(() => controller.abort(), 5000);\n", "LLM_justification": "This example demonstrates a complex async pattern involving a custom Promise implementation, async control flow with Promise.race, and the use of AbortController to handle fetch timeouts. It requires understanding of advanced JavaScript features such as Promises, async/await, and the AbortController API. The pattern is non-trivial and would be found in production code handling network requests with timeouts.", "assertions": "const timeoutPromise = (ms) => {\n  return new Promise((_, reject) => {\n    setTimeout(() => reject(new Error('Timeout')), ms);\n  });\n};\n\nconst fetchData = async (url) => {\n  const controller = new AbortController();\n  const signal = controller.signal;\n  const fetchPromise = fetch(url, { signal });\n  setTimeout(() => controller.abort(), 5000);\n  try {\n    const response = await Promise.race([fetchPromise, timeoutPromise(5000)]);\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Fetch error:', error);\n  }\n};\n\nfetchData('https://api.example.com/data');\n", "Ministral-3B": "  if (response.ok) {\n    const data = await response.json();\n    console.log(data);\n  } else {\n    console.error('Fetch error:', response.statusText);\n  }"}
{"id": "48", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class RateLimiter {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.activeCount = 0;\n  }\n\n  _next() {\n    if (this.queue.length > 0 && this.activeCount < this.limit) {\n      const { fn, resolve, reject } = this.queue.shift();\n      this.activeCount++;\n      fn().then(resolve, reject).finally(() => {\n        this.activeCount--;\n        this._next();\n      });\n    }\n  }\n\n  limit(fn) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ fn, resolve, reject });\n      this._next();\n    });\n  }\n}\n\nconst limiter = new RateLimiter(2);\n", "suffix": "limiter.limit(() => Promise.resolve('Task 1')).then(console.log);\nlimiter.limit(() => Promise.resolve('Task 2')).then(console.log);\nlimiter.limit(() => Promise.resolve('Task 3')).then(console.log);\nlimiter.limit(() => Promise.resolve('Task 4')).then(console.log);", "golden_completion": "limiter.limit(() => new Promise((resolve) => setTimeout(() => resolve('Task 5'), 1000))).then(console.log);", "LLM_justification": "This example tests the model's ability to recognize and complete an advanced async pattern using a custom rate limiter that controls concurrency with Promises. The minimal context provided should challenge the model to understand the pattern and insert a valid task without exceeding the concurrency limit. The use of asynchronous control flow and promise handling demonstrates a realistic and production-quality scenario.", "assertions": "const assert = require('assert');\nconst outputs = [];\nconst originalLog = console.log;\nconsole.log = (msg) => outputs.push(msg);\n\nlimiter.limit(() => Promise.resolve('Task 1')).then(console.log);\nlimiter.limit(() => Promise.resolve('Task 2')).then(console.log);\nlimiter.limit(() => Promise.resolve('Task 3')).then(console.log);\nlimiter.limit(() => Promise.resolve('Task 4')).then(console.log);\nlimiter.limit(() => new Promise((resolve) => setTimeout(() => resolve('Task 5'), 1000))).then(console.log);\n\nsetTimeout(() => {\n  assert.strictEqual(outputs.length, 5);\n  assert.strictEqual(outputs[0], 'Task 1');\n  assert.strictEqual(outputs[1], 'Task 2');\n  assert.strictEqual(outputs[2], 'Task 3');\n  assert.strictEqual(outputs[3], 'Task 4');\n  assert.strictEqual(outputs[4], 'Task 5');\n  console.log = originalLog;\n}, 2000);", "Ministral-3B": "limiter.limit(() => Promise.resolve('Task 1')).then(console.log);"}
{"id": "49", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "class AsyncQueue {\n  constructor() {\n    this.queue = [];\n    this.processing = false;\n  }\n\n  enqueue(promiseGenerator) {\n    this.queue.push(promiseGenerator);\n    this.processQueue();\n  }\n\n  async processQueue() {\n    if (this.processing) return;\n    this.processing = true;\n    while (this.queue.length > 0) {\n      const promiseGenerator = this.queue.shift();\n      try {", "suffix": "      } catch (err) {\n        console.error('Error processing queue item:', err);\n      }\n    }\n    this.processing = false;\n  }\n}\n\nconst queue = new AsyncQueue();\nlet result = [];\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve('first'), 1000)));\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve('second'), 500)));\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve('third'), 1500)));\nsetTimeout(() => {\n  console.log(result);\n  // Expect ['first', 'second', 'third']\n}, 3000);", "golden_completion": "        const result = await promiseGenerator();\n        console.log('Processed:', result);", "LLM_justification": "This test case evaluates the model's understanding of async patterns specifically within custom async queue implementations. The model needs to recognize that the promise returned by `promiseGenerator` should be awaited and handled appropriately. This requires understanding of async functions, the `await` keyword, and proper error handling, which are advanced JavaScript patterns. The minimal context provided ensures that the model must infer the correct pattern without extensive surrounding code.", "assertions": "const assert = require('assert');\nconst queue = new AsyncQueue();\nlet results = [];\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve('first'), 1000)).then(res => results.push(res)));\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve('second'), 500)).then(res => results.push(res)));\nqueue.enqueue(() => new Promise(resolve => setTimeout(() => resolve('third'), 1500)).then(res => results.push(res)));\nsetTimeout(() => {\n  assert.deepStrictEqual(results, ['first', 'second', 'third']);\n  console.log('All assertions passed.');\n}, 3000);", "Ministral-3B": "    await promiseGenerator();\n    result.push(await promiseGenerator());"}
{"id": "50", "testsource": "synthbench-low-context", "language": "javascript", "prefix": "function asyncTimeout(ms) { return new Promise((resolve, reject) => { const id = setTimeout(() => { resolve(); }, ms); }); }\n\nasync function fetchData(url) {", "suffix": "  return response.json();\n}\n\n(async () => {\n  try {\n    const data = await fetchData('https://api.example.com/data');\n    console.log(data);\n  } catch (err) {\n    console.error(err);\n  }\n})();", "golden_completion": "  const response = await fetch(url, { signal: new AbortController().signal });", "LLM_justification": "This example tests the model's ability to recognize an async pattern with a timeout using Promises and the Fetch API with AbortController. The pattern is complex and involves understanding both async/await and how to handle fetch with a signal. The prefix sets up the async function and the suffix shows an example usage, leaving the middle part where the fetch call is made to be completed.", "assertions": "const fetch = require('node-fetch');\nconst assert = require('assert');\n\n(async () => {\n  try {\n    const data = await fetchData('https://jsonplaceholder.typicode.com/todos/1');\n    assert(data.userId === 1);\n    assert(data.id === 1);\n    assert(data.title);\n  } catch (err) {\n    console.error(err);\n  }\n})();", "Ministral-3B": "const response = await fetch(url);"}
