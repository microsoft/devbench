
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * Validates if the provided user data complies with business rules.
 * The function checks if the user is over a certain age and has accepted the terms and conditions.
 * 
 * @param {Object} user - The user data object.
 * @param {number} user.age - The age of the user.
 * @param {boolean} user.acceptedTerms - Whether the user has accepted the terms and conditions.
 * @returns {boolean} Returns true if the user data is valid, otherwise false.
 * @throws {Error} If the user data is missing required properties or if the validation fails.
 */
function validateUserData(user) {


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
  if (typeof user.age !== 'number' || typeof user.acceptedTerms !== 'boolean') {
    throw new Error('User data is missing required properties.');
  }
  if (user.age <= 18 || !user.acceptedTerms) {
    return false;
  }

SUFFIX CODE:
----------------------------------------
  return true;
}

try {
  // Valid user data
  assert.strictEqual(validateUserData({ age: 25, acceptedTerms: true }), true);
  // Invalid user data: underage
  assert.strictEqual(validateUserData({ age: 15, acceptedTerms: true }), false);
  // Invalid user data: terms not accepted
  assert.strictEqual(validateUserData({ age: 25, acceptedTerms: false }), false);
  // Invalid user data: missing properties
  assert.throws(() => validateUserData({ age: 25 }), Error);
  assert.throws(() => validateUserData({ acceptedTerms: true }), Error);
} catch (error) {
  console.error('Validation failed:', error);
}


JUSTIFICATION:
----------------------------------------
This example is a good test case because it demonstrates a realistic business logic scenario where user data validation is critical. It includes detailed JSDoc comments explaining the function's purpose, parameters, return value, and error handling. The golden completion fills in the core validation logic, ensuring that the provided user data meets specific criteria. The suffix contains comprehensive test cases that verify the function's correctness, including edge cases and error scenarios. This setup effectively tests the LLM's ability to translate between code and documentation in both directions, ensuring alignment and completeness.

ASSERTIONS:
----------------------------------------
assert.strictEqual(typeof validateUserData, 'function');
const docString = validateUserData.toString();
assert(docString.includes('Validates if the provided user data complies with business rules'));
assert(docString.includes('@param {Object} user'));
assert(docString.includes('@param {number} user.age'));
assert(docString.includes('@param {boolean} user.acceptedTerms'));
assert(docString.includes('@returns {boolean}'));
assert(docString.includes('@throws {Error}'));
assert.strictEqual(validateUserData({ age: 25, acceptedTerms: true }), true);
assert.strictEqual(validateUserData({ age: 15, acceptedTerms: true }), false);
assert.strictEqual(validateUserData({ age: 25, acceptedTerms: false }), false);
assert.throws(() => validateUserData({ age: 25 }), Error);
assert.throws(() => validateUserData({ acceptedTerms: true }), Error);
================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * Class representing a portfolio for financial analysis.
 */
class Portfolio {
    constructor() {
        this.assets = [];
    }

    /**
     * Add an asset to the portfolio.
     * @param {string} name - The name of the asset.
     * @param {number} value - The value of the asset.
     */
    addAsset(name, value) {
        this.assets.push({ name, value });
    }

    /**
     * Calculate the total value of the portfolio.
     * @returns {number} The total value of all assets.
     */
    calculateTotalValue() {
        return this.assets.reduce((acc, asset) => acc + asset.value, 0);
    }

    // TODO: Implement risk assessment logic


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
    assessRisk() {
        const totalValue = this.calculateTotalValue();
        if (totalValue > 10000) {
            return 'High Risk';
        } else if (totalValue > 5000) {
            return 'Medium Risk';
        } else {
            return 'Low Risk';
        }
    }

SUFFIX CODE:
----------------------------------------

}

// Example usage
const portfolio = new Portfolio();
portfolio.addAsset('Stock A', 1500);
portfolio.addAsset('Bond B', 500);
assert(portfolio.calculateTotalValue() === 2000);

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case demonstrates the ability to generate comprehensive documentation for a method implementation (code-to-comment) and to implement a method based on detailed documentation (comment-to-code). The prefix provides context with existing class methods, the suffix contains example usage, and the golden_completion fills in the missing method and its documentation. Assertions validate the correctness of the implementation, ensuring the total value is calculated correctly.

ASSERTIONS:
----------------------------------------
const portfolio = new Portfolio();
portfolio.addAsset('Stock A', 1500);
portfolio.addAsset('Bond B', 500);
portfolio.addAsset('Real Estate C', 8000);
assert(portfolio.assessRisk() === 'Medium');
portfolio.addAsset('Private Equity D', 3000);
assert(portfolio.assessRisk() === 'High');
portfolio.assets = [];
portfolio.addAsset('Bond E', 2000);
assert(portfolio.assessRisk() === 'Low');
console.log('Risk assessment assertions passed.');
================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * Class representing a simple financial portfolio.
 */
class Portfolio {
    /**
     * Create a portfolio.
     * @param {Array} investments - An array of investment objects.
     */
    constructor(investments) {
        this.investments = investments;
    }

    /**
     * Calculate the total value of the portfolio.
     * @return {number} The total value of all investments.
     */
    totalValue() {
        let total = 0;
        for (const investment of this.investments) {
            total += investment.value;
        }
        return total;
    }

    /**
     * Calculate the average return rate of the portfolio.
     * @return {number} The average return rate of the investments.
     */
    averageReturnRate() {

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
        let totalReturnRate = 0;
        for (const investment of this.investments) {
            totalReturnRate += investment.returnRate;
        }
        return totalReturnRate / this.investments.length;

SUFFIX CODE:
----------------------------------------

    }

    /**
     * Get the investment with the highest value.
     * @return {Object} The investment object with the highest value.
     */
    highestValueInvestment() {
        return this.investments.reduce((max, investment) => investment.value > max.value ? investment : max, this.investments[0]);
    }
}

// Example usage:
const investments = [
    { name: 'Stock A', value: 1000, returnRate: 0.05 },
    { name: 'Stock B', value: 1500, returnRate: 0.07 },
    { name: 'Bond A', value: 500, returnRate: 0.03 }
];
const portfolio = new Portfolio(investments);

// Assertions:
assert.strictEqual(portfolio.totalValue(), 3000);
assert.strictEqual(portfolio.highestValueInvestment().name, 'Stock B');
assert.strictEqual(portfolio.averageReturnRate(), 0.05);

JUSTIFICATION:
----------------------------------------
This test case is a good example because it demonstrates a realistic business scenario of a financial portfolio with methods to calculate total value, average return rate, and find the highest value investment. It includes class and method documentation, ensuring coverage of JSDoc conventions. The provided suffix includes additional methods and assertions that validate the correct functionality of the code. This scenario tests both code-to-comment and comment-to-code translations, ensuring comprehensive understanding and correct translation by the LLM.

ASSERTIONS:
----------------------------------------
const investments = [
    { name: 'Stock A', value: 1000, returnRate: 0.05 },
    { name: 'Stock B', value: 1500, returnRate: 0.07 },
    { name: 'Bond A', value: 500, returnRate: 0.03 }
];
const portfolio = new Portfolio(investments);

// Validate total value calculation
assert.strictEqual(portfolio.totalValue(), 3000);

// Validate highest value investment
assert.strictEqual(portfolio.highestValueInvestment().name, 'Stock B');

// Validate average return rate calculation
assert.strictEqual(portfolio.averageReturnRate(), 0.05);
================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * Represents a financial portfolio containing various assets.
 */
class Portfolio {
  /**
   * Creates a new portfolio.
   * @param {string} owner - The name of the portfolio owner.
   */
  constructor(owner) {
    this.owner = owner;
    this.assets = [];
  }

  /**
   * Adds an asset to the portfolio.
   * @param {string} name - The name of the asset.
   * @param {number} value - The value of the asset.
   */
  addAsset(name, value) {
    this.assets.push({ name, value });
  }

  /**
   * Calculates the total value of the portfolio.
   * @returns {number} The total value of all assets in the portfolio.
   */
  calculateTotalValue() {
    return this.assets.reduce((total, asset) => total + asset.value, 0);
  }
}

// Example usage
const myPortfolio = new Portfolio('John Doe');
myPortfolio.addAsset('Stock A', 10000);
myPortfolio.addAsset('Bond B', 5000);

// Calculate and assert the total value
assert.strictEqual(myPortfolio.calculateTotalValue(), 15000);

/**
 * Validates if the portfolio meets a certain minimum value requirement.
 * @param {Portfolio} portfolio - The portfolio to validate.
 * @param {number} minValue - The minimum value requirement.
 * @returns {boolean} True if the portfolio meets the requirement, false otherwise.
 */
function validatePortfolioValue(portfolio, minValue) {

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
  return portfolio.calculateTotalValue() >= minValue;

SUFFIX CODE:
----------------------------------------

}

// Example usage
const isValid = validatePortfolioValue(myPortfolio, 12000);
assert.strictEqual(isValid, true);

const isInvalid = validatePortfolioValue(myPortfolio, 20000);
assert.strictEqual(isInvalid, false);

// Cleanup (if any resources to clean, not applicable here)


JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic business logic scenario involving a financial portfolio, complete with asset management and value calculation. The code-to-comment task provides comprehensive JSDoc comments that describe the class, methods, and parameters. The comment-to-code task involves implementing a validation function based on provided documentation. The assertions verify functional requirements, including edge cases, ensuring the translation between code and comments is accurate and complete.

ASSERTIONS:
----------------------------------------
assert.strictEqual(validatePortfolioValue(myPortfolio, 12000), true);
assert.strictEqual(validatePortfolioValue(myPortfolio, 20000), false);
assert.strictEqual(validatePortfolioValue(myPortfolio, 15000), true);
assert.strictEqual(validatePortfolioValue(myPortfolio, 14999), false);

================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { strict: assert } = require('assert');

/**
 * Calculate the portfolio value based on the current prices of the assets.
 * This function iterates through the portfolio and multiplies the quantity
 * of each asset by its current price, summing up the total value.
 *
 * @param {Array<Object>} portfolio - Array of asset objects containing 'name', 'quantity', and 'price'.
 * @returns {number} - The total value of the portfolio.
 */
function calculatePortfolioValue(portfolio) {
    let totalValue = 0;
    for (const asset of portfolio) {
        totalValue += asset.quantity * asset.price;
    }
    return totalValue;
}

// Example usage
const portfolio = [
    { name: 'Stock A', quantity: 100, price: 50 },
    { name: 'Stock B', quantity: 200, price: 75 },
    { name: 'Stock C', quantity: 150, price: 30 }
];
const totalValue = calculatePortfolioValue(portfolio);

/**
 * Assess the risk of the portfolio based on the distribution of assets.
 * This function calculates the percentage of each asset in the portfolio
 * and determines if any asset exceeds a specified risk threshold.
 *
 * @param {Array<Object>} portfolio - Array of asset objects containing 'name', 'quantity', and 'price'.
 * @param {number} threshold - The risk threshold percentage.
 * @returns {Array<string>} - List of asset names that exceed the risk threshold.
 */

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function assessPortfolioRisk(portfolio, threshold) {
    const totalValue = calculatePortfolioValue(portfolio);
    const highRiskAssets = [];

    for (const asset of portfolio) {
        const assetValue = asset.quantity * asset.price;
        const assetPercentage = (assetValue / totalValue) * 100;
        if (assetPercentage > threshold) {
            highRiskAssets.push(asset.name);
        }
    }

    return highRiskAssets;
}

SUFFIX CODE:
----------------------------------------
const highRiskAssets = assessPortfolioRisk(portfolio, 50);

assert(Array.isArray(highRiskAssets));
assert(highRiskAssets.length === 1);
assert(highRiskAssets[0] === 'Stock B');

console.log('All tests passed.');

JUSTIFICATION:
----------------------------------------
This example tests the ability of an LLM to translate between code and comments in both directions. The prefix includes extensive code and comments for a function that calculates portfolio value. The golden completion requires generating a function that assesses portfolio risk based on detailed comments. The suffix includes assertions that verify the implementation, ensuring functional correctness and proper error handling.

ASSERTIONS:
----------------------------------------
const portfolio = [
    { name: 'Stock A', quantity: 100, price: 50 },
    { name: 'Stock B', quantity: 200, price: 75 },
    { name: 'Stock C', quantity: 150, price: 30 }
];
const highRiskAssets = assessPortfolioRisk(portfolio, 50);

assert(Array.isArray(highRiskAssets));
assert(highRiskAssets.length === 1);
assert(highRiskAssets[0] === 'Stock B');

console.log('All tests passed.');
================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * Represents a financial portfolio with various assets.
 */
class Portfolio {
    constructor() {
        this.assets = [];
    }

    /**
     * Adds an asset to the portfolio.
     * @param {string} name - The name of the asset.
     * @param {number} value - The value of the asset.
     */
    addAsset(name, value) {
        this.assets.push({ name, value });
    }

    /**
     * Calculates the total value of the portfolio.
     * @returns {number} - The total value of all assets.
     */
    calculateTotalValue() {
        let totalValue = 0;
        for (const asset of this.assets) {
            totalValue += asset.value;
        }
        return totalValue;
    }

    /**
     * Calculates the risk of the portfolio based on asset values.
     * The risk is defined as the standard deviation of the asset values.
     * @returns {number} - The calculated risk of the portfolio.
     */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
calculateRisk() {
    const totalValue = this.calculateTotalValue();
    const mean = totalValue / this.assets.length;
    let variance = 0;
    for (const asset of this.assets) {
        variance += Math.pow(asset.value - mean, 2);
    }
    variance /= this.assets.length;
    return Math.sqrt(variance);
}

SUFFIX CODE:
----------------------------------------

}

const portfolio = new Portfolio();
portfolio.addAsset('Stock A', 100);
portfolio.addAsset('Stock B', 200);
portfolio.addAsset('Stock C', 300);

assert.strictEqual(portfolio.calculateTotalValue(), 600);

const risk = portfolio.calculateRisk();
assert(risk > 0);

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case is a good example for evaluating the translation capabilities between code and natural language for several reasons. First, it covers a realistic business scenario of financial portfolio management, including the calculation of total value and risk assessment. Second, it includes detailed JSDoc comments that explain the purpose and usage of each method, which tests the model's ability to generate and understand documentation. Third, the golden completion requires the implementation of a complex algorithm (standard deviation) based on the provided documentation, testing the model's ability to translate natural language requirements into correct and efficient code. Finally, the assertions ensure that the implemented code performs as expected, covering both normal and edge cases.

ASSERTIONS:
----------------------------------------
const Portfolio = require('./Portfolio');

const portfolio = new Portfolio();
portfolio.addAsset('Stock A', 100);
portfolio.addAsset('Stock B', 200);
portfolio.addAsset('Stock C', 300);

assert.strictEqual(portfolio.calculateTotalValue(), 600);

const risk = portfolio.calculateRisk();
assert(risk > 0);

console.log('All assertions passed.');
================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Loads a JSON configuration file and returns the parsed object.
 * @param {string} configPath - The file path to the configuration JSON file.
 * @returns {Object} The parsed configuration object.
 * @throws Will throw an error if the file cannot be read or parsed.
 */
function loadConfig(configPath) {
    if (typeof configPath !== 'string') {
        throw new TypeError('The configPath should be a string');
    }
    const absolutePath = path.resolve(configPath);
    let rawData;
    try {
        rawData = fs.readFileSync(absolutePath, 'utf8');
    } catch (err) {
        throw new Error('Failed to read configuration file: ' + err.message);
    }
    let config;
    try {
        config = JSON.parse(rawData);
    } catch (err) {
        throw new Error('Failed to parse configuration file: ' + err.message);
    }
    return config;
}

/**
 * Validates the configuration object to ensure all required properties are present.
 * @param {Object} config - The configuration object to validate.
 * @throws Will throw an error if any required property is missing.
 */
function validateConfig(config) {
    if (typeof config !== 'object' || config === null) {
        throw new TypeError('The config should be a non-null object');
    }
    const requiredProps = ['host', 'port', 'database'];
    requiredProps.forEach(prop => {
        if (!config.hasOwnProperty(prop)) {
            throw new Error(`Missing required config property: ${prop}`);
        }
    });
}

const exampleConfigPath = './config.json';
let config;
try {
    config = loadConfig(exampleConfigPath);
    validateConfig(config);
} catch (error) {
    console.error('Configuration error:', error.message);
}

// Further processing with the validated config


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
if (config) {
    console.log('Configuration loaded and validated successfully.');
} else {
    throw new Error('Configuration is invalid or missing.');
}

SUFFIX CODE:
----------------------------------------
function connectToDatabase(config) {
    if (!config) {
        throw new Error('Config is required to connect to the database');
    }
    // Mocked database connection function
    console.log(`Connecting to database at ${config.host}:${config.port}`);
    // Simulate successful connection
    return true;
}

try {
    const connectionSuccess = connectToDatabase(config);
    console.log('Connection successful:', connectionSuccess);
} catch (error) {
    console.error('Database connection error:', error.message);
}


JUSTIFICATION:
----------------------------------------
This test case provides a realistic scenario involving configuration loading, validation, and database connection logic. The prefix includes detailed setup code with helper functions and error handling, providing a comprehensive context. The golden completion requires generating accurate documentation for a function that connects to a database using a configuration object. The suffix continues with the actual database connection logic. This example effectively tests the LLM's ability to translate between code and documentation, ensuring functional requirements and error handling are met.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Extracted documentation for the connectToDatabase function
const docString = `/**
 * Connects to the database using the provided configuration.
 * @param {Object} config - The configuration object containing database connection details.
 * @param {string} config.host - The database host.
 * @param {number} config.port - The database port.
 * @param {string} config.database - The database name.
 * @returns {boolean} Returns true if the connection is successful.
 * @throws Will throw an error if the connection fails.
 */`;

// Assertions to verify the documentation accuracy
assert(docString.includes('Connects to the database using the provided configuration'));
assert(docString.includes('@param {Object} config - The configuration object containing database connection details'));
assert(docString.includes('@param {string} config.host - The database host'));
assert(docString.includes('@param {number} config.port - The database port'));
assert(docString.includes('@param {string} config.database - The database name'));
assert(docString.includes('@returns {boolean} Returns true if the connection is successful'));
assert(docString.includes('@throws Will throw an error if the connection fails'));
================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Reads and parses a JSON file from the given path.
 * @param {string} filePath - The path to the JSON file.
 * @returns {Object} The parsed JSON object.
 * @throws Will throw an error if the file cannot be read or parsed.
 */
function readJsonFile(filePath) {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data);
    } catch (err) {
        throw new Error(`Failed to read or parse file: ${err.message}`);
    }
}

/**
 * Writes a JSON object to a file at the given path.
 * @param {string} filePath - The path to the file where JSON will be written.
 * @param {Object} jsonObject - The JSON object to write.
 * @throws Will throw an error if the file cannot be written.
 */
function writeJsonFile(filePath, jsonObject) {
    try {
        const data = JSON.stringify(jsonObject, null, 2);
        fs.writeFileSync(filePath, data, 'utf8');
    } catch (err) {
        throw new Error(`Failed to write file: ${err.message}`);
    }
}

/**
 * Merges two JSON objects.
 * @param {Object} json1 - The first JSON object.
 * @param {Object} json2 - The second JSON object.
 * @returns {Object} The merged JSON object.
 */
function mergeJsonObjects(json1, json2) {
    return { ...json1, ...json2 };
}

// Helper function to check if a file exists
function fileExists(filePath) {
    try {
        return fs.existsSync(filePath);
    } catch (err) {
        return false;
    }
}

// Example usage
const jsonFilePath1 = path.join(__dirname, 'data1.json');
const jsonFilePath2 = path.join(__dirname, 'data2.json');
const outputFilePath = path.join(__dirname, 'mergedData.json');

if (fileExists(jsonFilePath1) && fileExists(jsonFilePath2)) {
    const json1 = readJsonFile(jsonFilePath1);
    const json2 = readJsonFile(jsonFilePath2);
    const mergedJson = mergeJsonObjects(json1, json2);
    writeJsonFile(outputFilePath, mergedJson);
    console.log('Merged JSON data written to', outputFilePath);
} else {
    console.error('One or both input JSON files do not exist.');
}


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
console.log('Process completed.');

SUFFIX CODE:
----------------------------------------
console.log('Process completed.');


JUSTIFICATION:
----------------------------------------
This example is a good test case because it includes complex business logic involving file operations and JSON manipulation, which are common in real-world applications. It tests both code-to-comment and comment-to-code translation capabilities. The documentation includes parameter descriptions, error handling, and usage examples, ensuring comprehensive coverage. Additionally, the assertions verify documentation accuracy and code correctness.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Verify the function documentation
const docString = `/**
 * Combines the content of two JSON files and writes the result to a new file.
 * @param {string} inputFilePath1 - The path to the first JSON file.
 * @param {string} inputFilePath2 - The path to the second JSON file.
 * @param {string} outputFilePath - The path to the output JSON file.
 * @throws Will throw an error if any of the files cannot be read or written.
 */`;
assert(docString.includes('Combines the content of two JSON files'));
assert(docString.includes('@param {string} inputFilePath1'));
assert(docString.includes('@param {string} inputFilePath2'));
assert(docString.includes('@param {string} outputFilePath'));
assert(docString.includes('@throws'));

// Verify the function implementation
const testOutputPath = path.join(__dirname, 'testMergedData.json');
fs.writeFileSync(jsonFilePath1, JSON.stringify({ key1: 'value1' }));
fs.writeFileSync(jsonFilePath2, JSON.stringify({ key2: 'value2' }));
combineJsonFiles(jsonFilePath1, jsonFilePath2, testOutputPath);
const result = readJsonFile(testOutputPath);
assert(result.key1 === 'value1');
assert(result.key2 === 'value2');

// Cleanup
fs.unlinkSync(jsonFilePath1);
fs.unlinkSync(jsonFilePath2);
fs.unlinkSync(testOutputPath);

================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * A function to calculate the risk of a financial portfolio based on the value at risk (VaR) method.
 * @param {number} portfolioValue - The total value of the financial portfolio.
 * @param {number} confidenceLevel - The confidence level for VaR calculation (e.g., 0.95 for 95%).
 * @param {number} standardDeviation - The standard deviation of the portfolio returns.
 * @returns {number} - The calculated VaR value.
 */
function calculateVaR(portfolioValue, confidenceLevel, standardDeviation) {
	// Calculate the z-score for the given confidence level
	const zScore = (confidenceLevel - 0.5) * Math.sqrt(2) * Math.erf(1);
	// Calculate the VaR
	const varValue = portfolioValue * zScore * standardDeviation;
	return varValue;
}

/**
 * A function to perform a simple data transformation.
 * It normalizes the values in the given array to a 0-1 range.
 * @param {number[]} data - The array of numbers to be normalized.
 * @returns {number[]} - The normalized array of numbers.
 */
function normalizeData(data) {
	const max = Math.max(...data);
	const min = Math.min(...data);
	return data.map(value => (value - min) / (max - min));
}

/**
 * A function to validate business rules for a loan application.
 * Checks if the applicant's age and income meet the required criteria.
 * @param {number} age - The age of the applicant.
 * @param {number} income - The annual income of the applicant.
 * @returns {boolean} - Returns true if the applicant meets the criteria, otherwise false.
 */
function validateLoanApplication(age, income) {
	const minAge = 18;
	const minIncome = 30000;
	if (age >= minAge && income >= minIncome) {
		return true;
	}
	return false;
}

/**
 * A function to orchestrate a workflow for processing tasks in a queue.
 * Processes each task and logs the result.
 * @param {Array} tasks - The array of tasks to be processed.
 */
function processTasks(tasks) {
	for (const task of tasks) {
		try {
			const result = task();
			console.log(`Task completed successfully: ${result}`);
		} catch (error) {
			console.error(`Task failed: ${error.message}`);
		}
	}
}

/**
 * A function to model a business entity representing a customer.
 * @param {string} name - The name of the customer.
 * @param {number} age - The age of the customer.
 * @param {string} address - The address of the customer.
 * @returns {object} - The customer object.
 */
function createCustomer(name, age, address) {
	return { name, age, address };
}

/**
 * A function to manage API integration with rate limiting.
 * Ensures that API calls do not exceed the rate limit.
 * @param {function} apiCall - The API call function.
 * @param {number} limit - The maximum number of API calls allowed per minute.
 * @returns {Promise<void>} - A promise that resolves when the rate limit is respected.
 */
async function manageApiRateLimit(apiCall, limit) {
	let calls = 0;
	const interval = 60000 / limit;
	const makeCall = async () => {
		if (calls < limit) {
			calls++;
			await apiCall();
		}
		setTimeout(() => { calls--; }, interval);
	};
	await makeCall();
}

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
// No additional code needed here

SUFFIX CODE:
----------------------------------------


// Example usage of the manageApiRateLimit function
const exampleApiCall = async () => {
	console.log('API call made');
};
manageApiRateLimit(exampleApiCall, 5).then(() => {
	console.log('Rate limit respected');
});

// Assertions to verify the correctness of the code
const customer = createCustomer('John Doe', 30, '123 Main St');
assert(customer.name === 'John Doe');
assert(customer.age === 30);
assert(customer.address === '123 Main St');

const normalizedData = normalizeData([1, 2, 3, 4, 5]);
assert(normalizedData[0] === 0);
assert(normalizedData[4] === 1);

const isLoanValid = validateLoanApplication(25, 40000);
assert(isLoanValid === true);

const varValue = calculateVaR(100000, 0.95, 0.1);
assert(varValue > 0);

const tasks = [
	() => 'Task 1',
	() => { throw new Error('Task 2 failed'); },
	() => 'Task 3'
];
processTasks(tasks);

// Cleanup code if needed


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to translate between code and documentation effectively. The prefix includes complex implementations of business logic and technical features, while the golden completion requires generating comprehensive documentation for a new function. The suffix ensures a clear distinction from the golden completion, with assertions to verify the correctness of the code. This example demonstrates realistic scenarios and tests the bidirectional translation capabilities of the LLM.

ASSERTIONS:
----------------------------------------
const cache = { data: 'old data' };
const isValid = (cache) => cache.data === 'new data';
const refreshCache = () => ({ data: 'new data' });
manageCache(cache, isValid, refreshCache);
assert(cache.data === 'new data');
================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');

/**
 * A class representing a financial portfolio.
 */
class Portfolio {
    /**
     * Create a portfolio.
     * @param {Array} assets - The assets in the portfolio.
     */
    constructor(assets) {
        this.assets = assets;
    }

    /**
     * Calculate the total value of the portfolio.
     * @param {Object} prices - The current prices of the assets.
     * @returns {number} The total value of the portfolio.
     */
    calculateTotalValue(prices) {
        return this.assets.reduce((total, asset) => {
            return total + (prices[asset.ticker] * asset.quantity);
        }, 0);
    }

    /**
     * Fetch the current prices of the assets from an external API.
     * @returns {Promise<Object>} A promise that resolves to an object with the current prices.
     */
    async fetchCurrentPrices() {
        try {
            const response = await axios.get('https://api.example.com/prices');
            return response.data;
        } catch (error) {
            console.error('Error fetching prices:', error);
            throw new Error('Failed to fetch current prices.');
        }
    }
}

// Example usage:
const myPortfolio = new Portfolio([
    { ticker: 'AAPL', quantity: 10 },
    { ticker: 'GOOG', quantity: 5 }
]);

(async () => {
    const prices = await myPortfolio.fetchCurrentPrices();
    const totalValue = myPortfolio.calculateTotalValue(prices);
    console.log('Total Portfolio Value:', totalValue);
})();

/**
 * A function to validate if the portfolio assets comply with a set of business rules.
 * Business rules:
 * - The portfolio must contain at least two different assets.
 * - No asset can exceed 50% of the total value of the portfolio.
 * @param {Array} assets - The assets in the portfolio.
 * @param {Object} prices - The current prices of the assets.
 * @returns {boolean} True if the portfolio complies with the business rules, false otherwise.
 */
function validatePortfolio(assets, prices) {

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
    if (assets.length < 2) return false;

    const portfolio = new Portfolio(assets);
    const totalValue = portfolio.calculateTotalValue(prices);

    return assets.every(asset => (prices[asset.ticker] * asset.quantity) <= (0.5 * totalValue));

SUFFIX CODE:
----------------------------------------
}

// Mock data for testing
const testAssets = [
    { ticker: 'AAPL', quantity: 10 },
    { ticker: 'GOOG', quantity: 5 }
];
const testPrices = {
    'AAPL': 150,
    'GOOG': 1000
};

// Assertions
const assert = require('assert');
const totalValue = new Portfolio(testAssets).calculateTotalValue(testPrices);
assert.strictEqual(totalValue, 6500, 'Total value calculation is incorrect');

// Ensure the validatePortfolio function works correctly
const isValid = validatePortfolio(testAssets, testPrices);
assert.strictEqual(isValid, true, 'Portfolio validation failed');

console.log('All tests passed.');


JUSTIFICATION:
----------------------------------------
This is a good test case because it includes a realistic financial scenario involving portfolio management and validation against business rules. The code-to-comment translation requires generating detailed and accurate JSDoc comments for existing code, while the comment-to-code translation requires implementing a function based on provided documentation. This scenario tests the LLM's ability to both generate comprehensive documentation and implement functionality from detailed requirements. The assertions verify that the code works correctly and meets the specified business rules.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const testAssets = [
    { ticker: 'AAPL', quantity: 10 },
    { ticker: 'GOOG', quantity: 5 }
];
const testPrices = {
    'AAPL': 150,
    'GOOG': 1000
};
const totalValue = new Portfolio(testAssets).calculateTotalValue(testPrices);
assert.strictEqual(totalValue, 6500, 'Total value calculation is incorrect');

const isValid = validatePortfolio(testAssets, testPrices);
assert.strictEqual(isValid, true, 'Portfolio validation failed');

console.log('All tests passed.');
================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Reads a JSON file from the specified path and parses its content.
 * @param {string} filePath - The path to the JSON file.
 * @returns {Promise<Object>} The parsed JSON content.
 */
async function readJsonFile(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (err, data) => {
      if (err) {
        reject(err);
        return;
      }
      try {
        const jsonData = JSON.parse(data);
        resolve(jsonData);
      } catch (parseErr) {
        reject(parseErr);
      }
    });
  });
}

/**
 * Writes an object to a JSON file at the specified path.
 * @param {string} filePath - The path to the JSON file.
 * @param {Object} data - The data to write to the file.
 * @returns {Promise<void>} A promise that resolves when the file is written.
 */
async function writeJsonFile(filePath, data) {
  return new Promise((resolve, reject) => {
    const jsonData = JSON.stringify(data, null, 2);
    fs.writeFile(filePath, jsonData, 'utf8', (err) => {
      if (err) {
        reject(err);
        return;
      }
      resolve();
    });
  });
}

/**
 * Merges two JSON objects and writes the result to a file.
 * @param {string} inputPath1 - The path to the first input JSON file.
 * @param {string} inputPath2 - The path to the second input JSON file.
 * @param {string} outputPath - The path to the output JSON file.
 * @returns {Promise<void>} A promise that resolves when the merge and write are complete.
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
async function mergeJsonFiles(inputPath1, inputPath2, outputPath) {
  const data1 = await readJsonFile(inputPath1);
  const data2 = await readJsonFile(inputPath2);
  const mergedData = { ...data1, ...data2 };
  await ensureDirectoryExists(outputPath);
  await writeJsonFile(outputPath, mergedData);
}

SUFFIX CODE:
----------------------------------------

// Utility function to ensure the directory exists before writing a file
/**
 * Ensures the directory exists for the given file path.
 * @param {string} filePath - The path to the file.
 * @returns {Promise<void>} A promise that resolves when the directory is ensured.
 */
async function ensureDirectoryExists(filePath) {
  return new Promise((resolve, reject) => {
    const dir = path.dirname(filePath);
    fs.mkdir(dir, { recursive: true }, (err) => {
      if (err) {
        reject(err);
        return;
      }
      resolve();
    });
  });
}

// Example usage:
// ensureDirectoryExists('path/to/output.json')


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the ability of a language model to translate JavaScript code into comprehensive documentation and vice versa. The provided prefix includes detailed implementation of functions to read, write, and merge JSON files, which are common tasks in data transformation and ETL processes. The golden_completion provides complete JSDoc comments for the `mergeJsonFiles` function, ensuring that the documentation includes parameter descriptions, return value, and error handling details. The suffix introduces additional utility code without duplicating the golden_completion. This scenario demonstrates realistic business logic and technical requirements, making it a robust test for bidirectional translation.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

(async () => {
  const testInputPath1 = 'testInput1.json';
  const testInputPath2 = 'testInput2.json';
  const testOutputPath = 'testOutput.json';
  const data1 = { key1: 'value1' };
  const data2 = { key2: 'value2' };

  await writeJsonFile(testInputPath1, data1);
  await writeJsonFile(testInputPath2, data2);

  await mergeJsonFiles(testInputPath1, testInputPath2, testOutputPath);

  const mergedData = await readJsonFile(testOutputPath);
  assert.deepStrictEqual(mergedData, { key1: 'value1', key2: 'value2' }, 'Merged data should contain keys and values from both input files');

  fs.unlinkSync(testInputPath1);
  fs.unlinkSync(testInputPath2);
  fs.unlinkSync(testOutputPath);
})();
================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');

/**
 * A utility function to transform user data.
 * @param {Array} users - The array of user objects to transform.
 * @returns {Array} Transformed user data.
 */
function transformUserData(users) {
    return users.map(user => {
        return {
            fullName: `${user.firstName} ${user.lastName}`,
            email: user.email.toLowerCase(),
            isActive: user.status === 'active'
        };
    });
}

/**
 * Fetches user data from an external API and transforms it.
 * @param {string} apiUrl - The URL of the API to fetch user data from.
 * @returns {Promise<Array>} A promise that resolves to an array of transformed user data.
 */
async function fetchAndTransformUserData(apiUrl) {
    try {
        const response = await axios.get(apiUrl);
        const users = response.data;
        return transformUserData(users);
    } catch (error) {
        console.error('Error fetching user data:', error);
        throw new Error('Failed to fetch user data');
    }
}

/**
 * Example usage of fetchAndTransformUserData function.
 */
(async () => {
    const apiUrl = 'https://api.example.com/users';
    try {
        const transformedData = await fetchAndTransformUserData(apiUrl);
        console.log('Transformed User Data:', transformedData);
    } catch (error) {
        console.error('Error:', error);
    }
})();



LLM COMPLETION gpt-4.5-preview:
----------------------------------------
module.exports = {
    transformUserData,
    fetchAndTransformUserData
};

SUFFIX CODE:
----------------------------------------

(async () => {
    const apiUrl = 'https://api.example.com/new-users';
    try {
        const newTransformedData = await fetchAndTransformUserData(apiUrl);
        console.log('New Transformed User Data:', newTransformedData);
    } catch (error) {
        console.error('Error:', error);
    }
})();


JUSTIFICATION:
----------------------------------------
This scenario tests the translation of detailed documentation for a function that fetches and transforms user data. The prefix provides a comprehensive implementation, while the golden completion requires filling in detailed JSDoc comments. The suffix continues the usage with different input to ensure completeness and correctness of the translation.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const docString = `/**
 * Fetches user data from an external API and transforms it.
 * @param {string} apiUrl - The URL of the API to fetch user data from.
 * @returns {Promise<Array>} A promise that resolves to an array of transformed user data.
 * @throws Will throw an error if the API request fails.
 */`;
assert(docString.toLowerCase().includes('fetches user data from an external api'));
assert(docString.includes('@param {string} apiUrl'));
assert(docString.includes('@returns {Promise<Array>}'));
assert(docString.includes('@throws'));
assert(docString.includes('if the API request fails'));
assert(docString.includes('transforms it'));
(async () => {
    const apiUrl = 'https://api.example.com/users';
    try {
        const transformedData = await fetchAndTransformUserData(apiUrl);
        assert(Array.isArray(transformedData));
        assert(transformedData.length > 0);
        assert(transformedData[0].hasOwnProperty('fullName'));
        assert(transformedData[0].hasOwnProperty('email'));
        assert(transformedData[0].hasOwnProperty('isActive'));
    } catch (error) {
        assert.fail('Error should not occur');
    }
})();
================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Utility function to read a JSON file and parse its contents.
 * @param {string} filePath - Path to the JSON file.
 * @returns {Object} Parsed JSON object.
 * @throws {Error} If the file cannot be read or parsed.
 */
function readJsonFile(filePath) {
	try {
		const data = fs.readFileSync(filePath, 'utf-8');
		return JSON.parse(data);
	} catch (error) {
		throw new Error(`Failed to read or parse JSON file: ${error.message}`);
	}
}

/**
 * Cleans up a temporary directory by deleting all files within it.
 * @param {string} tempDir - Path to the temporary directory.
 * @throws {Error} If the directory cannot be cleaned up.
 */
function cleanupTempDir(tempDir) {
	try {
		const files = fs.readdirSync(tempDir);
		files.forEach(file => {
			const filePath = path.join(tempDir, file);
			fs.unlinkSync(filePath);
		});
	} catch (error) {
		throw new Error(`Failed to clean up temporary directory: ${error.message}`);
	}
}

/**
 * Transforms input data by applying a set of business rules.
 * @param {Array<Object>} data - Array of data objects to transform.
 * @returns {Array<Object>} Transformed data.
 */
function transformData(data) {
	return data.map(item => {
		item.transformed = true;
		return item;
	});
}



LLM COMPLETION gpt-4.5-preview:
----------------------------------------
/**
 * Processes data by reading from an input file, transforming it, and writing to an output file.
 * @param {string} inputFilePath - Path to the input JSON file.
 * @param {string} outputFilePath - Path to the output JSON file.
 * @throws {Error} If processing fails at any stage.
 */
function processData(inputFilePath, outputFilePath) {
	const inputData = readJsonFile(inputFilePath);
	const transformedData = transformData(inputData);
	fs.writeFileSync(outputFilePath, JSON.stringify(transformedData, null, 2), 'utf-8');
}

SUFFIX CODE:
----------------------------------------


// Example usage
const inputFilePath = path.join(__dirname, 'input.json');
const outputFilePath = path.join(__dirname, 'output.json');

try {
	processData(inputFilePath, outputFilePath);
	console.log('Data processing complete.');
} catch (error) {
	console.error(`Error processing data: ${error.message}`);
}
cleanupTempDir(path.join(__dirname, 'temp'));


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to translate between code and natural language documentation. The prefix provides substantial context with multiple utility functions and a partially documented processData function. The golden completion requires generating comprehensive documentation for the processData function, including detailed descriptions of parameters, return values, error handling, and workflow orchestration. The suffix ensures proper cleanup of resources. This scenario tests the LLM's capability to understand and document complex business logic, handle errors, and manage resources, making it a robust test case.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const docString = `/**
 * Orchestrates the entire data processing workflow.
 * This function reads data from an input JSON file, applies transformations, and writes the results to an output file.
 * Additionally, it handles any errors that occur during the process and ensures proper cleanup of temporary resources.
 *
 * @param {string} inputFilePath - The path to the input JSON file containing the data to be processed.
 * @param {string} outputFilePath - The path to the output JSON file where the transformed data will be saved.
 * @throws {Error} If any step of the data processing fails, an error is thrown with a descriptive message.
 */
`;
assert(docString.includes('Orchestrates the entire data processing workflow.'));
assert(docString.includes('Additionally, it handles any errors that occur during the process and ensures proper cleanup of temporary resources.'));
assert(docString.includes('@param {string} inputFilePath - The path to the input JSON file containing the data to be processed.'));
assert(docString.includes('@throws {Error} If any step of the data processing fails, an error is thrown with a descriptive message.'));
assert(docString.includes('This function reads data from an input JSON file, applies transformations, and writes the results to an output file.'));

================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

// Helper function to simulate a database fetch operation
function fetchUserData(userId) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({ id: userId, name: 'John Doe', role: 'admin' });
        }, 100);
    });
}

// Helper function to simulate a database save operation
function saveUserData(user) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(true);
        }, 100);
    });
}

// Validate user data based on business rules
function validateUserData(user) {
    if (!user.name || !user.role) {
        throw new Error('User data is incomplete');
    }
    if (user.role !== 'admin' && user.role !== 'user') {
        throw new Error('Invalid user role');
    }
    return true;
}



LLM COMPLETION gpt-4.5-preview:
----------------------------------------


SUFFIX CODE:
----------------------------------------
async function updateUserRole(userId, newRole) {
    try {
        const user = await fetchUserData(userId);
        user.role = newRole;
        validateUserData(user);
        await saveUserData(user);
        return user;
    } catch (error) {
        throw new Error(`Failed to update user role: ${error.message}`);
    }
}

(async () => {
    // Test case to verify the updateUserRole function
    const userId = 1;
    const newRole = 'user';
    const updatedUser = await updateUserRole(userId, newRole);
    assert.strictEqual(updatedUser.role, newRole);
    assert.strictEqual(updatedUser.name, 'John Doe');
    console.log('All assertions passed');
})();


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to generate comprehensive documentation for an existing function implementation. The function 'updateUserRole' involves fetching data, validating business rules, handling errors, and saving data, making it a realistic and complex scenario. The documentation includes parameter descriptions, return value, error scenarios, and an example usage, ensuring thorough coverage of the function's behavior. This tests the LLM's understanding of both the code and documentation conventions.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Updates the role of a user.
 *
 * @param {number} userId - The ID of the user to update.
 * @param {string} newRole - The new role to assign to the user.
 * @returns {Promise<Object>} A promise that resolves to the updated user object.
 * @throws {Error} If the user data is invalid or the update fails.
 *
 * Example usage:
 * 
 * const updatedUser = await updateUserRole(1, 'user');
 * console.log(updatedUser);
 * 
 */`;
assert(docString.toLowerCase().includes('updates the role of a user'));
assert(docString.includes('@param {number} userId'));
assert(docString.includes('@param {string} newRole'));
assert(docString.includes('@returns {Promise<Object>}'));
assert(docString.includes('@throws {Error}'));
assert(docString.includes('Example usage'));

================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * Validates if a given email address is in a proper format.
 * An email is considered valid if it matches the following pattern:
 * - Contains exactly one '@' symbol
 * - Contains at least one '.' after the '@' symbol
 * - The part before the '@' symbol is non-empty
 * - The part between the '@' and the last '.' is non-empty
 * - The part after the last '.' is at least two characters long
 *
 * @param {string} email - The email address to validate
 * @returns {boolean} True if the email is valid, false otherwise
 */
function validateEmail(email) {
    const atSymbolIndex = email.indexOf('@');
    if (atSymbolIndex === -1) return false;

    const lastDotIndex = email.lastIndexOf('.');
    if (lastDotIndex === -1 || lastDotIndex < atSymbolIndex) return false;

    if (atSymbolIndex === 0 || lastDotIndex - atSymbolIndex <= 1 || lastDotIndex + 2 > email.length) return false;

    return true;
}

/**
 * Cleans up an array of email addresses by removing invalid ones.
 *
 * @param {string[]} emails - The array of email addresses to clean
 * @returns {string[]} A new array containing only valid email addresses
 */
function cleanEmailList(emails) {
    return emails.filter(validateEmail);
}

// Example usage
const emails = [
    'valid.email@example.com',
    'invalid.email@example',
    '@example.com',
    'valid@example.co'
];

const validEmails = cleanEmailList(emails);


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
console.log(validEmails);

SUFFIX CODE:
----------------------------------------

// Assertions
assert.strictEqual(validEmails.length, 2);
assert.strictEqual(validEmails[0], 'valid.email@example.com');
assert.strictEqual(validEmails[1], 'valid@example.co');

console.log('All assertions passed');

JUSTIFICATION:
----------------------------------------
This test case is a good example for code-to-comment translation because it includes a detailed function with multiple validation rules and a clear business logic scenario. The function validateEmail ensures email addresses meet specific criteria, and the cleanEmailList function demonstrates a practical use case. The golden_completion requires generating comprehensive documentation for the new function filterValidEmails, ensuring the LLM can provide accurate and detailed comments. Assertions verify the correct functionality of the code.

ASSERTIONS:
----------------------------------------
const docString = filterValidEmails.toString();
assert(docString.includes('Filters an array of email addresses'));
assert(docString.includes('Utilizes the validateEmail function'));
assert(docString.includes('Parameters:'));
assert(docString.includes('@param {string[]} emails'));
assert(docString.includes('@returns {string[]}'));

const filteredEmails = filterValidEmails(emails);
assert.strictEqual(filteredEmails.length, 2);
assert.strictEqual(filteredEmails[0], 'valid.email@example.com');
assert.strictEqual(filteredEmails[1], 'valid@example.co');
================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');

/**
 * Business rules validation for a financial transaction.
 * This function checks whether a transaction complies with the company's policy.
 * @param {Object} transaction - The transaction object
 * @param {number} transaction.amount - The amount of the transaction
 * @param {string} transaction.currency - The currency of the transaction
 * @param {boolean} transaction.isInternal - Whether the transaction is internal
 * @returns {boolean} - Returns true if the transaction is valid, otherwise false
 */
function validateTransaction(transaction) {
    // Check if the transaction amount is within the allowed range
    if (transaction.amount <= 0 || transaction.amount > 10000) {
        return false;
    }
    // Check if the transaction currency is supported
    const supportedCurrencies = ['USD', 'EUR', 'GBP'];
    if (!supportedCurrencies.includes(transaction.currency)) {
        return false;
    }
    // Internal transactions must be in USD
    if (transaction.isInternal && transaction.currency !== 'USD') {
        return false;
    }
    return true;
}

/**
 * Workflow orchestration for processing multiple tasks sequentially.
 * This function processes a list of tasks and returns the results.
 * @param {Array<Function>} tasks - An array of task functions
 * @returns {Promise<Array>} - A promise that resolves to an array of results
 */
async function processTasksSequentially(tasks) {
    const results = [];
    for (const task of tasks) {
        try {
            const result = await task();
            results.push(result);
        } catch (error) {
            console.error('Task failed:', error);
            results.push(null);
        }
    }
    return results;
}

/**
 * Domain modeling for business entities.
 * Class representing a Customer.
 */
class Customer {
    /**
     * Create a Customer.
     * @param {string} id - The customer ID
     * @param {string} name - The customer name
     * @param {string} email - The customer email
     */
    constructor(id, name, email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    /**
     * Get the customer's full details.
     * @returns {string} - The full details of the customer
     */
    getDetails() {
        return `Customer ID: ${this.id}, Name: ${this.name}, Email: ${this.email}`;
    }
}

/**
 * API integration for authentication.
 * This function authenticates a user with the API.
 * @param {string} username - The username
 * @param {string} password - The password
 * @returns {Promise<Object>} - A promise that resolves to the authentication response
 */
async function authenticateUser(username, password) {
    try {
        const response = await axios.post('https://api.example.com/auth', { username, password });
        return response.data;
    } catch (error) {
        throw new Error('Authentication failed');
    }
}

/**
 * Cache management strategies.
 * Function to invalidate cache for a specific key.
 * @param {string} key - The cache key to invalidate
 * @returns {void}
 */
function invalidateCache(key) {
    // Simulate cache invalidation
    console.log(`Cache invalidated for key: ${key}`);
}

/**
 * Error handling logic for resource management.
 * This function releases a database connection.
 * @param {Object} connection - The database connection object
 * @returns {void}
 */
function releaseConnection(connection) {
    if (connection) {
        connection.release();
        console.log('Connection released');
    } else {
        console.error('No connection to release');
    }
}

/**
 * Error handling logic for resource management.
 * This function ensures that resources are properly released.
 * @returns {void}
 */
function cleanupResources() {
    try {
        // Perform cleanup tasks
        releaseConnection(dbConnection);
    } catch (error) {
        console.error('Failed to clean up resources:', error);
    }
}



LLM COMPLETION gpt-4.5-preview:
----------------------------------------
// Mock database connection object
const dbConnection = { release: () => console.log('Mock connection released') };

SUFFIX CODE:
----------------------------------------

// Test assertions
const assert = require('assert');

// Validate transaction tests
assert.strictEqual(validateTransaction({ amount: 5000, currency: 'USD', isInternal: true }), true);
assert.strictEqual(validateTransaction({ amount: 15000, currency: 'USD', isInternal: true }), false);
assert.strictEqual(validateTransaction({ amount: 5000, currency: 'EUR', isInternal: false }), true);
assert.strictEqual(validateTransaction({ amount: 5000, currency: 'EUR', isInternal: true }), false);

// Process tasks sequentially tests
(async () => {
    const tasks = [
        async () => 'Task 1 result',
        async () => { throw new Error('Task 2 error'); },
        async () => 'Task 3 result'
    ];
    const results = await processTasksSequentially(tasks);
    assert.deepStrictEqual(results, ['Task 1 result', null, 'Task 3 result']);
})();

// Customer class tests
const customer = new Customer('123', 'John Doe', 'john.doe@example.com');
assert.strictEqual(customer.getDetails(), 'Customer ID: 123, Name: John Doe, Email: john.doe@example.com');

// API integration tests
(async () => {
    try {
        const authResponse = await authenticateUser('user', 'pass');
        assert.ok(authResponse.token);
    } catch (error) {
        assert.fail('Authentication should not fail');
    }
})();

// Cache invalidation test
invalidateCache('user_cache');

// Resource cleanup test
const dbConnection = { release: () => console.log('Mock connection released') };
cleanupResources();


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the ability of a language model to understand and generate comprehensive documentation for JavaScript code. The prefix includes various examples of functions and classes with detailed JSDoc comments, covering business rules validation, workflow orchestration, domain modeling, API integration, cache management, and resource management. The golden completion requires generating a function with proper documentation for configuration management. The suffix includes assertions to verify the correctness of the implementations and the generated documentation. This scenario tests the model's capability to handle complex business logic and technical requirements, ensuring the alignment between code and comments.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Configuration management for dynamic settings.
 * This function updates a configuration setting.
 * @param {string} key - The configuration key
 * @param {any} value - The new value for the configuration key
 * @returns {void}
 */`;
assert(docString.toLowerCase().includes('configuration management'));
assert(docString.includes('@param {string} key'));
assert(docString.includes('@returns {void}'));
assert(docString.includes('updates a configuration setting'));

================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { assert } = require('chai');

/**
 * Class representing a Task Scheduler
 * Responsible for scheduling tasks based on priority and execution time.
 */
class TaskScheduler {


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
    constructor() {

SUFFIX CODE:
----------------------------------------
    constructor() {
        /** @private @type {Array<{priority: number, execute: Function, time: number}>} */
        this.tasks = [];
    }

    /**
     * Adds a task to the scheduler.
     * @param {number} priority - The priority of the task.
     * @param {Function} execute - The function to execute the task.
     * @param {number} time - The execution time of the task.
     */
    addTask(priority, execute, time) {
        this.tasks.push({ priority, execute, time });
        this.tasks.sort((a, b) => a.priority - b.priority);
    }

    /**
     * Executes all tasks in the scheduler.
     */
    executeAll() {
        for (const task of this.tasks) {
            setTimeout(task.execute, task.time);
        }
    }

    /**
     * Clears all scheduled tasks.
     */
    clear() {
        this.tasks = [];
    }
}

// Example usage of TaskScheduler
const scheduler = new TaskScheduler();
scheduler.addTask(1, () => console.log('Task 1 executed'), 1000);
scheduler.addTask(2, () => console.log('Task 2 executed'), 500);
scheduler.addTask(1, () => console.log('Task 3 executed'), 1500);
scheduler.executeAll();

// Test that tasks are scheduled and executed correctly
setTimeout(() => { 
    scheduler.clear();
    assert(scheduler.tasks.length === 0, 'Tasks were not cleared correctly');
}, 2000);

// Clean up resources
scheduler.clear();


JUSTIFICATION:
----------------------------------------
This test case is designed to validate the LLM's ability to generate comprehensive documentation for a class implementation, demonstrating code-to-comment translation. The provided prefix includes a fully functional TaskScheduler class with methods for adding, executing, and clearing tasks. The golden completion requires the LLM to generate detailed JSDoc comments for the class and its methods, including parameter descriptions, usage examples, and method explanations. The suffix contains code that follows the completion, ensuring no duplication of the golden completion. Assertions verify that tasks are correctly executed and cleared, ensuring functional correctness.

ASSERTIONS:
----------------------------------------
assert(scheduler.tasks.length === 3, 'Tasks were not added correctly');
setTimeout(() => { 
    assert(scheduler.tasks.length === 0, 'Tasks were not cleared correctly');
}, 2000);

================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');



LLM COMPLETION gpt-4.5-preview:
----------------------------------------
// 

SUFFIX CODE:
----------------------------------------
/**
 * A utility function to read a JSON configuration file and parse its content.
 * @param {string} filePath - The path to the JSON configuration file.
 * @returns {Object} - The parsed configuration object.
 * @throws Will throw an error if the file does not exist or is not valid JSON.
 */
function readConfig(filePath) {
    const absolutePath = path.resolve(filePath);
    if (!fs.existsSync(absolutePath)) {
        throw new Error(`Configuration file not found: ${absolutePath}`);
    }
    const fileContent = fs.readFileSync(absolutePath, 'utf-8');
    try {
        return JSON.parse(fileContent);
    } catch (e) {
        throw new Error(`Invalid JSON in configuration file: ${absolutePath}`);
    }
}

/**
 * A utility function to write a JSON configuration file.
 * @param {string} filePath - The path to the JSON configuration file.
 * @param {Object} config - The configuration object to write.
 * @throws Will throw an error if the file cannot be written.
 */
function writeConfig(filePath, config) {
    const absolutePath = path.resolve(filePath);
    const fileContent = JSON.stringify(config, null, 2);
    try {
        fs.writeFileSync(absolutePath, fileContent, 'utf-8');
    } catch (e) {
        throw new Error(`Could not write to configuration file: ${absolutePath}`);
    }
}

/**
 * A function to update a specific configuration setting.
 * @param {string} filePath - The path to the JSON configuration file.
 * @param {string} key - The key of the setting to update.
 * @param {any} value - The new value for the setting.
 * @throws Will throw an error if the configuration file cannot be read or written.
 */
function updateConfig(filePath, key, value) {
    const config = readConfig(filePath);
    config[key] = value;
    writeConfig(filePath, config);
}

// Example usage of the above utility functions
const configPath = 'config.json';
try {
    const config = readConfig(configPath);
    console.log('Current configuration:', config);
    updateConfig(configPath, 'newSetting', 'newValue');
    console.log('Updated configuration:', readConfig(configPath));
} catch (e) {
    console.error(e.message);
}
console.log('Finished updating configuration');

JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves non-trivial business logic for managing JSON configuration files. The prefix code includes utility functions for reading, writing, and updating configuration files, which require proper error handling. The golden completion provides comprehensive documentation for these utilities, ensuring that an LLM can generate detailed and accurate comments for complex code. The suffix contains code that follows the documented functions, ensuring there is no duplication. The assertions will verify the correctness of the generated documentation.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const docString = `/**
 * This module provides utility functions for reading, writing, and updating JSON configuration files.
 * It ensures that the configuration files are read and written in a safe manner, handling errors appropriately.
 * 
 * Functions:
 * 1. readConfig(filePath): Reads and parses a JSON configuration file.
 * 2. writeConfig(filePath, config): Writes a configuration object to a JSON file.
 * 3. updateConfig(filePath, key, value): Updates a specific configuration setting in a JSON file.
 * 
 * Usage examples demonstrate reading the current configuration, updating a setting, and printing the updated configuration.
 */`;
assert(docString.toLowerCase().includes('utility functions for reading, writing, and updating json configuration files'));
assert(docString.includes('Functions:'));
assert(docString.includes('1. readConfig(filePath): Reads and parses a JSON configuration file.'));
assert(docString.includes('2. writeConfig(filePath, config): Writes a configuration object to a JSON file.'));
assert(docString.includes('3. updateConfig(filePath, key, value): Updates a specific configuration setting in a JSON file.'));
assert(docString.includes('Usage examples demonstrate reading the current configuration, updating a setting, and printing the updated configuration.'));

================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { strict: assert } = require('assert');

/**
 * Business rule validator for checking if a user is eligible for a premium account.
 * @param {Object} user - The user object
 * @param {number} user.age - The age of the user
 * @param {string} user.accountType - The type of the user's account
 * @returns {boolean} Returns true if the user is eligible for a premium account, otherwise false.
 * @throws {Error} Throws an error if the user object is invalid.
 */
function isEligibleForPremium(user) {
    if (!user || typeof user !== 'object') {
        throw new Error('Invalid user object');
    }
    if (typeof user.age !== 'number' || typeof user.accountType !== 'string') {
        throw new Error('Invalid user properties');
    }
    return user.age >= 18 && user.accountType === 'standard';
}

// Example Usage
const user1 = { age: 25, accountType: 'standard' };
const user2 = { age: 16, accountType: 'standard' };
const user3 = { age: 25, accountType: 'premium' };

// Test cases
assert.strictEqual(isEligibleForPremium(user1), true);
assert.strictEqual(isEligibleForPremium(user2), false);
assert.strictEqual(isEligibleForPremium(user3), false);

/**
 * Function to upgrade a user's account to premium if eligible.
 * @param {Object} user - The user object
 * @param {number} user.age - The age of the user
 * @param {string} user.accountType - The type of the user's account
 * @returns {Object} The updated user object
 * @throws {Error} Throws an error if the user is not eligible for a premium account.
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function upgradeToPremium(user) {
    if (!isEligibleForPremium(user)) {
        throw new Error('User is not eligible for a premium account');
    }
    return { ...user, accountType: 'premium' };
}


SUFFIX CODE:
----------------------------------------
const upgradedUser = upgradeToPremium(user1);
assert.strictEqual(upgradedUser.accountType, 'premium');

try {
    upgradeToPremium(user2);
} catch (error) {
    assert.strictEqual(error.message, 'User is not eligible for a premium account');
}

try {
    upgradeToPremium(user3);
} catch (error) {
    assert.strictEqual(error.message, 'User is not eligible for a premium account');
}

console.log('All tests passed.');

JUSTIFICATION:
----------------------------------------
This test case is a good example of bidirectional translation between code and natural language because it involves complex business rules and error handling. The prefix includes the implementation of a business rule validator function with detailed JSDoc comments, example usages, and test cases. The golden completion requires implementing a function based on provided documentation, ensuring that the function correctly follows the business logic and handles errors appropriately. The suffix includes further test cases to validate the implementation, ensuring that the assertions pass and the resource management is correct. The example demonstrates clear documentation patterns and realistic business logic.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Function to upgrade a user's account to premium if eligible.
 * @param {Object} user - The user object
 * @param {number} user.age - The age of the user
 * @param {string} user.accountType - The type of the user's account
 * @returns {Object} The updated user object
 * @throws {Error} Throws an error if the user is not eligible for a premium account.
 */`;
assert(docString.includes('Function to upgrade a user\'s account to premium if eligible'));
assert(docString.includes('@param {Object} user - The user object'));
assert(docString.includes('@returns {Object} The updated user object'));
assert(docString.includes('@throws {Error} Throws an error if the user is not eligible for a premium account'));
assert.strictEqual(upgradeToPremium({ age: 25, accountType: 'standard' }).accountType, 'premium');
assert.throws(() => upgradeToPremium({ age: 16, accountType: 'standard' }), /User is not eligible for a premium account/);
================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

/**
 * Reads a JSON file and parses its content.
 * @param {string} filePath - The path to the JSON file.
 * @returns {Object} The parsed JSON object.
 * @throws {Error} If the file cannot be read or parsed.
 */
function readJsonFile(filePath) {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        throw new Error(`Error reading or parsing file: ${error.message}`);
    }
}

/**
 * Validates the structure of a user object.
 * @param {Object} user - The user object to validate.
 * @returns {boolean} True if the user object is valid, otherwise false.
 */
function validateUser(user) {
    if (typeof user !== 'object' || user === null) return false;
    const requiredFields = ['id', 'name', 'email'];
    return requiredFields.every(field => user.hasOwnProperty(field));
}

/**
 * Loads and validates users from a JSON file.
 * @param {string} filePath - The path to the JSON file containing users.
 * @returns {Object[]} An array of valid user objects.
 * @throws {Error} If the file cannot be read or parsed, or if the data is invalid.
 */
function loadAndValidateUsers(filePath) {
    const users = readJsonFile(filePath);
    if (!Array.isArray(users)) throw new Error('Invalid data format: expected an array of users.');
    const validUsers = users.filter(validateUser);
    if (validUsers.length === 0) throw new Error('No valid users found.');
    return validUsers;
}

// Example usage:
const filePath = './users.json';
try {
    const users = loadAndValidateUsers(filePath);
    console.log('Valid users:', users);
} catch (error) {
    console.error(error.message);
}


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
users.forEach(user => {
    console.log(`User ID: ${user.id}, Name: ${user.name}, Email: ${user.email}`);
});

SUFFIX CODE:
----------------------------------------

// Additional processing of valid users can be done here
// For example, adding them to a database or sending them to another service


JUSTIFICATION:
----------------------------------------
This test case effectively evaluates the ability of an LLM to translate between code and comprehensive documentation. The scenario involves complex business logic of loading and validating user data from a JSON file, with detailed JSDoc comments explaining the workflow. The prefix provides extensive context, including helper functions and example usage, while the golden_completion focuses on generating detailed documentation for a function orchestrating the entire process. Assertions will verify the correctness and completeness of the generated documentation.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Mock the file system for testing
const mockFs = require('mock-fs');
mockFs({ './users.json': JSON.stringify([{ id: 1, name: 'John Doe', email: 'john@example.com' }, { id: 2, name: 'Jane Doe', email: 'jane@example.com' }]) });

// Test readJsonFile function
const users = readJsonFile('./users.json');
assert(Array.isArray(users), 'Expected an array of users');
assert(users.length === 2, 'Expected two users in the array');

// Test validateUser function
assert(validateUser(users[0]), 'Expected the first user to be valid');
assert(validateUser(users[1]), 'Expected the second user to be valid');
assert(!validateUser({}), 'Expected an empty object to be invalid');

// Test loadAndValidateUsers function
const validUsers = loadAndValidateUsers('./users.json');
assert(Array.isArray(validUsers), 'Expected an array of valid users');
assert(validUsers.length === 2, 'Expected two valid users');

// Test orchestrateUserProcessing function
let consoleOutput = '';
const originalConsoleLog = console.log;
const originalConsoleError = console.error;
console.log = (message) => { consoleOutput += message; };
console.error = (message) => { consoleOutput += message; };
orchestrateUserProcessing('./users.json');
assert(consoleOutput.includes('Valid users:'), 'Expected console output to include valid users');

// Restore original console methods
console.log = originalConsoleLog;
console.error = originalConsoleError;

// Cleanup mock file system
mockFs.restore();
================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');



LLM COMPLETION gpt-4.5-preview:
----------------------------------------
// No additional code needed here

SUFFIX CODE:
----------------------------------------

function calculatePortfolioRisk(assets) {
    let totalValue = 0;
    let totalRisk = 0;

    assets.forEach(asset => {
        totalValue += asset.value;
        totalRisk += asset.value * asset.risk;
    });

    if (totalValue === 0) {
        throw new Error('Total value of assets cannot be zero.');
    }

    return totalRisk / totalValue;
}

// Example usage:
const portfolio = [
    { value: 10000, risk: 0.1 },
    { value: 20000, risk: 0.2 },
    { value: 30000, risk: 0.15 }
];

const expectedRisk = (10000 * 0.1 + 20000 * 0.2 + 30000 * 0.15) / (10000 + 20000 + 30000);
assert.strictEqual(calculatePortfolioRisk(portfolio), expectedRisk);

// Additional tests
const zeroValuePortfolio = [
    { value: 0, risk: 0.1 }
];

try {
    calculatePortfolioRisk(zeroValuePortfolio);
    assert.fail('Expected an error due to zero total value');
} catch (e) {
    assert.strictEqual(e.message, 'Total value of assets cannot be zero.');
}


JUSTIFICATION:
----------------------------------------
This test case is a good example of translating between code and natural language because it covers a complex business logic scenario involving financial calculations. The provided prefix includes a function that calculates the risk of a financial portfolio based on its assets, along with detailed JSDoc comments explaining the function, parameters, and return value. The golden completion requires generating comprehensive documentation for the function, ensuring that the LLM can accurately translate the code into natural language. The suffix includes different code for additional tests, avoiding duplication with the golden completion. The assertions verify the correctness of the documentation and the function's behavior, including error handling for edge cases.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * The function calculates the risk of a financial portfolio by considering the value and risk factor of each asset.
 * It throws an error if the total value of the assets is zero to prevent division by zero.
 * 
 * @param {Array} assets - An array of objects representing the assets in the portfolio.
 * @param {number} assets[].value - The monetary value of the asset.
 * @param {number} assets[].risk - The risk factor associated with the asset.
 * @returns {number} The weighted average risk of the portfolio.
 * 
 * @throws {Error} If the total value of the assets is zero.
 * 
 * @example
 * const portfolio = [
 *     { value: 10000, risk: 0.1 },
 *     { value: 20000, risk: 0.2 },
 *     { value: 30000, risk: 0.15 }
 * ];
 * const risk = calculatePortfolioRisk(portfolio);
 * console.log(risk); // Expected output: 0.15
 */`;

assert(docString.toLowerCase().includes('calculates the risk of a financial portfolio'));
assert(docString.includes('@param {Array} assets'));
assert(docString.includes('@returns {number}'));
assert(docString.includes('@throws {Error}'));
assert(docString.includes('@example'));

================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');

/**
 * Function to fetch stock data for a given portfolio.
 * @param {Array} portfolio - An array of stock symbols.
 * @returns {Promise<Object>} - A promise that resolves to an object containing stock data.
 */
async function fetchStockData(portfolio) {
    const apiKey = 'YOUR_API_KEY';
    const baseURL = 'https://api.example.com/stocks';
    let stockData = {};

    for (const symbol of portfolio) {
        try {
            const response = await axios.get(`${baseURL}/${symbol}`, {
                params: { apiKey }
            });
            stockData[symbol] = response.data;
        } catch (error) {
            console.error(`Failed to fetch data for ${symbol}: ${error.message}`);
            stockData[symbol] = null;
        }
    }

    return stockData;
}

/**
 * Function to calculate the total value of a stock portfolio.
 * @param {Object} stockData - An object containing stock data with stock symbols as keys.
 * @param {Object} portfolio - An object containing the number of shares for each stock symbol.
 * @returns {number} - The total value of the portfolio.
 */
function calculatePortfolioValue(stockData, portfolio) {
    let totalValue = 0;
    for (const symbol in portfolio) {
        if (stockData[symbol] && stockData[symbol].price) {
            totalValue += stockData[symbol].price * portfolio[symbol];
        }
    }
    return totalValue;
}

// Portfolio symbols and shares
const myPortfolioSymbols = ['AAPL', 'GOOGL', 'MSFT'];
const myPortfolioShares = { 'AAPL': 10, 'GOOGL': 5, 'MSFT': 8 };

// Fetch stock data and calculate portfolio value
(async () => {
    const stockData = await fetchStockData(myPortfolioSymbols);


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
    const portfolioValue = calculatePortfolioValue(stockData, myPortfolioShares);

SUFFIX CODE:
----------------------------------------
    const portfolioValue = calculatePortfolioValue(stockData, myPortfolioShares);
    console.log(`Total portfolio value: $${portfolioValue}`);
})();


JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic financial scenario involving fetching stock data, calculating portfolio value, and calculating portfolio risk. It includes a comprehensive setup with API calls, error handling, and data processing. The test ensures the LLM can generate proper documentation for complex functions and translate detailed comments into accurate code implementations. The scenario includes both code-to-comment and comment-to-code translations, verifying the model's ability to handle both directions effectively.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

(async () => {
    const stockDataMock = {
        'AAPL': { price: 150, volatility: 0.02 },
        'GOOGL': { price: 2800, volatility: 0.015 },
        'MSFT': { price: 300, volatility: 0.025 }
    };
    const portfolioMock = { 'AAPL': 10, 'GOOGL': 5, 'MSFT': 8 };

    const portfolioValue = calculatePortfolioValue(stockDataMock, portfolioMock);
    assert.strictEqual(portfolioValue, 150 * 10 + 2800 * 5 + 300 * 8, 'Portfolio value calculation is incorrect');

    const portfolioRisk = calculatePortfolioRisk(stockDataMock, portfolioMock);
    const expectedRisk = ((150 * 10 * 0.02) + (2800 * 5 * 0.015) + (300 * 8 * 0.025)) / (150 * 10 + 2800 * 5 + 300 * 8);
    assert.strictEqual(portfolioRisk, expectedRisk, 'Portfolio risk calculation is incorrect');
})();

================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { strict: assert } = require('assert');
const fs = require('fs');



LLM COMPLETION gpt-4.5-preview:
----------------------------------------


SUFFIX CODE:
----------------------------------------
class Portfolio {
    constructor() {
        this.assets = [];
    }

    /**
     * Adds an asset to the portfolio.
     * @param {string} assetName - The name of the asset.
     * @param {number} amount - The amount invested in the asset.
     */
    addAsset(assetName, amount) {
        this.assets.push({ assetName, amount });
    }

    /**
     * Calculates the total value of the portfolio.
     * @returns {number} The total value of all assets in the portfolio.
     */
    calculateTotalValue() {
        return this.assets.reduce((total, asset) => total + asset.amount, 0);
    }

    /**
     * Saves the portfolio to a file.
     * @param {string} filePath - The path to the file where the portfolio should be saved.
     * @returns {Promise<void>} A promise that resolves when the file has been written.
     */
    saveToFile(filePath) {
        const data = JSON.stringify(this.assets, null, 2);
        return fs.promises.writeFile(filePath, data);
    }

    /**
     * Loads the portfolio from a file.
     * @param {string} filePath - The path to the file from which the portfolio should be loaded.
     * @returns {Promise<void>} A promise that resolves when the portfolio has been loaded.
     */
    loadFromFile(filePath) {
        return fs.promises.readFile(filePath, 'utf-8')
            .then((data) => {
                this.assets = JSON.parse(data);
            });
    }

    /**
     * Performs risk assessment of the portfolio.
     * @returns {number} The calculated risk of the portfolio.
     */
    assessRisk() {
        // Complex risk assessment algorithm
        let risk = 0;
        for (const asset of this.assets) {
            // Simple example: higher investment amounts are riskier
            risk += asset.amount * 0.01;
        }
        return risk;
    }
}

// Example usage:
const myPortfolio = new Portfolio();
myPortfolio.addAsset('Stock A', 1000);
myPortfolio.addAsset('Bond B', 5000);
const totalValue = myPortfolio.calculateTotalValue();
console.log(`Total Portfolio Value: $${totalValue}`);
myPortfolio.saveToFile('portfolio.json').then(() => {
    console.log('Portfolio saved successfully.');
});
myPortfolio.loadFromFile('portfolio.json').then(() => {
    console.log('Portfolio loaded successfully.');
    const risk = myPortfolio.assessRisk();
    console.log(`Portfolio Risk: ${risk}`);
});


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves a realistic business scenario of managing a financial portfolio. The provided code includes various methods for adding assets, calculating total value, saving to and loading from files, and performing risk assessments. The task requires translating this code into comprehensive JSDoc comments, testing the LLM's ability to generate detailed and accurate documentation. The provided assertions will verify the presence of key terms and ensure the documentation covers all important concepts.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * @class Portfolio
 * @description Represents a financial portfolio and provides methods to perform risk assessment and portfolio analysis.
 * @property {Array<Object>} assets - The list of assets in the portfolio.
 * @method addAsset - Adds an asset to the portfolio.
 * @method calculateTotalValue - Calculates the total value of the portfolio.
 * @method saveToFile - Saves the portfolio to a file.
 * @method loadFromFile - Loads the portfolio from a file.
 * @method assessRisk - Performs risk assessment of the portfolio.
 */`;
assert(docString.toLowerCase().includes('portfolio'));
assert(docString.toLowerCase().includes('risk assessment'));
assert(docString.includes('Parameters:'));
assert(docString.includes('@property {Array<Object>} assets'));
assert(docString.includes('@method addAsset'));
assert(docString.includes('@method calculateTotalValue'));
assert(docString.includes('@method saveToFile'));
assert(docString.includes('@method loadFromFile'));
assert(docString.includes('@method assessRisk'));
================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

/**
 * Function to fetch stock data from an external API and calculate the risk assessment of a portfolio.
 * @param {string} apiUrl - The API endpoint URL to fetch stock data.
 * @param {Array<string>} stockSymbols - Array of stock symbols to fetch data for.
 * @param {number} riskFreeRate - The risk-free rate for calculations.
 * @returns {Promise<Object>} - A promise that resolves to an object containing risk assessment details.
 */
async function fetchStockDataAndCalculateRisk(apiUrl, stockSymbols, riskFreeRate) {
    try {
        const stockDataPromises = stockSymbols.map(symbol => fetch(`${apiUrl}/stocks/${symbol}`).then(response => response.json()));
        const stockData = await Promise.all(stockDataPromises);

        // Calculate average returns and standard deviation
        const averageReturns = stockData.map(data => data.averageReturn);
        const standardDeviations = stockData.map(data => data.standardDeviation);

        // Calculate portfolio variance and expected return
        let portfolioVariance = 0;
        let expectedReturn = 0;

        stockData.forEach((data, index) => {
            portfolioVariance += Math.pow(standardDeviations[index], 2);
            expectedReturn += averageReturns[index];
        });

        portfolioVariance /= stockSymbols.length;
        expectedReturn /= stockSymbols.length;

        // Calculate Sharpe ratio
        const sharpeRatio = (expectedReturn - riskFreeRate) / Math.sqrt(portfolioVariance);

        return {
            expectedReturn,
            portfolioVariance,
            sharpeRatio
        };
    } catch (error) {
        console.error('Error fetching stock data or calculating risk:', error);
        throw new Error('Failed to fetch stock data or calculate risk');
    }
}

module.exports = { fetchStockDataAndCalculateRisk };

// Example usage
(async () => {
    const apiUrl = 'https://api.example.com';
    const stockSymbols = ['AAPL', 'GOOGL', 'MSFT'];
    const riskFreeRate = 0.02;
    try {
        const riskAssessment = await fetchStockDataAndCalculateRisk(apiUrl, stockSymbols, riskFreeRate);
        console.log('Risk Assessment:', riskAssessment);
    } catch (error) {
        console.error('Error:', error.message);
    }
})();


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
const assert = require('assert');

(async () => {
    const apiUrl = 'https://api.example.com';
    const stockSymbols = ['AAPL', 'GOOGL', 'MSFT'];
    const riskFreeRate = 0.02;
    const mockResponse = [
        { averageReturn: 0.1, standardDeviation: 0.2 },
        { averageReturn: 0.15, standardDeviation: 0.25 },
        { averageReturn: 0.12, standardDeviation: 0.22 }
    ];

    global.fetch = async (url) => {
        const symbol = url.split('/').pop();
        const data = mockResponse[stockSymbols.indexOf(symbol)];
        return { json: async () => data };
    };

    try {
        const riskAssessment = await fetchStockDataAndCalculateRisk(apiUrl, stockSymbols, riskFreeRate);
        assert(riskAssessment.expectedReturn > 0, 'Expected return should be positive');
        assert(riskAssessment.portfolioVariance > 0, 'Portfolio variance should be positive');
        assert(riskAssessment.sharpeRatio > 0, 'Sharpe ratio should be positive');
        console.log('All assertions passed.');
    } catch (error) {
        console.error('Test failed:', error.message);
    } finally {
        delete global.fetch;
    }
})();

SUFFIX CODE:
----------------------------------------
const assert = require('assert');

(async () => {
    const apiUrl = 'https://api.example.com';
    const stockSymbols = ['AAPL', 'GOOGL', 'MSFT'];
    const riskFreeRate = 0.02;
    const mockResponse = [
        { averageReturn: 0.1, standardDeviation: 0.2 },
        { averageReturn: 0.15, standardDeviation: 0.25 },
        { averageReturn: 0.12, standardDeviation: 0.22 }
    ];

    // Mock fetch to return predefined responses
    global.fetch = async (url) => {
        const symbol = url.split('/').pop();
        const data = mockResponse[stockSymbols.indexOf(symbol)];
        return { json: async () => data };
    };

    try {
        const riskAssessment = await fetchStockDataAndCalculateRisk(apiUrl, stockSymbols, riskFreeRate);
        assert(riskAssessment.expectedReturn > 0, 'Expected return should be positive');
        assert(riskAssessment.portfolioVariance > 0, 'Portfolio variance should be positive');
        assert(riskAssessment.sharpeRatio > 0, 'Sharpe ratio should be positive');
        console.log('All assertions passed.');
    } catch (error) {
        console.error('Test failed:', error.message);
    } finally {
        // Cleanup mock
        delete global.fetch;
    }
})();


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves complex business logic related to financial calculations, including fetching data from an external API, processing the data to compute financial metrics, and handling potential errors. The prefix provides a detailed setup with a fully implemented function and example usage, while the golden completion requires generating comprehensive documentation that accurately describes the function's parameters, return values, and error handling. The suffix includes assertions to verify the correctness of the function's output, ensuring that the documentation provided in the golden completion is complete and accurate. This test case effectively evaluates an LLM's ability to translate between code and natural language, demonstrating both code-to-comment and comment-to-code capabilities.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Fetches stock data from an external API, calculates average returns, standard deviations, portfolio variance, expected return, and Sharpe ratio.
 * Handles errors by logging and rethrowing them.
 *
 * Parameters:
 * - apiUrl (string): The API endpoint URL to fetch stock data.
 * - stockSymbols (Array<string>): Array of stock symbols to fetch data for.
 * - riskFreeRate (number): The risk-free rate for calculations.
 *
 * Returns:
 * - Promise<Object>: A promise that resolves to an object containing the risk assessment details.
 *
 * Example usage:
 * (async () => {
 *     const apiUrl = 'https://api.example.com';
 *     const stockSymbols = ['AAPL', 'GOOGL', 'MSFT'];
 *     const riskFreeRate = 0.02;
 *     try {
 *         const riskAssessment = await fetchStockDataAndCalculateRisk(apiUrl, stockSymbols, riskFreeRate);
 *         console.log('Risk Assessment:', riskAssessment);
 *     } catch (error) {
 *         console.error('Error:', error.message);
 *     }
 * })();
 */`;
const assert = require('assert');
assert(docString.includes('Fetches stock data from an external API'));
assert(docString.includes('Parameters:'));
assert(docString.includes('Returns:'));
assert(docString.includes('Example usage:'));
assert(docString.includes('Handles errors by logging and rethrowing them.'));
================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');



LLM COMPLETION gpt-4.5-preview:
----------------------------------------


SUFFIX CODE:
----------------------------------------
class Portfolio {
    /**
     * Create a portfolio.
     * @param {string} owner - The owner of the portfolio.
     */
    constructor(owner) {
        this.owner = owner;
        this.holdings = [];
    }

    /**
     * Add an asset to the portfolio.
     * @param {string} asset - The name of the asset.
     * @param {number} quantity - The quantity of the asset.
     */
    addAsset(asset, quantity) {
        this.holdings.push({ asset, quantity });
    }

    /**
     * Calculate the total value of the portfolio.
     * @param {Object} prices - An object mapping asset names to their prices.
     * @returns {number} The total value of the portfolio.
     */
    calculateTotalValue(prices) {
        let total = 0;
        for (const holding of this.holdings) {
            total += holding.quantity * prices[holding.asset];
        }
        return total;
    }
}

// Example usage:
const myPortfolio = new Portfolio('Alice');
myPortfolio.addAsset('AAPL', 10);
myPortfolio.addAsset('GOOGL', 5);
const prices = { 'AAPL': 150, 'GOOGL': 100 };
const totalValue = myPortfolio.calculateTotalValue(prices);
console.log(`Total value of the portfolio is: $${totalValue}`);

assert.strictEqual(totalValue, 2000);

// Cleanup (if any resources need to be cleaned up, place it here)


JUSTIFICATION:
----------------------------------------
This example serves as a comprehensive test case for translating between code and natural language. The prefix establishes a detailed implementation of a Portfolio class, complete with methods for adding assets and calculating the total value. The golden_completion provides a thorough JSDoc comment block that documents the class, its properties, and methods, ensuring alignment with the implementation. The suffix continues the execution and verification of the implementation, ensuring the documentation accurately reflects the code. Assertions validate the functional correctness, making this a robust test case for bidirectional translation capabilities.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * @class Portfolio
 * @classdesc Represents a portfolio of assets owned by an individual.
 * @param {string} owner - The owner of the portfolio.
 * @property {string} owner - The owner of the portfolio.
 * @property {Array<{asset: string, quantity: number}>} holdings - The holdings in the portfolio.
 * @method addAsset - Adds an asset to the portfolio.
 * @param {string} asset - The name of the asset.
 * @param {number} quantity - The quantity of the asset.
 * @method calculateTotalValue - Calculates the total value of the portfolio based on current prices.
 * @param {Object} prices - An object mapping asset names to their prices.
 * @returns {number} The total value of the portfolio.
 */`;
assert(docString.toLowerCase().includes('portfolio'));
assert(docString.includes('Parameters:'));
assert(docString.includes('owner'));
assert(docString.includes('holdings'));
assert(docString.includes('addAsset'));
assert(docString.includes('calculateTotalValue'));
assert(docString.includes('prices'));
assert(docString.includes('returns'));

================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { strict: assert } = require('assert');

/**
 * Represents a stock in a financial portfolio.
 * @constructor
 * @param {string} symbol - The stock symbol.
 * @param {number} shares - The number of shares owned.
 * @param {number} price - The current price per share.
 */
function Stock(symbol, shares, price) {
    this.symbol = symbol;
    this.shares = shares;
    this.price = price;
}

/**
 * Calculates the total value of the stock holdings.
 * @returns {number} The total value of the stock holdings.
 */
Stock.prototype.totalValue = function() {
    return this.shares * this.price;
};

/**
 * Represents a portfolio of stocks.
 * @constructor
 */
function Portfolio() {
    this.stocks = [];
}

/**
 * Adds a stock to the portfolio.
 * @param {Stock} stock - The stock to add.
 */
Portfolio.prototype.addStock = function(stock) {
    this.stocks.push(stock);
};

/**
 * Calculates the total value of the portfolio.
 * @returns {number} The total value of the portfolio.
 */
Portfolio.prototype.totalValue = function() {
    return this.stocks.reduce((total, stock) => total + stock.totalValue(), 0);
};



/**
 * Example usage of Portfolio and Stock classes.
 */
function exampleUsage() {
    const portfolio = new Portfolio();
    portfolio.addStock(new Stock('AAPL', 10, 150));
    portfolio.addStock(new Stock('GOOG', 5, 1200));
    portfolio.addStock(new Stock('MSFT', 8, 200));
    return portfolio;
}


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
Portfolio.prototype.calculateRisk = function() {
    const values = this.stocks.map(stock => stock.totalValue());
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
    return Math.sqrt(variance);
};

SUFFIX CODE:
----------------------------------------
const portfolio = exampleUsage();
assert.strictEqual(portfolio.totalValue(), 15000);
assert.strictEqual(Math.round(portfolio.calculateRisk()), 463);

console.log('All assertions passed.');


JUSTIFICATION:
----------------------------------------
This test case is effective because it involves realistic business logic related to financial portfolio management, including stock value calculations and risk assessment. The prefix contains a substantial amount of context and setup code, providing a comprehensive but incomplete implementation. The golden_completion section requires generating accurate documentation for the calculateRisk method, ensuring the LLM can translate complex code into detailed comments. The suffix includes different code that follows the completion, validating the functional requirements and edge cases with assertions. This tests both code-to-comment and comment-to-code translation capabilities.

ASSERTIONS:
----------------------------------------
const portfolio = exampleUsage();
const docString = Portfolio.prototype.calculateRisk.toString();
assert.strictEqual(portfolio.totalValue(), 15000);
assert.strictEqual(Math.round(portfolio.calculateRisk()), 463);
assert(docString.includes('Calculates the risk of the portfolio based on the standard deviation of stock prices.'));
assert(docString.includes('This is a simplified risk calculation and should be improved for real-world applications.'));
assert(docString.includes('returns {number} The calculated risk of the portfolio.'));
console.log('All assertions passed.');
================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');



LLM COMPLETION gpt-4.5-preview:
----------------------------------------
// No additional code needed here.

SUFFIX CODE:
----------------------------------------
class Portfolio {
  constructor(owner, assets) {
    this.owner = owner;
    this.assets = assets;
  }

  /**
   * Calculates the total value of the portfolio.
   * @param {Object} marketData - An object containing market prices for the assets.
   * @returns {number} The total value of the portfolio.
   */
  calculateTotalValue(marketData) {
    let totalValue = 0;
    for (const asset of this.assets) {
      if (marketData[asset.name]) {
        totalValue += asset.quantity * marketData[asset.name];
      }
    }
    return totalValue;
  }

  /**
   * Loads portfolio data from a JSON file.
   * @param {string} filePath - The path to the JSON file.
   * @returns {Portfolio} The loaded portfolio instance.
   */
  static loadFromFile(filePath) {
    const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    return new Portfolio(data.owner, data.assets);
  }
}

// Example usage of the Portfolio class
const portfolio = Portfolio.loadFromFile(path.join(__dirname, 'portfolio.json'));
const marketData = {
  'AAPL': 150.00,
  'GOOGL': 2800.00,
  'TSLA': 700.00
};
const totalValue = portfolio.calculateTotalValue(marketData);
console.log(`Total Portfolio Value: $${totalValue}`);
console.log('Portfolio loaded successfully');

JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic business logic scenario involving financial portfolio management, including methods for calculating the total value of a portfolio and loading portfolio data from a file. The documentation provided uses JSDoc to comprehensively describe the class, its methods, and their parameters and return values. This scenario tests the LLM's ability to accurately generate detailed documentation for complex code and verify that the documentation covers all important aspects of the implementation.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const docString = `/**
 * @class Portfolio
 * @description Represents a business entity for managing financial portfolios.
 * @param {string} owner - The owner of the portfolio.
 * @param {Array} assets - An array of asset objects.
 * 
 * @method calculateTotalValue
 * @description Calculates the total value of the portfolio.
 * @param {Object} marketData - An object containing market prices for the assets.
 * @returns {number} The total value of the portfolio.
 * 
 * @method loadFromFile
 * @description Loads portfolio data from a JSON file.
 * @param {string} filePath - The path to the JSON file.
 * @returns {Portfolio} The loaded portfolio instance.
 */`;
assert(docString.includes('@class Portfolio'));
assert(docString.includes('@description Represents a business entity for managing financial portfolios'));
assert(docString.includes('@param {string} owner'));
assert(docString.includes('@param {Array} assets'));
assert(docString.includes('@method calculateTotalValue'));
assert(docString.includes('@description Calculates the total value of the portfolio'));
assert(docString.includes('@param {Object} marketData'));
assert(docString.includes('@returns {number} The total value of the portfolio'));
assert(docString.includes('@method loadFromFile'));
assert(docString.includes('@description Loads portfolio data from a JSON file'));
assert(docString.includes('@param {string} filePath'));
assert(docString.includes('@returns {Portfolio} The loaded portfolio instance'));

================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * Function to calculate the risk score of a portfolio
 * based on the variance of returns.
 * 
 * @param {Array<number>} returns - Array of returns for the portfolio.
 * @returns {number} The calculated risk score.
 */
function calculateRiskScore(returns) {
    if (!Array.isArray(returns) || returns.length === 0) {
        throw new Error('Invalid input: returns should be a non-empty array');
    }

    const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
    const riskScore = Math.sqrt(variance);

    return riskScore;
}

// Example usage
const portfolioReturns = [0.05, 0.1, -0.02, 0.03, 0.07];
const riskScore = calculateRiskScore(portfolioReturns);
console.log('Risk Score:', riskScore);

// Assertions
assert.strictEqual(typeof riskScore, 'number');
assert(riskScore >= 0);

/**
 * Validates if the risk score is within acceptable limits.
 * 
 * @param {number} riskScore - The calculated risk score.
 * @param {number} threshold - The threshold for acceptable risk.
 * @returns {boolean} True if the risk score is within limits, otherwise false.
 * @throws {Error} If the riskScore or threshold are not numbers.
 */

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function validateRiskScore(riskScore, threshold) {
    if (typeof riskScore !== 'number' || typeof threshold !== 'number') {
        throw new Error('Invalid input: riskScore and threshold should be numbers');
    }
    return riskScore <= threshold;
}


SUFFIX CODE:
----------------------------------------
const isRiskAcceptable = validateRiskScore(riskScore, 0.1);
console.log('Is risk acceptable:', isRiskAcceptable);

// Assertions
assert.strictEqual(typeof isRiskAcceptable, 'boolean');
assert(isRiskAcceptable === true || isRiskAcceptable === false);

// Resource cleanup, if any


JUSTIFICATION:
----------------------------------------
This test case is a strong example because it includes a comprehensive implementation of a financial calculation (risk score) and a function to validate the calculated risk score. The task tests the LLM's ability to translate detailed function requirements from comments into executable code while maintaining clear error handling and parameter validation. The assertions ensure the code works correctly and handles edge cases, making it a realistic and practical scenario.

ASSERTIONS:
----------------------------------------
assert.strictEqual(typeof validateRiskScore, 'function');
assert.strictEqual(validateRiskScore(0.05, 0.1), true);
assert.throws(() => validateRiskScore('invalid', 0.1), /Invalid input/);
assert.throws(() => validateRiskScore(0.05, 'invalid'), /Invalid input/);

================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Reads a JSON file from the filesystem and parses its content.
 * @param {string} filePath - The path to the JSON file.
 * @returns {Object} The parsed JSON object.
 * @throws Will throw an error if the file does not exist or is not valid JSON.
 */
function readJsonFile(filePath) {
    if (!fs.existsSync(filePath)) {
        throw new Error(`File not found: ${filePath}`);
    }

    const fileContent = fs.readFileSync(filePath, 'utf8');
    try {
        return JSON.parse(fileContent);
    } catch (error) {
        throw new Error(`Invalid JSON format in file: ${filePath}`);
    }
}

/**
 * Writes an object to a JSON file on the filesystem.
 * @param {string} filePath - The path to the JSON file.
 * @param {Object} data - The data to write to the file.
 * @throws Will throw an error if the file cannot be written.
 */
function writeJsonFile(filePath, data) {
    const jsonString = JSON.stringify(data, null, 2);
    try {
        fs.writeFileSync(filePath, jsonString, 'utf8');
    } catch (error) {
        throw new Error(`Could not write file: ${filePath}`);
    }
}

/**
 * Updates a specific key in a JSON file.
 * @param {string} filePath - The path to the JSON file.
 * @param {string} key - The key to update.
 * @param {*} value - The new value for the key.
 * @throws Will throw an error if the file does not exist, is not valid JSON, or cannot be written.
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function updateJsonFile(filePath, key, value) {
    const data = readJsonFile(filePath);
    data[key] = value;
    writeJsonFile(filePath, data);
}

SUFFIX CODE:
----------------------------------------
// Updating the example JSON file
updateJsonFile(exampleFilePath, 'age', 31);

// Reading back the updated JSON file
const updatedData = readJsonFile(exampleFilePath);
console.log(updatedData); // { name: 'John Doe', age: 31 }

// Clean up by removing the example JSON file
fs.unlinkSync(exampleFilePath);

JUSTIFICATION:
----------------------------------------
This test case is a good example as it involves realistic file handling operations, including reading, writing, and updating JSON files on the filesystem. It demonstrates the need for comprehensive documentation and proper error handling. The prefix provides a complete context, including helper functions and example usage. The golden_completion requires translating a detailed comment into a specific function implementation, and the suffix verifies the correctness of the implementation. The assertions ensure that the function performs as expected, handles errors correctly, and that the JSON file operations succeed.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Check if the example file was created and updated correctly
const dataBeforeUpdate = readJsonFile(exampleFilePath);
assert.strictEqual(dataBeforeUpdate.age, 30);

updateJsonFile(exampleFilePath, 'age', 31);
const dataAfterUpdate = readJsonFile(exampleFilePath);
assert.strictEqual(dataAfterUpdate.age, 31);

// Clean up
fs.unlinkSync(exampleFilePath);
================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Utility function to read a JSON file and parse its content
 * @param {string} filePath - The path to the JSON file
 * @returns {object} - The parsed JSON object
 * @throws {Error} - If the file cannot be read or parsed
 */
function readJsonFile(filePath) {
    if (!fs.existsSync(filePath)) {
        throw new Error('File does not exist');
    }
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    try {
        return JSON.parse(fileContent);
    } catch (error) {
        throw new Error('Error parsing JSON');
    }
}

/**
 * Utility function to write an object to a JSON file
 * @param {string} filePath - The path to the JSON file
 * @param {object} data - The data to write to the file
 * @throws {Error} - If the file cannot be written
 */
function writeJsonFile(filePath, data) {
    try {
        const jsonString = JSON.stringify(data, null, 2);
        fs.writeFileSync(filePath, jsonString, 'utf-8');
    } catch (error) {
        throw new Error('Error writing JSON');
    }
}

// Example usage of readJsonFile and writeJsonFile functions
const exampleFilePath = path.join(__dirname, 'example.json');
const exampleData = { name: 'Test', value: 42 };
writeJsonFile(exampleFilePath, exampleData);
const readData = readJsonFile(exampleFilePath);
console.log(readData);

/**
 * Function to merge two JSON files into one
 * @param {string} sourceFilePath1 - The path to the first JSON file
 * @param {string} sourceFilePath2 - The path to the second JSON file
 * @param {string} destinationFilePath - The path to the destination JSON file
 * @returns {void}
 * @throws {Error} - If any of the files cannot be read or written
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function mergeJsonFiles(sourceFilePath1, sourceFilePath2, destinationFilePath) {
    const data1 = readJsonFile(sourceFilePath1);
    const data2 = readJsonFile(sourceFilePath2);
    const mergedData = { ...data1, ...data2 };
    writeJsonFile(destinationFilePath, mergedData);
}

SUFFIX CODE:
----------------------------------------
const sourceFilePath1 = path.join(__dirname, 'source1.json');
const sourceFilePath2 = path.join(__dirname, 'source2.json');
const destinationFilePath = path.join(__dirname, 'destination.json');

// Create example source files
writeJsonFile(sourceFilePath1, { key1: 'value1' });
writeJsonFile(sourceFilePath2, { key2: 'value2' });

// Merge the files
mergeJsonFiles(sourceFilePath1, sourceFilePath2, destinationFilePath);

// Read and verify the merged content
const mergedData = readJsonFile(destinationFilePath);
console.log(mergedData);

// Clean up the example files
fs.unlinkSync(exampleFilePath);
fs.unlinkSync(sourceFilePath1);
fs.unlinkSync(sourceFilePath2);
fs.unlinkSync(destinationFilePath);


JUSTIFICATION:
----------------------------------------
This example is a good test case because it involves a realistic scenario of reading, merging, and writing JSON files, which is common in many applications. The test case demonstrates the ability to correctly handle file operations, error handling, and merging data. The prefix establishes context by providing utility functions and example usage, while the golden completion requires implementing a function based on detailed comments. The suffix contains code that uses the completed function and performs cleanup, ensuring a comprehensive and realistic scenario. Assertions verify the functional requirements and correctness of the implementation.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const destinationFilePath = path.join(__dirname, 'destination.json');
const sourceFilePath1 = path.join(__dirname, 'source1.json');
const sourceFilePath2 = path.join(__dirname, 'source2.json');

// Create example source files
writeJsonFile(sourceFilePath1, { key1: 'value1' });
writeJsonFile(sourceFilePath2, { key2: 'value2' });

// Merge the files
mergeJsonFiles(sourceFilePath1, sourceFilePath2, destinationFilePath);

// Read and verify the merged content
const mergedData = readJsonFile(destinationFilePath);
assert.deepStrictEqual(mergedData, { key1: 'value1', key2: 'value2' });

================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { strict: assert } = require('assert');

/**
 * Represents a single financial transaction.
 * @typedef {Object} Transaction
 * @property {number} amount - The amount of the transaction.
 * @property {string} type - The type of the transaction ('credit' or 'debit').
 * @property {Date} date - The date of the transaction.
 */

/**
 * Calculate the net balance from an array of transactions.
 * @param {Transaction[]} transactions - An array of transactions.
 * @returns {number} The net balance.
 */
function calculateNetBalance(transactions) {
    let balance = 0;
    transactions.forEach(transaction => {
        if (transaction.type === 'credit') {
            balance += transaction.amount;
        } else if (transaction.type === 'debit') {
            balance -= transaction.amount;
        }
    });
    return balance;
}

/**
 * Check if the transactions comply with a specific policy.
 * The policy states that no transaction should exceed a specific amount.
 * @param {Transaction[]} transactions - An array of transactions.
 * @param {number} maxAmount - The maximum allowed transaction amount.
 * @returns {boolean} True if all transactions comply with the policy, false otherwise.
 */
function validateTransactionPolicy(transactions, maxAmount) {
    for (let transaction of transactions) {
        if (transaction.amount > maxAmount) {
            return false;
        }
    }
    return true;
}

// Sample transactions array
const transactions = [
    { amount: 100, type: 'credit', date: new Date('2023-01-01') },
    { amount: 50, type: 'debit', date: new Date('2023-01-02') },
    { amount: 200, type: 'credit', date: new Date('2023-01-03') },
];

/**
 * Calculate the average transaction amount for a given type.
 * @param {Transaction[]} transactions - An array of transactions.
 * @param {string} type - The type of transactions to include ('credit' or 'debit').
 * @returns {number} The average transaction amount for the specified type.
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function calculateAverageTransactionAmount(transactions, type) {
    const filteredTransactions = transactions.filter(transaction => transaction.type === type);
    if (filteredTransactions.length === 0) return 0;
    const totalAmount = filteredTransactions.reduce((sum, transaction) => sum + transaction.amount, 0);
    return totalAmount / filteredTransactions.length;
}

SUFFIX CODE:
----------------------------------------

// Validate that the transactions comply with a policy
const policyCompliant = validateTransactionPolicy(transactions, 150);
assert(policyCompliant === false);

// Calculate the net balance of the transactions
const netBalance = calculateNetBalance(transactions);
assert(netBalance === 250);

// Calculate the average credit transaction amount
const avgCreditAmount = calculateAverageTransactionAmount(transactions, 'credit');
assert(avgCreditAmount === 150);

console.log('All assertions passed.');


JUSTIFICATION:
----------------------------------------
This test case provides a comprehensive scenario for evaluating an LLM's ability to translate between code and documentation effectively. The prefix includes detailed JSDoc comments that describe the data structures and functions involved in financial transactions, while the golden completion requires the LLM to generate a function implementation based on provided documentation. The suffix includes assertions that test the correctness of the generated implementation, ensuring that it meets the functional requirements. This scenario is realistic and involves complex business logic, making it a good test case for bidirectional translation capabilities.

ASSERTIONS:
----------------------------------------
assert(typeof calculateAverageTransactionAmount === 'function');
assert(calculateAverageTransactionAmount.length === 2);
const testTransactions = [
    { amount: 100, type: 'credit', date: new Date('2023-01-01') },
    { amount: 200, type: 'credit', date: new Date('2023-01-02') },
    { amount: 300, type: 'debit', date: new Date('2023-01-03') },
];
assert(calculateAverageTransactionAmount(testTransactions, 'credit') === 150);
assert(calculateAverageTransactionAmount(testTransactions, 'debit') === 300);
assert(calculateAverageTransactionAmount(testTransactions, 'unknown') === 0);

================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * A utility function to calculate the annualized return of an investment portfolio.
 * @param {number} initialInvestment - The initial amount of money invested.
 * @param {number} finalValue - The value of the investment at the end of the period.
 * @param {number} years - The number of years the investment was held.
 * @returns {number} - The annualized return as a percentage.
 */
function calculateAnnualizedReturn(initialInvestment, finalValue, years) {
    // Check for valid input
    if (initialInvestment <= 0 || finalValue <= 0 || years <= 0) {
        throw new Error('Invalid input: All parameters must be greater than zero.');
    }

    // Calculate the annualized return
    const annualizedReturn = Math.pow(finalValue / initialInvestment, 1 / years) - 1;
    return annualizedReturn * 100;
}

/**
 * A function to calculate the risk of an investment portfolio based on standard deviation.
 * @param {Array<number>} returns - An array of historical return percentages.
 * @returns {number} - The standard deviation of the returns, representing risk.
 */
function calculatePortfolioRisk(returns) {
    if (returns.length === 0) {
        throw new Error('Invalid input: Returns array cannot be empty.');
    }

    const mean = returns.reduce((sum, r) => sum + r, 0) / returns.length;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
    return Math.sqrt(variance);
}

// Example usage:
const initialInvestment = 10000;
const finalValue = 15000;
const years = 5;
const returns = [0.1, 0.2, 0.15, -0.05, 0.1];



LLM COMPLETION gpt-4.5-preview:
----------------------------------------
const annualizedReturn = calculateAnnualizedReturn(initialInvestment, finalValue, years);
console.log('Annualized Return:', annualizedReturn);

SUFFIX CODE:
----------------------------------------
const risk = calculatePortfolioRisk(returns);
console.log('Portfolio Risk:', risk);

// Assertions
assert.strictEqual(calculateAnnualizedReturn(initialInvestment, finalValue, years), 8.447219295712571);
assert.strictEqual(Math.round(calculatePortfolioRisk(returns) * 100) / 100, 0.08);

// Resource cleanup if any
// (Not applicable in this scenario as no persistent resources are being held)


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to translate detailed natural language requirements into a correctly implemented JavaScript function. The prefix provides comprehensive context with existing functions and example usages, while the golden completion requires the LLM to implement a new function based on provided documentation. The suffix contains different code that does not repeat the golden completion, ensuring clear separation. The assertions verify the correctness of the implemented function and existing functions, making this a robust test case for bidirectional translation capabilities.

ASSERTIONS:
----------------------------------------
assert.strictEqual(calculateExpectedReturn(returns), 0.1);
assert.throws(() => calculateExpectedReturn([]), /Invalid input: Returns array cannot be empty./);
================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Function to read a JSON file and parse its content.
 * @param {string} filePath - The path to the JSON file.
 * @returns {Object} The parsed JSON content.
 * @throws Will throw an error if the file cannot be read or parsed.
 */
function readJsonFile(filePath) {
    if (!fs.existsSync(filePath)) {
        throw new Error(`File not found: ${filePath}`);
    }
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    try {
        return JSON.parse(fileContent);
    } catch (error) {
        throw new Error(`Error parsing JSON from file: ${filePath}`);
    }
}

/**
 * Function to write an object to a JSON file.
 * @param {string} filePath - The path to the JSON file.
 * @param {Object} data - The data to be written to the file.
 * @throws Will throw an error if the file cannot be written.
 */
function writeJsonFile(filePath, data) {
    try {
        const jsonData = JSON.stringify(data, null, 2);
        fs.writeFileSync(filePath, jsonData, 'utf-8');
    } catch (error) {
        throw new Error(`Error writing JSON to file: ${filePath}`);
    }
}

// Example usage
const exampleFilePath = path.join(__dirname, 'example.json');
const exampleData = { name: 'John Doe', age: 30, occupation: 'Software Developer' };

writeJsonFile(exampleFilePath, exampleData);
const readData = readJsonFile(exampleFilePath);
console.log(readData);

/**
 * Function to validate the structure of the read JSON data.
 * @param {Object} data - The JSON data to validate.
 * @returns {boolean} True if the structure is valid, false otherwise.
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function validateJsonStructure(data) {
    return data &&
        typeof data.name === 'string' &&
        typeof data.age === 'number' &&
        typeof data.occupation === 'string';
}

SUFFIX CODE:
----------------------------------------


fs.unlinkSync(exampleFilePath); // Cleanup the example file


JUSTIFICATION:
----------------------------------------
This example tests the ability of an LLM to translate between code and documentation in both directions. The prefix provides detailed documentation for reading and writing JSON files, setting the context for the function to validate the JSON structure. The golden completion requires the LLM to implement the function based on the provided documentation. This scenario is realistic as validating JSON structure is a common task in many applications.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const data = { name: 'Jane Doe', age: 25, occupation: 'Data Scientist' };
assert(validateJsonStructure(data) === true);
assert(validateJsonStructure({ name: 'Jane Doe' }) === false);
assert(validateJsonStructure(null) === false);
assert(validateJsonStructure('invalid data') === false);

================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Reads a JSON configuration file and returns the parsed object.
 * @param {string} configFilePath - The path to the configuration file.
 * @returns {Object} The parsed configuration object.
 * @throws Will throw an error if the file cannot be read or parsed.
 */
function readConfig(configFilePath) {
	if (!fs.existsSync(configFilePath)) {
		throw new Error(`Configuration file not found: ${configFilePath}`);
	}
	const rawData = fs.readFileSync(configFilePath);
	try {
		return JSON.parse(rawData);
	} catch (error) {
		throw new Error(`Error parsing configuration file: ${error.message}`);
	}
}

/**
 * Loads and validates the configuration from a file.
 * @param {string} configFilePath - The path to the configuration file.
 * @returns {Object} The validated configuration object.
 * @throws Will throw an error if the configuration is invalid.
 */
function loadConfig(configFilePath) {
	const config = readConfig(configFilePath);
	if (!validateConfig(config)) {
		throw new Error('Invalid configuration');
	}
	return config;
}

const configFilePath = path.join(__dirname, 'config.json');
let config;
try {
	config = loadConfig(configFilePath);
	console.log('Configuration loaded successfully:', config);
} catch (error) {
	console.error(error.message);
}

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
if (config) {
	console.log(`Connecting to database at ${config.host}:${config.port}, database name: ${config.database}`);
}

SUFFIX CODE:
----------------------------------------
console.log('Performing further operations with the config object...');
// Further operations that depend on the configuration object would go here
// Ensure to handle any operations that might depend on the config object availability

// Mocking the config file for testing purposes
const mockConfigPath = path.join(__dirname, 'mockConfig.json');
fs.writeFileSync(mockConfigPath, JSON.stringify({ host: 'localhost', port: 8080, database: 'testdb' }));

try {
	const mockConfig = loadConfig(mockConfigPath);
	assert.strictEqual(mockConfig.host, 'localhost');
	assert.strictEqual(mockConfig.port, 8080);
	assert.strictEqual(mockConfig.database, 'testdb');
	console.log('Mock configuration validated successfully');
} catch (error) {
	console.error('Mock configuration validation failed:', error.message);
} finally {
	fs.unlinkSync(mockConfigPath);
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic scenario of loading and validating a configuration file, which is common in many applications. The task requires the LLM to understand both code-to-comment and comment-to-code translation. The provided prefix includes detailed function implementations and error handling, which the LLM needs to document accurately. The golden completion requires the LLM to generate comprehensive documentation for an existing function. The suffix includes further operations and assertions to validate the configuration, ensuring all code runs correctly and the documentation is consistent with the implementation.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const docString = `/**
 * Validates the configuration object against the required schema.
 * @param {Object} config - The configuration object to validate.
 * @returns {boolean} True if the configuration is valid, otherwise false.
 */
function validateConfig(config) {
	if (!config) {
		return false;
	}
	const requiredFields = ['host', 'port', 'database'];
	for (const field of requiredFields) {
		if (!config.hasOwnProperty(field)) {
			return false;
		}
	}
	return true;
}
`;
assert(docString.toLowerCase().includes('validates the configuration object against the required schema'));
assert(docString.includes('@param {Object} config - The configuration object to validate'));
assert(docString.includes('@returns {boolean} True if the configuration is valid, otherwise false'));

================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Utility function to read JSON data from a file
 * @param {string} filePath - Path to the JSON file
 * @returns {Object} Parsed JSON data
 */
function readJsonFile(filePath) {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        throw new Error(`Error reading JSON file: ${error.message}`);
    }
}

/**
 * Utility function to write JSON data to a file
 * @param {string} filePath - Path to the JSON file
 * @param {Object} data - Data to write to the file
 */
function writeJsonFile(filePath, data) {
    try {
        const jsonData = JSON.stringify(data, null, 2);
        fs.writeFileSync(filePath, jsonData, 'utf8');
    } catch (error) {
        throw new Error(`Error writing JSON file: ${error.message}`);
    }
}

// Example usage
const filePath = path.join(__dirname, 'data.json');
const updatedData = updateJsonFile(filePath, 'name', 'New Name');
console.log('Updated Data:', updatedData);

// Additional function to validate updated JSON data
function validateUpdatedData(data, key, expectedValue) {
    return data[key] === expectedValue;
}

const isValid = validateUpdatedData(updatedData, 'name', 'New Name');
console.log('Validation Result:', isValid);
/**
 * Function to update a specific key-value pair in a JSON file
 * @param {string} filePath - Path to the JSON file
 * @param {string} key - Key to update
 * @param {*} value - New value for the key
 * @returns {Object} Updated JSON data
 * @throws Will throw an error if the file cannot be read or written
 * @example
 * // Update the 'name' key in the JSON file
 * const updatedData = updateJsonFile('path/to/file.json', 'name', 'New Name');
 * console.log(updatedData);
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function updateJsonFile(filePath, key, value) {
    const data = readJsonFile(filePath);
    data[key] = value;
    writeJsonFile(filePath, data);
    return data;
}

SUFFIX CODE:
----------------------------------------
const anotherUpdate = updateJsonFile(filePath, 'age', 30);
console.log('Another Update:', anotherUpdate);

const isAnotherValid = validateUpdatedData(anotherUpdate, 'age', 30);
console.log('Another Validation Result:', isAnotherValid);

// Clean up: Remove the test file after validation
fs.unlinkSync(filePath);

JUSTIFICATION:
----------------------------------------
This test case is a good example of bidirectional translation between JavaScript code and natural language documentation. It includes a realistic scenario involving file operations and JSON data manipulation, which are common in business logic. The documentation provided in the golden_completion is comprehensive, covering parameters, return values, and usage examples. The assertions check for functional correctness and validate that the documentation includes key terms and sections.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Check that documentation includes key terms and sections
const docString = `/**
 * Function to update a specific key-value pair in a JSON file
 * @param {string} filePath - Path to the JSON file
 * @param {string} key - Key to update
 * @param {*} value - New value for the key
 * @returns {Object} Updated JSON data
 * @throws Will throw an error if the file cannot be read or written
 * @example
 * // Update the 'name' key in the JSON file
 * const updatedData = updateJsonFile('path/to/file.json', 'name', 'New Name');
 * console.log(updatedData);
 */`;

assert(docString.toLowerCase().includes('function to update a specific key-value pair in a json file'));
assert(docString.includes('@param {string} filePath'));
assert(docString.includes('@returns {Object} Updated JSON data'));
assert(docString.includes('@throws Will throw an error if the file cannot be read or written'));
assert(docString.includes('@example'));

// Check functional correctness
const testFilePath = path.join(__dirname, 'test_data.json');
fs.writeFileSync(testFilePath, JSON.stringify({ name: 'Old Name', age: 25 }, null, 2), 'utf8');

const testUpdatedData = updateJsonFile(testFilePath, 'name', 'Test Name');
assert.strictEqual(testUpdatedData.name, 'Test Name');

const testIsValid = validateUpdatedData(testUpdatedData, 'name', 'Test Name');
assert.strictEqual(testIsValid, true);

// Clean up: Remove the test file
fs.unlinkSync(testFilePath);
================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Function to read a JSON file and parse its content
 * @param {string} filePath - Path to the JSON file
 * @returns {Object} Parsed JSON content
 * @throws Will throw an error if the file cannot be read or parsed
 */
function readJsonFile(filePath) {
    if (!fs.existsSync(filePath)) {
        throw new Error('File does not exist');
    }
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    try {
        return JSON.parse(fileContent);
    } catch (error) {
        throw new Error('Failed to parse JSON');
    }
}

/**
 * Function to write an object to a JSON file
 * @param {string} filePath - Path to the JSON file
 * @param {Object} data - Data to be written to the file
 * @throws Will throw an error if the file cannot be written
 */
function writeJsonFile(filePath, data) {
    const jsonData = JSON.stringify(data, null, 2);
    try {
        fs.writeFileSync(filePath, jsonData, 'utf-8');
    } catch (error) {
        throw new Error('Failed to write JSON');
    }
}

/**
 * Function to update a specific key-value pair in a JSON file
 * @param {string} filePath - Path to the JSON file
 * @param {string} key - Key to be updated
 * @param {any} value - New value for the key
 * @throws Will throw an error if the file cannot be read, parsed, or written
 */
function updateJsonFile(filePath, key, value) {
    const data = readJsonFile(filePath);
    data[key] = value;
    writeJsonFile(filePath, data);
}

// Example usage:
const filePath = path.join(__dirname, 'example.json');
const key = 'name';
const value = 'Updated Name';

try {
    updateJsonFile(filePath, key, value);
    console.log('File updated successfully');
} catch (error) {
    console.error('Error updating file:', error.message);
}


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
fs.unlinkSync(filePath);

SUFFIX CODE:
----------------------------------------
fs.unlinkSync(filePath);

JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic scenario involving file operations with JSON data. It tests the LLM's ability to generate documentation for existing code (code-to-comment) and to implement code from given documentation (comment-to-code). The scenario includes error handling, file reading/writing, and data manipulation, making it a comprehensive test for translation capabilities.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Check if function deleteJsonFile is documented correctly
const functionString = deleteJsonFile.toString();
const docString = `/**
 * Function to delete a JSON file
 * @param {string} filePath - Path to the JSON file to be deleted
 * @throws Will throw an error if the file cannot be deleted
 */`;
assert(functionString.includes(docString), 'Documentation for deleteJsonFile function is incomplete or incorrect');

// Validate that the deleteJsonFile function works as expected
const testFilePath = path.join(__dirname, 'test.json');
fs.writeFileSync(testFilePath, JSON.stringify({ test: 'data' }), 'utf-8');
assert(fs.existsSync(testFilePath), 'Test file should exist before deletion');
deleteJsonFile(testFilePath);
assert(!fs.existsSync(testFilePath), 'Test file should be deleted');
================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

/**
 * Reads a JSON file and parses its content.
 * @param {string} filePath - The path to the JSON file.
 * @returns {object} - The parsed JSON content.
 * @throws {Error} - Throws an error if the file cannot be read or parsed.
 */
function readJsonFile(filePath) {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        throw new Error('Failed to read or parse JSON file: ' + error.message);
    }
}

/**
 * Validates the structure of a user object.
 * @param {object} user - The user object to validate.
 * @param {string} user.name - The name of the user.
 * @param {number} user.age - The age of the user.
 * @param {string} user.email - The email of the user.
 * @returns {boolean} - Returns true if the user object is valid, otherwise false.
 */
function validateUser(user) {
    if (typeof user.name !== 'string' || user.name.length === 0) {
        return false;
    }
    if (typeof user.age !== 'number' || user.age <= 0) {
        return false;
    }
    if (typeof user.email !== 'string' || !user.email.includes('@')) {
        return false;
    }
    return true;
}

/**
 * Processes a list of users by validating and transforming their data.
 * @param {Array<object>} users - The list of users to process.
 * @returns {Array<object>} - The list of valid users with transformed data.
 */
function processUsers(users) {
    return users.filter(validateUser).map(user => ({
        ...user,
        name: user.name.toUpperCase(),
        email: user.email.toLowerCase(),
    }));
}

// Example usage of the above functions
const users = [
    { name: 'Alice', age: 25, email: 'alice@example.com' },
    { name: 'Bob', age: -1, email: 'bobexample.com' },
    { name: 'Charlie', age: 30, email: 'charlie@example.com' },
];
const validUsers = processUsers(users);
console.log(validUsers);


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
fs.writeFileSync('validUsers.json', JSON.stringify(validUsers, null, 2), 'utf8');

SUFFIX CODE:
----------------------------------------

// Further processing with validUsers
console.log('Number of valid users:', validUsers.length);


JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic scenario of fetching and processing user data from a remote API, validating and transforming the data, and handling potential errors. It tests the model's ability to translate between code and comprehensive documentation, including parameter descriptions, return values, and error handling. The assertions verify both the documentation's accuracy and the code's functionality, ensuring a robust and meaningful evaluation of the model's capabilities.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
    const mockFetch = async (url) => {
        if (url === 'https://api.example.com/users') {
            return { ok: true, json: async () => [
                { name: 'Dave', age: 20, email: 'dave@example.com' },
                { name: 'Eve', age: 22, email: 'eve@example.com' },
                { name: 'Frank', age: -1, email: 'frankexample.com' }
            ]};
        } else {
            return { ok: false };
        }
    };

    global.fetch = mockFetch;

    const apiUrl = 'https://api.example.com/users';
    const processedUsers = await fetchAndProcessUsers(apiUrl);

    assert(Array.isArray(processedUsers), 'processedUsers should be an array');
    assert.strictEqual(processedUsers.length, 2, 'There should be 2 valid users');
    assert.strictEqual(processedUsers[0].name, 'DAVE', 'User name should be uppercase');
    assert.strictEqual(processedUsers[0].email, 'dave@example.com', 'User email should be lowercase');

    console.log('All assertions passed');
})();

================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Represents a user in the business domain.
 * @typedef {Object} User
 * @property {string} id - Unique identifier for the user.
 * @property {string} name - Name of the user.
 * @property {string} email - Email address of the user.
 */

/**
 * Load users from a JSON file.
 * @param {string} filePath - Path to the JSON file containing user data.
 * @returns {Promise<User[]>} - A promise that resolves with the list of users.
 */
async function loadUsers(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                return reject(err);
            }
            try {
                const users = JSON.parse(data);
                resolve(users);
            } catch (parseErr) {
                reject(parseErr);
            }
        });
    });
}

/**
 * Validate email format.
 * @param {string} email - Email address to validate.
 * @returns {boolean} - True if the email format is valid, false otherwise.
 */
function validateEmail(email) {
    const emailRegex = /^[\w-\.]+@[\w-]+\.[a-z]{2,4}$/i;
    return emailRegex.test(email);
}

/**
 * Validate user data.
 * @param {User} user - User object to validate.
 * @returns {boolean} - True if the user data is valid, false otherwise.
 */
function validateUser(user) {
    if (!user.id || !user.name || !user.email) {
        return false;
    }
    return validateEmail(user.email);
}

/**
 * Filter users based on a validation function.
 * @param {User[]} users - List of users to filter.
 * @param {(user: User) => boolean} validationFn - Validation function to apply to each user.
 * @returns {User[]} - List of users that pass the validation function.
 */
function filterUsers(users, validationFn) {
    return users.filter(validationFn);
}

// Example usage
const filePath = path.join(__dirname, 'users.json');

loadUsers(filePath)
    .then(users => {
        const validUsers = filterUsers(users, validateUser);
        console.log('Valid users:', validUsers);
    })
    .catch(err => {
        console.error('Error loading users:', err);
    });

/**
 * Save valid users to a JSON file.
 * @param {string} filePath - Path to the JSON file to save user data.
 * @param {User[]} users - List of users to save.
 * @returns {Promise<void>} - A promise that resolves when the file has been saved.
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function saveValidUsers(filePath, users) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, JSON.stringify(users, null, 2), 'utf8', (err) => {
            if (err) {
                return reject(err);
            }
            resolve();
        });
    });
}

SUFFIX CODE:
----------------------------------------


// Example usage
const validUsersFilePath = path.join(__dirname, 'valid_users.json');

loadUsers(filePath)
    .then(users => {
        const validUsers = filterUsers(users, validateUser);
        return saveValidUsers(validUsersFilePath, validUsers);
    })
    .then(() => {
        console.log('Valid users saved successfully.');
    })
    .catch(err => {
        console.error('Error:', err);
    });


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to translate between code and documentation effectively. The prefix sets up a comprehensive context with multiple functions and detailed JSDoc comments, demonstrating business logic related to user data management. The golden completion involves generating documentation for the provided function implementation, ensuring the LLM can accurately describe the function's behavior, parameters, and return values. The assertions verify the completeness and accuracy of the generated documentation.

ASSERTIONS:
----------------------------------------
const { strict: assert } = require('assert');
const fs = require('fs');

// Extract documentation string for the saveValidUsers function
const docString = `/**
 * Save valid users to a JSON file.
 * @param {string} filePath - Path to the JSON file to save user data.
 * @param {User[]} users - List of users to save.
 * @returns {Promise<void>} - A promise that resolves when the file has been saved.
 */
async function saveValidUsers(filePath, users) {
    return new Promise((resolve, reject) => {
        const data = JSON.stringify(users, null, 2);
        fs.writeFile(filePath, data, 'utf8', (err) => {
            if (err) {
                return reject(err);
            }
            resolve();
        });
    });
}`;

// Assertions to verify the documentation
assert(docString.includes('Save valid users to a JSON file.'));
assert(docString.includes('@param {string} filePath'));
assert(docString.includes('@param {User[]} users'));
assert(docString.includes('@returns {Promise<void>}'));
assert(docString.includes('when the file has been saved.'));

================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Utility function to read JSON file
 * @param {string} filePath - Path to the JSON file
 * @returns {Object} - Parsed JSON object
 */
function readJSONFile(filePath) {
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
}

/**
 * Function to transform raw user data into standardized format
 * @param {Object} rawData - The raw user data from the source
 * @returns {Object} - Transformed user data
 */
function transformUserData(rawData) {
    return {
        id: rawData.userId,
        name: `${rawData.firstName} ${rawData.lastName}`,
        email: rawData.email,
        address: {
            street: rawData.street,
            city: rawData.city,
            postalCode: rawData.zipCode
        }
    };
}

/**
 * Main function to orchestrate ETL process for user data
 * @param {string} inputDir - Directory containing raw data files
 * @param {string} outputDir - Directory to store transformed data files
 */
function processUserData(inputDir, outputDir) {
    const files = fs.readdirSync(inputDir);
    files.forEach(file => {
        const filePath = path.join(inputDir, file);
        const rawData = readJSONFile(filePath);
        const transformedData = transformUserData(rawData);
        const outputFilePath = path.join(outputDir, file);
        fs.writeFileSync(outputFilePath, JSON.stringify(transformedData, null, 2));
    });
}

// Example usage
const inputDirectory = './input';
const outputDirectory = './output';
processUserData(inputDirectory, outputDirectory);
/**
 * Function to validate the transformed user data
 * @param {Object} transformedData - The transformed user data to validate
 * @throws {Error} If any of the required fields are missing or invalid
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function validateTransformedData(transformedData) {
    if (!transformedData.id || typeof transformedData.id !== 'string') {
        throw new Error('Invalid or missing id');
    }
    if (!transformedData.name || typeof transformedData.name !== 'string') {
        throw new Error('Invalid or missing name');
    }
    if (!transformedData.email || typeof transformedData.email !== 'string') {
        throw new Error('Invalid or missing email');
    }
    if (!transformedData.address || typeof transformedData.address !== 'object') {
        throw new Error('Invalid or missing address');
    }
    const { street, city, postalCode } = transformedData.address;
    if (!street || typeof street !== 'string') {
        throw new Error('Invalid or missing street');
    }
    if (!city || typeof city !== 'string') {
        throw new Error('Invalid or missing city');
    }
    if (!postalCode || typeof postalCode !== 'string') {
        throw new Error('Invalid or missing postalCode');
    }
}

SUFFIX CODE:
----------------------------------------


// Example validation
const exampleTransformedData = {
    id: '12345',
    name: 'John Doe',
    email: 'john.doe@example.com',
    address: {
        street: '123 Elm St',
        city: 'Somewhere',
        postalCode: '12345'
    }
};
validateTransformedData(exampleTransformedData);


JUSTIFICATION:
----------------------------------------
This test case is a comprehensive example demonstrating the bidirectional translation capability between code and natural language. It includes a realistic business logic scenario involving data transformation and validation. The prefix provides a substantial amount of context and setup code, which is necessary to understand the overall ETL process. The golden completion focuses on generating detailed documentation for the validation function, ensuring it meets the required standards. The suffix contains additional code that further validates the transformed data, ensuring that the example is both realistic and robust. The assertions provided will check for the accuracy and completeness of the documentation generated, making it an effective test case for evaluating the capabilities of an LLM in translating between code and natural language.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const docString = `/**
 * Function to validate the transformed user data
 * @param {Object} transformedData - The transformed user data to validate
 * @throws {Error} If any of the required fields are missing or invalid
 */
function validateTransformedData(transformedData) {
    if (!transformedData.id || typeof transformedData.id !== 'string') {
        throw new Error('Invalid or missing user ID');
    }
    if (!transformedData.name || typeof transformedData.name !== 'string') {
        throw new Error('Invalid or missing user name');
    }
    if (!transformedData.email || typeof transformedData.email !== 'string') {
        throw new Error('Invalid or missing user email');
    }
    if (!transformedData.address || typeof transformedData.address !== 'object') {
        throw new Error('Invalid or missing address');
    }
    if (!transformedData.address.street || typeof transformedData.address.street !== 'string') {
        throw new Error('Invalid or missing street');
    }
    if (!transformedData.address.city || typeof transformedData.address.city !== 'string') {
        throw new Error('Invalid or missing city');
    }
    if (!transformedData.address.postalCode || typeof transformedData.address.postalCode !== 'string') {
        throw new Error('Invalid or missing postal code');
    }
}
`;
assert(docString.toLowerCase().includes('validate the transformed user data'));
assert(docString.includes('@param {Object} transformedData'));
assert(docString.includes('@throws {Error} If any of the required fields are missing or invalid'));

================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');

/**
 * Utility function to log errors in a standardized format
 * @param {Error} error - The error object to log
 */
function logError(error) {
    console.error(`[ERROR] ${error.message}`);
}

/**
 * Fetches user data from an external API and processes it
 * @param {string} userId - The ID of the user to fetch data for
 * @returns {Promise<object>} - A promise that resolves to the processed user data
 */
async function fetchAndProcessUserData(userId) {
    try {
        const response = await axios.get(`https://api.example.com/users/${userId}`);
        const userData = response.data;
        
        // Check if the user data is valid
        if (!userData || !userData.id) {
            throw new Error('Invalid user data received');
        }

        // Process user data (e.g., normalize fields)
        const processedData = {
            id: userData.id,
            name: userData.name.trim(),
            email: userData.email.toLowerCase(),
            registeredAt: new Date(userData.registeredAt)
        };

        return processedData;
    } catch (error) {
        logError(error);
        throw error; // Re-throw the error after logging
    }
}

/**
 * Main function to handle user data fetching and processing
 * @param {string[]} userIds - Array of user IDs to process
 * @returns {Promise<object[]>} - A promise that resolves to an array of processed user data
 */
async function handleUserData(userIds) {
    const results = [];
    for (const userId of userIds) {
        try {
            const userData = await fetchAndProcessUserData(userId);
            results.push(userData);
        } catch (error) {
            console.log(`Failed to process user with ID: ${userId}`);
        }
    }
    return results;
}

// Example usage
(async () => {
    const userIds = ['123', '456', '789'];
    const processedUsers = await handleUserData(userIds);
    console.log(processedUsers);
})();

// Function to clear the cache
/**
 * Clears the cache for the given key
 * @param {string} key - The cache key to clear
 */
function clearCache(key) {
    // Cache clearing logic (mock implementation)
    console.log(`Cache cleared for key: ${key}`);
}

// Error handling strategy
/**
 * Handles errors by logging and optionally alerting
 * @param {Error} error - The error to handle
 */
function handleError(error) {
    logError(error);
    // Additional error handling logic (e.g., alerting)
}
/**
 * Validates the user data based on business rules
 * @param {object} userData - The user data to validate
 * @returns {boolean} - True if the user data is valid, otherwise false
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function validateUserData(userData) {
    if (!userData) return false;
    if (typeof userData.id !== 'string' || userData.id.trim() === '') return false;
    if (typeof userData.name !== 'string' || userData.name.trim() === '') return false;
    if (typeof userData.email !== 'string' || !userData.email.includes('@')) return false;
    if (isNaN(Date.parse(userData.registeredAt))) return false;
    return true;
}

SUFFIX CODE:
----------------------------------------

/**
 * Refreshes the cache by fetching new data and updating the cache
 * @param {string} key - The cache key to refresh
 * @param {Function} fetchData - Function to fetch new data
 * @returns {Promise<void>} - A promise that resolves when the cache is refreshed
 */
async function refreshCache(key, fetchData) {
    try {
        const newData = await fetchData();
        // Update cache logic (mock implementation)
        console.log(`Cache updated for key: ${key}`);
    } catch (error) {
        handleError(error);
    }
}

// Example usage of refreshCache
(async () => {
    const fetchData = async () => ({ data: 'new data' });
    await refreshCache('user_data', fetchData);
})();


JUSTIFICATION:
----------------------------------------
This test case provides a realistic scenario involving a common task in business logic: validating user data based on business rules. The prefix includes substantial setup code with various functions and usage examples, establishing the context for the validation function. The golden completion requires generating a function to validate user data, which tests the LLM's ability to understand and implement business rules. The suffix continues with additional functionality, ensuring a clear distinction from the golden completion. The assertions verify the correctness of the validation logic and cover both valid and invalid cases, ensuring comprehensive testing.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

const sampleUserData = { name: 'John Doe', email: 'john@example.com' };
const invalidUserData = { name: '', email: 'invalid-email' };

assert(validateUserData(sampleUserData) === true, 'Validation failed for valid user data');
assert(validateUserData(invalidUserData) === false, 'Validation passed for invalid user data');

================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Represents a business entity for managing user accounts.
 */
class UserAccount {
    /**
     * Creates a new user account.
     * @param {string} username - The username of the account.
     * @param {string} email - The email address of the user.
     */
    constructor(username, email) {
        this.username = username;
        this.email = email;
        this.createdAt = new Date();
        this.isActive = true;
    }

    /**
     * Deactivates the user account.
     */
    deactivate() {
        this.isActive = false;
    }
}

/**
 * Loads user accounts from a JSON file.
 * @param {string} filePath - The path to the JSON file.
 * @returns {UserAccount[]} An array of loaded user accounts.
 */
function loadUserAccounts(filePath) {
    const data = fs.readFileSync(filePath, 'utf8');
    const accounts = JSON.parse(data);
    return accounts.map(account => new UserAccount(account.username, account.email));
}

/**
 * Saves user accounts to a JSON file.
 * @param {string} filePath - The path to the JSON file.
 * @param {UserAccount[]} accounts - The array of user accounts to save.
 */
function saveUserAccounts(filePath, accounts) {
    const data = JSON.stringify(accounts, null, 2);
    fs.writeFileSync(filePath, data, 'utf8');
}

/**
 * Updates the email of a user account.
 * @param {UserAccount} account - The user account to update.
 * @param {string} newEmail - The new email address.
 */
function updateEmail(account, newEmail) {
    account.email = newEmail;
}

/**
 * Deletes a user account.
 * @param {string} username - The username of the account to delete.
 * @param {UserAccount[]} accounts - The array of user accounts.
 * @returns {boolean} True if the account was found and deleted, false otherwise.
 */
function deleteUserAccount(username, accounts) {
    const index = accounts.findIndex(account => account.username === username);
    if (index !== -1) {
        accounts.splice(index, 1);
        return true;
    }
    return false;
}

// Usage example
const accountsFilePath = path.join(__dirname, 'user_accounts.json');
const accounts = loadUserAccounts(accountsFilePath);


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function addUserAccount(account, accounts) {
    accounts.push(account);
}

SUFFIX CODE:
----------------------------------------

// Add a new account
const newAccount = new UserAccount('newuser', 'newuser@example.com');
addUserAccount(newAccount, accounts);
assert(accounts.includes(newAccount), 'New account should be added to accounts array');
saveUserAccounts(accountsFilePath, accounts);

// Assertions to verify the correctness of the documentation and code
const assert = require('assert');

// Check if the accounts array is loaded correctly
assert(Array.isArray(accounts), 'Accounts should be an array');
assert(accounts.length > 0, 'Accounts array should not be empty');
assert(accounts[0] instanceof UserAccount, 'Accounts should contain instances of UserAccount');

// Test updating an email
const testAccount = accounts[0];
const newEmail = 'newemail@example.com';
updateEmail(testAccount, newEmail);
assert.strictEqual(testAccount.email, newEmail, 'Email should be updated correctly');

// Test deleting an account
const initialLength = accounts.length;
const deleteResult = deleteUserAccount(testAccount.username, accounts);
assert.strictEqual(deleteResult, true, 'Account should be deleted');
assert.strictEqual(accounts.length, initialLength - 1, 'Accounts array length should decrease by 1');

// Cleanup (if needed)
// No actual cleanup needed as this is an in-memory operation example


JUSTIFICATION:
----------------------------------------
This test case is a good example for evaluating bidirectional translation between code and natural language because it includes a comprehensive setup with business logic for managing user accounts, along with detailed JSDoc comments. The prefix provides extensive context with multiple functions and a class definition, which helps in establishing the relationship between code and comments. The golden completion requires generating a new function and corresponding JSDoc comments, ensuring that the LLM can accurately translate between natural language and code. The assertions verify the correctness of the implementation and the documentation, ensuring that both the code and comments are accurate and complete.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Adds a new user account.
 * @param {UserAccount} account - The user account to add.
 * @param {UserAccount[]} accounts - The array of user accounts.
 */`;
assert(docString.toLowerCase().includes('adds a new user account'), 'Documentation should describe the function purpose');
assert(docString.includes('Parameters:'), 'Documentation should include parameters section');
assert(docString.includes('@param {UserAccount} account'), 'Documentation should describe the account parameter');
assert(docString.includes('@param {UserAccount[]} accounts'), 'Documentation should describe the accounts parameter');

================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Read JSON data from a file and parse it.
 * @param {string} filePath - The path to the JSON file.
 * @returns {Object} The parsed JSON data.
 * @throws {Error} If the file does not exist or cannot be read.
 */
function readJsonFile(filePath) {
    const absolutePath = path.resolve(filePath);
    if (!fs.existsSync(absolutePath)) {
        throw new Error(`File not found: ${absolutePath}`);
    }
    const fileContent = fs.readFileSync(absolutePath, 'utf8');
    return JSON.parse(fileContent);
}

/**
 * Validate the structure of a user object.
 * @param {Object} user - The user object to validate.
 * @param {string} user.name - The name of the user.
 * @param {number} user.age - The age of the user.
 * @param {string} user.email - The email of the user.
 * @returns {boolean} True if the user object is valid, otherwise false.
 */
function validateUser(user) {
    if (typeof user.name !== 'string' || user.name.length === 0) {
        return false;
    }
    if (typeof user.age !== 'number' || user.age < 0) {
        return false;
    }
    if (typeof user.email !== 'string' || !user.email.includes('@')) {
        return false;
    }
    return true;
}

/**
 * Process and clean user data from a JSON file.
 * @param {string} inputFilePath - The path to the input JSON file.
 * @param {string} outputFilePath - The path to the output JSON file.
 * @returns {Object[]} The array of valid user objects.
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function processUserData(inputFilePath, outputFilePath) {
    const users = readJsonFile(inputFilePath);
    const validUsers = users.filter(validateUser);
    fs.writeFileSync(outputFilePath, JSON.stringify(validUsers, null, 2), 'utf8');
    return validUsers;
}


SUFFIX CODE:
----------------------------------------
module.exports = { readJsonFile, validateUser, processUserData };

const assert = require('assert');
const mock = require('mock-fs');

// Mock file system for testing
mock({
    'input.json': JSON.stringify([
        { "name": "Alice", "age": 30, "email": "alice@example.com" },
        { "name": "Bob", "age": -5, "email": "bob@example" },
        { "name": "Charlie", "age": 25, "email": "charlie@example.com" }
    ]),
    'output.json': ''
});

// Test processUserData function
const validUsers = processUserData('input.json', 'output.json');
assert.strictEqual(validUsers.length, 2);
assert.strictEqual(validUsers[0].name, 'Alice');
assert.strictEqual(validUsers[1].name, 'Charlie');

// Clean up mock file system
mock.restore();


JUSTIFICATION:
----------------------------------------
This test case is a realistic scenario involving data processing and validation, which is common in business logic. The prefix provides a comprehensive setup, including utility functions and a detailed description of the task. The golden completion is focused on translating comments to code, ensuring the implementation matches the documented requirements. The suffix contains different code that tests the functionality, ensuring that the assertions validate the correctness of the implementation. This scenario effectively tests the LLM's ability to generate accurate documentation and implement code based on detailed comments.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Process and clean user data from a JSON file.
 * @param {string} inputFilePath - The path to the input JSON file.
 * @param {string} outputFilePath - The path to the output JSON file.
 * @returns {Object[]} The array of valid user objects.
 * @throws {Error} If the input file does not exist or cannot be read.
 */`;
assert(docString.toLowerCase().includes('user data'));
assert(docString.includes('Parameters:'));
assert(docString.includes('inputFilePath'));
assert(docString.includes('outputFilePath'));
assert(docString.includes('returns'));
assert(docString.includes('throws'));
================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Utility function to read a JSON file and parse its content.
 * @param {string} filePath - The path to the JSON file.
 * @returns {Object} The parsed JSON object.
 * @throws Will throw an error if the file cannot be read or the content is not valid JSON.
 */
function readJsonFile(filePath) {
    try {
        const data = fs.readFileSync(filePath, 'utf8');
        return JSON.parse(data);
    } catch (err) {
        throw new Error('Error reading or parsing JSON file: ' + err.message);
    }
}

/**
 * Business rule validation function to check if a user is eligible for a discount.
 * @param {Object} user - The user object containing user details.
 * @param {number} user.age - The age of the user.
 * @param {boolean} user.isMember - Whether the user is a member.
 * @returns {boolean} True if the user is eligible for a discount, false otherwise.
 */
function isEligibleForDiscount(user) {
    if (user.age >= 65 || user.isMember) {
        return true;
    }
    return false;
}

// Example usage:
const user1 = { age: 70, isMember: false };
const user2 = { age: 30, isMember: true };
const user3 = { age: 30, isMember: false };

console.log(isEligibleForDiscount(user1)); // true
console.log(isEligibleForDiscount(user2)); // true
console.log(isEligibleForDiscount(user3)); // false

/**
 * Function to validate a JSON configuration file against a schema.
 * @param {Object} config - The configuration object.
 * @returns {boolean} True if the configuration is valid, false otherwise.
 * @throws Will throw an error if the configuration is invalid.
 */
function validateConfig(config) {
    if (!config.name || typeof config.name !== 'string') {
        throw new Error('Invalid configuration: name is required and must be a string');
    }
    if (!config.version || typeof config.version !== 'string') {
        throw new Error('Invalid configuration: version is required and must be a string');
    }
    if (!config.settings || typeof config.settings !== 'object') {
        throw new Error('Invalid configuration: settings is required and must be an object');
    }
    return true;
}

// Example usage:
const config = {
    name: 'SampleApp',
    version: '1.0.0',
    settings: {
        theme: 'dark',
        notifications: true
    }
};

try {
    validateConfig(config);
    console.log('Configuration is valid');
} catch (err) {
    console.error(err.message);
}

// Add new functionality to handle dynamic feature flags
/**
 * Function to check if a feature is enabled based on user roles and configuration.
 * @param {string} featureName - The name of the feature to check.
 * @param {Object} user - The user object containing user details.
 * @param {Array<string>} user.roles - The roles assigned to the user.
 * @param {Object} config - The configuration object containing feature flags.
 * @returns {boolean} True if the feature is enabled for the user, false otherwise.
 */


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
function isFeatureEnabled(featureName, user, config) {
    const allowedRoles = config.featureFlags[featureName];
    if (!allowedRoles) return false;
    return user.roles.some(role => allowedRoles.includes(role));
}

SUFFIX CODE:
----------------------------------------
const configWithFeatures = {
    featureFlags: {
        newDashboard: ['admin', 'manager'],
        betaFeature: ['betaTester', 'admin']
    }
};

// Example usage:
const user4 = { roles: ['admin', 'user'] };
const user5 = { roles: ['user'] };

console.log(isFeatureEnabled('newDashboard', user4, configWithFeatures)); // true
console.log(isFeatureEnabled('newDashboard', user5, configWithFeatures)); // false
console.log(isFeatureEnabled('betaFeature', user4, configWithFeatures)); // true
console.log(isFeatureEnabled('betaFeature', user5, configWithFeatures)); // false


JUSTIFICATION:
----------------------------------------
This test case is a good example of bidirectional translation between code and natural language as it involves complex business logic with feature flags and user roles. The provided documentation in the prefix is comprehensive, and the implementation details for checking feature flags based on user roles are realistic and relevant to modern applications. The golden completion demonstrates generating accurate code from detailed documentation. The assertions validate the functionality and correctness of the implementation, ensuring the code performs as expected in various scenarios.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const user4 = { roles: ['admin', 'user'] };
const user5 = { roles: ['user'] };
const configWithFeatures = {
    featureFlags: {
        newDashboard: ['admin', 'manager'],
        betaFeature: ['betaTester', 'admin']
    }
};

assert.strictEqual(isFeatureEnabled('newDashboard', user4, configWithFeatures), true);
assert.strictEqual(isFeatureEnabled('newDashboard', user5, configWithFeatures), false);
assert.strictEqual(isFeatureEnabled('betaFeature', user4, configWithFeatures), true);
assert.strictEqual(isFeatureEnabled('betaFeature', user5, configWithFeatures), false);

================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');

/**
 * Function to fetch user data from an API and filter active users
 * @param {string} apiUrl - The URL of the API endpoint
 * @param {number} minAge - The minimum age of active users to filter
 * @returns {Promise<Array>} - A promise that resolves to an array of active users
 * @throws {Error} - Throws error if the API request fails
 */
async function fetchActiveUsers(apiUrl, minAge) {
    try {
        const response = await axios.get(apiUrl);
        const users = response.data;
        return users.filter(user => user.active && user.age >= minAge);
    } catch (error) {
        throw new Error('Failed to fetch data from API');
    }
}

// Example usage
const apiUrl = 'https://example.com/api/users';
const minAge = 18;
fetchActiveUsers(apiUrl, minAge)
    .then(activeUsers => {
        console.log('Active Users:', activeUsers);
    })
    .catch(error => {
        console.error(error.message);
    });

/**
 * Function to calculate the average age of users
 * @param {Array} users - An array of user objects
 * @returns {number} - The average age of the users
 * @throws {Error} - Throws error if the input is not an array or empty
 */
function calculateAverageAge(users) {

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
    if (!Array.isArray(users) || users.length === 0) {
        throw new Error('Input must be a non-empty array');
    }
    const totalAge = users.reduce((sum, user) => sum + user.age, 0);
    return totalAge / users.length;

SUFFIX CODE:
----------------------------------------
}

// Example usage
const users = [
    { name: 'Alice', age: 25, active: true },
    { name: 'Bob', age: 30, active: false },
    { name: 'Charlie', age: 35, active: true }
];
try {
    const averageAge = calculateAverageAge(users);
    console.log('Average Age:', averageAge);
} catch (error) {
    console.error(error.message);
}


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves realistic business logic with multiple functions handling API integration and data processing. The prefix provides substantial context and setup code, including detailed JSDoc comments for two functions. The golden completion involves implementing a function to calculate the average age of users, handling edge cases and errors. The suffix includes different code to ensure clear separation between completion and suffix content. Assertions will verify both documentation accuracy and functional requirements, making it a comprehensive test for bidirectional translation capabilities.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Test case for calculateAverageAge function
try {
    const validUsers = [
        { name: 'Alice', age: 25, active: true },
        { name: 'Bob', age: 30, active: false },
        { name: 'Charlie', age: 35, active: true }
    ];
    assert.strictEqual(calculateAverageAge(validUsers), 30);

    const invalidUsers = [];
    assert.throws(() => calculateAverageAge(invalidUsers), /Invalid input/);

    const nonArrayInput = 'invalid';
    assert.throws(() => calculateAverageAge(nonArrayInput), /Invalid input/);
} catch (error) {
    console.error('Assertion failed:', error);
}

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * A function that reads a JSON file, processes the data according to business rules,
 * and writes the results to a new file. The business rules include: filtering out inactive users,
 * and calculating the age of each user from their birthdate.
 */

// Helper function to calculate age from birthdate
function calculateAge(birthdate) {
    const birthDate = new Date(birthdate);
    const ageDifMs = Date.now() - birthDate.getTime();
    const ageDate = new Date(ageDifMs); // miliseconds from epoch
    return Math.abs(ageDate.getUTCFullYear() - 1970);
}

// Helper function to filter active users
function filterActiveUsers(users) {
    return users.filter(user => user.isActive);
}



LLM COMPLETION gpt-4.5-preview:
----------------------------------------


SUFFIX CODE:
----------------------------------------
function processUserData(inputFilePath, outputFilePath) {
    try {
        const data = fs.readFileSync(inputFilePath, 'utf8');
        const users = JSON.parse(data);

        // Filter active users
        const activeUsers = filterActiveUsers(users);

        // Calculate age for each user
        const processedUsers = activeUsers.map(user => ({
            ...user,
            age: calculateAge(user.birthdate)
        }));

        // Write processed data to a new file
        fs.writeFileSync(outputFilePath, JSON.stringify(processedUsers, null, 2));
        console.log('User data processed successfully.');
    } catch (error) {
        console.error('Error processing user data:', error);
    }
}

// Example usage of the processUserData function
const inputFilePath = path.join(__dirname, 'users.json');
const outputFilePath = path.join(__dirname, 'processed_users.json');
processUserData(inputFilePath, outputFilePath);
console.log('Processing complete. Check the processed_users.json file for results.');

JUSTIFICATION:
----------------------------------------
This test case provides a realistic scenario involving business logic and file processing. The prefix includes a comprehensive implementation of a function that reads and processes user data from a JSON file, applying specific business rules such as filtering inactive users and calculating their ages. The golden_completion section requires generating detailed JSDoc comments for this function, capturing all key aspects such as parameters, business rules, error handling, and return values. The suffix demonstrates the continuation of the code execution. This test case effectively evaluates an LLM's capability to generate meaningful and accurate documentation for complex business logic.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const docString = `/**
 * Processes the user data from a JSON file by applying business rules.
 *
 * @param {string} inputFilePath - The path to the input JSON file containing user data.
 * @param {string} outputFilePath - The path to the output JSON file to write processed data.
 *
 * The business rules applied are:
 * - Filtering out inactive users.
 * - Calculating the age of each user from their birthdate.
 *
 * The function reads the input file, processes the data, and writes the results to the output file.
 *
 * @throws Will throw an error if the input file cannot be read or the output file cannot be written.
 * @returns {void}
 */`;
assert(docString.includes('@param {string} inputFilePath'));
assert(docString.includes('@param {string} outputFilePath'));
assert(docString.includes('@throws'));
assert(docString.includes('@returns {void}'));
assert(docString.includes('Filtering out inactive users'));
assert(docString.includes('Calculating the age of each user from their birthdate'));
assert(docString.includes('error if the input file cannot be read'));
assert(docString.includes('the output file cannot be written'));

================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');
const { promisify } = require('util');
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);



LLM COMPLETION gpt-4.5-preview:
----------------------------------------


SUFFIX CODE:
----------------------------------------
class ConfigManager {
    constructor(configPath) {
        this.configPath = configPath;
        this.config = null;
    }

    /**
     * Loads the configuration from the file
     */
    async loadConfig() {
        try {
            const data = await readFile(this.configPath, 'utf8');
            this.config = JSON.parse(data);
        } catch (error) {
            console.error('Error loading config:', error);
            throw new Error('Failed to load configuration');
        }
    }

    /**
     * Saves the current configuration to the file
     */
    async saveConfig() {
        if (!this.config) {
            throw new Error('No configuration to save');
        }
        try {
            const data = JSON.stringify(this.config, null, 2);
            await writeFile(this.configPath, data, 'utf8');
        } catch (error) {
            console.error('Error saving config:', error);
            throw new Error('Failed to save configuration');
        }
    }

    /**
     * Sets a value in the configuration
     * @param {string} key - The key for the configuration value
     * @param {*} value - The value to set
     */
    setConfigValue(key, value) {
        if (!this.config) {
            throw new Error('Configuration not loaded');
        }
        this.config[key] = value;
    }

    /**
     * Gets a value from the configuration
     * @param {string} key - The key for the configuration value
     * @returns {*} The value of the key in the configuration
     */
    getConfigValue(key) {
        if (!this.config) {
            throw new Error('Configuration not loaded');
        }
        return this.config[key];
    }
}

// Example usage:
// const configManager = new ConfigManager('./config.json');
// await configManager.loadConfig();
// configManager.setConfigValue('theme', 'dark');
// await configManager.saveConfig();
async function main() {
    const configManager = new ConfigManager('./config.json');
    await configManager.loadConfig();
    console.log('Config loaded:', configManager.getConfigValue('theme'));
    configManager.setConfigValue('theme', 'light');
    await configManager.saveConfig();
    console.log('Config saved with new theme');
}

main().catch(console.error);


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to generate comprehensive class-level JSDoc comments for a complex class that handles configuration management. The provided prefix includes various methods with detailed comments, making it a good test case for code-to-comment translation. The golden completion requires the model to understand the overall functionality and error handling within the class. The suffix demonstrates the use of the class, ensuring that the completion and the prefix are aligned and coherent.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const docString = `/**
 * Configuration Manager Class
 * Manages loading, saving, and accessing configuration settings stored in a JSON file.
 *
 * @class
 * @param {string} configPath - Path to the configuration file
 *
 * Methods:
 * - loadConfig: Loads the configuration from the file
 * - saveConfig: Saves the current configuration to the file
 * - setConfigValue: Sets a value in the configuration
 * - getConfigValue: Gets a value from the configuration
 *
 * Error Handling:
 * - Throws an error if the configuration file cannot be read or written
 * - Throws an error if configuration methods are called before loading the configuration
 */`;
assert(docString.includes('Configuration Manager Class'));
assert(docString.includes('@class'));
assert(docString.includes('@param {string} configPath'));
assert(docString.includes('Methods:'));
assert(docString.includes('Error Handling:'));
assert(docString.includes('Throws an error if the configuration file cannot be read or written'));

================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');



LLM COMPLETION gpt-4.5-preview:
----------------------------------------


SUFFIX CODE:
----------------------------------------
class TaskScheduler {
    constructor() {
        /**
         * Queue to hold the tasks.
         * @type {Array<{ id: number, task: Function, interval: number, lastRun: number }>}
         */
        this.taskQueue = [];

        /**
         * Unique identifier for tasks.
         * @type {number}
         */
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the scheduler.
     * @param {Function} task - The task function to execute.
     * @param {number} interval - The interval in milliseconds at which to run the task.
     * @returns {number} The ID of the added task.
     */
    addTask(task, interval) {
        const taskId = this.nextTaskId++;
        this.taskQueue.push({ id: taskId, task, interval, lastRun: 0 });
        return taskId;
    }

    /**
     * Removes a task from the scheduler.
     * @param {number} taskId - The ID of the task to remove.
     */
    removeTask(taskId) {
        this.taskQueue = this.taskQueue.filter(task => task.id !== taskId);
    }

    /**
     * Runs the scheduler, executing tasks as needed.
     * @param {number} currentTime - The current time in milliseconds.
     */
    run(currentTime) {
        this.taskQueue.forEach(task => {
            if (currentTime - task.lastRun >= task.interval) {
                try {
                    task.task();
                    task.lastRun = currentTime;
                } catch (error) {
                    console.error(`Task ${task.id} failed:`, error);
                }
            }
        });
    }
}

// Example usage
const scheduler = new TaskScheduler();
const taskId = scheduler.addTask(() => console.log('Task executed!'), 1000);

// Simulate running the scheduler at different times
scheduler.run(0);
scheduler.run(1000);
scheduler.run(2000);

scheduler.removeTask(taskId);

// Verify task removal
assert.strictEqual(scheduler.taskQueue.length, 0);


JUSTIFICATION:
----------------------------------------
This example provides a robust test case for bidirectional translation between code and comments. The TaskScheduler class contains methods for adding, removing, and executing tasks, which are typical operations in workflow orchestration. The code-to-comment translation (golden_completion) demonstrates comprehensive documentation for the class and its methods, including parameter descriptions, usage examples, and method summaries. The assertions verify the functionality of the task scheduler, ensuring tasks are added, executed, and removed correctly. This scenario effectively tests the LLM's ability to generate accurate documentation from code and implement code from detailed documentation.

ASSERTIONS:
----------------------------------------
assert(typeof TaskScheduler === 'function');
assert(typeof scheduler.addTask === 'function');
assert(typeof scheduler.removeTask === 'function');
assert(typeof scheduler.run === 'function');
assert(scheduler.addTask(() => {}, 1000) > 0);
assert.strictEqual(scheduler.taskQueue.length, 1);
scheduler.run(Date.now());
assert.strictEqual(scheduler.taskQueue.length, 1);
scheduler.removeTask(taskId);
assert.strictEqual(scheduler.taskQueue.length, 0);
================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');

/**
 * Business rule validation function to check if a user is eligible for a premium service.
 * The user must meet the following criteria:
 * - Age must be 18 or older
 * - Must have an active subscription
 * - Must not have any outstanding balance
 */
function isUserEligibleForPremium(user) {
    if (user.age < 18) {
        return false;
    }
    if (!user.activeSubscription) {
        return false;
    }
    if (user.outstandingBalance > 0) {
        return false;
    }
    return true;
}

// Example usage:
const user1 = { age: 25, activeSubscription: true, outstandingBalance: 0 };
const user2 = { age: 17, activeSubscription: true, outstandingBalance: 0 };
const user3 = { age: 30, activeSubscription: false, outstandingBalance: 0 };
const user4 = { age: 22, activeSubscription: true, outstandingBalance: 100 };
assert.strictEqual(isUserEligibleForPremium(user1), true);
assert.strictEqual(isUserEligibleForPremium(user2), false);
assert.strictEqual(isUserEligibleForPremium(user3), false);
assert.strictEqual(isUserEligibleForPremium(user4), false);

/**
 * Function to check if a user meets the criteria for a standard service.
 * Criteria include:
 * - Age must be 18 or older
 * - Must have an active subscription
 */
function isUserEligibleForStandard(user) {

LLM COMPLETION gpt-4.5-preview:
----------------------------------------
    return user.age >= 18 && user.activeSubscription;

SUFFIX CODE:
----------------------------------------

}

// Example usage:
const user5 = { age: 25, activeSubscription: true };
const user6 = { age: 17, activeSubscription: true };
const user7 = { age: 30, activeSubscription: false };
assert.strictEqual(isUserEligibleForStandard(user5), true);
assert.strictEqual(isUserEligibleForStandard(user6), false);
assert.strictEqual(isUserEligibleForStandard(user7), false);

console.log('All assertions passed.');


JUSTIFICATION:
----------------------------------------
This test case provides a realistic scenario for validating business rules in a user eligibility function. The prefix contains a comprehensive implementation of a function checking if a user is eligible for a premium service, including multiple criteria and example usage. The golden completion requires the LLM to generate the implementation for checking eligibility for a standard service based on given criteria. The suffix includes different test cases to ensure the function works correctly. Assertions verify the functional requirements, making this a robust test for bidirectional translation between code and natural language.

ASSERTIONS:
----------------------------------------
assert.strictEqual(isUserEligibleForStandard({ age: 25, activeSubscription: true }), true);
assert.strictEqual(isUserEligibleForStandard({ age: 17, activeSubscription: true }), false);
assert.strictEqual(isUserEligibleForStandard({ age: 30, activeSubscription: false }), false);

================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * Represents a user in the system.
 * @typedef {Object} User
 * @property {string} id - The unique identifier for the user.
 * @property {string} name - The name of the user.
 * @property {string} email - The email address of the user.
 */

/**
 * Validates the user data against business rules.
 * @param {User} user - The user object to validate.
 * @returns {boolean} - Returns true if the user data is valid, otherwise false.
 */
function validateUser(user) {
    if (!user.id || !user.name || !user.email) {
        return false;
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(user.email);
}

/**
 * Loads user data from a JSON file.
 * @param {string} filePath - The path to the JSON file.
 * @returns {User[]} - Returns an array of users.
 */
function loadUsers(filePath) {
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
}

/**
 * Saves user data to a JSON file.
 * @param {string} filePath - The path to the JSON file.
 * @param {User[]} users - The array of users to save.
 */
function saveUsers(filePath, users) {
    const data = JSON.stringify(users, null, 2);
    fs.writeFileSync(filePath, data, 'utf8');
}

/**
 * Adds a new user to the system.
 * @param {User[]} users - The array of current users.
 * @param {User} newUser - The new user to add.
 * @returns {User[]} - Returns the updated array of users.
 */
function addUser(users, newUser) {
    if (!validateUser(newUser)) {
        throw new Error('Invalid user data');
    }
    users.push(newUser);
    return users;
}

/**
 * Example usage of the user management functions.
 */
function exampleUsage() {
    const usersFilePath = path.join(__dirname, 'users.json');
    let users = loadUsers(usersFilePath);
    const newUser = { id: '3', name: 'Alice', email: 'alice@example.com' };
    users = addUser(users, newUser);
    saveUsers(usersFilePath, users);
}

exampleUsage();



LLM COMPLETION gpt-4.5-preview:
----------------------------------------
const usersFilePath = path.join(__dirname, 'users.json');
let users = loadUsers(usersFilePath);
users = removeUser(users, '2');
saveUsers(usersFilePath, users);

SUFFIX CODE:
----------------------------------------
function removeUser(users, userId) {
    const index = users.findIndex(user => user.id === userId);
    if (index === -1) {
        throw new Error('User not found');
    }
    users.splice(index, 1);
    return users;
}

// Load the updated users from the file and log them
const updatedUsersFilePath = path.join(__dirname, 'users.json');
const updatedUsers = loadUsers(updatedUsersFilePath);
console.log(updatedUsers);


JUSTIFICATION:
----------------------------------------
This test case is beneficial because it evaluates the LLM's ability to generate both code and documentation in a realistic business scenario involving user data management. The prefix provides substantial context with multiple functions and a sample usage. The golden completion requires generating a new function that fits seamlessly into the existing codebase, including handling error scenarios and returning appropriate values. The suffix demonstrates further use of the existing functions, ensuring the completion integrates correctly. Assertions validate the correctness of the generated function and overall consistency.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Mock data for testing
const users = [
    { id: '1', name: 'John Doe', email: 'john@example.com' },
    { id: '2', name: 'Jane Doe', email: 'jane@example.com' }
];

// Test removeUser function
const updatedUsers = removeUser(users, '1');
assert.strictEqual(updatedUsers.length, 1, 'User should be removed');
assert.strictEqual(updatedUsers[0].id, '2', 'Remaining user ID should be 2');

// Test error scenario in removeUser function
let errorOccurred = false;
try {
    removeUser(users, 'nonexistent');
} catch (error) {
    errorOccurred = true;
    assert.strictEqual(error.message, 'User not found', 'Error message should be "User not found"');
}
assert.strictEqual(errorOccurred, true, 'Error should occur when removing nonexistent user');

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: devbench-code2NL-NL2code
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

/**
 * A class to manage configuration settings for an application.
 * This class allows loading, updating, and saving configuration settings.
 */
class ConfigManager {
    constructor(configFilePath) {
        this.configFilePath = configFilePath;
        this.config = {};
    }

    /**
     * Loads the configuration from the specified file.
     * @throws Will throw an error if the file does not exist or cannot be read.
     */
    loadConfig() {
        if (!fs.existsSync(this.configFilePath)) {
            throw new Error('Configuration file not found');
        }
        const fileContent = fs.readFileSync(this.configFilePath, 'utf-8');
        this.config = JSON.parse(fileContent);
    }

    /**
     * Updates a specific configuration setting.
     * @param {string} key - The key of the configuration setting.
     * @param {*} value - The value to set for the configuration setting.
     */
    updateConfig(key, value) {
        this.config[key] = value;
    }

    /**
     * Saves the current configuration to the specified file.
     */
    saveConfig() {
        const fileContent = JSON.stringify(this.config, null, 2);
        fs.writeFileSync(this.configFilePath, fileContent, 'utf-8');
    }
}

// Example usage:
// const configManager = new ConfigManager('./config.json');
// configManager.loadConfig();
// configManager.updateConfig('setting1', 'value1');
// configManager.saveConfig();


LLM COMPLETION gpt-4.5-preview:
----------------------------------------
module.exports = ConfigManager;

SUFFIX CODE:
----------------------------------------


/**
 * Retrieves a specific configuration setting.
 * @param {string} key - The key of the configuration setting to retrieve.
 * @returns {*} The value of the configuration setting.
 * @throws Will throw an error if the key does not exist in the configuration.
 */
ConfigManager.prototype.getConfig = function(key) {
    if (!(key in this.config)) {
        throw new Error(`Configuration key ${key} not found`);
    }
    return this.config[key];
};

// Example usage:
// const configValue = configManager.getConfig('setting1');


JUSTIFICATION:
----------------------------------------
This example provides a realistic scenario of managing configuration settings within an application. The prefix includes comprehensive comments and code for loading, updating, and saving configurations. The golden completion requires the LLM to generate a method for deleting a configuration setting based on detailed comments. The suffix further expands the functionality by adding a method to retrieve a setting, demonstrating the LLM's ability to maintain consistency in the class design. The assertions verify the correctness of the new method and ensure it handles error scenarios appropriately.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

const configManager = new ConfigManager('./config.json');
configManager.config = { 'setting1': 'value1', 'setting2': 'value2' };

// Testing deleteConfig method
configManager.deleteConfig('setting1');
assert(!('setting1' in configManager.config), 'The setting1 should be deleted');

try {
    configManager.deleteConfig('setting3');
} catch (e) {
    assert(e.message === 'Configuration key setting3 not found', 'Should throw error for non-existing key');
}

================================================================================
