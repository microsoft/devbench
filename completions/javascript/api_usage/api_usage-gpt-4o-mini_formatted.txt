
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const s3 = new AWS.S3();
const bucketName = 'my-unique-bucket-name';
const objectKey = 'test-object.txt';
const objectContent = 'This is a test object content';

// Function to create a bucket
async function createBucket(bucketName) {
    const params = {
        Bucket: bucketName
    };
    try {
        await s3.createBucket(params).promise();
        console.log(`Bucket created: ${bucketName}`);
    } catch (error) {
        console.error(`Error creating bucket: ${error.message}`);
    }
}

// Function to upload an object to the bucket
async function uploadObject(bucketName, objectKey, objectContent) {
    const params = {
        Bucket: bucketName,
        Key: objectKey,
        Body: objectContent
    };
    try {
        await s3.putObject(params).promise();
        console.log(`Object uploaded: ${objectKey}`);
    } catch (error) {
        console.error(`Error uploading object: ${error.message}`);
    }
}

// Function to get an object from the bucket
async function getObject(bucketName, objectKey) {
    const params = {
        Bucket: bucketName,
        Key: objectKey
    };
    try {
        const data = await s3.getObject(params).promise();
        console.log(`Object retrieved: ${objectKey}`);
        return data.Body.toString();
    } catch (error) {
        console.error(`Error getting object: ${error.message}`);
    }
}

// Function to delete an object from the bucket
async function deleteObject(bucketName, objectKey) {
    const params = {
        Bucket: bucketName,
        Key: objectKey
    };
    try {
        await s3.deleteObject(params).promise();
        console.log(`Object deleted: ${objectKey}`);
    } catch (error) {
        console.error(`Error deleting object: ${error.message}`);
    }
}

// Function to delete the bucket
async function deleteBucket(bucketName) {
    const params = {
        Bucket: bucketName
    };
    try {
        await s3.deleteBucket(params).promise();
        console.log(`Bucket deleted: ${bucketName}`);
    } catch (error) {
        console.error(`Error deleting bucket: ${error.message}`);
    }
}

// Main function to demonstrate bucket operations
async function main() {
    await createBucket(bucketName);
    await uploadObject(bucketName, objectKey, objectContent);


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    const retrievedContent = await getObject(bucketName, objectKey);
    console.log(`Retrieved content: ${retrievedContent}`);

SUFFIX CODE:
----------------------------------------

    await deleteObject(bucketName, objectKey);
    await deleteBucket(bucketName);
}

main().catch(console.error);

JUSTIFICATION:
----------------------------------------
This is a good test case because it involves using the AWS SDK for JavaScript, which is an uncommon library for many developers. The code demonstrates the creation, uploading, retrieval, and deletion of an object in an S3 bucket, covering a full lifecycle of S3 operations. It tests the model's ability to recognize and complete patterns in code involving cloud services, specifically AWS S3. The assertions ensure that the operations are performed correctly, and the use of async/await for handling asynchronous operations is a critical pattern that needs to be understood correctly by the model.

ASSERTIONS:
----------------------------------------
console.assert(retrievedContent === objectContent, 'Retrieved content does not match');
================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { MongoClient } = require('mongodb');
const assert = require('assert');

// Connection URL
const url = 'mongodb://localhost:27017';
// Database Name
const dbName = 'myproject';

// Create a new MongoClient
const client = new MongoClient(url, { useNewUrlParser: true, useUnifiedTopology: true });

async function run() {
  try {
    // Connect the client to the server
    await client.connect();
    console.log('Connected successfully to server');

    const db = client.db(dbName);

    // Create a collection
    const collection = db.collection('documents');

    // Insert some documents
    await collection.insertMany([
      { a: 1 }, { a: 2 }, { a: 3 }
    ]);
    console.log('Inserted documents into the collection');

    // Find some documents
    const docs = await collection.find({}).toArray();
    console.log('Found documents:', docs);

    // Index a field
    await collection.createIndex({ a: 1 });
    console.log('Index created');

    const pipeline = [
      { $match: { a: { $gte: 2 } } },
      { $group: { _id: '$a', count: { $sum: 1 } } }
    ];
    const aggCursor = collection.aggregate(pipeline);

    // Fetch the results
    const aggResults = await aggCursor.toArray();
    console.log('Aggregation results:', aggResults);

  } catch (err) {
    console.error(err);
  } finally {
    // Close the connection
    await client.close();
  }
}

run().catch(console.dir);
    // Use the aggregate function with a pipeline


LLM COMPLETION gpt-4o-mini:
----------------------------------------
const aggCursor = collection.aggregate(pipeline);

SUFFIX CODE:
----------------------------------------


// Find a document
const document = await collection.findOne({ a: 3 });
console.log('Found one document:', document);

// Drop the collection
await collection.drop();
console.log('Collection dropped');

// Close the connection
await client.close();


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and complete a pattern involving the MongoDB Node.js driver, specifically using the aggregate function with a pipeline. Aggregation is a powerful but less common feature compared to basic CRUD operations, making it a good test for uncommon API usage. The assertions validate the correct use of the aggregation pipeline and ensure the expected documents are returned.

ASSERTIONS:
----------------------------------------
assert(Array.isArray(aggResults), 'Aggregation results should be an array');
assert(aggResults.length > 0, 'Aggregation results should contain documents');
assert(aggResults[0].hasOwnProperty('_id'), 'Aggregation result documents should have an _id field');
assert(aggResults[0].hasOwnProperty('count'), 'Aggregation result documents should have a count field');
================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const app = express();
app.use(bodyParser.json());

// MongoDB Schema and Model
const userSchema = new mongoose.Schema({
    name: String,
    email: String,
    password: String,
});
const User = mongoose.model('User', userSchema);

// Express.js route to create a new user
app.post('/user', async (req, res) => {
    try {
        const { name, email, password } = req.body;
        if (!name || !email || !password) {
            return res.status(400).send('All fields are required');
        }

        // Check if user already exists
        const existingUser = await User.findOne({ email });
        if (existingUser) {
            return res.status(400).send('User already exists');
        }


LLM COMPLETION gpt-4o-mini:
----------------------------------------
        const newUser = new User({ name, email, password });

SUFFIX CODE:
----------------------------------------
        const savedUser = await newUser.save();
        res.status(201).send(savedUser);
    } catch (error) {
        res.status(500).send('Internal Server Error');
    }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Mongoose connection setup
mongoose.connect('mongodb://localhost:27017/test', {
    useNewUrlParser: true,
    useUnifiedTopology: true,
}).then(() => {
    console.log('Connected to MongoDB');
}).catch((error) => {
    console.error('Error connecting to MongoDB:', error);
});

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete the use of the Mongoose library, specifically the creation of a new document with the Mongoose model. The task involves understanding the correct usage of the Mongoose schema and model to create a new instance and handle it properly within an Express.js route. This scenario is realistic and involves common practices in building web applications with Node.js and MongoDB, but it uses a specific pattern of API calls that are less common in simple examples.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const mongoose = require('mongoose');
const User = mongoose.model('User', new mongoose.Schema({ name: String, email: String, password: String }));

(async () => {
    await mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true });
    try {
        const newUser = new User({ name: 'John Doe', email: 'john.doe@example.com', password: 'password123' });
        const savedUser = await newUser.save();
        assert.strictEqual(savedUser.name, 'John Doe');
        assert.strictEqual(savedUser.email, 'john.doe@example.com');
        assert.strictEqual(savedUser.password, 'password123');
    } finally {
        await mongoose.connection.dropDatabase();
        await mongoose.connection.close();
    }
})();
================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { Sequelize, DataTypes, Model } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

class User extends Model {}
User.init({
  username: {
    type: DataTypes.STRING,
    allowNull: false
  },
  birthday: {
    type: DataTypes.DATE,
    allowNull: false
  }
}, { sequelize, modelName: 'user' });

class Post extends Model {}
Post.init({
  title: {
    type: DataTypes.STRING,
    allowNull: false
  },
  content: {
    type: DataTypes.TEXT,
    allowNull: false
  }
}, { sequelize, modelName: 'post' });

User.hasMany(Post);
Post.belongsTo(User);

async function setupDatabase() {
  await sequelize.sync();
  const user = await User.create({ username: 'JohnDoe', birthday: new Date(1990, 1, 1) });
  await Post.create({ title: 'Hello World', content: 'This is a test post.', userId: user.id });
  return user;
}

async function fetchUserWithPosts(userId) {
  const user = await User.findByPk(userId, {
    include: Post
  });
  return user;
}

setupDatabase().then(async (user) => {
  const userId = user.id;
  const fetchedUser = await fetchUserWithPosts(userId);
  console.log(`Fetched user: ${fetchedUser.username}`);
  console.log(`Posts: ${fetchedUser.posts.map(post => post.title).join(', ')}`);

  // Now, let's demonstrate an uncommon Sequelize method usage


LLM COMPLETION gpt-4o-mini:
----------------------------------------
  const updatedUser = await User.update({ username: 'JaneDoe' }, { where: { id: userId } });

SUFFIX CODE:
----------------------------------------

  console.log(`User update complete: ${updatedUser.username}`);
  sequelize.close();
}).catch(err => console.error(err));

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of an uncommon method in Sequelize: the `update` method with the `returning` and `plain` options. These options are not frequently used together but are valid and useful in specific cases where the updated instance needs to be returned. The example also covers associations and fetching related data, providing a comprehensive test of the model's understanding of Sequelize's capabilities.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
  const user = await setupDatabase();
  const userId = user.id;
  const fetchedUser = await fetchUserWithPosts(userId);
  assert.strictEqual(fetchedUser.username, 'JohnDoe');
  assert.strictEqual(fetchedUser.posts.length, 1);
  assert.strictEqual(fetchedUser.posts[0].title, 'Hello World');

  const updatedUser = await User.update({ username: 'JaneDoe' }, { where: { id: userId }, returning: true, plain: true });
  assert.strictEqual(updatedUser[1].username, 'JaneDoe');

  sequelize.close();
})();
================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const mongoose = require('mongoose');
const assert = require('assert');

// Define a simple schema for a User
const userSchema = new mongoose.Schema({
    name: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    age: Number
});

// Create a model from the schema
const User = mongoose.model('User', userSchema);

// Connect to a mock MongoDB database
mongoose.connect('mongodb://localhost:27017/testdb', { useNewUrlParser: true, useUnifiedTopology: true });

// Helper function to clear the User collection
async function clearUsers() {
    await User.deleteMany({});
}

// Helper function to create a new user
async function createUser(name, email, age) {
    const user = new User({ name, email, age });
    await user.save();
    return user;
}

// Clear the collection before starting the test
clearUsers().then(async () => {
    // Create a new user
    const user = await createUser('John Doe', 'johndoe@example.com', 30);

    // Find the user by email using a rare Mongoose method: findOneAndUpdate
    const updatedUser = await User.findOneAndUpdate(
        { email: 'johndoe@example.com' },
        { $set: { age: 31 } },
        { new: true, useFindAndModify: false }
    );

    // Assertions to verify the update
    assert(updatedUser.age === 31);

    // Now we will test another rare method: findOneAndRemove
    const removedUser = await 

LLM COMPLETION gpt-4o-mini:
----------------------------------------
User.findOneAndRemove({ email: 'johndoe@example.com' });

SUFFIX CODE:
----------------------------------------
    assert(removedUser.email === 'johndoe@example.com');

    // Verify that the user has been removed
    const userAfterRemoval = await User.findOne({ email: 'johndoe@example.com' });
    assert(userAfterRemoval === null);

    // Cleanup: close the connection
    mongoose.connection.close();
}).catch(err => {
    console.error(err);
    mongoose.connection.close();
});

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the model's ability to handle rare Mongoose methods like `findOneAndUpdate` and `findOneAndRemove`. These methods are less commonly used compared to standard CRUD operations and have specific parameter requirements. The scenario demonstrates proper usage, parameter ordering, and error handling within a MongoDB context. The assertions verify that the user is updated and then removed correctly, ensuring the model understands the complete lifecycle of these operations.

ASSERTIONS:
----------------------------------------
assert(removedUser.email === 'johndoe@example.com');
assert(userAfterRemoval === null);
================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');
const csv = require('csv-parser');
const results = [];

// Function to read and parse a CSV file
function parseCSVFile(filePath) {
    return new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
            .pipe(csv())
            .on('data', (data) => results.push(data))
            .on('end', () => {
                resolve(results);
            })
            .on('error', (err) => {
                reject(err);
            });
    });
}

// Function to write data to a CSV file
function writeCSVFile(filePath, data) {
    return new Promise((resolve, reject) => {
        const writeStream = fs.createWriteStream(filePath);
        writeStream.on('error', (err) => reject(err));
        writeStream.on('finish', () => resolve());
        data.forEach(row => {
            writeStream.write(row.join(',') + '\n');
        });
        writeStream.end();
    });
}

// Helper function to generate sample data
function generateSampleData() {
    return [
        ['name', 'age', 'city'],
        ['Alice', '30', 'New York'],
        ['Bob', '25', 'San Francisco'],
        ['Charlie', '35', 'Los Angeles']
    ];
}

// Main function to demonstrate read and write operations
async function main() {
    const sampleData = generateSampleData();
    const inputFilePath = path.join(__dirname, 'input.csv');
    const outputFilePath = path.join(__dirname, 'output.csv');

    try {
        await writeCSVFile(inputFilePath, sampleData);
        const parsedData = await parseCSVFile(inputFilePath);

LLM COMPLETION gpt-4o-mini:
----------------------------------------
        console.log('Parsed Data:', parsedData);

SUFFIX CODE:
----------------------------------------

        console.log('Parsed Data:', parsedData);
        // Additional operations can be performed here
    } catch (error) {
        console.error('Error processing CSV files:', error);
    } finally {
        // Cleanup created files
        fs.unlinkSync(inputFilePath);
        fs.unlinkSync(outputFilePath);
    }
}

main();

JUSTIFICATION:
----------------------------------------
This test case is a good test scenario because it involves the use of the csv-parser library, which is not as commonly used as other libraries for CSV parsing. It also demonstrates the use of the fs module to handle file operations and ensures proper error handling and cleanup. The pattern of reading from a CSV file, processing the data, and writing to another CSV file is established, and the completion requires understanding of the correct use of promises and the csv-parser API. The assertions verify the correctness of the data being read and written, ensuring proper parameter ordering and handling of asynchronous operations.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const path = require('path');
const fs = require('fs');
const csv = require('csv-parser');
const results = [];

async function test() {
    const sampleData = [
        ['name', 'age', 'city'],
        ['Alice', '30', 'New York'],
        ['Bob', '25', 'San Francisco'],
        ['Charlie', '35', 'Los Angeles']
    ];
    const inputFilePath = path.join(__dirname, 'test_input.csv');
    const outputFilePath = path.join(__dirname, 'test_output.csv');

    await writeCSVFile(inputFilePath, sampleData);
    const parsedData = await parseCSVFile(inputFilePath);
    await writeCSVFile(outputFilePath, parsedData);
    const outputData = await parseCSVFile(outputFilePath);

    assert.deepStrictEqual(parsedData, outputData, 'Parsed data should match output data');
    assert.strictEqual(parsedData.length, 4, 'Parsed data should have 4 rows');
    assert.deepStrictEqual(parsedData[0], { name: 'Alice', age: '30', city: 'New York' }, 'First row should match');
    assert.deepStrictEqual(parsedData[1], { name: 'Bob', age: '25', city: 'San Francisco' }, 'Second row should match');
    assert.deepStrictEqual(parsedData[2], { name: 'Charlie', age: '35', city: 'Los Angeles' }, 'Third row should match');

    fs.unlinkSync(inputFilePath);
    fs.unlinkSync(outputFilePath);
}

test().then(() => console.log('All tests passed')).catch(err => console.error('Tests failed', err));
================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');
const express = require('express');
const app = express();
const port = 3000;

// A mock function to simulate a delay
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Mock database
const users = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' },
    { id: 3, name: 'Charlie' }
];

// Function to fetch user data
async function fetchUserData(userId) {
    const user = users.find(u => u.id === userId);
    if (!user) {
        throw new Error('User not found');
    }
    await delay(1000); // Simulate network delay
    return user;
}

// Middleware to log request details
app.use((req, res, next) => {
    console.log(`Received request: ${req.method} ${req.url}`);
    next();
});

// Endpoint to get user data
app.get('/user/:id', async (req, res) => {
    try {
        const userId = parseInt(req.params.id, 10);
        const user = await fetchUserData(userId);
        res.json(user);
    } catch (error) {
        res.status(404).send(error.message);
    }
});

// Start the server
app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}/`);
});

// Function to get data from an external API
async function getExternalData() {
    const response = await axios.get('https://api.example.com/data');
    return response.data;
}

// Main function to execute the code
async function main() {
    try {
        const externalData = await getExternalData();
        console.log('External data:', externalData);
    } catch (error) {
        console.error('Error fetching external data:', error);
    }
}

LLM COMPLETION gpt-4o-mini:
----------------------------------------
const server = app.listen(port);

SUFFIX CODE:
----------------------------------------
app.use((req, res, next) => {
    console.log(`Response status: ${res.statusCode}`);
    next();
});

// Cleanup function to close the server
async function cleanup() {
    server.close(() => {
        console.log('Server closed');
    });
}

main().then(cleanup).catch(cleanup);

JUSTIFICATION:
----------------------------------------
This test case involves the usage of the Express web framework along with the Axios library. It demonstrates a realistic scenario of setting up a web server, handling routes, fetching data from an external API, and proper cleanup of resources. The golden completion focuses on the correct usage of the app.listen method, which is a critical part of starting the Express server. This example tests the model's ability to recognize and continue the pattern of setting up and using an Express server along with external API calls.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const http = require('http');
const serverUrl = `http://localhost:${port}/user/1`;

// Test the server is running and responds correctly
(async () => {
    const response = await axios.get(serverUrl);
    assert.strictEqual(response.status, 200);
    assert.strictEqual(response.data.name, 'Alice');

    // Test logging middleware
    const logResponse = await axios.get(serverUrl);
    assert.strictEqual(logResponse.status, 200);
    assert.strictEqual(logResponse.data.name, 'Alice');

    // Cleanup
    server.close(() => {
        console.log('Server closed for assertions');
    });
})();
================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const app = express();

// Middleware setup
app.use(bodyParser.json());

// MongoDB connection setup
mongoose.connect('mongodb://localhost/test', { useNewUrlParser: true, useUnifiedTopology: true });

// Define a Mongoose schema and model
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String
});
const User = mongoose.model('User', userSchema);

// Helper function to hash passwords
const bcrypt = require('bcrypt');
const saltRounds = 10;
function hashPassword(password) {
  return bcrypt.hash(password, saltRounds);
}

// Helper function to handle errors
function handleError(res, err) {
  console.error(err);
  res.status(500).send('Internal Server Error');
}

// API route to create a new user
app.post('/users', async (req, res) => {
  const { name, email, password } = req.body;
  try {
    const hashedPassword = await hashPassword(password);
    const newUser = new User({ name, email, password: hashedPassword });
    await newUser.save();
    res.status(201).send('User created');
  } catch (err) {
    handleError(res, err);
  }
});

// API route to get user details
app.get('/users/:id', async (req, res) => {
  const userId = req.params.id;
  try {
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).send('User not found');
    }
    res.json(user);
  } catch (err) {
    handleError(res, err);
  }
});

// API route to update user details
app.put('/users/:id', async (req, res) => {
  const userId = req.params.id;
  const { name, email, password } = req.body;
  try {
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).send('User not found');
    }
    user.name = name;
    user.email = email;
    if (password) {
      user.password = await hashPassword(password);
    }
    await user.save();
    res.send('User updated');
  } catch (err) {
    handleError(res, err);
  }
});

// API route to delete a user
app.delete('/users/:id', async (req, res) => {
  const userId = req.params.id;
  try {
    const user = await User.findByIdAndDelete(userId);
    if (!user) {
      return res.status(404).send('User not found');
    }
    res.send('User deleted');
  } catch (err) {
    handleError(res, err);
  }
});

// Start the server
const server = app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

LLM COMPLETION gpt-4o-mini:
----------------------------------------
server.close();

SUFFIX CODE:
----------------------------------------
server.close();

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the MongoMemoryServer from the mongodb-memory-server package, which is a less common library used for creating an in-memory MongoDB server for testing purposes. This setup is not frequently used in typical production code but is very useful for unit tests and integration tests. The completion demonstrates the correct setup of an in-memory MongoDB server and its integration with Mongoose, making it a good test case for recognizing and completing patterns involving in-memory databases.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
assert(mongoose.connection.readyState === 1, 'Mongoose should be connected to in-memory MongoDB');
================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const { promisify } = require('util');
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);

const tempFile = 'temp.txt';
const backupFile = 'backup.txt';

async function createTempFile(content) {
    try {
        await writeFileAsync(tempFile, content);
        console.log('Temp file created');
    } catch (error) {
        console.error('Error creating temp file:', error);
    }
}

async function readTempFile() {
    try {
        const data = await readFileAsync(tempFile, 'utf8');
        console.log('Temp file content:', data);
        return data;
    } catch (error) {
        console.error('Error reading temp file:', error);
    }
}

async function backupTempFile() {
    try {
        const data = await readTempFile();
        await writeFileAsync(backupFile, data);
        console.log('Backup file created');
    } catch (error) {
        console.error('Error creating backup file:', error);
    }
}

async function runFileOperations() {
    await createTempFile('Sample content');
    await backupTempFile();
}

LLM COMPLETION gpt-4o-mini:
----------------------------------------
runFileOperations().then(() => {

SUFFIX CODE:
----------------------------------------

    fs.unlink(backupFile, (err) => {
        if (err) console.error('Error deleting backup file:', err);
        else console.log('Backup file deleted');
    });
});

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and use the Node.js 'fs' module with promisified methods for file operations. The task involves reading, writing, and deleting files, which are common tasks but using promisify adds a layer of complexity. This tests the LLM's understanding of error handling and correct sequencing of asynchronous file operations.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

(async () => {
    await runFileOperations();
    const tempExists = fs.existsSync(tempFile);
    const backupExists = fs.existsSync(backupFile);
    assert.strictEqual(tempExists, false, 'Temp file should be deleted');
    assert.strictEqual(backupExists, false, 'Backup file should be deleted');
})().catch(console.error);
================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const assert = require('assert');

// Configure the AWS SDK with necessary credentials
AWS.config.update({
  region: 'us-west-2',
  accessKeyId: 'YOUR_ACCESS_KEY_ID',
  secretAccessKey: 'YOUR_SECRET_ACCESS_KEY'
});

// Create an S3 service object
const s3 = new AWS.S3();

// Function to upload a file to S3
async function uploadFileToS3(bucketName, key, body) {
  const params = {
    Bucket: bucketName,
    Key: key,
    Body: body
  };

  try {
    const data = await s3.upload(params).promise();
    console.log('File uploaded successfully:', data);
    return data;
  } catch (err) {
    console.error('Error uploading file:', err);
    throw err;
  }
}

// Function to list objects in an S3 bucket
async function listObjectsInBucket(bucketName) {
  const params = {
    Bucket: bucketName
  };

  try {
    const data = await s3.listObjectsV2(params).promise();
    console.log('Objects in bucket:', data);
    return data;
  } catch (err) {
    console.error('Error listing objects:', err);
    throw err;
  }
}

// Function to delete an object from S3
async function deleteObjectFromS3(bucketName, key) {
  const params = {
    Bucket: bucketName,
    Key: key
  };

  try {
    const data = await s3.deleteObject(params).promise();
    console.log('File deleted successfully:', data);
    return data;
  } catch (err) {
    console.error('Error deleting file:', err);
    throw err;
  }
}

// Test constants
const bucketName = 'my-test-bucket';
const uploadKey = 'test-file.txt';
const fileContent = 'Hello, this is a test file!';

LLM COMPLETION gpt-4o-mini:
----------------------------------------
const fileContent = Buffer.from('Hello, this is a test file!', 'utf-8');

SUFFIX CODE:
----------------------------------------

// Clean up: Delete the uploaded file from S3
(async () => {
  try {
    const deleteData = await deleteObjectFromS3(bucketName, uploadKey);
    console.log('Cleanup successful:', deleteData);
  } catch (err) {
    console.error('Cleanup failed:', err);
  }
})();

JUSTIFICATION:
----------------------------------------
This test case focuses on using the AWS SDK to interact with Amazon S3, demonstrating functions for uploading, listing, and deleting objects in a bucket. It tests the LLM's ability to recognize and complete patterns involving asynchronous API calls, handling promises, and correctly using AWS SDK methods. The example includes uncommon but valid usage patterns, such as checking for the existence of an uploaded file in the bucket, which is crucial for verifying correct behavior. The assertions ensure that the file upload and listing operations are performed correctly and that the uploaded file is accurately identified in the bucket.

ASSERTIONS:
----------------------------------------
assert(typeof uploadData === 'object', 'Upload data should be an object');
assert(uploadData.Key === uploadKey, 'Uploaded file key mismatch');
assert(listData.Contents.some(item => item.Key === uploadKey), 'Uploaded file not found in bucket');
================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { MongoClient } = require('mongodb');
const assert = require('assert');

// Connection URL
const url = 'mongodb://localhost:27017';
// Database Name
const dbName = 'myproject';

async function main() {
  // Use connect method to connect to the server
  const client = new MongoClient(url, { useNewUrlParser: true, useUnifiedTopology: true });
  await client.connect();
  console.log('Connected successfully to server');

  const db = client.db(dbName);

  // Get the documents collection
  const collection = db.collection('documents');

  // Insert some documents
  await collection.insertMany([
    { a: 1 }, { a: 2 }, { a: 3 }
  ]);

  // Define a function to find documents
  async function findDocuments() {
    // Find some documents
    const docs = await collection.find({}).toArray();
    console.log('Found the following records');
    console.log(docs);
    return docs;
  }

  // Define a function to update a document
  async function updateDocument() {
    // Update document where a is 2, set b equal to 1
    const result = await collection.updateOne({ a: 2 }


LLM COMPLETION gpt-4o-mini:
----------------------------------------
, { $set: { b: 1 } });

SUFFIX CODE:
----------------------------------------
    console.log('Updated the document with the field a equal to 2');
    return result;
  }

  // Call the updateDocument function
  const updateResult = await updateDocument();
  assert.strictEqual(updateResult.matchedCount, 1);
  assert.strictEqual(updateResult.modifiedCount, 1);

  // Call the findDocuments function
  const docs = await findDocuments();
  assert.strictEqual(docs.length, 3);
  assert.strictEqual(docs[1].b, 1);

  // Close the connection
  await client.close();
}

main().catch(console.error);


JUSTIFICATION:
----------------------------------------
This is a good test case because it uses the MongoDB Node.js driver to demonstrate a database operation that involves updating a document. The MongoDB updateOne method is used with a specific filter and update operation, which tests the model's ability to handle database interfaces and correctly use method parameters. The example includes assertions to verify the operation's correctness, ensuring that the document is updated as expected.

ASSERTIONS:
----------------------------------------
assert.strictEqual(updateResult.matchedCount, 1);
assert.strictEqual(updateResult.modifiedCount, 1);
const docs = await findDocuments();
assert.strictEqual(docs.length, 3);
assert.strictEqual(docs[1].b, 1);
================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const s3 = new AWS.S3();
const bucketName = 'example-bucket';
const objectKey = 'example-object.txt';
const objectContent = 'Hello, world!';

async function uploadObject() {
    const params = {
        Bucket: bucketName,
        Key: objectKey,
        Body: objectContent,
        ContentType: 'text/plain'
    };
    try {
        const result = await s3.putObject(params).promise();
        return result;
    } catch (error) {
        console.error('Error uploading object:', error);
        throw error;
    }
}

async function getObject() {
    const params = {
        Bucket: bucketName,
        Key: objectKey
    };
    try {
        const result = await s3.getObject(params).promise();
        return result.Body.toString('utf-8');
    } catch (error) {
        console.error('Error getting object:', error);
        throw error;
    }
}

async function listObjects() {
    const params = {
        Bucket: bucketName
    };
    try {
        const result = await s3.listObjectsV2(params).promise();
        return result.Contents;
    } catch (error) {
        console.error('Error listing objects:', error);
        throw error;
    }
}

(async () => {
    try {
        await uploadObject();
        const content = await getObject();
        console.log('Uploaded and retrieved content:', content);
        const objects = await listObjects();
        console.log('List of objects in bucket:', objects);
    } catch (error) {
        console.error('Error in S3 operations:', error);
    }
})();

// Deleting the object from S3 to clean up resources
async function deleteObject() {
    const params = {
        Bucket: bucketName,
        Key: objectKey
    };
    try {
        const result = await s3.deleteObject(params).promise();
        return result;
    } catch (error) {
        console.error('Error deleting object:', error);
        throw error;
    }
}

// Ensure the object is deleted after the operations
(async () => {

LLM COMPLETION gpt-4o-mini:
----------------------------------------
    await deleteObject();

SUFFIX CODE:
----------------------------------------

    console.log('Object deleted successfully');
})();

JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the AWS SDK to perform operations with S3, including uploading, retrieving, listing, and deleting objects. The scenario tests the model's ability to recognize and complete patterns involving the AWS SDK for JavaScript, which is less commonly used in basic examples. The golden completion focuses on the correct implementation of the delete operation, ensuring proper parameter usage and error handling. The assertions verify the behavior of these operations, ensuring that the object is correctly deleted from S3 after the main operations are performed.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
    const content = await getObject();
    assert.strictEqual(content, objectContent, 'Content should match the uploaded content');
    const objects = await listObjects();
    assert(objects.some(obj => obj.Key === objectKey), 'The object should be listed in the bucket');
    await deleteObject();
    try {
        await getObject();
        assert.fail('The object should not exist after deletion');
    } catch (error) {
        assert.strictEqual(error.code, 'NoSuchKey', 'Expected NoSuchKey error after deletion');
    }
})();
================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const express = require('express');
const app = express();
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
app.use(bodyParser.json());

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/testdb', { useNewUrlParser: true, useUnifiedTopology: true });

// Define a schema for our data
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String,
});

// Create a model from the schema
const User = mongoose.model('User', userSchema);

// Middleware to log request details
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();
});

// Route to create a new user
app.post('/users', async (req, res) => {
  try {
    const user = new User({
      name: req.body.name,
      email: req.body.email,
      password: req.body.password,
    });
    await user.save();
    res.status(201).send(user);
  } catch (error) {
    res.status(400).send(error);
  }
});

// Route to get all users
app.get('/users', async (req, res) => {
  try {
    const users = await User.find();
    res.status(200).send(users);
  } catch (error) {
    res.status(500).send(error);
  }
});

// Route to update a user
app.put('/users/:id', async (req, res) => {
  try {
    const user = await User.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
    if (!user) {
      return res.status(404).send();
    }
    res.send(user);
  } catch (error) {
    res.status(400).send(error);
  }
});

// Route to delete a user
app.delete('/users/:id', async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    if (!user) {
      return res.status(404).send();
    }
    res.send(user);
  } catch (error) {
    res.status(500).send(error);
  }
});

// Start the server
const server = app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

LLM COMPLETION gpt-4o-mini:
----------------------------------------
// Clean up resources
server.close(() => {
  console.log('Server closed');
  mongoose.connection.close();
});

SUFFIX CODE:
----------------------------------------
// Clean up resources
server.close(() => {
  console.log('Server closed');
  mongoose.connection.close();
});

JUSTIFICATION:
----------------------------------------
This test case is a good example of using the Mongoose library with Express.js to handle database connections and CRUD operations. The golden completion demonstrates the use of a less common Mongoose event handler for the 'connected' event, which is crucial for monitoring the database connection status. This tests the model's ability to recognize and correctly implement event handling patterns in Mongoose, which may not be as frequently used as basic CRUD operations.

ASSERTIONS:
----------------------------------------
const mongoose = require('mongoose');
const assert = require('assert');

mongoose.connect('mongodb://localhost:27017/testdb', { useNewUrlParser: true, useUnifiedTopology: true });

mongoose.connection.on('connected', () => {
  console.log('Mongoose connected to db');
  assert.strictEqual(mongoose.connection.readyState, 1);
  mongoose.connection.close();
});

mongoose.connection.on('disconnected', () => {
  console.log('Mongoose disconnected from db');
  assert.strictEqual(mongoose.connection.readyState, 0);
});
================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');
const { parseString } = require('xml2js');

// Utility function to read XML file
function readXmlFile(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (err, data) => {
      if (err) {
        return reject(err);
      }
      parseString(data, (err, result) => {
        if (err) {
          return reject(err);
        }
        resolve(result);
      });
    });
  });
}

// Function to find a book by title
async function findBookByTitle(xmlFilePath, title) {
  try {
    const result = await readXmlFile(xmlFilePath);
    const books = result.catalog.book;
    for (const book of books) {
      if (book.title[0] === title) {
        return book;
      }
    }
  } catch (error) {
    console.error('Error reading XML file:', error);
  }
  return null;
}

// Sample XML data
const sampleXmlData = `
<catalog>
  <book id="bk101">
    <author>Gambardella, Matthew</author>
    <title>XML Developer's Guide</title>
    <genre>Computer</genre>
    <price>44.95</price>
    <publish_date>2000-10-01</publish_date>
    <description>An in-depth look at creating applications with XML.</description>
  </book>
  <book id="bk102">
    <author>Ralls, Kim</author>
    <title>Midnight Rain</title>
    <genre>Fantasy</genre>
    <price>5.95</price>
    <publish_date>2000-12-16</publish_date>
    <description>A former architect battles corporate zombies, an evil sorceress, and her own childhood to become queen of the world.</description>
  </book>
</catalog>
`;

// Write sample XML data to a file
const sampleXmlFilePath = path.join(__dirname, 'sample.xml');
fs.writeFileSync(sampleXmlFilePath, sampleXmlData);

LLM COMPLETION gpt-4o-mini:
----------------------------------------
async function testFindBookByTitle() {
  const book = await findBookByTitle(sampleXmlFilePath, "XML Developer's Guide");
  console.log(book);
}

SUFFIX CODE:
----------------------------------------


testFindBookByTitle();

JUSTIFICATION:
----------------------------------------
This test case involves parsing XML using the `xml2js` library, which is less commonly used compared to JSON parsing libraries. The pattern includes reading an XML file, parsing its content, and searching for specific elements based on a condition. This scenario tests the LLM's ability to correctly recognize and use the `xml2js` library's parsing function, handle nested structures in XML, and implement a search function that iterates over the parsed data. Additionally, the test ensures proper cleanup of resources by deleting the sample XML file after the assertions.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

async function assertFindBookByTitle() {
  const book = await findBookByTitle(sampleXmlFilePath, 'XML Developer\'s Guide');
  assert(book !== null, 'Book should not be null');
  assert.strictEqual(book.title[0], 'XML Developer\'s Guide', 'Book title should match');
  assert.strictEqual(book.author[0], 'Gambardella, Matthew', 'Book author should match');
  assert.strictEqual(book.genre[0], 'Computer', 'Book genre should match');
  assert.strictEqual(book.price[0], '44.95', 'Book price should match');
  assert.strictEqual(book.publish_date[0], '2000-10-01', 'Book publish date should match');
}

assertFindBookByTitle().then(() => {
  fs.unlinkSync(sampleXmlFilePath);
  console.log('All assertions passed');
}).catch(error => {
  console.error('Assertion failed:', error);
  fs.unlinkSync(sampleXmlFilePath);
});
================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');
const express = require('express');
const app = express();
const bodyParser = require('body-parser');
const { URLSearchParams } = require('url');

app.use(bodyParser.json());

// Mock database
let users = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' }
];

// Utility function to find user by ID
function findUserById(id) {
    return users.find(user => user.id === id);
}

// Route to get user info
app.get('/user/:id', (req, res) => {
    const userId = parseInt(req.params.id, 10);
    const user = findUserById(userId);
    if (user) {
        res.json(user);
    } else {
        res.status(404).send('User not found');
    }
});

// Route to update user info
app.put('/user/:id', (req, res) => {
    const userId = parseInt(req.params.id, 10);
    const user = findUserById(userId);
    if (user) {
        const { name, email } = req.body;
        user.name = name || user.name;
        user.email = email || user.email;
        res.json(user);
    } else {
        res.status(404).send('User not found');
    }
});

// Function to simulate external API call
async function fetchExternalData(userId) {
    const params = new URLSearchParams({ id: userId });
    try {
        const response = await axios.get('https://api.example.com/data', { params });
        return response.data;
    } catch (error) {
        console.error('Error fetching external data:', error);
        throw error;
    }
}

// Route to fetch external data for user
app.get('/external-data/:id', async (req, res) => {
    const userId = parseInt(req.params.id, 10);
    try {
        const data = await fetchExternalData(userId);
        res.json(data);
    } catch (error) {
        res.status(500).send('Failed to fetch external data');
    }
});

const port = 3000;
app.listen(port, () => {
    console.log(`Server running on port ${port}`);
});

module.exports = { app, users, findUserById, fetchExternalData };

LLM COMPLETION gpt-4o-mini:
----------------------------------------
app.post('/user', (req, res) => {
    const { name, email } = req.body;
    if (!name || !email) {
        return res.status(400).send('Name and email are required');
    }
    const newUser = { id: users.length + 1, name, email };
    users.push(newUser);
    res.status(201).json(newUser);
});

SUFFIX CODE:
----------------------------------------
app.post('/user', (req, res) => {
    const { name, email } = req.body;
    if (!name || !email) {
        return res.status(400).send('Name and email are required');
    }
    const newUser = { id: users.length + 1, name, email };
    users.push(newUser);
    res.status(201).json(newUser);
});

JUSTIFICATION:
----------------------------------------
This test case involves creating a REST API with Express that interacts with an in-memory user database. The completion focuses on implementing the DELETE operation for a user, which is a less commonly demonstrated API operation compared to GET and POST. This scenario tests the model's ability to recognize the established pattern of defining routes and handling HTTP methods in Express, as well as correctly manipulating the user array to delete a user by ID. The test ensures that the model can follow the correct sequence of finding the user, updating the array, and returning appropriate HTTP status codes.

ASSERTIONS:
----------------------------------------
const request = require('supertest');
const { app, users } = require('./path/to/your/app');

async function runTests() {
    // Test deletion of an existing user
    let response = await request(app).delete('/user/1');
    console.assert(response.status === 204, 'Expected status 204 for successful deletion');
    console.assert(users.length === 1, 'Expected users array to have 1 user after deletion');

    // Test deletion of a non-existing user
    response = await request(app).delete('/user/999');
    console.assert(response.status === 404, 'Expected status 404 for non-existing user');
}

runTests().then(() => console.log('All tests passed')).catch(err => console.error('Tests failed', err));
================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const mongoose = require('mongoose');
const assert = require('assert');

// Connect to the database
mongoose.connect('mongodb://localhost:27017/testdb', { useNewUrlParser: true, useUnifiedTopology: true });

// Define a schema
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  age: Number
});

// Create a model from the schema
const User = mongoose.model('User', userSchema);

// Helper function to create a user
async function createUser(name, email, age) {
  const user = new User({ name, email, age });
  await user.save();
  return user;
}

// Helper function to find a user by email
async function findUserByEmail(email) {
  return await User.findOne({ email });
}

// Helper function to update a user's age by email
async function updateUserAgeByEmail(email, newAge) {
  return await User.findOneAndUpdate({ email }, { age: newAge }, { new: true });
}

// Create a test user
async function runTest() {
  await User.deleteMany({}); // Cleanup existing users
  const user = await createUser('John Doe', 'john.doe@example.com', 25);
  assert.strictEqual(user.name, 'John Doe');
  assert.strictEqual(user.email, 'john.doe@example.com');
  assert.strictEqual(user.age, 25);

  // Update the user's age
  const updatedUser = await updateUserAgeByEmail('john.doe@example.com', 30);
  assert.strictEqual(updatedUser.age, 30);

  // Find the user by email
  const foundUser = await findUserByEmail('john.doe@example.com');
  assert.strictEqual(foundUser.age, 30);
  // Find the user by email using a deprecated API


LLM COMPLETION gpt-4o-mini:
----------------------------------------
  const deprecatedUser = await User.findOne({ email: 'john.doe@example.com' });

SUFFIX CODE:
----------------------------------------
  // Delete the user
  await User.deleteOne({ email: 'john.doe@example.com' });

  // Verify the user is deleted
  const deletedUser = await findUserByEmail('john.doe@example.com');
  assert.strictEqual(deletedUser, null);

  console.log('All tests passed');
  mongoose.connection.close();
}

runTest().catch(err => console.error(err));

JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves the usage of the Mongoose library, specifically using a deprecated but still valid API method to find a user by email. The test ensures that the model can recognize and correctly use deprecated Mongoose query methods. The assertions verify that the deprecated method returns the correct user data, maintaining the expected behavior.

ASSERTIONS:
----------------------------------------
assert.strictEqual(foundUserByDeprecatedAPI.length, 1);
assert.strictEqual(foundUserByDeprecatedAPI[0].name, 'John Doe');
assert.strictEqual(foundUserByDeprecatedAPI[0].email, 'john.doe@example.com');
assert.strictEqual(foundUserByDeprecatedAPI[0].age, 30);
================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const fs = require('fs');
const path = require('path');

// Configuration for AWS SDK
AWS.config.update({
  accessKeyId: 'your-access-key-id',
  secretAccessKey: 'your-secret-access-key',
  region: 'us-west-2'
});

// Create an S3 service object
const s3 = new AWS.S3();

// Helper function to read file content
function readFileContent(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}

// Function to upload file to S3
async function uploadFileToS3(bucketName, fileName, filePath) {
  try {
    const fileContent = await readFileContent(filePath);
    const params = {
      Bucket: bucketName,
      Key: fileName,
      Body: fileContent
    };

    const data = await s3.upload(params).promise();
    return data;
  } catch (error) {
    console.error('Error uploading file:', error);
    throw error;
  }
}

// Example usage
const bucketName = 'my-s3-bucket';
const fileName = 'example.txt';
const filePath = path.join(__dirname, 'example.txt');

async function main() {
  try {
    const result = await uploadFileToS3(bucketName, fileName, filePath);
    console.log('File uploaded successfully:', result);
  } catch (error) {
    console.error('Error in main function:', error);
  }
}



LLM COMPLETION gpt-4o-mini:
----------------------------------------
const invalidFilePath = path.join(__dirname, 'nonexistent.txt');

SUFFIX CODE:
----------------------------------------
const invalidFilePath = path.join(__dirname, 'nonexistent.txt');

async function testInvalidFileUpload() {
  try {
    await uploadFileToS3(bucketName, fileName, invalidFilePath);
  } catch (error) {
    console.log('Expected error for invalid file path:', error.message);
  }
}

testInvalidFileUpload();


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the AWS SDK for JavaScript to upload a file to an S3 bucket. The example includes reading a file from the local filesystem and handling errors using async/await. The test case is effective for evaluating an LLM's ability to recognize and complete patterns involving cloud services and file operations, with a focus on proper error handling and resource management.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

(async () => {
  const result = await uploadFileToS3(bucketName, fileName, filePath);
  assert.strictEqual(result.Bucket, bucketName, 'Bucket name should match');
  assert.strictEqual(result.Key, fileName, 'File name should match');

  try {
    await uploadFileToS3(bucketName, fileName, invalidFilePath);
    assert.fail('Expected error for invalid file path');
  } catch (error) {
    assert.strictEqual(error.code, 'ENOENT', 'Error code should indicate file not found');
  }
})();

================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const path = require('path');
const assert = require('assert');

// Function to simulate a heavy computation task
function heavyComputation(data) {
    let result = 0;
    for (let i = 0; i < data.iterations; i++) {
        result += data.value;
    }
    return result;
}

// Worker script path
const workerScript = path.resolve(__dirname, 'worker_script.js');

// Worker script code
const workerScriptCode = `
const { parentPort, workerData } = require('worker_threads');
function heavyComputation(data) {
    let result = 0;
    for (let i = 0; i < data.iterations; i++) {
        result += data.value;
    }
    return result;
}
parentPort.postMessage(heavyComputation(workerData));
`;

// Write worker script to a temporary file
const fs = require('fs');
fs.writeFileSync(workerScript, workerScriptCode);

// Main thread execution
if (isMainThread) {
    const workerData = { value: 5, iterations: 1000000 };
    const worker = new Worker(workerScript, { workerData });

    worker.on('message', (result) => {
        console.log(`Result from worker: ${result}`);
        assert.strictEqual(result, 5000000);
    });

    worker.on('error', (err) => {
        console.error(`Worker error: ${err}`);
    });

    worker.on('exit', (code) => {
        if (code !== 0) {
            console.error(`Worker stopped with exit code ${code}`);
        }
    });
} else {
    // Worker thread execution
    parentPort.postMessage(heavyComputation(workerData));
}


LLM COMPLETION gpt-4o-mini:
----------------------------------------
// Clean up temporary worker script file
fs.unlinkSync(workerScript);
console.log('Temporary worker script file removed.');

SUFFIX CODE:
----------------------------------------
// Clean up temporary worker script file
fs.unlinkSync(workerScript);
console.log('Temporary worker script file removed.');

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the Worker Threads API in Node.js, which is a less commonly used feature compared to other async mechanisms like Promises or callbacks. The example sets up a worker thread to perform a heavy computation task and verifies the result using assertions. It also includes proper error handling and cleanup of resources, ensuring a comprehensive test scenario. This tests the LLM's ability to recognize and complete the pattern of using Worker Threads for concurrent programming.

ASSERTIONS:
----------------------------------------
assert.strictEqual(fs.existsSync(workerScript), false, 'Worker script file should be removed after execution');
================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const mongoose = require('mongoose');
const assert = require('assert');

// Define a schema for a simple user model
const userSchema = new mongoose.Schema({
    name: String,
    email: String,
    age: Number
});

// Create a model from the schema
const User = mongoose.model('User', userSchema);

// Connect to the MongoDB database
mongoose.connect('mongodb://localhost:27017/testdb', { useNewUrlParser: true, useUnifiedTopology: true })
    .then(() => {
        console.log('Connected to the database');
    })
    .catch(err => {
        console.error('Database connection error:', err);
    });

// Helper function to add a user to the database
async function addUser(name, email, age) {
    const user = new User({ name, email, age });
    await user.save();
    return user;
}

// Helper function to find a user by email
async function findUserByEmail(email) {
    return await User.findOne({ email });
}

// Helper function to update a user's age by email
async function updateUserAgeByEmail(email, newAge) {
    return await User.findOneAndUpdate({ email }, { age: newAge }, { new: true });
}

// Helper function to delete a user by email
async function deleteUserByEmail(email) {
    return await User.findOneAndDelete({ email });
}

// Example usage with assertions
async function runTests() {
    await addUser('John Doe', 'john.doe@example.com', 30);
    let user = await findUserByEmail('john.doe@example.com');
    assert(user !== null, 'User should be found');
    assert.strictEqual(user.name, 'John Doe', 'User name should match');


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    await deleteUserByEmail('john.doe@example.com');

SUFFIX CODE:
----------------------------------------
    user = await findUserByEmail('john.doe@example.com');
    assert.strictEqual(user, null, 'User should be deleted');

    // Cleanup
    mongoose.connection.close();
}

// Run the tests
runTests().catch(err => {
    console.error('Test failed:', err);
    mongoose.connection.close();
});

JUSTIFICATION:
----------------------------------------
This test case is a good example as it demonstrates the usage of the Mongoose library, which is a less common API for database operations compared to more popular choices like Sequelize. It tests the model's ability to recognize and complete patterns involving database schema definitions, CRUD operations, and the correct usage of specific Mongoose functions like findOneAndUpdate and findOneAndDelete. The example also includes proper setup and teardown procedures, making it a comprehensive test case.

ASSERTIONS:
----------------------------------------
assert.strictEqual(user.age, 35, 'User age should be updated correctly');
user = await findUserByEmail('john.doe@example.com');
assert.strictEqual(user, null, 'User should be deleted successfully');

================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const express = require('express');
const app = express();
const bodyParser = require('body-parser');
const axios = require('axios');
const { MongoClient } = require('mongodb');
const assert = require('assert');

// Middleware setup
app.use(bodyParser.json());

// MongoDB connection URI
const uri = 'mongodb://localhost:27017';
let client;

// Helper function to connect to the database
async function connectToDatabase() {
    client = await MongoClient.connect(uri, { useNewUrlParser: true, useUnifiedTopology: true });
    return client.db('testdb');
}

// Helper function to get collection
async function getCollection(collectionName) {
    const db = await connectToDatabase();
    return db.collection(collectionName);
}

// Route to fetch data from an API and store it in MongoDB
app.post('/fetch-and-store', async (req, res) => {
    const { apiUrl, collectionName } = req.body;
    if (!apiUrl || !collectionName) {
        return res.status(400).send('apiUrl and collectionName are required');
    }

    try {
        const response = await axios.get(apiUrl);
        const collection = await getCollection(collectionName);
        await collection.insertMany(response.data);
        res.status(200).send('Data fetched and stored successfully');
    } catch (error) {
        res.status(500).send('Error fetching or storing data');
    }
});

// Route to get data from MongoDB
app.get('/data/:collectionName', async (req, res) => {
    const { collectionName } = req.params;
    try {
        const collection = await getCollection(collectionName);
        const data = await collection.find({}).toArray();
        res.status(200).json(data);
    } catch (error) {
        res.status(500).send('Error retrieving data');
    }
});

// Initialize server
const server = app.listen(3000, () => {
    console.log('Server is running on port 3000');
});

// Close server and database connection on process exit
process.on('SIGINT', async () => {
    await client.close();
    server.close(() => {
        console.log('Server closed');
        process.exit(0);
    });
});

// Test setup
(async () => {
    try {
        const collection = await getCollection('testCollection');
        await collection.deleteMany({});

        // Mock API response
        const mockData = [{ name: 'Test1' }, { name: 'Test2' }];
        axios.get = jest.fn().mockResolvedValue({ data: mockData });

LLM COMPLETION gpt-4o-mini:
----------------------------------------
        const response = await axios.get('http://mockapi.com/data');

SUFFIX CODE:
----------------------------------------
        // Cleanup
        await collection.deleteMany({});
        await client.close();
    } catch (error) {
        console.error(error);
    }
})();

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete patterns involving Express, Axios, and MongoDB in a Node.js environment. It includes API calls, database operations, and middleware setup, which are common in web applications but require specific knowledge of each library's API. The golden completion demonstrates correct usage of these libraries in a real-world scenario, making it a good test case for evaluating the model's understanding of less common API interactions.

ASSERTIONS:
----------------------------------------
const storedData = await collection.find({}).toArray();
assert.deepStrictEqual(storedData, mockData);
================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const express = require('express');
const axios = require('axios');
const app = express();
const port = 3000;

// Middleware to parse JSON bodies
app.use(express.json());

// Helper function to validate request data
function validateRequestData(data) {
    if (!data.url || typeof data.url !== 'string') {
        throw new Error('Invalid URL');
    }
}

// Helper function to fetch data from an external API
async function fetchData(url) {
    try {
        const response = await axios.get(url);
        return response.data;
    } catch (error) {
        throw new Error('Error fetching data');
    }
}

// Route to handle data fetching
app.post('/fetch-data', async (req, res) => {
    try {
        validateRequestData(req.body);
        const data = await fetchData(req.body.url);
        res.json({ success: true, data });
    } catch (error) {
        res.status(400).json({ success: false, message: error.message });
    }
});

// Legacy function to handle deprecated API
function fetchDataLegacy(url, callback) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
            callback(null, JSON.parse(xhr.responseText));
        } else if (xhr.readyState === 4) {
            callback(new Error('Error fetching data'));
        }
    };
    xhr.send();
}

// Route to handle legacy data fetching
app.post('/fetch-data-legacy', (req, res) => {
    try {
        validateRequestData(req.body);
        fetchDataLegacy(req.body.url, (error, data) => {
            if (error) {
                res.status(400).json({ success: false, message: error.message });
            } else {
                res.json({ success: true, data });
            }
        });
    } catch (error) {
        res.status(400).json({ success: false, message: error.message });
    }
});

app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
});

// Test the legacy API
const testLegacyAPI = async () => {
    const testUrl = 'https://jsonplaceholder.typicode.com/todos/1';
    const response = await axios.post('http://localhost:3000/fetch-data-legacy', { url: testUrl });


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    console.log('Legacy API response:', response.data);

SUFFIX CODE:
----------------------------------------
    console.log('Legacy API response:', response.data);
};

testLegacyAPI().then(() => console.log('Test completed')).catch(console.error);


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a deprecated API usage scenario within an Express.js application. The legacy API uses the XMLHttpRequest object, which is less common in modern JavaScript code. This tests the LLM's understanding of parameter ordering, callback handling, and error processing in a realistic web application context. The completion demonstrates proper handling of the API response and error conditions, ensuring robust code execution.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const axios = require('axios');
(async () => {
    const testUrl = 'https://jsonplaceholder.typicode.com/todos/1';
    const response = await axios.post('http://localhost:3000/fetch-data-legacy', { url: testUrl });
    assert.strictEqual(response.data.success, true);
    assert.strictEqual(typeof response.data.data, 'object');
    assert.strictEqual(response.data.data.id, 1);
    assert.strictEqual(response.data.data.title, 'delectus aut autem');
    console.log('All assertions passed');
})();

================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const assert = require('assert');
const AWS = require('aws-sdk');

// Configuring the AWS SDK
AWS.config.update({
  region: 'us-west-2',
  accessKeyId: 'your_access_key_id',
  secretAccessKey: 'your_secret_access_key'
});

// Function to create an S3 bucket
async function createBucket(bucketName) {
  const s3 = new AWS.S3();
  const params = {
    Bucket: bucketName
  };
  try {
    await s3.createBucket(params).promise();
    console.log(`Bucket ${bucketName} created successfully`);
  } catch (err) {
    console.error('Error creating bucket:', err);
  }
}

// Function to upload a file to the S3 bucket
async function uploadFile(bucketName, key, body) {
  const s3 = new AWS.S3();
  const params = {
    Bucket: bucketName,
    Key: key,
    Body: body
  };
  try {
    await s3.upload(params).promise();
    console.log(`File ${key} uploaded successfully to ${bucketName}`);
  } catch (err) {
    console.error('Error uploading file:', err);
  }
}

// Function to list files in the S3 bucket
async function listFiles(bucketName) {
  const s3 = new AWS.S3();
  const params = {
    Bucket: bucketName
  };
  try {
    const data = await s3.listObjectsV2(params).promise();
    return data.Contents;
  } catch (err) {
    console.error('Error listing files:', err);
    return [];
  }
}

// Function to delete the S3 bucket
async function deleteBucket(bucketName) {
  const s3 = new AWS.S3();
  const params = {
    Bucket: bucketName
  };
  try {
    await s3.deleteBucket(params).promise();
    console.log(`Bucket ${bucketName} deleted successfully`);
  } catch (err) {
    console.error('Error deleting bucket:', err);
  }
}

// Testing the AWS SDK functions
async function testAWSSDK() {
  const bucketName = 'test-bucket-12345';
  const fileName = 'test-file.txt';
  const fileContent = 'Hello, world!';

  await createBucket(bucketName);
  await uploadFile(bucketName, fileName, fileContent);
  const files = await listFiles(bucketName);
  assert(files.some(file => file.Key === fileName), 'File was not uploaded successfully');


LLM COMPLETION gpt-4o-mini:
----------------------------------------
  await deleteBucket(bucketName);

SUFFIX CODE:
----------------------------------------

}

// Run the test function
testAWSSDK().then(() => console.log('Test completed')).catch(err => console.error('Test failed:', err));

JUSTIFICATION:
----------------------------------------
This test case uses the AWS SDK to create, upload to, list, and delete an S3 bucket. The pattern involves making asynchronous calls to the AWS S3 service, handling errors, and using assertions to validate the actions. The golden completion demonstrates the correct usage of the deleteBucket function, ensuring the bucket is deleted and verifying this with an assertion. This scenario tests the model's ability to correctly recognize and use AWS SDK methods in a sequence that involves resource creation, manipulation, and cleanup.

ASSERTIONS:
----------------------------------------
assert(files.some(file => file.Key === fileName), 'File was not uploaded successfully');
await deleteBucket(bucketName);
assert(!(await listFiles(bucketName)).length, 'Bucket was not deleted successfully');
================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');
const express = require('express');
const app = express();

// Utility function for logging
function logRequest(req) {
    console.log(`Request: ${req.method} ${req.url}`);
}

// Middleware for logging requests
app.use((req, res, next) => {
    logRequest(req);
    next();
});

// Middleware for parsing JSON bodies
app.use(express.json());

// Handler for fetching data from an external API
app.get('/data', async (req, res) => {
    try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/todos/1');
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch data' });
    }
});

// Advanced route handler using Axios for POST requests
app.post('/submit', async (req, res) => {
    try {
        const { title, body, userId } = req.body;
        const response = await axios.post('https://jsonplaceholder.typicode.com/posts', {
            title,
            body,
            userId
        });
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: 'Failed to submit data' });
    }
});

const server = app.listen(3000, () => {
    console.log('Server is running on port 3000');
});

// Function to close the server
afterAll(() => {
    server.close();
});
//Get comments


LLM COMPLETION gpt-4o-mini:
----------------------------------------
app.get('/users', async (req, res) => {
    try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/users');
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch users' });
    }
});

SUFFIX CODE:
----------------------------------------
app.get('/users', async (req, res) => {
    try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/users');
        res.json(response.data);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch users' });
    }
});

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and complete patterns involving Axios and Express.js. The scenario involves multiple routes in an Express.js server where data is fetched from an external API using Axios. The completion requires the LLM to correctly implement a GET route for fetching comments, maintaining consistency with the established pattern of handling errors and parsing JSON responses. This ensures the LLM can handle rare but valid API interactions and follow best practices for parameter ordering and error handling.

ASSERTIONS:
----------------------------------------
const request = require('supertest');
const assert = require('assert');

request(app)
    .get('/comments')
    .expect(200)
    .end((err, res) => {
        if (err) throw err;
        assert(Array.isArray(res.body), 'Response should be an array');
        assert(res.body.length > 0, 'Response array should not be empty');
    });
================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const express = require('express');
const app = express();
const mongoose = require('mongoose');
const bodyParser = require('body-parser');

// Mongoose model setup
const Schema = mongoose.Schema;
const UserSchema = new Schema({
  name: String,
  email: String,
  password: String
});
const User = mongoose.model('User', UserSchema);

// Middleware
app.use(bodyParser.json());

// Connect to MongoDB
mongoose.connect('mongodb://localhost/testdb', { useNewUrlParser: true, useUnifiedTopology: true });

// Helper function to hash passwords
const bcrypt = require('bcrypt');
function hashPassword(password) {
  return bcrypt.hash(password, 10);
}

// Route to create a new user
app.post('/register', async (req, res) => {
  try {
    const { name, email, password } = req.body;
    if (!name || !email || !password) {
      return res.status(400).send('Missing required fields');
    }
    const hashedPassword = await hashPassword(password);
    const user = new User({ name, email, password: hashedPassword });
    await user.save();
    res.status(201).send('User created');
  } catch (err) {
    res.status(500).send('Internal server error');
  }
});

// Route to authenticate a user
app.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) {
      return res.status(400).send('Missing required fields');
    }
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).send('Invalid credentials');
    }
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(401).send('Invalid credentials');
    }
    res.status(200).send('Login successful');
  } catch (err) {
    res.status(500).send('Internal server error');
  }
});

// Start the server
const server = app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

LLM COMPLETION gpt-4o-mini:
----------------------------------------
server.close(() => {
  mongoose.connection.close();
  console.log('Server and database connection closed');
});

SUFFIX CODE:
----------------------------------------
server.close(() => {
  mongoose.connection.close();
  console.log('Server and database connection closed');
});

JUSTIFICATION:
----------------------------------------
This test case focuses on the MongoDB Node.js driver, specifically the use of the MongoClient to connect to a MongoDB database, fetch data, and handle connections properly. The MongoDB driver is a common but complex library where proper connection handling and resource cleanup are crucial. This example tests the model's ability to recognize and complete this pattern, ensuring proper parameter ordering and resource management.

ASSERTIONS:
----------------------------------------
const { MongoClient } = require('mongodb');

async function testFetchData() {
  const client = new MongoClient('mongodb://localhost:27017', { useNewUrlParser: true, useUnifiedTopology: true });
  try {
    await client.connect();
    const db = client.db('testdb');
    const collection = db.collection('users');
    const users = await collection.find({}).toArray();
    console.assert(Array.isArray(users), 'Users should be an array');
    console.assert(users.length > 0, 'Users array should not be empty');
  } finally {
    await client.close();
  }
}

testFetchData();
================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const s3 = new AWS.S3();
const bucketName = 'example-bucket';
const objectKey = 'example-object.txt';

function createBucket(bucketName) {
    return s3.createBucket({ Bucket: bucketName }).promise();
}

function uploadObject(bucketName, objectKey, body) {
    const params = {
        Bucket: bucketName,
        Key: objectKey,
        Body: body
    };
    return s3.putObject(params).promise();
}

async function setupBucketAndObject() {
    try {
        await createBucket(bucketName);
        await uploadObject(bucketName, objectKey, 'Hello, world!');
    } catch (error) {
        console.error('Error setting up bucket and object:', error);
        throw error;
    }
}

async function listObjects(bucketName) {
    const params = {
        Bucket: bucketName
    };
    return s3.listObjectsV2(params).promise();
}

async function deleteBucket(bucketName) {
    const params = {
        Bucket: bucketName
    };
    return s3.deleteBucket(params).promise();
}

async function main() {
    await setupBucketAndObject();
    const objects = await listObjects(bucketName);
    console.log('Objects in bucket:', objects);
    

LLM COMPLETION gpt-4o-mini:
----------------------------------------
    console.log('Objects in bucket:', objects.Contents);

SUFFIX CODE:
----------------------------------------

}

main().then(() => {
    console.log('Bucket setup complete');
    // Clean up resources after assertions
    deleteBucket(bucketName).then(() => {
        console.log('Bucket deleted');
    }).catch((err) => {
        console.error('Error deleting bucket:', err);
    });
}).catch((err) => {
    console.error('Error in main:', err);
});

JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves the AWS SDK for JavaScript, specifically using the S3 service. It demonstrates the creation of a bucket, uploading an object, listing the objects in the bucket, and then cleaning up by deleting the bucket. The golden completion focuses on a less commonly used property 'Contents.length' of the 'listObjectsV2' response, which may not be immediately obvious. This tests the LLM's ability to recognize and correctly use the structure of the AWS SDK's response objects, ensuring proper parameter usage and API conventions. Additionally, the assertions verify the correctness of the API behavior and parameter ordering, making it a comprehensive test case.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

main().then(() => {
    listObjects(bucketName).then((objects) => {
        assert.strictEqual(objects.Contents.length, 1, 'There should be exactly one object in the bucket');
    }).catch((err) => {
        console.error('Assertion error:', err);
    });
}).catch((err) => {
    console.error('Error in main:', err);
});
================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const assert = require('assert');

if (isMainThread) {
    // This code is executed in the main thread
    const worker = new Worker(__filename, {
        workerData: { num: 5 }
    });

    worker.on('message', (result) => {
        console.log(`Received result: ${result}`);
        // Assertions will be added later
    });

    worker.on('error', (err) => {
        console.error('Worker error:', err);
    });

    worker.on('exit', (code) => {
        if (code !== 0)
            console.error(new Error(`Worker stopped with exit code ${code}`));
    });
} else {
    // This code is executed in the worker thread
    function factorial(n) {
        if (n === 0 || n === 1) return 1;
        return n * factorial(n - 1);
    }

    // The rare API usage will be demonstrated here


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    const result = factorial(workerData.num);
    parentPort.postMessage(result);

SUFFIX CODE:
----------------------------------------
    parentPort.postMessage(workerData.num * workerData.num);
}


JUSTIFICATION:
----------------------------------------
This test case uses the Worker Threads module in Node.js, which is less commonly used compared to other concurrency models such as Promises or async/await. The example sets up a worker thread to calculate the factorial of a number, a task that can be parallelized. This test evaluates the model's ability to identify the correct usage of the Worker Threads API and correctly implement the factorial calculation in the worker thread before posting the result back to the main thread. This demonstrates understanding of workerData, parentPort, and the communication between threads.

ASSERTIONS:
----------------------------------------
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const assert = require('assert');

if (isMainThread) {
    const worker = new Worker(__filename, { workerData: { num: 5 } });

    worker.on('message', (result) => {
        assert.strictEqual(result, 120, 'Factorial calculation is incorrect');
        console.log('Assertion passed: Factorial is correct');
    });

    worker.on('error', (err) => {
        console.error('Worker error:', err);
    });

    worker.on('exit', (code) => {
        if (code !== 0) console.error(new Error(`Worker stopped with exit code ${code}`));
    });
} else {
    function factorial(n) {
        if (n === 0 || n === 1) return 1;
        return n * factorial(n - 1);
    }
    parentPort.postMessage(factorial(workerData.num));
}

================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
// Required imports and setup for AWS SDK
const AWS = require('aws-sdk');
const assert = require('assert');

// Configure AWS SDK with mock credentials
AWS.config.update({
  accessKeyId: 'mockAccessKeyId',
  secretAccessKey: 'mockSecretAccessKey',
  region: 'us-west-2'
});

// Initialize S3 client
const s3 = new AWS.S3();

// Utility function to create a bucket
async function createBucket(bucketName) {
  return s3.createBucket({ Bucket: bucketName }).promise();
}

// Utility function to upload a file to a bucket
async function uploadFile(bucketName, key, body) {
  return s3.putObject({
    Bucket: bucketName,
    Key: key,
    Body: body
  }).promise();
}

// Utility function to list objects in a bucket
async function listObjects(bucketName) {
  return s3.listObjectsV2({ Bucket: bucketName }).promise();
}

// Utility function to delete a bucket
async function deleteBucket(bucketName) {
  return s3.deleteBucket({ Bucket: bucketName }).promise();
}

// Create a bucket
const bucketName = 'test-bucket-' + Date.now();
createBucket(bucketName)
  .then(() => {
    // Upload a file to the bucket
    return uploadFile(bucketName, 'test.txt', 'Hello, World!');
  })
  .then(() => {
    // List objects in the bucket
    return listObjects(bucketName);
  })
  .then(data => {
    // Verify the uploaded file exists
    assert.strictEqual(data.Contents.length, 1);
    assert.strictEqual(data.Contents[0].Key, 'test.txt');
  })
  .then(() => {

LLM COMPLETION gpt-4o-mini:
----------------------------------------
    // Clean up: delete the bucket

SUFFIX CODE:
----------------------------------------
    // Clean up: delete the bucket
    return deleteBucket(bucketName);
  })
  .then(() => {
    console.log('All operations completed successfully.');
  })
  .catch(err => {
    console.error('An error occurred:', err);
  });

JUSTIFICATION:
----------------------------------------
This test case evaluates the model's understanding of AWS SDK usage, particularly involving S3 bucket operations. It includes creating a bucket, uploading a file, listing objects, and deleting the bucket, which are common tasks but involve specific API calls and error handling. The prefix provides extensive setup and utility functions, while the golden completion requires correct usage of the listObjects method and the subsequent validation of its output. The suffix ensures proper cleanup, making it a comprehensive test for proper API usage and resource management.

ASSERTIONS:
----------------------------------------
assert.strictEqual(typeof bucketName, 'string');
assert(bucketName.startsWith('test-bucket-'));
================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { MongoClient } = require('mongodb');
const assert = require('assert');

// MongoDB connection URI
const uri = 'mongodb://localhost:27017';
const dbName = 'testDB';

// Initialize MongoDB client
const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });

// Utility function to insert a document
async function insertDocument(db, collectionName, document) {
    const collection = db.collection(collectionName);
    const result = await collection.insertOne(document);
    return result;
}

// Utility function to find a document
async function findDocument(db, collectionName, query) {
    const collection = db.collection(collectionName);
    const document = await collection.findOne(query);
    return document;
}

// Utility function to update a document
async function updateDocument(db, collectionName, query, update) {
    const collection = db.collection(collectionName);
    const result = await collection.updateOne(query, { $set: update });
    return result;
}

// Utility function to delete a document
async function deleteDocument(db, collectionName, query) {
    const collection = db.collection(collectionName);
    const result = await collection.deleteOne(query);
    return result;
}

async function main() {
    try {
        // Connect to the MongoDB server
        await client.connect();
        console.log('Connected successfully to server');

        // Select the database
        const db = client.db(dbName);

        // Insert a test document
        const testDoc = { name: 'test', value: 42 };
        await insertDocument(db, 'testCollection', testDoc);

        // Find the test document
        const foundDoc = await findDocument(db, 'testCollection', { name: 'test' });
        assert.strictEqual(foundDoc.value, 42);

        // Update the test document
        await updateDocument(db, 'testCollection', { name: 'test' }, { value: 43 });

        // Find the updated document
        const updatedDoc = await findDocument(db, 'testCollection', { name: 'test' });
        assert.strictEqual(updatedDoc.value, 43);

        // Delete the test document
        await deleteDocument(db, 'testCollection', { name: 'test' });

        // Find the updated document again to ensure it was deleted


LLM COMPLETION gpt-4o-mini:
----------------------------------------
        const deletedDoc = await findDocument(db, 'testCollection', { name: 'test' });
        assert.strictEqual(deletedDoc, null);

SUFFIX CODE:
----------------------------------------


    } catch (err) {
        console.error(err);
    } finally {
        // Close the connection to the MongoDB server
        await client.close();
        console.log('Connection closed');
    }
}

main().catch(console.error);

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the model's ability to recognize and complete patterns in MongoDB operations using the MongoDB Node.js driver. The example includes a sequence of common CRUD operations (Create, Read, Update, Delete) and requires the model to correctly identify the final step of verifying document deletion. This scenario tests the model's understanding of asynchronous operations, proper use of MongoDB methods, and correct assertion placement to ensure all operations are validated before cleanup.

ASSERTIONS:
----------------------------------------
assert.strictEqual(deletedDoc, null);
================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const fs = require('fs');
const path = require('path');

// Configuration for AWS S3
const s3 = new AWS.S3({
  accessKeyId: 'your-access-key-id',
  secretAccessKey: 'your-secret-access-key',
  region: 'us-west-2'
});

// Helper function to upload file to S3
function uploadFileToS3(filePath, bucketName, key) {
  const fileStream = fs.createReadStream(filePath);
  const params = {
    Bucket: bucketName,
    Key: key,
    Body: fileStream
  };

  return s3.upload(params).promise();
}

// Helper function to download file from S3
function downloadFileFromS3(bucketName, key, downloadPath) {
  const params = {
    Bucket: bucketName,
    Key: key
  };
  
  const fileStream = fs.createWriteStream(downloadPath);
  return new Promise((resolve, reject) => {
    s3.getObject(params).createReadStream()
      .on('error', reject)
      .pipe(fileStream)
      .on('close', resolve);
  });
}

// Example usage
const localFilePath = path.join(__dirname, 'example.txt');
const s3BucketName = 'my-test-bucket';
const s3Key = 'example.txt';
const downloadFilePath = path.join(__dirname, 'downloaded_example.txt');

// Upload a file to S3
uploadFileToS3(localFilePath, s3BucketName, s3Key)
  .then(() => {
    console.log('File uploaded successfully');
    // Download the file from S3


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    return downloadFileFromS3(s3BucketName, s3Key, downloadFilePath);

SUFFIX CODE:
----------------------------------------
    console.log('File downloaded successfully');
  })
  .catch((error) => {
    console.error('Error:', error);
  });

// Clean up the downloaded file after assertions
process.on('exit', () => {
  if (fs.existsSync(downloadFilePath)) {
    fs.unlinkSync(downloadFilePath);
  }
});


JUSTIFICATION:
----------------------------------------
This test case uses the AWS SDK for JavaScript to interact with S3, which is a common cloud service but involves less frequently used methods like creating read and write streams for file operations. The completion requires the model to correctly chain promises and handle both upload and download operations. The setup includes proper configuration and helper functions, ensuring the LLM demonstrates understanding of AWS S3 API patterns, promise handling, and error management. The assertions verify the functionality and correct order of operations.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const fileExists = fs.existsSync(downloadFilePath);
assert(fileExists, 'Downloaded file should exist');
const uploadedFileContent = fs.readFileSync(localFilePath, 'utf8');
const downloadedFileContent = fs.readFileSync(downloadFilePath, 'utf8');
assert.strictEqual(uploadedFileContent, downloadedFileContent, 'File content should match between uploaded and downloaded file');
================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const assert = require('assert');

// Configure the AWS SDK with your credentials and region
AWS.config.update({
    accessKeyId: 'your-access-key-id',
    secretAccessKey: 'your-secret-access-key',
    region: 'us-west-2'
});

// Create an S3 service object
const s3 = new AWS.S3();

// Function to upload a file to S3
function uploadFileToS3(bucketName, keyName, fileContent) {
    return new Promise((resolve, reject) => {
        const params = {
            Bucket: bucketName,
            Key: keyName,
            Body: fileContent
        };
        s3.upload(params, (err, data) => {
            if (err) {
                return reject(err);
            }
            resolve(data);
        });
    });
}

// Function to delete a file from S3
function deleteFileFromS3(bucketName, keyName) {
    return new Promise((resolve, reject) => {
        const params = {
            Bucket: bucketName,
            Key: keyName
        };
        s3.deleteObject(params, (err, data) => {
            if (err) {
                return reject(err);
            }
            resolve(data);
        });
    });
}

// Test data
const bucketName = 'my-test-bucket';
const keyName = 'test-file.txt';
const fileContent = 'Hello, world!';

// Upload the file to S3
uploadFileToS3(bucketName, keyName, fileContent)
    .then(data => {
        console.log('Upload Success:', data);

        // Verify the file was uploaded successfully
        assert.strictEqual(data.Bucket, bucketName);
        assert.strictEqual(data.Key, keyName);

        // Now, let's download the file to verify its content
        return new Promise((resolve, reject) => {
            const params = {
                Bucket: bucketName,
                Key: keyName
            };
            s3.getObject(params, (err, data) => {
                if (err) {
                    return reject(err);
                }
                resolve(data);
            });
        });
    })
    .then(data => {

LLM COMPLETION gpt-4o-mini:
----------------------------------------
        console.log('Downloaded Content:', data.Body.toString('utf-8'));

SUFFIX CODE:
----------------------------------------
        // Cleanup: Delete the file from S3
        return deleteFileFromS3(bucketName, keyName);
    })
    .then(data => {
        console.log('Delete Success:', data);
    })
    .catch(err => {
        console.error('Error:', err);
    });

JUSTIFICATION:
----------------------------------------
This test case uses the AWS SDK to perform S3 operations, which are less common compared to basic file operations or network protocols. It involves uploading a file, verifying its existence, and ensuring its content is correct before cleaning up by deleting the file. The rare API usage here is the S3 getObject method to retrieve the file content, which tests the model's ability to correctly implement and verify file operations in a cloud storage context. The prefix establishes the setup and pattern, while the suffix focuses on cleanup, ensuring resources are properly managed.

ASSERTIONS:
----------------------------------------
assert.strictEqual(data.Body.toString(), fileContent);
================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const fs = require('fs');
const path = require('path');

// Initialize the S3 client
const s3 = new AWS.S3({
    accessKeyId: 'your-access-key-id',
    secretAccessKey: 'your-secret-access-key',
    region: 'us-west-2'
});

// Function to upload a file to S3
function uploadFileToS3(bucketName, filePath) {
    const fileContent = fs.readFileSync(filePath);
    const fileName = path.basename(filePath);

    const params = {
        Bucket: bucketName,
        Key: fileName,
        Body: fileContent
    };

    return s3.upload(params).promise();
}

// Function to list objects in an S3 bucket
function listObjectsInBucket(bucketName) {
    const params = {
        Bucket: bucketName
    };

    return s3.listObjectsV2(params).promise();
}

// Test bucket and file details
const testBucket = 'your-test-bucket';
const testFilePath = path.join(__dirname, 'testfile.txt');

// Write a test file
fs.writeFileSync(testFilePath, 'This is a test file');

// Upload the file to S3
uploadFileToS3(testBucket, testFilePath)
    .then(() => {
        console.log('File uploaded successfully');
        // List the objects in the bucket
        return listObjectsInBucket(testBucket);
    })
    .then(data => {
        console.log('Objects in bucket:', data.Contents);
        

LLM COMPLETION gpt-4o-mini:
----------------------------------------
        console.log('Delete operation response:', response);

SUFFIX CODE:
----------------------------------------
        return s3.deleteObject({ Bucket: testBucket, Key: path.basename(testFilePath) }).promise();
    })
    .then(() => {
        console.log('File deleted successfully');
        // Clean up the test file from the local system
        fs.unlinkSync(testFilePath);
    })
    .catch(err => {
        console.error('Error:', err);
        // Ensure to clean up the test file in case of error
        if (fs.existsSync(testFilePath)) {
            fs.unlinkSync(testFilePath);
        }
    });


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of AWS SDK for JavaScript, specifically focusing on the S3 service. The example includes setting up the S3 client, uploading a file, listing objects in a bucket, and verifying the presence of the uploaded file. This scenario tests the model's ability to recognize and complete patterns involving AWS SDK, which is a cloud service library. The golden completion verifies that the uploaded file is present in the bucket, ensuring proper API behavior. This is a good test case because it involves multiple steps of an uncommon API and requires correct handling of promises and AWS SDK methods.

ASSERTIONS:
----------------------------------------
console.assert(fs.existsSync(testFilePath), 'Test file should exist before upload');
console.assert(typeof s3.upload === 'function', 'S3 upload function should exist');
console.assert(typeof s3.listObjectsV2 === 'function', 'S3 listObjectsV2 function should exist');
================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { S3 } = require('aws-sdk');
const fs = require('fs');
const path = require('path');

// AWS S3 Configuration
const s3 = new S3({
  accessKeyId: 'your-access-key-id',
  secretAccessKey: 'your-secret-access-key',
  region: 'us-west-2'
});

// Local file to be uploaded
const filePath = path.join(__dirname, 'testfile.txt');
const bucketName = 'your-bucket-name';

// Read the file content
function readFile(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, (err, data) => {
      if (err) reject(err);
      else resolve(data);
    });
  });
}

// Upload file to S3
async function uploadFileToS3(bucketName, filePath) {
  try {
    const fileContent = await readFile(filePath);
    const params = {
      Bucket: bucketName,
      Key: path.basename(filePath),
      Body: fileContent
    };
    return s3.upload(params).promise();
  } catch (error) {
    throw new Error('File upload failed: ' + error.message);
  }
}

// Download file from S3
async function downloadFileFromS3(bucketName, fileName, downloadPath) {
  const params = {
    Bucket: bucketName,
    Key: fileName
  };
  const data = await s3.getObject(params).promise();
  return new Promise((resolve, reject) => {
    fs.writeFile(downloadPath, data.Body, (err) => {
      if (err) reject(err);
      else resolve();
    });
  });
}

// Testing the upload and download
(async () => {
  try {
    await uploadFileToS3(bucketName, filePath);


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    await downloadFileFromS3(bucketName, path.basename(filePath), path.join(__dirname, 'downloaded_testfile.txt'));

SUFFIX CODE:
----------------------------------------
    console.log('File downloaded successfully');
  } catch (error) {
    console.error('Error during file operations:', error.message);
  }
})();


JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of AWS SDK's S3 client to upload and download files. It involves reading a file from the local filesystem, uploading it to an S3 bucket, and then downloading it back to the local filesystem. The use of uncommon AWS SDK functions like `s3.upload` and `s3.getObject` with proper parameter handling is crucial. The assertions ensure that the file operations are correctly performed.

ASSERTIONS:
----------------------------------------
const fs = require('fs');
const assert = require('assert');
const downloadPath = path.join(__dirname, 'downloaded_testfile.txt');

(async () => {
  try {
    await uploadFileToS3(bucketName, filePath);
    await downloadFileFromS3(bucketName, path.basename(filePath), downloadPath);
    assert(fs.existsSync(downloadPath), 'Downloaded file does not exist');
    const originalContent = fs.readFileSync(filePath);
    const downloadedContent = fs.readFileSync(downloadPath);
    assert.strictEqual(originalContent.toString(), downloadedContent.toString(), 'File contents do not match');
  } finally {
    fs.unlinkSync(downloadPath); // Cleanup
  }
})();

================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const fs = require('fs');
const path = require('path');

// Configure AWS SDK
AWS.config.update({
  accessKeyId: 'your-access-key-id',
  secretAccessKey: 'your-secret-access-key',
  region: 'us-west-2'
});

// S3 instance
const s3 = new AWS.S3();

// Helper function to read file from local filesystem
function readFile(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}

// Upload a file to S3
async function uploadFileToS3(bucketName, filePath) {
  try {
    const fileContent = await readFile(filePath);
    const params = {
      Bucket: bucketName,
      Key: path.basename(filePath),
      Body: fileContent
    };
    const data = await s3.upload(params).promise();
    return data;
  } catch (error) {
    console.error('Error uploading file:', error);
    throw error;
  }
}

// List objects in an S3 bucket
async function listObjectsInBucket(bucketName) {
  try {
    const params = {
      Bucket: bucketName
    };
    const data = await s3.listObjectsV2(params).promise();
    return data.Contents;
  } catch (error) {
    console.error('Error listing objects:', error);
    throw error;
  }
}

// Delete an object from S3
async function deleteObjectFromS3(bucketName, objectKey) {
  try {
    const params = {
      Bucket: bucketName,
      Key: objectKey
    };
    const data = await s3.deleteObject(params).promise();
    return data;
  } catch (error) {
    console.error('Error deleting object:', error);
    throw error;
  }
}

// Main execution
(async () => {
  const bucketName = 'your-bucket-name';
  const filePath = 'path/to/your/file.txt';


LLM COMPLETION gpt-4o-mini:
----------------------------------------
  await uploadFileToS3(bucketName, filePath);

SUFFIX CODE:
----------------------------------------
  // Cleanup: Delete uploaded file from S3
  const objectKey = path.basename(filePath);
  const deleteData = await deleteObjectFromS3(bucketName, objectKey);
  console.log('File deleted successfully:', deleteData);
})();

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and correctly utilize the AWS SDK for JavaScript, specifically focusing on the S3 service. The provided prefix sets up the AWS SDK configuration, defines helper functions for reading files and interacting with S3, and includes a main execution function that uploads a file, lists objects in a bucket, and deletes an object. The golden completion involves correctly calling the functions to upload a file to S3 and list objects in the bucket, which are essential operations when working with S3. This scenario tests the LLM's understanding of AWS SDK method chaining, promise handling, and parameter ordering. The assertions ensure that the file upload, listing, and deletion operations are correctly performed, which validates the correct usage of the AWS SDK.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

(async () => {
  const bucketName = 'your-bucket-name';
  const filePath = 'path/to/your/file.txt';
  const objectKey = path.basename(filePath);

  // Upload the file
  const uploadData = await uploadFileToS3(bucketName, filePath);
  assert(uploadData.Bucket === bucketName, 'Bucket name should match');
  assert(uploadData.Key === objectKey, 'Object key should match the file name');

  // List objects in the bucket
  const objects = await listObjectsInBucket(bucketName);
  assert(objects.some(obj => obj.Key === objectKey), 'Uploaded file should be in the bucket');

  // Delete the uploaded file
  const deleteData = await deleteObjectFromS3(bucketName, objectKey);
  assert(deleteData.DeleteMarker, 'Delete marker should be true');
})();
================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const s3 = new AWS.S3();

// Configuration for S3
const bucketName = 'example-bucket';
const keyName = 'example-key';

// Helper function to create a bucket
async function createBucket(bucketName) {
  const params = {
    Bucket: bucketName
  };
  try {
    await s3.createBucket(params).promise();
    console.log(`Bucket ${bucketName} created successfully`);
  } catch (err) {
    console.error(`Error creating bucket: ${err.message}`);
  }
}

// Helper function to upload a file to S3
async function uploadFile(bucketName, keyName, body) {
  const params = {
    Bucket: bucketName,
    Key: keyName,
    Body: body
  };
  try {
    await s3.putObject(params).promise();
    console.log(`File uploaded successfully to ${bucketName}/${keyName}`);
  } catch (err) {
    console.error(`Error uploading file: ${err.message}`);
  }
}

// Helper function to delete a file from S3
async function deleteFile(bucketName, keyName) {
  const params = {
    Bucket: bucketName,
    Key: keyName
  };
  try {
    await s3.deleteObject(params).promise();
    console.log(`File ${keyName} deleted successfully from ${bucketName}`);
  } catch (err) {
    console.error(`Error deleting file: ${err.message}`);
  }
}

// Main function to demonstrate the use of S3
async function main() {
  await createBucket(bucketName);
  await uploadFile(bucketName, keyName, 'This is a test file');


LLM COMPLETION gpt-4o-mini:
----------------------------------------
  await new Promise(resolve => setTimeout(resolve, 2000));

SUFFIX CODE:
----------------------------------------
  await deleteFile(bucketName, keyName);
  console.log('Demo completed');
}

main().catch(err => console.error(err));

JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the AWS SDK for JavaScript, specifically the S3 service. It includes creating a bucket, uploading a file, retrieving the file content, and deleting the file. The completion involves using the uncommon 'getObject' method to retrieve the content of the uploaded file. This tests the model's ability to recognize and correctly use the AWS S3 API, especially less common methods like 'getObject'.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async function test() {
  await createBucket(bucketName);
  await uploadFile(bucketName, keyName, 'This is a test file');
  const fileContent = await s3.getObject({ Bucket: bucketName, Key: keyName }).promise();
  assert.strictEqual(fileContent.Body.toString(), 'This is a test file', 'File content should match the uploaded content');
  await deleteFile(bucketName, keyName);
  console.log('All tests passed');
})().catch(err => console.error(err));
================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const assert = require('assert');

// Configure AWS SDK
AWS.config.update({
  region: 'us-west-2',
  accessKeyId: 'fakeAccessKeyId',
  secretAccessKey: 'fakeSecretAccessKey'
});

// Create an S3 service object
const s3 = new AWS.S3();

// Helper function to create a bucket
async function createBucket(bucketName) {
  const params = {
    Bucket: bucketName
  };
  try {
    await s3.createBucket(params).promise();
    console.log(`Bucket ${bucketName} created successfully.`);
  } catch (error) {
    console.error(`Error creating bucket ${bucketName}:`, error);
    throw error;
  }
}

// Helper function to upload a file to a bucket
async function uploadFile(bucketName, key, body) {
  const params = {
    Bucket: bucketName,
    Key: key,
    Body: body
  };
  try {
    await s3.putObject(params).promise();
    console.log(`File ${key} uploaded successfully to bucket ${bucketName}.`);
  } catch (error) {
    console.error(`Error uploading file ${key} to bucket ${bucketName}:`, error);
    throw error;
  }
}

// Helper function to delete a file from a bucket
async function deleteFile(bucketName, key) {
  const params = {
    Bucket: bucketName,
    Key: key
  };
  try {
    await s3.deleteObject(params).promise();
    console.log(`File ${key} deleted successfully from bucket ${bucketName}.`);
  } catch (error) {
    console.error(`Error deleting file ${key} from bucket ${bucketName}:`, error);
    throw error;
  }
}

// Main function to demonstrate the uncommon AWS S3 API usage
async function main() {
  const bucketName = 'test-bucket';
  const fileName = 'test-file.txt';
  const fileContent = 'Hello, AWS S3!';

  // Create a bucket
  await createBucket(bucketName);

  // Upload a file to the bucket
  await uploadFile(bucketName, fileName, fileContent);

  // Generate a presigned URL for the uploaded file


LLM COMPLETION gpt-4o-mini:
----------------------------------------
  const url = await s3.getSignedUrlPromise('getObject', { Bucket: bucketName, Key: fileName, Expires: 60 });

SUFFIX CODE:
----------------------------------------
  console.log(`Generated presigned URL: ${url}`);

  // Delete the file from the bucket
  await deleteFile(bucketName, fileName);

  // Clean up: delete the bucket
  try {
    await s3.deleteBucket({ Bucket: bucketName }).promise();
    console.log(`Bucket ${bucketName} deleted successfully.`);
  } catch (error) {
    console.error(`Error deleting bucket ${bucketName}:`, error);
    throw error;
  }
}

main().catch(error => console.error('Error in main function:', error));

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of an uncommon AWS S3 API function, `getSignedUrl`, to generate a presigned URL for a file stored in an S3 bucket. The prefix sets up the AWS SDK and provides helper functions for creating, uploading, and deleting files in a bucket. The completion requires the model to recognize the pattern and correctly implement the `getSignedUrl` function with proper parameters. Assertions ensure the correctness of the generated URL and the cleanup of resources.

ASSERTIONS:
----------------------------------------
assert(url.startsWith('https://test-bucket.s3.us-west-2.amazonaws.com/test-file.txt'), 'Presigned URL does not start with expected prefix');
assert(url.includes('X-Amz-Expires=60'), 'Presigned URL does not have the correct expiration time');
================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
// Node.js built-in modules - child_process
const { exec } = require('child_process');
const path = require('path');

// Helper function to execute a shell command and return it as a promise
function execCommand(command) {
    return new Promise((resolve, reject) => {
        exec(command, (error, stdout, stderr) => {
            if (error) {
                reject(`Error: ${error.message}`);
            }
            if (stderr) {
                reject(`Stderr: ${stderr}`);
            }
            resolve(stdout);
        });
    });
}

// Function to list the contents of a directory
async function listDirectoryContents(directory) {
    const command = `ls ${directory}`;
    try {
        const output = await execCommand(command);
        return output.split('\n').filter(item => item);
    } catch (error) {
        console.error(`Failed to list directory contents: ${error}`);
        return [];
    }
}

// Function to create a new directory
async function createDirectory(directory) {
    const command = `mkdir -p ${directory}`;
    try {
        await execCommand(command);
        console.log(`Directory created: ${directory}`);
    } catch (error) {
        console.error(`Failed to create directory: ${error}`);
    }
}

// Function to delete a directory
async function deleteDirectory(directory) {
    const command = `rm -rf ${directory}`;
    try {
        await execCommand(command);
        console.log(`Directory deleted: ${directory}`);
    } catch (error) {
        console.error(`Failed to delete directory: ${error}`);
    }
}

// Test directory path
const testDirectory = path.join(__dirname, 'test_dir');

// Create and list directory contents
async function testDirectoryOperations() {
    await createDirectory(testDirectory);
    let contents = await listDirectoryContents(testDirectory);
    console.log('Contents after creation:', contents);

    // Now let's create a file inside the directory
    const testFilePath = path.join(testDirectory, 'test_file.txt');


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    const fs = require('fs');
    if (fs.existsSync(testFilePath)) {
        fs.unlinkSync(testFilePath);
    }

SUFFIX CODE:
----------------------------------------
    // Code to delete the file
    const deleteFileCommand = `rm ${testFilePath}`;
    await execCommand(deleteFileCommand);
    console.log('File deleted:', testFilePath);

    // List directory contents again
    contents = await listDirectoryContents(testDirectory);
    console.log('Contents after deleting file:', contents);

    // Clean up by deleting the directory
    await deleteDirectory(testDirectory);
    console.log('Cleanup complete.');
}

// Execute the test function
(async () => {
    await testDirectoryOperations();
})();


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the model's ability to recognize and correctly use the Node.js 'child_process' module to execute shell commands. The code pattern involves creating, listing, and deleting directories and files using shell commands. The 'golden_completion' requires the model to correctly form and execute a shell command to create a file, which is a less common use case for 'child_process'. Additionally, the code includes error handling and cleanup processes, ensuring that the model can handle real-world scenarios and resource management.

ASSERTIONS:
----------------------------------------
const fs = require('fs');
const assert = require('assert');

(async () => {
    // Create the test directory and file
    await createDirectory(testDirectory);
    const testFilePath = path.join(testDirectory, 'test_file.txt');
    const createFileCommand = `touch ${testFilePath}`;
    await execCommand(createFileCommand);

    // List directory contents and verify the file creation
    let contents = await listDirectoryContents(testDirectory);
    assert(contents.includes('test_file.txt'), 'File should be created in the directory');

    // Delete the file and verify its deletion
    const deleteFileCommand = `rm ${testFilePath}`;
    await execCommand(deleteFileCommand);
    contents = await listDirectoryContents(testDirectory);
    assert(!contents.includes('test_file.txt'), 'File should be deleted from the directory');

    // Cleanup
    await deleteDirectory(testDirectory);
})();

================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { WebSocketServer } = require('ws');

// Helper function to handle incoming messages
function handleMessage(message) {
    console.log('Received:', message);
}

// Create a new WebSocket server
const wss = new WebSocketServer({ port: 8080 });

// Set up connection event listener
wss.on('connection', function connection(ws) {
    console.log('Client connected');

    // Set up message event listener
    ws.on('message', function incoming(message) {
        handleMessage(message);
    });

    // Send a welcome message to the client
    ws.send('Welcome to the WebSocket server');

    // Set a timer to send a heartbeat every 30 seconds
    const heartbeatInterval = setInterval(function() {
        if (ws.readyState === ws.OPEN) {
            ws.send('heartbeat');
        }
    }, 30000);

    // Clean up on close
    ws.on('close', function() {
        clearInterval(heartbeatInterval);
        console.log('Client disconnected');
    });
});

LLM COMPLETION gpt-4o-mini:
----------------------------------------
// Start the server

SUFFIX CODE:
----------------------------------------

// Start the server
wss.on('listening', function listening() {
    console.log('WebSocket server is listening on port 8080');
});

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and complete WebSocket server error handling patterns using the 'ws' library, which is an uncommon but important aspect of WebSocket server implementation. Proper error handling is crucial for robust applications, and this completion tests the model's understanding of setting up event listeners for the 'error' event.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Mock the console.error method to capture error messages
let errorMessage = '';
console.error = (message) => { errorMessage = message; };

// Simulate an error event
wss.emit('error', new Error('Test error'));

// Assertion to check if the error message was logged
assert.strictEqual(errorMessage, 'WebSocket server error: Error: Test error');

// Restore the original console.error method
console.error = console.constructor.prototype.error;

// Clean up resources
wss.close();
================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');
const assert = require('assert');

// Generate a pair of RSA keys
function generateKeyPair() {
    return new Promise((resolve, reject) => {
        crypto.generateKeyPair('rsa', {
            modulusLength: 2048,
            publicKeyEncoding: {
                type: 'spki',
                format: 'pem'
            },
            privateKeyEncoding: {
                type: 'pkcs8',
                format: 'pem'
            }
        }, (err, publicKey, privateKey) => {
            if (err) {
                reject(err);
            } else {
                resolve({ publicKey, privateKey });
            }
        });
    });
}

// Encrypt data using RSA public key
function encryptWithPublicKey(publicKey, data) {
    const buffer = Buffer.from(data, 'utf8');
    return crypto.publicEncrypt(publicKey, buffer).toString('base64');
}

// Decrypt data using RSA private key
function decryptWithPrivateKey(privateKey, encryptedData) {
    const buffer = Buffer.from(encryptedData, 'base64');
    return crypto.privateDecrypt(privateKey, buffer).toString('utf8');
}

async function main() {
    const { publicKey, privateKey } = await generateKeyPair();
    const data = 'Hello, world!';
    const encryptedData = encryptWithPublicKey(publicKey, data);

    // These are the edge cases we will be testing
    const corruptedEncryptedData = encryptedData.slice(0, -1); // Remove last character to corrupt
    const wrongKeyPair = await generateKeyPair(); // Generate a different key pair
    const wrongPrivateKey = wrongKeyPair.privateKey;

    // Decrypt data using the correct private key


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    const decryptedData = decryptWithPrivateKey(privateKey, encryptedData);

SUFFIX CODE:
----------------------------------------
    // Decrypt data using a different private key (should fail)
    try {
        decryptWithPrivateKey(wrongPrivateKey, encryptedData);
        throw new Error('Expected decryption to fail with wrong private key');
    } catch (e) {
        assert.strictEqual(e.message.includes('decryption'), true, 'Error message should indicate decryption failure');
    }

    // Decrypt corrupted data (should fail)
    try {
        decryptWithPrivateKey(privateKey, corruptedEncryptedData);
        throw new Error('Expected decryption to fail with corrupted data');
    } catch (e) {
        assert.strictEqual(e.message.includes('decryption'), true, 'Error message should indicate decryption failure');
    }

    // Cleanup resources (none needed in this case)
}

main().then(() => console.log('All tests passed')).catch(console.error);


JUSTIFICATION:
----------------------------------------
This test case focuses on the Node.js built-in 'crypto' module, specifically on the RSA encryption and decryption functionality. The completion involves decrypting data using a private key, which is a less common usage pattern. This example tests the model's ability to understand and correctly implement the decryption process, handle edge cases such as decryption with the wrong key and corrupted data, and ensure proper error handling and assertions.

ASSERTIONS:
----------------------------------------
const { publicKey, privateKey } = await generateKeyPair();
const data = 'Hello, world!';
const encryptedData = encryptWithPublicKey(publicKey, data);
const decryptedData = decryptWithPrivateKey(privateKey, encryptedData);
assert.strictEqual(decryptedData, data, 'Decrypted data should match original');

================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');
const { promisify } = require('util');
const fs = require('fs');

// Utility function to generate a random string
function generateRandomString(length) {
    return crypto.randomBytes(length).toString('hex');
}

// Utility function to write data to a file
function writeFile(filePath, data) {
    return promisify(fs.writeFile)(filePath, data);
}

// Utility function to read data from a file
function readFile(filePath) {
    return promisify(fs.readFile)(filePath, 'utf8');
}

// Generate a random string and write it to a file
const randomString = generateRandomString(16);
const filePath = './randomString.txt';

async function performFileOperations() {
    try {
        await writeFile(filePath, randomString);
        const fileData = await readFile(filePath);
        return fileData;
    } catch (error) {
        console.error('Error performing file operations:', error);
        throw error;
    }
}

performFileOperations().then((data) => {
    console.log('File data:', data);
}).catch((error) => {
    console.error('Error:', error);
});
// Generate a derived key


LLM COMPLETION gpt-4o-mini:
----------------------------------------
const derivedKey = crypto.pbkdf2Sync(randomString, 'salt', 100000, 64, 'sha512');

SUFFIX CODE:
----------------------------------------
performFileOperations().then((data) => {
    console.log('File data:', data);
}).catch((error) => {
    console.error('Error:', error);
});

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of the crypto.pbkdf2 function, which is a less commonly used function in the Node.js crypto module. The test checks if the model can correctly implement this function with the appropriate parameters, ensuring the derived key is generated and logged correctly. The prefix provides context with other crypto and fs functions, while the suffix continues file operations, ensuring the golden completion is distinct and focused on the rare API usage.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
crypto.pbkdf2('password', 'salt', 100000, 64, 'sha512', (err, derivedKey) => {
    if (err) throw err;
    assert.strictEqual(derivedKey.toString('hex').length, 128, 'Derived key length should be 128 characters');
    assert.strictEqual(typeof derivedKey.toString('hex'), 'string', 'Derived key should be a string');
});
================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { Worker, isMainThread, parentPort } = require('worker_threads');
const path = require('path');
const fs = require('fs');

// Utility function to read a file
function readFile(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                return reject(err);
            }
            resolve(data);
        });
    });
}

// Utility function to write to a file
function writeFile(filePath, content) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, content, 'utf8', (err) => {
            if (err) {
                return reject(err);
            }
            resolve();
        });
    });
}

// Function to process data in a worker thread
function processDataInWorker(data) {
    return new Promise((resolve, reject) => {
        const worker = new Worker(path.resolve(__dirname, 'worker.js'), {
            workerData: data
        });

        worker.on('message', resolve);
        worker.on('error', reject);
        worker.on('exit', (code) => {
            if (code !== 0) {
                reject(new Error(`Worker stopped with exit code ${code}`));
            }
        });
    });
}

if (isMainThread) {
    // Main thread code
    (async () => {
        try {
            const inputFilePath = path.resolve(__dirname, 'input.txt');
            const outputFilePath = path.resolve(__dirname, 'output.txt');

            // Step 1: Read input file
            const inputData = await readFile(inputFilePath);

            // Step 2: Process data in worker thread
            const processedData = await processDataInWorker(inputData);

            // Step 3: Write processed data to output file
            await writeFile(outputFilePath, processedData);

            console.log('Processing complete.');
        } catch (err) {
            console.error('Error:', err);
        }
    })();
} else {
    // Worker thread code
    parentPort.on('message', async (data) => {
        try {
            // Simulate data processing
            const result = data.toUpperCase();

            // Send result back to main thread
            parentPort.postMessage(result);
        } catch (err) {
            parentPort.postMessage({ error: err.message });
        }
    });
}


LLM COMPLETION gpt-4o-mini:
----------------------------------------
parentPort.on('message', async (data) => {

SUFFIX CODE:
----------------------------------------


        // Send result back to main thread
        parentPort.postMessage(result);
    } catch (err) {
        parentPort.postMessage({ error: err.message });
    }
});


JUSTIFICATION:
----------------------------------------
This test case focuses on the use of the Worker Threads API, specifically the parentPort.on method to handle messages in a worker thread. It tests the LLM's ability to recognize and complete the pattern for processing data asynchronously in a worker thread and sending the result back to the main thread. The scenario includes file operations, error handling, and demonstrates how to use promises with worker threads. The golden completion follows the pattern of converting the input data to uppercase, which matches the context established in the prefix.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const { Worker, isMainThread, parentPort } = require('worker_threads');
const path = require('path');
const fs = require('fs');

(async () => {
    const inputFilePath = path.resolve(__dirname, 'input.txt');
    const outputFilePath = path.resolve(__dirname, 'output.txt');
    fs.writeFileSync(inputFilePath, 'hello world');

    const inputData = await readFile(inputFilePath);
    const processedData = await processDataInWorker(inputData);
    await writeFile(outputFilePath, processedData);

    const outputData = await readFile(outputFilePath);

    assert.strictEqual(outputData, 'HELLO WORLD', 'The processed data should be in uppercase.');
    console.log('All assertions passed.');
})();

================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { JSDOM } = require('jsdom');
const jquery = require('jquery');

const htmlContent = `<!DOCTYPE html>
<html>
<head>
  <title>Test Document</title>
</head>
<body>
  <div id="content">
    <p class="text">Hello, World!</p>
  </div>
</body>
</html>`;

const { window } = new JSDOM(htmlContent);
const $ = jquery(window);

function updateContent() {
  // Update the content of the paragraph
  $('#content .text').text('Updated Text');
}

function addNewElement() {
  // Add a new element to the content div
  $('#content').append('<p class="new">New Element</p>');
}

function removeElement() {
  // Remove the paragraph element
  $('#content .text').remove();
}

function changeElementAttribute() {
  // Change the id of the content div
  $('#content').attr('id', 'new-content');
}

// Initial state checks
updateContent();
addNewElement();
removeElement();


LLM COMPLETION gpt-4o-mini:
----------------------------------------
console.log(window.document.querySelector('#new-content').innerHTML);

SUFFIX CODE:
----------------------------------------
console.log(window.document.querySelector('#new-content'));
console.log(window.document.querySelector('.new').textContent);


JUSTIFICATION:
----------------------------------------
This test case uses the deprecated jQuery library in combination with jsdom to manipulate and verify DOM elements. It tests the model's ability to recognize and complete patterns involving jQuery methods, such as text(), append(), remove(), and attr(). The golden completion reuses the changeElementAttribute function to demonstrate understanding of jQuery's attr() method. The suffix uses native DOM methods to verify the changes, ensuring the model can switch contexts between jQuery and standard DOM APIs.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const { JSDOM } = require('jsdom');
const jquery = require('jquery');

const htmlContent = `<!DOCTYPE html>
<html>
<head>
  <title>Test Document</title>
</head>
<body>
  <div id="content">
    <p class="text">Hello, World!</p>
  </div>
</body>
</html>`;

const { window } = new JSDOM(htmlContent);
const $ = jquery(window);

function updateContent() {
  $('#content .text').text('Updated Text');
}

function addNewElement() {
  $('#content').append('<p class="new">New Element</p>');
}

function removeElement() {
  $('#content .text').remove();
}

function changeElementAttribute() {
  $('#content').attr('id', 'new-content');
}

updateContent();
addNewElement();
removeElement();
changeElementAttribute();

// Assertions
assert.strictEqual(window.document.querySelector('#new-content').id, 'new-content');
assert.strictEqual(window.document.querySelector('.new').textContent, 'New Element');

================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

// Utility function to generate a random salt
function generateSalt(length) {
    return crypto.randomBytes(Math.ceil(length / 2)).toString('hex').slice(0, length);
}

// Utility function to hash a password with salt
function hashPassword(password, salt) {
    const hash = crypto.createHmac('sha512', salt);
    hash.update(password);
    const value = hash.digest('hex');
    return {
        salt: salt,
        hashedPassword: value
    };
}

// Function to validate a password
function validatePassword(password, hashedPassword, salt) {
    const hash = crypto.createHmac('sha512', salt);
    hash.update(password);
    const value = hash.digest('hex');
    return value === hashedPassword;
}

// Example usage
const password = 'superSecretPassword';
const salt = generateSalt(16);
const hashedPasswordData = hashPassword(password, salt);

// Intentionally using a deprecated Node.js API to test LLM's capability to recognize and complete patterns
const legacyCrypto = require('crypto');
const legacyHash = legacyCrypto.createHash('md5');
legacyHash.update(password);
const legacyHashedPassword = legacyHash.digest('hex');



LLM COMPLETION gpt-4o-mini:
----------------------------------------
const isValid = validatePassword(password, hashedPasswordData.hashedPassword, salt);

SUFFIX CODE:
----------------------------------------
const isValid = validatePassword(password, hashedPasswordData.hashedPassword, salt);

console.log(`Password is valid: ${isValid}`);
console.log(`Legacy hashed password: ${legacyHashedPassword}`);

// Cleanup resources if any
// (In this case, there are no resources to clean up)


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and complete patterns involving both modern and deprecated Node.js crypto APIs. The example establishes a clear pattern of using the 'crypto' module for hashing and salting passwords. The completion specifically requires the LLM to correctly use a deprecated API (crypto.createHash('md5')) and understand the context of salting a password before hashing, which is less common and may not be immediately obvious. This makes it a good test case for evaluating the model's understanding of rare and deprecated API usage.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const generatedSalt = generateSalt(16);
const hashedData = hashPassword(password, generatedSalt);
const isPasswordValid = validatePassword(password, hashedData.hashedPassword, generatedSalt);
assert.strictEqual(isPasswordValid, true, 'The password should be validated correctly');
legacyHash.update(salt);
const expectedLegacySaltedHash = legacyHash.digest('hex');
assert.strictEqual(legacySaltedHashedPassword, expectedLegacySaltedHash, 'The legacy salted hashed password should match the expected value');
================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

// Function to generate a random string of specified length
function generateRandomString(length) {
    return crypto.randomBytes(length).toString('hex');
}

// Function to hash a password using bcrypt
const bcrypt = require('bcrypt');
const saltRounds = 10;

function hashPassword(password) {
    return new Promise((resolve, reject) => {
        bcrypt.hash(password, saltRounds, (err, hash) => {
            if (err) reject(err);
            resolve(hash);
        });
    });
}

// Function to verify a password against a hash
function verifyPassword(password, hash) {
    return new Promise((resolve, reject) => {
        bcrypt.compare(password, hash, (err, result) => {
            if (err) reject(err);
            resolve(result);
        });
    });
}

// Example usage of the functions
async function exampleUsage() {
    try {
        const password = 'mySecretPassword';
        const hash = await hashPassword(password);
        const isValid = await verifyPassword(password, hash);
        console.log('Password is valid:', isValid);
    } catch (error) {
        console.error('Error:', error);
    }
}

exampleUsage();

// Advanced usage of Web Crypto API to generate an RSA key pair
async function generateKeyPair() {
    const keyPair = await crypto.webcrypto.subtle.generateKey({
        name: 'RSA-PSS',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256'
    }, true, ['sign', 'verify']);
    return keyPair;
}

async function signData(key, data) {
    const signature = await crypto.webcrypto.subtle.sign({
        name: 'RSA-PSS',
        saltLength: 32
    }, key, data);
    return signature;
}

async function verifySignature(key, data, signature) {
    const isValid = await crypto.webcrypto.subtle.verify({
        name: 'RSA-PSS',
        saltLength: 32
    }, key, signature, data);
    return isValid;
}

// Example usage of the Web Crypto API
async function exampleWebCryptoUsage() {
    const { publicKey, privateKey } = await generateKeyPair();
    const data = new TextEncoder().encode('Hello, world!');


LLM COMPLETION gpt-4o-mini:
----------------------------------------
    const signature = await signData(privateKey, data);
    const result = await verifySignature(publicKey, data, signature);

SUFFIX CODE:
----------------------------------------

    console.log('Verification result:', result);
}

exampleWebCryptoUsage();


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern using the Web Crypto API, which is less common compared to other cryptographic libraries. The example involves generating an RSA key pair, signing data, and verifying the signature. The completion is critical to ensure the correct usage of the Web Crypto API functions and parameters. The assertions verify the correctness of the generated signature and its verification process.

ASSERTIONS:
----------------------------------------
const { publicKey, privateKey } = await generateKeyPair();
const data = new TextEncoder().encode('Hello, world!');
const signature = await signData(privateKey, data);
const result = await verifySignature(publicKey, data, signature);
console.assert(result === true, 'Signature verification failed');

================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

// Utility function to generate a random string
function generateRandomString(length) {
    return crypto.randomBytes(length).toString('hex');
}

// Function to hash a password using bcrypt
const bcrypt = require('bcrypt');
const saltRounds = 10;

function hashPassword(password) {
    return new Promise((resolve, reject) => {
        bcrypt.hash(password, saltRounds, (err, hash) => {
            if (err) reject(err);
            resolve(hash);
        });
    });
}

// Function to verify a hashed password
function verifyPassword(password, hash) {
    return new Promise((resolve, reject) => {
        bcrypt.compare(password, hash, (err, result) => {
            if (err) reject(err);
            resolve(result);
        });
    });
}

// JWT related functions
const jwt = require('jsonwebtoken');
const secretKey = 'mySecretKey';

// Function to generate a JWT token
function generateToken(payload) {
    return jwt.sign(payload, secretKey, { expiresIn: '1h' });
}

// Function to verify a JWT token
function verifyToken(token) {
    return new Promise((resolve, reject) => {
        jwt.verify(token, secretKey, (err, decoded) => {
            if (err) reject(err);
            resolve(decoded);
        });
    });
}

// Sample user data
const user = {
    username: 'testUser',
    password: 'password123'
};

async function main() {
    try {
        // Generate a random string
        const randomString = generateRandomString(16);
        console.log('Random String:', randomString);

        // Hash the user's password
        const hashedPassword = await hashPassword(user.password);
        console.log('Hashed Password:', hashedPassword);

        // Verify the hashed password
        const isPasswordValid = await verifyPassword(user.password, hashedPassword);
        console.log('Is Password Valid:', isPasswordValid);

        // Generate a JWT token for the user
        const token = generateToken({ username: user.username });
        console.log('JWT Token:', token);

        // Verify the JWT token
        const decodedToken = await verifyToken(token);
        console.log('Decoded Token:', decodedToken);

        // Additional security: Sign data using HMAC with SHA-256
        const dataToSign = 'Important data';
        const hmac = crypto.createHmac('sha256', secretKey);
        hmac.update(dataToSign);


LLM COMPLETION gpt-4o-mini:
----------------------------------------
        const signedData = hmac.digest('hex');

SUFFIX CODE:
----------------------------------------

        console.log('Signed Data:', signedData);

        // Assertions
        const assert = require('assert');
        assert.strictEqual(isPasswordValid, true, 'Password should be valid');
        assert.strictEqual(decodedToken.username, user.username, 'Decoded token should match the username');
        assert.strictEqual(typeof signedData, 'string', 'Signed data should be a string');
        assert.notStrictEqual(signedData, '', 'Signed data should not be empty');

        // Clean up resources
        // (No specific cleanup needed for this example)
    } catch (error) {
        console.error('Error:', error);
    }
}

main();

JUSTIFICATION:
----------------------------------------
This test case involves the use of several uncommon and security-focused Node.js APIs, including the crypto module for HMAC signing, bcrypt for password hashing, and jsonwebtoken for JWT token management. It tests the model's understanding of complex asynchronous patterns with Promises and error handling, as well as the correct usage of specific API functions. The assertions ensure that the cryptographic operations are performed correctly and that the generated data meets expected criteria.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
assert.strictEqual(isPasswordValid, true, 'Password should be valid');
assert.strictEqual(decodedToken.username, user.username, 'Decoded token should match the username');
assert.strictEqual(typeof signedData, 'string', 'Signed data should be a string');
assert.notStrictEqual(signedData, '', 'Signed data should not be empty');
================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

// Helper function to generate a random salt
function generateSalt(length) {
  return crypto.randomBytes(Math.ceil(length / 2)).toString('hex').slice(0, length);
}

// Helper function to hash a password using pbkdf2
function hashPassword(password, salt) {
  return new Promise((resolve, reject) => {
    crypto.pbkdf2(password, salt, 1000, 64, 'sha512', (err, derivedKey) => {
      if (err) reject(err);
      resolve(derivedKey.toString('hex'));
    });
  });
}

// Function to create a new user with hashed password
async function createUser(username, password) {
  const salt = generateSalt(16);
  const hashedPassword = await hashPassword(password, salt);
  // Store the user in the database (mocked here)
  return { username, salt, hashedPassword };
}

// Mock database
const users = [];

async function run() {
  try {
    const newUser = await createUser('testuser', 'mypassword');
    users.push(newUser);
    console.log('User created:', newUser);
  } catch (error) {
    console.error('Error creating user:', error);
  }

  // Attempt to verify the user's password
  const storedUser = users.find(user => user.username === 'testuser');
  if (!storedUser) {
    throw new Error('User not found');
  }

  const { salt, hashedPassword } = storedUser;

  async function verifyPassword(storedHash, password, salt) {
    return new Promise((resolve, reject) => {
      crypto.pbkdf2(password, salt, 1000, 64, 'sha512', (err, derivedKey) => {
        if (err) reject(err);
        resolve(storedHash === derivedKey.toString('hex'));
      });
    });
  }

  // Verify the password
  const isPasswordCorrect = await verifyPassword(hashedPassword, 'mypassword', salt);
  console.log('Password correct:', isPasswordCorrect);
}

run();

LLM COMPLETION gpt-4o-mini:
----------------------------------------
const isPasswordIncorrect = await verifyPassword(hashedPassword, 'wrongpassword', salt);
console.log('Password incorrect:', isPasswordIncorrect);

SUFFIX CODE:
----------------------------------------
const isPasswordIncorrect = await verifyPassword(hashedPassword, 'wrongpassword', salt);
console.log('Password incorrect:', isPasswordIncorrect);


JUSTIFICATION:
----------------------------------------
This test case involves the use of the crypto module's pbkdf2 function in Node.js to hash and verify passwords, a less common use case compared to bcrypt or jsonwebtoken. The code demonstrates the complete process of creating a user, hashing a password, and verifying it. The golden completion is essential to test the LLM's ability to recognize and complete the hash verification process correctly. It also checks the correct ordering of parameters and proper handling of async/await patterns.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const crypto = require('crypto');

async function runTests() {
  const salt = generateSalt(16);
  const hashedPassword = await hashPassword('mypassword', salt);
  const isPasswordCorrect = await verifyPassword(hashedPassword, 'mypassword', salt);
  assert.strictEqual(isPasswordCorrect, true, 'The password should be correct');

  const isPasswordIncorrect = await verifyPassword(hashedPassword, 'wrongpassword', salt);
  assert.strictEqual(isPasswordIncorrect, false, 'The password should be incorrect');
}

runTests().then(() => console.log('All tests passed')).catch(error => console.error('Tests failed:', error));
================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');
const assert = require('assert');

// Helper function to convert a buffer to a hex string
function bufferToHex(buffer) {
    return buffer.toString('hex');
}

// Generate a random initialization vector
function generateIV() {
    return crypto.randomBytes(16);
}

// Encrypts a text using AES-256-CBC
function encrypt(text, key, iv) {
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
}

// Decrypts an encrypted text using AES-256-CBC
function decrypt(encrypted, key, iv) {
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

// Generate a secure random key for AES-256
const key = crypto.randomBytes(32);
const iv = generateIV();
const text = "This is a secret message";

// Encrypt the text
const encryptedText = encrypt(text, key, iv);

// Decrypt the text
const decryptedText = decrypt(encryptedText, key, iv);

// Assertions to verify the encryption and decryption
assert.strictEqual(decryptedText, text, "The decrypted text should match the original text");

LLM COMPLETION gpt-4o-mini:
----------------------------------------
console.log('Decrypted text:', decryptedText);

SUFFIX CODE:
----------------------------------------

// Clean up resources (not needed in this case but included for completeness)
console.log('Encryption and decryption were successful');

JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of the Node.js crypto module to perform both AES-256-CBC encryption/decryption and HMAC generation. The rare API usage here is the creation of an HMAC using the 'crypto.createHmac' method, which is less commonly used compared to other cryptographic operations. The golden completion includes correct parameter ordering and demonstrates best practices for generating and verifying an HMAC. Assertions ensure that the HMAC digest is correctly generated, of the expected type, and of the correct length. This scenario tests the model's ability to recognize and complete patterns involving cryptographic operations.

ASSERTIONS:
----------------------------------------
assert.strictEqual(typeof hmacDigest, 'string', "HMAC digest should be a string");
assert.strictEqual(hmacDigest.length, 64, "HMAC digest length should be 64 characters");
assert.strictEqual(decryptedText, text, "The decrypted text should match the original text");
================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

// Utility function to convert buffer to hex string
function bufferToHex(buffer) {
    return buffer.toString('hex');
}

// Utility function to compare two buffers securely
function buffersEqual(a, b) {
    if (a.length !== b.length) return false;
    let result = 0;
    for (let i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    return result === 0;
}

// Configuration object for key derivation
const keyConfig = {
    salt: crypto.randomBytes(16),
    iterations: 100000,
    keylen: 64,
    digest: 'sha512'
};

// Function to derive a key from a password
function deriveKey(password, salt, iterations, keylen, digest, callback) {
    crypto.pbkdf2(password, salt, iterations, keylen, digest, (err, derivedKey) => {
        if (err) throw err;
        callback(derivedKey);
    });
}

// Example usage of key derivation function
const password = 'supersecretpassword';
let derivedKey1;
deriveKey(password, keyConfig.salt, keyConfig.iterations, keyConfig.keylen, keyConfig.digest, (key) => {
    derivedKey1 = key;
});

// Another example with different salt
const differentSalt = crypto.randomBytes(16);
let derivedKey2;
deriveKey(password, differentSalt, keyConfig.iterations, keyConfig.keylen, keyConfig.digest, (key) => {
    derivedKey2 = key;
});

// Mocking a derived key for comparison
const mockDerivedKey = Buffer.from('a1b2c3d4e5f678901234567890abcdef1234567890abcdef1234567890abcdef', 'hex');

// Function to verify password
function verifyPassword(password, salt, storedKey, iterations, keylen, digest, callback) {
    crypto.pbkdf2(password, salt, iterations, keylen, digest, (err, derivedKey) => {
        if (err) throw err;
        callback(buffersEqual(derivedKey, storedKey));
    });
}

// Example verification
verifyPassword(password, keyConfig.salt, mockDerivedKey, keyConfig.iterations, keyConfig.keylen, keyConfig.digest, (isMatch) => {
    console.log('Password match:', isMatch);
});

// Additional setup and utility functions
const randomBytesAsync = (size) => new Promise((resolve, reject) => {
    crypto.randomBytes(size, (err, buf) => {
        if (err) reject(err);
        else resolve(buf);
    });
});

const createHmac = (algorithm, key) => {
    return crypto.createHmac(algorithm, key);
};
// Derive key with randomBytesAsync


LLM COMPLETION gpt-4o-mini:
----------------------------------------
randomBytesAsync(32).then((buf) => {
    const key = buf;
    const message = 'Hello, World!';
    const hmac = createHmac('sha256', key);
    hmac.update(message);
    const digest = hmac.digest('hex');
    console.log('HMAC digest:', digest);
}).catch(err => console.error(err));

SUFFIX CODE:
----------------------------------------
const key = 'mysecretkey';
const message = 'Hello, World!';
const hmac = createHmac('sha256', key);
hmac.update(message);
const digest = hmac.digest('hex');
console.log('HMAC digest:', digest);

// Cleanup resources
console.log('Finished HMAC generation');

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete patterns involving the Web Crypto API, specifically using the 'crypto' module in Node.js. The completion involves generating random bytes asynchronously, which is a less common but valid use case. The test verifies correct handling of asynchronous functions and cryptographic operations, ensuring the derived key is properly generated and converted to hex format. This scenario demonstrates proper parameter usage, error handling, and integration of cryptographic functions.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const testPassword = 'testpassword';
const testSalt = crypto.randomBytes(16);
const expectedDerivedKey = Buffer.from('a1b2c3d4e5f678901234567890abcdef1234567890abcdef1234567890abcdef', 'hex');
deriveKey(testPassword, testSalt, keyConfig.iterations, keyConfig.keylen, keyConfig.digest, (key) => {
    assert.strictEqual(bufferToHex(key).length, 128, 'Derived key length should be 128 hex characters');
});
verifyPassword(testPassword, testSalt, expectedDerivedKey, keyConfig.iterations, keyConfig.keylen, keyConfig.digest, (isMatch) => {
    assert.strictEqual(isMatch, false, 'Password should not match the mock derived key');
});
================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');
const assert = require('assert');

// Utility function to convert a string to a Buffer
function stringToBuffer(str) {
    return Buffer.from(str, 'utf8');
}

// Utility function to generate a random IV
function generateIV() {
    return crypto.randomBytes(16);
}

// Function to encrypt data using AES-256-CBC
function encryptData(data, key) {
    const iv = generateIV();
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return { iv: iv.toString('hex'), encryptedData: encrypted };
}

// Function to decrypt data using AES-256-CBC
function decryptData(encryptedData, key, iv) {
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, Buffer.from(iv, 'hex'));
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

// Generate a random key for encryption
const key = crypto.randomBytes(32);

// Sample data to encrypt
const data = 'This is some secret data.';

// Encrypt the data
const encrypted = encryptData(data, key);

// Decrypt the data


LLM COMPLETION gpt-4o-mini:
----------------------------------------
const decrypted = decryptData(encrypted.encryptedData, key, encrypted.iv);

SUFFIX CODE:
----------------------------------------
const decrypted = 'Decryption failed';

// Assertions
assert.strictEqual(decrypted, data, 'Decrypted data does not match the original data');

// Cleanup code (if any) would go here


JUSTIFICATION:
----------------------------------------
This test case uses the Web Crypto API in Node.js to demonstrate encryption and decryption using AES-256-CBC, which is a less commonly used but important cryptographic algorithm. The example includes utility functions for converting strings to buffers and generating random initialization vectors (IVs). It sets up encryption and decryption functions, generates a random key, and tests the entire encryption-decryption cycle with appropriate assertions. This scenario tests the model's ability to recognize and correctly use the crypto module's uncommon functions and handle the parameters correctly.

ASSERTIONS:
----------------------------------------
assert.strictEqual(decrypted, data, 'Decrypted data does not match the original data');
================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const express = require('express');
const bodyParser = require('body-parser');
const app = express();
const port = 3000;

// Middleware setup
app.use(bodyParser.json());

// Mock database
let users = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' },
];

// Helper function to find user by ID
function findUserById(id) {
    return users.find(user => user.id === id);
}

// Setup routes
app.get('/users/:id', (req, res) => {
    const userId = parseInt(req.params.id, 10);
    const user = findUserById(userId);
    if (user) {
        res.status(200).json(user);
    } else {
        res.status(404).json({ error: 'User not found' });
    }
});

app.post('/users', (req, res) => {
    const newUser = req.body;
    newUser.id = users.length + 1;
    users.push(newUser);
    res.status(201).json(newUser);
});

// Uncommon API usage: Using express.Router for nested routes
const userRouter = express.Router();

// Route to update a user
userRouter.put('/:id', (req, res) => {
    const userId = parseInt(req.params.id, 10);
    const user = findUserById(userId);
    if (user) {
        Object.assign(user, req.body);
        res.status(200).json(user);
    } else {
        res.status(404).json({ error: 'User not found' });
    }
});

// Route to delete a user
userRouter.delete('/:id', (req, res) => {
    const userId = parseInt(req.params.id, 10);
    const userIndex = users.findIndex(user => user.id === userId);
    if (userIndex !== -1) {
        users.splice(userIndex, 1);
        res.status(204).send();
    } else {
        res.status(404).json({ error: 'User not found' });
    }
});

// Use the userRouter for /users route
app.use('/users', userRouter);

// Start the server
app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
});


LLM COMPLETION gpt-4o-mini:
----------------------------------------
// Cleanup resources
app.close();

SUFFIX CODE:
----------------------------------------
// Cleanup resources
app.close();


JUSTIFICATION:
----------------------------------------
This test case demonstrates the uncommon usage of express.Router for setting up nested routes in an Express.js application. The prefix provides extensive setup of an Express application, including middleware, routes, and a mock database. The completion focuses on correctly using express.Router to handle nested routes under the '/api/users' path, showcasing understanding of middleware and route handling in Express. The test ensures the proper usage of express.Router and validates that nested routes work as expected.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const request = require('supertest');

// Setup test server
const server = app.listen(3001);

// Test GET /api/users/:id route
request(server)
    .get('/api/users/1')
    .expect(200)
    .end((err, res) => {
        if (err) throw err;
        assert.strictEqual(res.body.name, 'Alice');
    });

// Test PUT /api/users/:id route
request(server)
    .put('/api/users/1')
    .send({ name: 'Alice Updated' })
    .expect(200)
    .end((err, res) => {
        if (err) throw err;
        assert.strictEqual(res.body.name, 'Alice Updated');
    });

// Test DELETE /api/users/:id route
request(server)
    .delete('/api/users/1')
    .expect(204)
    .end((err) => {
        if (err) throw err;
    });

// Ensure user is deleted
request(server)
    .get('/api/users/1')
    .expect(404)
    .end((err) => {
        if (err) throw err;
        server.close();
    });

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: devbench-api-usage
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const AWS = require('aws-sdk');
const s3 = new AWS.S3();
const bucketName = 'my-test-bucket';
const objectKey = 'test-object.txt';
const uploadParams = {
  Bucket: bucketName,
  Key: objectKey,
  Body: 'Hello, world!'
};

async function uploadObject() {
  try {
    await s3.createBucket({ Bucket: bucketName }).promise();
    console.log('Bucket created successfully');

    const data = await s3.upload(uploadParams).promise();
    console.log('Object uploaded successfully:', data);

    const getObjectParams = {
      Bucket: bucketName,
      Key: objectKey
    };

    const objectData = await s3.getObject(getObjectParams).promise();
    console.log('Object retrieved successfully:', objectData.Body.toString('utf-8'));

    return objectData.Body.toString('utf-8');
  } catch (error) {
    console.error('Error uploading object:', error);
    throw error;
  }
}

async function deleteObject() {
  const deleteParams = {
    Bucket: bucketName,
    Key: objectKey
  };

  try {
    const deleteData = await s3.deleteObject(deleteParams).promise();
    console.log('Object deleted successfully:', deleteData);
  } catch (error) {
    console.error('Error deleting object:', error);
    throw error;
  }
}

async function cleanupBucket() {
  try {
    await s3.deleteBucket({ Bucket: bucketName }).promise();
    console.log('Bucket deleted successfully');
  } catch (error) {
    console.error('Error deleting bucket:', error);
    throw error;
  }
}

(async () => {
  try {
    const content = await uploadObject();
    

LLM COMPLETION gpt-4o-mini:
----------------------------------------
    console.log('Uploaded content:', content);

SUFFIX CODE:
----------------------------------------

    await deleteObject();
    await cleanupBucket();
  } catch (error) {
    console.error('Error in operation:', error);
  }
})();

JUSTIFICATION:
----------------------------------------
This test case involves using the AWS SDK to perform a series of operations on an S3 bucket, including creating a bucket, uploading an object, retrieving the object, and verifying its content. It then cleans up by deleting the object and the bucket. The example tests the model's ability to recognize and complete patterns involving AWS SDK methods, handle asynchronous operations, and correctly place assertions to validate API behavior. This is a realistic and complex scenario demonstrating uncommon library functions and requiring precise API usage and error handling.

ASSERTIONS:
----------------------------------------
console.assert(content === 'Hello, world!', 'The content of the uploaded and retrieved object should be "Hello, world!"');
================================================================================
