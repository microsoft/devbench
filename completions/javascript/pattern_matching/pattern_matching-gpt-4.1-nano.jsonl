{"id": "1", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\nfunction encrypt(text, algorithm, password) {\n    const cipher = crypto.createCipher(algorithm, password);\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n}\n\nfunction decrypt(encryptedText, algorithm, password) {\n    const decipher = crypto.createDecipher(algorithm, password);\n    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n}\n\nfunction hash(text, algorithm) {\n    const hash = crypto.createHash(algorithm);\n    hash.update(text);\n    return hash.digest('hex');\n}\n\n// Function to generate a random salt\nfunction generateSalt(length) {\n    return crypto.randomBytes(length).toString('hex');\n}\n\n// Function to hash a password with a salt\nfunction hashPasswordWithSalt(password, salt, algorithm) {", "suffix": "\n    return `${salt}:${hash.digest('hex')}`;\n}\n\n// Test the functionality\nconst password = 'mysecretpassword';\nconst salt = generateSalt(16);\nconst algorithm = 'sha256';\n\nconst hashedPassword = hashPasswordWithSalt(password, salt, algorithm);\nconst [saltPart, hashPart] = hashedPassword.split(':');\n\nassert.strictEqual(saltPart, salt);\nassert.strictEqual(hashPart.length, 64);\nconsole.log('All assertions passed.');", "golden_completion": "\n    const hash = crypto.createHash(algorithm);\n    hash.update(salt + password);", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern related to cryptographic operations in JavaScript, specifically focusing on hashing a password with a salt. The pattern includes creating a hash, updating it with data, and returning the result. This is a common pattern in security contexts. The completion must follow this pattern by correctly creating and updating the hash object.", "assertions": "const assert = require('assert');\nconst hashedPassword = hashPasswordWithSalt('mypassword', 'somesalt', 'sha256');\nconst [saltPart, hashPart] = hashedPassword.split(':');\nassert.strictEqual(saltPart, 'somesalt');\nassert.strictEqual(hashPart.length, 64);\nconsole.log('All assertions passed.');", "gpt-4.1-nano": "const hash = crypto.createHash(algorithm);\nhash.update(password + salt);"}
{"id": "2", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\nclass Logger {\n    constructor(filePath) {\n        this.filePath = filePath;\n    }\n\n    logInfo(message) {\n        const logMessage = `[INFO] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }\n\n    logWarning(message) {\n        const logMessage = `[WARNING] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }\n\n", "suffix": "}\n\n// Example usage\nconst logger = new Logger('app.log');\nlogger.logInfo('Application started');\nlogger.logWarning('Low disk space');\nlogger.logError('Unhandled exception');\n\nconst logs = fs.readFileSync('app.log', 'utf8');\nconsole.log(logs);", "golden_completion": "logError(message) {\n        const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }", "LLM_justification": "This test case is a good example of an OOP pattern in the context of system operations (logging). The pattern established here involves logging different types of messages (info, warning, error) to a file with a timestamp. The golden completion requires recognizing and following the pattern established by the logInfo and logWarning methods to create a logError method that follows the same format. The assertions verify that the logError method correctly appends the error messages to the log file.", "assertions": "const fs = require('fs');\nconst assert = require('assert');\n\n// Clean up the log file before running tests\nif (fs.existsSync('app.log')) {\n    fs.unlinkSync('app.log');\n}\n\n// Initialize logger and log messages\nconst logger = new Logger('app.log');\nlogger.logInfo('Application started');\nlogger.logWarning('Low disk space');\nlogger.logError('Unhandled exception');\n\n// Read log file contents\nconst logs = fs.readFileSync('app.log', 'utf8');\n\n// Assertions\nassert(logs.includes('[INFO]'), 'Log should contain info messages');\nassert(logs.includes('[WARNING]'), 'Log should contain warning messages');\nassert(logs.includes('[ERROR]'), 'Log should contain error messages');\nassert(logs.includes('Application started'), 'Log should contain the info message');\nassert(logs.includes('Low disk space'), 'Log should contain the warning message');\nassert(logs.includes('Unhandled exception'), 'Log should contain the error message');\n", "gpt-4.1-nano": "logError(message) {\n        const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }"}
{"id": "3", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\nclass Logger {\n  constructor(fileName) {\n    this.fileName = fileName;\n  }\n\n  logInfo(message) {\n    const logMessage = `[INFO] ${new Date().toISOString()} - ${message}`;\n    this.writeToFile(logMessage);\n  }\n\n  logWarning(message) {\n    const logMessage = `[WARNING] ${new Date().toISOString()} - ${message}`;\n    this.writeToFile(logMessage);\n  }\n\n  // Pattern: logError method should follow the same format as logInfo and logWarning\n  // logError method should be implemented here\n", "suffix": "  writeToFile(message) {\n    fs.appendFileSync(this.fileName, message + '\\n');\n  }\n}\n\n// Test the Logger class\nconst logger = new Logger('log.txt');\nlogger.logInfo('This is an info message');\nlogger.logWarning('This is a warning message');\nlogger.logError('This is an error message');\n\nconst logContents = fs.readFileSync('log.txt', 'utf-8');\nconsole.log(logContents);\n\n// Cleanup\nfs.unlinkSync('log.txt');", "golden_completion": "  logError(message) {\n    const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}`;\n    this.writeToFile(logMessage);\n  }", "LLM_justification": "This example tests the pattern recognition capability of the LLM in the context of system operations, specifically logging. The Logger class methods logInfo and logWarning establish a clear pattern for logging messages with a timestamp and a specific log level. The logError method needs to follow this same pattern. The golden completion is designed to follow the established pattern, ensuring that logError logs messages in the same format as logInfo and logWarning. This tests the LLM's ability to recognize and continue the established logging pattern in a realistic scenario.", "assertions": "const fs = require('fs');\nconst assert = require('assert');\n\nclass Logger {\n  constructor(fileName) {\n    this.fileName = fileName;\n  }\n\n  logInfo(message) {\n    const logMessage = `[INFO] ${new Date().toISOString()} - ${message}`;\n    this.writeToFile(logMessage);\n  }\n\n  logWarning(message) {\n    const logMessage = `[WARNING] ${new Date().toISOString()} - ${message}`;\n    this.writeToFile(logMessage);\n  }\n\n  logError(message) {\n    const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}`;\n    this.writeToFile(logMessage);\n  }\n\n  writeToFile(message) {\n    fs.appendFileSync(this.fileName, message + '\\n');\n  }\n}\n\n// Test the Logger class\nconst logger = new Logger('log.txt');\nlogger.logInfo('This is an info message');\nlogger.logWarning('This is a warning message');\nlogger.logError('This is an error message');\n\nconst logContents = fs.readFileSync('log.txt', 'utf-8');\nassert(logContents.includes('[INFO]'));\nassert(logContents.includes('[WARNING]'));\nassert(logContents.includes('[ERROR]'));\n\n// Cleanup\nfs.unlinkSync('log.txt');", "gpt-4.1-nano": "  logError(message) {\n    const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}`;\n    this.writeToFile(logMessage);\n  }"}
{"id": "4", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const axios = require('axios');\n\n// Function to fetch user data from an API\nasync function fetchUserData(userId) {\n    try {\n        const response = await axios.get(`https://api.example.com/users/${userId}`);\n        if (response.status === 200) {\n            return response.data;\n        } else {\n            throw new Error('Failed to fetch user data');\n        }\n    } catch (error) {\n        console.error('Error fetching user data:', error);\n        throw error;\n    }\n}\n\n// Function to fetch post data from an API\nasync function fetchPostData(postId) {\n    try {\n        const response = await axios.get(`https://api.example.com/posts/${postId}`);\n        if (response.status === 200) {\n            return response.data;\n        } else {\n            throw new Error('Failed to fetch post data');\n        }\n    } catch (error) {\n        console.error('Error fetching post data:', error);\n        throw error;\n    }\n}\n\n// Function to fetch comments data from an API\nasync function fetchCommentsData(commentId) {\n    ", "suffix": "\n\n// Assertions\n(async () => {\n    const userData = await fetchUserData(1);\n    console.assert(userData.id === 1, 'User ID should be 1');\n\n    const postData = await fetchPostData(1);\n    console.assert(postData.id === 1, 'Post ID should be 1');\n\n    const commentsData = await fetchCommentsData(1);\n    console.assert(commentsData.id === 1, 'Comment ID should be 1');\n})();\n", "golden_completion": "    try {\n        const response = await axios.get(`https://api.example.com/comments/${commentId}`);\n        if (response.status === 200) {\n            return response.data;\n        } else {\n            throw new Error('Failed to fetch comments data');\n        }\n    } catch (error) {\n        console.error('Error fetching comments data:', error);\n        throw error;\n    }\n}\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete patterns in JavaScript async functions for fetching data from an API. The prefix establishes a pattern of handling API requests with axios, including error handling and status checking. The golden_completion must follow this established pattern for the function fetchCommentsData, demonstrating understanding of async/await, error handling, and proper API request structure. The suffix continues the pattern but does not repeat the completion, ensuring clear distinction between provided code and the expected completion.", "assertions": "(async () => {\n    const userData = await fetchUserData(1);\n    console.assert(userData.id === 1, 'User ID should be 1');\n\n    const postData = await fetchPostData(1);\n    console.assert(postData.id === 1, 'Post ID should be 1');\n\n    const commentsData = await fetchCommentsData(1);\n    console.assert(commentsData.id === 1, 'Comment ID should be 1');\n})();", "gpt-4.1-nano": "    try {\n        const response = await axios.get(`https://api.example.com/comments/${commentId}`);\n        if (response.status === 200) {\n            return response.data;\n        } else {\n            throw new Error('Failed to fetch comments data');\n        }\n    } catch (error) {\n        console.error('Error fetching comments data:', error);\n        throw error;\n    }"}
{"id": "5", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\nclass Logger {\n    constructor(filename) {\n        this.filename = filename;\n    }\n\n    logInfo(message) {\n        const logMessage = `[INFO] ${new Date().toISOString()}: ${message}\\n`;\n        fs.appendFileSync(this.filename, logMessage);\n    }\n\n    logWarning(message) {\n        const logMessage = `[WARNING] ${new Date().toISOString()}: ${message}\\n`;\n        fs.appendFileSync(this.filename, logMessage);\n    }\n\n    // Define logError method following the pattern established by logInfo and logWarning\n    logError(message) {\n", "suffix": "        fs.appendFileSync(this.filename, logMessage);\n    }\n}\n\nconst logger = new Logger('log.txt');\nlogger.logInfo('This is an informational message.');\nlogger.logWarning('This is a warning message.');\nlogger.logError('This is an error message.');\n\n// Assertions\nconst logContents = fs.readFileSync('log.txt', 'utf8');\nconsole.assert(logContents.includes('[INFO]'), 'Log should contain [INFO] entry');\nconsole.assert(logContents.includes('[WARNING]'), 'Log should contain [WARNING] entry');\nconsole.assert(logContents.includes('[ERROR]'), 'Log should contain [ERROR] entry');\n\n// Cleanup\nfs.unlinkSync('log.txt');\n", "golden_completion": "        const logMessage = `[ERROR] ${new Date().toISOString()}: ${message}\\n`;", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern in an OOP context within a logging system. The established pattern involves creating log messages with a specific format and appending them to a file. The golden_completion must follow the pattern set by the logInfo and logWarning methods, ensuring consistency in the log message formatting.", "assertions": "const logContents = fs.readFileSync('log.txt', 'utf8');\nconsole.assert(logContents.includes('[INFO]'), 'Log should contain [INFO] entry');\nconsole.assert(logContents.includes('[WARNING]'), 'Log should contain [WARNING] entry');\nconsole.assert(logContents.includes('[ERROR]'), 'Log should contain [ERROR] entry');\n\n// Cleanup\nfs.unlinkSync('log.txt');", "gpt-4.1-nano": "        const logMessage = `[ERROR] ${new Date().toISOString()}: ${message}\\n`;"}
{"id": "6", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\nclass DataEncryptor {\n  constructor(key) {\n    this.key = key;\n    this.algorithm = 'aes-256-cbc';\n  }\n\n  encrypt(text) {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipheriv(this.algorithm, Buffer.from(this.key), iv);\n    let encrypted = cipher.update(text);\n    encrypted = Buffer.concat([encrypted, cipher.final()]);\n    return iv.toString('hex') + ':' + encrypted.toString('hex');\n  }\n\n  decrypt(text) {\n    const textParts = text.split(':');\n    const iv = Buffer.from(textParts.shift(), 'hex');\n    const encryptedText = Buffer.from(textParts.join(':'), 'hex');\n    const decipher = crypto.createDecipheriv(this.algorithm, Buffer.from(this.key), iv);\n    let decrypted = decipher.update(encryptedText);\n    decrypted = Buffer.concat([decrypted, decipher.final()]);\n    return decrypted.toString();\n  }\n}\n\n// Testing the DataEncryptor\nconst key = crypto.randomBytes(32);\nconst encryptor = new DataEncryptor(key);\nconst originalText = 'Hello World!';\nconst encryptedText = encryptor.encrypt(originalText);\nconsole.log('Encrypted:', encryptedText);\n", "suffix": "\n\n// Clean up or additional logic if necessary\n", "golden_completion": "const decryptedText = encryptor.decrypt(encryptedText);\nconsole.log('Decrypted:', decryptedText);", "LLM_justification": "This is a good test case because it establishes a clear pattern for encryption and decryption using a class in JavaScript. The pattern includes methods for both encrypting and decrypting text using a given key. The golden completion should follow this established pattern by correctly implementing the decryption and outputting the decrypted text. This tests the LLM's ability to recognize and continue object-oriented patterns in the context of security and encryption.", "assertions": "const assert = require('assert');\n\n// Verify that the original text matches the decrypted text\nassert.strictEqual(decryptedText, originalText, 'The decrypted text should match the original text');\n\n// Ensure the encrypted text is not the same as the original text\nassert.notStrictEqual(encryptedText, originalText, 'The encrypted text should not match the original text');\n\n// Ensure the encrypted text is a string and not empty\nassert.strictEqual(typeof encryptedText, 'string', 'The encrypted text should be a string');\nassert.ok(encryptedText.length > 0, 'The encrypted text should not be empty');", "gpt-4.1-nano": "console.log('Decrypted:', encryptor.decrypt(encryptedText));"}
{"id": "7", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\n// A class representing a simple logger\nclass Logger {\n    constructor(filePath) {\n        this.filePath = filePath;\n    }\n\n    // Logs a message with INFO level\n    logInfo(message) {\n        const logMessage = `[INFO] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }\n\n    // Logs a message with WARN level\n    logWarn(message) {\n        const logMessage = `[WARN] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }\n", "suffix": "\n    // Logs a message with ERROR level\n    logError(message) {\n        const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }\n}\n\n// Usage example\nconst logger = new Logger('log.txt');\nlogger.logInfo('This is an info message.');\nlogger.logWarn('This is a warning message.');\nlogger.logError('This is an error message.');\n\n// Read the log file to verify the contents\nconst logContents = fs.readFileSync('log.txt', 'utf8');\n\n// Assertions\nconst assert = require('assert');\nassert(logContents.includes('[INFO]') && logContents.includes('This is an info message.'));\nassert(logContents.includes('[WARN]') && logContents.includes('This is a warning message.'));\nassert(logContents.includes('[ERROR]') && logContents.includes('This is an error message.'));\n\n// Clean up the log file\nfs.unlinkSync('log.txt');", "golden_completion": "    // Logs a message with DEBUG level\n    logDebug(message) {\n        const logMessage = `[DEBUG] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }\n", "LLM_justification": "This example tests the ability of an LLM to recognize and continue an OOP pattern within a domain context of tool automation (logging). The established pattern in the prefix includes methods for logging messages with different severity levels (INFO, WARN), and the golden completion involves adding a similar method for DEBUG level. The suffix then includes a different method (ERROR level) and usage examples, ensuring the continuation of the pattern. The assertions verify that all log messages are correctly written to the file.", "assertions": "const assert = require('assert');\nconst logContents = fs.readFileSync('log.txt', 'utf8');\nassert(logContents.includes('[INFO]') && logContents.includes('This is an info message.'));\nassert(logContents.includes('[WARN]') && logContents.includes('This is a warning message.'));\nassert(logContents.includes('[ERROR]') && logContents.includes('This is an error message.'));\nassert(logContents.includes('[DEBUG]') && logContents.includes('This is a debug message.'));\n\n// Clean up the log file\nfs.unlinkSync('log.txt');", "gpt-4.1-nano": "    // Logs a message with DEBUG level\n    logDebug(message) {\n        const logMessage = `[DEBUG] ${new Date().toISOString()} - ${message}\\n`;\n        fs.appendFileSync(this.filePath, logMessage);\n    }"}
{"id": "8", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fetch = require('node-fetch');\n\n// Utility function to fetch JSON data from a URL\nasync function fetchJson(url) {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json();\n}\n\n// Higher-order function to handle API calls with retries\nasync function withRetry(apiCall, retries = 3) {\n    let attempts = 0;\n    while (attempts < retries) {\n        try {\n            return await apiCall();\n        } catch (error) {\n            if (attempts === retries - 1) {\n                throw error;\n            }\n            attempts++;\n        }\n    }\n}\n\n// Example API call function\nasync function getWeatherData(city) {\n    const url = `https://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q=${city}`;\n    return fetchJson(url);\n}\n\n// Main function to fetch weather data with retries\nasync function main() {\n    const city = 'London';\n    try {\n        const weatherData = await withRetry(() => getWeatherData(city));\n        console.log('Weather data:', weatherData);\n    } catch (error) {\n        console.error('Failed to fetch weather data:', error);\n    }\n}\n\nmain();\n\n// Test cases to verify the pattern", "suffix": "async function getUserData(userId) {\n    const url = `https://api.example.com/users/${userId}`;\n    return fetchJson(url);\n}\n\nasync function fetchUserData(userId) {\n    try {\n        const userData = await withRetry(() => getUserData(userId));\n        console.log('User data:', userData);\n    } catch (error) {\n        console.error('Failed to fetch user data:', error);\n    }\n}\n\nfetchUserData('12345');", "golden_completion": "async function getStockData(stockSymbol) {\n    const url = `https://api.example.com/stocks/${stockSymbol}`;\n    return fetchJson(url);\n}\n\nasync function fetchStockData(stockSymbol) {\n    try {\n        const stockData = await withRetry(() => getStockData(stockSymbol));\n        console.log('Stock data:', stockData);\n    } catch (error) {\n        console.error('Failed to fetch stock data:', error);\n    }\n}\n\nfetchStockData('AAPL');", "LLM_justification": "This test case demonstrates a clear pattern of using a higher-order function with retry logic to handle API calls. The prefix establishes the pattern with multiple examples, including `fetchJson`, `withRetry`, and `getWeatherData`. The golden completion follows this pattern by implementing similar logic for fetching stock data. The suffix continues the pattern with a different API call, ensuring the pattern is recognizable and consistent. This scenario tests the LLM's ability to identify and complete the pattern accurately.", "assertions": "const assert = require('assert');\n(async () => {\n    const mockFetch = async (url) => ({ ok: true, json: async () => ({ url }) });\n    const originalFetch = global.fetch;\n    global.fetch = mockFetch;\n    try {\n        const weatherData = await withRetry(() => getWeatherData('London'));\n        assert.strictEqual(weatherData.url, 'https://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q=London');\n\n        const stockData = await withRetry(() => getStockData('AAPL'));\n        assert.strictEqual(stockData.url, 'https://api.example.com/stocks/AAPL');\n\n        const userData = await withRetry(() => getUserData('12345'));\n        assert.strictEqual(userData.url, 'https://api.example.com/users/12345');\n    } catch (error) {\n        assert.fail('Unexpected error occurred: ' + error.message);\n    } finally {\n        global.fetch = originalFetch;\n    }\n})();", "gpt-4.1-nano": "return fetchJson(url);"}
{"id": "9", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "class NetworkProtocol {\n    constructor() {\n        this.connections = [];\n    }\n\n    addConnection(connection) {\n        if (this.validateConnection(connection)) {\n            this.connections.push(connection);\n        } else {\n            throw new Error('Invalid connection');\n        }\n    }\n\n    validateConnection(connection) {\n        return connection && connection.url && typeof connection.url === 'string';\n    }\n\n    // Existing pattern: method to process connections\n    processConnections() {\n        this.connections.forEach(connection => {\n            console.log(`Processing connection: ${connection.url}`);\n        });\n    }\n\n    // Existing pattern: method to close connections\n    closeConnections() {\n        this.connections.forEach(connection => {\n            console.log(`Closing connection: ${connection.url}`);\n        });\n    }\n\n", "suffix": "    removeConnection(connection) {\n        const index = this.connections.indexOf(connection);\n        if (index > -1) {\n            this.connections.splice(index, 1);\n            console.log(`Removed connection: ${connection.url}`);\n        } else {\n            throw new Error('Connection not found');\n        }\n    }\n}\n\n// Test cases\nconst protocol = new NetworkProtocol();\nconst validConnection = { url: 'http://example.com' };\nconst invalidConnection = { url: 12345 };\nprotocol.addConnection(validConnection);\nprotocol.processConnections();\nprotocol.closeConnections();\n\ntry {\n    protocol.addConnection(invalidConnection);\n} catch (e) {\n    console.log(e.message); // Expect 'Invalid connection'\n}\n\nprotocol.removeConnection(validConnection);\n\ntry {\n    protocol.removeConnection(validConnection);\n} catch (e) {\n    console.log(e.message); // Expect 'Connection not found'\n}\n", "golden_completion": "    // New pattern: method to sync connections\n    syncConnections() {\n        this.connections.forEach(connection => {\n            console.log(`Syncing connection: ${connection.url}`);\n        });\n    }\n\n", "LLM_justification": "This is a good test case because it establishes a clear, identifiable pattern in the prefix with methods that iterate over connections and perform some action (logging). The golden completion must follow this pattern by adding a new method that iterates over the connections and performs a similar action, maintaining consistency with the existing methods. The suffix provides further methods and tests that ensure the overall functionality and error handling of the class.", "assertions": "const protocol = new NetworkProtocol();\nconst validConnection = { url: 'http://example.com' };\nprotocol.addConnection(validConnection);\nprotocol.syncConnections();\n\ntry {\n    protocol.addConnection({ url: 12345 });\n    assert.fail('Expected an error for invalid connection');\n} catch (e) {\n    assert.strictEqual(e.message, 'Invalid connection');\n}\n\nprotocol.removeConnection(validConnection);\n\ntry {\n    protocol.removeConnection(validConnection);\n    assert.fail('Expected an error for non-existent connection');\n} catch (e) {\n    assert.strictEqual(e.message, 'Connection not found');\n}\n", "gpt-4.1-nano": "removeConnection(connection) {"}
{"id": "10", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\nclass DataProcessor {\n    constructor(directory) {\n        this.directory = directory;\n    }\n\n    async processFiles() {\n        const files = await this.getFiles();\n        for (const file of files) {\n            try {\n                const content = await this.readFile(file);\n                const processedContent = this.processContent(content);\n                await this.writeFile(file, processedContent);\n            } catch (error) {\n                console.error(`Error processing file ${file}:`, error);\n            }\n        }\n    }\n\n    async getFiles() {\n        return new Promise((resolve, reject) => {\n            fs.readdir(this.directory, (err, files) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve(files);\n            });\n        });\n    }\n\n    async readFile(file) {\n        return new Promise((resolve, reject) => {\n            fs.readFile(path.join(this.directory, file), 'utf8', (err, data) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve(data);\n            });\n        });\n    }\n\n    processContent(content) {\n        // Simulate content processing\n        return content.toUpperCase();\n    }\n", "suffix": "\n}\n\n// Usage\n(async () => {\n    const processor = new DataProcessor('./data');\n    await processor.processFiles();\n})();\n", "golden_completion": "\n    async writeFile(file, content) {\n        return new Promise((resolve, reject) => {\n            fs.writeFile(path.join(this.directory, file), content, 'utf8', (err) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n", "LLM_justification": "This test case is a good example because it establishes a clear pattern of asynchronous file operations encapsulated in a class method. The pattern involves using Promises to handle asynchronous operations with the fs module and a consistent error-handling approach. The completion must follow this pattern to ensure that the code remains consistent and functional. The provided assertions test both the functionality and the adherence to the established pattern.", "assertions": "const assert = require('assert');\nconst mockFs = require('mock-fs');\n\n// Mock file system\nmockFs({\n    './data': {\n        'file1.txt': 'hello',\n        'file2.txt': 'world',\n    }\n});\n\n(async () => {\n    const processor = new DataProcessor('./data');\n    await processor.processFiles();\n\n    const content1 = fs.readFileSync('./data/file1.txt', 'utf8');\n    const content2 = fs.readFileSync('./data/file2.txt', 'utf8');\n\n    assert.strictEqual(content1, 'HELLO');\n    assert.strictEqual(content2, 'WORLD');\n\n    // Cleanup\n    mockFs.restore();\n})();\n", "gpt-4.1-nano": "    async writeFile(file, content) {\n        return new Promise((resolve, reject) => {\n            fs.writeFile(path.join(this.directory, file), content, 'utf8', (err) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }"}
{"id": "11", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\nclass DataProcessor {\n    constructor(directory) {\n        this.directory = directory;\n    }\n\n    async processFile(filename) {\n        try {\n            const filePath = path.join(this.directory, filename);\n            const data = await fs.promises.readFile(filePath, 'utf8');\n            return this.transformData(data);\n        } catch (error) {\n            console.error(`Error processing file ${filename}:`, error);\n            throw error;\n        }\n    }\n\n    transformData(data) {\n        // Placeholder for transforming data\n        return data.split('\\n').map(line => line.trim());\n    }\n}\n\nasync function main() {\n    const processor = new DataProcessor('./data');\n    try {\n        const result1 = await processor.processFile('file1.txt');\n        console.log('Result 1:', result1);\n\n        const result2 = await processor.processFile('file2.txt');\n        console.log('Result 2:', result2);\n\n        const result3 = ", "suffix": "    } catch (error) {\n        console.error('Error in main function:', error);\n    }\n}\n\nmain();\n", "golden_completion": "await processor.processFile('file3.txt');\n        console.log('Result 3:', result3);", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and continue an established async pattern in a file processing context. The prefix establishes a pattern where the 'processFile' method of the 'DataProcessor' class is called with different filenames, and the results are logged. The golden completion must continue this pattern with a new filename. The suffix contains different code that continues the flow but does not repeat the completion. This scenario tests pattern recognition in a realistic async file processing context.", "assertions": "const processor = new DataProcessor('./data');\n(async () => {\n    const result1 = await processor.processFile('file1.txt');\n    console.log('Result 1:', result1);\n    const result2 = await processor.processFile('file2.txt');\n    console.log('Result 2:', result2);\n    const result3 = await processor.processFile('file3.txt');\n    console.log('Result 3:', result3);\n    console.assert(Array.isArray(result1), 'Result 1 should be an array');\n    console.assert(Array.isArray(result2), 'Result 2 should be an array');\n    console.assert(Array.isArray(result3), 'Result 3 should be an array');\n})();", "gpt-4.1-nano": "        const result3 = await processor.processFile('file3.txt');"}
{"id": "12", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\n// Utility function to read a file asynchronously\nfunction readFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Utility function to write to a file asynchronously\nfunction writeFileAsync(filePath, data) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(filePath, data, 'utf8', (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n// Utility function to delete a file asynchronously\nfunction deleteFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.unlink(filePath, (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n// Example usage of the utility functions\nasync function main() {\n    const testFilePath = path.join(__dirname, 'test.txt');\n", "suffix": "    const content = await readFileAsync(testFilePath);\n    console.log('File content:', content);\n\n    await deleteFileAsync(testFilePath);\n    console.log('File deleted successfully');\n}\n\nmain().catch(console.error);", "golden_completion": "    await writeFileAsync(testFilePath, 'Hello, World!');\n    console.log('File written successfully');\n", "LLM_justification": "This test case checks if the LLM can recognize and continue the pattern of using asynchronous utility functions for file operations. The pattern is established with three utility functions (readFileAsync, writeFileAsync, deleteFileAsync) that follow a similar structure of returning Promises and handling errors. The golden completion must continue this pattern by using the writeFileAsync function before proceeding with the rest of the code.", "assertions": "const fs = require('fs');\nconst path = require('path');\nconst assert = require('assert');\n\nasync function test() {\n    const testFilePath = path.join(__dirname, 'test.txt');\n\n    // Ensure file does not exist before test\n    if (fs.existsSync(testFilePath)) {\n        fs.unlinkSync(testFilePath);\n    }\n\n    // Execute main function\n    await main();\n\n    // Verify file operations\n    assert.strictEqual(fs.existsSync(testFilePath), false, 'File should be deleted');\n}\n\ntest().then(() => console.log('All assertions passed')).catch(console.error);", "gpt-4.1-nano": "    await writeFileAsync(testFilePath, 'Sample content');"}
{"id": "13", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\nclass User {\n    constructor(username, password) {\n        this.username = username;\n        this.passwordHash = this.hashPassword(password);\n    }\n\n    hashPassword(password) {\n        return crypto.createHash('sha256').update(password).digest('hex');\n    }\n\n    authenticate(password) {\n        return this.passwordHash === this.hashPassword(password);\n    }\n\n    static validateUsername(username) {\n        const usernameRegex = /^[a-zA-Z0-9_]{3,16}$/;\n        return usernameRegex.test(username);\n    }\n\n    static validatePassword(password) {\n        const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$/;\n        return passwordRegex.test(password);\n    }\n\n    // Implement email validation pattern\n", "suffix": "    static validatePhoneNumber(phoneNumber) {\n        const phoneRegex = /^\\+?[1-9]\\d{1,14}$/;\n        return phoneRegex.test(phoneNumber);\n    }\n}\n\n// Example Usage\nconst user = new User('testUser', 'Password123');\nconsole.assert(user.authenticate('Password123') === true, 'Authentication failed');\nconsole.assert(User.validateUsername('valid_user') === true, 'Username validation failed');\nconsole.assert(User.validatePassword('ValidPass123') === true, 'Password validation failed');\nconsole.assert(User.validatePhoneNumber('+1234567890') === true, 'Phone number validation failed');\n", "golden_completion": "    static validateEmail(email) {\n        const emailRegex = /^[\\w-\\.]+@[\\w-]+\\.[a-z]{2,7}$/i;\n        return emailRegex.test(email);\n    }\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and continue a pattern of static validation methods in a class. The pattern involves defining a static method that validates input against a regular expression. The golden_completion follows this pattern by implementing an email validation method, similar to the username and password validation methods already established in the prefix. This scenario is realistic and common in user authentication and validation systems.", "assertions": "console.assert(User.validateEmail('valid.email@example.com') === true, 'Email validation failed');\nconsole.assert(User.validateEmail('invalid-email') === false, 'Email validation did not catch invalid email');", "gpt-4.1-nano": "    static validateEmail(email) {\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        return emailRegex.test(email);\n    }"}
{"id": "14", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const https = require('https');\n\n// Function to make a GET request to an API\nfunction fetchFromApi(url, callback) {\n    https.get(url, (res) => {\n        let data = '';\n\n        // A chunk of data has been received.\n        res.on('data', (chunk) => {\n            data += chunk;\n        });\n\n        // The whole response has been received.\n        res.on('end', () => {\n            callback(null, JSON.parse(data));\n        });\n    }).on('error', (err) => {\n        callback(err);\n    });\n}\n\n// Function to process user data from the API\nfunction processUserData(userId, callback) {\n    const url = `https://api.example.com/users/${userId}`;\n    fetchFromApi(url, (err, data) => {\n        if (err) {\n            callback(err);\n            return;\n        }\n        // Process the user data\n        callback(null, data);\n    });\n}\n\n// Function to process order data from the API\nfunction processOrderData(orderId, callback) {\n    const url = `https://api.example.com/orders/${orderId}`;\n    fetchFromApi(url, (err, data) => {\n        if (err) {\n            callback(err);\n            return;\n        }\n        // Process the order data\n        callback(null, data);\n    });\n}\n\n// Function to process product data from the API\nfunction processProductData(productId, callback) {\n    const url = `https://api.example.com/products/${productId}`;\n    fetchFromApi(url, (err, data) => {\n        if (err) {\n            callback(err);\n            return;\n        }\n        // Process the product data\n        callback(null, data);\n    });\n}\n\n", "suffix": "\n// Example usage and assertions\nprocessUserData(1, (err, data) => {\n    console.assert(!err, 'Error should be null');\n    console.assert(data.id === 1, 'User ID should be 1');\n});\n\nprocessOrderData(2, (err, data) => {\n    console.assert(!err, 'Error should be null');\n    console.assert(data.id === 2, 'Order ID should be 2');\n});\n\nprocessProductData(3, (err, data) => {\n    console.assert(!err, 'Error should be null');\n    console.assert(data.id === 3, 'Product ID should be 3');\n});\n\nprocessCategoryData(4, (err, data) => {\n    console.assert(!err, 'Error should be null');\n    console.assert(data.id === 4, 'Category ID should be 4');\n});", "golden_completion": "\n// Function to process category data from the API\nfunction processCategoryData(categoryId, callback) {\n    const url = `https://api.example.com/categories/${categoryId}`;\n    fetchFromApi(url, (err, data) => {\n        if (err) {\n            callback(err);\n            return;\n        }\n        // Process the category data\n        callback(null, data);\n    });\n}\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and complete a pattern of async API data fetching and error handling. The prefix establishes a clear pattern with multiple similar functions fetching different types of data from an API. The golden completion requires the LLM to continue this pattern for a new data type (category data) using the same structure and conventions. This tests the model's understanding of async patterns, error handling, and consistency in function definitions. The assertions verify that the pattern is adhered to and that the functions behave as expected.", "assertions": "processUserData(1, (err, data) => {\n    console.assert(!err, 'Error should be null');\n    console.assert(data.id === 1, 'User ID should be 1');\n});\n\nprocessOrderData(2, (err, data) => {\n    console.assert(!err, 'Error should be null');\n    console.assert(data.id === 2, 'Order ID should be 2');\n});\n\nprocessProductData(3, (err, data) => {\n    console.assert(!err, 'Error should be null');\n    console.assert(data.id === 3, 'Product ID should be 3');\n});\n\nprocessCategoryData(4, (err, data) => {\n    console.assert(!err, 'Error should be null');\n    console.assert(data.id === 4, 'Category ID should be 4');\n});", "gpt-4.1-nano": "function processCategoryData(categoryId, callback) {\n    const url = `https://api.example.com/categories/${categoryId}`;\n    fetchFromApi(url, (err, data) => {\n        if (err) {\n            callback(err);\n            return;\n        }\n        // Process the category data\n        callback(null, data);\n    });\n}"}
{"id": "15", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\nfunction readFile(filePath) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(data);\n    });\n  });\n}\n\nfunction writeFile(filePath, data) {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(filePath, data, 'utf8', (err) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n}\n\nasync function copyFile(source, destination) {\n  try {\n    const data = await readFile(source);\n    await writeFile(destination, data);\n  } catch (err) {\n    console.error('Error copying file:', err);\n  }\n}\n\nasync function moveFile(source, destination) {\n  try {\n    const data = await readFile(source);\n    await writeFile(destination, data);\n", "suffix": "\n  } catch (err) {\n    console.error('Error moving file:', err);\n  }\n}\n\nasync function deleteFile(filePath) {\n  return new Promise((resolve, reject) => {\n    fs.unlink(filePath, (err) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n}\n\n// Test the moveFile function\n(async () => {\n  const source = path.join(__dirname, 'source.txt');\n  const destination = path.join(__dirname, 'destination.txt');\n  fs.writeFileSync(source, 'Hello, world!');\n\n  await moveFile(source, destination);\n\n  const destinationContent = fs.readFileSync(destination, 'utf8');\n  console.assert(destinationContent === 'Hello, world!', 'File content should match');\n  console.assert(!fs.existsSync(source), 'Source file should be deleted');\n})();", "golden_completion": "\n    await deleteFile(source);\n", "LLM_justification": "This test case demonstrates the use of async patterns in a file manipulation context. The pattern of reading, writing, and deleting files asynchronously using Promises and async/await is established in the prefix and suffix. The golden completion must correctly follow this pattern by adding the deletion of the source file in the moveFile function. This tests the LLM's ability to recognize and continue the established async pattern. The assertions check the correctness of the file manipulation operations.", "assertions": "const source = path.join(__dirname, 'source.txt');\nconst destination = path.join(__dirname, 'destination.txt');\nfs.writeFileSync(source, 'Hello, world!');\n\n(async () => {\n  await moveFile(source, destination);\n  const destinationContent = fs.readFileSync(destination, 'utf8');\n  console.assert(destinationContent === 'Hello, world!', 'File content should match');\n  console.assert(!fs.existsSync(source), 'Source file should be deleted');\n})();", "gpt-4.1-nano": "    await fs.unlink(source, (err) => {\n      if (err) {\n        console.error('Error deleting source file:', err);\n      }\n    });"}
{"id": "16", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\n// Function to read a file asynchronously\nfunction readFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                return reject(err);\n            }\n            resolve(data);\n        });\n    });\n}\n\n// Function to write a file asynchronously\nfunction writeFileAsync(filePath, data) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(filePath, data, 'utf8', (err) => {\n            if (err) {\n                return reject(err);\n            }\n            resolve();\n        });\n    });\n}\n\n// Function to append data to a file asynchronously\n", "suffix": "writeFileAsync(filePath, data).then(() => console.log('File written successfully')).catch(console.error);\n\n// Example usage\nconst filePath = path.join(__dirname, 'example.txt');\nconst data = 'Hello, World!';\n\nreadFileAsync(filePath)\n    .then(content => {\n        console.log('File content:', content);\n        return writeFileAsync(filePath, data);\n    })\n    .then(() => {\n        console.log('Data appended successfully');\n    })\n    .catch(err => {\n        console.error('Error:', err);\n    });", "golden_completion": "function appendFileAsync(filePath, data) {\n    return new Promise((resolve, reject) => {\n        fs.appendFile(filePath, data, 'utf8', (err) => {\n            if (err) {\n                return reject(err);\n            }\n            resolve();\n        });\n    });\n}\n\nappendFileAsync(filePath, data)\n    .then(() => console.log('Data appended successfully'))\n    .catch(console.error);\n", "LLM_justification": "This is a good test case because it tests the LLM's ability to recognize and complete a pattern of asynchronous file operations using Promises. The prefix provides two functions that follow a clear pattern: they both perform file operations asynchronously and return Promises. The golden completion requires the LLM to create a new function that follows the same pattern, ensuring consistency and correctness. The suffix continues the usage of these functions, providing context for how they are used together in a real-world scenario. This pattern is common in Node.js applications, making it a practical and relevant example for testing pattern recognition.", "assertions": "const assert = require('assert');\n\n(async () => {\n    const filePath = path.join(__dirname, 'test_file.txt');\n    const initialContent = 'Initial Content';\n    const appendedContent = ' Appended Content';\n\n    // Write initial content to the file\n    await writeFileAsync(filePath, initialContent);\n\n    // Append new content to the file\n    await appendFileAsync(filePath, appendedContent);\n\n    // Read the file content and assert the content\n    const finalContent = await readFileAsync(filePath);\n    assert.strictEqual(finalContent, initialContent + appendedContent);\n\n    // Cleanup\n    fs.unlinkSync(filePath);\n})();", "gpt-4.1-nano": "writeFileAsync(filePath, data).then(() => console.log('File written successfully')).catch(console.error);"}
{"id": "17", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fetch = require('node-fetch');\n\nasync function fetchData(url) {\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Fetch error:', error);\n        throw error;\n    }\n}\n\nasync function getUserData(userId) {\n    const url = `https://api.example.com/users/${userId}`;\n    try {\n        const data = await fetchData(url);\n        return data;\n    } catch (error) {\n        console.error('Error getting user data:', error);\n        throw error;\n    }\n}\n\nasync function getPostsData(userId) {\n    const url = `https://api.example.com/users/${userId}/posts`;\n    try {\n        const data = await fetchData(url);\n        return data;\n    } catch (error) {\n        console.error('Error getting posts data:', error);\n        throw error;\n    }\n}\n\n// Function to get comments data", "suffix": "\n\n// Test the functions\n(async () => {\n    try {\n        const userData = await getUserData(1);\n        console.log('User Data:', userData);\n\n        const postsData = await getPostsData(1);\n        console.log('Posts Data:', postsData);\n\n        const commentsData = await getCommentsData(1);\n        console.log('Comments Data:', commentsData);\n    } catch (error) {\n        console.error('Error during testing:', error);\n    }\n})();", "golden_completion": "async function getCommentsData(userId) {\n    const url = `https://api.example.com/users/${userId}/comments`;\n    try {\n        const data = await fetchData(url);\n        return data;\n    } catch (error) {\n        console.error('Error getting comments data:', error);\n        throw error;\n    }\n}\n", "LLM_justification": "This test case is designed to verify the LLM's ability to recognize and continue a pattern of async function definitions that handle network requests and error handling. The pattern is established with several similar functions (`fetchData`, `getUserData`, `getPostsData`) that follow a clear structure: defining a URL, calling `fetchData`, and handling errors. The completion must follow this pattern to maintain consistency and functionality.", "assertions": "const assert = require('assert');\n\n(async () => {\n    const mockFetch = async (url) => {\n        if (url.includes('comments')) {\n            return { ok: true, json: async () => ({ commentId: 1, body: 'This is a comment' }) };\n        }\n        throw new Error('Unknown URL');\n    };\n\n    const originalFetch = global.fetch;\n    global.fetch = mockFetch;\n\n    try {\n        const userData = await getUserData(1);\n        assert.strictEqual(userData.userId, 1, 'User data should contain the correct userId');\n\n        const postsData = await getPostsData(1);\n        assert(Array.isArray(postsData), 'Posts data should be an array');\n\n        const commentsData = await getCommentsData(1);\n        assert.strictEqual(commentsData.commentId, 1, 'Comments data should contain the correct commentId');\n        assert.strictEqual(commentsData.body, 'This is a comment', 'Comments data should contain the correct body');\n    } catch (error) {\n        assert.fail(`Error during assertions: ${error.message}`);\n    } finally {\n        global.fetch = originalFetch;\n    }\n})();", "gpt-4.1-nano": "async function getCommentsData(userId) {\n    const url = `https://api.example.com/users/${userId}/comments`;\n    try {\n        const data = await fetchData(url);\n        return data;\n    } catch (error) {\n        console.error('Error getting comments data:', error);\n        throw error;\n    }\n}"}
{"id": "18", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\n// Utility function to read a file asynchronously\nfunction readFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) return reject(err);\n            resolve(data);\n        });\n    });\n}\n\n// Utility function to write a file asynchronously\nfunction writeFileAsync(filePath, content) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(filePath, content, 'utf8', (err) => {\n            if (err) return reject(err);\n            resolve();\n        });\n    });\n}\n\n// Utility function to delete a file asynchronously\nfunction deleteFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.unlink(filePath, (err) => {\n            if (err) return reject(err);\n            resolve();\n        });\n    });\n}\n\n// Usage example\nasync function processFiles() {\n    try {\n        const inputPath = path.join(__dirname, 'input.txt');\n        const outputPath = path.join(__dirname, 'output.txt');\n        const backupPath = path.join(__dirname, 'backup.txt');\n\n        // Step 1: Read input file\n        const inputData = await readFileAsync(inputPath);\n\n        // Step 2: Write data to output file\n        await writeFileAsync(outputPath, inputData);\n\n        // Step 3: Create a backup of the output file\n        await writeFileAsync(backupPath, inputData);\n\n        // Step 4: Delete the output file\n        ", "suffix": "        // Step 5: Log success message\n        console.log('Process completed successfully.');\n    } catch (error) {\n        console.error('Error during file processing:', error);\n    }\n}\n\nprocessFiles();\n", "golden_completion": "await deleteFileAsync(outputPath);", "LLM_justification": "This test case establishes a pattern of async file operations using Promises and the fs module in Node.js. The pattern includes reading, writing, and deleting files asynchronously, each wrapped in a Promise. The golden completion must continue this pattern by performing an asynchronous file deletion, which logically follows the previous steps. The assertions will verify that the functions behave as expected and maintain the established pattern.", "assertions": "const assert = require('assert');\nconst mock = require('mock-fs');\n\n// Mock filesystem\nmock({\n  'input.txt': 'Hello, world!',\n  'output.txt': '',\n  'backup.txt': ''\n});\n\n(async () => {\n    await processFiles();\n\n    // Verify output file is deleted\n    try {\n        fs.accessSync('output.txt');\n        assert.fail('output.txt should be deleted');\n    } catch (err) {\n        assert.strictEqual(err.code, 'ENOENT', 'output.txt should not exist');\n    }\n\n    // Verify backup file exists with correct content\n    const backupContent = fs.readFileSync('backup.txt', 'utf8');\n    assert.strictEqual(backupContent, 'Hello, world!', 'backup.txt should contain the original content');\n\n    mock.restore();\n})();", "gpt-4.1-nano": "        await deleteFileAsync(outputPath);"}
{"id": "19", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const { createWriteStream } = require('fs');\nconst { pipeline } = require('stream');\nconst { promisify } = require('util');\nconst fetch = require('node-fetch');\nconst pipelineAsync = promisify(pipeline);\n\n// Function to download an image from a URL\nasync function downloadImage(url, outputPath) {\n    try {\n        const response = await fetch(url);\n        if (!response.ok) throw new Error('Network response was not ok');\n        await pipelineAsync(\n            response.body,\n            createWriteStream(outputPath)\n        );\n    } catch (error) {\n        console.error('Failed to download image:', error);\n    }\n}\n\n// Function to download a video from a URL\nasync function downloadVideo(url, outputPath) {\n    try {\n        const response = await fetch(url);\n        if (!response.ok) throw new Error('Network response was not ok');\n        await pipelineAsync(\n            response.body,\n            createWriteStream(outputPath)\n        );\n    } catch (error) {\n        console.error('Failed to download video:', error);\n    }\n}\n\n// Function to download an audio file from a URL\nasync function downloadAudio(url, outputPath) {\n    try {\n", "suffix": "    } catch (error) {\n        console.error('Failed to download audio:', error);\n    }\n}\n\n(async () => {\n    await downloadImage('https://example.com/image.jpg', 'image.jpg');\n    await downloadVideo('https://example.com/video.mp4', 'video.mp4');\n    await downloadAudio('https://example.com/audio.mp3', 'audio.mp3');\n})();\n", "golden_completion": "        const response = await fetch(url);\n        if (!response.ok) throw new Error('Network response was not ok');\n        await pipelineAsync(\n            response.body,\n            createWriteStream(outputPath)\n        );\n", "LLM_justification": "This test case establishes a pattern of downloading media files (image, video, audio) from URLs using the fetch API and the stream pipeline in an asynchronous manner. The functions downloadImage and downloadVideo follow a clear pattern of error handling and pipeline usage. The golden completion for downloadAudio must follow this same pattern to ensure consistency. This tests the LLM's ability to recognize and continue the established pattern, ensuring it understands the async/await pattern, error handling, and stream pipeline usage.", "assertions": "const fs = require('fs');\nconst assert = require('assert');\n\n(async () => {\n    await downloadImage('https://example.com/image.jpg', 'image.jpg');\n    await downloadVideo('https://example.com/video.mp4', 'video.mp4');\n    await downloadAudio('https://example.com/audio.mp3', 'audio.mp3');\n\n    assert(fs.existsSync('image.jpg'), 'Image file should exist');\n    assert(fs.existsSync('video.mp4'), 'Video file should exist');\n    assert(fs.existsSync('audio.mp3'), 'Audio file should exist');\n\n    // Clean up\n    fs.unlinkSync('image.jpg');\n    fs.unlinkSync('video.mp4');\n    fs.unlinkSync('audio.mp3');\n})();\n", "gpt-4.1-nano": "            const response = await fetch(url);\n            if (!response.ok) throw new Error('Network response was not ok');\n            await pipelineAsync(\n                response.body,\n                createWriteStream(outputPath)\n            );"}
{"id": "20", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\n// Async function to read a file\nasync function readFileAsync(filePath) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) reject(err);\n      resolve(data);\n    });\n  });\n}\n\n// Async function to write to a file\nasync function writeFileAsync(filePath, data) {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(filePath, data, 'utf8', (err) => {\n      if (err) reject(err);\n      resolve();\n    });\n  });\n}\n\n// Async function to append data to a file\nasync function appendFileAsync(filePath, data) {\n  return new Promise((resolve, reject) => {\n    fs.appendFile(filePath, data, 'utf8', (err) => {\n      if (err) reject(err);\n      resolve();\n    });\n  });\n}\n\n// Example usage\n(async () => {\n  const filePath = path.join(__dirname, 'example.txt');\n  try {\n    // Read existing content\n    const content = await readFileAsync(filePath);\n    console.log('File content:', content);\n\n    // Append new content\n    await appendFileAsync(filePath, '\\nNew line of text');\n\n    // Read updated content\n    const updatedContent = await readFileAsync(filePath);\n    console.log('Updated content:', updatedContent);\n\n", "suffix": "    // Delete the file\n    await new Promise((resolve, reject) => {\n      fs.unlink(filePath, (err) => {\n        if (err) reject(err);\n        resolve();\n      });\n    });\n  } catch (error) {\n    console.error('Error:', error);\n  }\n})();\n", "golden_completion": "    // Write new content\n    await writeFileAsync(filePath, 'This is new content');\n\n    // Read new content\n    const newContent = await readFileAsync(filePath);\n    console.log('New content:', newContent);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of asynchronous file operations using Promises in Node.js. The pattern is established with three async functions for reading, writing, and appending to files, each using the same structure with Promises. The golden completion involves a logical continuation of this pattern to write new content to a file and then read it back, which aligns with the established pattern. The suffix continues with deleting the file, thus ensuring resource cleanup.", "assertions": "const assert = require('assert');\nconst fs = require('fs');\nconst path = require('path');\n(async () => {\n  const filePath = path.join(__dirname, 'example.txt');\n  const initialContent = 'Initial content';\n  await writeFileAsync(filePath, initialContent);\n  const content = await readFileAsync(filePath);\n  assert.strictEqual(content, initialContent, 'Initial content should match');\n  await appendFileAsync(filePath, '\\nNew line of text');\n  const updatedContent = await readFileAsync(filePath);\n  assert.strictEqual(updatedContent, initialContent + '\\nNew line of text', 'Updated content should include appended text');\n  await writeFileAsync(filePath, 'This is new content');\n  const newContent = await readFileAsync(filePath);\n  assert.strictEqual(newContent, 'This is new content', 'New content should match written content');\n  await new Promise((resolve, reject) => {\n    fs.unlink(filePath, (err) => {\n      if (err) reject(err);\n      resolve();\n    });\n  });\n  console.log('All assertions passed');\n})();", "gpt-4.1-nano": "await new Promise((resolve, reject) => {\n  fs.unlink(filePath, (err) => {\n    if (err) reject(err);\n    resolve();\n  });\n});"}
{"id": "21", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\n// Function to process files in a directory asynchronously\nasync function processFiles(directory) {\n    const files = await fs.promises.readdir(directory);\n\n    // Process each file in the directory\n    const results = await Promise.all(files.map(async (file) => {\n        const filePath = path.join(directory, file);\n        const stats = await fs.promises.stat(filePath);\n        if (stats.isFile()) {\n            const content = await fs.promises.readFile(filePath, 'utf-8');\n            return { file, content };\n        }\n        return null;\n    }));\n\n    return results.filter(result => result !== null);\n}\n\n// Function to log file details\nasync function logFileDetails(directory) {\n    try {\n        const files = await processFiles(directory);\n        files.forEach(file => {\n            console.log(`File: ${file.file}`);\n            console.log(`Content: ${file.content}`);\n        });\n    } catch (error) {\n        console.error('Error processing files:', error);\n    }\n}", "suffix": "\n\n// Example usage and assertions\n(async () => {\n    const testDirectory = './testDir';\n    await fs.promises.mkdir(testDirectory, { recursive: true });\n    await fs.promises.writeFile(path.join(testDirectory, 'test1.txt'), 'Hello World');\n    await fs.promises.writeFile(path.join(testDirectory, 'test2.txt'), 'Test Content');\n\n    await logFileDetails(testDirectory);\n\n    const files = await processFiles(testDirectory);\n    console.assert(files.length === 2, 'Should find 2 files');\n    console.assert(files[0].file === 'test1.txt', 'First file should be test1.txt');\n    console.assert(files[0].content === 'Hello World', 'Content of first file should be Hello World');\n    console.assert(files[1].file === 'test2.txt', 'Second file should be test2.txt');\n    console.assert(files[1].content === 'Test Content', 'Content of second file should be Test Content');\n\n    // Cleanup\n    await fs.promises.unlink(path.join(testDirectory, 'test1.txt'));\n    await fs.promises.unlink(path.join(testDirectory, 'test2.txt'));\n    await fs.promises.rmdir(testDirectory);\n})();", "golden_completion": "async function deleteFiles(directory) {\n    try {\n        const files = await processFiles(directory);\n        await Promise.all(files.map(async (file) => {\n            const filePath = path.join(directory, file.file);\n            await fs.promises.unlink(filePath);\n        }));\n        console.log('All files deleted successfully');\n    } catch (error) {\n        console.error('Error deleting files:', error);\n    }\n}", "LLM_justification": "This test case is a good example of async patterns in the context of tool automation. The prefix establishes a clear pattern of asynchronous file operations using Promises and async/await syntax. The golden completion should follow this established pattern by implementing a function that deletes files asynchronously. Assertions verify the correct processing and deletion of files, ensuring the pattern is followed correctly.", "assertions": "console.assert(typeof deleteFiles === 'function', 'deleteFiles should be a function');\n(async () => {\n    const testDirectory = './testDir';\n    await deleteFiles(testDirectory);\n    const filesAfterDeletion = await processFiles(testDirectory);\n    console.assert(filesAfterDeletion.length === 0, 'All files should be deleted');\n})();", "gpt-4.1-nano": "logFileDetails('./testDir');"}
{"id": "22", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\n// Higher-order function to read and process files\nconst processFile = (filePath, processor) => {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n        if (err) {\n            console.error('Error reading file:', err);\n            return;\n        }\n        try {\n            const result = processor(data);\n            console.log('Processing result:', result);\n        } catch (processingError) {\n            console.error('Error processing file:', processingError);\n        }\n    });\n};\n\n// Example processor function to count words\nconst wordCountProcessor = (text) => {\n    return text.split(/\\s+/).length;\n};\n\n// Example processor function to count lines\nconst lineCountProcessor = (text) => {\n    return text.split('\\n').length;\n};\n\n// Processing files with different processors\nprocessFile(path.join(__dirname, 'example1.txt'), wordCountProcessor);\nprocessFile(path.join(__dirname, 'example2.txt'), lineCountProcessor);\n", "suffix": "\n// Clean up resources if necessary\nconsole.log('File processing completed.');\n", "golden_completion": "processFile(path.join(__dirname, 'example3.txt'), wordCountProcessor);", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue the pattern of using a higher-order function to process files with different processor functions. The prefix establishes a clear pattern with multiple examples of `processFile` being called with different file paths and processors. The golden completion continues this pattern with a new file and an existing processor, demonstrating the correct application of the higher-order function concept. The suffix provides a logical continuation without repeating the golden completion.", "assertions": "const mockFs = require('mock-fs');\nmockFs({\n  'example1.txt': 'Hello world',\n  'example2.txt': 'Line one\\nLine two',\n  'example3.txt': 'Another example text'\n});\n\nconst assert = require('assert');\nlet consoleOutput = [];\nconst originalConsoleLog = console.log;\nconsole.log = (msg) => consoleOutput.push(msg);\n\n// Re-run the prefix code with the golden completion inserted\nprocessFile(path.join(__dirname, 'example1.txt'), wordCountProcessor);\nprocessFile(path.join(__dirname, 'example2.txt'), lineCountProcessor);\nprocessFile(path.join(__dirname, 'example3.txt'), wordCountProcessor);\n\nsetTimeout(() => {\n  try {\n    assert(consoleOutput.includes('Processing result: 2'));\n    assert(consoleOutput.includes('Processing result: 2'));\n    assert(consoleOutput.includes('Processing result: 3'));\n    console.log('All assertions passed.');\n  } finally {\n    console.log = originalConsoleLog;\n    mockFs.restore();\n  }\n}, 100);\n", "gpt-4.1-nano": ""}
{"id": "23", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\nfunction processFile(filePath, callback) {\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    const processedData = data.toUpperCase();\n    callback(null, processedData);\n  });\n}\n\nfunction validateFile(filePath, callback) {\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    const isValid = data.includes('VALID');\n    callback(null, isValid);\n  });\n}\n\nfunction analyzeFile(filePath, callback) {\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    const wordCount = data.split(' ').length;\n    callback(null, wordCount);\n  });\n}\n\n// New function to be completed", "suffix": "\n// Test cases\nconst filePath = 'test.txt';\nfs.writeFileSync(filePath, 'This is a VALID test file with some content.');\n\nprocessFile(filePath, (err, data) => {\n  if (err) throw err;\n  console.log('Processed Data:', data);\n  assert.strictEqual(data, 'THIS IS A VALID TEST FILE WITH SOME CONTENT.');\n});\n\nvalidateFile(filePath, (err, isValid) => {\n  if (err) throw err;\n  console.log('Is Valid:', isValid);\n  assert.strictEqual(isValid, true);\n});\n\nanalyzeFile(filePath, (err, wordCount) => {\n  if (err) throw err;\n  console.log('Word Count:', wordCount);\n  assert.strictEqual(wordCount, 8);\n});\n\n// Cleanup\nfs.unlinkSync(filePath);", "golden_completion": "function summarizeFile(filePath, callback) {\n  fs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    const summary = data.split(' ').slice(0, 5).join(' ') + '...';\n    callback(null, summary);\n  });\n}", "LLM_justification": "This example tests the model's ability to recognize and continue a pattern of asynchronous file processing functions using the Node.js `fs` module. The prefix establishes a clear pattern with three functions (`processFile`, `validateFile`, and `analyzeFile`) that follow a similar structure: reading a file asynchronously, handling errors, processing the file content, and calling the callback with the result. The golden completion `summarizeFile` must adhere to this pattern by implementing similar logic for summarizing the file content.", "assertions": "const filePath = 'test.txt';\nfs.writeFileSync(filePath, 'This is a VALID test file with some content.');\n\nsummarizeFile(filePath, (err, summary) => {\n  if (err) throw err;\n  console.log('Summary:', summary);\n  assert.strictEqual(summary, 'This is a VALID test...');\n});\nfs.unlinkSync(filePath);", "gpt-4.1-nano": "function appendToFile(filePath, content, callback) {\n  fs.appendFile(filePath, content, (err) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    callback(null);\n  });\n}"}
{"id": "24", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\nfunction encrypt(text, key) {\n    const cipher = crypto.createCipher('aes-256-cbc', key);\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n}\n\nfunction decrypt(encryptedText, key) {\n    const decipher = crypto.createDecipher('aes-256-cbc', key);\n    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n}\n\nfunction hash(text) {\n    return crypto.createHash('sha256').update(text).digest('hex');\n}\n\nfunction verifyHash(text, hashValue) {\n    return hash(text) === hashValue;\n}\n\n// Usage example\nconst key = 'mysecretkey';\nconst text = 'Hello, World!';\nconst encryptedText = encrypt(text, key);\nconst decryptedText = decrypt(encryptedText, key);\nconst hashedText = hash(text);\nconst isVerified = verifyHash(text, hashedText);\n", "suffix": "console.log('Decrypted Text:', decryptedText);\nconsole.log('Hashed Text:', hashedText);\nconsole.log('Verification:', isVerified);\n", "golden_completion": "console.log('Encrypted Text:', encryptedText);\n", "LLM_justification": "This example tests the ability to recognize and continue a pattern involving cryptographic functions in JavaScript. The prefix establishes a clear pattern with functions for encryption, decryption, and hashing, followed by a usage example. The golden completion requires the LLM to continue this pattern by logging the encrypted text, a logical step in the sequence. This scenario is practical for developers working with security-related code.", "assertions": "const assert = require('assert');\nassert.strictEqual(decryptedText, text, 'Decryption failed');\nassert.strictEqual(hash(text), hashedText, 'Hashing failed');\nassert.strictEqual(isVerified, true, 'Hash verification failed');\n", "gpt-4.1-nano": "console.log('Decrypted Text:', decryptedText);"}
{"id": "25", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\nfunction logMetrics(metricName, value) {\n    const timestamp = new Date().toISOString();\n    const logEntry = `${timestamp} - ${metricName}: ${value}\\n`;\n    fs.appendFile('metrics.log', logEntry, (err) => {\n        if (err) {\n            console.error('Failed to log metric:', err);\n        }\n    });\n}\n\nfunction processMetrics(metrics) {\n    metrics.forEach(metric => {\n        logMetrics(metric.name, metric.value);\n    });\n}\n\n// Example usage\nconst exampleMetrics = [\n    { name: 'CPU_Usage', value: 75 },\n    { name: 'Memory_Usage', value: 60 },\n    { name: 'Disk_Usage', value: 85 }\n];\n\nprocessMetrics(exampleMetrics);\n", "suffix": "\n// Further processing can go here\nconsole.log('Metrics processing complete.');", "golden_completion": "function logError(errorMessage) {\n    const timestamp = new Date().toISOString();\n    const logEntry = `${timestamp} - ERROR: ${errorMessage}\\n`;\n    fs.appendFile('error.log', logEntry, (err) => {\n        if (err) {\n            console.error('Failed to log error:', err);\n        }\n    });\n}\n\n", "LLM_justification": "This test case is designed to evaluate the ability of an LLM to recognize and continue a pattern of logging information to a file. The prefix establishes a pattern for logging metrics with timestamps to a 'metrics.log' file. The golden completion requires the LLM to follow this pattern to log errors to an 'error.log' file. This tests the LLM's ability to identify and replicate a pattern in a different context (error handling) while maintaining consistency in the logging mechanism.", "assertions": "const fs = require('fs');\nconst assert = require('assert');\n\n// Mocking fs.appendFile to avoid actual file IO\nfs.appendFile = (path, data, callback) => { callback(null); };\n\nlet errorLogged = false;\nconsole.error = (message) => { errorLogged = true; };\n\nfunction logError(errorMessage) {\n    const timestamp = new Date().toISOString();\n    const logEntry = `${timestamp} - ERROR: ${errorMessage}\\n`;\n    fs.appendFile('error.log', logEntry, (err) => {\n        if (err) {\n            console.error('Failed to log error:', err);\n        }\n    });\n}\n\ntry {\n    // Simulate an error\n    throw new Error('Something went wrong');\n} catch (error) {\n    logError(error.message);\n}\n\nassert.strictEqual(errorLogged, false, 'Error should be logged without console error');\n", "gpt-4.1-nano": "// Additional processing can be added here"}
{"id": "26", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\n// Function to hash a password using a specific algorithm\nfunction hashPassword(password) {\n    return crypto.createHash('sha256').update(password).digest('hex');\n}\n\n// Function to verify a password against a hash\nfunction verifyPassword(password, hash) {\n    return hashPassword(password) === hash;\n}\n\n// Example usage of the functions\nconst password = 'securepassword123';\nconst hash = hashPassword(password);\n\n// Higher-order function for authentication\nfunction authenticateUser(getPasswordHash, userPassword) {\n    const storedHash = getPasswordHash();\n    return verifyPassword(userPassword, storedHash);\n}\n\n// Mock function to get stored password hash\nfunction mockGetPasswordHash() {\n    return hash;\n}\n\nconst userPassword = 'securepassword123';\n", "suffix": "console.log('User authenticated:', authenticateUser(() => hash, userPassword));\n\n// Assertions\nconst assert = require('assert');\nassert.strictEqual(authenticateUser(mockGetPasswordHash, userPassword), true, 'The user should be authenticated successfully');\nassert.strictEqual(authenticateUser(mockGetPasswordHash, 'wrongpassword'), false, 'The user should not be authenticated with a wrong password');\n\n// Cleanup (if any)\n// No resources to clean up in this example\n", "golden_completion": "console.log('User authenticated:', authenticateUser(mockGetPasswordHash, userPassword));", "LLM_justification": "This example demonstrates the use of higher-order functions in the context of security, specifically password hashing and authentication. The pattern of using higher-order functions for authentication is established in the prefix, and the golden completion follows this pattern by correctly using the mockGetPasswordHash function for authentication. The suffix continues the pattern with assertions to verify the functionality. This tests the LLM's ability to recognize and continue the established pattern of higher-order functions in a security context.", "assertions": "const assert = require('assert');\nassert.strictEqual(authenticateUser(mockGetPasswordHash, userPassword), true, 'The user should be authenticated successfully');\nassert.strictEqual(authenticateUser(mockGetPasswordHash, 'wrongpassword'), false, 'The user should not be authenticated with a wrong password');", "gpt-4.1-nano": "console.log('User authenticated:', authenticateUser(() => hash, userPassword));"}
{"id": "27", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\n// Utility function to hash a string using SHA-256\nfunction hashStringSHA256(input) {\n    return crypto.createHash('sha256').update(input).digest('hex');\n}\n\n// Utility function to hash a string using SHA-1\nfunction hashStringSHA1(input) {\n    return crypto.createHash('sha1').update(input).digest('hex');\n}\n\n// Utility function to hash a string using MD5\nfunction hashStringMD5(input) {\n    return crypto.createHash('md5').update(input).digest('hex');\n}\n\n// Example usage of the utility functions\nconst testStrings = ['hello', 'world', 'test'];\nconst sha256Hashes = testStrings.map(hashStringSHA256);\nconst sha1Hashes = testStrings.map(hashStringSHA1);\n", "suffix": "const sha512Hashes = testStrings.map(input => crypto.createHash('sha512').update(input).digest('hex'));\n\n// Assertions\nconst assert = require('assert');\nassert.strictEqual(hashStringSHA256('hello'), sha256Hashes[0]);\nassert.strictEqual(hashStringSHA1('world'), sha1Hashes[1]);\nassert.strictEqual(sha512Hashes.length, testStrings.length);\n\nconsole.log('All tests passed.');", "golden_completion": "const md5Hashes = testStrings.map(hashStringMD5);", "LLM_justification": "This test case is a good example for pattern matching as it establishes a clear pattern of hashing strings using different algorithms (SHA-256, SHA-1, MD5). The prefix contains multiple examples of this pattern, ensuring it is recognizable. The completion must follow this pattern, demonstrating understanding and continuation of the established pattern. The suffix introduces a new hashing algorithm (SHA-512) to show diversity while maintaining the overall structure, ensuring the model's ability to generalize the pattern. Assertions validate that the pattern is followed and the functionality is correct.", "assertions": "const assert = require('assert');\nassert.strictEqual(hashStringSHA256('hello'), sha256Hashes[0]);\nassert.strictEqual(hashStringSHA1('world'), sha1Hashes[1]);\nassert.strictEqual(md5Hashes.length, testStrings.length);\nassert.strictEqual(md5Hashes[0], hashStringMD5('hello'));\nassert.strictEqual(md5Hashes[1], hashStringMD5('world'));\nassert.strictEqual(md5Hashes[2], hashStringMD5('test'));\nconsole.log('All tests passed.');", "gpt-4.1-nano": "const sha512Hashes = testStrings.map(hashStringSHA512);\nfunction hashStringSHA512(input) {\n    return crypto.createHash('sha512').update(input).digest('hex');\n}"}
{"id": "28", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\n// Example pattern: Encrypting text with a key\nfunction encrypt(text, key) {\n    const cipher = crypto.createCipher('aes-256-cbc', key);\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n}\n\n// Example pattern: Decrypting text with a key\nfunction decrypt(encrypted, key) {\n    const decipher = crypto.createDecipher('aes-256-cbc', key);\n    let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n}\n\n// Function to hash a text with a salt\nfunction hash(text, salt) {\n    const hash = crypto.createHmac('sha256', salt);\n    hash.update(text);\n    return hash.digest('hex');\n}\n\n// Function to verify if the text matches the hash\n", "suffix": "\n\n// Test cases\nconst key = 'mysecretkey';\nconst text = 'Hello, World!';\nconst salt = 'randomsalt';\nconst encryptedText = encrypt(text, key);\nconst decryptedText = decrypt(encryptedText, key);\nconst hashedText = hash(text, salt);\nconst isHashVerified = verifyHash(text, salt, hashedText);\n\nconsole.assert(encryptedText !== text, 'Encryption failed.');\nconsole.assert(decryptedText === text, 'Decryption failed.');\nconsole.assert(hashedText.length === 64, 'Hashing failed.');\nconsole.assert(isHashVerified, 'Hash verification failed.');\n", "golden_completion": "function verifyHash(text, salt, hashValue) {\n    const hash = crypto.createHmac('sha256', salt);\n    hash.update(text);\n    const digest = hash.digest('hex');\n    return digest === hashValue;\n}\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern related to cryptographic operations. The prefix establishes clear patterns for encryption, decryption, and hashing functions. The completion requires the LLM to follow the same pattern for verifying a hash, which involves creating a HMAC, updating it with the text, and comparing the result to the provided hash value. The suffix continues this pattern but in a different function (testing and asserting the encryption, decryption, and hashing). The provided assertions verify that the encryption, decryption, hashing, and hash verification work correctly, ensuring pattern adherence and functional correctness.", "assertions": "const key = 'mysecretkey';\nconst text = 'Hello, World!';\nconst salt = 'randomsalt';\nconst encryptedText = encrypt(text, key);\nconst decryptedText = decrypt(encryptedText, key);\nconst hashedText = hash(text, salt);\nconst isHashVerified = verifyHash(text, salt, hashedText);\n\nconsole.assert(encryptedText !== text, 'Encryption failed.');\nconsole.assert(decryptedText === text, 'Decryption failed.');\nconsole.assert(hashedText.length === 64, 'Hashing failed.');\nconsole.assert(isHashVerified, 'Hash verification failed.');\n", "gpt-4.1-nano": "function verifyHash(text, salt, hashToVerify) {\n    const hash = crypto.createHmac('sha256', salt);\n    hash.update(text);\n    const digest = hash.digest('hex');\n    return digest === hashToVerify;\n}"}
{"id": "29", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const { createHash } = require('crypto');\n\nfunction hashPassword(password) {\n    return createHash('sha256').update(password).digest('hex');\n}\n\nfunction authenticateUser(username, password, users) {\n    const hashedPassword = hashPassword(password);\n    for (const user of users) {\n        if (user.username === username && user.password === hashedPassword) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst users = [\n    { username: 'alice', password: hashPassword('password123') },\n    { username: 'bob', password: hashPassword('qwerty') }\n];\n\n// Function to log authentication attempts\nfunction logAuthenticationAttempt(username, success) {\n    const timestamp = new Date().toISOString();\n    console.log(`[${timestamp}] Authentication attempt for user: ${username} - ${success ? 'SUCCESS' : 'FAILURE'}`);\n}\n\n// Function to handle user login\nfunction loginUser(username, password) {\n    const isAuthenticated = authenticateUser(username, password, users);\n    logAuthenticationAttempt(username, isAuthenticated);\n    if (isAuthenticated) {\n        return 'Login successful';\n    } else {\n        return 'Invalid username or password';\n    }\n}\n\n", "suffix": "\n\nconst result2 = loginUser('alice', 'wrongpassword');\nconsole.log(result2); // Expected output: Invalid username or password\n\n// Cleanup resources (if any)\n", "golden_completion": "const result = loginUser('alice', 'password123');\nconsole.log(result); // Expected output: Login successful\n\n", "LLM_justification": "This test case establishes a clear pattern of handling user authentication including password hashing, user validation, and logging of authentication attempts. The pattern requires functions to work together to ensure security, correct logging, and proper user feedback. The completion must follow this established pattern by correctly invoking the loginUser function and validating the output against expected results. The assertions verify that the pattern is adhered to and the functionality is correct.", "assertions": "const { strict: assert } = require('assert');\n\nconst result = loginUser('alice', 'password123');\nassert.strictEqual(result, 'Login successful', 'Expected login to be successful for correct password');\n\nconst result2 = loginUser('alice', 'wrongpassword');\nassert.strictEqual(result2, 'Invalid username or password', 'Expected login to fail for incorrect password');\n", "gpt-4.1-nano": "console.log('Attempting login for user: alice');"}
{"id": "30", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\nfunction encryptText(plainText, key) {\n  const cipher = crypto.createCipher('aes-256-cbc', key);\n  let encrypted = cipher.update(plainText, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction decryptText(encryptedText, key) {\n  const decipher = crypto.createDecipher('aes-256-cbc', key);\n  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\nfunction hashPassword(password) {\n  return crypto.createHash('sha256').update(password).digest('hex');\n}\n\nfunction verifyPassword(password, hash) {\n  return hashPassword(password) === hash;\n}\n\n// Example usage\nconst key = 'mysecretkey';\nconst plainText = 'This is a secret message';\nconst password = 'mypassword';\nconst hashedPassword = hashPassword(password);\n", "suffix": "console.log('Encrypted Text:', encryptedText);\nconst decryptedText = decryptText(encryptedText, key);\nconsole.log('Decrypted Text:', decryptedText);\n\n// Verify the password\nconst isPasswordCorrect = verifyPassword(password, hashedPassword);\nconsole.log('Is password correct:', isPasswordCorrect);\n\n// Cleanup (none required in this simple example)\n", "golden_completion": "const encryptedText = encryptText(plainText, key);\n", "LLM_justification": "This test case is a good example of pattern matching as it involves functional programming with cryptographic functions for encryption and hashing, which are common in security contexts. The established pattern involves creating functions for encryption, decryption, hashing, and verification. The golden completion continues this pattern by encrypting a plaintext message, a logical next step given the context. This ensures the LLM understands the sequence and usage of these functions, adhering to the pattern established in the prefix.", "assertions": "const assert = require('assert');\nconst key = 'mysecretkey';\nconst plainText = 'This is a secret message';\nconst encryptedText = encryptText(plainText, key);\nconst decryptedText = decryptText(encryptedText, key);\nconst password = 'mypassword';\nconst hashedPassword = hashPassword(password);\nconst isPasswordCorrect = verifyPassword(password, hashedPassword);\n\nassert.strictEqual(encryptedText.length > 0, true, 'Encrypted text should not be empty');\nassert.strictEqual(decryptedText, plainText, 'Decrypted text should match the original plaintext');\nassert.strictEqual(isPasswordCorrect, true, 'Password verification should be correct');\nconsole.log('All assertions passed');\n", "gpt-4.1-nano": "const encryptedText = encryptText(plainText, key);"}
{"id": "31", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const crypto = require('crypto');\n\nfunction encrypt(text, key) {\n    const cipher = crypto.createCipher('aes-256-cbc', key);\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n}\n\nfunction decrypt(encrypted, key) {\n    const decipher = crypto.createDecipher('aes-256-cbc', key);\n    let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n}\n\nfunction hash(text) {\n    return crypto.createHash('sha256').update(text).digest('hex');\n}\n\nfunction verifyHash(text, hash) {\n    const textHash = crypto.createHash('sha256').update(text).digest('hex');\n    return textHash === hash;\n}\n\nconst key = 'my_secret_key';\nconst text = 'Hello, World!';\nconst encrypted = encrypt(text, key);\nconst decrypted = decrypt(encrypted, key);\nconst textHash = hash(text);\n", "suffix": "const invalidKey = 'invalid_key';\nconst invalidDecrypted = decrypt(encrypted, invalidKey);\n\nconsole.assert(decrypted === text, 'Decryption failed with correct key');\nconsole.assert(invalidDecrypted !== text, 'Decryption should fail with incorrect key');\nconsole.assert(verifyHash(text, textHash), 'Hash verification failed');\nconsole.assert(!verifyHash('Different text', textHash), 'Hash verification should fail for different text');\n\nconsole.log('All assertions passed.');", "golden_completion": "const textHashVerification = verifyHash(text, textHash);\n", "LLM_justification": "This is a good test case because it establishes a clear pattern of cryptographic operations (encryption, decryption, hashing, and verification) and requires the model to continue the pattern with a verification function. The prefix sets up multiple cryptographic functions and their usage, and the golden completion follows the same pattern by verifying the hash, which is a common practice in security-related code. The assertions then test the correctness and adherence to the pattern by ensuring the encryption, decryption, and hashing functions work as expected.", "assertions": "console.assert(decrypted === text, 'Decryption failed with correct key');\nconsole.assert(invalidDecrypted !== text, 'Decryption should fail with incorrect key');\nconsole.assert(verifyHash(text, textHash), 'Hash verification failed');\nconsole.assert(!verifyHash('Different text', textHash), 'Hash verification should fail for different text');", "gpt-4.1-nano": "try {"}
{"id": "32", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\n// Higher-order function to log the time taken by an async function\nfunction logExecutionTime(asyncFunc) {\n    return async function(...args) {\n        const start = Date.now();\n        try {\n            const result = await asyncFunc(...args);\n            const end = Date.now();\n            console.log(`Execution time: ${end - start}ms`);\n            return result;\n        } catch (error) {\n            console.error('Error:', error);\n            throw error;\n        }\n    };\n}\n\n// Sample async functions representing tool automation tasks\nconst readFileAsync = logExecutionTime(async function(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) reject(err);\n            else resolve(data);\n        });\n    });\n});\n\nconst writeFileAsync = logExecutionTime(async function(filePath, data) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(filePath, data, 'utf8', (err) => {\n            if (err) reject(err);\n            else resolve();\n        });\n    });\n});\n\n", "suffix": "\n(async () => {\n    const testFilePath = 'test.txt';\n    try {\n        await writeFileAsync(testFilePath, 'Hello, world!');\n        const data = await readFileAsync(testFilePath);\n        console.log('File contents:', data);\n        // Cleanup\n        fs.unlinkSync(testFilePath);\n    } catch (error) {\n        console.error('Caught error:', error);\n    }\n})();", "golden_completion": "const deleteFileAsync = logExecutionTime(async function(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.unlink(filePath, (err) => {\n            if (err) reject(err);\n            else resolve();\n        });\n    });\n});\n\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and extend a higher-order function pattern in the context of tool automation. The prefix establishes the pattern with two higher-order functions that log the execution time of asynchronous file operations. The golden completion requires the LLM to maintain this pattern by creating a similar higher-order function for deleting a file. This scenario is practical and tests the model's understanding of both higher-order functions and async patterns in JavaScript.", "assertions": "const assert = require('assert');\n(async () => {\n    const testFilePath = 'test.txt';\n    try {\n        await writeFileAsync(testFilePath, 'Hello, world!');\n        const data = await readFileAsync(testFilePath);\n        assert.strictEqual(data, 'Hello, world!');\n        await deleteFileAsync(testFilePath);\n        assert.throws(() => fs.readFileSync(testFilePath), /no such file or directory/);\n    } catch (error) {\n        console.error('Caught error during assertions:', error);\n    }\n})();", "gpt-4.1-nano": ""}
{"id": "33", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const metrics = [];\n\nfunction recordMetric(name, value) {\n    metrics.push({ name, value, timestamp: new Date() });\n}\n\nfunction calculateAverage(metricName) {\n    const filteredMetrics = metrics.filter(metric => metric.name === metricName);\n    const sum = filteredMetrics.reduce((acc, metric) => acc + metric.value, 0);\n    return sum / filteredMetrics.length;\n}\n\nfunction generateReport() {\n    const report = {};\n    metrics.forEach(metric => {\n        if (!report[metric.name]) {\n            report[metric.name] = { total: 0, count: 0 };\n        }\n        report[metric.name].total += metric.value;\n        report[metric.name].count += 1;\n    });\n    return report;\n}\n\n// We need to add a new function that follows the established pattern of processing metrics\n\n", "suffix": "\n\n// Tests\nrecordMetric('clicks', 5);\nrecordMetric('clicks', 10);\nrecordMetric('views', 100);\nrecordMetric('views', 150);\n\nconst avgClicks = calculateAverage('clicks');\nconst avgViews = calculateAverage('views');\n\nconsole.assert(avgClicks === 7.5, `Expected 7.5, but got ${avgClicks}`);\nconsole.assert(avgViews === 125, `Expected 125, but got ${avgViews}`);\n\nconst report = generateReport();\nconsole.assert(report['clicks'].total === 15, `Expected 15, but got ${report['clicks'].total}`);\nconsole.assert(report['clicks'].count === 2, `Expected 2, but got ${report['clicks'].count}`);\nconsole.assert(report['views'].total === 250, `Expected 250, but got ${report['views'].total}`);\nconsole.assert(report['views'].count === 2, `Expected 2, but got ${report['views'].count}`);\n\n// Cleanup\nmetrics.length = 0;", "golden_completion": "function getMetricHistory(metricName) {\n    return metrics.filter(metric => metric.name === metricName);\n}\n", "LLM_justification": "This test case is a good benchmark for pattern matching because it establishes a clear pattern of processing metrics through functions like `recordMetric`, `calculateAverage`, and `generateReport`. The new function `getMetricHistory` must follow this pattern by filtering metrics based on their name, similar to the existing functions. The assertions validate the functionality and consistency of the pattern, ensuring the LLM correctly identifies and continues the pattern.", "assertions": "const history = getMetricHistory('clicks');\nconsole.assert(history.length === 2, `Expected 2, but got ${history.length}`);\nconsole.assert(history[0].value === 5, `Expected 5, but got ${history[0].value}`);\nconsole.assert(history[1].value === 10, `Expected 10, but got ${history[1].value}`);\n", "gpt-4.1-nano": "function getMetricsSummary() {\n    const summary = {};\n    metrics.forEach(metric => {\n        if (!summary[metric.name]) {\n            summary[metric.name] = { total: 0, count: 0 };\n        }\n        summary[metric.name].total += metric.value;\n        summary[metric.name].count += 1;\n    });\n    return summary;\n}"}
{"id": "34", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fetch = require('node-fetch');\n\n// Higher-order function to measure execution time of an async function\nfunction measureExecutionTime(asyncFunc) {\n    return async function(...args) {\n        const start = Date.now();\n        try {\n            const result = await asyncFunc(...args);\n            return result;\n        } finally {\n            const end = Date.now();\n            console.log(`Execution time: ${end - start} ms`);\n        }\n    };\n}\n\n// Async function to fetch data from an API\nasync function fetchData(url) {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error('Network response was not ok');\n    }\n    const data = await response.json();\n    return data;\n}\n\n// Wrapped function with execution time measurement\nconst fetchDataWithTiming = measureExecutionTime(fetchData);\n\n// Example usage\n", "suffix": "fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/2').then(data => {\n    console.log('Fetched data:', data);\n}).catch(error => {\n    console.error('Error fetching data:', error);\n});\n\n// Additional test case\nfetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/3').then(data => {\n    console.log('Fetched data:', data);\n}).catch(error => {\n    console.error('Error fetching data:', error);\n});\n", "golden_completion": "fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/1').then(data => {\n    console.log('Fetched data:', data);\n}).catch(error => {\n    console.error('Error fetching data:', error);\n});\n\n// Additional test case\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of using higher-order functions to measure the execution time of async functions, specifically in the context of fetching data from an API. The pattern is clear: wrapping an async function with a timing measurement function and then using the wrapped function to fetch data from different URLs. The golden completion must follow this established pattern by correctly wrapping an async function call and handling the result.", "assertions": "const assert = require('assert');\n\n// Mock fetch for testing\nconst originalFetch = global.fetch;\nglobal.fetch = async (url) => {\n    if (url === 'https://jsonplaceholder.typicode.com/todos/1') {\n        return { ok: true, json: async () => ({ id: 1, title: 'delectus aut autem' }) };\n    } else if (url === 'https://jsonplaceholder.typicode.com/todos/2') {\n        return { ok: true, json: async () => ({ id: 2, title: 'quis ut nam facilis et officia qui' }) };\n    } else if (url === 'https://jsonplaceholder.typicode.com/todos/3') {\n        return { ok: true, json: async () => ({ id: 3, title: 'fugiat veniam minus' }) };\n    } else {\n        return { ok: false };\n    }\n};\n\n(async () => {\n    try {\n        const data1 = await fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/1');\n        assert.deepStrictEqual(data1, { id: 1, title: 'delectus aut autem' });\n        const data2 = await fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/2');\n        assert.deepStrictEqual(data2, { id: 2, title: 'quis ut nam facilis et officia qui' });\n        const data3 = await fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/3');\n        assert.deepStrictEqual(data3, { id: 3, title: 'fugiat veniam minus' });\n        console.log('All assertions passed.');\n    } catch (error) {\n        console.error('Assertion failed:', error);\n    } finally {\n        // Cleanup mock\n        global.fetch = originalFetch;\n    }\n})();\n", "gpt-4.1-nano": "fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/2').then(data => {\n    console.log('Fetched data:', data);\n}).catch(error => {\n    console.error('Error fetching data:', error);\n});"}
{"id": "35", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const metrics = [];\n\nfunction recordMetric(name, value) {\n    metrics.push({ name, value, timestamp: new Date() });\n}\n\nfunction calculateAverage(metricName) {\n    const metricValues = metrics.filter(metric => metric.name === metricName).map(metric => metric.value);\n    if (metricValues.length === 0) return 0;\n    const sum = metricValues.reduce((acc, val) => acc + val, 0);\n    return sum / metricValues.length;\n}\n\nfunction calculateMax(metricName) {\n    const metricValues = metrics.filter(metric => metric.name === metricName).map(metric => metric.value);\n    if (metricValues.length === 0) return 0;\n    return Math.max(...metricValues);\n}\n\n", "suffix": "\nfunction calculateMin(metricName) {\n    const metricValues = metrics.filter(metric => metric.name === metricName).map(metric => metric.value);\n    if (metricValues.length === 0) return 0;\n    return Math.min(...metricValues);\n}\n\n// Test cases\nrecordMetric('response_time', 200);\nrecordMetric('response_time', 100);\nrecordMetric('response_time', 300);\nrecordMetric('response_time', 150);\n\nconsole.assert(calculateAverage('response_time') === 187.5, 'Average calculation is incorrect');\nconsole.assert(calculateMax('response_time') === 300, 'Max calculation is incorrect');\nconsole.assert(calculateMin('response_time') === 100, 'Min calculation is incorrect');\n\nconsole.log('All assertions passed');\n", "golden_completion": "function calculateSum(metricName) {\n    const metricValues = metrics.filter(metric => metric.name === metricName).map(metric => metric.value);\n    if (metricValues.length === 0) return 0;\n    return metricValues.reduce((acc, val) => acc + val, 0);\n}\n\n", "LLM_justification": "This test case is a good benchmark for pattern matching capabilities as it involves a clear and identifiable pattern of metric calculations. The functions `calculateAverage`, `calculateMax`, and `calculateMin` all follow a similar structure: filtering metrics by name, mapping to values, checking for an empty array, and then performing a reduction operation. The `calculateSum` function must follow this established pattern to correctly complete the metric calculations. The assertions verify the correctness of all metric calculations, ensuring pattern adherence and functionality.", "assertions": "console.assert(calculateSum('response_time') === 750, 'Sum calculation is incorrect');\n", "gpt-4.1-nano": "function calculateMedian(metricName) {\n    const metricValues = metrics.filter(metric => metric.name === metricName).map(metric => metric.value).sort((a, b) => a - b);\n    if (metricValues.length === 0) return 0;\n    const mid = Math.floor(metricValues.length / 2);\n    if (metricValues.length % 2 === 0) {\n        return (metricValues[mid - 1] + metricValues[mid]) / 2;\n    } else {\n        return metricValues[mid];\n    }\n}"}
{"id": "36", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const { assert } = require('chai');\n\n// Game mechanics: A simple state machine for a game character\nclass Character {\n    constructor() {\n        this.state = 'idle';\n    }\n\n    setState(newState) {\n        this.state = newState;\n    }\n\n    idle() {\n        this.setState('idle');\n    }\n\n    walk() {\n        this.setState('walking');\n    }\n\n    run() {\n        this.setState('running');\n    }\n\n    jump() {\n        this.setState('jumping');\n    }\n\n    // The pattern of state transitions should be clear here\n    attack() {\n        this.setState('attacking');\n    }\n\n    defend() {\n        this.setState('defending');\n    }\n\n    // Need to complete the state pattern with 'die' state\n", "suffix": "\n}\n\nconst character = new Character();\n\ncharacter.idle();\nassert.equal(character.state, 'idle');\n\ncharacter.walk();\nassert.equal(character.state, 'walking');\n\ncharacter.run();\nassert.equal(character.state, 'running');\n\ncharacter.jump();\nassert.equal(character.state, 'jumping');\n\ncharacter.attack();\nassert.equal(character.state, 'attacking');\n\ncharacter.defend();\nassert.equal(character.state, 'defending');\n\ncharacter.die();\nassert.equal(character.state, 'dead');\n\nconsole.log('All assertions passed.');", "golden_completion": "    die() {\n        this.setState('dead');\n    }\n", "LLM_justification": "This test case demonstrates a state machine pattern in a game mechanics context. The `Character` class has methods for various states (idle, walk, run, jump, attack, defend) that follow a clear pattern of setting the state. The golden completion requires adding the 'die' method, which must follow the established pattern of setting the state using `this.setState()`. This tests the LLM's ability to recognize and extend the state machine pattern correctly.", "assertions": "assert.equal(character.state, 'idle');\nassert.equal(character.state, 'walking');\nassert.equal(character.state, 'running');\nassert.equal(character.state, 'jumping');\nassert.equal(character.state, 'attacking');\nassert.equal(character.state, 'defending');\nassert.equal(character.state, 'dead');", "gpt-4.1-nano": "this.setState('dead');"}
{"id": "37", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\n// Utility function to read a file asynchronously\nfunction readFileAsync(path) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(path, 'utf8', (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Utility function to write a file asynchronously\nfunction writeFileAsync(path, data) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(path, data, 'utf8', (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n// Function to read, modify, and write a file asynchronously\nasync function modifyFile(path, modifyCallback) {\n    try {\n        const data = await readFileAsync(path);\n        const modifiedData = modifyCallback(data);\n        await writeFileAsync(path, modifiedData);\n    } catch (err) {\n        console.error('Error modifying file:', err);\n    }\n}\n\n// Example usage\nmodifyFile('example.txt', (data) => data.toUpperCase());\n", "suffix": "// Example usage with a different file and callback\nmodifyFile('another_example.txt', (data) => data.split('').reverse().join(''));\n", "golden_completion": "// Example usage with a different file and callback\nmodifyFile('test.txt', (data) => data.replace(/foo/g, 'bar'));\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete a pattern involving asynchronous file operations using Promises and async/await syntax. The prefix establishes a clear pattern by defining utility functions for reading and writing files asynchronously, as well as a function to modify files using a callback. The golden_completion follows this established pattern by providing another example usage of the modifyFile function with a different file and callback. This tests the LLM's understanding of the established pattern and its ability to generate code that adheres to it. The suffix provides another example usage to further verify the pattern adherence.", "assertions": "const assert = require('assert');\nconst mockFs = require('mock-fs');\n\n// Mock the file system\nmockFs({\n    'example.txt': 'hello world',\n    'test.txt': 'foo bar',\n    'another_example.txt': '12345'\n});\n\n// Test the first example usage\nmodifyFile('example.txt', (data) => data.toUpperCase()).then(() => {\n    return readFileAsync('example.txt');\n}).then((data) => {\n    assert.strictEqual(data, 'HELLO WORLD');\n\n    // Test the golden completion\n    return modifyFile('test.txt', (data) => data.replace(/foo/g, 'bar'));\n}).then(() => {\n    return readFileAsync('test.txt');\n}).then((data) => {\n    assert.strictEqual(data, 'bar bar');\n\n    // Test the suffix example usage\n    return modifyFile('another_example.txt', (data) => data.split('').reverse().join(''));\n}).then(() => {\n    return readFileAsync('another_example.txt');\n}).then((data) => {\n    assert.strictEqual(data, '54321');\n\n    // Cleanup mock file system\n    mockFs.restore();\n}).catch((err) => {\n    console.error('Test failed:', err);\n    mockFs.restore();\n});\n", "gpt-4.1-nano": "modifyFile('sample.txt', (data) => data.replace(/foo/g, 'bar'));"}
{"id": "38", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const { assert } = require('chai');\n\n// Game mechanics: State machine for a simple game character\nclass Character {\n  constructor(name) {\n    this.name = name;\n    this.state = 'idle';\n  }\n\n  setState(state) {\n    this.state = state;\n  }\n\n  isIdle() {\n    return this.state === 'idle';\n  }\n\n  isMoving() {\n    return this.state === 'moving';\n  }\n\n  isAttacking() {\n    return this.state === 'attacking';\n  }\n\n  handleInput(input) {\n    switch(input) {\n      case 'move':\n        this.setState('moving');\n        break;\n      case 'attack':\n        this.setState('attacking');\n        break;\n      case 'stop':\n        this.setState('idle');\n        break;\n      default:\n        throw new Error('Invalid input');\n    }\n  }\n}\n\nconst character = new Character('Hero');\ncharacter.handleInput('move');\nassert(character.isMoving(), 'Character should be moving');\ncharacter.handleInput('attack');\nassert(character.isAttacking(), 'Character should be attacking');", "suffix": "\n\n// Clean up resources\nconsole.log('All assertions passed.');", "golden_completion": "\ncharacter.handleInput('stop');\nassert(character.isIdle(), 'Character should be idle');", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a state machine pattern within a game mechanics context. The pattern involves handling different states (idle, moving, attacking) and transitioning between these states based on input. The golden completion demonstrates the correct handling of the 'stop' input to transition the character back to the idle state, which is critical for ensuring the state machine functions correctly. This is a realistic and practical example for game development, making it a good test case for pattern matching capabilities.", "assertions": "assert(character.isMoving(), 'Character should be moving');\nassert(character.isAttacking(), 'Character should be attacking');\ncharacter.handleInput('stop');\nassert(character.isIdle(), 'Character should be idle');", "gpt-4.1-nano": "character.setState('idle');"}
{"id": "39", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\n// Utility function to log errors\nfunction logError(error) {\n    console.error('Error:', error);\n}\n\n// Function to read a file asynchronously\nfunction readFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                logError(err);\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Function to write to a file asynchronously\nfunction writeFileAsync(filePath, data) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(filePath, data, 'utf8', (err) => {\n            if (err) {\n                logError(err);\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n// Function to delete a file asynchronously\nfunction deleteFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.unlink(filePath, (err) => {\n            if (err) {\n                logError(err);\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n// Usage example\nasync function exampleUsage() {\n    const filePath = path.join(__dirname, 'example.txt');\n\n    try {\n        // Read the file\n        const content = await readFileAsync(filePath);\n        console.log('File content:', content);\n\n        // Write to the file\n        await writeFileAsync(filePath, 'New content');\n\n        // Delete the file\n", "suffix": "        console.log('File deleted successfully');\n    } catch (error) {\n        logError(error);\n    }\n}\n\n// Run the example usage function\nexampleUsage();", "golden_completion": "        await deleteFileAsync(filePath);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern of asynchronous file operations with proper error handling. The pattern of defining asynchronous functions using promises and handling errors using a utility function is clearly established in the prefix. The golden completion requires the LLM to follow this pattern by adding the call to the asynchronous delete function within the try block, maintaining consistency with the established pattern. The suffix continues the pattern by handling errors and logging the file deletion success message.", "assertions": "const assert = require('assert');\nconst mockFs = require('mock-fs');\n\nmockFs({\n    'example.txt': 'Initial content'\n});\n\nasync function testExampleUsage() {\n    const filePath = path.join(__dirname, 'example.txt');\n\n    try {\n        await exampleUsage();\n\n        // Ensure file is deleted\n        const fileExists = fs.existsSync(filePath);\n        assert.strictEqual(fileExists, false, 'File should be deleted');\n    } finally {\n        mockFs.restore();\n    }\n}\n\ntestExampleUsage();", "gpt-4.1-nano": "        await deleteFileAsync(filePath);"}
{"id": "40", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\nconst path = require('path');\n\n// Higher-order function to read a file and process its contents\nfunction readFileAndProcess(filePath, processFn) {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n        if (err) {\n            console.error('Error reading file:', err);\n            return;\n        }\n        processFn(data);\n    });\n}\n\n// Higher-order function to write data to a file\nfunction writeFileAndProcess(filePath, data, processFn) {\n    fs.writeFile(filePath, data, (err) => {\n        if (err) {\n            console.error('Error writing file:', err);\n            return;\n        }\n        processFn();\n    });\n}\n\n// Example usage of higher-order functions\nconst inputFilePath = path.join(__dirname, 'input.txt');\nconst outputFilePath = path.join(__dirname, 'output.txt');\n\nreadFileAndProcess(inputFilePath, (data) => {\n    const processedData = data.toUpperCase();\n    writeFileAndProcess(outputFilePath, processedData, () => {\n        console.log('Data has been processed and written to output file.');\n    });\n});\n\n// Another example usage of higher-order functions\nconst anotherInputFilePath = path.join(__dirname, 'anotherInput.txt');\nconst anotherOutputFilePath = path.join(__dirname, 'anotherOutput.txt');\n\nreadFileAndProcess(anotherInputFilePath, (data) => {", "suffix": "\n});\n\n// Assertions\nconst assert = require('assert');\nfs.readFile(outputFilePath, 'utf8', (err, data) => {\n    assert.strictEqual(data, 'HELLO WORLD');\n    console.log('First assertion passed');\n    fs.unlinkSync(outputFilePath); // Cleanup\n});\n\nfs.readFile(anotherOutputFilePath, 'utf8', (err, data) => {\n    assert.strictEqual(data, 'DLROW OLLEH');\n    console.log('Second assertion passed');\n    fs.unlinkSync(anotherOutputFilePath); // Cleanup\n});", "golden_completion": "    const reversedData = data.split('').reverse().join('');\n    writeFileAndProcess(anotherOutputFilePath, reversedData, () => {\n        console.log('Data has been reversed and written to another output file.');\n    });", "LLM_justification": "This is a good test case because it clearly establishes a pattern of using higher-order functions to read and write files, while processing the data in between. The pattern involves reading a file, processing the data (e.g., converting to uppercase, reversing), and then writing the processed data to another file. This scenario is realistic and common in tool automation tasks. The golden_completion demonstrates the continuation of this pattern by processing data (reversing it) and writing it to a file, which is consistent with the previously established pattern.", "assertions": "const assert = require('assert');\nfs.readFile(outputFilePath, 'utf8', (err, data) => {\n    assert.strictEqual(data, 'HELLO WORLD');\n    console.log('First assertion passed');\n    fs.unlinkSync(outputFilePath); // Cleanup\n});\n\nfs.readFile(anotherOutputFilePath, 'utf8', (err, data) => {\n    assert.strictEqual(data, 'DLROW OLLEH');\n    console.log('Second assertion passed');\n    fs.unlinkSync(anotherOutputFilePath); // Cleanup\n});", "gpt-4.1-nano": "    const processedData = data.split('').reverse().join('');\n    writeFileAndProcess(anotherOutputFilePath, processedData, () => {\n        console.log('Data has been processed and written to output file.');\n    });"}
{"id": "41", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fetch = require('node-fetch');\n\nasync function fetchData(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Fetch error:', error);\n    throw error;\n  }\n}\n\nasync function fetchMetrics() {\n  const url = 'https://api.example.com/metrics';\n  try {\n    const metrics = await fetchData(url);\n    // Further processing of metrics data\n    ", "suffix": "    return metrics;\n  } catch (error) {\n    console.error('Metrics fetch error:', error);\n    throw error;\n  }\n}\n\n// Example usage\nfetchMetrics().then(metrics => {\n  console.log('Metrics:', metrics);\n}).catch(error => {\n  console.error('Error:', error);\n});\n", "golden_completion": "    console.log('Fetched metrics:', metrics);\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and continue the pattern of async error handling in JavaScript. The prefix includes a function that fetches data from a URL with error handling, and another function that uses the first function to fetch specific metrics. The golden completion should log the fetched metrics data, following the established pattern of handling and logging data in the async functions.", "assertions": "const assert = require('assert');\n(async () => {\n  const fetchMock = async (url) => ({ ok: true, json: async () => ({ metric1: 100, metric2: 200 }) });\n  fetch = fetchMock;\n\n  const result = await fetchMetrics();\n  assert.deepStrictEqual(result, { metric1: 100, metric2: 200 }, 'Metrics data should match expected values');\n  console.log('Assertions passed');\n})();", "gpt-4.1-nano": "console.log('Fetched metrics:', metrics);"}
{"id": "42", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const analytics = require('analytics-library');\n\n// Function to log user actions\nfunction logUserAction(action) {\n    analytics.logEvent(action);\n}\n\n// Function to log page views\nfunction logPageView(page) {\n    analytics.logEvent(page);\n}\n\n// Function to log errors\nfunction logError(error) {\n    analytics.logEvent(error);\n}\n\n// New function to log user signups\nfunction logUserSignup(user) {\n    ", "suffix": "\n}\n\n// Usage examples\nlogUserAction('clicked_button');\nlogPageView('homepage');\nlogError('404_not_found');\nlogUserSignup('JohnDoe');\n\n// Assertions\nconst assert = require('assert');\nconst events = analytics.getLoggedEvents();\nassert(events.includes('clicked_button'));\nassert(events.includes('homepage'));\nassert(events.includes('404_not_found'));\nassert(events.includes('JohnDoe'));\n\n// Cleanup\nanalytics.clearLoggedEvents();", "golden_completion": "analytics.logEvent(user);", "LLM_justification": "This example tests the LLM's ability to recognize a pattern of logging events using an analytics library. The prefix establishes a pattern with three functions that log different types of events using `analytics.logEvent`. The golden completion must continue this pattern by using `analytics.logEvent` to log user signups. The suffix demonstrates the usage of these functions and includes assertions to verify that the events were logged correctly.", "assertions": "assert(events.includes('clicked_button'));\nassert(events.includes('homepage'));\nassert(events.includes('404_not_found'));\nassert(events.includes('JohnDoe'));", "gpt-4.1-nano": "    analytics.logEvent(user);"}
{"id": "43", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\n// Function to read a file asynchronously and process its content\nfunction readFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Function to write to a file asynchronously\nfunction writeFileAsync(filePath, content) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(filePath, content, 'utf8', (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\nasync function processFile(inputPath, outputPath) {\n    try {\n        const data = await readFileAsync(inputPath);\n        const processedData = data.toUpperCase(); // Example processing\n        await writeFileAsync(outputPath, processedData);\n    } catch (error) {\n        console.error('Error processing file:', error);\n    }\n}\n", "suffix": "processFile('input.txt', 'output.txt');\n\n// Cleanup resources if any\n// In this example, there are no explicit resources to clean up", "golden_completion": "async function deleteFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.unlink(filePath, (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}", "LLM_justification": "This is a good test case because it establishes a clear pattern of async functions that perform file operations (readFileAsync, writeFileAsync) using Promises. The task is to complete the pattern by implementing another async function (deleteFileAsync) that follows the same structure. This tests the model's ability to recognize and extend the pattern of async file operations with proper error handling.", "assertions": "const assert = require('assert');\n\n(async () => {\n    const testFile = 'test.txt';\n    const content = 'Hello, World!';\n\n    // Test writeFileAsync\n    await writeFileAsync(testFile, content);\n    const writtenContent = await readFileAsync(testFile);\n    assert.strictEqual(writtenContent, content, 'Content written and read should match');\n\n    // Test deleteFileAsync\n    await deleteFileAsync(testFile);\n    try {\n        await readFileAsync(testFile);\n        assert.fail('File should have been deleted');\n    } catch (error) {\n        assert.strictEqual(error.code, 'ENOENT', 'Error code should be ENOENT for non-existent file');\n    }\n\n    console.log('All assertions passed');\n})();\n\n// No explicit resources to clean up in this example", "gpt-4.1-nano": "processFile('input.txt', 'output.txt');"}
{"id": "44", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fetch = require('node-fetch');\n\n// Function to fetch and process analytics data\nasync function getAnalyticsData(url) {\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        return processAnalyticsData(data);\n    } catch (error) {\n        console.error('Failed to fetch analytics data:', error);\n        throw error;\n    }\n}\n\n// Helper function to process analytics data\nfunction processAnalyticsData(data) {\n    return data.map(item => ({\n        metric: item.metric,\n        value: item.value * 2 // Example transformation\n    }));\n}\n\n// Function to fetch and process user metrics\nasync function getUserMetrics(url) {\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        return processUserMetrics(data);\n    } catch (error) {\n        console.error('Failed to fetch user metrics:', error);\n        throw error;\n    }\n}\n\n// Helper function to process user metrics\nfunction processUserMetrics(data) {\n    return data.map(item => ({\n        user: item.user,\n        score: item.score + 10 // Example transformation\n    }));\n}\n\n// Function to fetch and process error logs\nasync function getErrorLogs(url) {\n    try {\n", "suffix": "        const data = await response.json();\n        return data.map(log => ({\n            timestamp: log.timestamp,\n            message: log.message.toUpperCase() // Example transformation\n        }));\n    } catch (error) {\n        console.error('Failed to fetch error logs:', error);\n        throw error;\n    }\n}\n\n// Example usage\n(async () => {\n    const analyticsDataUrl = 'https://api.example.com/analytics';\n    const userMetricsUrl = 'https://api.example.com/user-metrics';\n    const errorLogsUrl = 'https://api.example.com/error-logs';\n\n    try {\n        const analyticsData = await getAnalyticsData(analyticsDataUrl);\n        const userMetrics = await getUserMetrics(userMetricsUrl);\n        const errorLogs = await getErrorLogs(errorLogsUrl);\n\n        console.log('Analytics Data:', analyticsData);\n        console.log('User Metrics:', userMetrics);\n        console.log('Error Logs:', errorLogs);\n    } catch (error) {\n        console.error('Error during data fetching:', error);\n    }\n})();\n", "golden_completion": "        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n", "LLM_justification": "This example tests the pattern matching capabilities of an LLM by establishing a clear pattern of error handling and data processing in asynchronous functions. The prefix sets up two functions that fetch and process data with error handling in place. The golden completion requires recognizing this pattern and completing the third function accordingly. Assertions verify pattern adherence and functional correctness.", "assertions": "const assert = require('assert');\n(async () => {\n    // Mock fetch responses\n    global.fetch = async (url) => ({\n        ok: true,\n        json: async () => [{ timestamp: '2023-01-01T00:00:00Z', message: 'Error occurred' }]\n    });\n\n    const errorLogs = await getErrorLogs('https://api.example.com/error-logs');\n    assert.strictEqual(errorLogs.length, 1);\n    assert.strictEqual(errorLogs[0].timestamp, '2023-01-01T00:00:00Z');\n    assert.strictEqual(errorLogs[0].message, 'ERROR OCCURRED');\n})();\n", "gpt-4.1-nano": "        const response = await fetch(url);"}
{"id": "45", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\n// Higher-order function to create a logging function\nfunction createLogger(logFile) {\n    return function log(message) {\n        const timestamp = new Date().toISOString();\n        const logMessage = `${timestamp} - ${message}\\n`;\n        fs.appendFileSync(logFile, logMessage);\n    };\n}\n\n// Create two loggers for different purposes\nconst errorLogger = createLogger('error.log');\nconst activityLogger = createLogger('activity.log');\n\n// Log some messages\nerrorLogger('An error occurred');\nactivityLogger('User logged in');\n\n// Higher-order function to create a metric tracking function\nfunction createMetricTracker(metricFile) {\n    return function trackMetric(metric, value) {\n        const timestamp = new Date().toISOString();\n        const metricMessage = `${timestamp} - ${metric}: ${value}\\n`;\n        fs.appendFileSync(metricFile, metricMessage);\n    };\n}\n\n// Create two metric trackers for different purposes\nconst performanceTracker = createMetricTracker('performance.log');\nconst usageTracker = createMetricTracker('usage.log');\n\n// Track some metrics\nperformanceTracker('CPU Usage', '75%');\nusageTracker('API Calls', 120);", "suffix": "\n\n// Perform cleanup (for demonstration purposes)\nfs.unlinkSync('error.log');\nfs.unlinkSync('activity.log');\nfs.unlinkSync('performance.log');\nfs.unlinkSync('usage.log');", "golden_completion": "\n// Track more metrics\nperformanceTracker('Memory Usage', '60%');\nusageTracker('Page Views', 300);", "LLM_justification": "This test case establishes a clear pattern of higher-order functions that create specialized logging and metric tracking functions. The pattern involves creating a function that returns another function with specific behavior, demonstrated by both createLogger and createMetricTracker functions. The golden completion follows this pattern by using the performanceTracker and usageTracker functions to log additional metrics, consistent with the established pattern of tracking metrics. This scenario effectively tests the LLM's ability to recognize and continue the higher-order function pattern in a realistic context involving tool automation and logging.", "assertions": "const fs = require('fs');\nconst assert = require('assert');\n\n// Ensure log files are created and contain expected entries\nconst errorLogContent = fs.readFileSync('error.log', 'utf8');\nassert(errorLogContent.includes('An error occurred'));\n\nconst activityLogContent = fs.readFileSync('activity.log', 'utf8');\nassert(activityLogContent.includes('User logged in'));\n\nconst performanceLogContent = fs.readFileSync('performance.log', 'utf8');\nassert(performanceLogContent.includes('CPU Usage: 75%'));\nassert(performanceLogContent.includes('Memory Usage: 60%'));\n\nconst usageLogContent = fs.readFileSync('usage.log', 'utf8');\nassert(usageLogContent.includes('API Calls: 120'));\nassert(usageLogContent.includes('Page Views: 300'));\n\n// Cleanup log files\nfs.unlinkSync('error.log');\nfs.unlinkSync('activity.log');\nfs.unlinkSync('performance.log');\nfs.unlinkSync('usage.log');", "gpt-4.1-nano": "usageTracker('API Calls', 120);"}
{"id": "46", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fetch = require('node-fetch');\n\n// Function to fetch and process data asynchronously\nasync function fetchData(url) {\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        return processData(data);\n    } catch (error) {\n        console.error('Fetch error:', error);\n        throw error;\n    }\n}\n\n// Function to process data\nfunction processData(data) {\n    // Process data here\n    return data.map(item => item.value);\n}\n\n// Function to fetch multiple URLs asynchronously\nasync function fetchMultipleUrls(urls) {\n    const results = [];\n    for (const url of urls) {\n        try {\n            const result = await fetchData(url);\n            results.push(result);\n        } catch (error) {\n            console.error('Error fetching URL:', url, error);\n        }\n    }\n    return results;\n}\n\n// Test URLs\nconst urls = ['https://api.example.com/data1', 'https://api.example.com/data2'];\n\nasync function testFetchMultipleUrls() {\n    try {\n        const results = await fetchMultipleUrls(urls);\n        console.log('Results:', results);\n    } catch (error) {\n        console.error('Test error:', error);\n    }\n}\n\ntestFetchMultipleUrls();\n", "suffix": "\n\n// Test fetchDataWithRetries\nasync function testFetchDataWithRetries() {\n    try {\n        const result = await fetchDataWithRetries('https://api.example.com/data1');\n        console.log('Fetched with retries:', result);\n    } catch (error) {\n        console.error('Test fetchDataWithRetries error:', error);\n    }\n}\n\ntestFetchDataWithRetries();\n", "golden_completion": "async function fetchDataWithRetries(url, retries = 3) {\n    for (let i = 0; i < retries; i++) {\n        try {\n            const result = await fetchData(url);\n            return result;\n        } catch (error) {\n            console.error('Retrying fetch:', url, 'attempt:', i + 1);\n            if (i === retries - 1) throw error;\n        }\n    }\n}\n", "LLM_justification": "This test case is a good example of testing async patterns and error handling in the context of fetching data from multiple URLs. The pattern of async/await with try/catch for error handling is clearly established in the prefix. The golden_completion must follow this established pattern and handle retries for fetching data, which is a realistic scenario. The assertions verify both the pattern adherence and functionality by checking successful data fetch and proper error handling.", "assertions": "const assert = require('assert');\n(async () => {\n    try {\n        const result = await fetchDataWithRetries('https://api.example.com/data1');\n        assert(result.length > 0, 'Result should not be empty');\n    } catch (error) {\n        assert.fail('fetchDataWithRetries should not throw an error');\n    }\n})();\n(async () => {\n    try {\n        const results = await fetchMultipleUrls(['https://api.example.com/data1', 'https://api.example.com/data2']);\n        assert(results.length === 2, 'Should fetch data from both URLs');\n    } catch (error) {\n        assert.fail('fetchMultipleUrls should not throw an error');\n    }\n})();\n", "gpt-4.1-nano": ""}
{"id": "47", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fs = require('fs');\n\n// Function to read the contents of a file asynchronously\nfunction readFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Function to write data to a file asynchronously\nfunction writeFileAsync(filePath, data) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(filePath, data, 'utf8', (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n// Function to append data to a file asynchronously\n", "suffix": "function deleteFileAsync(filePath) {\n    return new Promise((resolve, reject) => {\n        fs.unlink(filePath, (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n// Tests\n(async () => {\n    const filePath = 'test.txt';\n    try {\n        await writeFileAsync(filePath, 'Hello, World!');\n        let data = await readFileAsync(filePath);\n        console.assert(data === 'Hello, World!', 'Data should be \"Hello, World!\"');\n        await appendFileAsync(filePath, ' More text.');\n        data = await readFileAsync(filePath);\n        console.assert(data === 'Hello, World! More text.', 'Data should be \"Hello, World! More text.\"');\n        await deleteFileAsync(filePath);\n    } catch (err) {\n        console.error('Test failed', err);\n    }\n})();", "golden_completion": "function appendFileAsync(filePath, data) {\n    return new Promise((resolve, reject) => {\n        fs.appendFile(filePath, data, 'utf8', (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern of asynchronous file operations using Promises. The established pattern in the prefix includes functions for reading and writing files asynchronously with error handling. The golden completion follows this pattern by implementing an asynchronous append operation. The suffix continues the pattern by defining a function for deleting files and performing assertions to test the functionality. The completion must adhere to the same conventions and structure as the other functions to be correct.", "assertions": "const filePath = 'test.txt';\n(async () => {\n    try {\n        await writeFileAsync(filePath, 'Hello, World!');\n        let data = await readFileAsync(filePath);\n        console.assert(data === 'Hello, World!', 'Data should be \"Hello, World!\"');\n        await appendFileAsync(filePath, ' More text.');\n        data = await readFileAsync(filePath);\n        console.assert(data === 'Hello, World! More text.', 'Data should be \"Hello, World! More text.\"');\n        await deleteFileAsync(filePath);\n    } catch (err) {\n        console.error('Test failed', err);\n    }\n})();\n", "gpt-4.1-nano": "function deleteFileAsync(filePath) {"}
{"id": "48", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const { assert } = require('chai');\n\n// Higher-order function to create an event handler\nfunction createEventHandler(eventType) {\n    return function handler(event) {\n        console.log(`Handling ${eventType} event`);\n        if (eventType === 'click') {\n            // Click event specific handling\n            console.log('Click event detected:', event.detail);\n        } else if (eventType === 'keydown') {\n            // Keydown event specific handling\n            console.log('Keydown event detected:', event.key);\n        }\n        // Return event processed status\n        return true;\n    };\n}\n\n// Create and test a click event handler\nconst clickHandler = createEventHandler('click');\nconst clickEvent = { detail: 'Button clicked' };\nassert.strictEqual(clickHandler(clickEvent), true);\n\n// Create and test a keydown event handler\nconst keydownHandler = createEventHandler('keydown');\nconst keydownEvent = { key: 'Enter' };\nassert.strictEqual(keydownHandler(keydownEvent), true);\n\n", "suffix": "// Create and test a mouseover event handler\nconst mouseoverHandler = createEventHandler('mouseover');\nconst mouseoverEvent = { detail: 'Mouse over element' };\nassert.strictEqual(mouseoverHandler(mouseoverEvent), true);\n\nconsole.log('All tests passed.');", "golden_completion": "// Create and test a keyup event handler\nconst keyupHandler = createEventHandler('keyup');\nconst keyupEvent = { key: 'A' };\nassert.strictEqual(keyupHandler(keyupEvent), true);\n\n", "LLM_justification": "This test case is a good example of pattern matching as it involves the creation of higher-order functions to handle different types of events. The pattern established in the prefix involves creating handlers for specific event types and testing them with corresponding events. The golden completion continues this pattern by creating and testing another event handler, ensuring the LLM can recognize and continue the established pattern. Assertions check the correctness of event handling and the return values, ensuring the pattern is followed correctly.", "assertions": "assert.strictEqual(createEventHandler('keyup')({ key: 'A' }), true);\nassert.strictEqual(createEventHandler('mouseover')({ detail: 'Mouse over element' }), true);", "gpt-4.1-nano": "// Create and test a mouseover event handler\nconst mouseoverHandler = createEventHandler('mouseover');\nconst mouseoverEvent = { detail: 'Mouse over element' };\nassert.strictEqual(mouseoverHandler(mouseoverEvent), true);"}
{"id": "49", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fetch = require('node-fetch');\n\n// Helper function to fetch data from an API\nasync function fetchData(url) {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Fetch error:', error);\n    throw error;\n  }\n}\n\n// Function to process analytics data\nasync function processAnalytics(urls) {\n  const results = [];\n  for (const url of urls) {\n    try {\n      const data = await fetchData(url);\n      results.push(data);\n    } catch (error) {\n      results.push({ error: error.message });\n    }\n  }\n  return results;\n}\n\nconst testUrls = [\n  'https://jsonplaceholder.typicode.com/todos/1',\n  'https://jsonplaceholder.typicode.com/todos/2',\n  'https://jsonplaceholder.typicode.com/invalid-url'\n];\n\n// Execute the processAnalytics function\nprocessAnalytics(testUrls)\n  .then(results => {\n    console.log('Results:', results);\n    // Assertions\n    const assert = require('assert');\n    assert.strictEqual(results.length, 3);\n    assert.strictEqual(results[0].id, 1);\n    assert.strictEqual(results[1].id, 2);\n    assert(results[2].error);\n", "suffix": "  })\n  .catch(error => console.error('Unexpected error:', error));\n", "golden_completion": "    assert.strictEqual(results[2].error, 'Network response was not ok');\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue a pattern involving error handling and async patterns within the context of processing analytics data. The prefix establishes a clear pattern of handling asynchronous API calls with error handling, which the golden completion continues by asserting the correct error message for a failed API call. This helps verify that the LLM can maintain consistency in error handling practices.", "assertions": "const assert = require('assert');\nconst results = [\n  { id: 1 },\n  { id: 2 },\n  { error: 'Network response was not ok' }\n];\nassert.strictEqual(results.length, 3);\nassert.strictEqual(results[0].id, 1);\nassert.strictEqual(results[1].id, 2);\nassert(results[2].error);\nassert.strictEqual(results[2].error, 'Network response was not ok');\n", "gpt-4.1-nano": "  });"}
{"id": "50", "testsource": "synthbench-pattern-matching", "language": "javascript", "prefix": "const fetch = require('node-fetch');\n\n// Function to fetch and process user data for analytics\nasync function fetchUserData(userId) {\n    try {\n        const response = await fetch(`https://api.example.com/users/${userId}`);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const userData = await response.json();\n        return userData;\n    } catch (error) {\n        console.error('Failed to fetch user data:', error);\n        throw error;\n    }\n}\n\n// Function to fetch and process analytics data for a user\nasync function fetchUserAnalytics(userId) {\n    try {\n        const response = await fetch(`https://api.example.com/users/${userId}/analytics`);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const analyticsData = await response.json();\n        return analyticsData;\n    } catch (error) {\n        console.error('Failed to fetch user analytics:', error);\n        throw error;\n    }\n}\n\n// Function to fetch and process user settings\nasync function fetchUserSettings(userId) {\n    ", "suffix": "\n}\n\n(async () => {\n    try {\n        const userId = 123;\n        const userData = await fetchUserData(userId);\n        const userAnalytics = await fetchUserAnalytics(userId);\n        const userSettings = await fetchUserSettings(userId);\n\n        console.log('User Data:', userData);\n        console.log('User Analytics:', userAnalytics);\n        console.log('User Settings:', userSettings);\n    } catch (error) {\n        console.error('Error fetching data:', error);\n    }\n})();\n", "golden_completion": "try {\n        const response = await fetch(`https://api.example.com/users/${userId}/settings`);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const settingsData = await response.json();\n        return settingsData;\n    } catch (error) {\n        console.error('Failed to fetch user settings:', error);\n        throw error;\n    }\n", "LLM_justification": "This is a good test case because it establishes a clear pattern of asynchronous functions with error handling for fetching data from an API. Each function follows the same structure: making a network request, checking the response, parsing the JSON, and handling errors. The golden completion must follow this pattern to be correct. This tests the LLM's ability to recognize and continue a pattern in the context of async/await operations and error handling, which are common in real-world JavaScript applications.", "assertions": "const assert = require('assert');\n(async () => {\n    const userId = 123;\n    try {\n        const userSettings = await fetchUserSettings(userId);\n        assert(userSettings, 'User settings should be fetched successfully');\n        assert(typeof userSettings === 'object', 'User settings should be an object');\n    } catch (error) {\n        assert.fail('Fetching user settings should not throw an error');\n    }\n})();", "gpt-4.1-nano": "        const response = await fetch(`https://api.example.com/users/${userId}/settings`);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const settingsData = await response.json();\n        return settingsData;"}
