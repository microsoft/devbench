
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

function encrypt(text, algorithm, password) {
    const cipher = crypto.createCipher(algorithm, password);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
}

function decrypt(encryptedText, algorithm, password) {
    const decipher = crypto.createDecipher(algorithm, password);
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

function hash(text, algorithm) {
    const hash = crypto.createHash(algorithm);
    hash.update(text);
    return hash.digest('hex');
}

// Function to generate a random salt
function generateSalt(length) {
    return crypto.randomBytes(length).toString('hex');
}

// Function to hash a password with a salt
function hashPasswordWithSalt(password, salt, algorithm) {

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    const hash = crypto.createHash(algorithm);
    hash.update(salt + password);

SUFFIX CODE:
----------------------------------------

    return `${salt}:${hash.digest('hex')}`;
}

// Test the functionality
const password = 'mysecretpassword';
const salt = generateSalt(16);
const algorithm = 'sha256';

const hashedPassword = hashPasswordWithSalt(password, salt, algorithm);
const [saltPart, hashPart] = hashedPassword.split(':');

assert.strictEqual(saltPart, salt);
assert.strictEqual(hashPart.length, 64);
console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern related to cryptographic operations in JavaScript, specifically focusing on hashing a password with a salt. The pattern includes creating a hash, updating it with data, and returning the result. This is a common pattern in security contexts. The completion must follow this pattern by correctly creating and updating the hash object.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const hashedPassword = hashPasswordWithSalt('mypassword', 'somesalt', 'sha256');
const [saltPart, hashPart] = hashedPassword.split(':');
assert.strictEqual(saltPart, 'somesalt');
assert.strictEqual(hashPart.length, 64);
console.log('All assertions passed.');
================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

class Logger {
    constructor(filePath) {
        this.filePath = filePath;
    }

    logInfo(message) {
        const logMessage = `[INFO] ${new Date().toISOString()} - ${message}\n`;
        fs.appendFileSync(this.filePath, logMessage);
    }

    logWarning(message) {
        const logMessage = `[WARNING] ${new Date().toISOString()} - ${message}\n`;
        fs.appendFileSync(this.filePath, logMessage);
    }



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    logError(message) {
        const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}\n`;
        fs.appendFileSync(this.filePath, logMessage);
    }

SUFFIX CODE:
----------------------------------------
}

// Example usage
const logger = new Logger('app.log');
logger.logInfo('Application started');
logger.logWarning('Low disk space');
logger.logError('Unhandled exception');

const logs = fs.readFileSync('app.log', 'utf8');
console.log(logs);

JUSTIFICATION:
----------------------------------------
This test case is a good example of an OOP pattern in the context of system operations (logging). The pattern established here involves logging different types of messages (info, warning, error) to a file with a timestamp. The golden completion requires recognizing and following the pattern established by the logInfo and logWarning methods to create a logError method that follows the same format. The assertions verify that the logError method correctly appends the error messages to the log file.

ASSERTIONS:
----------------------------------------
const fs = require('fs');
const assert = require('assert');

// Clean up the log file before running tests
if (fs.existsSync('app.log')) {
    fs.unlinkSync('app.log');
}

// Initialize logger and log messages
const logger = new Logger('app.log');
logger.logInfo('Application started');
logger.logWarning('Low disk space');
logger.logError('Unhandled exception');

// Read log file contents
const logs = fs.readFileSync('app.log', 'utf8');

// Assertions
assert(logs.includes('[INFO]'), 'Log should contain info messages');
assert(logs.includes('[WARNING]'), 'Log should contain warning messages');
assert(logs.includes('[ERROR]'), 'Log should contain error messages');
assert(logs.includes('Application started'), 'Log should contain the info message');
assert(logs.includes('Low disk space'), 'Log should contain the warning message');
assert(logs.includes('Unhandled exception'), 'Log should contain the error message');

================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

class Logger {
  constructor(fileName) {
    this.fileName = fileName;
  }

  logInfo(message) {
    const logMessage = `[INFO] ${new Date().toISOString()} - ${message}`;
    this.writeToFile(logMessage);
  }

  logWarning(message) {
    const logMessage = `[WARNING] ${new Date().toISOString()} - ${message}`;
    this.writeToFile(logMessage);
  }

  // Pattern: logError method should follow the same format as logInfo and logWarning
  // logError method should be implemented here


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
  logError(message) {
    const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}`;
    this.writeToFile(logMessage);
  }

SUFFIX CODE:
----------------------------------------
  writeToFile(message) {
    fs.appendFileSync(this.fileName, message + '\n');
  }
}

// Test the Logger class
const logger = new Logger('log.txt');
logger.logInfo('This is an info message');
logger.logWarning('This is a warning message');
logger.logError('This is an error message');

const logContents = fs.readFileSync('log.txt', 'utf-8');
console.log(logContents);

// Cleanup
fs.unlinkSync('log.txt');

JUSTIFICATION:
----------------------------------------
This example tests the pattern recognition capability of the LLM in the context of system operations, specifically logging. The Logger class methods logInfo and logWarning establish a clear pattern for logging messages with a timestamp and a specific log level. The logError method needs to follow this same pattern. The golden completion is designed to follow the established pattern, ensuring that logError logs messages in the same format as logInfo and logWarning. This tests the LLM's ability to recognize and continue the established logging pattern in a realistic scenario.

ASSERTIONS:
----------------------------------------
const fs = require('fs');
const assert = require('assert');

class Logger {
  constructor(fileName) {
    this.fileName = fileName;
  }

  logInfo(message) {
    const logMessage = `[INFO] ${new Date().toISOString()} - ${message}`;
    this.writeToFile(logMessage);
  }

  logWarning(message) {
    const logMessage = `[WARNING] ${new Date().toISOString()} - ${message}`;
    this.writeToFile(logMessage);
  }

  logError(message) {
    const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}`;
    this.writeToFile(logMessage);
  }

  writeToFile(message) {
    fs.appendFileSync(this.fileName, message + '\n');
  }
}

// Test the Logger class
const logger = new Logger('log.txt');
logger.logInfo('This is an info message');
logger.logWarning('This is a warning message');
logger.logError('This is an error message');

const logContents = fs.readFileSync('log.txt', 'utf-8');
assert(logContents.includes('[INFO]'));
assert(logContents.includes('[WARNING]'));
assert(logContents.includes('[ERROR]'));

// Cleanup
fs.unlinkSync('log.txt');
================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const axios = require('axios');

// Function to fetch user data from an API
async function fetchUserData(userId) {
    try {
        const response = await axios.get(`https://api.example.com/users/${userId}`);
        if (response.status === 200) {
            return response.data;
        } else {
            throw new Error('Failed to fetch user data');
        }
    } catch (error) {
        console.error('Error fetching user data:', error);
        throw error;
    }
}

// Function to fetch post data from an API
async function fetchPostData(postId) {
    try {
        const response = await axios.get(`https://api.example.com/posts/${postId}`);
        if (response.status === 200) {
            return response.data;
        } else {
            throw new Error('Failed to fetch post data');
        }
    } catch (error) {
        console.error('Error fetching post data:', error);
        throw error;
    }
}

// Function to fetch comments data from an API
async function fetchCommentsData(commentId) {
    

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    try {
        const response = await axios.get(`https://api.example.com/comments/${commentId}`);
        if (response.status === 200) {
            return response.data;
        } else {
            throw new Error('Failed to fetch comments data');
        }
    } catch (error) {
        console.error('Error fetching comments data:', error);
        throw error;
    }
}

SUFFIX CODE:
----------------------------------------


// Assertions
(async () => {
    const userData = await fetchUserData(1);
    console.assert(userData.id === 1, 'User ID should be 1');

    const postData = await fetchPostData(1);
    console.assert(postData.id === 1, 'Post ID should be 1');

    const commentsData = await fetchCommentsData(1);
    console.assert(commentsData.id === 1, 'Comment ID should be 1');
})();


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and complete patterns in JavaScript async functions for fetching data from an API. The prefix establishes a pattern of handling API requests with axios, including error handling and status checking. The golden_completion must follow this established pattern for the function fetchCommentsData, demonstrating understanding of async/await, error handling, and proper API request structure. The suffix continues the pattern but does not repeat the completion, ensuring clear distinction between provided code and the expected completion.

ASSERTIONS:
----------------------------------------
(async () => {
    const userData = await fetchUserData(1);
    console.assert(userData.id === 1, 'User ID should be 1');

    const postData = await fetchPostData(1);
    console.assert(postData.id === 1, 'Post ID should be 1');

    const commentsData = await fetchCommentsData(1);
    console.assert(commentsData.id === 1, 'Comment ID should be 1');
})();
================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

class Logger {
    constructor(filename) {
        this.filename = filename;
    }

    logInfo(message) {
        const logMessage = `[INFO] ${new Date().toISOString()}: ${message}\n`;
        fs.appendFileSync(this.filename, logMessage);
    }

    logWarning(message) {
        const logMessage = `[WARNING] ${new Date().toISOString()}: ${message}\n`;
        fs.appendFileSync(this.filename, logMessage);
    }

    // Define logError method following the pattern established by logInfo and logWarning
    logError(message) {


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        const logMessage = `[ERROR] ${new Date().toISOString()}: ${message}\n`;

SUFFIX CODE:
----------------------------------------
        fs.appendFileSync(this.filename, logMessage);
    }
}

const logger = new Logger('log.txt');
logger.logInfo('This is an informational message.');
logger.logWarning('This is a warning message.');
logger.logError('This is an error message.');

// Assertions
const logContents = fs.readFileSync('log.txt', 'utf8');
console.assert(logContents.includes('[INFO]'), 'Log should contain [INFO] entry');
console.assert(logContents.includes('[WARNING]'), 'Log should contain [WARNING] entry');
console.assert(logContents.includes('[ERROR]'), 'Log should contain [ERROR] entry');

// Cleanup
fs.unlinkSync('log.txt');


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern in an OOP context within a logging system. The established pattern involves creating log messages with a specific format and appending them to a file. The golden_completion must follow the pattern set by the logInfo and logWarning methods, ensuring consistency in the log message formatting.

ASSERTIONS:
----------------------------------------
const logContents = fs.readFileSync('log.txt', 'utf8');
console.assert(logContents.includes('[INFO]'), 'Log should contain [INFO] entry');
console.assert(logContents.includes('[WARNING]'), 'Log should contain [WARNING] entry');
console.assert(logContents.includes('[ERROR]'), 'Log should contain [ERROR] entry');

// Cleanup
fs.unlinkSync('log.txt');
================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

class DataEncryptor {
  constructor(key) {
    this.key = key;
    this.algorithm = 'aes-256-cbc';
  }

  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, Buffer.from(this.key), iv);
    let encrypted = cipher.update(text);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return iv.toString('hex') + ':' + encrypted.toString('hex');
  }

  decrypt(text) {
    const textParts = text.split(':');
    const iv = Buffer.from(textParts.shift(), 'hex');
    const encryptedText = Buffer.from(textParts.join(':'), 'hex');
    const decipher = crypto.createDecipheriv(this.algorithm, Buffer.from(this.key), iv);
    let decrypted = decipher.update(encryptedText);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString();
  }
}

// Testing the DataEncryptor
const key = crypto.randomBytes(32);
const encryptor = new DataEncryptor(key);
const originalText = 'Hello World!';
const encryptedText = encryptor.encrypt(originalText);
console.log('Encrypted:', encryptedText);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const decryptedText = encryptor.decrypt(encryptedText);
console.log('Decrypted:', decryptedText);

SUFFIX CODE:
----------------------------------------


// Clean up or additional logic if necessary


JUSTIFICATION:
----------------------------------------
This is a good test case because it establishes a clear pattern for encryption and decryption using a class in JavaScript. The pattern includes methods for both encrypting and decrypting text using a given key. The golden completion should follow this established pattern by correctly implementing the decryption and outputting the decrypted text. This tests the LLM's ability to recognize and continue object-oriented patterns in the context of security and encryption.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Verify that the original text matches the decrypted text
assert.strictEqual(decryptedText, originalText, 'The decrypted text should match the original text');

// Ensure the encrypted text is not the same as the original text
assert.notStrictEqual(encryptedText, originalText, 'The encrypted text should not match the original text');

// Ensure the encrypted text is a string and not empty
assert.strictEqual(typeof encryptedText, 'string', 'The encrypted text should be a string');
assert.ok(encryptedText.length > 0, 'The encrypted text should not be empty');
================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

// A class representing a simple logger
class Logger {
    constructor(filePath) {
        this.filePath = filePath;
    }

    // Logs a message with INFO level
    logInfo(message) {
        const logMessage = `[INFO] ${new Date().toISOString()} - ${message}\n`;
        fs.appendFileSync(this.filePath, logMessage);
    }

    // Logs a message with WARN level
    logWarn(message) {
        const logMessage = `[WARN] ${new Date().toISOString()} - ${message}\n`;
        fs.appendFileSync(this.filePath, logMessage);
    }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    // Logs a message with DEBUG level
    logDebug(message) {
        const logMessage = `[DEBUG] ${new Date().toISOString()} - ${message}\n`;
        fs.appendFileSync(this.filePath, logMessage);
    }

SUFFIX CODE:
----------------------------------------

    // Logs a message with ERROR level
    logError(message) {
        const logMessage = `[ERROR] ${new Date().toISOString()} - ${message}\n`;
        fs.appendFileSync(this.filePath, logMessage);
    }
}

// Usage example
const logger = new Logger('log.txt');
logger.logInfo('This is an info message.');
logger.logWarn('This is a warning message.');
logger.logError('This is an error message.');

// Read the log file to verify the contents
const logContents = fs.readFileSync('log.txt', 'utf8');

// Assertions
const assert = require('assert');
assert(logContents.includes('[INFO]') && logContents.includes('This is an info message.'));
assert(logContents.includes('[WARN]') && logContents.includes('This is a warning message.'));
assert(logContents.includes('[ERROR]') && logContents.includes('This is an error message.'));

// Clean up the log file
fs.unlinkSync('log.txt');

JUSTIFICATION:
----------------------------------------
This example tests the ability of an LLM to recognize and continue an OOP pattern within a domain context of tool automation (logging). The established pattern in the prefix includes methods for logging messages with different severity levels (INFO, WARN), and the golden completion involves adding a similar method for DEBUG level. The suffix then includes a different method (ERROR level) and usage examples, ensuring the continuation of the pattern. The assertions verify that all log messages are correctly written to the file.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const logContents = fs.readFileSync('log.txt', 'utf8');
assert(logContents.includes('[INFO]') && logContents.includes('This is an info message.'));
assert(logContents.includes('[WARN]') && logContents.includes('This is a warning message.'));
assert(logContents.includes('[ERROR]') && logContents.includes('This is an error message.'));
assert(logContents.includes('[DEBUG]') && logContents.includes('This is a debug message.'));

// Clean up the log file
fs.unlinkSync('log.txt');
================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

// Utility function to fetch JSON data from a URL
async function fetchJson(url) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
}

// Higher-order function to handle API calls with retries
async function withRetry(apiCall, retries = 3) {
    let attempts = 0;
    while (attempts < retries) {
        try {
            return await apiCall();
        } catch (error) {
            if (attempts === retries - 1) {
                throw error;
            }
            attempts++;
        }
    }
}

// Example API call function
async function getWeatherData(city) {
    const url = `https://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q=${city}`;
    return fetchJson(url);
}

// Main function to fetch weather data with retries
async function main() {
    const city = 'London';
    try {
        const weatherData = await withRetry(() => getWeatherData(city));
        console.log('Weather data:', weatherData);
    } catch (error) {
        console.error('Failed to fetch weather data:', error);
    }
}

main();

// Test cases to verify the pattern

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
async function getUserData(userId) {
    const url = `https://api.example.com/users/${userId}`;
    return fetchJson(url);
}

async function fetchUserData(userId) {
    try {
        const userData = await withRetry(() => getUserData(userId));
        console.log('User data:', userData);
    } catch (error) {
        console.error('Failed to fetch user data:', error);
    }
}

fetchUserData('12345');

SUFFIX CODE:
----------------------------------------
async function getUserData(userId) {
    const url = `https://api.example.com/users/${userId}`;
    return fetchJson(url);
}

async function fetchUserData(userId) {
    try {
        const userData = await withRetry(() => getUserData(userId));
        console.log('User data:', userData);
    } catch (error) {
        console.error('Failed to fetch user data:', error);
    }
}

fetchUserData('12345');

JUSTIFICATION:
----------------------------------------
This test case demonstrates a clear pattern of using a higher-order function with retry logic to handle API calls. The prefix establishes the pattern with multiple examples, including `fetchJson`, `withRetry`, and `getWeatherData`. The golden completion follows this pattern by implementing similar logic for fetching stock data. The suffix continues the pattern with a different API call, ensuring the pattern is recognizable and consistent. This scenario tests the LLM's ability to identify and complete the pattern accurately.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
    const mockFetch = async (url) => ({ ok: true, json: async () => ({ url }) });
    const originalFetch = global.fetch;
    global.fetch = mockFetch;
    try {
        const weatherData = await withRetry(() => getWeatherData('London'));
        assert.strictEqual(weatherData.url, 'https://api.weatherapi.com/v1/current.json?key=YOUR_API_KEY&q=London');

        const stockData = await withRetry(() => getStockData('AAPL'));
        assert.strictEqual(stockData.url, 'https://api.example.com/stocks/AAPL');

        const userData = await withRetry(() => getUserData('12345'));
        assert.strictEqual(userData.url, 'https://api.example.com/users/12345');
    } catch (error) {
        assert.fail('Unexpected error occurred: ' + error.message);
    } finally {
        global.fetch = originalFetch;
    }
})();
================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
class NetworkProtocol {
    constructor() {
        this.connections = [];
    }

    addConnection(connection) {
        if (this.validateConnection(connection)) {
            this.connections.push(connection);
        } else {
            throw new Error('Invalid connection');
        }
    }

    validateConnection(connection) {
        return connection && connection.url && typeof connection.url === 'string';
    }

    // Existing pattern: method to process connections
    processConnections() {
        this.connections.forEach(connection => {
            console.log(`Processing connection: ${connection.url}`);
        });
    }

    // Existing pattern: method to close connections
    closeConnections() {
        this.connections.forEach(connection => {
            console.log(`Closing connection: ${connection.url}`);
        });
    }



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    removeConnection(connection) {

SUFFIX CODE:
----------------------------------------
    removeConnection(connection) {
        const index = this.connections.indexOf(connection);
        if (index > -1) {
            this.connections.splice(index, 1);
            console.log(`Removed connection: ${connection.url}`);
        } else {
            throw new Error('Connection not found');
        }
    }
}

// Test cases
const protocol = new NetworkProtocol();
const validConnection = { url: 'http://example.com' };
const invalidConnection = { url: 12345 };
protocol.addConnection(validConnection);
protocol.processConnections();
protocol.closeConnections();

try {
    protocol.addConnection(invalidConnection);
} catch (e) {
    console.log(e.message); // Expect 'Invalid connection'
}

protocol.removeConnection(validConnection);

try {
    protocol.removeConnection(validConnection);
} catch (e) {
    console.log(e.message); // Expect 'Connection not found'
}


JUSTIFICATION:
----------------------------------------
This is a good test case because it establishes a clear, identifiable pattern in the prefix with methods that iterate over connections and perform some action (logging). The golden completion must follow this pattern by adding a new method that iterates over the connections and performs a similar action, maintaining consistency with the existing methods. The suffix provides further methods and tests that ensure the overall functionality and error handling of the class.

ASSERTIONS:
----------------------------------------
const protocol = new NetworkProtocol();
const validConnection = { url: 'http://example.com' };
protocol.addConnection(validConnection);
protocol.syncConnections();

try {
    protocol.addConnection({ url: 12345 });
    assert.fail('Expected an error for invalid connection');
} catch (e) {
    assert.strictEqual(e.message, 'Invalid connection');
}

protocol.removeConnection(validConnection);

try {
    protocol.removeConnection(validConnection);
    assert.fail('Expected an error for non-existent connection');
} catch (e) {
    assert.strictEqual(e.message, 'Connection not found');
}

================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

class DataProcessor {
    constructor(directory) {
        this.directory = directory;
    }

    async processFiles() {
        const files = await this.getFiles();
        for (const file of files) {
            try {
                const content = await this.readFile(file);
                const processedContent = this.processContent(content);
                await this.writeFile(file, processedContent);
            } catch (error) {
                console.error(`Error processing file ${file}:`, error);
            }
        }
    }

    async getFiles() {
        return new Promise((resolve, reject) => {
            fs.readdir(this.directory, (err, files) => {
                if (err) {
                    return reject(err);
                }
                resolve(files);
            });
        });
    }

    async readFile(file) {
        return new Promise((resolve, reject) => {
            fs.readFile(path.join(this.directory, file), 'utf8', (err, data) => {
                if (err) {
                    return reject(err);
                }
                resolve(data);
            });
        });
    }

    processContent(content) {
        // Simulate content processing
        return content.toUpperCase();
    }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    async writeFile(file, content) {
        return new Promise((resolve, reject) => {
            fs.writeFile(path.join(this.directory, file), content, 'utf8', (err) => {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    }

SUFFIX CODE:
----------------------------------------

}

// Usage
(async () => {
    const processor = new DataProcessor('./data');
    await processor.processFiles();
})();


JUSTIFICATION:
----------------------------------------
This test case is a good example because it establishes a clear pattern of asynchronous file operations encapsulated in a class method. The pattern involves using Promises to handle asynchronous operations with the fs module and a consistent error-handling approach. The completion must follow this pattern to ensure that the code remains consistent and functional. The provided assertions test both the functionality and the adherence to the established pattern.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const mockFs = require('mock-fs');

// Mock file system
mockFs({
    './data': {
        'file1.txt': 'hello',
        'file2.txt': 'world',
    }
});

(async () => {
    const processor = new DataProcessor('./data');
    await processor.processFiles();

    const content1 = fs.readFileSync('./data/file1.txt', 'utf8');
    const content2 = fs.readFileSync('./data/file2.txt', 'utf8');

    assert.strictEqual(content1, 'HELLO');
    assert.strictEqual(content2, 'WORLD');

    // Cleanup
    mockFs.restore();
})();

================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

class DataProcessor {
    constructor(directory) {
        this.directory = directory;
    }

    async processFile(filename) {
        try {
            const filePath = path.join(this.directory, filename);
            const data = await fs.promises.readFile(filePath, 'utf8');
            return this.transformData(data);
        } catch (error) {
            console.error(`Error processing file ${filename}:`, error);
            throw error;
        }
    }

    transformData(data) {
        // Placeholder for transforming data
        return data.split('\n').map(line => line.trim());
    }
}

async function main() {
    const processor = new DataProcessor('./data');
    try {
        const result1 = await processor.processFile('file1.txt');
        console.log('Result 1:', result1);

        const result2 = await processor.processFile('file2.txt');
        console.log('Result 2:', result2);

        const result3 = 

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
await processor.processFile('file3.txt');

SUFFIX CODE:
----------------------------------------
    } catch (error) {
        console.error('Error in main function:', error);
    }
}

main();


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and continue an established async pattern in a file processing context. The prefix establishes a pattern where the 'processFile' method of the 'DataProcessor' class is called with different filenames, and the results are logged. The golden completion must continue this pattern with a new filename. The suffix contains different code that continues the flow but does not repeat the completion. This scenario tests pattern recognition in a realistic async file processing context.

ASSERTIONS:
----------------------------------------
const processor = new DataProcessor('./data');
(async () => {
    const result1 = await processor.processFile('file1.txt');
    console.log('Result 1:', result1);
    const result2 = await processor.processFile('file2.txt');
    console.log('Result 2:', result2);
    const result3 = await processor.processFile('file3.txt');
    console.log('Result 3:', result3);
    console.assert(Array.isArray(result1), 'Result 1 should be an array');
    console.assert(Array.isArray(result2), 'Result 2 should be an array');
    console.assert(Array.isArray(result3), 'Result 3 should be an array');
})();
================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

// Utility function to read a file asynchronously
function readFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Utility function to write to a file asynchronously
function writeFileAsync(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, data, 'utf8', (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Utility function to delete a file asynchronously
function deleteFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.unlink(filePath, (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Example usage of the utility functions
async function main() {
    const testFilePath = path.join(__dirname, 'test.txt');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await writeFileAsync(testFilePath, 'Hello, world!');

SUFFIX CODE:
----------------------------------------
    const content = await readFileAsync(testFilePath);
    console.log('File content:', content);

    await deleteFileAsync(testFilePath);
    console.log('File deleted successfully');
}

main().catch(console.error);

JUSTIFICATION:
----------------------------------------
This test case checks if the LLM can recognize and continue the pattern of using asynchronous utility functions for file operations. The pattern is established with three utility functions (readFileAsync, writeFileAsync, deleteFileAsync) that follow a similar structure of returning Promises and handling errors. The golden completion must continue this pattern by using the writeFileAsync function before proceeding with the rest of the code.

ASSERTIONS:
----------------------------------------
const fs = require('fs');
const path = require('path');
const assert = require('assert');

async function test() {
    const testFilePath = path.join(__dirname, 'test.txt');

    // Ensure file does not exist before test
    if (fs.existsSync(testFilePath)) {
        fs.unlinkSync(testFilePath);
    }

    // Execute main function
    await main();

    // Verify file operations
    assert.strictEqual(fs.existsSync(testFilePath), false, 'File should be deleted');
}

test().then(() => console.log('All assertions passed')).catch(console.error);
================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

class User {
    constructor(username, password) {
        this.username = username;
        this.passwordHash = this.hashPassword(password);
    }

    hashPassword(password) {
        return crypto.createHash('sha256').update(password).digest('hex');
    }

    authenticate(password) {
        return this.passwordHash === this.hashPassword(password);
    }

    static validateUsername(username) {
        const usernameRegex = /^[a-zA-Z0-9_]{3,16}$/;
        return usernameRegex.test(username);
    }

    static validatePassword(password) {
        const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/;
        return passwordRegex.test(password);
    }

    // Implement email validation pattern


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    static validateEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

SUFFIX CODE:
----------------------------------------
    static validatePhoneNumber(phoneNumber) {
        const phoneRegex = /^\+?[1-9]\d{1,14}$/;
        return phoneRegex.test(phoneNumber);
    }
}

// Example Usage
const user = new User('testUser', 'Password123');
console.assert(user.authenticate('Password123') === true, 'Authentication failed');
console.assert(User.validateUsername('valid_user') === true, 'Username validation failed');
console.assert(User.validatePassword('ValidPass123') === true, 'Password validation failed');
console.assert(User.validatePhoneNumber('+1234567890') === true, 'Phone number validation failed');


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and continue a pattern of static validation methods in a class. The pattern involves defining a static method that validates input against a regular expression. The golden_completion follows this pattern by implementing an email validation method, similar to the username and password validation methods already established in the prefix. This scenario is realistic and common in user authentication and validation systems.

ASSERTIONS:
----------------------------------------
console.assert(User.validateEmail('valid.email@example.com') === true, 'Email validation failed');
console.assert(User.validateEmail('invalid-email') === false, 'Email validation did not catch invalid email');
================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const https = require('https');

// Function to make a GET request to an API
function fetchFromApi(url, callback) {
    https.get(url, (res) => {
        let data = '';

        // A chunk of data has been received.
        res.on('data', (chunk) => {
            data += chunk;
        });

        // The whole response has been received.
        res.on('end', () => {
            callback(null, JSON.parse(data));
        });
    }).on('error', (err) => {
        callback(err);
    });
}

// Function to process user data from the API
function processUserData(userId, callback) {
    const url = `https://api.example.com/users/${userId}`;
    fetchFromApi(url, (err, data) => {
        if (err) {
            callback(err);
            return;
        }
        // Process the user data
        callback(null, data);
    });
}

// Function to process order data from the API
function processOrderData(orderId, callback) {
    const url = `https://api.example.com/orders/${orderId}`;
    fetchFromApi(url, (err, data) => {
        if (err) {
            callback(err);
            return;
        }
        // Process the order data
        callback(null, data);
    });
}

// Function to process product data from the API
function processProductData(productId, callback) {
    const url = `https://api.example.com/products/${productId}`;
    fetchFromApi(url, (err, data) => {
        if (err) {
            callback(err);
            return;
        }
        // Process the product data
        callback(null, data);
    });
}



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Function to process category data from the API
function processCategoryData(categoryId, callback) {
    const url = `https://api.example.com/categories/${categoryId}`;
    fetchFromApi(url, (err, data) => {
        if (err) {
            callback(err);
            return;
        }
        // Process the category data
        callback(null, data);
    });
}

SUFFIX CODE:
----------------------------------------

// Example usage and assertions
processUserData(1, (err, data) => {
    console.assert(!err, 'Error should be null');
    console.assert(data.id === 1, 'User ID should be 1');
});

processOrderData(2, (err, data) => {
    console.assert(!err, 'Error should be null');
    console.assert(data.id === 2, 'Order ID should be 2');
});

processProductData(3, (err, data) => {
    console.assert(!err, 'Error should be null');
    console.assert(data.id === 3, 'Product ID should be 3');
});

processCategoryData(4, (err, data) => {
    console.assert(!err, 'Error should be null');
    console.assert(data.id === 4, 'Category ID should be 4');
});

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and complete a pattern of async API data fetching and error handling. The prefix establishes a clear pattern with multiple similar functions fetching different types of data from an API. The golden completion requires the LLM to continue this pattern for a new data type (category data) using the same structure and conventions. This tests the model's understanding of async patterns, error handling, and consistency in function definitions. The assertions verify that the pattern is adhered to and that the functions behave as expected.

ASSERTIONS:
----------------------------------------
processUserData(1, (err, data) => {
    console.assert(!err, 'Error should be null');
    console.assert(data.id === 1, 'User ID should be 1');
});

processOrderData(2, (err, data) => {
    console.assert(!err, 'Error should be null');
    console.assert(data.id === 2, 'Order ID should be 2');
});

processProductData(3, (err, data) => {
    console.assert(!err, 'Error should be null');
    console.assert(data.id === 3, 'Product ID should be 3');
});

processCategoryData(4, (err, data) => {
    console.assert(!err, 'Error should be null');
    console.assert(data.id === 4, 'Category ID should be 4');
});
================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

function readFile(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (err, data) => {
      if (err) {
        return reject(err);
      }
      resolve(data);
    });
  });
}

function writeFile(filePath, data) {
  return new Promise((resolve, reject) => {
    fs.writeFile(filePath, data, 'utf8', (err) => {
      if (err) {
        return reject(err);
      }
      resolve();
    });
  });
}

async function copyFile(source, destination) {
  try {
    const data = await readFile(source);
    await writeFile(destination, data);
  } catch (err) {
    console.error('Error copying file:', err);
  }
}

async function moveFile(source, destination) {
  try {
    const data = await readFile(source);
    await writeFile(destination, data);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await deleteFile(source);

SUFFIX CODE:
----------------------------------------

  } catch (err) {
    console.error('Error moving file:', err);
  }
}

async function deleteFile(filePath) {
  return new Promise((resolve, reject) => {
    fs.unlink(filePath, (err) => {
      if (err) {
        return reject(err);
      }
      resolve();
    });
  });
}

// Test the moveFile function
(async () => {
  const source = path.join(__dirname, 'source.txt');
  const destination = path.join(__dirname, 'destination.txt');
  fs.writeFileSync(source, 'Hello, world!');

  await moveFile(source, destination);

  const destinationContent = fs.readFileSync(destination, 'utf8');
  console.assert(destinationContent === 'Hello, world!', 'File content should match');
  console.assert(!fs.existsSync(source), 'Source file should be deleted');
})();

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of async patterns in a file manipulation context. The pattern of reading, writing, and deleting files asynchronously using Promises and async/await is established in the prefix and suffix. The golden completion must correctly follow this pattern by adding the deletion of the source file in the moveFile function. This tests the LLM's ability to recognize and continue the established async pattern. The assertions check the correctness of the file manipulation operations.

ASSERTIONS:
----------------------------------------
const source = path.join(__dirname, 'source.txt');
const destination = path.join(__dirname, 'destination.txt');
fs.writeFileSync(source, 'Hello, world!');

(async () => {
  await moveFile(source, destination);
  const destinationContent = fs.readFileSync(destination, 'utf8');
  console.assert(destinationContent === 'Hello, world!', 'File content should match');
  console.assert(!fs.existsSync(source), 'Source file should be deleted');
})();
================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

// Function to read a file asynchronously
function readFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                return reject(err);
            }
            resolve(data);
        });
    });
}

// Function to write a file asynchronously
function writeFileAsync(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, data, 'utf8', (err) => {
            if (err) {
                return reject(err);
            }
            resolve();
        });
    });
}

// Function to append data to a file asynchronously


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
function appendFileAsync(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.appendFile(filePath, data, 'utf8', (err) => {
            if (err) {
                return reject(err);
            }
            resolve();
        });
    });
}

SUFFIX CODE:
----------------------------------------
writeFileAsync(filePath, data).then(() => console.log('File written successfully')).catch(console.error);

// Example usage
const filePath = path.join(__dirname, 'example.txt');
const data = 'Hello, World!';

readFileAsync(filePath)
    .then(content => {
        console.log('File content:', content);
        return writeFileAsync(filePath, data);
    })
    .then(() => {
        console.log('Data appended successfully');
    })
    .catch(err => {
        console.error('Error:', err);
    });

JUSTIFICATION:
----------------------------------------
This is a good test case because it tests the LLM's ability to recognize and complete a pattern of asynchronous file operations using Promises. The prefix provides two functions that follow a clear pattern: they both perform file operations asynchronously and return Promises. The golden completion requires the LLM to create a new function that follows the same pattern, ensuring consistency and correctness. The suffix continues the usage of these functions, providing context for how they are used together in a real-world scenario. This pattern is common in Node.js applications, making it a practical and relevant example for testing pattern recognition.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

(async () => {
    const filePath = path.join(__dirname, 'test_file.txt');
    const initialContent = 'Initial Content';
    const appendedContent = ' Appended Content';

    // Write initial content to the file
    await writeFileAsync(filePath, initialContent);

    // Append new content to the file
    await appendFileAsync(filePath, appendedContent);

    // Read the file content and assert the content
    const finalContent = await readFileAsync(filePath);
    assert.strictEqual(finalContent, initialContent + appendedContent);

    // Cleanup
    fs.unlinkSync(filePath);
})();
================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

async function fetchData(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Fetch error:', error);
        throw error;
    }
}

async function getUserData(userId) {
    const url = `https://api.example.com/users/${userId}`;
    try {
        const data = await fetchData(url);
        return data;
    } catch (error) {
        console.error('Error getting user data:', error);
        throw error;
    }
}

async function getPostsData(userId) {
    const url = `https://api.example.com/users/${userId}/posts`;
    try {
        const data = await fetchData(url);
        return data;
    } catch (error) {
        console.error('Error getting posts data:', error);
        throw error;
    }
}

// Function to get comments data

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
async function getCommentsData(userId) {
    const url = `https://api.example.com/users/${userId}/comments`;
    try {
        const data = await fetchData(url);
        return data;
    } catch (error) {
        console.error('Error getting comments data:', error);
        throw error;
    }
}

SUFFIX CODE:
----------------------------------------


// Test the functions
(async () => {
    try {
        const userData = await getUserData(1);
        console.log('User Data:', userData);

        const postsData = await getPostsData(1);
        console.log('Posts Data:', postsData);

        const commentsData = await getCommentsData(1);
        console.log('Comments Data:', commentsData);
    } catch (error) {
        console.error('Error during testing:', error);
    }
})();

JUSTIFICATION:
----------------------------------------
This test case is designed to verify the LLM's ability to recognize and continue a pattern of async function definitions that handle network requests and error handling. The pattern is established with several similar functions (`fetchData`, `getUserData`, `getPostsData`) that follow a clear structure: defining a URL, calling `fetchData`, and handling errors. The completion must follow this pattern to maintain consistency and functionality.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

(async () => {
    const mockFetch = async (url) => {
        if (url.includes('comments')) {
            return { ok: true, json: async () => ({ commentId: 1, body: 'This is a comment' }) };
        }
        throw new Error('Unknown URL');
    };

    const originalFetch = global.fetch;
    global.fetch = mockFetch;

    try {
        const userData = await getUserData(1);
        assert.strictEqual(userData.userId, 1, 'User data should contain the correct userId');

        const postsData = await getPostsData(1);
        assert(Array.isArray(postsData), 'Posts data should be an array');

        const commentsData = await getCommentsData(1);
        assert.strictEqual(commentsData.commentId, 1, 'Comments data should contain the correct commentId');
        assert.strictEqual(commentsData.body, 'This is a comment', 'Comments data should contain the correct body');
    } catch (error) {
        assert.fail(`Error during assertions: ${error.message}`);
    } finally {
        global.fetch = originalFetch;
    }
})();
================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

// Utility function to read a file asynchronously
function readFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) return reject(err);
            resolve(data);
        });
    });
}

// Utility function to write a file asynchronously
function writeFileAsync(filePath, content) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, content, 'utf8', (err) => {
            if (err) return reject(err);
            resolve();
        });
    });
}

// Utility function to delete a file asynchronously
function deleteFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.unlink(filePath, (err) => {
            if (err) return reject(err);
            resolve();
        });
    });
}

// Usage example
async function processFiles() {
    try {
        const inputPath = path.join(__dirname, 'input.txt');
        const outputPath = path.join(__dirname, 'output.txt');
        const backupPath = path.join(__dirname, 'backup.txt');

        // Step 1: Read input file
        const inputData = await readFileAsync(inputPath);

        // Step 2: Write data to output file
        await writeFileAsync(outputPath, inputData);

        // Step 3: Create a backup of the output file
        await writeFileAsync(backupPath, inputData);

        // Step 4: Delete the output file
        

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        await deleteFileAsync(outputPath);

SUFFIX CODE:
----------------------------------------
        // Step 5: Log success message
        console.log('Process completed successfully.');
    } catch (error) {
        console.error('Error during file processing:', error);
    }
}

processFiles();


JUSTIFICATION:
----------------------------------------
This test case establishes a pattern of async file operations using Promises and the fs module in Node.js. The pattern includes reading, writing, and deleting files asynchronously, each wrapped in a Promise. The golden completion must continue this pattern by performing an asynchronous file deletion, which logically follows the previous steps. The assertions will verify that the functions behave as expected and maintain the established pattern.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const mock = require('mock-fs');

// Mock filesystem
mock({
  'input.txt': 'Hello, world!',
  'output.txt': '',
  'backup.txt': ''
});

(async () => {
    await processFiles();

    // Verify output file is deleted
    try {
        fs.accessSync('output.txt');
        assert.fail('output.txt should be deleted');
    } catch (err) {
        assert.strictEqual(err.code, 'ENOENT', 'output.txt should not exist');
    }

    // Verify backup file exists with correct content
    const backupContent = fs.readFileSync('backup.txt', 'utf8');
    assert.strictEqual(backupContent, 'Hello, world!', 'backup.txt should contain the original content');

    mock.restore();
})();
================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { createWriteStream } = require('fs');
const { pipeline } = require('stream');
const { promisify } = require('util');
const fetch = require('node-fetch');
const pipelineAsync = promisify(pipeline);

// Function to download an image from a URL
async function downloadImage(url, outputPath) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        await pipelineAsync(
            response.body,
            createWriteStream(outputPath)
        );
    } catch (error) {
        console.error('Failed to download image:', error);
    }
}

// Function to download a video from a URL
async function downloadVideo(url, outputPath) {
    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        await pipelineAsync(
            response.body,
            createWriteStream(outputPath)
        );
    } catch (error) {
        console.error('Failed to download video:', error);
    }
}

// Function to download an audio file from a URL
async function downloadAudio(url, outputPath) {
    try {


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        await pipelineAsync(
            response.body,
            createWriteStream(outputPath)
        );

SUFFIX CODE:
----------------------------------------
    } catch (error) {
        console.error('Failed to download audio:', error);
    }
}

(async () => {
    await downloadImage('https://example.com/image.jpg', 'image.jpg');
    await downloadVideo('https://example.com/video.mp4', 'video.mp4');
    await downloadAudio('https://example.com/audio.mp3', 'audio.mp3');
})();


JUSTIFICATION:
----------------------------------------
This test case establishes a pattern of downloading media files (image, video, audio) from URLs using the fetch API and the stream pipeline in an asynchronous manner. The functions downloadImage and downloadVideo follow a clear pattern of error handling and pipeline usage. The golden completion for downloadAudio must follow this same pattern to ensure consistency. This tests the LLM's ability to recognize and continue the established pattern, ensuring it understands the async/await pattern, error handling, and stream pipeline usage.

ASSERTIONS:
----------------------------------------
const fs = require('fs');
const assert = require('assert');

(async () => {
    await downloadImage('https://example.com/image.jpg', 'image.jpg');
    await downloadVideo('https://example.com/video.mp4', 'video.mp4');
    await downloadAudio('https://example.com/audio.mp3', 'audio.mp3');

    assert(fs.existsSync('image.jpg'), 'Image file should exist');
    assert(fs.existsSync('video.mp4'), 'Video file should exist');
    assert(fs.existsSync('audio.mp3'), 'Audio file should exist');

    // Clean up
    fs.unlinkSync('image.jpg');
    fs.unlinkSync('video.mp4');
    fs.unlinkSync('audio.mp3');
})();

================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

// Async function to read a file
async function readFileAsync(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (err, data) => {
      if (err) reject(err);
      resolve(data);
    });
  });
}

// Async function to write to a file
async function writeFileAsync(filePath, data) {
  return new Promise((resolve, reject) => {
    fs.writeFile(filePath, data, 'utf8', (err) => {
      if (err) reject(err);
      resolve();
    });
  });
}

// Async function to append data to a file
async function appendFileAsync(filePath, data) {
  return new Promise((resolve, reject) => {
    fs.appendFile(filePath, data, 'utf8', (err) => {
      if (err) reject(err);
      resolve();
    });
  });
}

// Example usage
(async () => {
  const filePath = path.join(__dirname, 'example.txt');
  try {
    // Read existing content
    const content = await readFileAsync(filePath);
    console.log('File content:', content);

    // Append new content
    await appendFileAsync(filePath, '\nNew line of text');

    // Read updated content
    const updatedContent = await readFileAsync(filePath);
    console.log('Updated content:', updatedContent);



LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
    // Delete the file
    await new Promise((resolve, reject) => {
      fs.unlink(filePath, (err) => {
        if (err) reject(err);
        resolve();
      });
    });
  } catch (error) {
    console.error('Error:', error);
  }
})();


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of asynchronous file operations using Promises in Node.js. The pattern is established with three async functions for reading, writing, and appending to files, each using the same structure with Promises. The golden completion involves a logical continuation of this pattern to write new content to a file and then read it back, which aligns with the established pattern. The suffix continues with deleting the file, thus ensuring resource cleanup.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const fs = require('fs');
const path = require('path');
(async () => {
  const filePath = path.join(__dirname, 'example.txt');
  const initialContent = 'Initial content';
  await writeFileAsync(filePath, initialContent);
  const content = await readFileAsync(filePath);
  assert.strictEqual(content, initialContent, 'Initial content should match');
  await appendFileAsync(filePath, '\nNew line of text');
  const updatedContent = await readFileAsync(filePath);
  assert.strictEqual(updatedContent, initialContent + '\nNew line of text', 'Updated content should include appended text');
  await writeFileAsync(filePath, 'This is new content');
  const newContent = await readFileAsync(filePath);
  assert.strictEqual(newContent, 'This is new content', 'New content should match written content');
  await new Promise((resolve, reject) => {
    fs.unlink(filePath, (err) => {
      if (err) reject(err);
      resolve();
    });
  });
  console.log('All assertions passed');
})();
================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

// Function to process files in a directory asynchronously
async function processFiles(directory) {
    const files = await fs.promises.readdir(directory);

    // Process each file in the directory
    const results = await Promise.all(files.map(async (file) => {
        const filePath = path.join(directory, file);
        const stats = await fs.promises.stat(filePath);
        if (stats.isFile()) {
            const content = await fs.promises.readFile(filePath, 'utf-8');
            return { file, content };
        }
        return null;
    }));

    return results.filter(result => result !== null);
}

// Function to log file details
async function logFileDetails(directory) {
    try {
        const files = await processFiles(directory);
        files.forEach(file => {
            console.log(`File: ${file.file}`);
            console.log(`Content: ${file.content}`);
        });
    } catch (error) {
        console.error('Error processing files:', error);
    }
}

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
module.exports = { processFiles, logFileDetails };

SUFFIX CODE:
----------------------------------------


// Example usage and assertions
(async () => {
    const testDirectory = './testDir';
    await fs.promises.mkdir(testDirectory, { recursive: true });
    await fs.promises.writeFile(path.join(testDirectory, 'test1.txt'), 'Hello World');
    await fs.promises.writeFile(path.join(testDirectory, 'test2.txt'), 'Test Content');

    await logFileDetails(testDirectory);

    const files = await processFiles(testDirectory);
    console.assert(files.length === 2, 'Should find 2 files');
    console.assert(files[0].file === 'test1.txt', 'First file should be test1.txt');
    console.assert(files[0].content === 'Hello World', 'Content of first file should be Hello World');
    console.assert(files[1].file === 'test2.txt', 'Second file should be test2.txt');
    console.assert(files[1].content === 'Test Content', 'Content of second file should be Test Content');

    // Cleanup
    await fs.promises.unlink(path.join(testDirectory, 'test1.txt'));
    await fs.promises.unlink(path.join(testDirectory, 'test2.txt'));
    await fs.promises.rmdir(testDirectory);
})();

JUSTIFICATION:
----------------------------------------
This test case is a good example of async patterns in the context of tool automation. The prefix establishes a clear pattern of asynchronous file operations using Promises and async/await syntax. The golden completion should follow this established pattern by implementing a function that deletes files asynchronously. Assertions verify the correct processing and deletion of files, ensuring the pattern is followed correctly.

ASSERTIONS:
----------------------------------------
console.assert(typeof deleteFiles === 'function', 'deleteFiles should be a function');
(async () => {
    const testDirectory = './testDir';
    await deleteFiles(testDirectory);
    const filesAfterDeletion = await processFiles(testDirectory);
    console.assert(filesAfterDeletion.length === 0, 'All files should be deleted');
})();
================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

// Higher-order function to read and process files
const processFile = (filePath, processor) => {
    fs.readFile(filePath, 'utf8', (err, data) => {
        if (err) {
            console.error('Error reading file:', err);
            return;
        }
        try {
            const result = processor(data);
            console.log('Processing result:', result);
        } catch (processingError) {
            console.error('Error processing file:', processingError);
        }
    });
};

// Example processor function to count words
const wordCountProcessor = (text) => {
    return text.split(/\s+/).length;
};

// Example processor function to count lines
const lineCountProcessor = (text) => {
    return text.split('\n').length;
};

// Processing files with different processors
processFile(path.join(__dirname, 'example1.txt'), wordCountProcessor);
processFile(path.join(__dirname, 'example2.txt'), lineCountProcessor);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
processFile(path.join(__dirname, 'example3.txt'), (text) => text.length);

SUFFIX CODE:
----------------------------------------

// Clean up resources if necessary
console.log('File processing completed.');


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and continue the pattern of using a higher-order function to process files with different processor functions. The prefix establishes a clear pattern with multiple examples of `processFile` being called with different file paths and processors. The golden completion continues this pattern with a new file and an existing processor, demonstrating the correct application of the higher-order function concept. The suffix provides a logical continuation without repeating the golden completion.

ASSERTIONS:
----------------------------------------
const mockFs = require('mock-fs');
mockFs({
  'example1.txt': 'Hello world',
  'example2.txt': 'Line one\nLine two',
  'example3.txt': 'Another example text'
});

const assert = require('assert');
let consoleOutput = [];
const originalConsoleLog = console.log;
console.log = (msg) => consoleOutput.push(msg);

// Re-run the prefix code with the golden completion inserted
processFile(path.join(__dirname, 'example1.txt'), wordCountProcessor);
processFile(path.join(__dirname, 'example2.txt'), lineCountProcessor);
processFile(path.join(__dirname, 'example3.txt'), wordCountProcessor);

setTimeout(() => {
  try {
    assert(consoleOutput.includes('Processing result: 2'));
    assert(consoleOutput.includes('Processing result: 2'));
    assert(consoleOutput.includes('Processing result: 3'));
    console.log('All assertions passed.');
  } finally {
    console.log = originalConsoleLog;
    mockFs.restore();
  }
}, 100);

================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

function processFile(filePath, callback) {
  fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      callback(err);
      return;
    }
    const processedData = data.toUpperCase();
    callback(null, processedData);
  });
}

function validateFile(filePath, callback) {
  fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      callback(err);
      return;
    }
    const isValid = data.includes('VALID');
    callback(null, isValid);
  });
}

function analyzeFile(filePath, callback) {
  fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      callback(err);
      return;
    }
    const wordCount = data.split(' ').length;
    callback(null, wordCount);
  });
}

// New function to be completed

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
function summarizeFile(filePath, callback) {
  fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      callback(err);
      return;
    }
    const summary = {
      length: data.length,
      lines: data.split('\n').length,
      words: data.split(/\s+/).filter(Boolean).length,
    };
    callback(null, summary);
  });
}

SUFFIX CODE:
----------------------------------------

// Test cases
const filePath = 'test.txt';
fs.writeFileSync(filePath, 'This is a VALID test file with some content.');

processFile(filePath, (err, data) => {
  if (err) throw err;
  console.log('Processed Data:', data);
  assert.strictEqual(data, 'THIS IS A VALID TEST FILE WITH SOME CONTENT.');
});

validateFile(filePath, (err, isValid) => {
  if (err) throw err;
  console.log('Is Valid:', isValid);
  assert.strictEqual(isValid, true);
});

analyzeFile(filePath, (err, wordCount) => {
  if (err) throw err;
  console.log('Word Count:', wordCount);
  assert.strictEqual(wordCount, 8);
});

// Cleanup
fs.unlinkSync(filePath);

JUSTIFICATION:
----------------------------------------
This example tests the model's ability to recognize and continue a pattern of asynchronous file processing functions using the Node.js `fs` module. The prefix establishes a clear pattern with three functions (`processFile`, `validateFile`, and `analyzeFile`) that follow a similar structure: reading a file asynchronously, handling errors, processing the file content, and calling the callback with the result. The golden completion `summarizeFile` must adhere to this pattern by implementing similar logic for summarizing the file content.

ASSERTIONS:
----------------------------------------
const filePath = 'test.txt';
fs.writeFileSync(filePath, 'This is a VALID test file with some content.');

summarizeFile(filePath, (err, summary) => {
  if (err) throw err;
  console.log('Summary:', summary);
  assert.strictEqual(summary, 'This is a VALID test...');
});
fs.unlinkSync(filePath);
================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

function encrypt(text, key) {
    const cipher = crypto.createCipher('aes-256-cbc', key);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
}

function decrypt(encryptedText, key) {
    const decipher = crypto.createDecipher('aes-256-cbc', key);
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

function hash(text) {
    return crypto.createHash('sha256').update(text).digest('hex');
}

function verifyHash(text, hashValue) {
    return hash(text) === hashValue;
}

// Usage example
const key = 'mysecretkey';
const text = 'Hello, World!';
const encryptedText = encrypt(text, key);
const decryptedText = decrypt(encryptedText, key);
const hashedText = hash(text);
const isVerified = verifyHash(text, hashedText);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log('Encrypted Text:', encryptedText);

SUFFIX CODE:
----------------------------------------
console.log('Decrypted Text:', decryptedText);
console.log('Hashed Text:', hashedText);
console.log('Verification:', isVerified);


JUSTIFICATION:
----------------------------------------
This example tests the ability to recognize and continue a pattern involving cryptographic functions in JavaScript. The prefix establishes a clear pattern with functions for encryption, decryption, and hashing, followed by a usage example. The golden completion requires the LLM to continue this pattern by logging the encrypted text, a logical step in the sequence. This scenario is practical for developers working with security-related code.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
assert.strictEqual(decryptedText, text, 'Decryption failed');
assert.strictEqual(hash(text), hashedText, 'Hashing failed');
assert.strictEqual(isVerified, true, 'Hash verification failed');

================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

function logMetrics(metricName, value) {
    const timestamp = new Date().toISOString();
    const logEntry = `${timestamp} - ${metricName}: ${value}\n`;
    fs.appendFile('metrics.log', logEntry, (err) => {
        if (err) {
            console.error('Failed to log metric:', err);
        }
    });
}

function processMetrics(metrics) {
    metrics.forEach(metric => {
        logMetrics(metric.name, metric.value);
    });
}

// Example usage
const exampleMetrics = [
    { name: 'CPU_Usage', value: 75 },
    { name: 'Memory_Usage', value: 60 },
    { name: 'Disk_Usage', value: 85 }
];

processMetrics(exampleMetrics);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
module.exports = { logMetrics, processMetrics };

SUFFIX CODE:
----------------------------------------

// Further processing can go here
console.log('Metrics processing complete.');

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the ability of an LLM to recognize and continue a pattern of logging information to a file. The prefix establishes a pattern for logging metrics with timestamps to a 'metrics.log' file. The golden completion requires the LLM to follow this pattern to log errors to an 'error.log' file. This tests the LLM's ability to identify and replicate a pattern in a different context (error handling) while maintaining consistency in the logging mechanism.

ASSERTIONS:
----------------------------------------
const fs = require('fs');
const assert = require('assert');

// Mocking fs.appendFile to avoid actual file IO
fs.appendFile = (path, data, callback) => { callback(null); };

let errorLogged = false;
console.error = (message) => { errorLogged = true; };

function logError(errorMessage) {
    const timestamp = new Date().toISOString();
    const logEntry = `${timestamp} - ERROR: ${errorMessage}\n`;
    fs.appendFile('error.log', logEntry, (err) => {
        if (err) {
            console.error('Failed to log error:', err);
        }
    });
}

try {
    // Simulate an error
    throw new Error('Something went wrong');
} catch (error) {
    logError(error.message);
}

assert.strictEqual(errorLogged, false, 'Error should be logged without console error');

================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

// Function to hash a password using a specific algorithm
function hashPassword(password) {
    return crypto.createHash('sha256').update(password).digest('hex');
}

// Function to verify a password against a hash
function verifyPassword(password, hash) {
    return hashPassword(password) === hash;
}

// Example usage of the functions
const password = 'securepassword123';
const hash = hashPassword(password);

// Higher-order function for authentication
function authenticateUser(getPasswordHash, userPassword) {
    const storedHash = getPasswordHash();
    return verifyPassword(userPassword, storedHash);
}

// Mock function to get stored password hash
function mockGetPasswordHash() {
    return hash;
}

const userPassword = 'securepassword123';


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log('User authenticated:', authenticateUser(mockGetPasswordHash, userPassword));

SUFFIX CODE:
----------------------------------------
console.log('User authenticated:', authenticateUser(() => hash, userPassword));

// Assertions
const assert = require('assert');
assert.strictEqual(authenticateUser(mockGetPasswordHash, userPassword), true, 'The user should be authenticated successfully');
assert.strictEqual(authenticateUser(mockGetPasswordHash, 'wrongpassword'), false, 'The user should not be authenticated with a wrong password');

// Cleanup (if any)
// No resources to clean up in this example


JUSTIFICATION:
----------------------------------------
This example demonstrates the use of higher-order functions in the context of security, specifically password hashing and authentication. The pattern of using higher-order functions for authentication is established in the prefix, and the golden completion follows this pattern by correctly using the mockGetPasswordHash function for authentication. The suffix continues the pattern with assertions to verify the functionality. This tests the LLM's ability to recognize and continue the established pattern of higher-order functions in a security context.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
assert.strictEqual(authenticateUser(mockGetPasswordHash, userPassword), true, 'The user should be authenticated successfully');
assert.strictEqual(authenticateUser(mockGetPasswordHash, 'wrongpassword'), false, 'The user should not be authenticated with a wrong password');
================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

// Utility function to hash a string using SHA-256
function hashStringSHA256(input) {
    return crypto.createHash('sha256').update(input).digest('hex');
}

// Utility function to hash a string using SHA-1
function hashStringSHA1(input) {
    return crypto.createHash('sha1').update(input).digest('hex');
}

// Utility function to hash a string using MD5
function hashStringMD5(input) {
    return crypto.createHash('md5').update(input).digest('hex');
}

// Example usage of the utility functions
const testStrings = ['hello', 'world', 'test'];
const sha256Hashes = testStrings.map(hashStringSHA256);
const sha1Hashes = testStrings.map(hashStringSHA1);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const md5Hashes = testStrings.map(hashStringMD5);

SUFFIX CODE:
----------------------------------------
const sha512Hashes = testStrings.map(input => crypto.createHash('sha512').update(input).digest('hex'));

// Assertions
const assert = require('assert');
assert.strictEqual(hashStringSHA256('hello'), sha256Hashes[0]);
assert.strictEqual(hashStringSHA1('world'), sha1Hashes[1]);
assert.strictEqual(sha512Hashes.length, testStrings.length);

console.log('All tests passed.');

JUSTIFICATION:
----------------------------------------
This test case is a good example for pattern matching as it establishes a clear pattern of hashing strings using different algorithms (SHA-256, SHA-1, MD5). The prefix contains multiple examples of this pattern, ensuring it is recognizable. The completion must follow this pattern, demonstrating understanding and continuation of the established pattern. The suffix introduces a new hashing algorithm (SHA-512) to show diversity while maintaining the overall structure, ensuring the model's ability to generalize the pattern. Assertions validate that the pattern is followed and the functionality is correct.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
assert.strictEqual(hashStringSHA256('hello'), sha256Hashes[0]);
assert.strictEqual(hashStringSHA1('world'), sha1Hashes[1]);
assert.strictEqual(md5Hashes.length, testStrings.length);
assert.strictEqual(md5Hashes[0], hashStringMD5('hello'));
assert.strictEqual(md5Hashes[1], hashStringMD5('world'));
assert.strictEqual(md5Hashes[2], hashStringMD5('test'));
console.log('All tests passed.');
================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

// Example pattern: Encrypting text with a key
function encrypt(text, key) {
    const cipher = crypto.createCipher('aes-256-cbc', key);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
}

// Example pattern: Decrypting text with a key
function decrypt(encrypted, key) {
    const decipher = crypto.createDecipher('aes-256-cbc', key);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

// Function to hash a text with a salt
function hash(text, salt) {
    const hash = crypto.createHmac('sha256', salt);
    hash.update(text);
    return hash.digest('hex');
}

// Function to verify if the text matches the hash


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
function verifyHash(text, salt, hashed) {
    const hash = crypto.createHmac('sha256', salt);
    hash.update(text);
    const digest = hash.digest('hex');
    return digest === hashed;
}

SUFFIX CODE:
----------------------------------------


// Test cases
const key = 'mysecretkey';
const text = 'Hello, World!';
const salt = 'randomsalt';
const encryptedText = encrypt(text, key);
const decryptedText = decrypt(encryptedText, key);
const hashedText = hash(text, salt);
const isHashVerified = verifyHash(text, salt, hashedText);

console.assert(encryptedText !== text, 'Encryption failed.');
console.assert(decryptedText === text, 'Decryption failed.');
console.assert(hashedText.length === 64, 'Hashing failed.');
console.assert(isHashVerified, 'Hash verification failed.');


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern related to cryptographic operations. The prefix establishes clear patterns for encryption, decryption, and hashing functions. The completion requires the LLM to follow the same pattern for verifying a hash, which involves creating a HMAC, updating it with the text, and comparing the result to the provided hash value. The suffix continues this pattern but in a different function (testing and asserting the encryption, decryption, and hashing). The provided assertions verify that the encryption, decryption, hashing, and hash verification work correctly, ensuring pattern adherence and functional correctness.

ASSERTIONS:
----------------------------------------
const key = 'mysecretkey';
const text = 'Hello, World!';
const salt = 'randomsalt';
const encryptedText = encrypt(text, key);
const decryptedText = decrypt(encryptedText, key);
const hashedText = hash(text, salt);
const isHashVerified = verifyHash(text, salt, hashedText);

console.assert(encryptedText !== text, 'Encryption failed.');
console.assert(decryptedText === text, 'Decryption failed.');
console.assert(hashedText.length === 64, 'Hashing failed.');
console.assert(isHashVerified, 'Hash verification failed.');

================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { createHash } = require('crypto');

function hashPassword(password) {
    return createHash('sha256').update(password).digest('hex');
}

function authenticateUser(username, password, users) {
    const hashedPassword = hashPassword(password);
    for (const user of users) {
        if (user.username === username && user.password === hashedPassword) {
            return true;
        }
    }
    return false;
}

const users = [
    { username: 'alice', password: hashPassword('password123') },
    { username: 'bob', password: hashPassword('qwerty') }
];

// Function to log authentication attempts
function logAuthenticationAttempt(username, success) {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] Authentication attempt for user: ${username} - ${success ? 'SUCCESS' : 'FAILURE'}`);
}

// Function to handle user login
function loginUser(username, password) {
    const isAuthenticated = authenticateUser(username, password, users);
    logAuthenticationAttempt(username, isAuthenticated);
    if (isAuthenticated) {
        return 'Login successful';
    } else {
        return 'Invalid username or password';
    }
}



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const result1 = loginUser('alice', 'password123');
console.log(result1); // Expected output: Login successful

SUFFIX CODE:
----------------------------------------


const result2 = loginUser('alice', 'wrongpassword');
console.log(result2); // Expected output: Invalid username or password

// Cleanup resources (if any)


JUSTIFICATION:
----------------------------------------
This test case establishes a clear pattern of handling user authentication including password hashing, user validation, and logging of authentication attempts. The pattern requires functions to work together to ensure security, correct logging, and proper user feedback. The completion must follow this established pattern by correctly invoking the loginUser function and validating the output against expected results. The assertions verify that the pattern is adhered to and the functionality is correct.

ASSERTIONS:
----------------------------------------
const { strict: assert } = require('assert');

const result = loginUser('alice', 'password123');
assert.strictEqual(result, 'Login successful', 'Expected login to be successful for correct password');

const result2 = loginUser('alice', 'wrongpassword');
assert.strictEqual(result2, 'Invalid username or password', 'Expected login to fail for incorrect password');

================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

function encryptText(plainText, key) {
  const cipher = crypto.createCipher('aes-256-cbc', key);
  let encrypted = cipher.update(plainText, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}

function decryptText(encryptedText, key) {
  const decipher = crypto.createDecipher('aes-256-cbc', key);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

function hashPassword(password) {
  return crypto.createHash('sha256').update(password).digest('hex');
}

function verifyPassword(password, hash) {
  return hashPassword(password) === hash;
}

// Example usage
const key = 'mysecretkey';
const plainText = 'This is a secret message';
const password = 'mypassword';
const hashedPassword = hashPassword(password);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const encryptedText = encryptText(plainText, key);

SUFFIX CODE:
----------------------------------------
console.log('Encrypted Text:', encryptedText);
const decryptedText = decryptText(encryptedText, key);
console.log('Decrypted Text:', decryptedText);

// Verify the password
const isPasswordCorrect = verifyPassword(password, hashedPassword);
console.log('Is password correct:', isPasswordCorrect);

// Cleanup (none required in this simple example)


JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching as it involves functional programming with cryptographic functions for encryption and hashing, which are common in security contexts. The established pattern involves creating functions for encryption, decryption, hashing, and verification. The golden completion continues this pattern by encrypting a plaintext message, a logical next step given the context. This ensures the LLM understands the sequence and usage of these functions, adhering to the pattern established in the prefix.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const key = 'mysecretkey';
const plainText = 'This is a secret message';
const encryptedText = encryptText(plainText, key);
const decryptedText = decryptText(encryptedText, key);
const password = 'mypassword';
const hashedPassword = hashPassword(password);
const isPasswordCorrect = verifyPassword(password, hashedPassword);

assert.strictEqual(encryptedText.length > 0, true, 'Encrypted text should not be empty');
assert.strictEqual(decryptedText, plainText, 'Decrypted text should match the original plaintext');
assert.strictEqual(isPasswordCorrect, true, 'Password verification should be correct');
console.log('All assertions passed');

================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const crypto = require('crypto');

function encrypt(text, key) {
    const cipher = crypto.createCipher('aes-256-cbc', key);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
}

function decrypt(encrypted, key) {
    const decipher = crypto.createDecipher('aes-256-cbc', key);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

function hash(text) {
    return crypto.createHash('sha256').update(text).digest('hex');
}

function verifyHash(text, hash) {
    const textHash = crypto.createHash('sha256').update(text).digest('hex');
    return textHash === hash;
}

const key = 'my_secret_key';
const text = 'Hello, World!';
const encrypted = encrypt(text, key);
const decrypted = decrypt(encrypted, key);
const textHash = hash(text);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log('Encrypted:', encrypted);
console.log('Decrypted:', decrypted);
console.log('Hash:', textHash);

SUFFIX CODE:
----------------------------------------
const invalidKey = 'invalid_key';
const invalidDecrypted = decrypt(encrypted, invalidKey);

console.assert(decrypted === text, 'Decryption failed with correct key');
console.assert(invalidDecrypted !== text, 'Decryption should fail with incorrect key');
console.assert(verifyHash(text, textHash), 'Hash verification failed');
console.assert(!verifyHash('Different text', textHash), 'Hash verification should fail for different text');

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This is a good test case because it establishes a clear pattern of cryptographic operations (encryption, decryption, hashing, and verification) and requires the model to continue the pattern with a verification function. The prefix sets up multiple cryptographic functions and their usage, and the golden completion follows the same pattern by verifying the hash, which is a common practice in security-related code. The assertions then test the correctness and adherence to the pattern by ensuring the encryption, decryption, and hashing functions work as expected.

ASSERTIONS:
----------------------------------------
console.assert(decrypted === text, 'Decryption failed with correct key');
console.assert(invalidDecrypted !== text, 'Decryption should fail with incorrect key');
console.assert(verifyHash(text, textHash), 'Hash verification failed');
console.assert(!verifyHash('Different text', textHash), 'Hash verification should fail for different text');
================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

// Higher-order function to log the time taken by an async function
function logExecutionTime(asyncFunc) {
    return async function(...args) {
        const start = Date.now();
        try {
            const result = await asyncFunc(...args);
            const end = Date.now();
            console.log(`Execution time: ${end - start}ms`);
            return result;
        } catch (error) {
            console.error('Error:', error);
            throw error;
        }
    };
}

// Sample async functions representing tool automation tasks
const readFileAsync = logExecutionTime(async function(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) reject(err);
            else resolve(data);
        });
    });
});

const writeFileAsync = logExecutionTime(async function(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, data, 'utf8', (err) => {
            if (err) reject(err);
            else resolve();
        });
    });
});



LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------

(async () => {
    const testFilePath = 'test.txt';
    try {
        await writeFileAsync(testFilePath, 'Hello, world!');
        const data = await readFileAsync(testFilePath);
        console.log('File contents:', data);
        // Cleanup
        fs.unlinkSync(testFilePath);
    } catch (error) {
        console.error('Caught error:', error);
    }
})();

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and extend a higher-order function pattern in the context of tool automation. The prefix establishes the pattern with two higher-order functions that log the execution time of asynchronous file operations. The golden completion requires the LLM to maintain this pattern by creating a similar higher-order function for deleting a file. This scenario is practical and tests the model's understanding of both higher-order functions and async patterns in JavaScript.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
    const testFilePath = 'test.txt';
    try {
        await writeFileAsync(testFilePath, 'Hello, world!');
        const data = await readFileAsync(testFilePath);
        assert.strictEqual(data, 'Hello, world!');
        await deleteFileAsync(testFilePath);
        assert.throws(() => fs.readFileSync(testFilePath), /no such file or directory/);
    } catch (error) {
        console.error('Caught error during assertions:', error);
    }
})();
================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const metrics = [];

function recordMetric(name, value) {
    metrics.push({ name, value, timestamp: new Date() });
}

function calculateAverage(metricName) {
    const filteredMetrics = metrics.filter(metric => metric.name === metricName);
    const sum = filteredMetrics.reduce((acc, metric) => acc + metric.value, 0);
    return sum / filteredMetrics.length;
}

function generateReport() {
    const report = {};
    metrics.forEach(metric => {
        if (!report[metric.name]) {
            report[metric.name] = { total: 0, count: 0 };
        }
        report[metric.name].total += metric.value;
        report[metric.name].count += 1;
    });
    return report;
}

// We need to add a new function that follows the established pattern of processing metrics



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
function getMetricCount(metricName) {
    return metrics.filter(metric => metric.name === metricName).length;
}

SUFFIX CODE:
----------------------------------------


// Tests
recordMetric('clicks', 5);
recordMetric('clicks', 10);
recordMetric('views', 100);
recordMetric('views', 150);

const avgClicks = calculateAverage('clicks');
const avgViews = calculateAverage('views');

console.assert(avgClicks === 7.5, `Expected 7.5, but got ${avgClicks}`);
console.assert(avgViews === 125, `Expected 125, but got ${avgViews}`);

const report = generateReport();
console.assert(report['clicks'].total === 15, `Expected 15, but got ${report['clicks'].total}`);
console.assert(report['clicks'].count === 2, `Expected 2, but got ${report['clicks'].count}`);
console.assert(report['views'].total === 250, `Expected 250, but got ${report['views'].total}`);
console.assert(report['views'].count === 2, `Expected 2, but got ${report['views'].count}`);

// Cleanup
metrics.length = 0;

JUSTIFICATION:
----------------------------------------
This test case is a good benchmark for pattern matching because it establishes a clear pattern of processing metrics through functions like `recordMetric`, `calculateAverage`, and `generateReport`. The new function `getMetricHistory` must follow this pattern by filtering metrics based on their name, similar to the existing functions. The assertions validate the functionality and consistency of the pattern, ensuring the LLM correctly identifies and continues the pattern.

ASSERTIONS:
----------------------------------------
const history = getMetricHistory('clicks');
console.assert(history.length === 2, `Expected 2, but got ${history.length}`);
console.assert(history[0].value === 5, `Expected 5, but got ${history[0].value}`);
console.assert(history[1].value === 10, `Expected 10, but got ${history[1].value}`);

================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

// Higher-order function to measure execution time of an async function
function measureExecutionTime(asyncFunc) {
    return async function(...args) {
        const start = Date.now();
        try {
            const result = await asyncFunc(...args);
            return result;
        } finally {
            const end = Date.now();
            console.log(`Execution time: ${end - start} ms`);
        }
    };
}

// Async function to fetch data from an API
async function fetchData(url) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error('Network response was not ok');
    }
    const data = await response.json();
    return data;
}

// Wrapped function with execution time measurement
const fetchDataWithTiming = measureExecutionTime(fetchData);

// Example usage


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/2').then(data => {
    console.log('Fetched data:', data);
}).catch(error => {
    console.error('Error fetching data:', error);
});

SUFFIX CODE:
----------------------------------------
fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/2').then(data => {
    console.log('Fetched data:', data);
}).catch(error => {
    console.error('Error fetching data:', error);
});

// Additional test case
fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/3').then(data => {
    console.log('Fetched data:', data);
}).catch(error => {
    console.error('Error fetching data:', error);
});


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of using higher-order functions to measure the execution time of async functions, specifically in the context of fetching data from an API. The pattern is clear: wrapping an async function with a timing measurement function and then using the wrapped function to fetch data from different URLs. The golden completion must follow this established pattern by correctly wrapping an async function call and handling the result.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

// Mock fetch for testing
const originalFetch = global.fetch;
global.fetch = async (url) => {
    if (url === 'https://jsonplaceholder.typicode.com/todos/1') {
        return { ok: true, json: async () => ({ id: 1, title: 'delectus aut autem' }) };
    } else if (url === 'https://jsonplaceholder.typicode.com/todos/2') {
        return { ok: true, json: async () => ({ id: 2, title: 'quis ut nam facilis et officia qui' }) };
    } else if (url === 'https://jsonplaceholder.typicode.com/todos/3') {
        return { ok: true, json: async () => ({ id: 3, title: 'fugiat veniam minus' }) };
    } else {
        return { ok: false };
    }
};

(async () => {
    try {
        const data1 = await fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/1');
        assert.deepStrictEqual(data1, { id: 1, title: 'delectus aut autem' });
        const data2 = await fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/2');
        assert.deepStrictEqual(data2, { id: 2, title: 'quis ut nam facilis et officia qui' });
        const data3 = await fetchDataWithTiming('https://jsonplaceholder.typicode.com/todos/3');
        assert.deepStrictEqual(data3, { id: 3, title: 'fugiat veniam minus' });
        console.log('All assertions passed.');
    } catch (error) {
        console.error('Assertion failed:', error);
    } finally {
        // Cleanup mock
        global.fetch = originalFetch;
    }
})();

================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const metrics = [];

function recordMetric(name, value) {
    metrics.push({ name, value, timestamp: new Date() });
}

function calculateAverage(metricName) {
    const metricValues = metrics.filter(metric => metric.name === metricName).map(metric => metric.value);
    if (metricValues.length === 0) return 0;
    const sum = metricValues.reduce((acc, val) => acc + val, 0);
    return sum / metricValues.length;
}

function calculateMax(metricName) {
    const metricValues = metrics.filter(metric => metric.name === metricName).map(metric => metric.value);
    if (metricValues.length === 0) return 0;
    return Math.max(...metricValues);
}



LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------

function calculateMin(metricName) {
    const metricValues = metrics.filter(metric => metric.name === metricName).map(metric => metric.value);
    if (metricValues.length === 0) return 0;
    return Math.min(...metricValues);
}

// Test cases
recordMetric('response_time', 200);
recordMetric('response_time', 100);
recordMetric('response_time', 300);
recordMetric('response_time', 150);

console.assert(calculateAverage('response_time') === 187.5, 'Average calculation is incorrect');
console.assert(calculateMax('response_time') === 300, 'Max calculation is incorrect');
console.assert(calculateMin('response_time') === 100, 'Min calculation is incorrect');

console.log('All assertions passed');


JUSTIFICATION:
----------------------------------------
This test case is a good benchmark for pattern matching capabilities as it involves a clear and identifiable pattern of metric calculations. The functions `calculateAverage`, `calculateMax`, and `calculateMin` all follow a similar structure: filtering metrics by name, mapping to values, checking for an empty array, and then performing a reduction operation. The `calculateSum` function must follow this established pattern to correctly complete the metric calculations. The assertions verify the correctness of all metric calculations, ensuring pattern adherence and functionality.

ASSERTIONS:
----------------------------------------
console.assert(calculateSum('response_time') === 750, 'Sum calculation is incorrect');

================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { assert } = require('chai');

// Game mechanics: A simple state machine for a game character
class Character {
    constructor() {
        this.state = 'idle';
    }

    setState(newState) {
        this.state = newState;
    }

    idle() {
        this.setState('idle');
    }

    walk() {
        this.setState('walking');
    }

    run() {
        this.setState('running');
    }

    jump() {
        this.setState('jumping');
    }

    // The pattern of state transitions should be clear here
    attack() {
        this.setState('attacking');
    }

    defend() {
        this.setState('defending');
    }

    // Need to complete the state pattern with 'die' state


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    die() {
        this.setState('dead');
    }

SUFFIX CODE:
----------------------------------------

}

const character = new Character();

character.idle();
assert.equal(character.state, 'idle');

character.walk();
assert.equal(character.state, 'walking');

character.run();
assert.equal(character.state, 'running');

character.jump();
assert.equal(character.state, 'jumping');

character.attack();
assert.equal(character.state, 'attacking');

character.defend();
assert.equal(character.state, 'defending');

character.die();
assert.equal(character.state, 'dead');

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case demonstrates a state machine pattern in a game mechanics context. The `Character` class has methods for various states (idle, walk, run, jump, attack, defend) that follow a clear pattern of setting the state. The golden completion requires adding the 'die' method, which must follow the established pattern of setting the state using `this.setState()`. This tests the LLM's ability to recognize and extend the state machine pattern correctly.

ASSERTIONS:
----------------------------------------
assert.equal(character.state, 'idle');
assert.equal(character.state, 'walking');
assert.equal(character.state, 'running');
assert.equal(character.state, 'jumping');
assert.equal(character.state, 'attacking');
assert.equal(character.state, 'defending');
assert.equal(character.state, 'dead');
================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

// Utility function to read a file asynchronously
function readFileAsync(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, 'utf8', (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Utility function to write a file asynchronously
function writeFileAsync(path, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(path, data, 'utf8', (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Function to read, modify, and write a file asynchronously
async function modifyFile(path, modifyCallback) {
    try {
        const data = await readFileAsync(path);
        const modifiedData = modifyCallback(data);
        await writeFileAsync(path, modifiedData);
    } catch (err) {
        console.error('Error modifying file:', err);
    }
}

// Example usage
modifyFile('example.txt', (data) => data.toUpperCase());


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
// Example usage with a different file and callback
modifyFile('another_example.txt', (data) => data.split('').reverse().join(''));


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and complete a pattern involving asynchronous file operations using Promises and async/await syntax. The prefix establishes a clear pattern by defining utility functions for reading and writing files asynchronously, as well as a function to modify files using a callback. The golden_completion follows this established pattern by providing another example usage of the modifyFile function with a different file and callback. This tests the LLM's understanding of the established pattern and its ability to generate code that adheres to it. The suffix provides another example usage to further verify the pattern adherence.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const mockFs = require('mock-fs');

// Mock the file system
mockFs({
    'example.txt': 'hello world',
    'test.txt': 'foo bar',
    'another_example.txt': '12345'
});

// Test the first example usage
modifyFile('example.txt', (data) => data.toUpperCase()).then(() => {
    return readFileAsync('example.txt');
}).then((data) => {
    assert.strictEqual(data, 'HELLO WORLD');

    // Test the golden completion
    return modifyFile('test.txt', (data) => data.replace(/foo/g, 'bar'));
}).then(() => {
    return readFileAsync('test.txt');
}).then((data) => {
    assert.strictEqual(data, 'bar bar');

    // Test the suffix example usage
    return modifyFile('another_example.txt', (data) => data.split('').reverse().join(''));
}).then(() => {
    return readFileAsync('another_example.txt');
}).then((data) => {
    assert.strictEqual(data, '54321');

    // Cleanup mock file system
    mockFs.restore();
}).catch((err) => {
    console.error('Test failed:', err);
    mockFs.restore();
});

================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { assert } = require('chai');

// Game mechanics: State machine for a simple game character
class Character {
  constructor(name) {
    this.name = name;
    this.state = 'idle';
  }

  setState(state) {
    this.state = state;
  }

  isIdle() {
    return this.state === 'idle';
  }

  isMoving() {
    return this.state === 'moving';
  }

  isAttacking() {
    return this.state === 'attacking';
  }

  handleInput(input) {
    switch(input) {
      case 'move':
        this.setState('moving');
        break;
      case 'attack':
        this.setState('attacking');
        break;
      case 'stop':
        this.setState('idle');
        break;
      default:
        throw new Error('Invalid input');
    }
  }
}

const character = new Character('Hero');
character.handleInput('move');
assert(character.isMoving(), 'Character should be moving');
character.handleInput('attack');
assert(character.isAttacking(), 'Character should be attacking');

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
character.handleInput('stop');
assert(character.isIdle(), 'Character should be idle');

SUFFIX CODE:
----------------------------------------


// Clean up resources
console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and complete a state machine pattern within a game mechanics context. The pattern involves handling different states (idle, moving, attacking) and transitioning between these states based on input. The golden completion demonstrates the correct handling of the 'stop' input to transition the character back to the idle state, which is critical for ensuring the state machine functions correctly. This is a realistic and practical example for game development, making it a good test case for pattern matching capabilities.

ASSERTIONS:
----------------------------------------
assert(character.isMoving(), 'Character should be moving');
assert(character.isAttacking(), 'Character should be attacking');
character.handleInput('stop');
assert(character.isIdle(), 'Character should be idle');
================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

// Utility function to log errors
function logError(error) {
    console.error('Error:', error);
}

// Function to read a file asynchronously
function readFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                logError(err);
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Function to write to a file asynchronously
function writeFileAsync(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, data, 'utf8', (err) => {
            if (err) {
                logError(err);
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Function to delete a file asynchronously
function deleteFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.unlink(filePath, (err) => {
            if (err) {
                logError(err);
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Usage example
async function exampleUsage() {
    const filePath = path.join(__dirname, 'example.txt');

    try {
        // Read the file
        const content = await readFileAsync(filePath);
        console.log('File content:', content);

        // Write to the file
        await writeFileAsync(filePath, 'New content');

        // Delete the file


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        await deleteFileAsync(filePath);

SUFFIX CODE:
----------------------------------------
        console.log('File deleted successfully');
    } catch (error) {
        logError(error);
    }
}

// Run the example usage function
exampleUsage();

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern of asynchronous file operations with proper error handling. The pattern of defining asynchronous functions using promises and handling errors using a utility function is clearly established in the prefix. The golden completion requires the LLM to follow this pattern by adding the call to the asynchronous delete function within the try block, maintaining consistency with the established pattern. The suffix continues the pattern by handling errors and logging the file deletion success message.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const mockFs = require('mock-fs');

mockFs({
    'example.txt': 'Initial content'
});

async function testExampleUsage() {
    const filePath = path.join(__dirname, 'example.txt');

    try {
        await exampleUsage();

        // Ensure file is deleted
        const fileExists = fs.existsSync(filePath);
        assert.strictEqual(fileExists, false, 'File should be deleted');
    } finally {
        mockFs.restore();
    }
}

testExampleUsage();
================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');
const path = require('path');

// Higher-order function to read a file and process its contents
function readFileAndProcess(filePath, processFn) {
    fs.readFile(filePath, 'utf8', (err, data) => {
        if (err) {
            console.error('Error reading file:', err);
            return;
        }
        processFn(data);
    });
}

// Higher-order function to write data to a file
function writeFileAndProcess(filePath, data, processFn) {
    fs.writeFile(filePath, data, (err) => {
        if (err) {
            console.error('Error writing file:', err);
            return;
        }
        processFn();
    });
}

// Example usage of higher-order functions
const inputFilePath = path.join(__dirname, 'input.txt');
const outputFilePath = path.join(__dirname, 'output.txt');

readFileAndProcess(inputFilePath, (data) => {
    const processedData = data.toUpperCase();
    writeFileAndProcess(outputFilePath, processedData, () => {
        console.log('Data has been processed and written to output file.');
    });
});

// Another example usage of higher-order functions
const anotherInputFilePath = path.join(__dirname, 'anotherInput.txt');
const anotherOutputFilePath = path.join(__dirname, 'anotherOutput.txt');

readFileAndProcess(anotherInputFilePath, (data) => {

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    const processedData = data.split('').reverse().join('').toUpperCase();
    writeFileAndProcess(anotherOutputFilePath, processedData, () => {
        console.log('Another data has been processed and written to another output file.');
    });

SUFFIX CODE:
----------------------------------------

});

// Assertions
const assert = require('assert');
fs.readFile(outputFilePath, 'utf8', (err, data) => {
    assert.strictEqual(data, 'HELLO WORLD');
    console.log('First assertion passed');
    fs.unlinkSync(outputFilePath); // Cleanup
});

fs.readFile(anotherOutputFilePath, 'utf8', (err, data) => {
    assert.strictEqual(data, 'DLROW OLLEH');
    console.log('Second assertion passed');
    fs.unlinkSync(anotherOutputFilePath); // Cleanup
});

JUSTIFICATION:
----------------------------------------
This is a good test case because it clearly establishes a pattern of using higher-order functions to read and write files, while processing the data in between. The pattern involves reading a file, processing the data (e.g., converting to uppercase, reversing), and then writing the processed data to another file. This scenario is realistic and common in tool automation tasks. The golden_completion demonstrates the continuation of this pattern by processing data (reversing it) and writing it to a file, which is consistent with the previously established pattern.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
fs.readFile(outputFilePath, 'utf8', (err, data) => {
    assert.strictEqual(data, 'HELLO WORLD');
    console.log('First assertion passed');
    fs.unlinkSync(outputFilePath); // Cleanup
});

fs.readFile(anotherOutputFilePath, 'utf8', (err, data) => {
    assert.strictEqual(data, 'DLROW OLLEH');
    console.log('Second assertion passed');
    fs.unlinkSync(anotherOutputFilePath); // Cleanup
});
================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

async function fetchData(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}

async function fetchMetrics() {
  const url = 'https://api.example.com/metrics';
  try {
    const metrics = await fetchData(url);
    // Further processing of metrics data
    

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log('Fetched metrics:', metrics);

SUFFIX CODE:
----------------------------------------
    return metrics;
  } catch (error) {
    console.error('Metrics fetch error:', error);
    throw error;
  }
}

// Example usage
fetchMetrics().then(metrics => {
  console.log('Metrics:', metrics);
}).catch(error => {
  console.error('Error:', error);
});


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and continue the pattern of async error handling in JavaScript. The prefix includes a function that fetches data from a URL with error handling, and another function that uses the first function to fetch specific metrics. The golden completion should log the fetched metrics data, following the established pattern of handling and logging data in the async functions.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
  const fetchMock = async (url) => ({ ok: true, json: async () => ({ metric1: 100, metric2: 200 }) });
  fetch = fetchMock;

  const result = await fetchMetrics();
  assert.deepStrictEqual(result, { metric1: 100, metric2: 200 }, 'Metrics data should match expected values');
  console.log('Assertions passed');
})();
================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const analytics = require('analytics-library');

// Function to log user actions
function logUserAction(action) {
    analytics.logEvent(action);
}

// Function to log page views
function logPageView(page) {
    analytics.logEvent(page);
}

// Function to log errors
function logError(error) {
    analytics.logEvent(error);
}

// New function to log user signups
function logUserSignup(user) {
    

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
analytics.logEvent(user);

SUFFIX CODE:
----------------------------------------

}

// Usage examples
logUserAction('clicked_button');
logPageView('homepage');
logError('404_not_found');
logUserSignup('JohnDoe');

// Assertions
const assert = require('assert');
const events = analytics.getLoggedEvents();
assert(events.includes('clicked_button'));
assert(events.includes('homepage'));
assert(events.includes('404_not_found'));
assert(events.includes('JohnDoe'));

// Cleanup
analytics.clearLoggedEvents();

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize a pattern of logging events using an analytics library. The prefix establishes a pattern with three functions that log different types of events using `analytics.logEvent`. The golden completion must continue this pattern by using `analytics.logEvent` to log user signups. The suffix demonstrates the usage of these functions and includes assertions to verify that the events were logged correctly.

ASSERTIONS:
----------------------------------------
assert(events.includes('clicked_button'));
assert(events.includes('homepage'));
assert(events.includes('404_not_found'));
assert(events.includes('JohnDoe'));
================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

// Function to read a file asynchronously and process its content
function readFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Function to write to a file asynchronously
function writeFileAsync(filePath, content) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, content, 'utf8', (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

async function processFile(inputPath, outputPath) {
    try {
        const data = await readFileAsync(inputPath);
        const processedData = data.toUpperCase(); // Example processing
        await writeFileAsync(outputPath, processedData);
    } catch (error) {
        console.error('Error processing file:', error);
    }
}


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
processFile('input.txt', 'output.txt');

SUFFIX CODE:
----------------------------------------
processFile('input.txt', 'output.txt');

// Cleanup resources if any
// In this example, there are no explicit resources to clean up

JUSTIFICATION:
----------------------------------------
This is a good test case because it establishes a clear pattern of async functions that perform file operations (readFileAsync, writeFileAsync) using Promises. The task is to complete the pattern by implementing another async function (deleteFileAsync) that follows the same structure. This tests the model's ability to recognize and extend the pattern of async file operations with proper error handling.

ASSERTIONS:
----------------------------------------
const assert = require('assert');

(async () => {
    const testFile = 'test.txt';
    const content = 'Hello, World!';

    // Test writeFileAsync
    await writeFileAsync(testFile, content);
    const writtenContent = await readFileAsync(testFile);
    assert.strictEqual(writtenContent, content, 'Content written and read should match');

    // Test deleteFileAsync
    await deleteFileAsync(testFile);
    try {
        await readFileAsync(testFile);
        assert.fail('File should have been deleted');
    } catch (error) {
        assert.strictEqual(error.code, 'ENOENT', 'Error code should be ENOENT for non-existent file');
    }

    console.log('All assertions passed');
})();

// No explicit resources to clean up in this example
================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

// Function to fetch and process analytics data
async function getAnalyticsData(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        return processAnalyticsData(data);
    } catch (error) {
        console.error('Failed to fetch analytics data:', error);
        throw error;
    }
}

// Helper function to process analytics data
function processAnalyticsData(data) {
    return data.map(item => ({
        metric: item.metric,
        value: item.value * 2 // Example transformation
    }));
}

// Function to fetch and process user metrics
async function getUserMetrics(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        return processUserMetrics(data);
    } catch (error) {
        console.error('Failed to fetch user metrics:', error);
        throw error;
    }
}

// Helper function to process user metrics
function processUserMetrics(data) {
    return data.map(item => ({
        user: item.user,
        score: item.score + 10 // Example transformation
    }));
}

// Function to fetch and process error logs
async function getErrorLogs(url) {
    try {


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

SUFFIX CODE:
----------------------------------------
        const data = await response.json();
        return data.map(log => ({
            timestamp: log.timestamp,
            message: log.message.toUpperCase() // Example transformation
        }));
    } catch (error) {
        console.error('Failed to fetch error logs:', error);
        throw error;
    }
}

// Example usage
(async () => {
    const analyticsDataUrl = 'https://api.example.com/analytics';
    const userMetricsUrl = 'https://api.example.com/user-metrics';
    const errorLogsUrl = 'https://api.example.com/error-logs';

    try {
        const analyticsData = await getAnalyticsData(analyticsDataUrl);
        const userMetrics = await getUserMetrics(userMetricsUrl);
        const errorLogs = await getErrorLogs(errorLogsUrl);

        console.log('Analytics Data:', analyticsData);
        console.log('User Metrics:', userMetrics);
        console.log('Error Logs:', errorLogs);
    } catch (error) {
        console.error('Error during data fetching:', error);
    }
})();


JUSTIFICATION:
----------------------------------------
This example tests the pattern matching capabilities of an LLM by establishing a clear pattern of error handling and data processing in asynchronous functions. The prefix sets up two functions that fetch and process data with error handling in place. The golden completion requires recognizing this pattern and completing the third function accordingly. Assertions verify pattern adherence and functional correctness.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
    // Mock fetch responses
    global.fetch = async (url) => ({
        ok: true,
        json: async () => [{ timestamp: '2023-01-01T00:00:00Z', message: 'Error occurred' }]
    });

    const errorLogs = await getErrorLogs('https://api.example.com/error-logs');
    assert.strictEqual(errorLogs.length, 1);
    assert.strictEqual(errorLogs[0].timestamp, '2023-01-01T00:00:00Z');
    assert.strictEqual(errorLogs[0].message, 'ERROR OCCURRED');
})();

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

// Higher-order function to create a logging function
function createLogger(logFile) {
    return function log(message) {
        const timestamp = new Date().toISOString();
        const logMessage = `${timestamp} - ${message}\n`;
        fs.appendFileSync(logFile, logMessage);
    };
}

// Create two loggers for different purposes
const errorLogger = createLogger('error.log');
const activityLogger = createLogger('activity.log');

// Log some messages
errorLogger('An error occurred');
activityLogger('User logged in');

// Higher-order function to create a metric tracking function
function createMetricTracker(metricFile) {
    return function trackMetric(metric, value) {
        const timestamp = new Date().toISOString();
        const metricMessage = `${timestamp} - ${metric}: ${value}\n`;
        fs.appendFileSync(metricFile, metricMessage);
    };
}

// Create two metric trackers for different purposes
const performanceTracker = createMetricTracker('performance.log');
const usageTracker = createMetricTracker('usage.log');

// Track some metrics
performanceTracker('CPU Usage', '75%');
usageTracker('API Calls', 120);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
usageTracker('Memory Usage', '512MB');

SUFFIX CODE:
----------------------------------------


// Perform cleanup (for demonstration purposes)
fs.unlinkSync('error.log');
fs.unlinkSync('activity.log');
fs.unlinkSync('performance.log');
fs.unlinkSync('usage.log');

JUSTIFICATION:
----------------------------------------
This test case establishes a clear pattern of higher-order functions that create specialized logging and metric tracking functions. The pattern involves creating a function that returns another function with specific behavior, demonstrated by both createLogger and createMetricTracker functions. The golden completion follows this pattern by using the performanceTracker and usageTracker functions to log additional metrics, consistent with the established pattern of tracking metrics. This scenario effectively tests the LLM's ability to recognize and continue the higher-order function pattern in a realistic context involving tool automation and logging.

ASSERTIONS:
----------------------------------------
const fs = require('fs');
const assert = require('assert');

// Ensure log files are created and contain expected entries
const errorLogContent = fs.readFileSync('error.log', 'utf8');
assert(errorLogContent.includes('An error occurred'));

const activityLogContent = fs.readFileSync('activity.log', 'utf8');
assert(activityLogContent.includes('User logged in'));

const performanceLogContent = fs.readFileSync('performance.log', 'utf8');
assert(performanceLogContent.includes('CPU Usage: 75%'));
assert(performanceLogContent.includes('Memory Usage: 60%'));

const usageLogContent = fs.readFileSync('usage.log', 'utf8');
assert(usageLogContent.includes('API Calls: 120'));
assert(usageLogContent.includes('Page Views: 300'));

// Cleanup log files
fs.unlinkSync('error.log');
fs.unlinkSync('activity.log');
fs.unlinkSync('performance.log');
fs.unlinkSync('usage.log');
================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

// Function to fetch and process data asynchronously
async function fetchData(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        return processData(data);
    } catch (error) {
        console.error('Fetch error:', error);
        throw error;
    }
}

// Function to process data
function processData(data) {
    // Process data here
    return data.map(item => item.value);
}

// Function to fetch multiple URLs asynchronously
async function fetchMultipleUrls(urls) {
    const results = [];
    for (const url of urls) {
        try {
            const result = await fetchData(url);
            results.push(result);
        } catch (error) {
            console.error('Error fetching URL:', url, error);
        }
    }
    return results;
}

// Test URLs
const urls = ['https://api.example.com/data1', 'https://api.example.com/data2'];

async function testFetchMultipleUrls() {
    try {
        const results = await fetchMultipleUrls(urls);
        console.log('Results:', results);
    } catch (error) {
        console.error('Test error:', error);
    }
}

testFetchMultipleUrls();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Function to fetch data with retries
async function fetchDataWithRetries(url, retries = 3, delay = 1000) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            const data = await response.json();
            return processData(data);
        } catch (error) {
            if (i === retries - 1) {
                throw error;
            }
            await new Promise(res => setTimeout(res, delay));
        }
    }
}

SUFFIX CODE:
----------------------------------------


// Test fetchDataWithRetries
async function testFetchDataWithRetries() {
    try {
        const result = await fetchDataWithRetries('https://api.example.com/data1');
        console.log('Fetched with retries:', result);
    } catch (error) {
        console.error('Test fetchDataWithRetries error:', error);
    }
}

testFetchDataWithRetries();


JUSTIFICATION:
----------------------------------------
This test case is a good example of testing async patterns and error handling in the context of fetching data from multiple URLs. The pattern of async/await with try/catch for error handling is clearly established in the prefix. The golden_completion must follow this established pattern and handle retries for fetching data, which is a realistic scenario. The assertions verify both the pattern adherence and functionality by checking successful data fetch and proper error handling.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
    try {
        const result = await fetchDataWithRetries('https://api.example.com/data1');
        assert(result.length > 0, 'Result should not be empty');
    } catch (error) {
        assert.fail('fetchDataWithRetries should not throw an error');
    }
})();
(async () => {
    try {
        const results = await fetchMultipleUrls(['https://api.example.com/data1', 'https://api.example.com/data2']);
        assert(results.length === 2, 'Should fetch data from both URLs');
    } catch (error) {
        assert.fail('fetchMultipleUrls should not throw an error');
    }
})();

================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fs = require('fs');

// Function to read the contents of a file asynchronously
function readFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Function to write data to a file asynchronously
function writeFileAsync(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, data, 'utf8', (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Function to append data to a file asynchronously


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
function appendFileAsync(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.appendFile(filePath, data, 'utf8', (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

SUFFIX CODE:
----------------------------------------
function deleteFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.unlink(filePath, (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Tests
(async () => {
    const filePath = 'test.txt';
    try {
        await writeFileAsync(filePath, 'Hello, World!');
        let data = await readFileAsync(filePath);
        console.assert(data === 'Hello, World!', 'Data should be "Hello, World!"');
        await appendFileAsync(filePath, ' More text.');
        data = await readFileAsync(filePath);
        console.assert(data === 'Hello, World! More text.', 'Data should be "Hello, World! More text."');
        await deleteFileAsync(filePath);
    } catch (err) {
        console.error('Test failed', err);
    }
})();

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern of asynchronous file operations using Promises. The established pattern in the prefix includes functions for reading and writing files asynchronously with error handling. The golden completion follows this pattern by implementing an asynchronous append operation. The suffix continues the pattern by defining a function for deleting files and performing assertions to test the functionality. The completion must adhere to the same conventions and structure as the other functions to be correct.

ASSERTIONS:
----------------------------------------
const filePath = 'test.txt';
(async () => {
    try {
        await writeFileAsync(filePath, 'Hello, World!');
        let data = await readFileAsync(filePath);
        console.assert(data === 'Hello, World!', 'Data should be "Hello, World!"');
        await appendFileAsync(filePath, ' More text.');
        data = await readFileAsync(filePath);
        console.assert(data === 'Hello, World! More text.', 'Data should be "Hello, World! More text."');
        await deleteFileAsync(filePath);
    } catch (err) {
        console.error('Test failed', err);
    }
})();

================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const { assert } = require('chai');

// Higher-order function to create an event handler
function createEventHandler(eventType) {
    return function handler(event) {
        console.log(`Handling ${eventType} event`);
        if (eventType === 'click') {
            // Click event specific handling
            console.log('Click event detected:', event.detail);
        } else if (eventType === 'keydown') {
            // Keydown event specific handling
            console.log('Keydown event detected:', event.key);
        }
        // Return event processed status
        return true;
    };
}

// Create and test a click event handler
const clickHandler = createEventHandler('click');
const clickEvent = { detail: 'Button clicked' };
assert.strictEqual(clickHandler(clickEvent), true);

// Create and test a keydown event handler
const keydownHandler = createEventHandler('keydown');
const keydownEvent = { key: 'Enter' };
assert.strictEqual(keydownHandler(keydownEvent), true);



LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
// Create and test a mouseover event handler
const mouseoverHandler = createEventHandler('mouseover');
const mouseoverEvent = { detail: 'Mouse over element' };
assert.strictEqual(mouseoverHandler(mouseoverEvent), true);

console.log('All tests passed.');

JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching as it involves the creation of higher-order functions to handle different types of events. The pattern established in the prefix involves creating handlers for specific event types and testing them with corresponding events. The golden completion continues this pattern by creating and testing another event handler, ensuring the LLM can recognize and continue the established pattern. Assertions check the correctness of event handling and the return values, ensuring the pattern is followed correctly.

ASSERTIONS:
----------------------------------------
assert.strictEqual(createEventHandler('keyup')({ key: 'A' }), true);
assert.strictEqual(createEventHandler('mouseover')({ detail: 'Mouse over element' }), true);
================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

// Helper function to fetch data from an API
async function fetchData(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}

// Function to process analytics data
async function processAnalytics(urls) {
  const results = [];
  for (const url of urls) {
    try {
      const data = await fetchData(url);
      results.push(data);
    } catch (error) {
      results.push({ error: error.message });
    }
  }
  return results;
}

const testUrls = [
  'https://jsonplaceholder.typicode.com/todos/1',
  'https://jsonplaceholder.typicode.com/todos/2',
  'https://jsonplaceholder.typicode.com/invalid-url'
];

// Execute the processAnalytics function
processAnalytics(testUrls)
  .then(results => {
    console.log('Results:', results);
    // Assertions
    const assert = require('assert');
    assert.strictEqual(results.length, 3);
    assert.strictEqual(results[0].id, 1);
    assert.strictEqual(results[1].id, 2);
    assert(results[2].error);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    console.log('All tests passed');

SUFFIX CODE:
----------------------------------------
  })
  .catch(error => console.error('Unexpected error:', error));


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and continue a pattern involving error handling and async patterns within the context of processing analytics data. The prefix establishes a clear pattern of handling asynchronous API calls with error handling, which the golden completion continues by asserting the correct error message for a failed API call. This helps verify that the LLM can maintain consistency in error handling practices.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const results = [
  { id: 1 },
  { id: 2 },
  { error: 'Network response was not ok' }
];
assert.strictEqual(results.length, 3);
assert.strictEqual(results[0].id, 1);
assert.strictEqual(results[1].id, 2);
assert(results[2].error);
assert.strictEqual(results[2].error, 'Network response was not ok');

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: synthbench-pattern-matching
Language: javascript
================================================================================

PREFIX CODE:
----------------------------------------
const fetch = require('node-fetch');

// Function to fetch and process user data for analytics
async function fetchUserData(userId) {
    try {
        const response = await fetch(`https://api.example.com/users/${userId}`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const userData = await response.json();
        return userData;
    } catch (error) {
        console.error('Failed to fetch user data:', error);
        throw error;
    }
}

// Function to fetch and process analytics data for a user
async function fetchUserAnalytics(userId) {
    try {
        const response = await fetch(`https://api.example.com/users/${userId}/analytics`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const analyticsData = await response.json();
        return analyticsData;
    } catch (error) {
        console.error('Failed to fetch user analytics:', error);
        throw error;
    }
}

// Function to fetch and process user settings
async function fetchUserSettings(userId) {
    

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    try {
        const response = await fetch(`https://api.example.com/users/${userId}/settings`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const settingsData = await response.json();
        return settingsData;
    } catch (error) {
        console.error('Failed to fetch user settings:', error);
        throw error;
    }

SUFFIX CODE:
----------------------------------------

}

(async () => {
    try {
        const userId = 123;
        const userData = await fetchUserData(userId);
        const userAnalytics = await fetchUserAnalytics(userId);
        const userSettings = await fetchUserSettings(userId);

        console.log('User Data:', userData);
        console.log('User Analytics:', userAnalytics);
        console.log('User Settings:', userSettings);
    } catch (error) {
        console.error('Error fetching data:', error);
    }
})();


JUSTIFICATION:
----------------------------------------
This is a good test case because it establishes a clear pattern of asynchronous functions with error handling for fetching data from an API. Each function follows the same structure: making a network request, checking the response, parsing the JSON, and handling errors. The golden completion must follow this pattern to be correct. This tests the LLM's ability to recognize and continue a pattern in the context of async/await operations and error handling, which are common in real-world JavaScript applications.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
(async () => {
    const userId = 123;
    try {
        const userSettings = await fetchUserSettings(userId);
        assert(userSettings, 'User settings should be fetched successfully');
        assert(typeof userSettings === 'object', 'User settings should be an object');
    } catch (error) {
        assert.fail('Fetching user settings should not throw an error');
    }
})();
================================================================================
