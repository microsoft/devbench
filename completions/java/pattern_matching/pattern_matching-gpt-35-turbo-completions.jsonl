{"id": "1", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\n\npublic class DataValidator {\n    private List<String> data;\n\n    public DataValidator(List<String> data) {\n        this.data = data;\n    }\n\n    // Function to remove null or empty strings\n    public List<String> cleanData() {\n        return data.stream()\n                .filter(s -> s != null && !s.isEmpty())\n                .collect(Collectors.toList());\n    }\n\n    // Function to normalize the data to lowercase\n    public List<String> normalizeData() {\n        return data.stream()\n                .map(String::toLowerCase)\n                .collect(Collectors.toList());\n    }\n\n    // Function to validate email format\n    public List<String> validateEmails() {\n        return data.stream()\n                .filter(s -> s != null && s.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\"))\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<String> rawData = new ArrayList<>();\n        rawData.add(\"test@example.com\");\n        rawData.add(\"\");\n        rawData.add(\"invalid-email\");\n        rawData.add(\"another.test@domain.com\");\n\n        DataValidator validator = new DataValidator(rawData);\n        List<String> cleanedData = validator.cleanData();\n        List<String> normalizedData = validator.normalizeData();\n        List<String> validEmails = validator.validateEmails();\n", "suffix": "        assert validEmails.size() == 2 : \"Expected 2 valid emails\";\n        assert validEmails.contains(\"test@example.com\") : \"Missing 'test@example.com'\";\n        assert validEmails.contains(\"another.test@domain.com\") : \"Missing 'another.test@domain.com'\";\n\n        // Cleanup resources\n        rawData.clear();\n        cleanedData.clear();\n        normalizedData.clear();\n        validEmails.clear();\n    }\n}", "golden_completion": "        assert cleanedData.size() == 3 : \"Expected 3 cleaned items\";\n        assert cleanedData.contains(\"test@example.com\") : \"Missing 'test@example.com'\";\n        assert cleanedData.contains(\"invalid-email\") : \"Missing 'invalid-email'\";\n\n        assert normalizedData.size() == 4 : \"Expected 4 normalized items\";\n        assert normalizedData.contains(\"test@example.com\") : \"Missing 'test@example.com'\";\n        assert normalizedData.contains(\"invalid-email\") : \"Missing 'invalid-email'\";\n", "LLM_justification": "This test case establishes a pattern in the prefix where various data validation methods are implemented using Java streams and lambdas. The golden completion follows this pattern by asserting the expected outcomes of these methods. The assertions check the size and contents of the cleaned and normalized data lists, ensuring that the validation logic is correctly applied. The suffix then contains different assertions for the validation of email addresses, followed by resource cleanup. This scenario is realistic and practical, reflecting common tasks in data validation and normalization. It tests the model's ability to recognize and continue the pattern of using streams and lambda expressions for data processing.", "assertions": "", "gpt-35-turbo-completions": "assert cleanedData.size() == 3 : \"Expected 3 cleaned data\";\n        assert cleanedData.contains(\"test@example.com\") : \"Missing 'test@example.com'\";\n        assert cleanedData.contains(\"invalid-email\") : \"Missing 'invalid-email'\";\n        assert cleanedData.contains(\"another.test@domain.com\") : \"Missing 'another.test@domain.com'\";\n\n        assert normalizedData.size() == 4 : \"Expected 4 normalized data\";\n        assert normalizedData.contains(\"test@example.com\") : \"Missing 'test@example.com'\";\n        assert normalizedData.contains(\"invalid-email\") : \"Missing 'invalid-email'\";\n        assert normalizedData.contains(\"another.test@domain.com\") : \"Missing 'another.test@domain.com'\";"}
{"id": "2", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class DataAnalyzer {\n    private Map<String, Integer> data;\n\n    public DataAnalyzer() {\n        this.data = new HashMap<>();\n    }\n\n    // Method to add data\n    public void addData(String key, int value) {\n        this.data.put(key, value);\n    }\n\n    // Method to get the sum of all values\n    public int getTotalValue() {\n        return this.data.values().stream().mapToInt(Integer::intValue).sum();\n    }\n\n    // Method to filter data based on a threshold and return a new map\n    public Map<String, Integer> filterData(int threshold) {\n        return this.data.entrySet().stream()\n                .filter(entry -> entry.getValue() > threshold)\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n    }\n\n    // Method to normalize data values\n    public Map<String, Double> normalizeData() {\n        int totalValue = getTotalValue();\n        return this.data.entrySet().stream()\n                .collect(Collectors.toMap(\n                    Map.Entry::getKey,\n                    entry -> (double) entry.getValue() / totalValue\n                ));\n    }\n\n    // Method to find the maximum value\n    public int getMaxValue() {\n        return this.data.values().stream().mapToInt(Integer::intValue).max().orElse(0);\n    }\n\n    // Method to find the minimum value\n    public int getMinValue() {\n        return this.data.values().stream().mapToInt(Integer::intValue).min().orElse(0);\n    }\n\n    // Method to calculate the mean value\n    public double getMeanValue() {\n        int totalValue = getTotalValue();\n        int count = this.data.size();\n        if (count == 0) {\n            return 0.0;\n        }\n        return (double) totalValue / count;\n    }\n", "suffix": "}\n\n// Test the DataAnalyzer class\npublic class DataAnalyzerTest {\n    public static void main(String[] args) {\n        DataAnalyzer analyzer = new DataAnalyzer();\n        analyzer.addData(\"A\", 10);\n        analyzer.addData(\"B\", 20);\n        analyzer.addData(\"C\", 30);\n\n        // Assertions\n        assert analyzer.getTotalValue() == 60;\n        assert analyzer.getMaxValue() == 30;\n        assert analyzer.getMinValue() == 10;\n        assert Math.abs(analyzer.getMeanValue() - 20.0) < 0.0001;\n        assert analyzer.filterData(15).size() == 2;\n        assert analyzer.filterData(15).get(\"B\") == 20;\n        assert analyzer.filterData(15).get(\"C\") == 30;\n        assert analyzer.normalizeData().get(\"A\") == 10.0 / 60;\n        assert analyzer.normalizeData().get(\"B\") == 20.0 / 60;\n        assert analyzer.normalizeData().get(\"C\") == 30.0 / 60;\n\n        System.out.println(\"All tests passed.\");\n    }\n}", "golden_completion": "    // Method to calculate the median value\n    public double getMedianValue() {\n        int[] sortedValues = this.data.values().stream().mapToInt(Integer::intValue).sorted().toArray();\n        int count = sortedValues.length;\n        if (count == 0) {\n            return 0.0;\n        }\n        if (count % 2 == 0) {\n            return (sortedValues[count / 2 - 1] + sortedValues[count / 2]) / 2.0;\n        } else {\n            return sortedValues[count / 2];\n        }    \n}\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and continue a pattern of statistical data analysis methods in the DataAnalyzer class. The prefix establishes several methods for data manipulation and statistical calculations, such as getting the total, maximum, minimum, and mean values. The golden completion follows this established pattern by implementing a method to calculate the median value. The suffix then tests the implementation with assertions that verify the correctness of the methods, ensuring that the LLM generates code consistent with the existing patterns and functionality.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "3", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class DataValidator {\n    private Map<String, String> data;\n\n    public DataValidator() {\n        this.data = new HashMap<>();\n    }\n\n    public void addData(String key, String value) {\n        this.data.put(key, value);\n    }\n\n    public boolean validateNotEmpty(String key) {\n        String value = this.data.get(key);\n        return value != null && !value.isEmpty();\n    }\n\n    public boolean validateMinLength(String key, int minLength) {\n        String value = this.data.get(key);\n        return value != null && value.length() >= minLength;\n    }\n\n    public boolean validateMaxLength(String key, int maxLength) {\n        String value = this.data.get(key);\n        return value != null && value.length() <= maxLength;\n    }\n\n    // Pattern: Validate that the value of a given key matches a regex pattern\n    public boolean validatePattern(String key, String pattern) {\n        String value = this.data.get(key);\n        return value != null && value.matches(pattern);\n    }\n\n    // Pattern: Validate that the value of a given key is a valid email address\n", "suffix": "    public boolean validatePhoneNumber(String key) {\n        String value = this.data.get(key);\n        return value != null && value.matches(\"\\\\+?[0-9]{10,15}\");\n    }\n\n    public static void main(String[] args) {\n        DataValidator validator = new DataValidator();\n        validator.addData(\"email\", \"test@example.com\");\n        validator.addData(\"phone\", \"+1234567890\");\n        validator.addData(\"username\", \"valid_user\");\n\n        // Assertions\n        assert validator.validateEmail(\"email\");\n        assert !validator.validateEmail(\"invalid\");\n        assert validator.validatePhoneNumber(\"phone\");\n        assert !validator.validatePhoneNumber(\"short\");\n    }\n}\n", "golden_completion": "    public boolean validateEmail(String key) {\n        String value = this.data.get(key);\n        return value != null && value.matches(\"^[\\\\w-\\\\.+]*[\\\\w-\\\\.]\\\\@[\\\\w]+([\\\\.][\\\\w]+)+$\");\n    }\n", "LLM_justification": "This test case is a good example of pattern matching because it involves a common data validation scenario where multiple validation methods follow a similar pattern. The prefix establishes a clear pattern of validation methods for different criteria, and the golden completion needs to follow this pattern to validate email addresses correctly. The suffix continues this pattern with a method to validate phone numbers, providing further context and consistency. The assertions ensure that the validation logic works as expected.", "assertions": "", "gpt-35-turbo-completions": "// Pattern: Validate that the value of a given key is a valid phone number\n#TODO: You Code Here\n\n    public boolean validateEmail(String key) {\n        String value = this.data.get(key);\n        return value != null && value.matches(\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\");\n    }"}
{"id": "4", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class DataValidation {\n    private Map<String, Function<String, Boolean>> validators;\n\n    public DataValidation() {\n        this.validators = new HashMap<>();\n    }\n\n    public void addValidator(String fieldName, Function<String, Boolean> validator) {\n        this.validators.put(fieldName, validator);\n    }\n\n    public boolean validateField(String fieldName, String value) {\n        if (!validators.containsKey(fieldName)) {\n            throw new IllegalArgumentException(\"No validator for field: \" + fieldName);\n        }\n        return validators.get(fieldName).apply(value);\n    }\n\n    public static void main(String[] args) {\n        DataValidation dv = new DataValidation();\n\n        // Adding validators\n        dv.addValidator(\"email\", value -> value.contains(\"@\") && value.contains(\".\"));\n        dv.addValidator(\"phone\", value -> value.matches(\"\\\\d{10}\"));\n        dv.addValidator(\"zipcode\", value -> value.matches(\"\\\\d{5}\"));\n\n        // Validate some fields\n        String email = \"test@example.com\";\n        String phone = \"1234567890\";\n        String zipcode = \"12345\";\n\n        // Assertions to verify the pattern\n        assert dv.validateField(\"email\", email) == true : \"Email validation failed\";\n        assert dv.validateField(\"phone\", phone) == true : \"Phone validation failed\";\n        assert dv.validateField(\"zipcode\", zipcode) == true : \"Zipcode validation failed\";\n\n        // Test invalid cases\n        String invalidEmail = \"testexample.com\";\n        String invalidPhone = \"123456\";\n        String invalidZipcode = \"12ab5\";\n\n        assert dv.validateField(\"email\", invalidEmail) == false : \"Invalid email validation failed\";\n        assert dv.validateField(\"phone\", invalidPhone) == false : \"Invalid phone validation failed\";\n", "suffix": "\n\n        System.out.println(\"All tests passed.\");\n    }\n}", "golden_completion": "        assert dv.validateField(\"zipcode\", invalidZipcode) == false : \"Invalid zipcode validation failed\";\n", "LLM_justification": "This test case is a good example of functional programming with data validation in the context of schema validation. The pattern established involves adding field-specific validators using lambdas and then validating input data against these validators. The completion requires understanding of the established validation pattern and correctly implementing the validation for invalid inputs. This tests the LLM's ability to recognize and continue a pattern in a realistic scenario commonly encountered in data validation tasks.", "assertions": "", "gpt-35-turbo-completions": "assert dv.validateField(\"zipcode\", invalidZipcode) == false : \"Invalid zipcode validation failed\";"}
{"id": "5", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\n\n// A class for scientific data analysis\npublic class DataAnalyzer {\n\n    private List<Double> data;\n\n    public DataAnalyzer(List<Double> data) {\n        this.data = data;\n    }\n\n    // Method to filter data greater than a given threshold\n    public List<Double> filterDataGreaterThan(double threshold) {\n        return data.stream()\n                    .filter(d -> d > threshold)\n                    .collect(Collectors.toList());\n    }\n\n    // Method to calculate the mean of the data\n    public double calculateMean() {\n        return data.stream()\n                    .mapToDouble(Double::doubleValue)\n                    .average()\n                    .orElse(0.0);\n    }\n\n    // Method to calculate the standard deviation of the data\n    public double calculateStandardDeviation() {\n        double mean = calculateMean();\n        return Math.sqrt(data.stream()\n                             .mapToDouble(d -> Math.pow(d - mean, 2))\n                             .average()\n                             .orElse(0.0));\n    }\n\n    // Pattern: Method to normalize data\n    public List<Double> normalizeData() {\n        double mean = calculateMean();\n        double stdDev = calculateStandardDeviation();\n        return data.stream()\n                    .map(d -> (d - mean) / stdDev)\n                    .collect(Collectors.toList());\n    }\n\n    // Method to find the min value in the data\n    public double findMinValue() {\n        return data.stream()\n                    .mapToDouble(Double::doubleValue)\n                    .min()\n                    .orElse(Double.NaN);\n    }\n\n    // Method to find the max value in the data\n", "suffix": "\n\n    // Method to calculate the range of the data\n    public double calculateRange() {\n        double min = findMinValue();\n        double max = findMaxValue();\n        return max - min;\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        List<Double> sampleData = new ArrayList<>();\n        for (int i = 1; i <= 100; i++) {\n            sampleData.add((double) i);\n        }\n        DataAnalyzer analyzer = new DataAnalyzer(sampleData);\n\n        // Assertions for testing\n        assert analyzer.filterDataGreaterThan(50).size() == 50;\n        assert Math.abs(analyzer.calculateMean() - 50.5) < 1e-9;\n        assert Math.abs(analyzer.calculateStandardDeviation() - 29.011) < 1e-3;\n        List<Double> normalizedData = analyzer.normalizeData();\n        assert Math.abs(normalizedData.get(49) + 0.171) < 1e-3;\n        assert Math.abs(normalizedData.get(50) - 0.171) < 1e-3;\n        assert analyzer.findMinValue() == 1.0;\n        assert analyzer.findMaxValue() == 100.0;\n        assert analyzer.calculateRange() == 99.0;\n    }\n}\n", "golden_completion": "    public double findMaxValue() {\n        return data.stream()\n                    .mapToDouble(Double::doubleValue)\n                    .max()\n                    .orElse(Double.NaN);\n    }\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of data analysis methods in Java. The prefix includes methods to filter, calculate mean, standard deviation, normalize, and find the min value. The golden completion involves completing the method to find the max value, following the established pattern of using Java streams to process the data. This test case is realistic and practical, as it demonstrates common data analysis operations and patterns used in scientific computing. The assertions verify both the functional correctness and adherence to the pattern.", "assertions": "", "gpt-35-turbo-completions": "public double findMaxValue() {\n        return data.stream()\n                    .mapToDouble(Double::doubleValue)\n                    .max()\n                    .orElse(Double.NaN);\n    }"}
{"id": "6", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class DataAnalyzer {\n    private Map<String, Integer> data;\n\n    public DataAnalyzer() {\n        data = new HashMap<>();\n    }\n\n    public void addDataPoint(String key, int value) {\n        data.put(key, value);\n    }\n\n    // Method to find the maximum value in the dataset\n    public int findMaxValue() {\n        int max = Integer.MIN_VALUE;\n        for (int value : data.values()) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n\n    // Method to find the minimum value in the dataset\n    public int findMinValue() {\n        int min = Integer.MAX_VALUE;\n        for (int value : data.values()) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n\n    // Method to calculate the average value in the dataset\n    public double calculateAverageValue() {\n        int sum = 0;\n        for (int value : data.values()) {\n            sum += value;\n        }\n        return sum / (double) data.size();\n    }\n\n    // Method to find the median value in the dataset\n", "suffix": "        return (data.size() % 2 == 0) ? (values[data.size() / 2 - 1] + values[data.size() / 2]) / 2.0 : values[data.size() / 2];\n    }\n\n    public static void main(String[] args) {\n        DataAnalyzer analyzer = new DataAnalyzer();\n        analyzer.addDataPoint(\"A\", 10);\n        analyzer.addDataPoint(\"B\", 20);\n        analyzer.addDataPoint(\"C\", 30);\n        analyzer.addDataPoint(\"D\", 40);\n        analyzer.addDataPoint(\"E\", 50);\n\n        int max = analyzer.findMaxValue();\n        int min = analyzer.findMinValue();\n        double average = analyzer.calculateAverageValue();\n        double median = analyzer.findMedianValue();\n\n        assert max == 50 : \"Max value should be 50\";\n        assert min == 10 : \"Min value should be 10\";\n        assert average == 30.0 : \"Average value should be 30.0\";\n        assert median == 30.0 : \"Median value should be 30.0\";\n    }\n}", "golden_completion": "    public double findMedianValue() {\n        int[] values = data.values().stream().sorted().mapToInt(Integer::intValue).toArray();\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue a pattern of statistical data analysis methods in a Java class. The prefix establishes a clear pattern of methods for finding maximum, minimum, and average values, making it evident that the next logical method would be to find the median value. The golden completion follows this pattern by implementing the median calculation using Java streams and sorting mechanisms. The suffix continues with the main method and assertions, ensuring all implemented methods are tested correctly.", "assertions": "", "gpt-35-turbo-completions": "public double findMedianValue() {\n        int[] values = data.values().stream().mapToInt(i -> i).sorted().toArray();"}
{"id": "7", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n// Class to perform data cleaning for a given dataset\npublic class DataCleaner {\n    private List<String> data;\n\n    public DataCleaner(List<String> data) {\n        this.data = data;\n    }\n\n    // Method to remove null or empty entries\n    public List<String> removeNullOrEmpty() {\n        List<String> cleanedData = new ArrayList<>();\n        for (String entry : data) {\n            if (entry != null && !entry.isEmpty()) {\n                cleanedData.add(entry);\n            }\n        }\n        return cleanedData;\n    }\n\n    // Method to trim whitespace from each entry\n    public List<String> trimWhitespace() {\n        List<String> cleanedData = new ArrayList<>();\n        for (String entry : data) {\n            if (entry != null) {\n                cleanedData.add(entry.trim());\n            }\n        }\n        return cleanedData;\n    }\n\n    // Method to normalize data to lower case\n    public List<String> normalizeToLowerCase() {\n        List<String> cleanedData = new ArrayList<>();\n        for (String entry : data) {\n            if (entry != null) {\n                cleanedData.add(entry.toLowerCase());\n            }\n        }\n        return cleanedData;\n    }\n\n    // Method to clean special characters\n    public List<String> cleanSpecialCharacters() {\n        List<String> cleanedData = new ArrayList<>();\n        for (String entry : data) {\n            if (entry != null) {\n                cleanedData.add(entry.replaceAll(\"[^a-zA-Z0-9]\", \"\"));\n            }\n        }\n        return cleanedData;\n    }\n\n    public static void main(String[] args) {\n        List<String> data = new ArrayList<>();\n        data.add(\"  Hello World!  \");\n        data.add(null);\n        data.add(\"Java123\");\n        data.add(\"\");\n        data.add(\"Clean-Data\");\n\n        DataCleaner cleaner = new DataCleaner(data);\n        List<String> cleanedData = cleaner.removeNullOrEmpty();\n        cleanedData = cleaner.trimWhitespace();\n        cleanedData = cleaner.normalizeToLowerCase();\n", "suffix": "\n        // Assertions to verify the behavior\n        assert cleanedData.size() == 3;\n        assert cleanedData.contains(\"hello world\");\n        assert cleanedData.contains(\"java123\");\n        assert cleanedData.contains(\"clean-data\");\n\n        // Clean up resources if any (not needed in this case)\n    }\n}\n", "golden_completion": "        cleanedData = cleaner.cleanSpecialCharacters();\n", "LLM_justification": "This test case is a good example of a pattern matching scenario because it demonstrates a series of data cleaning steps applied to a list of strings. The pattern of iterating over the data list and performing specific transformations is clear and consistent across multiple methods. The golden completion follows this established pattern by adding a method to clean special characters from the strings. The assertions ensure that the data cleaning operations are performed correctly and that the expected results are achieved.", "assertions": "", "gpt-35-turbo-completions": "cleanedData = cleaner.cleanSpecialCharacters();"}
{"id": "8", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class DataValidator {\n\n    // Function to check if a list of strings contains only numeric values\n    public static List<Boolean> validateNumericStrings(List<String> data) {\n        List<Boolean> results = new ArrayList<>();\n        for (String str : data) {\n            results.add(isNumeric(str));\n        }\n        return results;\n    }\n\n    // Helper function to check if a string is numeric\n    private static boolean isNumeric(String str) {\n        if (str == null || str.isEmpty()) {\n            return false;\n        }\n        for (char c : str.toCharArray()) {\n            if (!Character.isDigit(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Function to check if a list of strings contains only alphabetic values\n    public static List<Boolean> validateAlphabeticStrings(List<String> data) {\n        List<Boolean> results = new ArrayList<>();\n        for (String str : data) {\n            results.add(isAlphabetic(str));\n        }\n        return results;\n    }\n\n    // Helper function to check if a string is alphabetic\n    private static boolean isAlphabetic(String str) {\n        if (str == null || str.isEmpty()) {\n            return false;\n        }\n        for (char c : str.toCharArray()) {\n            if (!Character.isLetter(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Function to check if a list of strings contains only alphanumeric values\n", "suffix": "    public static void main(String[] args) {\n        List<String> testData = new ArrayList<>();\n        testData.add(\"123\");\n        testData.add(\"abc\");\n        testData.add(\"123abc\");\n        testData.add(\"456\");\n        testData.add(\"def\");\n\n        List<Boolean> numericResults = validateNumericStrings(testData);\n        List<Boolean> alphabeticResults = validateAlphabeticStrings(testData);\n        List<Boolean> alphanumericResults = validateAlphanumericStrings(testData);\n\n        // Assertions to verify the behavior\n        assert numericResults.get(0) == true : \"Expected true for '123'\";\n        assert numericResults.get(1) == false : \"Expected false for 'abc'\";\n        assert numericResults.get(2) == false : \"Expected false for '123abc'\";\n        assert numericResults.get(3) == true : \"Expected true for '456'\";\n        assert numericResults.get(4) == false : \"Expected false for 'def'\";\n\n        assert alphabeticResults.get(0) == false : \"Expected false for '123'\";\n        assert alphabeticResults.get(1) == true : \"Expected true for 'abc'\";\n        assert alphabeticResults.get(2) == false : \"Expected false for '123abc'\";\n        assert alphabeticResults.get(3) == false : \"Expected false for '456'\";\n        assert alphabeticResults.get(4) == true : \"Expected true for 'def'\";\n\n        assert alphanumericResults.get(0) == true : \"Expected true for '123'\";\n        assert alphanumericResults.get(1) == true : \"Expected true for 'abc'\";\n        assert alphanumericResults.get(2) == true : \"Expected true for '123abc'\";\n        assert alphanumericResults.get(3) == true : \"Expected true for '456'\";\n        assert alphanumericResults.get(4) == true : \"Expected true for 'def'\";\n    }\n}\n\n", "golden_completion": "    public static List<Boolean> validateAlphanumericStrings(List<String> data) {\n        List<Boolean> results = new ArrayList<>();\n        for (String str : data) {\n            results.add(isAlphanumeric(str));\n        }\n        return results;\n    }\n\n    // Helper function to check if a string is alphanumeric\n    private static boolean isAlphanumeric(String str) {\n        if (str == null || str.isEmpty()) {\n            return false;\n        }\n        for (char c : str.toCharArray()) {\n            if (!Character.isLetterOrDigit(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete a common pattern in data validation functions. The pattern involves creating validation functions for different types of string content (numeric, alphabetic, alphanumeric) and their corresponding helper functions. The golden completion involves extending this pattern to add a new validation function and helper for alphanumeric strings. The suffix includes assertions that test this new function, ensuring that the LLM can correctly follow the established pattern and that the function behaves as expected.", "assertions": "", "gpt-35-turbo-completions": "// Helper function to check if a string is alphanumeric\n#TODO: You Code Here\n\n    // Main function to test the implementation"}
{"id": "9", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList; import java.util.List; import java.util.function.Function; import java.util.stream.Collectors; import java.util.stream.Stream; public class DataProcessor { \n\tprivate List<Double> data; \n\n\tpublic DataProcessor(List<Double> data) { \n\t\tthis.data = data; \n\t} \n\n\tpublic List<Double> filterData(Function<Double, Boolean> predicate) { \n\t\treturn data.stream() \n\t\t\t.filter(d -> predicate.apply(d)) \n\t\t\t.collect(Collectors.toList()); \n\t} \n\n\tpublic double processData(Function<List<Double>, Double> processingFunction) { \n\t\treturn processingFunction.apply(data); \n\t} \n\n\tpublic static void main(String[] args) { \n\t\tList<Double> dataList = Stream.of(1.2, 3.4, 5.6, 7.8, 9.0).collect(Collectors.toList()); \n\t\tDataProcessor processor = new DataProcessor(dataList); \n\n\t\t// Example of filtering data with a lambda function \n\t\tList<Double> filteredData = processor.filterData(d -> d > 4.0); \n\t\tSystem.out.println(\"Filtered Data: \" + filteredData); \n\n\t\t// Example of processing data with a lambda function \n\t\tdouble sum = processor.processData(data -> data.stream().mapToDouble(Double::doubleValue).sum()); \n\t\tSystem.out.println(\"Sum of Data: \" + sum); \n\n\t\t// Further examples and patterns to follow \n\t\t// Filter data with another lambda function \n\t\tList<Double> evenFilteredData = processor.filterData(d -> d % 2 == 0); \n\t\tSystem.out.println(\"Even Filtered Data: \" + evenFilteredData); \n\n\t\t// Process data to find the average \n\t\tdouble average = processor.processData(data -> data.stream().mapToDouble(Double::doubleValue).average().orElse(0.0)); \n\t\tSystem.out.println(\"Average of Data: \" + average); \n\n\t\t// Ensure the first filter and process examples \n\t\tassert filteredData.equals(Stream.of(5.6, 7.8, 9.0).collect(Collectors.toList())); \n\t\tassert sum == 27.0; \n", "suffix": "\n\t} \n}\n", "golden_completion": "\t\t// Filter data to only include values greater than 6.0 \n\t\tList<Double> greaterThanSixFilteredData = processor.filterData(d -> d > 6.0); \n\t\tSystem.out.println(\"Greater Than 6 Filtered Data: \" + greaterThanSixFilteredData); \n\n\t\t// Process data to find the maximum value \n\t\tdouble max = processor.processData(data -> data.stream().mapToDouble(Double::doubleValue).max().orElse(Double.NaN)); \n\t\tSystem.out.println(\"Max of Data: \" + max); \n\n\t\t// Assertions for the new patterns \n\t\tassert greaterThanSixFilteredData.equals(Stream.of(7.8, 9.0).collect(Collectors.toList())); \n\t\tassert max == 9.0;\n", "LLM_justification": "This example tests an LLM's ability to recognize and continue a pattern involving functional programming in Java, specifically using lambda functions and streams for data processing. The prefix establishes a clear pattern of filtering and processing data using lambda functions. The golden completion continues this pattern by adding new examples of filtering and processing, which the LLM needs to recognize and complete correctly. The suffix then includes similar but distinct examples and assertions to verify the correct pattern continuation. This scenario is realistic and practical, as it involves common data processing tasks developers encounter.", "assertions": "", "gpt-35-turbo-completions": "assert evenFilteredData.equals(Stream.of(6.0, 8.0).collect(Collectors.toList())); \n\t\tassert average == 5.4; \n\t\tSystem.out.println(\"All assertions passed!\");"}
{"id": "10", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.*;\n\npublic class DataProcessor {\n\n    public static void main(String[] args) {\n        List<Double> data = Arrays.asList(1.2, 2.3, 3.4, 4.5, 5.6, 6.7, 7.8, 8.9, 9.0);\n        // Calculate average of data points\n        double average = calculateAverage(data);\n        System.out.println(\"Average: \" + average);\n\n        // Calculate variance of data points\n        double variance = calculateVariance(data, average);\n        System.out.println(\"Variance: \" + variance);\n\n        // Calculate standard deviation of data points\n        double stddev = calculateStandardDeviation(data, variance);\n        System.out.println(\"Standard Deviation: \" + stddev);\n    }\n\n    public static double calculateAverage(List<Double> data) {\n        return data.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n    }\n\n    public static double calculateVariance(List<Double> data, double mean) {\n        return data.stream().mapToDouble(val -> (val - mean) * (val - mean)).average().orElse(0.0);\n    }\n", "suffix": "\n\n    // Assertions to test the correctness of the calculations\n    public static void main(String[] args) {\n        List<Double> data = Arrays.asList(1.2, 2.3, 3.4, 4.5, 5.6, 6.7, 7.8, 8.9, 9.0);\n        double average = calculateAverage(data);\n        assert Math.abs(average - 5.6) < 0.01 : \"Average calculation failed\";\n\n        double variance = calculateVariance(data, average);\n        assert Math.abs(variance - 7.56) < 0.01 : \"Variance calculation failed\";\n\n        double stddev = calculateStandardDeviation(data, variance);\n        assert Math.abs(stddev - 2.75) < 0.01 : \"Standard deviation calculation failed\";\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "    public static double calculateStandardDeviation(List<Double> data, double variance) {\n        return Math.sqrt(variance);\n    }\n", "LLM_justification": "This test case establishes a clear pattern of functional programming with streams to calculate statistical measures (average, variance, and standard deviation). The golden completion requires the model to recognize and follow the pattern of using functional programming to compute the standard deviation. The suffix includes assertions to ensure the computations are correct, making this a robust test for pattern recognition and continuation in a scientific computing context.", "assertions": "", "gpt-35-turbo-completions": "public static double calculateStandardDeviation(List<Double> data, double variance) {\n        return Math.sqrt(variance);\n    }"}
{"id": "11", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\npublic class DataCleaner {\n\n    public static List<String> removeEmptyStrings(List<String> data) {\n        return data.stream()\n                   .filter(str -> str != null && !str.isEmpty())\n                   .collect(Collectors.toList());\n    }\n\n    public static List<Integer> parseToIntegers(List<String> data) {\n        return data.stream()\n                   .map(str -> {\n                       try {\n                           return Integer.parseInt(str);\n                       } catch (NumberFormatException e) {\n                           return null;\n                       }\n                   })\n                   .filter(num -> num != null)\n                   .collect(Collectors.toList());\n    }\n\n    public static List<Double> parseToDoubles(List<String> data) {\n        return data.stream()\n                   .map(str -> {\n                       try {\n                           return Double.parseDouble(str);\n                       } catch (NumberFormatException e) {\n                           return null;\n                       }\n                   })\n                   .filter(num -> num != null)\n                   .collect(Collectors.toList());\n    }\n\n    public static List<String> toUpperCase(List<String> data) {\n        return data.stream()\n                   .map(str -> str.toUpperCase())\n                   .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<String> rawData = Arrays.asList(\"123\", \"\", \"456\", \"abc\", null, \"789\");\n", "suffix": "        List<String> cleanedData = removeEmptyStrings(rawData);\n        assert cleanedData.equals(Arrays.asList(\"123\", \"456\", \"abc\", \"789\")) : \"Failed to remove empty strings correctly\";\n\n        List<Integer> integerData = parseToIntegers(cleanedData);\n        assert integerData.equals(Arrays.asList(123, 456, 789)) : \"Failed to parse integers correctly\";\n\n        List<Double> doubleData = parseToDoubles(cleanedData);\n        assert doubleData.equals(Arrays.asList(123.0, 456.0, 789.0)) : \"Failed to parse doubles correctly\";\n\n        List<String> upperCaseData = toUpperCase(cleanedData);\n        assert upperCaseData.equals(Arrays.asList(\"123\", \"456\", \"ABC\", \"789\")) : \"Failed to convert to uppercase correctly\";\n\n        System.out.println(\"All tests passed.\");\n    }\n}\n", "golden_completion": "        List<String> nonEmptyData = removeEmptyStrings(rawData);\n        List<Integer> integerData = parseToIntegers(nonEmptyData);\n        List<Double> doubleData = parseToDoubles(nonEmptyData);\n        List<String> upperCaseData = toUpperCase(nonEmptyData);\n", "LLM_justification": "This test case is a good example of data validation and transformation using functional programming techniques in Java. The pattern involves creating methods that process lists of strings to remove empty entries, parse integers, parse doubles, and convert to uppercase. The pattern is clear and involves a sequence of transformations on a data set, which are common tasks in data cleaning operations. The assertions test the functionality of each method in sequence, ensuring the transformations are applied correctly. The pattern is established in the prefix with multiple methods following a similar structure, making it identifiable for completion.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "12", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\n// Utility class for scientific data processing\npublic class DataProcessor {\n\n    // Method to normalize a list of integers\n    public List<Double> normalizeData(List<Integer> data) {\n        int max = data.stream().max(Integer::compare).orElse(1);\n        int min = data.stream().min(Integer::compare).orElse(0);\n        return data.stream()\n            .map(value -> (double)(value - min) / (max - min))\n            .collect(Collectors.toList());\n    }\n\n    // Method to apply a given function to each element in a list\n    public <T, R> List<R> applyFunction(List<T> data, Function<T, R> function) {\n        return data.stream()\n            .map(function)\n            .collect(Collectors.toList());\n    }\n\n    // Method to calculate the mean of a list of doubles\n    public double calculateMean(List<Double> data) {\n        return data.stream()\n            .mapToDouble(Double::doubleValue)\n            .average()\n            .orElse(0.0);\n    }\n\n    // Method to calculate the variance of a list of doubles\n    public double calculateVariance(List<Double> data, double mean) {\n        return data.stream()\n            .mapToDouble(value -> Math.pow(value - mean, 2))\n            .average()\n            .orElse(0.0);\n    }\n\n    // Method to calculate the standard deviation of a list of doubles\n    public double calculateStandardDeviation(List<Double> data, double mean) {\n        double variance = calculateVariance(data, mean);\n        return Math.sqrt(variance);\n    }\n", "suffix": "\n    public static void main(String[] args) {\n        DataProcessor processor = new DataProcessor();\n        List<Integer> data = new ArrayList<>();\n        for (int i = 1; i <= 10; i++) {\n            data.add(i);\n        }\n        List<Double> normalizedData = processor.normalizeData(data);\n        double mean = processor.calculateMean(normalizedData);\n\n        // Assertions\n        assert normalizedData.size() == 10 : \"Normalized data size should be 10\";\n        assert Math.abs(mean - 0.5) < 0.01 : \"Mean of normalized data should be approximately 0.5\";\n        double stdDev = processor.calculateStandardDeviation(normalizedData, mean);\n        assert Math.abs(stdDev - 0.3015) < 0.01 : \"Standard deviation should be approximately 0.3015\";\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "    public double calculateMedian(List<Double> data) {\n        List<Double> sortedData = data.stream()\n            .sorted()\n            .collect(Collectors.toList());\n        int size = sortedData.size();\n        if (size % 2 == 0) {\n            return (sortedData.get(size / 2 - 1) + sortedData.get(size / 2)) / 2.0;\n        } else {\n            return sortedData.get(size / 2);\n        }\n    }\n", "LLM_justification": "This test case is a good benchmark for assessing pattern matching capabilities in Java due to its focus on functional programming within the domain of scientific computing. The prefix establishes a clear pattern of using streams and higher-order functions to process data. The golden completion requires the LLM to follow this established pattern by implementing a method to calculate the median of a list of doubles. The suffix includes assertions that verify the functionality and correctness of the implementation, ensuring that the LLM has accurately identified and continued the pattern.", "assertions": "", "gpt-35-turbo-completions": "// Method to calculate the covariance of two lists of doubles\n    public double calculateCovariance(List<Double> data1, List<Double> data2, double mean1, double mean2) {\n        int n = data1.size();\n        double sum = 0.0;\n        for (int i = 0; i < n; i++) {\n            sum += (data1.get(i) - mean1) * (data2.get(i) - mean2);\n        }\n        return sum / n;\n    }\n\n    // Method to calculate the correlation coefficient of two lists of doubles\n    public double calculateCorrelation(List<Double> data1, List<Double> data2) {\n        double mean1 = calculateMean(data1);\n        double mean2 = calculateMean(data2);\n        double covariance = calculateCovariance(data1, data2, mean1, mean2);\n        double stdDev1 = calculateStandardDeviation(data1, mean1);\n        double stdDev2 = calculateStandardDeviation(data2, mean2);\n        return covariance / (stdDev1 * stdDev2);\n    }\n\n    // Method to calculate the sum of two lists of doubles\n    public List<Double> calculateSum(List<Double> data1, List<Double> data2) {\n        int n = data1.size();\n        List<Double> sum = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            sum.add(data1.get(i) + data2.get(i));\n        }\n        return sum;\n    }\n\n    // Method to calculate the difference of two lists of doubles\n    public List<Double> calculateDifference(List<Double> data1, List<Double> data2) {\n        int n = data1.size();\n        List<Double> difference = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            difference.add(data1.get(i) - data2.get(i));\n        }\n        return difference;\n    }\n\n    // Method to calculate the product of two lists of doubles\n    public List<Double> calculateProduct(List<Double> data1, List<Double> data2) {\n        int n = data1.size();\n        List<Double> product = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            product.add(data1.get(i) * data2.get(i));\n        }\n        return product;\n    }\n\n    // Method to calculate the quotient of two lists of doubles\n    public List<Double> calculateQuotient(List<Double> data1, List<Double> data2) {\n        int n = data1.size();\n        List<Double> quotient = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            quotient.add(data1.get(i) / data2.get(i));\n        }\n        return quotient;\n    }\n\n    // Method to calculate the dot product of two lists of doubles\n    public double calculateDotProduct(List<Double> data1, List<Double> data2) {\n        int n = data1.size();\n        double sum = 0.0;\n        for (int i = 0; i < n; i++) {\n            sum += data1.get(i) * data2.get(i);\n        }\n        return sum;\n    }\n\n    // Method to calculate the cross product of two lists of doubles\n    public List<Double> calculateCrossProduct(List<Double> data1, List<Double> data2) {\n        List<Double> crossProduct = new ArrayList<>();\n        crossProduct.add(data1.get(1) * data2.get(2) - data1.get(2) * data2.get(1));\n        crossProduct.add(data1.get(2) * data2.get(0) - data1.get(0) * data2.get(2));\n        crossProduct.add(data1.get(0) * data2.get(1) - data1.get("}
{"id": "13", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * This class provides a utility to handle scientific computing tasks.\n * Specifically, it provides methods to calculate basic statistics.\n */\npublic class StatisticsCalculator {\n\n    private Map<String, Double> data;\n\n    public StatisticsCalculator() {\n        this.data = new HashMap<>();\n    }\n\n    /**\n     * Add a data point to the calculator.\n     * \n     * @param key The name of the data point.\n     * @param value The value of the data point.\n     */\n    public void addDataPoint(String key, double value) {\n        data.put(key, value);\n    }\n\n    /**\n     * Calculate the mean of the data points.\n     * \n     * @return The mean value.\n     */\n    public double calculateMean() {\n        double sum = 0.0;\n        for (double value : data.values()) {\n            sum += value;\n        }\n        return sum / data.size();\n    }\n\n    /**\n     * Calculate the variance of the data points.\n     * \n     * @return The variance value.\n     */\n    public double calculateVariance() {\n        double mean = calculateMean();\n        double temp = 0;\n        for (double value : data.values()) {\n            temp += (value - mean) * (value - mean);\n        }\n        return temp / data.size();\n    }\n\n", "suffix": "\n    public static void main(String[] args) {\n        StatisticsCalculator calculator = new StatisticsCalculator();\n        calculator.addDataPoint(\"data1\", 2.0);\n        calculator.addDataPoint(\"data2\", 4.0);\n        calculator.addDataPoint(\"data3\", 4.0);\n        calculator.addDataPoint(\"data4\", 4.0);\n        calculator.addDataPoint(\"data5\", 5.0);\n        calculator.addDataPoint(\"data6\", 5.0);\n        calculator.addDataPoint(\"data7\", 7.0);\n        calculator.addDataPoint(\"data8\", 9.0);\n\n        double standardDeviation = calculator.calculateStandardDeviation();\n\n        // Assertions\n        assert Math.abs(standardDeviation - 2.0) < 0.001 : \"Standard Deviation calculation failed\";\n\n        // Cleanup (not needed in this example)\n    }\n}", "golden_completion": "\n    /**\n     * Calculate the standard deviation of the data points.\n     * \n     * @return The standard deviation value.\n     */\n    public double calculateStandardDeviation() {\n        return Math.sqrt(calculateVariance());\n    }\n", "LLM_justification": "This test case is a good example of pattern matching in Java for an algorithm implementation in the context of scientific computing. The prefix establishes a pattern of methods that calculate statistical measures (mean and variance). The golden completion continues this pattern by implementing the method to calculate the standard deviation, which logically follows from the calculation of variance. The suffix then tests this implementation with a specific set of data points and verifies the correctness of the result using an assertion. This scenario tests the LLM's ability to recognize and continue an established pattern in a realistic scientific computing context.", "assertions": "", "gpt-35-turbo-completions": "/**\n     * Calculate the standard deviation of the data points.\n     * \n     * @return The standard deviation value.\n     */\n    public double calculateStandardDeviation() {\n        return Math.sqrt(calculateVariance());\n    }\n\n    /**\n     * Main method to demonstrate the usage of the class.\n     * \n     * @param args The command line arguments.\n     */"}
{"id": "14", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class DataValidator {\n\tprivate final List<Predicate<String>> validators;\n\n\tpublic DataValidator(List<Predicate<String>> validators) {\n\t\tthis.validators = validators;\n\t}\n\n\tpublic boolean validate(String data) {\n\t\tfor (Predicate<String> validator : validators) {\n\t\t\tif (!validator.test(data)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tPredicate<String> isNotEmpty = str -> str != null && !str.isEmpty();\n\t\tPredicate<String> isLongEnough = str -> str.length() > 3;\n\t\tPredicate<String> containsDigit = str -> str.matches(\".*\\\\d.*\");\n\n\t\tList<Predicate<String>> validators = Arrays.asList(isNotEmpty, isLongEnough, containsDigit);\n\t\tDataValidator validator = new DataValidator(validators);\n\n\t\tString testString1 = \"abc123\";\n\t\tString testString2 = \"ab\";\n\t\tString testString3 = \"\";\n", "suffix": "\t\tboolean result2 = validator.validate(testString2);\n\t\tboolean result3 = validator.validate(testString3);\n\t\tassert !result2 : \"Test string 2 should fail validation\";\n\t\tassert !result3 : \"Test string 3 should fail validation\";\n\t\tSystem.out.println(\"All assertions passed.\");\n\t}\n}\n", "golden_completion": "\t\tboolean result1 = validator.validate(testString1);\n\t\tassert result1 : \"Test string 1 should pass validation\";\n", "LLM_justification": "This test case establishes a clear pattern of using a DataValidator class to validate strings based on multiple predicates. The pattern involves setting up predicates, passing them to the DataValidator, and then calling the validate method while asserting the results. The golden completion fits this pattern by adding a new validation call and assertion for an additional test string, ensuring the pattern is continued correctly.", "assertions": "", "gpt-35-turbo-completions": "boolean result1 = validator.validate(testString1);\n\t\tassert result1 : \"Test string 1 should pass validation\";"}
{"id": "15", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\nclass DataProcessor {\n    private List<Double> data;\n\n    public DataProcessor() {\n        this.data = new ArrayList<>();\n    }\n\n    public void addData(Double value) {\n        data.add(value);\n    }\n\n    // Compute the average of the data points\n    public double computeAverage() {\n        if (data.isEmpty()) {\n            throw new IllegalStateException(\"No data to compute average\");\n        }\n        double sum = 0;\n        for (Double d : data) {\n            sum += d;\n        }\n        return sum / data.size();\n    }\n\n    // Compute the variance of the data points\n    public double computeVariance() {\n        double average = computeAverage();\n        double sumOfSquares = 0;\n        for (Double d : data) {\n            sumOfSquares += Math.pow(d - average, 2);\n        }\n        return sumOfSquares / data.size();\n    }\n\n    // Compute the standard deviation of the data points\n", "suffix": "    public static void main(String[] args) {\n        DataProcessor processor = new DataProcessor();\n        processor.addData(1.0);\n        processor.addData(2.0);\n        processor.addData(3.0);\n        processor.addData(4.0);\n        processor.addData(5.0);\n\n        double standardDeviation = processor.computeStandardDeviation();\n\n        // Assertions\n        assert standardDeviation == 1.4142135623730951 : \"Standard deviation calculation is incorrect\";\n\n        // Cleanup code if needed (none required here)\n    }\n}", "golden_completion": "    public double computeStandardDeviation() {\n        return Math.sqrt(computeVariance());\n    }\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and continue a pattern in a class that performs statistical computations on a dataset. The pattern involves methods that compute various statistical measures such as average, variance, and standard deviation. The golden completion should follow the established pattern of using previously defined methods to perform the calculation. The suffix includes assertions to verify the correctness of the computed standard deviation, ensuring the LLM adheres to the pattern and maintains functional accuracy.", "assertions": "", "gpt-35-turbo-completions": "public double computeStandardDeviation() {\n        return Math.sqrt(computeVariance());\n    }\n}\n\npublic class Main {"}
{"id": "16", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.Collectors;\n\nclass DataCleaner {\n\n    // Function to remove null values from a list\n    public static List<String> removeNulls(List<String> list) {\n        return list.stream().filter(Objects::nonNull).collect(Collectors.toList());\n    }\n\n    // Function to trim whitespace from each string in a list\n    public static List<String> trimWhitespace(List<String> list) {\n        return list.stream().map(String::trim).collect(Collectors.toList());\n    }\n\n    // Function to convert all strings in a list to lowercase\n    public static List<String> toLowerCase(List<String> list) {\n        return list.stream().map(String::toLowerCase).collect(Collectors.toList());\n    }\n\n    // Function to normalize a list of strings\n    public static List<String> normalize(List<String> list) {\n", "suffix": "\n    }\n\n    public static void main(String[] args) {\n        List<String> data = Arrays.asList(\"  Hello \", null, \" WoRLd \", \"  \", \"Java \");\n        List<String> cleanedData = normalize(data);\n\n        // Assertions to verify functionality\n        assert cleanedData.size() == 3 : \"Size should be 3\";\n        assert cleanedData.get(0).equals(\"hello\") : \"First element should be 'hello'\";\n        assert cleanedData.get(1).equals(\"world\") : \"Second element should be 'world'\";\n        assert cleanedData.get(2).equals(\"java\") : \"Third element should be 'java'\";\n    }\n}\n", "golden_completion": "        return toLowerCase(trimWhitespace(removeNulls(list)));\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of functional programming using Java Streams for data validation and normalization. The pattern involves chaining multiple operations: removing nulls, trimming whitespace, and converting to lowercase. The golden completion follows this pattern by chaining the methods in the correct order. The suffix includes assertions to verify the correctness of the implementation and ensure that the pattern is followed accurately.", "assertions": "", "gpt-35-turbo-completions": "return toLowerCase(trimWhitespace(removeNulls(list)));"}
{"id": "17", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.*;\n\npublic class DataAnalysis {\n\n    // A helper method to calculate the mean of a list of integers\n    public static double calculateMean(List<Integer> data) {\n        return data.stream().mapToInt(Integer::intValue).average().orElse(0.0);\n    }\n\n    // A helper method to calculate the variance of a list of integers\n    public static double calculateVariance(List<Integer> data, double mean) {\n        return data.stream().mapToDouble(i -> Math.pow(i - mean, 2)).average().orElse(0.0);\n    }\n\n    // A method to calculate the standard deviation of a list of integers\n    public static double calculateStandardDeviation(List<Integer> data) {\n        double mean = calculateMean(data);\n        double variance = calculateVariance(data, mean);\n        return Math.sqrt(variance);\n    }\n\n    // A method to calculate the median of a list of integers\n    public static double calculateMedian(List<Integer> data) {\n        List<Integer> sortedData = data.stream().sorted().collect(Collectors.toList());\n        int size = sortedData.size();\n        if (size % 2 == 0) {\n            return (sortedData.get(size / 2 - 1) + sortedData.get(size / 2)) / 2.0;\n        } else {\n            return sortedData.get(size / 2);\n        }\n    }\n", "suffix": "\n    public static void main(String[] args) {\n        List<Integer> data = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n        // Validate the calculateMean method\n        double mean = calculateMean(data);\n        assert mean == 5.5 : \"Mean calculation is incorrect\";\n\n        // Validate the calculateStandardDeviation method\n        double stdDev = calculateStandardDeviation(data);\n        assert stdDev == 2.8722813232690143 : \"Standard deviation calculation is incorrect\";\n\n        // Validate the calculateMedian method\n        double median = calculateMedian(data);\n        assert median == 5.5 : \"Median calculation is incorrect\";\n\n        // Validate the calculateMode method\n        List<Integer> mode = calculateMode(data);\n        assert mode.equals(Collections.emptyList()) : \"Mode calculation is incorrect\";\n    }\n}\n", "golden_completion": "    // A method to calculate the mode of a list of integers\n    public static List<Integer> calculateMode(List<Integer> data) {\n        Map<Integer, Long> frequencyMap = data.stream().collect(Collectors.groupingBy(i -> i, Collectors.counting()));\n        long maxFrequency = frequencyMap.values().stream().max(Long::compare).orElse(0L);\n        return frequencyMap.entrySet().stream()\n            .filter(entry -> entry.getValue() == maxFrequency && maxFrequency > 1)\n            .map(Map.Entry::getKey)\n            .collect(Collectors.toList());\n    }\n", "LLM_justification": "This test case is a good example of pattern matching because it involves common statistical calculations on a list of integers, demonstrating the use of functional programming patterns with Java Streams. The established pattern includes calculating mean, variance, standard deviation, and median using Java Streams, and the golden completion follows this pattern by adding a method to calculate the mode. This scenario is realistic for data analysis tasks and ensures that the LLM can recognize and continue the established pattern correctly.", "assertions": "", "gpt-35-turbo-completions": "// A method to calculate the mode of a list of integers\n    public static List<Integer> calculateMode(List<Integer> data) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int i : data) {\n            frequencyMap.put(i, frequencyMap.getOrDefault(i, 0) + 1);\n        }\n\n        int maxFrequency = frequencyMap.values().stream().max(Integer::compare).orElse(0);\n        return frequencyMap.entrySet().stream()\n                .filter(e -> e.getValue() == maxFrequency)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n    }\n#TODO: You Code Here"}
{"id": "18", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class DataNormalization {\n\n    // Helper function to remove leading and trailing whitespace\n    public static String trimWhitespace(String input) {\n        return input == null ? null : input.trim();\n    }\n\n    // Helper function to convert strings to lowercase\n    public static String toLowerCase(String input) {\n        return input == null ? null : input.toLowerCase();\n    }\n\n    // Higher-order function to apply a list of transformations\n    public static List<String> applyTransformations(List<String> data, List<Function<String, String>> transformations) {\n        return data.stream()\n                    .map(item -> {\n                        for (Function<String, String> transformation : transformations) {\n                            item = transformation.apply(item);\n                        }\n                        return item;\n                    })\n                    .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<String> data = new ArrayList<>();\n        data.add(\"  Hello World  \");\n        data.add(\"  Java Programming  \");\n        data.add(\"  Data Normalization  \");\n\n        List<Function<String, String>> transformations = new ArrayList<>();\n        transformations.add(DataNormalization::trimWhitespace);\n        transformations.add(DataNormalization::toLowerCase);\n", "suffix": "\n        List<String> normalizedData = applyTransformations(data, transformations);\n\n        assert normalizedData.get(0).equals(\"hello world\");\n        assert normalizedData.get(1).equals(\"java programming\");\n        assert normalizedData.get(2).equals(\"data normalization\");\n\n        System.out.println(\"All assertions passed!\");\n    }\n}\n", "golden_completion": "        transformations.add(s -> s.replaceAll(\" \", \"_\"));\n", "LLM_justification": "This test case demonstrates a common scenario in data validation and normalization where a series of string transformations are applied to a list of data entries. The pattern involves using higher-order functions to compose multiple string transformation functions and apply them in sequence to each element of the list. The golden completion adds a new transformation to the list, which replaces spaces with underscores, following the established pattern of string manipulation functions. The suffix includes assertions to verify that the transformations have been applied correctly, ensuring that the pattern is correctly recognized and extended by the LLM.", "assertions": "", "gpt-35-turbo-completions": "// Apply transformations to data and store the result in normalizedData\n        // The expected output is: [\"hello world\", \"java programming\", \"data normalization\"]"}
{"id": "19", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\n\npublic class DataProcessor {\n\n\tprivate List<String> data;\n\n\tpublic DataProcessor() {\n\t\tthis.data = new ArrayList<>();\n\t}\n\n\tpublic void addData(String datum) {\n\t\tthis.data.add(datum);\n\t}\n\n\tpublic List<String> processData(Function<String, String> processor) {\n\t\tList<String> result = new ArrayList<>();\n\t\tfor (String datum : data) {\n\t\t\tresult.add(processor.apply(datum));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tDataProcessor processor = new DataProcessor();\n\t\tprocessor.addData(\"hello\");\n\t\tprocessor.addData(\"world\");\n\t\t\n\t\t// Define a processor that converts strings to uppercase\n\t\tFunction<String, String> toUpperCase = new Function<String, String>() {\n\t\t\t@Override\n\t\t\tpublic String apply(String s) {\n\t\t\t\treturn s.toUpperCase();\n\t\t\t}\n\t\t};\n\t\t\n\t\t// Process the data\n\t\tList<String> processedData = processor.processData(toUpperCase);\n\t\t\n\t\t// Assertions\n\t\tassert processedData.size() == 2;\n\t\tassert \"HELLO\".equals(processedData.get(0));\n\t\tassert \"WORLD\".equals(processedData.get(1));\n\t\t\n\t\t// Define another processor that reverses the strings\n\t\tFunction<String, String> reverseString = new Function<String, String>() {\n\t\t\t@Override\n\t\t\tpublic String apply(String s) {\n\t\t\t\treturn new StringBuilder(s).reverse().toString();\n\t\t\t}\n\t\t};\n\t\t\n\t\t// Process the data again\n\t\tprocessedData = processor.processData(reverseString);\n\t\t\n\t\t// Assertions\n\t\tassert processedData.size() == 2;\n\t\tassert \"olleh\".equals(processedData.get(0));\n\t\tassert \"dlrow\".equals(processedData.get(1));\n\t\t\n", "suffix": "\t\t// Define another processor that appends a suffix to the strings\n\t\tFunction<String, String> appendSuffix = new Function<String, String>() {\n\t\t\t@Override\n\t\t\tpublic String apply(String s) {\n\t\t\t\treturn s + \"_suffix\";\n\t\t\t}\n\t\t};\n\t\t\n\t\t// Process the data again\n\t\tList<String> processedData = processor.processData(appendSuffix);\n\t\t\n\t\t// Assertions\n\t\tassert processedData.size() == 2;\n\t\tassert \"hello_suffix\".equals(processedData.get(0));\n\t\tassert \"world_suffix\".equals(processedData.get(1));\n\t}\n}\n", "golden_completion": "\t\t// Define another processor that trims whitespace\n\t\tFunction<String, String> trimWhitespace = new Function<String, String>() {\n\t\t\t@Override\n\t\t\tpublic String apply(String s) {\n\t\t\t\treturn s.trim();\n\t\t\t}\n\t\t};\n\t\t\n\t\t// Process the data again\n\t\tList<String> processedData = processor.processData(trimWhitespace);\n\t\t\n\t\t// Assertions\n\t\tassert processedData.size() == 2;\n\t\tassert \"hello\".equals(processedData.get(0));\n\t\tassert \"world\".equals(processedData.get(1));\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and extend patterns in functional programming within the context of data processing. The pattern involves defining various string transformation functions (using Java's Function interface) and applying them to a list of strings. By following this pattern, the LLM is expected to correctly implement a new string transformation function and verify its results. This scenario is realistic for developers working with data processing and functional programming, and it tests the LLM's understanding of higher-order functions and pattern continuation.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "20", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class DataValidator {\n\tprivate Map<String, Pattern> validationRules;\n\n\tpublic DataValidator() {\n\t\tvalidationRules = new HashMap<>();\n\t}\n\n\tpublic void addRule(String fieldName, String regex) {\n\t\tvalidationRules.put(fieldName, Pattern.compile(regex));\n\t}\n\n\tpublic boolean validate(String fieldName, String value) {\n\t\tPattern pattern = validationRules.get(fieldName);\n\t\tif (pattern == null) {\n\t\t\tthrow new IllegalArgumentException(\"No rule defined for field: \" + fieldName);\n\t\t}\n\t\tMatcher matcher = pattern.matcher(value);\n\t\treturn matcher.matches();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tDataValidator validator = new DataValidator();\n\t\tvalidator.addRule(\"email\", \"^[A-Za-z0-9+_.-]+@(.+)$\");\n\t\tvalidator.addRule(\"phone\", \"^\\\\d{10}$\");\n\t\tvalidator.addRule(\"zipcode\", \"^\\\\d{5}$\");\n\n", "suffix": "\t\tboolean isValidPhone = validator.validate(\"phone\", \"1234567890\");\n\t\tboolean isValidZipcode = validator.validate(\"zipcode\", \"12345\");\n\n\t\t// Assertions\n\t\tif (!isValidEmail) {\n\t\t\tthrow new AssertionError(\"Email validation failed.\");\n\t\t}\n\t\tif (!isValidPhone) {\n\t\t\tthrow new AssertionError(\"Phone validation failed.\");\n\t\t}\n\t\tif (!isValidZipcode) {\n\t\t\tthrow new AssertionError(\"Zipcode validation failed.\");\n\t\t}\n\n\t\t// Negative test cases\n\t\tboolean isInvalidEmail = validator.validate(\"email\", \"invalid-email\");\n\t\tboolean isInvalidPhone = validator.validate(\"phone\", \"12345\");\n\t\tboolean isInvalidZipcode = validator.validate(\"zipcode\", \"ABCDE\");\n\n\t\t// Assertions for negative cases\n\t\tif (isInvalidEmail) {\n\t\t\tthrow new AssertionError(\"Invalid email should not pass validation.\");\n\t\t}\n\t\tif (isInvalidPhone) {\n\t\t\tthrow new AssertionError(\"Invalid phone number should not pass validation.\");\n\t\t}\n\t\tif (isInvalidZipcode) {\n\t\t\tthrow new AssertionError(\"Invalid zipcode should not pass validation.\");\n\t\t}\n\t\tSystem.out.println(\"All tests passed.\");\n\t}\n}\n", "golden_completion": "\t\tboolean isValidEmail = validator.validate(\"email\", \"test@example.com\");\n", "LLM_justification": "This test case is effective because it establishes a clear pattern of validation rule addition and validation checks for different data fields like email, phone, and zipcode. The prefix sets up the context with three addRule calls and an initial validation check for email. The golden completion continues the pattern with a specific validation check for email. The suffix further extends this pattern by adding validation checks for phone and zipcode, and includes assertions to verify both valid and invalid cases, ensuring comprehensive testing of the pattern.", "assertions": "", "gpt-35-turbo-completions": "// Positive test cases\n\t\tboolean isValidEmail = validator.validate(\"email\", \"test@example.com\");"}
{"id": "21", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class DataAnalyzer {\n\n    public static List<Double> analyzeData(List<Double> data, Function<Double, Double> transformation) {\n        return data.stream()\n                    .map(transformation)\n                    .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<Double> data = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        Function<Double, Double> squareFunction = x -> x * x;\n        Function<Double, Double> sqrtFunction = Math::sqrt;\n\n        List<Double> squaredData = analyzeData(data, squareFunction);\n        System.out.println(\"Squared Data: \" + squaredData);\n        // Expected: [1.0, 4.0, 9.0, 16.0, 25.0]\n\n        List<Double> sqrtData = analyzeData(data, sqrtFunction);\n        System.out.println(\"Square Root Data: \" + sqrtData);\n        // Expected: [1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979]\n", "suffix": "\n\n        assert squaredData.equals(Arrays.asList(1.0, 4.0, 9.0, 16.0, 25.0)) : \"Squared data does not match expected values\";\n        assert sqrtData.equals(Arrays.asList(1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979)) : \"Square root data does not match expected values\";\n        assert doubledData.equals(Arrays.asList(2.0, 4.0, 6.0, 8.0, 10.0)) : \"Doubled data does not match expected values\";\n\n        System.out.println(\"All assertions passed.\");\n    }\n}", "golden_completion": "        List<Double> doubledData = analyzeData(data, x -> x * 2);\n        System.out.println(\"Doubled Data: \" + doubledData);\n        // Expected: [2.0, 4.0, 6.0, 8.0, 10.0]\n", "LLM_justification": "This is a good test case for pattern matching as it demonstrates the use of higher-order functions to transform data in a consistent and predictable manner. The pattern of using the 'analyzeData' method with different transformation functions is clearly established in the prefix. The 'golden_completion' follows this pattern by providing another transformation function to double the data. The suffix then includes assertions to verify that the transformations are applied correctly, ensuring both pattern adherence and functional correctness.", "assertions": "", "gpt-35-turbo-completions": "List<Double> doubledData = analyzeData(data, x -> x * 2);\n        System.out.println(\"Doubled Data: \" + doubledData);\n        // Expected: [2.0, 4.0, 6.0, 8.0, 10.0]"}
{"id": "22", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n// This class represents a simple data validation utility\npublic class DataValidator {\n\n\t// Method to validate email addresses\n\tpublic static List<String> validateEmails(List<String> emails) {\n\t\tList<String> validEmails = new ArrayList<>();\n\t\tfor (String email : emails) {\n\t\t\tif (email != null && email.contains(\"@\") && email.contains(\".\")) {\n\t\t\t\tvalidEmails.add(email);\n\t\t\t}\n\t\t}\n\t\treturn validEmails;\n\t}\n\n\t// Method to validate phone numbers\n\tpublic static List<String> validatePhoneNumbers(List<String> phoneNumbers) {\n\t\tList<String> validPhoneNumbers = new ArrayList<>();\n\t\tfor (String phoneNumber : phoneNumbers) {\n\t\t\tif (phoneNumber != null && phoneNumber.matches(\"\\\\d{10}\")) {\n\t\t\t\tvalidPhoneNumbers.add(phoneNumber);\n\t\t\t}\n\t\t}\n\t\treturn validPhoneNumbers;\n\t}\n\n\t// Method to validate URLs\n", "suffix": "\tpublic static List<String> validateSSNs(List<String> ssns) {\n\t\tList<String> validSSNs = new ArrayList<>();\n\t\tfor (String ssn : ssns) {\n\t\t\tif (ssn != null && ssn.matches(\"\\\\d{3}-\\\\d{2}-\\\\d{4}\")) {\n\t\t\t\tvalidSSNs.add(ssn);\n\t\t\t}\n\t\t}\n\t\treturn validSSNs;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tList<String> emails = List.of(\"test@example.com\", \"invalid-email\", \"user@domain.org\");\n\t\tList<String> validEmails = validateEmails(emails);\n\t\tassert validEmails.size() == 2;\n\t\tassert validEmails.contains(\"test@example.com\");\n\t\tassert validEmails.contains(\"user@domain.org\");\n\n\t\tList<String> phoneNumbers = List.of(\"1234567890\", \"0987654321\", \"123-456-7890\");\n\t\tList<String> validPhoneNumbers = validatePhoneNumbers(phoneNumbers);\n\t\tassert validPhoneNumbers.size() == 2;\n\t\tassert validPhoneNumbers.contains(\"1234567890\");\n\t\tassert validPhoneNumbers.contains(\"0987654321\");\n\n\t\tList<String> ssns = List.of(\"123-45-6789\", \"987-65-4321\", \"123456789\");\n\t\tList<String> validSSNs = validateSSNs(ssns);\n\t\tassert validSSNs.size() == 2;\n\t\tassert validSSNs.contains(\"123-45-6789\");\n\t\tassert validSSNs.contains(\"987-65-4321\");\n\t}\n}\n", "golden_completion": "\tpublic static List<String> validateURLs(List<String> urls) {\n\t\tList<String> validURLs = new ArrayList<>();\n\t\tfor (String url : urls) {\n\t\t\tif (url != null && url.startsWith(\"http\")) {\n\t\t\t\tvalidURLs.add(url);\n\t\t\t}\n\t\t}\n\t\treturn validURLs;\n\t}\n", "LLM_justification": "This test case is designed to assess the model's ability to recognize and continue a pattern of data validation methods within a utility class. Each method in the prefix follows a specific pattern: iterating through a list, checking a condition, and adding valid items to a result list. The golden completion requires the model to follow this pattern by implementing a method to validate URLs. The suffix continues with another method to validate SSNs and includes assertions to verify the correctness of all methods. This scenario tests the model's understanding of both the pattern and the domain context of data validation.", "assertions": "", "gpt-35-turbo-completions": "// Method to validate SSNs"}
{"id": "23", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.function.Function;\n\npublic class DataProcessing {\n\n    // Helper method to process a list of integers\n    public static List<Integer> processIntegers(List<Integer> inputList, Function<Integer, Integer> processor) {\n        List<Integer> result = new ArrayList<>();\n        for (Integer number : inputList) {\n            result.add(processor.apply(number));\n        }\n        return result;\n    }\n\n    // Helper method to process a list of strings\n    public static List<String> processStrings(List<String> inputList, Function<String, String> processor) {\n        List<String> result = new ArrayList<>();\n        for (String text : inputList) {\n            result.add(processor.apply(text));\n        }\n        return result;\n    }\n\n    // Helper method to process a list of doubles\n    public static List<Double> processDoubles(List<Double> inputList, Function<Double, Double> processor) {\n        List<Double> result = new ArrayList<>();\n        for (Double number : inputList) {\n            result.add(processor.apply(number));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> integers = List.of(1, 2, 3, 4);\n        List<String> strings = List.of(\"a\", \"b\", \"c\");\n        List<Double> doubles = List.of(1.1, 2.2, 3.3);\n", "suffix": "        // Use the processFloats method\n        List<Float> floats = List.of(1.1f, 2.2f, 3.3f);\n        List<Float> processedFloats = processFloats(floats, number -> number * 2);\n        assert processedFloats.equals(List.of(2.2f, 4.4f, 6.6f));\n    }\n\n    // Helper method to process a list of floats\n    public static List<Float> processFloats(List<Float> inputList, Function<Float, Float> processor) {\n        List<Float> result = new ArrayList<>();\n        for (Float number : inputList) {\n            result.add(processor.apply(number));\n        }\n        return result;\n    }\n}\n", "golden_completion": "        // Use the processDoubles method\n        List<Double> processedDoubles = processDoubles(doubles, number -> number * 2);\n        assert processedDoubles.equals(List.of(2.2, 4.4, 6.6));\n", "LLM_justification": "This test case is good for evaluating the ability of an LLM to recognize and continue the pattern of processing lists with functional programming in Java. The prefix establishes a clear pattern with methods for processing lists of different types using a functional programming approach. The golden_completion requires the LLM to continue this pattern correctly with a new type (Double), ensuring it understands the structure and logic. The suffix then tests another type (Float), providing a clear example of how the pattern should be applied consistently across different data types, and includes assertions to verify the correctness.", "assertions": "", "gpt-35-turbo-completions": "// Use the processIntegers method\n        List<Integer> processedIntegers = processIntegers(integers, number -> number * 2);\n        assert processedIntegers.equals(List.of(2, 4, 6, 8));\n\n        // Use the processStrings method\n        List<String> processedStrings = processStrings(strings, text -> text.toUpperCase());\n        assert processedStrings.equals(List.of(\"A\", \"B\", \"C\"));\n\n        // Use the processDoubles method\n        List<Double> processedDoubles = processDoubles(doubles, number -> number * 2);\n        assert processedDoubles.equals(List.of(2.2, 4.4, 6.6));\n\n#TODO: You Code Here"}
{"id": "24", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\n\npublic class DataProcessor {\n\n    // Applies a given function to all elements in the list and returns a new list with the results\n    public static <T, R> List<R> applyFunction(List<T> inputList, Function<T, R> function) {\n        List<R> resultList = new ArrayList<>();\n        for (T element : inputList) {\n            resultList.add(function.apply(element));\n        }\n        return resultList;\n    }\n\n    // Example higher-order function that converts a list of integers to their string representations\n    public static List<String> convertIntegersToStrings(List<Integer> integers) {\n        return applyFunction(integers, Object::toString);\n    }\n\n    // Example higher-order function that squares a list of integers\n    public static List<Integer> squareIntegers(List<Integer> integers) {\n        return applyFunction(integers, x -> x * x);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> integers = List.of(1, 2, 3, 4, 5);\n\n        // Convert integers to strings\n        List<String> stringResults = convertIntegersToStrings(integers);\n        System.out.println(stringResults);  // Should print: [\"1\", \"2\", \"3\", \"4\", \"5\"]\n\n        // Square integers\n        List<Integer> squaredResults = squareIntegers(integers);\n        System.out.println(squaredResults);  // Should print: [1, 4, 9, 16, 25]\n\n        // Compute the factorial of each integer\n", "suffix": "        System.out.println(factorialResults);  // Should print: [1, 2, 6, 24, 120]\n        assert factorialResults.equals(List.of(1, 2, 6, 24, 120));\n    }\n\n    // Higher-order function to compute the factorial of a list of integers\n    public static List<Integer> computeFactorials(List<Integer> integers) {\n        return applyFunction(integers, DataProcessor::factorial);\n    }\n\n    // Helper method to compute the factorial of a single integer\n    public static int factorial(int n) {\n        if (n <= 1) return 1;\n        else return n * factorial(n - 1);\n    }\n}", "golden_completion": "        List<Integer> factorialResults = computeFactorials(integers);", "LLM_justification": "This scenario is designed to test the LLM's ability to recognize and continue a pattern involving higher-order functions in Java. The prefix establishes a clear pattern where a static method `applyFunction` is used to apply various transformations to a list of integers. The completion must adhere to this pattern by correctly implementing the call to `computeFactorials` which also utilizes the `applyFunction` method. The suffix continues the pattern with necessary assertions to validate the correct implementation.", "assertions": "", "gpt-35-turbo-completions": "List<Integer> factorialResults = computeFactorials(integers);"}
{"id": "25", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\n\n// Class to handle data transformation\npublic class DataTransformer {\n\n    // Method to apply a transformation function to a list of integers\n    public List<Integer> transformList(List<Integer> inputList, Function<Integer, Integer> transformFunction) {\n        List<Integer> resultList = new ArrayList<>();\n        for (Integer value : inputList) {\n            resultList.add(transformFunction.apply(value));\n        }\n        return resultList;\n    }\n\n    // Helper method to demonstrate transformation\n    public void demonstrateTransformation() {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5);\n        Function<Integer, Integer> squareFunction = x -> x * x;\n        Function<Integer, Integer> doubleFunction = x -> x * 2;\n\n        List<Integer> squaredNumbers = transformList(numbers, squareFunction);\n        System.out.println(\"Squared Numbers: \" + squaredNumbers);\n\n        List<Integer> doubledNumbers = transformList(numbers, doubleFunction);\n        System.out.println(\"Doubled Numbers: \" + doubledNumbers);\n    }\n\n    // Function to create a custom transformation function that multiplies by a factor\n    public Function<Integer, Integer> createMultiplierFunction(int factor) {\n", "suffix": "    }\n\n    public static void main(String[] args) {\n        DataTransformer transformer = new DataTransformer();\n        transformer.demonstrateTransformation();\n\n        // Custom multiplier function\n        Function<Integer, Integer> tripleFunction = transformer.createMultiplierFunction(3);\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5);\n        List<Integer> tripledNumbers = transformer.transformList(numbers, tripleFunction);\n        System.out.println(\"Tripled Numbers: \" + tripledNumbers);\n\n        // Assertions\n        assert tripledNumbers.equals(List.of(3, 6, 9, 12, 15)) : \"Tripled numbers are incorrect\";\n    }\n}", "golden_completion": "        return x -> x * factor;", "LLM_justification": "This example tests the ability of an LLM to recognize and continue a functional programming pattern using higher-order functions. The pattern involves applying transformation functions to a list of integers, and the completion requires creating a custom transformation function that multiplies by a given factor. This scenario is realistic as it demonstrates practical use of functional programming in Java, a common task in data processing and transformation.", "assertions": "", "gpt-35-turbo-completions": "return x -> x * factor;"}
{"id": "26", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\n\npublic class HigherOrderFunctionsExample {\n\n    public static <T, R> List<R> transform(List<T> list, Function<T, R> transformer) {\n        List<R> result = new ArrayList<>();\n        for (T item : list) {\n            result.add(transformer.apply(item));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example usage of transform function\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5);\n        Function<Integer, String> intToString = i -> \"Number \" + i;\n        List<String> numberStrings = transform(numbers, intToString);\n\n        // Print the results\n        for (String s : numberStrings) {\n            System.out.println(s);\n        }\n\n        // Another example usage of transform function\n        Function<Integer, Integer> squareFunction = i -> i * i;\n        List<Integer> squaredNumbers = transform(numbers, squareFunction);\n\n        // Print the results\n        for (Integer i : squaredNumbers) {\n            System.out.println(i);\n        }\n\n        // Placeholder for next transformation\n", "suffix": "        // Transform integers to their double values\n        Function<Integer, Double> toDoubleFunction = i -> i.doubleValue();\n        List<Double> doubleNumbers = transform(numbers, toDoubleFunction);\n\n        // Print the results\n        for (Double d : doubleNumbers) {\n            System.out.println(d);\n        }\n\n        // Assertions\n        assert numberStrings.equals(List.of(\"Number 1\", \"Number 2\", \"Number 3\", \"Number 4\", \"Number 5\"));\n        assert squaredNumbers.equals(List.of(1, 4, 9, 16, 25));\n        assert doubleNumbers.equals(List.of(1.0, 2.0, 3.0, 4.0, 5.0));\n    }\n}\n", "golden_completion": "        Function<Integer, Double> toDoubleFunction = i -> i.doubleValue();\n        List<Double> doubleNumbers = transform(numbers, toDoubleFunction);\n\n        // Print the results\n        for (Double d : doubleNumbers) {\n            System.out.println(d);\n        }\n\n        // Assertions\n        assert doubleNumbers.equals(List.of(1.0, 2.0, 3.0, 4.0, 5.0));\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of using higher-order functions in Java. The prefix sets up a generic higher-order function `transform` and demonstrates its usage with two different transformations. The task for the LLM is to add a third transformation that follows the established pattern. The suffix includes assertions to validate that the transformation and its usage are correct, ensuring the pattern is adhered to and functions as expected.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "27", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\n\npublic class AnalyticsProcessor {\n\n    public static List<Double> processAnalytics(List<Double> data, Function<Double, Double> transformer) {\n        List<Double> results = new ArrayList<>();\n        for (Double value : data) {\n            results.add(transformer.apply(value));\n        }\n        return results;\n    }\n\n    public static void main(String[] args) {\n        List<Double> data = new ArrayList<>();\n        data.add(1.0);\n        data.add(2.0);\n        data.add(3.0);\n\n        // Example usage of processAnalytics with a lambda function to square the values\n        List<Double> squaredData = processAnalytics(data, value -> value * value);\n        for (Double value : squaredData) {\n            System.out.println(value); // Should print 1.0, 4.0, 9.0\n        }\n\n        // Example usage of processAnalytics with a lambda function to halve the values\n        List<Double> halvedData = processAnalytics(data, value -> value / 2);\n        for (Double value : halvedData) {\n            System.out.println(value); // Should print 0.5, 1.0, 1.5\n        }\n\n", "suffix": "        // Example usage of processAnalytics with a lambda function to add 10 to the values\n        List<Double> incrementedData = processAnalytics(data, value -> value + 10);\n        for (Double value : incrementedData) {\n            System.out.println(value); // Should print 11.0, 12.0, 13.0\n        }\n\n        // Assertions\n        assert squaredData.size() == 3;\n        assert squaredData.get(0) == 1.0;\n        assert squaredData.get(1) == 4.0;\n        assert squaredData.get(2) == 9.0;\n\n        assert halvedData.size() == 3;\n        assert halvedData.get(0) == 0.5;\n        assert halvedData.get(1) == 1.0;\n        assert halvedData.get(2) == 1.5;\n\n        assert incrementedData.size() == 3;\n        assert incrementedData.get(0) == 11.0;\n        assert incrementedData.get(1) == 12.0;\n        assert incrementedData.get(2) == 13.0;\n    }\n}\n", "golden_completion": "        // Example usage of processAnalytics with a lambda function to negate the values\n        List<Double> negatedData = processAnalytics(data, value -> -value);\n        for (Double value : negatedData) {\n            System.out.println(value); // Should print -1.0, -2.0, -3.0\n        }\n\n        // Assertions\n        assert negatedData.size() == 3;\n        assert negatedData.get(0) == -1.0;\n        assert negatedData.get(1) == -2.0;\n        assert negatedData.get(2) == -3.0;\n", "LLM_justification": "This example tests the LLM's ability to recognize and extend the pattern of applying a transformation function to a list of data in the context of analytics. The pattern is established through multiple examples in the prefix, demonstrating different transformations using lambda functions. The golden completion follows this pattern by adding another transformation, while the suffix continues the pattern with further transformations and appropriate assertions to verify the correctness of the transformations.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "28", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\n\npublic class AnalyticsProcessor {\n\n\tprivate List<Double> data;\n\n\tpublic AnalyticsProcessor(List<Double> data) {\n\t\tthis.data = data;\n\t}\n\n\tpublic List<Double> processAnalytics(Function<Double, Double> processor) {\n\t\tList<Double> results = new ArrayList<>();\n\t\tfor (Double value : data) {\n\t\t\tresults.add(processor.apply(value));\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tList<Double> sampleData = new ArrayList<>();\n\t\tfor (double i = 1.0; i <= 10.0; i++) {\n\t\t\tsampleData.add(i);\n\t\t}\n\n\t\tAnalyticsProcessor processor = new AnalyticsProcessor(sampleData);\n\n\t\t// Pattern: Using processAnalytics with different Function implementations\n\t\tList<Double> squaredResults = processor.processAnalytics(new Function<Double, Double>() {\n\t\t\t@Override\n\t\t\tpublic Double apply(Double value) {\n\t\t\t\treturn value * value;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"Squared Results: \" + squaredResults);\n\n\t\tList<Double> halvedResults = processor.processAnalytics(new Function<Double, Double>() {\n\t\t\t@Override\n\t\t\tpublic Double apply(Double value) {\n\t\t\t\treturn value / 2;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"Halved Results: \" + halvedResults);\n\n\t\t// Next Function implementation here\n", "suffix": "\n\t\tList<Double> increasedResults = processor.processAnalytics(new Function<Double, Double>() {\n\t\t\t@Override\n\t\t\tpublic Double apply(Double value) {\n\t\t\t\treturn value + 5;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"Increased Results: \" + increasedResults);\n\n\t\t// Assertions\n\t\tassert squaredResults.size() == sampleData.size() : \"Size mismatch for squared results\";\n\t\tfor (int i = 0; i < squaredResults.size(); i++) {\n\t\t\tassert squaredResults.get(i) == sampleData.get(i) * sampleData.get(i) : \"Value mismatch in squared results at index \" + i;\n\t\t}\n\n\t\tassert halvedResults.size() == sampleData.size() : \"Size mismatch for halved results\";\n\t\tfor (int i = 0; i < halvedResults.size(); i++) {\n\t\t\tassert halvedResults.get(i) == sampleData.get(i) / 2 : \"Value mismatch in halved results at index \" + i;\n\t\t}\n\n\t\tassert increasedResults.size() == sampleData.size() : \"Size mismatch for increased results\";\n\t\tfor (int i = 0; i < increasedResults.size(); i++) {\n\t\t\tassert increasedResults.get(i) == sampleData.get(i) + 5 : \"Value mismatch in increased results at index \" + i;\n\t\t}\n\t}\n}\n", "golden_completion": "\t\tList<Double> doubledResults = processor.processAnalytics(new Function<Double, Double>() {\n\t\t\t@Override\n\t\t\tpublic Double apply(Double value) {\n\t\t\t\treturn value * 2;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"Doubled Results: \" + doubledResults);\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and continue a functional programming pattern using higher-order functions in the context of analytics processing. The prefix establishes a clear pattern of using the processAnalytics method with various Function implementations to perform different operations on data. The golden completion follows this pattern by adding a new Function implementation that doubles the values, which is consistent with the established pattern. The suffix includes different code that validates the pattern through assertions, ensuring both pattern adherence and functionality.", "assertions": "", "gpt-35-turbo-completions": "// Next Function implementation here\n\t\tList<Double> increasedResults = processor.processAnalytics(new Function<Double, Double>() {\n\t\t\t@Override\n\t\t\tpublic Double apply(Double value) {\n\t\t\t\treturn value + 5;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"Increased Results: \" + increasedResults);\n\n\t\t// Assertions\n\t\tassert squaredResults.size() == sampleData.size() : \"Size mismatch for squared results\";\n\t\tfor (int i = 0; i < squaredResults.size(); i++) {\n\t\t\tassert squaredResults.get(i) == sampleData.get(i) * sampleData.get(i) : \"Value mismatch in squared results at index \" + i;\n\t\t}\n\n\t\tassert halvedResults.size() == sampleData.size() : \"Size mismatch for halved results\";\n\t\tfor (int i = 0; i < halvedResults.size(); i++) {\n\t\t\tassert halvedResults.get(i) == sampleData.get(i) / 2 : \"Value mismatch in halved results at index \" + i;\n\t\t}\n\n\t\tassert increasedResults.size() == sampleData.size() : \"Size mismatch for increased results\";\n\t\tfor (int i = 0; i < increasedResults.size(); i++) {\n\t\t\tassert increasedResults.get(i) == sampleData.get(i) + 5 : \"Value mismatch in increased results at index \" + i;\n\t\t}\n\t}\n}\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\n\npublic class AnalyticsProcessor {\n\n\tprivate List<Double> data;\n\n\tpublic AnalyticsProcessor(List<Double> data) {\n\t\tthis.data = data;\n\t}\n\n\tpublic List<Double> processAnalytics(Function<Double, Double> processor) {\n\t\tList<Double> results = new ArrayList<>();\n\t\tfor (Double value : data) {\n\t\t\tresults.add(processor.apply(value));\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tList<Double> sampleData = new ArrayList<>();\n\t\tfor (double i = 1.0; i <= 10.0; i++) {\n\t\t\tsampleData.add(i);\n\t\t}\n\n\t\tAnalyticsProcessor processor = new AnalyticsProcessor(sampleData);\n\n\t\t// Pattern: Using processAnalytics with different Function implementations\n\t\tList<Double> squaredResults = processor.processAnalytics(new Function<Double, Double>() {\n\t\t\t@Override\n\t\t\tpublic Double apply(Double value) {\n\t\t\t\treturn value * value;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"Squared Results: \" + squaredResults);\n\n\t\tList<Double> halvedResults = processor.processAnalytics(new Function<Double, Double>() {\n\t\t\t@Override\n\t\t\tpublic Double apply(Double value) {\n\t\t\t\treturn value / 2;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"Halved Results: \" + halvedResults);\n\n\t\t// Next Function implementation here\n#TODO: You Code Here\n\t\t// Next Function implementation here\n\t\tList<Double> increasedResults = processor.processAnalytics(new Function<Double, Double>() {\n\t\t\t@Override\n\t\t\tpublic Double apply(Double value) {\n\t\t\t\treturn value + 5;\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"Increased Results: \" + increasedResults);\n\n\t\t// Assertions\n\t\tassert squaredResults.size() == sampleData.size() : \"Size mismatch for squared results\";\n\t\tfor (int i = 0; i < squaredResults.size(); i++) {\n\t\t\tassert squaredResults.get(i) == sampleData.get(i) * sampleData.get(i) : \"Value mismatch in squared results at index \" + i;\n\t\t}\n\n\t\tassert halvedResults.size() == sampleData.size() : \"Size mismatch for halved results\";\n\t\tfor (int i = 0; i < halvedResults.size(); i++) {\n\t\t\tassert halvedResults.get(i) == sampleData.get(i) / 2 : \"Value mismatch in halved results at index \" + i;\n\t\t}\n\n\t\tassert increasedResults"}
{"id": "29", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.function.Function;\n\n// This class demonstrates the use of higher-order functions to apply different transformations to a list of integers\npublic class HigherOrderFunctionsDemo {\n\n    // Method to apply a transformation to a list of integers\n    public static List<Integer> transformList(List<Integer> list, Function<Integer, Integer> transformation) {\n        List<Integer> result = new ArrayList<>();\n        for (Integer number : list) {\n            result.add(transformation.apply(number));\n        }\n        return result;\n    }\n\n    // Sample transformations\n    public static Function<Integer, Integer> square = x -> x * x;\n    public static Function<Integer, Integer> cube = x -> x * x * x;\n    public static Function<Integer, Integer> negate = x -> -x;\n\n    public static void main(String[] args) {\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 1; i <= 5; i++) {\n            numbers.add(i);\n        }\n\n        // Apply the square transformation\n        List<Integer> squaredNumbers = transformList(numbers, square);\n        System.out.println(\"Squared Numbers: \" + squaredNumbers);\n\n        // Apply the cube transformation\n        List<Integer> cubedNumbers = transformList(numbers, cube);\n        System.out.println(\"Cubed Numbers: \" + cubedNumbers);\n", "suffix": "\n\n        // Assertions\n        assert squaredNumbers.equals(List.of(1, 4, 9, 16, 25)) : \"Squared numbers are incorrect\";\n        assert cubedNumbers.equals(List.of(1, 8, 27, 64, 125)) : \"Cubed numbers are incorrect\";\n        assert negatedNumbers.equals(List.of(-1, -2, -3, -4, -5)) : \"Negated numbers are incorrect\";\n    }\n}\n", "golden_completion": "        // Apply the negate transformation\n        List<Integer> negatedNumbers = transformList(numbers, negate);\n        System.out.println(\"Negated Numbers: \" + negatedNumbers);", "LLM_justification": "This example tests the LLM's ability to recognize and complete the pattern of using higher-order functions to transform a list of integers. The prefix establishes the pattern by applying different transformations (square, cube) to a list and printing the results. The golden completion continues this pattern by applying another transformation (negate) and printing the result. The suffix includes assertions to verify the correctness of each transformation, ensuring that the LLM understands and correctly applies the pattern.", "assertions": "", "gpt-35-turbo-completions": "// Apply the negate transformation\n        List<Integer> negatedNumbers = transformList(numbers, negate);\n        System.out.println(\"Negated Numbers: \" + negatedNumbers);"}
{"id": "30", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.function.Function;\nimport org.junit.Assert;\n\npublic class HigherOrderFunctionExample {\n    public static <T, R> List<R> map(List<T> list, Function<T, R> mapper) {\n        List<R> result = new ArrayList<>();\n        for (T item : list) {\n            result.add(mapper.apply(item));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<String> names = List.of(\"Alice\", \"Bob\", \"Charlie\");\n        Function<String, Integer> lengthMapper = String::length;\n        List<Integer> lengths = map(names, lengthMapper);\n        Assert.assertEquals(List.of(5, 3, 7), lengths);\n\n        List<Integer> numbers = List.of(1, 2, 3, 4);\n        Function<Integer, Integer> squareMapper = x -> x * x;\n        List<Integer> squares = map(numbers, squareMapper);\n        Assert.assertEquals(List.of(1, 4, 9, 16), squares);\n\n        // Another example to be completed\n        List<Integer> moreNumbers = List.of(5, 6, 7);\n        Function<Integer, Integer> doubleMapper = x -> x * 2;\n", "suffix": "\n    }\n}\n", "golden_completion": "        List<Integer> doubles = map(moreNumbers, doubleMapper);\n        Assert.assertEquals(List.of(10, 12, 14), doubles);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a higher-order function pattern. The prefix establishes the pattern by defining a generic map function and using it with various mappers. The golden completion continues this pattern with a new mapper and validates the result using assertions. The suffix verifies that the pattern is correctly followed by checking the output of the map function against expected values.", "assertions": "", "gpt-35-turbo-completions": "Assert.assertEquals(List.of(10, 12, 14), doubles);"}
{"id": "31", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class AnalyticsProcessor {\n\n    // Utility method to convert a list of strings to upper case\n    public List<String> convertToUpper(List<String> input) {\n        return input.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }\n\n    // Utility method to calculate the length of each string in the list\n    public List<Integer> calculateLengths(List<String> input) {\n        return input.stream()\n                .map(String::length)\n                .collect(Collectors.toList());\n    }\n\n    // Higher-order function to process a list of strings with a given function\n    public <R> List<R> processList(List<String> input, Function<String, R> processor) {\n        return input.stream()\n                .map(processor)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        AnalyticsProcessor processor = new AnalyticsProcessor();\n        List<String> data = Arrays.asList(\"apple\", \"banana\", \"cherry\");\n\n        // Convert to upper case using the convertToUpper method\n        List<String> upperCaseData = processor.convertToUpper(data);\n        System.out.println(upperCaseData); // Output: [APPLE, BANANA, CHERRY]\n\n        // Calculate lengths using the calculateLengths method\n        List<Integer> lengths = processor.calculateLengths(data);\n        System.out.println(lengths); // Output: [5, 6, 6]\n\n        // Process list with a custom function to reverse each string\n        List<String> reversedData = processor.processList(data, s -> new StringBuilder(s).reverse().toString());\n        System.out.println(reversedData); // Output: [elppa, ananab, yrrehc]\n\n        // Process list with a custom function to get the first character of each string\n", "suffix": "\n        System.out.println(firstChars); // Output: [a, b, c]\n\n        // Assertions\n        assert upperCaseData.equals(Arrays.asList(\"APPLE\", \"BANANA\", \"CHERRY\")) : \"Uppercase conversion failed\";\n        assert lengths.equals(Arrays.asList(5, 6, 6)) : \"Length calculation failed\";\n        assert reversedData.equals(Arrays.asList(\"elppa\", \"ananab\", \"yrrehc\")) : \"Reversing strings failed\";\n        assert firstChars.equals(Arrays.asList('a', 'b', 'c')) : \"First character extraction failed\";\n\n        // Clean up resources if any\n    }\n}\n", "golden_completion": "        List<Character> firstChars = processor.processList(data, s -> s.charAt(0));\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of using higher-order functions in a functional programming style within the context of analytics processing. The pattern involves processing a list of strings with various functions and ensuring the correct application of the provided function to each element. The provided completion should correctly follow the established pattern of using the processList method with a lambda function, demonstrating understanding of higher-order functions in Java. The suffix includes assertions to verify the correctness and adherence to the pattern.", "assertions": "", "gpt-35-turbo-completions": "List<Character> firstChars = processor.processList(data, s -> s.charAt(0));"}
{"id": "32", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.function.Function;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\n\npublic class AnalyticsProcessor {\n\n    // Helper method to process a list of integers and apply a given function\n    public static List<Integer> processList(List<Integer> inputList, Function<Integer, Integer> processor) {\n        return inputList.stream()\n                .map(processor)\n                .collect(Collectors.toList());\n    }\n\n    // Method to calculate the square of an integer\n    public static Integer square(Integer x) {\n        return x * x;\n    }\n\n    // Method to calculate the cube of an integer\n    public static Integer cube(Integer x) {\n        return x * x * x;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 1; i <= 5; i++) {\n            numbers.add(i);\n        }\n\n        // Process the list with the square function\n        List<Integer> squaredNumbers = processList(numbers, AnalyticsProcessor::square);\n        System.out.println(\"Squared Numbers: \" + squaredNumbers);\n\n        // Process the list with the cube function\n        List<Integer> cubedNumbers = processList(numbers, AnalyticsProcessor::cube);\n        System.out.println(\"Cubed Numbers: \" + cubedNumbers);\n\n        // Process the list with a lambda function that doubles each number\n        List<Integer> doubledNumbers = processList(numbers, x -> x * 2);\n        System.out.println(\"Doubled Numbers: \" + doubledNumbers);\n\n        // Process the list with a lambda function that adds five to each number\n", "suffix": "\n\n        // Assertions to verify the correctness of the processing\n        assert incrementedByFiveNumbers.size() == 5 : \"Size of incrementedByFiveNumbers should be 5\";\n        assert incrementedByFiveNumbers.get(0) == 6 : \"First element should be 6\";\n        assert incrementedByFiveNumbers.get(1) == 7 : \"Second element should be 7\";\n        assert incrementedByFiveNumbers.get(2) == 8 : \"Third element should be 8\";\n        assert incrementedByFiveNumbers.get(3) == 9 : \"Fourth element should be 9\";\n        assert incrementedByFiveNumbers.get(4) == 10 : \"Fifth element should be 10\";\n    }\n}\n", "golden_completion": "        List<Integer> incrementedByFiveNumbers = processList(numbers, x -> x + 5);\n        System.out.println(\"Incremented by Five Numbers: \" + incrementedByFiveNumbers);", "LLM_justification": "This test case demonstrates the use of higher-order functions in the context of an analytics processor. The pattern of using the processList method with different processing functions is established clearly in the prefix. The golden_completion continues this pattern by applying a lambda function that increments each number by five. The suffix contains assertions to verify the correctness of the pattern implementation, ensuring that the model must understand and correctly apply the established pattern.", "assertions": "", "gpt-35-turbo-completions": "List<Integer> incrementedByFiveNumbers = processList(numbers, x -> x + 5);\n        System.out.println(\"Incremented by Five Numbers: \" + incrementedByFiveNumbers);"}
{"id": "33", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.function.Function;\n\npublic class AnalyticsPipeline {\n    private List<Integer> data;\n    \n    public AnalyticsPipeline(List<Integer> data) {\n        this.data = data;\n    }\n    \n    public List<Integer> processData(Function<Integer, Integer> processor) {\n        List<Integer> processedData = new ArrayList<>();\n        for (Integer value : data) {\n            processedData.add(processor.apply(value));\n        }\n        return processedData;\n    }\n    \n    public static void main(String[] args) {\n        List<Integer> inputData = Arrays.asList(1, 2, 3, 4, 5);\n        AnalyticsPipeline pipeline = new AnalyticsPipeline(inputData);\n        \n        Function<Integer, Integer> doubleFunction = x -> x * 2;\n        Function<Integer, Integer> squareFunction = x -> x * x;\n        \n        List<Integer> doubledData = pipeline.processData(doubleFunction);\n        List<Integer> squaredData = pipeline.processData(squareFunction);\n", "suffix": "\n        \n        assert doubledData.equals(Arrays.asList(2, 4, 6, 8, 10)) : \"Doubled data does not match expected values\";\n        assert squaredData.equals(Arrays.asList(1, 4, 9, 16, 25)) : \"Squared data does not match expected values\";\n        assert incrementedData.equals(Arrays.asList(2, 3, 4, 5, 6)) : \"Incremented data does not match expected values\";\n        \n        System.out.println(\"All assertions passed!\");\n    }\n}\n", "golden_completion": "        List<Integer> incrementedData = pipeline.processData(x -> x + 1);\n", "LLM_justification": "This test case is a good example because it demonstrates the use of higher-order functions in a practical scenario related to analytics. The pattern established is the use of the processData method to apply different transformations to the data. The golden completion follows this pattern by adding another transformation function. The assertions in the suffix verify that each transformation function works correctly, ensuring pattern adherence and functionality.", "assertions": "", "gpt-35-turbo-completions": "Function<Integer, Integer> incrementFunction = x -> x + 1;\n        List<Integer> incrementedData = pipeline.processData(incrementFunction);"}
{"id": "34", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class AnalyticsProcessor {\n\n    // Function to process a list of integers and return their squares\n    public static List<Integer> processAndSquare(List<Integer> input) {\n        return input.stream()\n                .map(i -> i * i)\n                .collect(Collectors.toList());\n    }\n\n    // Function to process a list of strings and return their lengths\n    public static List<Integer> processAndLength(List<String> input) {\n        return input.stream()\n                .map(String::length)\n                .collect(Collectors.toList());\n    }\n\n    // Higher-order function to process a list with a given function\n    public static <T, R> List<R> processList(List<T> input, Function<T, R> processor) {\n        return input.stream()\n                .map(processor)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 1; i <= 5; i++) {\n            numbers.add(i);\n        }\n\n        List<String> words = new ArrayList<>();\n        words.add(\"hello\");\n        words.add(\"world\");\n        words.add(\"java\");\n        words.add(\"programming\");\n\n        // Using processAndSquare\n        List<Integer> squaredNumbers = processAndSquare(numbers);\n        System.out.println(\"Squared Numbers: \" + squaredNumbers);\n\n        // Using processAndLength\n        List<Integer> wordLengths = processAndLength(words);\n        System.out.println(\"Word Lengths: \" + wordLengths);\n\n        // Using processList with a lambda function to double the numbers\n        List<Integer> doubledNumbers = processList(numbers, i -> i * 2);\n        System.out.println(\"Doubled Numbers: \" + doubledNumbers);\n", "suffix": "\n        // Using processList with a lambda function to reverse the strings\n        List<String> reversedWords = processList(words, s -> new StringBuilder(s).reverse().toString());\n        System.out.println(\"Reversed Words: \" + reversedWords);\n\n        // Assertions\n        assert squaredNumbers.equals(List.of(1, 4, 9, 16, 25));\n        assert wordLengths.equals(List.of(5, 5, 4, 11));\n        assert doubledNumbers.equals(List.of(2, 4, 6, 8, 10));\n        assert reversedWords.equals(List.of(\"olleh\", \"dlrow\", \"avaj\", \"gnimmargorp\"));\n    }\n}\n", "golden_completion": "        // Using processList with a lambda function to convert strings to uppercase\n        List<String> uppercasedWords = processList(words, String::toUpperCase);\n        System.out.println(\"Uppercased Words: \" + uppercasedWords);\n\n        // Assertions\n        assert uppercasedWords.equals(List.of(\"HELLO\", \"WORLD\", \"JAVA\", \"PROGRAMMING\"));\n", "LLM_justification": "This scenario tests an LLM's ability to recognize and continue a pattern of processing lists using higher-order functions in the context of analytics. The prefix establishes multiple examples of using higher-order functions to transform lists, creating a clear pattern. The golden completion follows this pattern by adding another transformation (converting strings to uppercase) and includes assertions to verify the correctness of the transformation. The suffix continues with a different transformation (reversing strings) and includes assertions for all transformations, ensuring the pattern is maintained and the functionality is correct.", "assertions": "", "gpt-35-turbo-completions": "// Using processList with a lambda function to calculate the square root of the numbers\n        List<Double> squareRoots = processList(numbers, Math::sqrt);\n        System.out.println(\"Square Roots: \" + squareRoots);\n#TODO: You Code Here\n        // Using processList with a lambda function to capitalize the words\n        List<String> capitalizedWords = processList(words, s -> s.toUpperCase());\n        System.out.println(\"Capitalized Words: \" + capitalizedWords);\n#TODO: You Code Here\n        // Using processList with a lambda function to add a prefix to the words\n        List<String> prefixedWords = processList(words, s -> \"prefix_\" + s);\n        System.out.println(\"Prefixed Words: \" + prefixedWords);\n#TODO: You Code Here\n        // Using processList with a lambda function to add a suffix to the words\n        List<String> suffixedWords = processList(words, s -> s + \"_suffix\");\n        System.out.println(\"Suffixed Words: \" + suffixedWords);\n#TODO: You Code Here\n        // Using processList with a lambda function to remove the first character of the words\n        List<String> removedFirstChars = processList(words, s -> s.substring(1));\n        System.out.println(\"Removed First Characters: \" + removedFirstChars);\n#TODO: You Code Here\n        // Using processList with a lambda function to remove the last character of the words\n        List<String> removedLastChars = processList(words, s -> s.substring(0, s.length() - 1));\n        System.out.println(\"Removed Last Characters: \" + removedLastChars);\n#TODO: You Code Here\n        // Using processList with a lambda function to reverse the strings\n        List<String> reversedWords = processList(words, s -> new StringBuilder(s).reverse().toString());\n        System.out.println(\"Reversed Words: \" + reversedWords);\n#TODO: You Code Here\n        // Assertions\n        assert squaredNumbers.equals(List.of(1, 4, 9, 16, 25));\n        assert wordLengths.equals(List.of(5, 5, 4, 11));\n        assert doubledNumbers.equals(List.of(2, 4, 6, 8, 10));\n        assert reversedWords.equals(List.of(\"olleh\", \"dlrow\", \"avaj\", \"gnimmargorp\"));\n    }\n}\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class AnalyticsProcessor {\n\n    // Function to process a list of integers and return their squares\n    public static List<Integer> processAndSquare(List<Integer> input) {\n        return input.stream()\n                .map(i -> i * i)\n                .collect(Collectors.toList());\n    }\n\n    // Function to process a list of strings and return their lengths\n    public static List<Integer> processAndLength(List<String> input) {\n        return input.stream()\n                .map(String::length)\n                .collect(Collectors.toList());\n    }\n\n    // Higher-order function to process a list with a given function\n    public static <T, R> List<R> processList(List<T> input, Function<T, R> processor) {\n        return input.stream()\n                .map(processor)\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = new ArrayList<>();\n        for (int i = 1; i <= 5; i++) {\n            numbers.add(i);\n        }\n\n        List<String> words = new ArrayList<>();\n        words.add(\"hello\");\n        words.add(\"world\");\n        words.add(\"java\");\n        words.add(\"programming\");\n\n        // Using processAndSquare\n        List<Integer> squaredNumbers = processAndSquare(numbers);\n        System.out.println(\"Squared Numbers: \" + squaredNumbers);\n\n        // Using processAndLength"}
{"id": "35", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class AnalyticsProcessor {\n\n    private List<Double> data;\n\n    public AnalyticsProcessor(List<Double> data) {\n        this.data = data;\n    }\n\n    // Function to calculate the average\n    public double calculateAverage() {\n        return data.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n    }\n\n    // Function to calculate the sum\n    public double calculateSum() {\n        return data.stream().mapToDouble(Double::doubleValue).sum();\n    }\n\n    // Function to find the maximum value\n    public double calculateMax() {\n        return data.stream().mapToDouble(Double::doubleValue).max().orElse(Double.MIN_VALUE);\n    }\n\n    // Function to find the minimum value\n    public double calculateMin() {\n        return data.stream().mapToDouble(Double::doubleValue).min().orElse(Double.MAX_VALUE);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Double> data = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);\n        AnalyticsProcessor processor = new AnalyticsProcessor(data);\n\n        double average = processor.calculateAverage();\n        System.out.println(\"Average: \" + average);", "suffix": "\n        double sum = processor.calculateSum();\n        System.out.println(\"Sum: \" + sum);\n        assert sum == 15.0;\n\n        double max = processor.calculateMax();\n        System.out.println(\"Max: \" + max);\n        assert max == 5.0;\n\n        double min = processor.calculateMin();\n        System.out.println(\"Min: \" + min);\n        assert min == 1.0;\n    }\n}\n", "golden_completion": "\n        assert average == 3.0;\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving functional programming with Java Streams in the context of analytics. The prefix establishes multiple methods that calculate statistical metrics (average, sum, max, min) using streams. The completion requires the LLM to follow this pattern by adding an assertion for the average calculation, ensuring consistency with the established method of verification. The suffix continues by asserting the correctness of the sum, max, and min calculations, and includes print statements for output verification.", "assertions": "", "gpt-35-turbo-completions": "assert average == 3.0;"}
{"id": "36", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.function.Function;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class AnalyticsProcessor {\n\n    // Function to process metrics with a given transformation\n    private static <T, R> List<R> processMetrics(List<T> metrics, Function<T, R> transformer) {\n        return metrics.stream()\n                      .map(transformer)\n                      .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        // Example metrics\n        List<Integer> metrics = Arrays.asList(1, 2, 3, 4, 5);\n\n        // Example transformations\n        Function<Integer, Integer> square = x -> x * x;\n        Function<Integer, String> stringify = x -> \"Metric: \" + x;\n\n        // Process metrics with the square transformation\n        List<Integer> squaredMetrics = processMetrics(metrics, square);\n        for (Integer metric : squaredMetrics) {\n            System.out.println(\"Squared Metric: \" + metric);\n        }\n\n        // Process metrics with the stringify transformation\n        List<String> stringMetrics = processMetrics(metrics, stringify);\n        for (String metric : stringMetrics) {\n            System.out.println(metric);\n        }\n        // Process metrics with a custom transformation to halve values\n", "suffix": "\n\n        // Assertions\n        assert squaredMetrics.equals(Arrays.asList(1, 4, 9, 16, 25));\n        assert stringMetrics.equals(Arrays.asList(\"Metric: 1\", \"Metric: 2\", \"Metric: 3\", \"Metric: 4\", \"Metric: 5\"));\n        assert halvedMetrics.equals(Arrays.asList(0.5, 1.0, 1.5, 2.0, 2.5));\n    }\n}\n", "golden_completion": "        // Process metrics with a custom transformation to halve values\n        Function<Integer, Double> halve = x -> x / 2.0;\n        List<Double> halvedMetrics = processMetrics(metrics, halve);\n        for (Double metric : halvedMetrics) {\n            System.out.println(\"Halved Metric: \" + metric);\n        }\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue a higher-order function pattern in the context of analytics processing. The pattern of applying different transformations to a list of metrics using higher-order functions is well-established in the prefix. The golden completion demonstrates the continuation of this pattern with a new transformation. The suffix includes assertions to verify that the pattern is correctly followed and the transformations produce the expected results. This test case ensures that the LLM can identify and extend the pattern appropriately, adhering to best practices in functional programming and analytics.", "assertions": "", "gpt-35-turbo-completions": "Function<Integer, Double> halve = x -> x / 2.0;\n        List<Double> halvedMetrics = processMetrics(metrics, halve);\n        for (Double metric : halvedMetrics) {\n            System.out.println(\"Halved Metric: \" + metric);\n        }"}
{"id": "37", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport org.junit.Assert;\n\npublic class MetricsCalculator {\n    private Map<String, List<Integer>> metricsData;\n\n    public MetricsCalculator() {\n        this.metricsData = new HashMap<>();\n    }\n\n    public void addMetricData(String metricName, int value) {\n        metricsData.computeIfAbsent(metricName, k -> new ArrayList<>()).add(value);\n    }\n\n    public double calculateAverage(String metricName) {\n        List<Integer> data = metricsData.get(metricName);\n        if (data == null || data.isEmpty()) {\n            throw new IllegalArgumentException(\"No data available for metric: \" + metricName);\n        }\n        return data.stream().mapToInt(Integer::intValue).average().orElse(0.0);\n    }\n\n    public int calculateSum(String metricName) {\n        List<Integer> data = metricsData.get(metricName);\n        if (data == null || data.isEmpty()) {\n            throw new IllegalArgumentException(\"No data available for metric: \" + metricName);\n        }\n        return data.stream().mapToInt(Integer::intValue).sum();\n    }\n\n    // Additional methods following the same pattern\n", "suffix": "\n    public int calculateMax(String metricName) {\n        List<Integer> data = metricsData.get(metricName);\n        if (data == null || data.isEmpty()) {\n            throw new IllegalArgumentException(\"No data available for metric: \" + metricName);\n        }\n        return data.stream().mapToInt(Integer::intValue).max().orElseThrow(NoSuchElementException::new);\n    }\n\n    public static void main(String[] args) {\n        MetricsCalculator calculator = new MetricsCalculator();\n        calculator.addMetricData(\"response_time\", 100);\n        calculator.addMetricData(\"response_time\", 200);\n        calculator.addMetricData(\"response_time\", 300);\n\n        double average = calculator.calculateAverage(\"response_time\");\n        int sum = calculator.calculateSum(\"response_time\");\n        int max = calculator.calculateMax(\"response_time\");\n\n        Assert.assertEquals(200.0, average, 0.01);\n        Assert.assertEquals(600, sum);\n        Assert.assertEquals(300, max);\n\n        // Test edge cases\n        boolean exceptionThrown = false;\n        try {\n            calculator.calculateAverage(\"non_existent_metric\");\n        } catch (IllegalArgumentException e) {\n            exceptionThrown = true;\n        }\n        Assert.assertTrue(exceptionThrown);\n    }\n}", "golden_completion": "\n    public int calculateMin(String metricName) {\n        List<Integer> data = metricsData.get(metricName);\n        if (data == null || data.isEmpty()) {\n            throw new IllegalArgumentException(\"No data available for metric: \" + metricName);\n        }\n        return data.stream().mapToInt(Integer::intValue).min().orElseThrow(NoSuchElementException::new);\n    }\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and continue a pattern in the implementation of analytics functions within a class. The pattern involves retrieving a list of integers for a given metric name and then performing a specific aggregation operation on that list using Java Streams. The golden completion should follow this established pattern to compute the minimum value, while the suffix continues the pattern by computing the maximum value and includes assertions to validate correct functionality.", "assertions": "", "gpt-35-turbo-completions": "public int calculateMin(String metricName) {\n        List<Integer> data = metricsData.get(metricName);\n        if (data == null || data.isEmpty()) {\n            throw new IllegalArgumentException(\"No data available for metric: \" + metricName);\n        }\n        return data.stream().mapToInt(Integer::intValue).min().orElseThrow(NoSuchElementException::new);\n    }"}
{"id": "38", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\n\npublic class AnalyticsProcessor {\n\n    private List<Integer> data;\n\n    public AnalyticsProcessor(List<Integer> data) {\n        this.data = data;\n    }\n\n    public List<Double> processData(Function<Integer, Double> transformation) {\n        List<Double> result = new ArrayList<>();\n        for (Integer value : data) {\n            result.add(transformation.apply(value));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> sampleData = List.of(1, 2, 3, 4, 5);\n        AnalyticsProcessor processor = new AnalyticsProcessor(sampleData);\n\n        // Using lambda expressions to define transformations\n        List<Double> squaredData = processor.processData(value -> Math.pow(value, 2));\n        List<Double> logData = processor.processData(value -> Math.log(value));\n", "suffix": "        // Assertions to verify the transformations\n        assert squaredData.equals(List.of(1.0, 4.0, 9.0, 16.0, 25.0)) : \"Squared data transformation failed\";\n        assert logData.equals(List.of(0.0, 0.6931471805599453, 1.0986122886681098, 1.3862943611198906, 1.6094379124341003)) : \"Log data transformation failed\";\n\n        // Additional transformation and assertion\n        List<Double> sqrtData = processor.processData(value -> Math.sqrt(value));\n        assert sqrtData.equals(List.of(1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979)) : \"Square root data transformation failed\";\n    }\n}\n", "golden_completion": "        List<Double> sqrtData = processor.processData(value -> Math.sqrt(value));\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue the pattern of using higher-order functions to process data in an analytics context. The pattern of defining lambda expressions for transformations is established in the prefix. The golden completion continues this pattern by adding a new transformation using Math.sqrt, which is a common mathematical operation in data processing. The suffix contains assertions that verify the correctness of each transformation, ensuring that the pattern is followed correctly and that the code behaves as expected.", "assertions": "", "gpt-35-turbo-completions": "// Using method references to define transformations\n        List<Double> squaredData = processor.processData(Math::pow);\n        List<Double> logData = processor.processData(Math::log);"}
{"id": "39", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MetricsCalculator {\n\n    public interface Metric {\n        double calculate(List<Double> data);\n    }\n\n    public static class AverageMetric implements Metric {\n        @Override\n        public double calculate(List<Double> data) {\n            double sum = 0;\n            for (double value : data) {\n                sum += value;\n            }\n            return sum / data.size();\n        }\n    }\n\n    public static class MedianMetric implements Metric {\n        @Override\n        public double calculate(List<Double> data) {\n            List<Double> sortedData = new ArrayList<>(data);\n            sortedData.sort(Double::compareTo);\n            int middle = sortedData.size() / 2;\n            if (sortedData.size() % 2 == 0) {\n                return (sortedData.get(middle - 1) + sortedData.get(middle)) / 2.0;\n            } else {\n                return sortedData.get(middle);\n            }\n        }\n    }\n\n    // Method to calculate a given metric on the data\n    public double calculateMetric(Metric metric, List<Double> data) {\n        return metric.calculate(data);\n    }\n\n    public static void main(String[] args) {\n        MetricsCalculator calculator = new MetricsCalculator();\n        List<Double> data = List.of(1.0, 2.0, 3.0, 4.0, 5.0);\n        Metric averageMetric = new AverageMetric();\n        Metric medianMetric = new MedianMetric();\n\n        double averageResult = calculator.calculateMetric(averageMetric, data);\n        double medianResult = calculator.calculateMetric(medianMetric, data);\n\n        System.out.println(\"Average: \" + averageResult);\n        System.out.println(\"Median: \" + medianResult);\n\n        // Assertions\n        assert averageResult == 3.0 : \"Average calculation is incorrect\";\n        assert medianResult == 3.0 : \"Median calculation is incorrect\";\n\n        // Adding new metric implementation\n", "suffix": "        Metric sumMetric = new Metric() {\n            @Override\n            public double calculate(List<Double> data) {\n                double sum = 0;\n                for (double value : data) {\n                    sum += value;\n                }\n                return sum;\n            }\n        };\n\n        double sumResult = calculator.calculateMetric(sumMetric, data);\n        System.out.println(\"Sum: \" + sumResult);\n        assert sumResult == 15.0 : \"Sum calculation is incorrect\";\n    }\n}", "golden_completion": "        Metric maxMetric = new Metric() {\n            @Override\n            public double calculate(List<Double> data) {\n                double max = Double.MIN_VALUE;\n                for (double value : data) {\n                    if (value > max) {\n                        max = value;\n                    }\n                }\n                return max;\n            }\n        };\n\n        double maxResult = calculator.calculateMetric(maxMetric, data);\n        System.out.println(\"Max: \" + maxResult);\n        assert maxResult == 5.0 : \"Max calculation is incorrect\";", "LLM_justification": "This example tests the LLM's ability to recognize and continue the pattern of implementing different metric calculations using the Metric interface and anonymous classes. The prefix sets up the pattern with two concrete implementations (AverageMetric and MedianMetric), and the golden completion requires the LLM to follow this pattern to create a new metric calculation (MaxMetric). The suffix then continues with another different metric calculation (SumMetric), ensuring the LLM understands the pattern and can apply it consistently. Assertions are included to verify correctness and adherence to the pattern.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "40", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.function.*;\n\npublic class AnalyticsReport {\n\n    public static class Metric {\n        private String name;\n        private int value;\n\n        public Metric(String name, int value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getValue() {\n            return value;\n        }\n    }\n\n    public static List<Metric> generateMetrics() {\n        List<Metric> metrics = new ArrayList<>();\n        metrics.add(new Metric(\"metric1\", 100));\n        metrics.add(new Metric(\"metric2\", 200));\n        metrics.add(new Metric(\"metric3\", 300));\n        return metrics;\n    }\n\n    public static List<Integer> processMetrics(List<Metric> metrics, Function<Metric, Integer> processor) {\n        List<Integer> results = new ArrayList<>();\n        for (Metric metric : metrics) {\n            results.add(processor.apply(metric));\n        }\n        return results;\n    }\n\n    public static void main(String[] args) {\n        List<Metric> metrics = generateMetrics();\n        // Add 50\n", "suffix": "        List<Integer> processedValues = processMetrics(metrics, metric -> metric.getValue() * 2);\n        List<Integer> expectedValues = Arrays.asList(200, 400, 600);\n\n        // Assertions\n        for (int i = 0; i < processedValues.size(); i++) {\n            assert processedValues.get(i).equals(expectedValues.get(i)) : \"Value mismatch at index \" + i;\n        }\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "        List<Integer> processedValues = processMetrics(metrics, metric -> metric.getValue() + 50);\n        List<Integer> expectedValues = Arrays.asList(150, 250, 350);\n\n        // Assertions\n        for (int i = 0; i < processedValues.size(); i++) {\n            assert processedValues.get(i).equals(expectedValues.get(i)) : \"Value mismatch at index \" + i;\n        }\n\n        System.out.println(\"All assertions passed.\");\n", "LLM_justification": "This test case involves higher-order functions within the context of analytics, specifically processing metrics using a lambda expression. The pattern established in the prefix is the use of the `processMetrics` method, which applies a given function to each metric in a list. The golden completion must follow this pattern by providing a different lambda function while adhering to the established method call and processing structure. The suffix verifies the correct application of the pattern with assertions that ensure the function's output meets expectations. This scenario tests the LLM's ability to recognize and continue the pattern of higher-order function usage in a realistic analytics context.", "assertions": "", "gpt-35-turbo-completions": "List<Integer> processedValues = processMetrics(metrics, metric -> metric.getValue() + 50);\n        List<Integer> expectedValues = Arrays.asList(150, 250, 350);\n\n        // Assertions\n        for (int i = 0; i < processedValues.size(); i++) {\n            assert processedValues.get(i).equals(expectedValues.get(i)) : \"Value mismatch at index \" + i;\n        }\n\n        // Multiply by 2\n#TODO: You Code Here"}
{"id": "41", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.function.Function;\n\npublic class AnalyticsProcessor {\n    private List<Double> data;\n\n    public AnalyticsProcessor(List<Double> data) {\n        this.data = data;\n    }\n\n    public double processData(Function<List<Double>, Double> operation) {\n        return operation.apply(data);\n    }\n\n    public static void main(String[] args) {\n        List<Double> dataset = new ArrayList<>();\n        dataset.add(10.0);\n        dataset.add(20.0);\n        dataset.add(30.0);\n        AnalyticsProcessor processor = new AnalyticsProcessor(dataset);\n\n        // Example: Calculating the sum of the dataset\n        Function<List<Double>, Double> sumOperation = new Function<List<Double>, Double>() {\n            @Override\n            public Double apply(List<Double> data) {\n                double sum = 0.0;\n                for (Double value : data) {\n                    sum += value;\n                }\n                return sum;\n            }\n        };\n\n        double sumResult = processor.processData(sumOperation);\n        System.out.println(\"Sum: \" + sumResult);\n        assert sumResult == 60.0;\n\n        // Example: Calculating the average of the dataset\n        Function<List<Double>, Double> averageOperation = new Function<List<Double>, Double>() {\n            @Override\n            public Double apply(List<Double> data) {\n                double sum = 0.0;\n                for (Double value : data) {\n                    sum += value;\n                }\n                return sum / data.size();\n            }\n        };\n\n        double averageResult = processor.processData(averageOperation);\n        System.out.println(\"Average: \" + averageResult);\n        assert averageResult == 20.0;\n\n        // Example: Calculating the maximum of the dataset", "suffix": "        Function<List<Double>, Double> minOperation = new Function<List<Double>, Double>() {\n            @Override\n            public Double apply(List<Double> data) {\n                double min = Double.MAX_VALUE;\n                for (Double value : data) {\n                    if (value < min) {\n                        min = value;\n                    }\n                }\n                return min;\n            }\n        };\n\n        double minResult = processor.processData(minOperation);\n        System.out.println(\"Min: \" + minResult);\n        assert minResult == 10.0;\n\n        // Example: Calculating the range of the dataset\n        Function<List<Double>, Double> rangeOperation = new Function<List<Double>, Double>() {\n            @Override\n            public Double apply(List<Double> data) {\n                double min = Double.MAX_VALUE;\n                double max = Double.MIN_VALUE;\n                for (Double value : data) {\n                    if (value < min) {\n                        min = value;\n                    }\n                    if (value > max) {\n                        max = value;\n                    }\n                }\n                return max - min;\n            }\n        };\n\n        double rangeResult = processor.processData(rangeOperation);\n        System.out.println(\"Range: \" + rangeResult);\n        assert rangeResult == 20.0;\n    }\n}", "golden_completion": "        Function<List<Double>, Double> maxOperation = new Function<List<Double>, Double>() {\n            @Override\n            public Double apply(List<Double> data) {\n                double max = Double.MIN_VALUE;\n                for (Double value : data) {\n                    if (value > max) {\n                        max = value;\n                    }\n                }\n                return max;\n            }\n        };\n\n        double maxResult = processor.processData(maxOperation);\n        System.out.println(\"Max: \" + maxResult);\n        assert maxResult == 30.0;", "LLM_justification": "This is a good test case because it involves higher-order functions in the context of analytics, where operations like sum, average, and max are common. The pattern of defining operations as Function objects and passing them to the processData method is clear and repeated multiple times. The golden completion requires the model to recognize this pattern and correctly implement the max operation. The suffix continues the pattern with different operations, and assertions ensure the correctness of the implementation.", "assertions": "", "gpt-35-turbo-completions": "Function<List<Double>, Double> maxOperation = new Function<List<Double>, Double>() {\n            @Override\n            public Double apply(List<Double> data) {\n                double max = Double.MIN_VALUE;\n                for (Double value : data) {\n                    if (value > max) {\n                        max = value;\n                    }\n                }\n                return max;\n            }\n        };\n\n        double maxResult = processor.processData(maxOperation);\n        System.out.println(\"Max: \" + maxResult);\n        assert maxResult == 30.0;\n\n        // Example: Calculating the minimum of the dataset"}
{"id": "42", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class AnalyticsTool {\n    private Map<String, Integer> data;\n\n    public AnalyticsTool() {\n        data = new HashMap<>();\n    }\n\n    public void incrementMetric(String metric) {\n        data.put(metric, data.getOrDefault(metric, 0) + 1);\n    }\n\n    public void applyToAllMetrics(Function<Integer, Integer> function) {\n        for (Map.Entry<String, Integer> entry : data.entrySet()) {\n            data.put(entry.getKey(), function.apply(entry.getValue()));\n        }\n    }\n\n    public void doubleAllMetrics() {\n        applyToAllMetrics(x -> x * 2);\n    }\n\n    public void squareAllMetrics() {\n        applyToAllMetrics(x -> x * x);\n    }\n\n    public Map<String, Integer> getMetrics() {\n        return data;\n    }\n\n    public static void main(String[] args) {\n        AnalyticsTool tool = new AnalyticsTool();\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"clicks\");\n        tool.doubleAllMetrics();\n        tool.squareAllMetrics();\n", "suffix": "        tool.incrementMetric(\"signups\");\n        tool.applyToAllMetrics(x -> x - 1);\n\n        // Assertions\n        assert tool.getMetrics().get(\"page_views\") == 15 : \"Expected page_views to be 15\";\n        assert tool.getMetrics().get(\"clicks\") == 3 : \"Expected clicks to be 3\";\n        assert tool.getMetrics().get(\"signups\") == 0 : \"Expected signups to be 0\";\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "        tool.applyToAllMetrics(x -> x + 1);\n", "LLM_justification": "This test case demonstrates the use of higher-order functions in a practical analytics context. The pattern of applying a function to all metrics is established through the applyToAllMetrics method and its uses in doubleAllMetrics and squareAllMetrics methods. The golden completion must follow this pattern by applying another transformation function to all metrics. The suffix then continues with different operations and includes assertions to verify that the pattern is correctly followed and the functionality is as expected.", "assertions": "", "gpt-35-turbo-completions": "tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.squareAllMetrics();\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"signups\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"clicks\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.incrementMetric(\"page_views\");\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.doubleAllMetrics();\n        tool.double"}
{"id": "43", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class EncryptionUtils {\n\n    private static final String ALGORITHM = \"AES\";\n\n    // Method to generate a key\n    public static SecretKey generateKey() throws NoSuchAlgorithmException {\n        KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);\n        keyGen.init(256);\n        return keyGen.generateKey();\n    }\n\n    // Method to encrypt data\n    public static byte[] encrypt(byte[] data, SecretKey key) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        return cipher.doFinal(data);\n    }\n\n    // Method to decrypt data\n    public static byte[] decrypt(byte[] encryptedData, SecretKey key) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        return cipher.doFinal(encryptedData);\n    }\n\n    public static void main(String[] args) {\n        try {\n            SecretKey key = generateKey();\n            String data = \"Sensitive Data\";\n            byte[] encryptedData = encrypt(data.getBytes(), key);\n            byte[] decryptedData = decrypt(encryptedData, key);\n            \n            // Assertions\n            assert Arrays.equals(data.getBytes(), decryptedData);\n            System.out.println(\"Encryption and decryption successful.\");\n\n", "suffix": "\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "golden_completion": "            String moreData = \"More Sensitive Data\";\n            byte[] moreEncryptedData = encrypt(moreData.getBytes(), key);\n            byte[] moreDecryptedData = decrypt(moreEncryptedData, key);\n\n            // Assertions\n            assert Arrays.equals(moreData.getBytes(), moreDecryptedData);\n            System.out.println(\"Further encryption and decryption successful.\");\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of encryption and decryption operations using the AES algorithm. The prefix establishes a clear pattern with methods for generating keys, encrypting, and decrypting data, and includes initial assertions. The golden completion continues this pattern with additional encryptions and decryptions, followed by assertions. The suffix includes further operations and assertions to ensure the pattern is correctly identified and adhered to.", "assertions": "", "gpt-35-turbo-completions": "// Print the encrypted data\n            System.out.println(\"Encrypted Data: \" + new String(encryptedData));\n\n            // Print the decrypted data\n            System.out.println(\"Decrypted Data: \" + new String(decryptedData));"}
{"id": "44", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.*;\n\nclass EncryptionUtils {\n\tpublic static String encrypt(String data, Function<String, String> encryptionStrategy) {\n\t\treturn encryptionStrategy.apply(data);\n\t}\n\n\tpublic static Function<String, String> caesarCipher(int shift) {\n\t\treturn (data) -> data.chars()\n\t\t\t.map(c -> c + shift)\n\t\t\t.mapToObj(c -> String.valueOf((char) c))\n\t\t\t.collect(Collectors.joining());\n\t}\n\n\tpublic static Function<String, String> reverse() {\n\t\treturn (data) -> new StringBuilder(data).reverse().toString();\n\t}\n\n\tpublic static Function<String, String> xorCipher(char key) {\n\t\treturn (data) -> data.chars()\n\t\t\t.map(c -> c ^ key)\n\t\t\t.mapToObj(c -> String.valueOf((char) c))\n\t\t\t.collect(Collectors.joining());\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tString original = \"Hello World!\";\n\t\tFunction<String, String> caesar = EncryptionUtils.caesarCipher(3);\n\t\tFunction<String, String> reversed = EncryptionUtils.reverse();\n\t\tString encryptedCaesar = EncryptionUtils.encrypt(original, caesar);\n\t\tString encryptedReversed = EncryptionUtils.encrypt(original, reversed);\n\n\t\t// Assertions to verify the correctness of the pattern followed\n\t\tassert encryptedCaesar.equals(\"Khoor#Zruog$\");\n\t\tassert encryptedReversed.equals(\"!dlroW olleH\");\n\n\t\t// Additional encryption strategies\n", "suffix": "\n\n\t\t// Assertions to verify the correctness of the pattern followed\n\t\tassert encryptedXor.equals(\"!DCCDKV'DNCZ\");\n\n\t\tSystem.out.println(\"All encryptions and assertions passed.\");\n\t}\n}\n", "golden_completion": "\t\tFunction<String, String> xor = EncryptionUtils.xorCipher('A');\n\t\tString encryptedXor = EncryptionUtils.encrypt(original, xor);\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete a pattern involving higher-order functions and encryption strategies. The prefix establishes a clear pattern of defining encryption strategies using higher-order functions and applying these strategies using a common method. The golden completion involves creating a new encryption strategy using the same pattern. The suffix includes assertions to validate the encrypted outputs and ensure the pattern is correctly followed.", "assertions": "", "gpt-35-turbo-completions": "Function<String, String> xor = EncryptionUtils.xorCipher('A');\n\t\tString encryptedXor = EncryptionUtils.encrypt(original, xor);"}
{"id": "45", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport org.junit.Assert;\npublic class MetricsCalculator {\n\tprivate List<Integer> data;\n\tpublic MetricsCalculator(List<Integer> data) {\n\t\tthis.data = data;\n\t}\n\t// Method to calculate the mean of the data\n\tpublic double calculateMean() {\n\t\tOptionalDouble mean = data.stream().mapToInt(Integer::intValue).average();\n\t\tif (mean.isPresent()) {\n\t\t\treturn mean.getAsDouble();\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Data list is empty\");\n\t\t}\n\t}\n\t// Method to calculate the median of the data\n\tpublic double calculateMedian() {\n\t\tCollections.sort(data);\n\t\tint size = data.size();\n\t\tif (size == 0) {\n\t\t\tthrow new IllegalArgumentException(\"Data list is empty\");\n\t\t}\n\t\tif (size % 2 == 0) {\n\t\t\treturn (data.get(size/2 - 1) + data.get(size/2)) / 2.0;\n\t\t} else {\n\t\t\treturn data.get(size/2);\n\t\t}\n\t}\n", "suffix": "\n\tpublic double calculateStandardDeviation() {\n\t\tint size = data.size();\n\t\tif (size == 0) {\n\t\t\tthrow new IllegalArgumentException(\"Data list is empty\");\n\t\t}\n\t\tdouble mean = calculateMean();\n\t\tdouble variance = 0;\n\t\tfor (int num : data) {\n\t\t\tvariance += Math.pow(num - mean, 2);\n\t\t}\n\t\tvariance /= size;\n\t\treturn Math.sqrt(variance);\n\t}\n\tpublic static void main(String[] args) {\n\t\tList<Integer> data = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\t\tMetricsCalculator calculator = new MetricsCalculator(data);\n\t\tAssert.assertEquals(5.5, calculator.calculateMean(), 0.01);\n\t\tAssert.assertEquals(5.5, calculator.calculateMedian(), 0.01);\n\t\tAssert.assertEquals(2.87, calculator.calculateStandardDeviation(), 0.01);\n\t}\n}\n", "golden_completion": "\t// Method to calculate the mode of the data\n\tpublic int calculateMode() {\n\t\tMap<Integer, Integer> frequencyMap = new HashMap<>();\n\t\tfor (int num : data) {\n\t\t\tfrequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n\t\t}\n\t\tint mode = data.get(0);\n\t\tint maxCount = 0;\n\t\tfor (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n\t\t\tif (entry.getValue() > maxCount) {\n\t\t\t\tmaxCount = entry.getValue();\n\t\t\t\tmode = entry.getKey();\n\t\t\t}\n\t\t}\n\t\treturn mode;\n\t}\n", "LLM_justification": "This test case demonstrates the implementation of various statistical metrics on a list of integers, a common pattern in analytics. The pattern involves computing different statistical measures (mean, median) and handling empty data scenarios with appropriate error handling. The golden completion follows this pattern by implementing the mode calculation, ensuring the LLM recognizes and continues the established pattern. The suffix includes the calculation of the standard deviation and assertions to verify the correctness of all implemented methods.", "assertions": "", "gpt-35-turbo-completions": "// Method to calculate the standard deviation of the data"}
{"id": "46", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class HigherOrderFunctionExample {\n\n    // Helper method to demonstrate higher-order functions\n    public static List<String> processStrings(List<String> inputList, Function<String, String> processor) {\n        return inputList.stream().map(processor).collect(Collectors.toList());\n    }\n\n    // Helper method to demonstrate higher-order functions\n    public static List<Integer> processIntegers(List<Integer> inputList, Function<Integer, Integer> processor) {\n        return inputList.stream().map(processor).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<String> stringList = new ArrayList<>();\n        stringList.add(\"apple\");\n        stringList.add(\"banana\");\n        stringList.add(\"cherry\");\n\n        List<Integer> integerList = new ArrayList<>();\n        integerList.add(1);\n        integerList.add(2);\n        integerList.add(3);\n\n        // Processing strings to uppercase\n        List<String> upperCaseList = processStrings(stringList, String::toUpperCase);\n\n        // Processing integers to their squares\n        List<Integer> squaredList = processIntegers(integerList, x -> x * x);\n", "suffix": "\n        // Assertion for uppercase processing\n        assert upperCaseList.get(0).equals(\"APPLE\");\n        assert upperCaseList.get(1).equals(\"BANANA\");\n        assert upperCaseList.get(2).equals(\"CHERRY\");\n        // Assertion for squared processing\n        assert squaredList.get(0) == 1;\n        assert squaredList.get(1) == 4;\n        assert squaredList.get(2) == 9;\n        // Assertion for lowercase processing\n        assert lowerCaseList.get(0).equals(\"apple\");\n        assert lowerCaseList.get(1).equals(\"banana\");\n        assert lowerCaseList.get(2).equals(\"cherry\");\n    }\n}\n", "golden_completion": "        // Processing strings to lowercase\n        List<String> lowerCaseList = processStrings(stringList, String::toLowerCase);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a higher-order function pattern in Java. The prefix establishes a clear pattern of using a higher-order function to process lists with different types of elements (Strings and Integers). The golden completion requires the LLM to apply this pattern by creating a new list that processes strings to lowercase. The suffix includes assertions to verify the correctness of the processing and ensures that the pattern is followed correctly without duplicating the golden completion.", "assertions": "", "gpt-35-turbo-completions": "// Processing strings to lowercase\n        List<String> lowerCaseList = processStrings(stringList, String::toLowerCase);"}
{"id": "47", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MetricsCollector {\n    private List<Double> data;\n\n    public MetricsCollector() {\n        this.data = new ArrayList<>();\n    }\n\n    public void addData(double value) {\n        this.data.add(value);\n    }\n\n    public double calculateMean() {\n        double sum = 0;\n        for (double d : data) {\n            sum += d;\n        }\n        return sum / data.size();\n    }\n\n    public double calculateStandardDeviation() {\n        double mean = calculateMean();\n        double sum = 0;\n        for (double d : data) {\n            sum += Math.pow(d - mean, 2);\n        }\n        return Math.sqrt(sum / data.size());\n    }\n\n    public double calculateMedian() {\n        List<Double> sortedData = new ArrayList<>(data);\n        sortedData.sort(Double::compareTo);\n        int size = sortedData.size();\n        if (size % 2 == 0) {\n            return (sortedData.get(size / 2 - 1) + sortedData.get(size / 2)) / 2.0;\n        } else {\n            return sortedData.get(size / 2);\n        }\n    }\n\n    // Pattern: calculateVariance method follows a similar pattern to calculateStandardDeviation\n", "suffix": "    public static void main(String[] args) {\n        MetricsCollector collector = new MetricsCollector();\n        collector.addData(1.0);\n        collector.addData(2.0);\n        collector.addData(3.0);\n        collector.addData(4.0);\n        collector.addData(5.0);\n\n        double variance = collector.calculateVariance();\n        System.out.println(\"Variance: \" + variance);\n\n        // Assertions\n        assert Math.abs(variance - 2.0) < 0.0001 : \"Variance calculation failed!\";\n    }\n\n    // Cleanup code if necessary\n}", "golden_completion": "    public double calculateVariance() {\n        double mean = calculateMean();\n        double sum = 0;\n        for (double d : data) {\n            sum += Math.pow(d - mean, 2);\n        }\n        return sum / data.size();\n    }\n", "LLM_justification": "This test case is a good example of pattern matching in an analytics context. The calculateVariance method follows a similar pattern to calculateStandardDeviation, which involves iterating over the data list, performing a mathematical operation on each element, and then computing a result based on the aggregated values. The golden completion exemplifies the expected pattern continuation. Assertions in the suffix validate the correctness of the calculateVariance method by checking its output against a known value.", "assertions": "", "gpt-35-turbo-completions": "// Cleanup code if necessary\n}\n\npublic class Main {"}
{"id": "48", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HigherOrderFunctionsExample {\n\n    // Utility function to filter a list based on a predicate\n    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {\n        List<T> result = new ArrayList<>();\n        for (T item : list) {\n            if (predicate.test(item)) {\n                result.add(item);\n            }\n        }\n        return result;\n    }\n\n    // Utility function to transform a list based on a function\n    public static <T, R> List<R> transform(List<T> list, Function<T, R> function) {\n        List<R> result = new ArrayList<>();\n        for (T item : list) {\n            result.add(function.apply(item));\n        }\n        return result;\n    }\n\n    // Higher-order function that returns a predicate to check if a string contains a given substring\n    public static Predicate<String> containsSubstring(String substring) {\n        return str -> str.contains(substring);\n    }\n\n    // Higher-order function that returns a function to convert strings to uppercase\n    public static Function<String, String> toUpperCase() {\n        return String::toUpperCase;\n    }\n\n    public static void main(String[] args) {\n        // Example usage of filter function\n        List<String> words = new ArrayList<>();\n        words.add(\"apple\");\n        words.add(\"banana\");\n        words.add(\"cherry\");\n        words.add(\"date\");\n        words.add(\"elderberry\");\n\n        // Filter words containing 'a'\n        List<String> wordsWithA = filter(words, containsSubstring(\"a\"));\n        System.out.println(\"Words with 'a': \" + wordsWithA);\n\n        // Transform words to uppercase\n        List<String> uppercasedWords = transform(words, toUpperCase());\n        System.out.println(\"Uppercased words: \" + uppercasedWords);\n\n        // Example usage of filter function with length predicate\n        List<String> longWords = filter(words, str -> str.length() > 5);\n        System.out.println(\"Long words: \" + longWords);\n\n", "suffix": "        // Assertions\n        assert wordsWithA.size() == 3 : \"There should be 3 words containing 'a'\";\n        assert wordsWithA.contains(\"apple\") : \"List should contain 'apple'\";\n        assert wordsWithA.contains(\"banana\") : \"List should contain 'banana'\";\n        assert wordsWithA.contains(\"date\") : \"List should contain 'date'\";\n\n        assert uppercasedWords.size() == 5 : \"There should be 5 words in the list\";\n        assert uppercasedWords.get(0).equals(\"APPLE\") : \"First word should be 'APPLE'\";\n        assert uppercasedWords.get(1).equals(\"BANANA\") : \"Second word should be 'BANANA'\";\n\n        assert longWords.size() == 2 : \"There should be 2 long words\";\n        assert longWords.contains(\"banana\") : \"List should contain 'banana'\";\n        assert longWords.contains(\"elderberry\") : \"List should contain 'elderberry'\";\n\n        assert wordLengths.size() == 5 : \"There should be 5 word lengths\";\n        assert wordLengths.get(0) == 5 : \"First word length should be 5\";\n        assert wordLengths.get(1) == 6 : \"Second word length should be 6\";\n    }\n}\n", "golden_completion": "\n\n        // Example usage of transform function with length function\n        List<Integer> wordLengths = transform(words, String::length);\n        System.out.println(\"Word lengths: \" + wordLengths);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete patterns involving higher-order functions in Java. The prefix establishes a clear pattern of using utility functions (filter and transform) with predicates and functions. The golden completion requires the model to continue this pattern by applying these utility functions with new predicates and functions. The suffix includes assertions to verify the correctness of the pattern continuation and ensure that the functionality is as expected.", "assertions": "", "gpt-35-turbo-completions": "// Example usage of transform function with length function\n        List<Integer> wordLengths = transform(words, String::length);\n        System.out.println(\"Word lengths: \" + wordLengths);"}
{"id": "49", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class MetricAnalyzer {\n\n    public static class Metric {\n        private String name;\n        private double value;\n\n        public Metric(String name, double value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public double getValue() {\n            return value;\n        }\n    }\n\n    public static List<Metric> filterMetrics(List<Metric> metrics, Predicate<Metric> condition) {\n        return metrics.stream().filter(condition).collect(Collectors.toList());\n    }\n\n    public static double calculateAverage(List<Metric> metrics) {\n        return metrics.stream().mapToDouble(Metric::getValue).average().orElse(0.0);\n    }\n\n    public static void printMetrics(List<Metric> metrics) {\n        metrics.forEach(metric -> System.out.println(metric.getName() + \": \" + metric.getValue()));\n    }\n\n    public static void main(String[] args) {\n        List<Metric> metrics = Arrays.asList(\n            new Metric(\"CPU\", 75.5),\n            new Metric(\"Memory\", 65.2),\n            new Metric(\"Disk\", 55.1),\n            new Metric(\"Network\", 85.0)\n        );\n        List<Metric> highUsageMetrics = filterMetrics(metrics, m -> m.getValue() > 70.0);\n", "suffix": "        List<Metric> lowUsageMetrics = filterMetrics(metrics, m -> m.getValue() < 60.0);\n        printMetrics(lowUsageMetrics);\n\n        double averageHighUsage = calculateAverage(highUsageMetrics);\n        double averageLowUsage = calculateAverage(lowUsageMetrics);\n\n        // Assertions\n        assert highUsageMetrics.size() == 2 : \"Expected 2 high usage metrics\";\n        assert lowUsageMetrics.size() == 2 : \"Expected 2 low usage metrics\";\n        assert averageHighUsage == 80.25 : \"Expected average high usage to be 80.25\";\n        assert averageLowUsage == 55.15 : \"Expected average low usage to be 55.15\";\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "        printMetrics(highUsageMetrics);\n", "LLM_justification": "This test case demonstrates the use of higher-order functions within an analytics context. The pattern of filtering metrics based on conditions and processing them using higher-order functions like filter, mapToDouble, and forEach is established in the prefix. The completion requires the model to recognize this pattern and continue it by applying the printMetrics function to the highUsageMetrics list. The suffix then introduces additional metric filtering and asserts correctness, ensuring the model understands the established pattern and follows it correctly.", "assertions": "", "gpt-35-turbo-completions": "printMetrics(highUsageMetrics);"}
{"id": "50", "testsource": "devbench-pattern-matching", "language": "java", "prefix": "import java.util.function.Function;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class HigherOrderFunctionExample {\n\n    // Function to apply a transformation to each element in a list\n    public static <T, R> List<R> transformList(List<T> list, Function<T, R> transformer) {\n        return list.stream().map(transformer).collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        // Example usage of transformList function\n        List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5);\n        Function<Integer, String> intToString = (Integer i) -> \"Number: \" + i;\n        List<String> stringList = transformList(integers, intToString);\n        for (String s : stringList) {\n            System.out.println(s);\n        }\n\n        // Another example usage\n        List<String> words = Arrays.asList(\"hello\", \"world\");\n        Function<String, String> toUpperCase = (String s) -> s.toUpperCase();\n        List<String> upperCaseWords = transformList(words, toUpperCase);\n        for (String word : upperCaseWords) {\n            System.out.println(word);\n        }\n\n        // More examples to establish the pattern\n        Function<String, Integer> stringLength = (String s) -> s.length();\n        List<Integer> lengths = transformList(words, stringLength);\n        for (Integer length : lengths) {\n            System.out.println(length);\n        }\n\n        Function<Integer, Integer> square = (Integer i) -> i * i;\n        List<Integer> squares = transformList(integers, square);\n        for (Integer squareValue : squares) {\n            System.out.println(squareValue);\n        }\n", "suffix": "        // Assertions to verify the results\n        assert stringList.equals(Arrays.asList(\"Number: 1\", \"Number: 2\", \"Number: 3\", \"Number: 4\", \"Number: 5\"));\n        assert upperCaseWords.equals(Arrays.asList(\"HELLO\", \"WORLD\"));\n        assert lengths.equals(Arrays.asList(5, 5));\n        assert squares.equals(Arrays.asList(1, 4, 9, 16, 25));\n\n        // Additional transformation example\n        Function<String, String> addExclamation = (String s) -> s + \"!\";\n        List<String> exclaimedWords = transformList(words, addExclamation);\n        for (String word : exclaimedWords) {\n            System.out.println(word);\n        }\n\n        // Assertions for the new transformation\n        assert exclaimedWords.equals(Arrays.asList(\"hello!\", \"world!\"));\n    }\n}\n", "golden_completion": "        Function<String, String> reverseString = (String s) -> new StringBuilder(s).reverse().toString();\n        List<String> reversedWords = transformList(words, reverseString);\n        for (String word : reversedWords) {\n            System.out.println(word);\n        }\n        assert reversedWords.equals(Arrays.asList(\"olleh\", \"dlrow\"));\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue the pattern of using higher-order functions with the transformList method. The prefix establishes a clear pattern of defining a lambda function and passing it to the transformList method to generate a new list. The golden completion requires the LLM to follow this pattern by defining a new transformation function and verifying its result. The suffix contains assertions that validate both the correctness of the transformation and the adherence to the pattern.", "assertions": "", "gpt-35-turbo-completions": "// Additional examples\n        List<String> words = Arrays.asList(\"hello\", \"world\");\n        Function<String, String> toUpperCase = (String s) -> s.toUpperCase();\n        List<String> upperCaseWords = transformList(words, toUpperCase);\n\n        Function<String, Integer> stringLength = (String s) -> s.length();\n        List<Integer> lengths = transformList(words, stringLength);\n\n        Function<Integer, Integer> square = (Integer i) -> i * i;\n        List<Integer> squares = transformList(integers, square);"}
