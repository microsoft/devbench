{"id": "1", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n", "suffix": "\npublic class ConfigurationManager {\n\n    private final Map<String, String> configSettings;\n    private final Lock lock;\n\n    public ConfigurationManager() {\n        this.configSettings = new HashMap<>();\n        this.lock = new ReentrantLock();\n    }\n\n    /**\n     * Retrieves the value of a configuration setting.\n     * @param key the configuration key\n     * @return the value associated with the given key\n     */\n    public String getSetting(String key) {\n        lock.lock();\n        try {\n            return configSettings.get(key);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Updates the value of a configuration setting.\n     * @param key the configuration key\n     * @param value the new value for the configuration setting\n     */\n    public void updateSetting(String key, String value) {\n        lock.lock();\n        try {\n            configSettings.put(key, value);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * Clears all configuration settings.\n     */\n    public void clearSettings() {\n        lock.lock();\n        try {\n            configSettings.clear();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n        configManager.updateSetting(\"timeout\", \"30\");\n        configManager.updateSetting(\"theme\", \"dark\");\n\n        // Assertions to verify the behavior\n        assert \"30\".equals(configManager.getSetting(\"timeout\"));\n        assert \"dark\".equals(configManager.getSetting(\"theme\"));\n        configManager.clearSettings();\n        // Verify settings are cleared\n        assert configManager.getSetting(\"timeout\") == null;\n        assert configManager.getSetting(\"theme\") == null;\n    }\n}\n", "golden_completion": "/**\n * ConfigurationManager is a utility class for managing application settings dynamically.\n * It ensures thread-safe operations for retrieving, updating, and clearing configuration settings.\n *\n * <p>Example usage:</p>\n * <pre>\n * ConfigurationManager configManager = new ConfigurationManager();\n * configManager.updateSetting(\"timeout\", \"30\");\n * String timeout = configManager.getSetting(\"timeout\");\n * configManager.clearSettings();\n * </pre>\n *\n * <p>Thread Safety:</p>\n * <p>All methods in this class are thread-safe. A ReentrantLock is used to synchronize access to the configuration settings.</p>\n *\n * <p>Error Handling:</p>\n * <p>The methods do not throw exceptions but will return null if a setting is not found or if the map is cleared.</p>\n *\n * @param key the configuration key\n * @return the value associated with the given key, or null if the key is not found\n */\n", "LLM_justification": "This example provides a realistic scenario involving configuration management in a multi-threaded environment. It tests the LLM's ability to generate comprehensive Javadoc-style documentation for a class that handles dynamic settings. The example covers method documentation, usage examples, thread safety, and error handling, making it a robust test for code-to-comment translation capabilities. The provided assertions ensure the functional correctness of the implementation.", "assertions": "", "gpt-4o_completion_0": "public class ConfigurationManager {", "gpt-4o_completion_1": "public class ConfigurationManager {", "gpt-4o_completion_2": "public class ConfigurationManager {", "gpt-4o_completion_3": "public class ConfigurationManager {", "gpt-4o_completion_4": "public class ConfigurationManager {", "gpt-4o_completions": ["public class ConfigurationManager {", "public class ConfigurationManager {", "public class ConfigurationManager {", "public class ConfigurationManager {", "public class ConfigurationManager {"]}
{"id": "2", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents a simple cache manager that handles cache storage and invalidation.\n */\npublic class SimpleCacheManager {\n    private Map<String, String> cache;\n\n    /**\n     * Initializes the SimpleCacheManager with an empty cache.\n     */\n    public SimpleCacheManager() {\n        this.cache = new HashMap<>();\n    }\n\n    /**\n     * Stores a value in the cache with the given key.\n     *\n     * @param key The key for the cache entry.\n     * @param value The value to be stored in the cache.\n     */\n    public void put(String key, String value) {\n        cache.put(key, value);\n    }\n\n    /**\n     * Retrieves a value from the cache by its key.\n     *\n     * @param key The key for the cache entry.\n     * @return The value associated with the key, or null if the key is not present.\n     */\n    public String get(String key) {\n        return cache.get(key);\n    }\n\n    /**\n     * Invalidates (removes) a cache entry by its key.\n     *\n     * @param key The key for the cache entry to be invalidated.\n     * @return The value that was removed, or null if the key was not present.\n     */\n", "suffix": "    public static void main(String[] args) {\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        cacheManager.put(\"testKey\", \"testValue\");\n        assert \"testValue\".equals(cacheManager.get(\"testKey\"));\n        assert \"testValue\".equals(cacheManager.invalidate(\"testKey\"));\n        assert cacheManager.get(\"testKey\") == null;\n        System.out.println(\"All assertions passed.\");\n    }\n}", "golden_completion": "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "LLM_justification": "This test case effectively demonstrates bidirectional translation capabilities between code and documentation. It includes a realistic example of cache management, providing context for a class and its methods, while the golden completion requires generating code for a documented method. The assertions verify the functional requirements and correctness of the implementation, ensuring that the cache manager behaves as expected. The example includes detailed Javadoc comments and tests edge cases such as cache invalidation and retrieval of non-existent entries.", "assertions": "", "gpt-4o_completion_0": "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "gpt-4o_completion_1": "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "gpt-4o_completion_2": "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "gpt-4o_completion_3": "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "gpt-4o_completion_4": "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "gpt-4o_completions": ["    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "    public String invalidate(String key) {\n        return cache.remove(key);\n    }", "    public String invalidate(String key) {\n        return cache.remove(key);\n    }"]}
{"id": "3", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Utility class for managing business policies.\n * Provides methods to add, validate, and enforce business rules.\n */\npublic class PolicyManager {\n    private Map<String, String> policies;\n\n    /**\n     * Constructor to initialize the PolicyManager with an empty policy set.\n     */\n    public PolicyManager() {\n        this.policies = new HashMap<>();\n    }\n\n    /**\n     * Adds a new policy to the policy manager.\n     *\n     * @param policyName the name of the policy\n     * @param policyDefinition the definition or rules of the policy\n     */\n    public void addPolicy(String policyName, String policyDefinition) {\n        policies.put(policyName, policyDefinition);\n    }\n\n    /**\n     * Validates a policy against provided rules.\n     *\n     * @param policyName the name of the policy to validate\n     * @return true if the policy is valid, false otherwise\n     */\n    public boolean validatePolicy(String policyName) {\n        String policy = policies.get(policyName);\n        // Simplified validation logic (actual implementation may vary)\n        return policy != null && !policy.isEmpty();\n    }\n", "suffix": "\n    public static void main(String[] args) {\n        PolicyManager manager = new PolicyManager();\n        manager.addPolicy(\"DataRetention\", \"All data must be retained for 5 years.\");\n        assert manager.validatePolicy(\"DataRetention\");\n        manager.addPolicy(\"DataPrivacy\", \"Personal data must be anonymized.\");\n        assert manager.validatePolicy(\"DataPrivacy\");\n        assert !manager.validatePolicy(\"NonExistentPolicy\");\n    }\n}\n", "golden_completion": "    /**\n     * Enforces a policy by executing its rules.\n     *\n     * @param policyName the name of the policy to enforce\n     * @return true if the policy was successfully enforced, false otherwise\n     */\n    public boolean enforcePolicy(String policyName) {\n        String policy = policies.get(policyName);\n        if (policy == null || policy.isEmpty()) {\n            return false;\n        }\n        // Simplified enforcement logic (actual implementation may vary)\n        System.out.println(\"Enforcing policy: \" + policy);\n        return true;\n    }\n", "LLM_justification": "This test case effectively evaluates the LLM's ability to translate between code and natural language documentation. It includes both detailed Javadoc-style documentation and complex logic for managing business policies, making it a robust test for code-to-comment and comment-to-code translation. The assertions in the suffix validate the functional correctness of the methods and ensure that the documentation aligns with the implementation.", "assertions": "", "gpt-4o_completion_0": "    /**\n     * Retrieves the definition of a policy.\n     *\n     * @param policyName the name of the policy to retrieve\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicyDefinition(String policyName) {\n        return policies.get(policyName);\n    }", "gpt-4o_completion_1": "    /**\n     * Retrieves the definition of a policy by its name.\n     *\n     * @param policyName the name of the policy\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicyDefinition(String policyName) {\n        return policies.get(policyName);\n    }", "gpt-4o_completion_2": "    /**\n     * Retrieves the definition of a policy by its name.\n     *\n     * @param policyName the name of the policy\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicy(String policyName) {\n        return policies.get(policyName);\n    }", "gpt-4o_completion_3": "    /**\n     * Retrieves the definition of a policy by its name.\n     *\n     * @param policyName the name of the policy to retrieve\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicy(String policyName) {\n        return policies.get(policyName);\n    }", "gpt-4o_completion_4": "    /**\n     * Retrieves the definition of a policy.\n     *\n     * @param policyName the name of the policy to retrieve\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicyDefinition(String policyName) {\n        return policies.get(policyName);\n    }", "gpt-4o_completions": ["    /**\n     * Retrieves the definition of a policy.\n     *\n     * @param policyName the name of the policy to retrieve\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicyDefinition(String policyName) {\n        return policies.get(policyName);\n    }", "    /**\n     * Retrieves the definition of a policy by its name.\n     *\n     * @param policyName the name of the policy\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicyDefinition(String policyName) {\n        return policies.get(policyName);\n    }", "    /**\n     * Retrieves the definition of a policy by its name.\n     *\n     * @param policyName the name of the policy\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicy(String policyName) {\n        return policies.get(policyName);\n    }", "    /**\n     * Retrieves the definition of a policy by its name.\n     *\n     * @param policyName the name of the policy to retrieve\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicy(String policyName) {\n        return policies.get(policyName);\n    }", "    /**\n     * Retrieves the definition of a policy.\n     *\n     * @param policyName the name of the policy to retrieve\n     * @return the definition of the policy, or null if the policy does not exist\n     */\n    public String getPolicyDefinition(String policyName) {\n        return policies.get(policyName);\n    }"]}
{"id": "4", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Represents a portfolio of financial assets and provides methods to calculate the total value and risk.\n */\npublic class Portfolio {\n    private Map<String, Double> assets;\n    private Map<String, Double> risks;\n\n    public Portfolio() {\n        assets = new HashMap<>();\n        risks = new HashMap<>();\n    }\n\n    /**\n     * Adds an asset to the portfolio.\n     *\n     * @param name the name of the asset\n     * @param value the value of the asset\n     * @param risk the risk associated with the asset\n     */\n    public void addAsset(String name, double value, double risk) {\n        assets.put(name, value);\n        risks.put(name, risk);\n    }\n\n    /**\n     * Calculates the total value of the portfolio.\n     *\n     * @return the total value of the portfolio\n     */\n    public double calculateTotalValue() {\n        double totalValue = 0.0;\n        for (double value : assets.values()) {\n            totalValue += value;\n        }\n        return totalValue;\n    }\n\n    /**\n     * Calculates the total risk of the portfolio based on individual asset risks.\n     *\n     * @return the total risk of the portfolio\n     */\n", "suffix": "\n    public static void main(String[] args) {\n        Portfolio portfolio = new Portfolio();\n        portfolio.addAsset(\"Stock A\", 1000.0, 0.1);\n        portfolio.addAsset(\"Stock B\", 2000.0, 0.2);\n        portfolio.addAsset(\"Bond C\", 3000.0, 0.05);\n\n        double totalValue = portfolio.calculateTotalValue();\n        double totalRisk = portfolio.calculateTotalRisk();\n\n        assert totalValue == 6000.0 : \"Total value should be 6000.0\";\n        assert Math.abs(totalRisk - 0.35) < 1e-9 : \"Total risk should be 0.35\";\n    }\n}\n", "golden_completion": "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (double risk : risks.values()) {\n            totalRisk += risk;\n        }\n        return totalRisk;\n    }\n", "LLM_justification": "This test case demonstrates a realistic business scenario involving portfolio risk assessment, which requires both accurate documentation and correct implementation. The prefix provides context and setup for the Portfolio class, including methods to add assets and calculate total value. The golden completion requires generating the calculateTotalRisk method, which is essential for understanding the overall risk of the portfolio. The suffix includes assertions to verify the correctness of the total value and risk calculations, ensuring that the generated code meets functional requirements.", "assertions": "", "gpt-4o_completion_0": "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "gpt-4o_completion_1": "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "gpt-4o_completion_2": "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "gpt-4o_completion_3": "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "gpt-4o_completion_4": "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "gpt-4o_completions": ["    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }", "    public double calculateTotalRisk() {\n        double totalRisk = 0.0;\n        for (Map.Entry<String, Double> entry : risks.entrySet()) {\n            totalRisk += entry.getValue();\n        }\n        return totalRisk;\n    }"]}
{"id": "5", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * Class representing a financial portfolio that holds various assets.\n * Provides methods to calculate the total value and assess risks associated with the portfolio.\n */\npublic class Portfolio {\n    private Map<String, Double> assets;\n\n    /**\n     * Initializes an empty portfolio.\n     */\n    public Portfolio() {\n        this.assets = new HashMap<>();\n    }\n\n    /**\n     * Adds an asset to the portfolio.\n     *\n     * @param assetName the name of the asset\n     * @param assetValue the value of the asset\n     */\n    public void addAsset(String assetName, double assetValue) {\n        Objects.requireNonNull(assetName, \"Asset name cannot be null\");\n        if (assetValue <= 0) {\n            throw new IllegalArgumentException(\"Asset value must be positive\");\n        }\n        assets.put(assetName, assetValue);\n    }\n\n    /**\n     * Retrieves the value of a specific asset.\n     *\n     * @param assetName the name of the asset\n     * @return the value of the asset\n     */\n    public double getAssetValue(String assetName) {\n        Objects.requireNonNull(assetName, \"Asset name cannot be null\");\n        Double value = assets.get(assetName);\n        if (value == null) {\n            throw new IllegalArgumentException(\"Asset not found\");\n        }\n        return value;\n    }\n\n    /**\n     * Calculates the total value of all assets in the portfolio.\n     *\n     * @return the total value of the portfolio\n     */\n", "suffix": "\n\n    public static void main(String[] args) {\n        Portfolio portfolio = new Portfolio();\n        portfolio.addAsset(\"Stock A\", 150.0);\n        portfolio.addAsset(\"Stock B\", 200.0);\n        portfolio.addAsset(\"Bond C\", 100.0);\n\n        double totalValue = portfolio.calculateTotalValue();\n        assert totalValue == 450.0 : \"Total value calculation failed\";\n\n        double stockAValue = portfolio.getAssetValue(\"Stock A\");\n        assert stockAValue == 150.0 : \"Asset value retrieval failed for Stock A\";\n\n        try {\n            portfolio.getAssetValue(\"Nonexistent Asset\");\n        } catch (IllegalArgumentException e) {\n            assert e.getMessage().equals(\"Asset not found\") : \"Exception message mismatch\";\n        }\n    }\n}\n", "golden_completion": "    public double calculateTotalValue() {\n        double totalValue = 0.0;\n        for (double value : assets.values()) {\n            totalValue += value;\n        }\n        return totalValue;\n    }\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to generate comprehensive documentation for a method implementation within a business logic context. The portfolio management example includes adding, retrieving, and calculating the total value of assets, which are realistic financial operations. The code-to-comment translation tests the LLM's ability to generate detailed Javadoc-style comments, while the comment-to-code translation tests the LLM's ability to implement the given method based on its description. The assertions verify that the generated code meets functional requirements and handles error scenarios appropriately.", "assertions": "", "gpt-4o_completion_0": "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "gpt-4o_completion_1": "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "gpt-4o_completion_2": "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "gpt-4o_completion_3": "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "gpt-4o_completion_4": "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "gpt-4o_completions": ["    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }", "    public double calculateTotalValue() {\n        return assets.values().stream().mapToDouble(Double::doubleValue).sum();\n    }"]}
{"id": "6", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Class representing a portfolio of financial assets.\n */\npublic class Portfolio {\n    private List<Asset> assets;\n\n    /**\n     * Initializes a new portfolio.\n     */\n    public Portfolio() {\n        this.assets = new ArrayList<>();\n    }\n\n    /**\n     * Adds an asset to the portfolio.\n     *\n     * @param asset the asset to add\n     */\n    public void addAsset(Asset asset) {\n        assets.add(asset);\n    }\n\n    /**\n     * Calculates the total value of the portfolio.\n     *\n     * @return the total value of all assets in the portfolio\n     */\n    public double calculateTotalValue() {\n        double totalValue = 0.0;\n        for (Asset asset : assets) {\n            totalValue += asset.getValue();\n        }\n        return totalValue;\n    }\n\n    public static void main(String[] args) {\n        Portfolio portfolio = new Portfolio();\n        portfolio.addAsset(new Asset(\"Stock A\", 1000.0));\n        portfolio.addAsset(new Asset(\"Stock B\", 2000.0));\n        portfolio.addAsset(new Asset(\"Bond C\", 500.0));\n\n        double totalValue = portfolio.calculateTotalValue();\n\n        // Assertions to verify the correctness of the implementation\n        assert totalValue == 3500.0 : \"Total value should be 3500.0\";\n    }\n}\n\n/**\n * Class representing a financial asset.\n */\nclass Asset {\n    private String name;\n    private double value;\n\n    /**\n     * Initializes a new asset.\n     *\n     * @param name the name of the asset\n     * @param value the value of the asset\n     */\n    public Asset(String name, double value) {\n        this.name = name;\n        this.value = value;\n    }\n\n    /**\n     * Gets the value of the asset.\n     *\n     * @return the value of the asset\n     */\n    public double getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the value of the asset.\n     *\n     * @param value the new value of the asset\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n}", "suffix": "", "golden_completion": "/**\n * A demonstration class to test the Portfolio and Asset classes.\n */\n", "LLM_justification": "This test case provides a realistic example of a financial portfolio management system, covering both code-to-comment and comment-to-code translation. The prefix includes a well-defined class structure with Javadoc comments, while the suffix includes executable code with assertions that verify the correctness of the implementation. This helps in testing the LLM's ability to generate accurate documentation and code based on given documentation.", "assertions": "", "gpt-4o_completion_0": "// No additional code is needed here as the implementation is complete and functional.", "gpt-4o_completion_1": "// No additional code is required here as the implementation is already complete.", "gpt-4o_completion_2": "// No additional code is needed here as the implementation is complete and functional.", "gpt-4o_completion_3": "// No additional code is needed here as the implementation is complete.", "gpt-4o_completion_4": "// No additional code is required here as the implementation is already complete.", "gpt-4o_completions": ["// No additional code is needed here as the implementation is complete and functional.", "// No additional code is required here as the implementation is already complete.", "// No additional code is needed here as the implementation is complete and functional.", "// No additional code is needed here as the implementation is complete.", "// No additional code is required here as the implementation is already complete."]}
{"id": "7", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A class representing a simple configuration manager for managing application settings.\n * It demonstrates dynamic settings update and retrieval functionalities.\n */\npublic class ConfigurationManager {\n    private final Map<String, String> settings;\n\n    /**\n     * Constructs a new ConfigurationManager with default settings.\n     */\n    public ConfigurationManager() {\n        this.settings = new HashMap<>();\n        initializeDefaultSettings();\n    }\n\n    /**\n     * Initializes the configuration manager with default settings.\n     */\n    private void initializeDefaultSettings() {\n        settings.put(\"app.theme\", \"light\");\n        settings.put(\"app.language\", \"en\");\n    }\n\n    /**\n     * Updates a setting with the given key and value.\n     * @param key the setting key\n     * @param value the setting value\n     * @throws IllegalArgumentException if the key or value is null or empty\n     */\n    public void updateSetting(String key, String value) {\n        if (key == null || key.isEmpty() || value == null || value.isEmpty()) {\n            throw new IllegalArgumentException(\"Key and value must not be null or empty\");\n        }\n        settings.put(key, value);\n    }\n\n    /**\n     * Retrieves the value of a setting by its key.\n     * @param key the setting key\n     * @return the setting value, or null if the key does not exist\n     */\n    public String getSetting(String key) {\n        return settings.get(key);\n    }\n\n    /**\n     * Removes a setting by its key.\n     * @param key the setting key\n     * @return the previous value associated with the key, or null if there was no mapping for the key\n     * @throws IllegalArgumentException if the key is null or empty\n     */", "suffix": "\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n\n        // Test updating settings\n        configManager.updateSetting(\"app.theme\", \"dark\");\n        assert \"dark\".equals(configManager.getSetting(\"app.theme\"));\n\n        configManager.updateSetting(\"app.language\", \"fr\");\n        assert \"fr\".equals(configManager.getSetting(\"app.language\"));\n\n        // Test retrieving non-existent setting\n        assert configManager.getSetting(\"non.existent\") == null;\n\n        // Test invalid arguments\n        try {\n            configManager.updateSetting(null, \"value\");\n        } catch (IllegalArgumentException e) {\n            assert e.getMessage().contains(\"Key and value must not be null or empty\");\n        }\n\n        try {\n            configManager.updateSetting(\"key\", \"\");\n        } catch (IllegalArgumentException e) {\n            assert e.getMessage().contains(\"Key and value must not be null or empty\");\n        }\n\n        // Test dynamic update and retrieval\n        configManager.updateSetting(\"app.mode\", \"production\");\n        assert \"production\".equals(configManager.getSetting(\"app.mode\"));\n    }\n}\n", "golden_completion": "\n    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }\n", "LLM_justification": "This test case is a good example of code-to-comment translation as it requires detailed documentation for a method implementation in a ConfigurationManager class. The comments should provide comprehensive details about the method's behavior, parameters, and return value. The assertions in the suffix test various edge cases and functional requirements, ensuring the method works correctly. This scenario effectively tests the LLM's ability to generate accurate and meaningful documentation based on the provided code, which is essential for understanding and maintaining the code.", "assertions": "", "gpt-4o_completion_0": "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "gpt-4o_completion_1": "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "gpt-4o_completion_2": "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "gpt-4o_completion_3": "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "gpt-4o_completion_4": "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "gpt-4o_completions": ["    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }", "    public String removeSetting(String key) {\n        if (key == null || key.isEmpty()) {\n            throw new IllegalArgumentException(\"Key must not be null or empty\");\n        }\n        return settings.remove(key);\n    }"]}
{"id": "8", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * Class to perform financial calculations for a portfolio analysis.\n */\npublic class PortfolioAnalysis {\n    private List<Double> investments;\n\n    /**\n     * Constructor to initialize the portfolio with a list of investments.\n     *\n     * @param investments List of investment amounts\n     */\n    public PortfolioAnalysis(List<Double> investments) {\n        this.investments = investments;\n    }\n\n    /**\n     * Calculate the total value of the portfolio.\n     *\n     * @return Total value of all investments\n     */\n    public double calculateTotalValue() {\n        return investments.stream().mapToDouble(Double::doubleValue).sum();\n    }\n\n    /**\n     * Calculate the average value of the investments in the portfolio.\n     *\n     * @return Average value of investments\n     */\n    public double calculateAverageValue() {\n        return investments.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n    }\n\n    /**\n     * Calculate the risk of the portfolio based on the standard deviation of the investments.\n     *\n     * @return Standard deviation of the investments\n     */\n    public double calculateRisk() {\n        double mean = calculateAverageValue();\n        double variance = investments.stream().mapToDouble(i -> Math.pow(i - mean, 2)).sum() / investments.size();\n        return Math.sqrt(variance);\n    }\n\n    /**\n     * Identify investments that exceed a certain threshold.\n     *\n     * @param threshold The value to compare against\n     * @return List of investments that exceed the threshold\n     */\n    public List<Double> identifyHighValueInvestments(double threshold) {\n        return investments.stream().filter(i -> i > threshold).collect(Collectors.toList());\n    }\n\n", "suffix": "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }\n\n    public static void main(String[] args) {\n    List<Double> investments = Arrays.asList(1000.0, 1500.0, 1200.0, 800.0, 950.0);\n    PortfolioAnalysis analysis = new PortfolioAnalysis(investments);\n\n    double medianValue = analysis.calculateMedianValue();\n\n    // Assert that the median value is calculated correctly\n    assert medianValue == 1000.0 : \"Median value calculation is incorrect\";\n\n    // Additional assertions for other methods\n    assert analysis.calculateTotalValue() == 5450.0 : \"Total value calculation is incorrect\";\n    assert analysis.calculateAverageValue() == 1090.0 : \"Average value calculation is incorrect\";\n    assert analysis.calculateRisk() > 0 : \"Risk calculation is incorrect\";\n    assert analysis.identifyHighValueInvestments(1000.0).size() == 2 : \"High value investment identification is incorrect\";\n\n    System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "    /**\n     * Calculate the median value of the investments in the portfolio.\n     *\n     * @return Median value of the investments\n     */", "LLM_justification": "This test case is a good example because it includes a realistic business scenario involving financial calculations for portfolio analysis. The prefix provides comprehensive code with documented methods, while the golden_completion requires generating documentation for an existing method. The suffix includes assertions to verify that the generated documentation accurately describes the method's functionality. This scenario effectively tests the model's ability to generate accurate and comprehensive documentation for existing code, ensuring alignment between code and comments.", "assertions": "", "gpt-4o_completion_0": "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "gpt-4o_completion_1": "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "gpt-4o_completion_2": "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "gpt-4o_completion_3": "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "gpt-4o_completion_4": "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "gpt-4o_completions": ["    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }", "    public double calculateMedianValue() {\n        List<Double> sortedInvestments = new ArrayList<>(investments);\n        Collections.sort(sortedInvestments);\n        int size = sortedInvestments.size();\n        if (size % 2 == 0) {\n            return (sortedInvestments.get(size / 2 - 1) + sortedInvestments.get(size / 2)) / 2.0;\n        } else {\n            return sortedInvestments.get(size / 2);\n        }\n    }"]}
{"id": "9", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\n\n/**\n * Class that handles portfolio analysis by calculating the risk and return of a given list of assets.\n */\npublic class PortfolioAnalysis {\n\n    /**\n     * Represents an asset in the portfolio.\n     */\n    public static class Asset {\n        private String name;\n        private double returnRate;\n        private double risk;\n\n        public Asset(String name, double returnRate, double risk) {\n            this.name = name;\n            this.returnRate = returnRate;\n            this.risk = risk;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public double getReturnRate() {\n            return returnRate;\n        }\n\n        public double getRisk() {\n            return risk;\n        }\n    }\n\n    /**\n     * Calculates the average return of the portfolio.\n     * @param assets List of assets in the portfolio.\n     * @return The average return rate.\n     */\n    public double calculateAverageReturn(List<Asset> assets) {\n        double totalReturn = 0;\n        for (Asset asset : assets) {\n            totalReturn += asset.getReturnRate();\n        }\n        return totalReturn / assets.size();\n    }\n\n    /**\n     * Calculates the total risk of the portfolio.\n     * @param assets List of assets in the portfolio.\n     * @return The total risk value.\n     */\n    public double calculateTotalRisk(List<Asset> assets) {\n        double totalRisk = 0;\n        for (Asset asset : assets) {\n            totalRisk += asset.getRisk();\n        }\n        return totalRisk;\n    }\n\n", "suffix": "\n    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<Asset> assets = new ArrayList<>();\n        assets.add(new Asset(\"Asset1\", 0.05, 0.1));\n        assets.add(new Asset(\"Asset2\", 0.07, 0.15));\n        assets.add(new Asset(\"Asset3\", 0.06, 0.05));\n\n        PortfolioAnalysis analysis = new PortfolioAnalysis();\n        List<Asset> filteredAssets = analysis.filterAssetsByRisk(assets, 0.1);\n\n        // Assertions\n        assert filteredAssets.size() == 2 : \"Filtered assets size should be 2\";\n        assert filteredAssets.get(0).getName().equals(\"Asset1\") : \"First asset should be Asset1\";\n        assert filteredAssets.get(1).getName().equals(\"Asset3\") : \"Second asset should be Asset3\";\n    }\n}\n", "golden_completion": "    /**\n     * Filters the assets based on a risk threshold.\n     * @param assets List of assets in the portfolio.\n     * @param riskThreshold The maximum acceptable risk value.\n     * @return A list of assets with risk values less than or equal to the risk threshold.\n     */\n", "LLM_justification": "This scenario provides a realistic example of portfolio analysis with financial calculations, including risk assessment. The task demonstrates bidirectional translation by requiring the model to generate both code and documentation. The code-to-comment part involves creating comprehensive documentation for the `filterAssetsByRisk` method, while the comment-to-code part requires implementing the method based on provided documentation. This example includes assertions to verify functional requirements and edge cases, ensuring the generated code is correct. The use of realistic business logic and detailed comments makes it a robust test for evaluating the model's translation capabilities.", "assertions": "", "gpt-4o_completion_0": "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completion_1": "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completion_2": "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completion_3": "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completion_4": "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completions": ["    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }", "    public List<Asset> filterAssetsByRisk(List<Asset> assets, double riskThreshold) {\n        return assets.stream()\n                     .filter(asset -> asset.getRisk() <= riskThreshold)\n                     .collect(Collectors.toList());\n    }"]}
{"id": "10", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Collections;\n\n/**\n * This class handles portfolio analysis including risk assessment.\n */\npublic class PortfolioAnalysis {\n    private List<Double> returns;\n\n    /**\n     * Constructor to initialize the returns list.\n     */\n    public PortfolioAnalysis() {\n        this.returns = new ArrayList<>();\n    }\n\n    /**\n     * Adds a return value to the portfolio.\n     * \n     * @param returnValue the return value to be added\n     */\n    public void addReturn(double returnValue) {\n        this.returns.add(returnValue);\n    }\n\n    /**\n     * Calculates the average return of the portfolio.\n     * \n     * @return the average return\n     */\n    public double calculateAverageReturn() {\n        double sum = 0;\n        for (double returnValue : returns) {\n            sum += returnValue;\n        }\n        return returns.size() > 0 ? sum / returns.size() : 0;\n    }\n\n    /**\n     * Analyzes the risk by calculating the standard deviation of the returns.\n     * \n     * @return the standard deviation of the returns\n     */\n    public double analyzeRisk() {\n        double mean = calculateAverageReturn();\n        double sumSquaredDiffs = 0;\n        for (double returnValue : returns) {\n            sumSquaredDiffs += Math.pow(returnValue - mean, 2);\n        }\n        return returns.size() > 1 ? Math.sqrt(sumSquaredDiffs / (returns.size() - 1)) : 0;\n    }\n\n    /**\n     * Finds the maximum return in the portfolio.\n     * \n     * @return the maximum return\n     */", "suffix": "\n\n    public static void main(String[] args) {\n        PortfolioAnalysis portfolio = new PortfolioAnalysis();\n        portfolio.addReturn(5.0);\n        portfolio.addReturn(10.0);\n        portfolio.addReturn(-2.0);\n        portfolio.addReturn(7.0);\n\n        assert portfolio.calculateAverageReturn() == 5.0 : \"Average return calculation is incorrect\";\n        assert portfolio.analyzeRisk() > 0 : \"Risk analysis is incorrect\";\n        assert portfolio.findMaxReturn() == 10.0 : \"Max return calculation is incorrect\";\n    }\n}\n", "golden_completion": "\n    public double findMaxReturn() {\n        return Collections.max(returns);\n    }\n", "LLM_justification": "This test case is a realistic scenario of portfolio analysis in financial calculations. It includes complex business logic for calculating average returns, analyzing risk, and finding the maximum return in a portfolio. The code-to-comment translation is tested by requiring comprehensive Javadoc-style documentation for a method that finds the maximum return. The comment-to-code translation is tested by implementing the method based on the provided Javadoc comments. Assertions are included in the suffix to ensure the correctness of the implementation and documentation, making this a robust test case for bidirectional translation between code and natural language.", "assertions": "", "gpt-4o_completion_0": "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "gpt-4o_completion_1": "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "gpt-4o_completion_2": "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "gpt-4o_completion_3": "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "gpt-4o_completion_4": "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "gpt-4o_completions": ["    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }", "    public double findMaxReturn() {\n        return returns.isEmpty() ? Double.NEGATIVE_INFINITY : Collections.max(returns);\n    }"]}
{"id": "11", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * This class represents a portfolio of financial assets. It provides methods for\n * adding assets, calculating the total value of the portfolio, and assessing risk.\n */\npublic class Portfolio {\n\n    private List<Asset> assets;\n\n    /**\n     * Constructor to initialize an empty portfolio.\n     */\n    public Portfolio() {\n        this.assets = new ArrayList<>();\n    }\n\n    /**\n     * Adds an asset to the portfolio.\n     *\n     * @param asset the asset to be added\n     */\n    public void addAsset(Asset asset) {\n        this.assets.add(asset);\n    }\n\n    /**\n     * Calculates the total value of the portfolio.\n     *\n     * @return the total value of the portfolio\n     */\n    public double calculateTotalValue() {\n        double totalValue = 0.0;\n        for (Asset asset : assets) {\n            totalValue += asset.getValue();\n        }\n        return totalValue;\n    }\n\n    /**\n     * Assesses the risk of the portfolio based on asset volatility.\n     *\n     * @return the risk score of the portfolio\n     */\n    public double assessRisk() {\n        double totalRisk = 0.0;\n        for (Asset asset : assets) {\n            totalRisk += asset.getVolatility();\n        }\n        return totalRisk / assets.size();\n    }\n\n    public static void main(String[] args) {\n        Portfolio portfolio = new Portfolio();\n        portfolio.addAsset(new Asset(1000, 0.05));\n        portfolio.addAsset(new Asset(2000, 0.1));\n        portfolio.addAsset(new Asset(1500, 0.07));\n\n        // Test calculateTotalValue method\n        double totalValue = portfolio.calculateTotalValue();\n        assert totalValue == 4500 : \"Total value should be 4500\";\n\n        // Test assessRisk method\n        double risk = portfolio.assessRisk();\n        assert Math.abs(risk - 0.07333333333333333) < 1e-9 : \"Risk should be approximately 0.0733\";\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n\n/**\n * This class represents a financial asset with a value and volatility.\n */\nclass Asset {\n\n    private double value;\n    private double volatility;\n\n    /**\n     * Constructor to initialize an asset with value and volatility.\n     *\n     * @param value the value of the asset\n     * @param volatility the volatility of the asset\n     */\n    public Asset(double value, double volatility) {\n        this.value = value;\n        this.volatility = volatility;\n    }\n\n    /**\n     * Gets the value of the asset.\n     *\n     * @return the value of the asset\n     */\n    public double getValue() {\n        return value;\n    }\n\n    /**\n     * Gets the volatility of the asset.\n     *\n     * @return the volatility of the asset\n     */\n    public double getVolatility() {\n        return volatility;\n    }\n}\n\n\n", "suffix": "", "golden_completion": "\n    /**\n     * Tests the Portfolio class by adding assets and verifying the total value and risk.\n     */", "LLM_justification": "This test case provides a realistic scenario of managing a portfolio of financial assets. The prefix includes comprehensive documentation for the Portfolio and Asset classes, testing code-to-comment translation. The golden_completion requires generating a method-level Javadoc comment, testing comment-to-code translation. The suffix includes assertions to verify the correctness of the Portfolio class methods, ensuring that the documentation accurately describes the functionality. This example tests the LLM's ability to generate and understand detailed comments and match them with code logic.", "assertions": "", "gpt-4o_completion_0": "// There is no TODO placeholder in the provided code snippet. Please clarify or provide the specific section to replace.", "gpt-4o_completion_1": "// There is no TODO in the provided code snippet.", "gpt-4o_completion_2": "// There is no TODO in the provided code snippet.", "gpt-4o_completion_3": "System.out.println(\"Portfolio Total Value: \" + portfolio.calculateTotalValue());\nSystem.out.println(\"Portfolio Risk Assessment: \" + portfolio.assessRisk());", "gpt-4o_completion_4": "// No additional code is needed here as the program is complete and functional.", "gpt-4o_completions": ["// There is no TODO placeholder in the provided code snippet. Please clarify or provide the specific section to replace.", "// There is no TODO in the provided code snippet.", "// There is no TODO in the provided code snippet.", "System.out.println(\"Portfolio Total Value: \" + portfolio.calculateTotalValue());\nSystem.out.println(\"Portfolio Risk Assessment: \" + portfolio.assessRisk());", "// No additional code is needed here as the program is complete and functional."]}
{"id": "12", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * This class represents a portfolio of financial assets.\n * It provides methods to calculate the total value of the portfolio\n * and to filter assets based on a minimum value threshold.\n */\npublic class Portfolio {\n\n    /**\n     * Represents a financial asset with a name and a value.\n     */\n    private static class Asset {\n        private String name;\n        private double value;\n\n        public Asset(String name, double value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public double getValue() {\n            return value;\n        }\n    }\n\n    private List<Asset> assets;\n\n    public Portfolio() {\n        this.assets = new ArrayList<>();\n    }\n\n    /**\n     * Adds an asset to the portfolio.\n     * @param name The name of the asset.\n     * @param value The value of the asset.\n     */\n    public void addAsset(String name, double value) {\n        assets.add(new Asset(name, value));\n    }\n\n    /**\n     * Calculates the total value of the portfolio.\n     * @return The total value of all assets in the portfolio.\n     */\n    public double calculateTotalValue() {\n        double totalValue = 0;\n        for (Asset asset : assets) {\n            totalValue += asset.getValue();\n        }\n        return totalValue;\n    }\n", "suffix": "\n    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        Portfolio portfolio = new Portfolio();\n        portfolio.addAsset(\"Stock A\", 1000);\n        portfolio.addAsset(\"Stock B\", 500);\n        portfolio.addAsset(\"Stock C\", 1500);\n\n        // Assert total value calculation\n        double totalValue = portfolio.calculateTotalValue();\n        assert totalValue == 3000 : \"Total value should be 3000\";\n\n        // Assert filtering functionality\n        List<Asset> filteredAssets = portfolio.filterAssetsByValue(1000);\n        assert filteredAssets.size() == 2 : \"There should be 2 assets with value >= 1000\";\n        assert filteredAssets.get(0).getName().equals(\"Stock A\") : \"First asset should be 'Stock A'\";\n        assert filteredAssets.get(1).getName().equals(\"Stock C\") : \"Second asset should be 'Stock C'\";\n    }\n}", "golden_completion": "    /**\n     * Filters the assets in the portfolio based on a minimum value threshold.\n     * @param minValue The minimum value threshold.\n     * @return A list of assets that have a value greater than or equal to the minimum value.\n     */\n", "LLM_justification": "This test case is a good example of translating between code and natural language as it involves a realistic business scenario of managing financial assets in a portfolio. The prefix provides a comprehensive setup of the Portfolio class with detailed documentation and methods for adding assets and calculating the total value. The golden completion involves adding a method to filter assets based on their value, which is a practical requirement in portfolio management. The suffix includes assertions to verify the correctness of the implementation, ensuring that the filter method works as expected. This test case effectively demonstrates the ability to generate accurate and meaningful documentation for complex business logic and verify the implementation through assertions.", "assertions": "", "gpt-4o_completion_0": "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completion_1": "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completion_2": "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completion_3": "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completion_4": "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "gpt-4o_completions": ["    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }", "    public List<Asset> filterAssetsByValue(double minValue) {\n        return assets.stream()\n                     .filter(asset -> asset.getValue() >= minValue)\n                     .collect(Collectors.toList());\n    }"]}
{"id": "13", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\n\n", "suffix": "public class Portfolio {\n    private List<Asset> assets;\n\n    /**\n     * Constructor to initialize the portfolio with a list of assets.\n     * \n     * @param assets List of assets to be included in the portfolio.\n     */\n    public Portfolio(List<Asset> assets) {\n        this.assets = assets;\n    }\n\n    /**\n     * Method to calculate the total value of the portfolio.\n     * The total value is the sum of the values of all assets in the portfolio.\n     *\n     * @return The total value of the portfolio.\n     */\n    public double calculateTotalValue() {\n        return assets.stream().mapToDouble(Asset::getValue).sum();\n    }\n\n    /**\n     * Method to find assets above a certain value threshold.\n     *\n     * @param threshold The value threshold to filter assets.\n     * @return List of assets whose value is above the threshold.\n     */\n    public List<Asset> findAssetsAboveValue(double threshold) {\n        return assets.stream()\n                .filter(asset -> asset.getValue() > threshold)\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Method to get the asset with the highest value in the portfolio.\n     *\n     * @return The asset with the highest value.\n     */\n    public Asset getHighestValueAsset() {\n        return assets.stream()\n                .max((a1, a2) -> Double.compare(a1.getValue(), a2.getValue()))\n                .orElse(null);\n    }\n\n    /**\n     * Method to get the asset with the lowest value in the portfolio.\n     *\n     * @return The asset with the lowest value.\n     */\n    public Asset getLowestValueAsset() {\n        return assets.stream()\n                .min((a1, a2) -> Double.compare(a1.getValue(), a2.getValue()))\n                .orElse(null);\n    }\n\n    public static void main(String[] args) {\n        List<Asset> assets = new ArrayList<>();\n        assets.add(new Asset(\"Asset1\", 100.0));\n        assets.add(new Asset(\"Asset2\", 200.0));\n        assets.add(new Asset(\"Asset3\", 50.0));\n\n        Portfolio portfolio = new Portfolio(assets);\n\n        // Test calculateTotalValue method\n        double totalValue = portfolio.calculateTotalValue();\n        assert totalValue == 350.0 : \"Total value calculation is incorrect\";\n\n        // Test findAssetsAboveValue method\n        List<Asset> valuableAssets = portfolio.findAssetsAboveValue(100.0);\n        assert valuableAssets.size() == 1 : \"Find assets above value method is incorrect\";\n        assert valuableAssets.get(0).getValue() == 200.0 : \"Find assets above value method is incorrect\";\n\n        // Test getHighestValueAsset method\n        Asset highestValueAsset = portfolio.getHighestValueAsset();\n        assert highestValueAsset != null : \"Highest value asset method is incorrect\";\n        assert highestValueAsset.getValue() == 200.0 : \"Highest value asset method is incorrect\";\n\n        // Test getLowestValueAsset method\n        Asset lowestValueAsset = portfolio.getLowestValueAsset();\n        assert lowestValueAsset != null : \"Lowest value asset method is incorrect\";\n        assert lowestValueAsset.getValue() == 50.0 : \"Lowest value asset method is incorrect\";\n    }\n}\n\n/**\n * Class representing an asset with a name and value.\n */\nclass Asset {\n    private String name;\n    private double value;\n\n    /**\n     * Constructor to initialize an asset with a name and value.\n     *\n     * @param name The name of the asset.\n     * @param value The value of the asset.\n     */\n    public Asset(String name, double value) {\n        this.name = name;\n        this.value = value;\n    }\n\n    /**\n     * Method to get the value of the asset.\n     *\n     * @return The value of the asset.\n     */\n    public double getValue() {\n        return value;\n    }\n}\nclass PortfolioTest {\n    public static void main(String[] args) {\n        List<Asset> assets = new ArrayList<>();\n        assets.add(new Asset(\"Asset1\", 100.0));\n        assets.add(new Asset(\"Asset2\", 200.0));\n        assets.add(new Asset(\"Asset3\", 50.0));\n\n        Portfolio portfolio = new Portfolio(assets);\n\n        // Test calculateTotalValue method\n        double totalValue = portfolio.calculateTotalValue();\n        assert totalValue == 350.0 : \"Total value calculation is incorrect\";\n\n        // Test findAssetsAboveValue method\n        List<Asset> valuableAssets = portfolio.findAssetsAboveValue(100.0);\n        assert valuableAssets.size() == 1 : \"Find assets above value method is incorrect\";\n        assert valuableAssets.get(0).getValue() == 200.0 : \"Find assets above value method is incorrect\";\n\n        // Test getHighestValueAsset method\n        Asset highestValueAsset = portfolio.getHighestValueAsset();\n        assert highestValueAsset != null : \"Highest value asset method is incorrect\";\n        assert highestValueAsset.getValue() == 200.0 : \"Highest value asset method is incorrect\";\n\n        // Test getLowestValueAsset method\n        Asset lowestValueAsset = portfolio.getLowestValueAsset();\n        assert lowestValueAsset != null : \"Lowest value asset method is incorrect\";\n        assert lowestValueAsset.getValue() == 50.0 : \"Lowest value asset method is incorrect\";\n    }\n}\n", "golden_completion": "/**\n * A class representing a portfolio of assets with various financial calculations.\n * This class provides methods to calculate the total value of the portfolio,\n * find assets above a specific value, and identify the assets with the highest\n * and lowest values.\n */\n", "LLM_justification": "This test case effectively evaluates the LLM's ability to translate between code and documentation in a business logic context. The prefix provides a comprehensive implementation of a portfolio analysis with detailed method comments. The golden_completion requires the model to generate a class-level Javadoc comment that captures the essence of the class and its methods. The suffix includes assertions to validate the correctness of the implementation, ensuring that all methods perform as expected. This scenario tests both code-to-comment and comment-to-code translation capabilities in a realistic financial calculation context.", "assertions": "", "gpt-4o_completion_0": "public class Portfolio {", "gpt-4o_completion_1": "public class Portfolio {", "gpt-4o_completion_2": "public class Portfolio {", "gpt-4o_completion_3": "public class Portfolio {", "gpt-4o_completion_4": "public class Portfolio {", "gpt-4o_completions": ["public class Portfolio {", "public class Portfolio {", "public class Portfolio {", "public class Portfolio {", "public class Portfolio {"]}
{"id": "14", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Represents an investment portfolio.\n */\npublic class Portfolio {\n    private List<Double> investments;\n\n    /**\n     * Initializes a new portfolio with no investments.\n     */\n    public Portfolio() {\n        this.investments = new ArrayList<>();\n    }\n\n    /**\n     * Adds an investment to the portfolio.\n     *\n     * @param amount the amount to invest\n     */\n    public void addInvestment(double amount) {\n        this.investments.add(amount);\n    }\n\n    /**\n     * Calculates the total value of the portfolio.\n     *\n     * @return the total value of all investments\n     */\n    public double getTotalValue() {\n        double total = 0;\n        for (double investment : investments) {\n            total += investment;\n        }\n        return total;\n    }\n\n    /**\n     * Calculates the average value of the investments in the portfolio.\n     *\n     * @return the average value of the investments\n     */\n", "suffix": "    public static void main(String[] args) {\n        Portfolio portfolio = new Portfolio();\n        portfolio.addInvestment(1000.0);\n        portfolio.addInvestment(2000.0);\n        portfolio.addInvestment(3000.0);\n\n        double totalValue = portfolio.getTotalValue();\n        double averageValue = portfolio.getAverageValue();\n\n        // Assertions\n        assert totalValue == 6000.0 : \"Total value should be 6000.0\";\n        assert averageValue == 2000.0 : \"Average value should be 2000.0\";\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0.0;\n        }\n        return getTotalValue() / investments.size();\n    }", "LLM_justification": "This test case is a good example because it combines both code-to-comment and comment-to-code translation. The prefix contains a partially implemented Portfolio class with detailed Javadoc comments, while the golden completion requires the model to generate the method implementation for calculating the average value of investments based on the provided comments. The suffix includes assertions to verify the correctness of the method implementation, ensuring that all functional requirements are met and edge cases are handled correctly.", "assertions": "", "gpt-4o_completion_0": "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0;\n        }\n        return getTotalValue() / investments.size();\n    }", "gpt-4o_completion_1": "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0;\n        }\n        return getTotalValue() / investments.size();\n    }", "gpt-4o_completion_2": "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0;\n        }\n        return getTotalValue() / investments.size();\n    }", "gpt-4o_completion_3": "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0;\n        }\n        return getTotalValue() / investments.size();\n    }", "gpt-4o_completion_4": "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0.0;\n        }\n        return getTotalValue() / investments.size();\n    }", "gpt-4o_completions": ["    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0;\n        }\n        return getTotalValue() / investments.size();\n    }", "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0;\n        }\n        return getTotalValue() / investments.size();\n    }", "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0;\n        }\n        return getTotalValue() / investments.size();\n    }", "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0;\n        }\n        return getTotalValue() / investments.size();\n    }", "    public double getAverageValue() {\n        if (investments.isEmpty()) {\n            return 0.0;\n        }\n        return getTotalValue() / investments.size();\n    }"]}
{"id": "15", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Class representing a simple portfolio analysis.\n * It calculates the average return of the portfolio based on historical data.\n */\npublic class PortfolioAnalysis {\n\n    /**\n     * Method to calculate the average return of a portfolio.\n     * \n     * @param returns A list of historical returns of the portfolio\n     * @return The average return of the portfolio\n     */\n    public double calculateAverageReturn(List<Double> returns) {\n        double sum = 0.0;\n        for (Double singleReturn : returns) {\n            sum += singleReturn;\n        }\n        return sum / returns.size();\n    }\n\n    public static void main(String[] args) {\n        PortfolioAnalysis analysis = new PortfolioAnalysis();\n        List<Double> historicalReturns = new ArrayList<>();\n        historicalReturns.add(0.05);\n        historicalReturns.add(0.10);\n        historicalReturns.add(0.15);\n        historicalReturns.add(-0.05);\n        historicalReturns.add(0.12);\n        historicalReturns.add(0.08);\n\n        double averageReturn = analysis.calculateAverageReturn(historicalReturns);\n        // Example usage and assertions\n        // Expected average return: (0.05 + 0.10 + 0.15 - 0.05 + 0.12 + 0.08) / 6 = 0.075\n", "suffix": "        // Assertions to verify the correctness of the calculateAverageReturn method\n        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;\n\n        // Resource cleanup if needed\n    }\n}\n", "golden_completion": "        System.out.println(\"Average Return: \" + averageReturn);\n", "LLM_justification": "This example tests the LLM's ability to translate between Java code and natural language documentation. The code calculates the average return of a portfolio based on historical data, and the golden completion provides a comprehensive example usage and documentation for the code. The assertions verify the correctness of the implementation by checking the calculated average return. This scenario is realistic, involving financial calculations and proper documentation, making it a good test case for code-to-comment and comment-to-code translation.", "assertions": "", "gpt-4o_completion_0": "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "gpt-4o_completion_1": "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "gpt-4o_completion_2": "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "gpt-4o_completion_3": "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "gpt-4o_completion_4": "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "gpt-4o_completions": ["        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;", "        assert Math.abs(averageReturn - 0.075) < 1e-9 : \"Test failed: Expected average return is 0.075 but got \" + averageReturn;"]}
{"id": "16", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * This class represents a simple ETL (Extract, Transform, Load) process.\n * It extracts data from a source, transforms it according to business rules,\n * and then loads it into a destination.\n */\npublic class SimpleETL {\n\n    /**\n     * Extracts data from the source.\n     * @return A list of raw data items.\n     */\n    public List<String> extract() {\n        List<String> rawData = new ArrayList<>();\n        rawData.add(\"data1\");\n        rawData.add(\"data2\");\n        rawData.add(\"data3\");\n        return rawData;\n    }\n\n    /**\n     * Transforms the raw data by applying business rules.\n     * For simplicity, this transformation converts all data to uppercase.\n     * @param rawData The list of raw data items.\n     * @return A list of transformed data items.\n     */\n    public List<String> transform(List<String> rawData) {\n        return rawData.stream().map(String::toUpperCase).collect(Collectors.toList());\n    }\n", "suffix": "\n    /**\n     * Loads the transformed data into the destination.\n     * In this example, it simply returns the data as is.\n     * @param transformedData The list of transformed data items.\n     * @return The list of loaded data items.\n     */\n    public List<String> load(List<String> transformedData) {\n        return transformedData;\n    }\n\n    public static void main(String[] args) {\n        SimpleETL etl = new SimpleETL();\n        List<String> rawData = etl.extract();\n        List<String> transformedData = etl.transform(rawData);\n        List<String> loadedData = etl.load(transformedData);\n\n        // Assertions to verify the correctness of the ETL process\n        assert rawData.size() == 3 : \"Raw data size should be 3\";\n        assert rawData.get(0).equals(\"data1\") : \"First raw data item should be 'data1'\";\n        assert transformedData.size() == 3 : \"Transformed data size should be 3\";\n        assert transformedData.get(0).equals(\"DATA1\") : \"First transformed data item should be 'DATA1'\";\n        assert loadedData.equals(transformedData) : \"Loaded data should match transformed data\";\n    }\n}\n", "golden_completion": "    /**\n     * This method orchestrates the entire ETL process.\n     * It extracts raw data, transforms it, and then loads it.\n     * @return The list of loaded data items.\n     */\n    public List<String> runETL() {\n        List<String> rawData = extract();\n        List<String> transformedData = transform(rawData);\n        return load(transformedData);\n    }\n", "LLM_justification": "This example provides a comprehensive ETL (Extract, Transform, Load) process implementation, which is a common business logic scenario. It tests the LLM's ability to generate accurate documentation for a method that orchestrates the ETL process. The example includes detailed Javadoc comments, parameter descriptions, and return value documentation. The assertions in the suffix verify the functional requirements and correctness of the ETL process, ensuring the LLM-generated documentation aligns with the code's behavior.", "assertions": "", "gpt-4o_completion_0": "    /**\n     * Validates the transformed data to ensure it meets certain criteria.\n     * For simplicity, this validation checks that all items are non-null and non-empty.\n     * @param transformedData The list of transformed data items.\n     * @return True if all items are valid, false otherwise.\n     */\n    public boolean validate(List<String> transformedData) {\n        return transformedData.stream().allMatch(item -> item != null && !item.isEmpty());\n    }", "gpt-4o_completion_1": "    /**\n     * This method orchestrates the ETL process by calling extract, transform, and load methods sequentially.\n     * @return The final loaded data after the ETL process.\n     */\n    public List<String> executeETL() {\n        List<String> rawData = extract();\n        List<String> transformedData = transform(rawData);\n        return load(transformedData);\n    }", "gpt-4o_completion_2": "    /**\n     * This method orchestrates the ETL process by calling extract, transform, and load in sequence.\n     * @return The list of loaded data items.\n     */\n    public List<String> executeETL() {\n        List<String> rawData = extract();\n        List<String> transformedData = transform(rawData);\n        return load(transformedData);\n    }", "gpt-4o_completion_3": "    /**\n     * This method orchestrates the ETL process.\n     * It extracts, transforms, and loads the data sequentially.\n     * @return The list of loaded data items.\n     */\n    public List<String> executeETL() {\n        List<String> rawData = extract();\n        List<String> transformedData = transform(rawData);\n        return load(transformedData);\n    }", "gpt-4o_completion_4": "    /**\n     * Validates the transformed data.\n     * For simplicity, this validation checks if all data items are non-empty.\n     * @param transformedData The list of transformed data items.\n     * @return True if all data items are valid, false otherwise.\n     */\n    public boolean validate(List<String> transformedData) {\n        return transformedData.stream().allMatch(data -> data != null && !data.isEmpty());\n    }", "gpt-4o_completions": ["    /**\n     * Validates the transformed data to ensure it meets certain criteria.\n     * For simplicity, this validation checks that all items are non-null and non-empty.\n     * @param transformedData The list of transformed data items.\n     * @return True if all items are valid, false otherwise.\n     */\n    public boolean validate(List<String> transformedData) {\n        return transformedData.stream().allMatch(item -> item != null && !item.isEmpty());\n    }", "    /**\n     * This method orchestrates the ETL process by calling extract, transform, and load methods sequentially.\n     * @return The final loaded data after the ETL process.\n     */\n    public List<String> executeETL() {\n        List<String> rawData = extract();\n        List<String> transformedData = transform(rawData);\n        return load(transformedData);\n    }", "    /**\n     * This method orchestrates the ETL process by calling extract, transform, and load in sequence.\n     * @return The list of loaded data items.\n     */\n    public List<String> executeETL() {\n        List<String> rawData = extract();\n        List<String> transformedData = transform(rawData);\n        return load(transformedData);\n    }", "    /**\n     * This method orchestrates the ETL process.\n     * It extracts, transforms, and loads the data sequentially.\n     * @return The list of loaded data items.\n     */\n    public List<String> executeETL() {\n        List<String> rawData = extract();\n        List<String> transformedData = transform(rawData);\n        return load(transformedData);\n    }", "    /**\n     * Validates the transformed data.\n     * For simplicity, this validation checks if all data items are non-empty.\n     * @param transformedData The list of transformed data items.\n     * @return True if all data items are valid, false otherwise.\n     */\n    public boolean validate(List<String> transformedData) {\n        return transformedData.stream().allMatch(data -> data != null && !data.isEmpty());\n    }"]}
{"id": "17", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * This class represents a simple task management system.\n * It allows adding tasks, marking them as completed, and retrieving the list of tasks.\n */\npublic class TaskManager {\n\n    /**\n     * This inner class represents a Task with a description and a completion status.\n     */\n    private static class Task {\n        private String description;\n        private boolean isCompleted;\n\n        public Task(String description) {\n            this.description = description;\n            this.isCompleted = false;\n        }\n\n        public String getDescription() {\n            return description;\n        }\n\n        public boolean isCompleted() {\n            return isCompleted;\n        }\n\n        public void markAsCompleted() {\n            this.isCompleted = true;\n        }\n    }\n\n    private final List<Task> tasks;\n\n    public TaskManager() {\n        this.tasks = new ArrayList<>();\n    }\n\n    /**\n     * Adds a new task to the task manager.\n     *\n     * @param description The description of the task to add.\n     * @throws IllegalArgumentException if the description is null or empty.\n     */\n    public void addTask(String description) {\n        if (description == null || description.isEmpty()) {\n            throw new IllegalArgumentException(\"Task description cannot be null or empty\");\n        }\n        tasks.add(new Task(description));\n    }\n\n    /**\n     * Marks the task at the specified index as completed.\n     *\n     * @param index The index of the task to mark as completed.\n     * @throws IndexOutOfBoundsException if the index is out of range.\n     */\n    public void markTaskAsCompleted(int index) {\n        if (index < 0 || index >= tasks.size()) {\n            throw new IndexOutOfBoundsException(\"Invalid task index\");\n        }\n        tasks.get(index).markAsCompleted();\n    }\n", "suffix": "\n    public List<String> getTasks() {\n        List<String> taskDescriptions = new ArrayList<>();\n        for (Task task : tasks) {\n            taskDescriptions.add(task.getDescription() + (task.isCompleted() ? \" (completed)\" : \"\"));\n        }\n        return taskDescriptions;\n    }\n\n    public static void main(String[] args) {\n        TaskManager taskManager = new TaskManager();\n        taskManager.addTask(\"Write unit tests\");\n        taskManager.addTask(\"Review pull request\");\n        taskManager.markTaskAsCompleted(0);\n\n        List<String> tasks = taskManager.getTasks();\n        assert tasks.size() == 2 : \"There should be 2 tasks\";\n        assert tasks.get(0).equals(\"Write unit tests (completed)\") : \"The first task should be marked as completed\";\n        assert tasks.get(1).equals(\"Review pull request\") : \"The second task should not be marked as completed\";\n    }\n}", "golden_completion": "\n    /**\n     * Retrieves the list of all tasks.\n     *\n     * @return The list of tasks.\n     */\n", "LLM_justification": "This test case provides a complex business logic scenario involving task management. The prefix includes class and method definitions that handle tasks with descriptions and completion status. The golden completion requires the LLM to generate a method that retrieves the list of tasks, ensuring that the descriptions of completed tasks are annotated appropriately. The suffix includes assertions to verify the method's functionality and the correctness of the task management logic. This scenario tests the LLM's ability to translate detailed comments into accurate code and vice versa.", "assertions": "", "gpt-4o_completion_0": "    /**\n     * Retrieves the list of tasks with their completion status.\n     *\n     * @return A list of task descriptions with their completion status.\n     */", "gpt-4o_completion_1": "    /**\n     * Retrieves the list of tasks with their completion status.\n     *\n     * @return A list of task descriptions with their completion status.\n     */", "gpt-4o_completion_2": "    /**\n     * Retrieves the list of tasks with their completion status.\n     *\n     * @return A list of task descriptions with their completion status.\n     */", "gpt-4o_completion_3": "    /**\n     * Retrieves the list of tasks with their completion status.\n     *\n     * @return A list of task descriptions with their completion status.\n     */", "gpt-4o_completion_4": "    public List<String> getTasks() {\n        List<String> taskDescriptions = new ArrayList<>();\n        for (Task task : tasks) {\n            taskDescriptions.add(task.getDescription() + (task.isCompleted() ? \" (completed)\" : \"\"));\n        }\n        return taskDescriptions;\n    }", "gpt-4o_completions": ["    /**\n     * Retrieves the list of tasks with their completion status.\n     *\n     * @return A list of task descriptions with their completion status.\n     */", "    /**\n     * Retrieves the list of tasks with their completion status.\n     *\n     * @return A list of task descriptions with their completion status.\n     */", "    /**\n     * Retrieves the list of tasks with their completion status.\n     *\n     * @return A list of task descriptions with their completion status.\n     */", "    /**\n     * Retrieves the list of tasks with their completion status.\n     *\n     * @return A list of task descriptions with their completion status.\n     */", "    public List<String> getTasks() {\n        List<String> taskDescriptions = new ArrayList<>();\n        for (Task task : tasks) {\n            taskDescriptions.add(task.getDescription() + (task.isCompleted() ? \" (completed)\" : \"\"));\n        }\n        return taskDescriptions;\n    }"]}
{"id": "18", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n", "suffix": "\npublic class BusinessEntityManager {\n\n    private List<String> entities;\n\n    /**\n     * Constructor to initialize the BusinessEntityManager.\n     */\n    public BusinessEntityManager() {\n        this.entities = new ArrayList<>();\n    }\n\n    /**\n     * Adds a new entity to the list.\n     *\n     * @param entity The entity to be added.\n     */\n    public void addEntity(String entity) {\n        entities.add(entity);\n    }\n\n    /**\n     * Transforms the data of all entities by converting them to uppercase.\n     */\n    public void transformEntitiesToUppercase() {\n        for (int i = 0; i < entities.size(); i++) {\n            entities.set(i, entities.get(i).toUpperCase());\n        }\n    }\n\n    /**\n     * Retrieves all entities in the list.\n     *\n     * @return A list of all entities.\n     */\n    public List<String> getEntities() {\n        return entities;\n    }\n\n    /**\n     * Validates whether all entities in the list adhere to a specific business rule.\n     * The rule is that entities must be non-empty strings.\n     *\n     * @return true if all entities are valid, false otherwise.\n     */\n    public boolean validateEntities() {\n        for (String entity : entities) {\n            if (entity == null || entity.isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        BusinessEntityManager manager = new BusinessEntityManager();\n        manager.addEntity(\"entityOne\");\n        manager.addEntity(\"entityTwo\");\n        manager.addEntity(\"entityThree\");\n        // Transform entities to uppercase\n        manager.transformEntitiesToUppercase();\n\n        // Retrieve and print all entities\n        List<String> transformedEntities = manager.getEntities();\n        for (String entity : transformedEntities) {\n            System.out.println(entity);\n        }\n\n        // Assertions\n        assert transformedEntities.get(0).equals(\"ENTITYONE\");\n        assert transformedEntities.get(1).equals(\"ENTITYTWO\");\n        assert transformedEntities.get(2).equals(\"ENTITYTHREE\");\n\n        // Validate entities\n        boolean areEntitiesValid = manager.validateEntities();\n        assert areEntitiesValid;\n    }\n}\n", "golden_completion": "/**\n * This class provides a manager for handling business entities with functionalities\n * such as adding new entities, transforming entities' data to uppercase, retrieving\n * entities, and validating entities based on specific business rules.\n */\n", "LLM_justification": "This example provides a realistic scenario of managing business entities with various operations such as adding, transforming, retrieving, and validating entities. The code includes detailed Javadoc-style documentation, making it suitable for testing code-to-comment translation. The golden completion includes comprehensive class-level documentation that aligns with the implementation, while the suffix contains code execution and assertions verifying the functionality of the class. The prefix is substantially long, providing extensive context and ensuring a robust test case for bidirectional translation capabilities.", "assertions": "", "gpt-4o_completion_0": "package com.example.business;", "gpt-4o_completion_1": "package com.example.business;", "gpt-4o_completion_2": "package com.example.business;", "gpt-4o_completion_3": "package com.example.business;", "gpt-4o_completion_4": "package com.example.business;", "gpt-4o_completions": ["package com.example.business;", "package com.example.business;", "package com.example.business;", "package com.example.business;", "package com.example.business;"]}
{"id": "19", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * This class represents a simple in-memory cache manager.\n * It supports basic operations such as adding, retrieving, and invalidating cache entries.\n */\npublic class CacheManager {\n    private Map<String, CacheEntry> cache;\n\n    public CacheManager() {\n        this.cache = new HashMap<>();\n    }\n\n    /**\n     * Adds an entry to the cache.\n     * \n     * @param key The key under which the entry should be stored.\n     * @param value The value to be stored in the cache.\n     */\n    public void addEntry(String key, Object value) {\n        CacheEntry entry = new CacheEntry(value);\n        cache.put(key, entry);\n    }\n\n    /**\n     * Retrieves an entry from the cache.\n     * \n     * @param key The key of the entry to be retrieved.\n     * @return The value associated with the key, or null if the key does not exist.\n     */\n    public Object getEntry(String key) {\n        CacheEntry entry = cache.get(key);\n        if (entry != null) {\n            return entry.getValue();\n        }\n        return null;\n    }\n\n    /**\n     * Invalidates an entry in the cache.\n     * \n     * @param key The key of the entry to be invalidated.\n     */\n    public void invalidateEntry(String key) {\n        cache.remove(key);\n    }\n\n    /**\n     * This inner class represents a cache entry.\n     * It stores the value and the timestamp of when the entry was created.\n     */\n    private static class CacheEntry {\n        private Object value;\n        private long timestamp;\n\n        public CacheEntry(Object value) {\n            this.value = value;\n            this.timestamp = System.currentTimeMillis();\n        }\n\n        public Object getValue() {\n            return value;\n        }\n\n        public long getTimestamp() {\n            return timestamp;\n        }\n    }\n\n    /**\n     * Retrieves all keys currently stored in the cache.\n     * \n     * @return A list of all keys in the cache.\n     */\n", "suffix": "\n\n    public static void main(String[] args) {\n        CacheManager cacheManager = new CacheManager();\n        cacheManager.addEntry(\"key1\", \"value1\");\n        cacheManager.addEntry(\"key2\", \"value2\");\n\n        // Test getAllKeys method\n        List<String> keys = cacheManager.getAllKeys();\n        assert keys.contains(\"key1\");\n        assert keys.contains(\"key2\");\n        assert keys.size() == 2;\n\n        // Test getEntry method\n        assert \"value1\".equals(cacheManager.getEntry(\"key1\"));\n        assert \"value2\".equals(cacheManager.getEntry(\"key2\"));\n        assert cacheManager.getEntry(\"key3\") == null;\n\n        // Test invalidateEntry method\n        cacheManager.invalidateEntry(\"key1\");\n        assert cacheManager.getEntry(\"key1\") == null;\n        assert cacheManager.getAllKeys().size() == 1;\n    }\n}\n", "golden_completion": "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }\n", "LLM_justification": "This test case provides a comprehensive scenario for a cache management system, which is a common technical feature in software development. The prefix includes a fully functional cache manager with methods for adding, retrieving, and invalidating cache entries. The golden completion requires the LLM to implement a method to retrieve all keys currently stored in the cache, which tests the model's understanding of the existing code and its ability to extend functionality. The suffix includes assertions that verify the correctness of all implemented methods, ensuring that the cache operations work as expected.", "assertions": "", "gpt-4o_completion_0": "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "gpt-4o_completion_1": "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "gpt-4o_completion_2": "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "gpt-4o_completion_3": "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "gpt-4o_completion_4": "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "gpt-4o_completions": ["    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }", "    public List<String> getAllKeys() {\n        return new ArrayList<>(cache.keySet());\n    }"]}
{"id": "20", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n", "suffix": "\npublic class ConfigurationManager {\n    private final Map<String, String> settings;\n\n    /**\n     * Constructs a new ConfigurationManager with default settings.\n     */\n    public ConfigurationManager() {\n        this.settings = new HashMap<>();\n        // Load default settings\n        loadDefaultSettings();\n    }\n\n    /**\n     * Loads the default settings into the settings map.\n     */\n    private void loadDefaultSettings() {\n        settings.put(\"featureXEnabled\", \"true\");\n        settings.put(\"maxConnections\", \"10\");\n        settings.put(\"timeout\", \"5000\");\n    }\n\n    /**\n     * Gets the value of a setting.\n     * \n     * @param key the key of the setting\n     * @return the value of the setting, or null if the setting does not exist\n     */\n    public String getSetting(String key) {\n        return settings.get(key);\n    }\n\n    /**\n     * Sets the value of a setting.\n     * \n     * @param key the key of the setting\n     * @param value the value of the setting\n     */\n    public void setSetting(String key, String value) {\n        settings.put(key, value);\n    }\n\n    /**\n     * Refreshes the settings by reloading them from a data source.\n     */\n    public void refreshSettings() {\n        // Simulate reloading settings\n        settings.put(\"featureXEnabled\", \"false\");\n        settings.put(\"maxConnections\", \"20\");\n        settings.put(\"timeout\", \"10000\");\n    }\n\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n        // Test default settings\n        assert \"true\".equals(configManager.getSetting(\"featureXEnabled\"));\n        assert \"10\".equals(configManager.getSetting(\"maxConnections\"));\n        assert \"5000\".equals(configManager.getSetting(\"timeout\"));\n\n        // Test setting and getting a new value\n        configManager.setSetting(\"newSetting\", \"newValue\");\n        assert \"newValue\".equals(configManager.getSetting(\"newSetting\"));\n\n        // Test refreshing settings\n        configManager.refreshSettings();\n        assert \"false\".equals(configManager.getSetting(\"featureXEnabled\"));\n        assert \"20\".equals(configManager.getSetting(\"maxConnections\"));\n        assert \"10000\".equals(configManager.getSetting(\"timeout\"));\n    }\n}", "golden_completion": "/**\n * ConfigurationManager is responsible for managing application settings.\n * It supports dynamic settings and feature flags that can be updated at runtime.\n * The settings are stored in a key-value map and can be refreshed to reflect changes from a data source.\n *\n * <p>Example usage:</p>\n * <pre>\n * ConfigurationManager configManager = new ConfigurationManager();\n * String value = configManager.getSetting(\"featureXEnabled\");\n * configManager.setSetting(\"newSetting\", \"newValue\");\n * configManager.refreshSettings();\n * </pre>\n *\n * <p>Methods:</p>\n * <ul>\n *   <li>{@link #getSetting(String)} - Retrieves the value of a setting</li>\n *   <li>{@link #setSetting(String, String)} - Updates the value of a setting</li>\n *   <li>{@link #refreshSettings()} - Reloads the settings from a data source</li>\n * </ul>\n */", "LLM_justification": "This test case is designed to evaluate the LLM's capability to generate comprehensive documentation for a realistic configuration management class. It includes detailed Javadoc comments that explain the class's purpose, usage examples, and method descriptions, which are essential for understanding and maintaining the code. The assertions in the suffix verify the functionality of the ConfigurationManager class, ensuring that the generated documentation accurately describes the implemented behavior.", "assertions": "", "gpt-4o_completion_0": "package com.example.configuration;", "gpt-4o_completion_1": "package com.example.configuration;", "gpt-4o_completion_2": "package com.example.configuration;", "gpt-4o_completion_3": "package com.example.configuration;", "gpt-4o_completion_4": "package com.example.configuration;", "gpt-4o_completions": ["package com.example.configuration;", "package com.example.configuration;", "package com.example.configuration;", "package com.example.configuration;", "package com.example.configuration;"]}
{"id": "21", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * A class that provides methods to clean and transform customer data.\n */\npublic class CustomerDataProcessor {\n\n    /**\n     * Cleans the provided list of customer names by removing any null or empty values\n     * and trimming leading and trailing whitespace from remaining names.\n     *\n     * @param customerNames the list of customer names to be cleaned\n     * @return a list of cleaned customer names\n     */\n    public List<String> cleanCustomerNames(List<String> customerNames) {\n        if (customerNames == null) {\n            throw new IllegalArgumentException(\"Customer names list cannot be null\");\n        }\n        return customerNames.stream()\n                .filter(Objects::nonNull)\n                .map(String::trim)\n                .filter(name -> !name.isEmpty())\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Transforms the cleaned customer names into uppercase.\n     *\n     * @param cleanedNames the list of cleaned customer names\n     * @return a list of customer names in uppercase\n     */\n", "suffix": "\n\n    public static void main(String[] args) {\n        CustomerDataProcessor processor = new CustomerDataProcessor();\n        List<String> rawNames = Arrays.asList(\" Alice \", \"Bob\", \"   \", null, \"Charlie\");\n        List<String> cleanedNames = processor.cleanCustomerNames(rawNames);\n        List<String> uppercasedNames = processor.transformNamesToUpperCase(cleanedNames);\n\n        // Assertions\n        assert cleanedNames.size() == 3 : \"Expected 3 cleaned names\";\n        assert cleanedNames.contains(\"Alice\") : \"Expected cleaned name 'Alice'\";\n        assert cleanedNames.contains(\"Bob\") : \"Expected cleaned name 'Bob'\";\n        assert cleanedNames.contains(\"Charlie\") : \"Expected cleaned name 'Charlie'\";\n\n        assert uppercasedNames.size() == 3 : \"Expected 3 uppercased names\";\n        assert uppercasedNames.contains(\"ALICE\") : \"Expected uppercased name 'ALICE'\";\n        assert uppercasedNames.contains(\"BOB\") : \"Expected uppercased name 'BOB'\";\n        assert uppercasedNames.contains(\"CHARLIE\") : \"Expected uppercased name 'CHARLIE'\";\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }\n", "LLM_justification": "This example tests the ability of an LLM to accurately translate between code and natural language. The prefix provides a detailed context with a method to clean customer names, including Javadoc comments. The golden_completion requires generating the method to transform names to uppercase, following the provided documentation pattern. The suffix includes assertions that validate the correctness of both the cleaning and transformation methods, ensuring that the generated code meets functional requirements and handles edge cases appropriately. This scenario is realistic as it involves common data cleaning and transformation tasks in business logic.", "assertions": "", "gpt-4o_completion_0": "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "gpt-4o_completion_1": "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "gpt-4o_completion_2": "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "gpt-4o_completion_3": "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "gpt-4o_completion_4": "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "gpt-4o_completions": ["    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }", "    public List<String> transformNamesToUpperCase(List<String> cleanedNames) {\n        if (cleanedNames == null) {\n            throw new IllegalArgumentException(\"Cleaned names list cannot be null\");\n        }\n        return cleanedNames.stream()\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }"]}
{"id": "22", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * This class handles a list of business transactions.\n * It provides functionality to add transactions, filter them based on criteria,\n * and calculate the total amount of all transactions.\n */\npublic class TransactionProcessor {\n    private List<Transaction> transactions;\n\n    public TransactionProcessor() {\n        transactions = new ArrayList<>();\n    }\n\n    /**\n     * Adds a new transaction to the list.\n     * \n     * @param transaction The transaction to add.\n     */\n    public void addTransaction(Transaction transaction) {\n        transactions.add(transaction);\n    }\n\n    /**\n     * Filters the transactions based on the provided criteria.\n     * \n     * @param criteria The criteria to filter transactions.\n     * @return A list of transactions that match the criteria.\n     */\n    public List<Transaction> filterTransactions(TransactionCriteria criteria) {\n        return transactions.stream()\n                .filter(criteria::matches)\n                .collect(Collectors.toList());\n    }\n", "suffix": "\n\n    public static void main(String[] args) {\n        TransactionProcessor processor = new TransactionProcessor();\n        processor.addTransaction(new Transaction(100.0));\n        processor.addTransaction(new Transaction(200.0));\n        processor.addTransaction(new Transaction(300.0));\n\n        double total = processor.calculateTotalAmount();\n        assert total == 600.0 : \"Total amount should be 600.0\";\n\n        TransactionCriteria criteria = new TransactionCriteria(150.0);\n        List<Transaction> filtered = processor.filterTransactions(criteria);\n        assert filtered.size() == 2 : \"There should be 2 transactions greater than 150.0\";\n        assert filtered.get(0).getAmount() == 200.0 : \"First filtered transaction should be 200.0\";\n        assert filtered.get(1).getAmount() == 300.0 : \"Second filtered transaction should be 300.0\";\n    }\n}\n\nclass Transaction {\n    private double amount;\n\n    public Transaction(double amount) {\n        this.amount = amount;\n    }\n\n    public double getAmount() {\n        return amount;\n    }\n}\n\nclass TransactionCriteria {\n    private double minAmount;\n\n    public TransactionCriteria(double minAmount) {\n        this.minAmount = minAmount;\n    }\n\n    public boolean matches(Transaction transaction) {\n        return transaction.getAmount() > minAmount;\n    }\n}\n", "golden_completion": "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount of all transactions.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }\n", "LLM_justification": "This test case provides a realistic business scenario involving transactions, which are common in financial systems. It includes complex business logic such as adding transactions, filtering them based on criteria, and calculating the total amount. The code-to-comment translation tests the model's ability to generate comprehensive documentation, while the comment-to-code translation tests the model's capability to implement functions based on detailed Javadoc comments. Assertions are included to verify the correctness of the implementation, ensuring that the total amount calculation and filtering logic work as expected.", "assertions": "", "gpt-4o_completion_0": "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "gpt-4o_completion_1": "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "gpt-4o_completion_2": "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "gpt-4o_completion_3": "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "gpt-4o_completion_4": "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "gpt-4o_completions": ["    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }", "    /**\n     * Calculates the total amount of all transactions.\n     * \n     * @return The total amount.\n     */\n    public double calculateTotalAmount() {\n        return transactions.stream()\n                .mapToDouble(Transaction::getAmount)\n                .sum();\n    }"]}
{"id": "23", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * This class handles the transformation of raw data into a cleaned and structured format.\n * It includes methods to filter, sort, and validate the data according to business rules.\n */\npublic class DataTransformer {\n\n    /**\n     * Filters a list of raw data to exclude any null or empty entries.\n     * @param rawData the list of raw data\n     * @return a list of non-null, non-empty data\n     */\n    public List<String> filterData(List<String> rawData) {\n        List<String> filteredData = new ArrayList<>();\n        for (String data : rawData) {\n            if (data != null && !data.isEmpty()) {\n                filteredData.add(data);\n            }\n        }\n        return filteredData;\n    }\n\n    /**\n     * Sorts a list of data in ascending order.\n     * @param data the list of data\n     * @return a sorted list of data\n     */\n    public List<String> sortData(List<String> data) {\n        data.sort(String::compareTo);\n        return data;\n    }\n\n    /**\n     * Validates the data according to specific business rules.\n     * For example, data entries must be at least 3 characters long.\n     * @param data the list of data\n     * @return true if all data entries are valid, false otherwise\n     */\n    public boolean validateData(List<String> data) {\n        for (String entry : data) {\n            if (entry.length() < 3) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Transforms raw data by applying filtering, sorting, and validation.\n     * This method integrates the three steps into a single workflow.\n     * @param rawData the list of raw data\n     * @return a cleaned and validated list of data\n     */\n", "suffix": "\n    public static void main(String[] args) {\n        DataTransformer transformer = new DataTransformer();\n        List<String> rawData = Arrays.asList(\"\", \"abc\", null, \"de\", \"fghi\", \"a\");\n\n        // Filter data\n        List<String> filteredData = transformer.filterData(rawData);\n        assert filteredData.size() == 4;\n        assert filteredData.contains(\"abc\");\n        assert filteredData.contains(\"de\");\n        assert filteredData.contains(\"fghi\");\n        assert filteredData.contains(\"a\");\n\n        // Sort data\n        List<String> sortedData = transformer.sortData(filteredData);\n        assert sortedData.get(0).equals(\"a\");\n        assert sortedData.get(1).equals(\"abc\");\n        assert sortedData.get(2).equals(\"de\");\n        assert sortedData.get(3).equals(\"fghi\");\n\n        // Validate data\n        boolean isValid = transformer.validateData(sortedData);\n        assert !isValid;\n    }\n}\n", "golden_completion": "\n    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>(); // Return an empty list if validation fails\n        }\n    }\n", "LLM_justification": "This test case is a good example because it covers the transformation of raw data through multiple steps: filtering, sorting, and validating. It tests the LLM's ability to generate comprehensive documentation for a method that integrates these steps. The scenario includes realistic business logic and validation rules, ensuring that the generated documentation is accurate and detailed. The assertions verify the correctness of the implementation and the accuracy of the documentation.", "assertions": "", "gpt-4o_completion_0": "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "gpt-4o_completion_1": "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "gpt-4o_completion_2": "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "gpt-4o_completion_3": "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "gpt-4o_completion_4": "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "gpt-4o_completions": ["    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }", "    public List<String> transformData(List<String> rawData) {\n        List<String> filteredData = filterData(rawData);\n        List<String> sortedData = sortData(filteredData);\n        if (validateData(sortedData)) {\n            return sortedData;\n        } else {\n            return new ArrayList<>();\n        }\n    }"]}
{"id": "24", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n", "suffix": "\npublic class WorkflowManager {\n\n    /**\n     * Represents a task with a name and status.\n     */\n    private static class Task {\n        String name;\n        boolean isCompleted;\n\n        Task(String name) {\n            this.name = name;\n            this.isCompleted = false;\n        }\n    }\n\n    private final List<Task> tasks = new ArrayList<>();\n\n    /**\n     * Adds a new task to the workflow.\n     *\n     * @param taskName the name of the task to add\n     */\n    public void addTask(String taskName) {\n        tasks.add(new Task(taskName));\n    }\n\n    /**\n     * Marks a task as completed.\n     *\n     * @param taskName the name of the task to mark as completed\n     * @throws IllegalArgumentException if the task does not exist\n     */\n    public void completeTask(String taskName) {\n        for (Task task : tasks) {\n            if (task.name.equals(taskName)) {\n                task.isCompleted = true;\n                return;\n            }\n        }\n        throw new IllegalArgumentException(\"Task not found: \" + taskName);\n    }\n\n    /**\n     * Returns a list of all tasks and their statuses.\n     *\n     * @return a list of tasks with their completion statuses\n     */\n    public List<String> getAllTasks() {\n        List<String> taskDescriptions = new ArrayList<>();\n        for (Task task : tasks) {\n            taskDescriptions.add(task.name + \" - \" + (task.isCompleted ? \"Completed\" : \"Pending\"));\n        }\n        return taskDescriptions;\n    }\n\n    public static void main(String[] args) {\n        WorkflowManager manager = new WorkflowManager();\n        manager.addTask(\"Task 1\");\n        manager.addTask(\"Task 2\");\n        manager.addTask(\"Task 3\");\n\n        manager.completeTask(\"Task 1\");\n\n        List<String> allTasks = manager.getAllTasks();\n        assert allTasks.size() == 3 : \"Should have 3 tasks\";\n        assert allTasks.get(0).equals(\"Task 1 - Completed\") : \"Task 1 should be completed\";\n        assert allTasks.get(1).equals(\"Task 2 - Pending\") : \"Task 2 should be pending\";\n        assert allTasks.get(2).equals(\"Task 3 - Pending\") : \"Task 3 should be pending\";\n    }\n}\n", "golden_completion": "/**\n * WorkflowManager is responsible for managing a list of tasks, allowing tasks to be added,\n * marked as completed, and retrieving all tasks with their statuses.\n *\n * <p>This class provides methods to add tasks, complete tasks, and get all tasks. Each task\n * is represented by a name and a completion status.</p>\n *\n * <p>Example usage:</p>\n * <pre>\n * {@code\n * WorkflowManager manager = new WorkflowManager();\n * manager.addTask(\"Task 1\");\n * manager.addTask(\"Task 2\");\n * manager.completeTask(\"Task 1\");\n * List<String> allTasks = manager.getAllTasks();\n * }\n * </pre>\n */\n", "LLM_justification": "This example tests the LLM's ability to generate comprehensive Javadoc comments for an existing class implementation. The class `WorkflowManager` provides practical business logic for managing tasks, making it a realistic scenario. The completion must include detailed class-level documentation, usage examples, and parameter descriptions, ensuring that key elements like task management and status updates are correctly documented. Assertions in the suffix verify the functional correctness of the implementation, ensuring that tasks are added, completed, and listed correctly.", "assertions": "", "gpt-4o_completion_0": "public class WorkflowManager {", "gpt-4o_completion_1": "public class WorkflowManager {", "gpt-4o_completion_2": "public class WorkflowManager {", "gpt-4o_completion_3": "package workflow;", "gpt-4o_completion_4": "public class WorkflowManager {", "gpt-4o_completions": ["public class WorkflowManager {", "public class WorkflowManager {", "public class WorkflowManager {", "package workflow;", "public class WorkflowManager {"]}
{"id": "25", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Class representing a basic configuration manager for a software application.\n * This class provides functionality to set, get, and remove configuration settings.\n */\npublic class ConfigurationManager {\n\n    private Map<String, String> configMap;\n\n    /**\n     * Constructor initializes the configuration manager with an empty configuration map.\n     */\n    public ConfigurationManager() {\n        this.configMap = new HashMap<>();\n    }\n\n    /**\n     * Sets a configuration value for a given key.\n     * @param key the configuration key\n     * @param value the configuration value\n     */\n    public void setConfig(String key, String value) {\n        configMap.put(key, value);\n    }\n\n    /**\n     * Retrieves the configuration value for a given key.\n     * @param key the configuration key\n     * @return the configuration value, or null if the key does not exist\n     */\n    public String getConfig(String key) {\n        return configMap.get(key);\n    }\n\n    /**\n     * Removes a configuration setting for a given key.\n     * @param key the configuration key\n     * @return the previous value associated with the key, or null if there was no mapping for the key\n     */\n    public String removeConfig(String key) {\n        return configMap.remove(key);\n    }\n\n    /**\n     * Clears all configuration settings.\n     */\n    public void clearConfigs() {\n        configMap.clear();\n    }\n\n    // Additional method to be documented\n    /**\n     * Checks if a configuration setting exists for a given key.\n     * @param key the configuration key\n     * @return true if the configuration exists, false otherwise\n     */\n", "suffix": "\n\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n        configManager.setConfig(\"apiUrl\", \"https://api.example.com\");\n        configManager.setConfig(\"timeout\", \"30\");\n\n        // Assertions\n        assert configManager.getConfig(\"apiUrl\").equals(\"https://api.example.com\");\n        assert configManager.getConfig(\"timeout\").equals(\"30\");\n        assert configManager.hasConfig(\"apiUrl\");\n        assert !configManager.hasConfig(\"nonexistentKey\");\n\n        // Remove a config and test\n        configManager.removeConfig(\"timeout\");\n        assert configManager.getConfig(\"timeout\") == null;\n\n        // Clear all configs and test\n        configManager.clearConfigs();\n        assert configManager.getConfig(\"apiUrl\") == null;\n        assert !configManager.hasConfig(\"apiUrl\");\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }\n", "LLM_justification": "This test case demonstrates a realistic scenario of managing configuration settings in a software application. The ConfigurationManager class provides methods to set, get, remove, and check the existence of configuration settings. The test case includes a comprehensive implementation of the ConfigurationManager class and tests various functionalities with assertions to ensure correctness. It effectively tests the LLM's ability to translate between code and documentation, as well as the ability to generate accurate and complete documentation for the provided code.", "assertions": "", "gpt-4o_completion_0": "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "gpt-4o_completion_1": "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "gpt-4o_completion_2": "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "gpt-4o_completion_3": "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "gpt-4o_completion_4": "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "gpt-4o_completions": ["    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }", "    public boolean hasConfig(String key) {\n        return configMap.containsKey(key);\n    }"]}
{"id": "26", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\n\n/**\n * A utility class for managing the business workflow of processing orders.\n */\npublic class OrderProcessor {\n\n    private static final Logger logger = Logger.getLogger(OrderProcessor.class.getName());\n    private List<String> orders;\n\n    /**\n     * Constructor initializes the order list.\n     */\n    public OrderProcessor() {\n        this.orders = new ArrayList<>();\n    }\n\n    /**\n     * Adds a new order to the list.\n     *\n     * @param order The order to be added\n     */\n    public void addOrder(String order) {\n        orders.add(order);\n        logger.info(\"Order added: \" + order);\n    }\n\n    /**\n     * Validates and processes all orders.\n     *\n     * @return a list of processed orders\n     */\n    public List<String> processOrders() {\n        List<String> processedOrders = new ArrayList<>();\n        for (String order : orders) {\n            if (validateOrder(order)) {\n                processedOrders.add(order);\n                logger.info(\"Order processed: \" + order);\n            } else {\n                logger.warning(\"Invalid order: \" + order);\n            }\n        }\n        return processedOrders;\n    }\n\n    /**\n     * Validates the given order based on predefined business rules.\n     *\n     * @param order The order to be validated\n     * @return true if the order is valid, false otherwise\n     */\n    private boolean validateOrder(String order) {\n        // Placeholder for complex validation logic\n        return order != null && !order.trim().isEmpty();\n    }\n\n    /**\n     * Clears all orders from the list.\n     */\n    public void clearOrders() {\n        orders.clear();\n        logger.info(\"All orders cleared.\");\n    }\n\n", "suffix": "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }\n}", "golden_completion": "/**\n * Main method to demonstrate the OrderProcessor functionality.\n *\n * This method creates an instance of OrderProcessor, adds orders,\n * processes them, and asserts the expected behavior.\n *\n * @param args the command line arguments\n */\n", "LLM_justification": "This test case demonstrates the ability to translate Java code implementing a business workflow into comprehensive Javadoc documentation. It includes detailed documentation for the main method of the OrderProcessor class, which showcases the functionality of adding, processing, and clearing orders. The assertions in the suffix verify the correctness of the implementation by checking the processed orders and ensuring that orders are cleared as expected. This example tests the LLM's ability to generate accurate and detailed documentation for complex business logic, as well as its understanding of the order processing flow and error handling.", "assertions": "", "gpt-4o_completion_0": "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "gpt-4o_completion_1": "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "gpt-4o_completion_2": "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "gpt-4o_completion_3": "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "gpt-4o_completion_4": "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "gpt-4o_completions": ["    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }", "    public static void main(String[] args) {\n        OrderProcessor orderProcessor = new OrderProcessor();\n        orderProcessor.addOrder(\"Order1\");\n        orderProcessor.addOrder(\"Order2\");\n        orderProcessor.addOrder(\"\");  // Invalid order\n        \n        List<String> processedOrders = orderProcessor.processOrders();\n        assert processedOrders.size() == 2 : \"Expected 2 valid orders to be processed.\";\n        assert processedOrders.contains(\"Order1\") : \"Order1 should be in the processed orders.\";\n        assert processedOrders.contains(\"Order2\") : \"Order2 should be in the processed orders.\";\n        \n        orderProcessor.clearOrders();\n        assert orderProcessor.processOrders().isEmpty() : \"Orders should be cleared.\";\n    }"]}
{"id": "27", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * This class handles the scheduling of tasks based on their priority.\n * It ensures that high-priority tasks are executed before low-priority tasks.\n */\npublic class TaskScheduler {\n\n    /**\n     * Represents a task with a name and a priority.\n     */\n    public static class Task implements Comparable<Task> {\n        private String name;\n        private int priority;\n\n        public Task(String name, int priority) {\n            this.name = name;\n            this.priority = priority;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getPriority() {\n            return priority;\n        }\n\n        @Override\n        public int compareTo(Task other) {\n            return Integer.compare(other.priority, this.priority); // Higher priority comes first\n        }\n    }\n\n    private List<Task> tasks;\n\n    public TaskScheduler() {\n        tasks = new ArrayList<>();\n    }\n\n    /**\n     * Adds a task to the scheduler.\n     *\n     * @param task The task to be added.\n     */\n    public void addTask(Task task) {\n        tasks.add(task);\n    }\n", "suffix": "    /**\n     * Executes all scheduled tasks in order of their priority.\n     *\n     * @return A list of task names in the order they were executed.\n     */\n    public List<String> executeTasks() {\n        Collections.sort(tasks);\n        List<String> executedTasks = new ArrayList<>();\n        for (Task task : tasks) {\n            executedTasks.add(task.getName());\n        }\n        return executedTasks;\n    }\n\n    public static void main(String[] args) {\n        TaskScheduler scheduler = new TaskScheduler();\n        scheduler.addTask(new Task(\"LowPriorityTask\", 1));\n        scheduler.addTask(new Task(\"HighPriorityTask\", 10));\n        scheduler.addTask(new Task(\"MediumPriorityTask\", 5));\n\n        List<String> executedTasks = scheduler.executeTasks();\n        assert executedTasks.get(0).equals(\"HighPriorityTask\");\n        assert executedTasks.get(1).equals(\"MediumPriorityTask\");\n        assert executedTasks.get(2).equals(\"LowPriorityTask\");\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "    /**\n     * Removes a task from the scheduler.\n     *\n     * @param task The task to be removed.\n     */\n    public void removeTask(Task task) {\n        tasks.remove(task);\n    }\n", "LLM_justification": "This test case effectively demonstrates the bidirectional translation between code and documentation. The prefix sets up a realistic scenario involving task scheduling based on priority, which is common in workflow orchestration. The golden completion requires generating a method with comprehensive Javadoc comments, testing the model's ability to produce accurate and detailed documentation. The suffix includes assertions to verify the correctness of the task execution order, ensuring that the high-priority task is executed first, followed by medium and low priority tasks. This setup tests both the code-to-comment and comment-to-code translation capabilities of the model.", "assertions": "", "gpt-4o_completion_0": "    /**\n     * Removes all tasks from the scheduler.\n     */\n    public void clearTasks() {\n        tasks.clear();\n    }", "gpt-4o_completion_1": "    /**\n     * Removes a task from the scheduler.\n     *\n     * @param task The task to be removed.\n     * @return True if the task was removed, false otherwise.\n     */\n    public boolean removeTask(Task task) {\n        return tasks.remove(task);\n    }", "gpt-4o_completion_2": "    /**\n     * Removes all tasks from the scheduler.\n     */\n    public void clearTasks() {\n        tasks.clear();\n    }", "gpt-4o_completion_3": "    /**\n     * Removes all tasks from the scheduler.\n     */\n    public void clearTasks() {\n        tasks.clear();\n    }", "gpt-4o_completion_4": "    /**\n     * Removes all tasks from the scheduler.\n     */\n    public void clearTasks() {\n        tasks.clear();\n    }", "gpt-4o_completions": ["    /**\n     * Removes all tasks from the scheduler.\n     */\n    public void clearTasks() {\n        tasks.clear();\n    }", "    /**\n     * Removes a task from the scheduler.\n     *\n     * @param task The task to be removed.\n     * @return True if the task was removed, false otherwise.\n     */\n    public boolean removeTask(Task task) {\n        return tasks.remove(task);\n    }", "    /**\n     * Removes all tasks from the scheduler.\n     */\n    public void clearTasks() {\n        tasks.clear();\n    }", "    /**\n     * Removes all tasks from the scheduler.\n     */\n    public void clearTasks() {\n        tasks.clear();\n    }", "    /**\n     * Removes all tasks from the scheduler.\n     */\n    public void clearTasks() {\n        tasks.clear();\n    }"]}
{"id": "28", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A class to manage a simple feature flag system. Feature flags are used to enable or disable\n * specific features in an application without deploying new code. This class provides methods\n * to add, remove, and check the status of feature flags.\n */\npublic class FeatureFlagManager {\n\n    private final Map<String, Boolean> featureFlags;\n\n    /**\n     * Constructor to initialize the feature flag manager with an empty map.\n     */\n    public FeatureFlagManager() {\n        this.featureFlags = new HashMap<>();\n    }\n\n    /**\n     * Adds a new feature flag to the manager.\n     * \n     * @param featureName The name of the feature.\n     * @param isEnabled The initial state of the feature flag.\n     */\n    public void addFeatureFlag(String featureName, boolean isEnabled) {\n        featureFlags.put(featureName, isEnabled);\n    }\n\n    /**\n     * Removes a feature flag from the manager.\n     * \n     * @param featureName The name of the feature to remove.\n     */\n    public void removeFeatureFlag(String featureName) {\n        featureFlags.remove(featureName);\n    }\n\n    /**\n     * Checks if a feature is enabled.\n     * \n     * @param featureName The name of the feature to check.\n     * @return true if the feature is enabled, false otherwise.\n     */\n    public boolean isFeatureEnabled(String featureName) {\n        return featureFlags.getOrDefault(featureName, false);\n    }\n\n    /**\n     * Toggles the state of a feature flag.\n     * If the feature is enabled, it will be disabled. If it is disabled, it will be enabled.\n     * \n     * @param featureName The name of the feature to toggle.\n     */\n", "suffix": "\n\n    public static void main(String[] args) {\n        FeatureFlagManager manager = new FeatureFlagManager();\n        manager.addFeatureFlag(\"darkMode\", true);\n        manager.addFeatureFlag(\"betaFeature\", false);\n\n        // Assertions\n        assert manager.isFeatureEnabled(\"darkMode\");\n        assert !manager.isFeatureEnabled(\"betaFeature\");\n\n        manager.toggleFeatureFlag(\"darkMode\");\n        manager.toggleFeatureFlag(\"betaFeature\");\n\n        assert !manager.isFeatureEnabled(\"darkMode\");\n        assert manager.isFeatureEnabled(\"betaFeature\");\n\n        manager.removeFeatureFlag(\"betaFeature\");\n        assert !manager.isFeatureEnabled(\"betaFeature\");\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "\n    public void toggleFeatureFlag(String featureName) {\n        if (featureFlags.containsKey(featureName)) {\n            featureFlags.put(featureName, !featureFlags.get(featureName));\n        }\n    }\n", "LLM_justification": "This example tests the bidirectional translation capabilities of an LLM by requiring it to generate comprehensive documentation for a method implementation (code-to-comment) and to implement a method based on detailed documentation (comment-to-code). The example involves realistic business logic with feature flag management, a common scenario in software development. It includes various actions such as adding, removing, checking, and toggling feature flags, which provide a good context for testing functional requirements and error handling. The assertions ensure the correctness of the implementation and documentation.", "assertions": "", "gpt-4o_completion_0": "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "gpt-4o_completion_1": "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "gpt-4o_completion_2": "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "gpt-4o_completion_3": "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "gpt-4o_completion_4": "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "gpt-4o_completions": ["    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }", "    public void toggleFeatureFlag(String featureName) {\n        featureFlags.put(featureName, !featureFlags.getOrDefault(featureName, false));\n    }"]}
{"id": "29", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A class that manages a list of tasks and performs various operations on them.\n */\npublic class TaskManager {\n    private List<String> tasks;\n\n    /**\n     * Initializes the TaskManager with an empty task list.\n     */\n    public TaskManager() {\n        this.tasks = new ArrayList<>();\n    }\n\n    /**\n     * Adds a new task to the task list.\n     *\n     * @param task The task to be added.\n     */\n    public void addTask(String task) {\n        tasks.add(task);\n    }\n\n    /**\n     * Retrieves the task at the specified index.\n     *\n     * @param index The index of the task to retrieve.\n     * @return The task at the specified index.\n     * @throws IndexOutOfBoundsException if the index is out of range.\n     */\n    public String getTask(int index) {\n        if (index < 0 || index >= tasks.size()) {\n            throw new IndexOutOfBoundsException(\"Invalid task index\");\n        }\n        return tasks.get(index);\n    }\n\n    /**\n     * Removes the task at the specified index.\n     *\n     * @param index The index of the task to remove.\n     * @throws IndexOutOfBoundsException if the index is out of range.\n     */\n    public void removeTask(int index) {\n        if (index < 0 || index >= tasks.size()) {\n            throw new IndexOutOfBoundsException(\"Invalid task index\");\n        }\n        tasks.remove(index);\n    }\n", "suffix": "\n\n    public static void main(String[] args) {\n        TaskManager manager = new TaskManager();\n        manager.addTask(\"Task 1\");\n        manager.addTask(\"Task 2\");\n\n        // Assertions to verify the correctness of the TaskManager methods\n        assert manager.getTaskCount() == 2 : \"Task count should be 2\";\n        assert \"Task 1\".equals(manager.getTask(0)) : \"First task should be 'Task 1'\";\n        assert \"Task 2\".equals(manager.getTask(1)) : \"Second task should be 'Task 2'\";\n\n        manager.removeTask(0);\n        assert manager.getTaskCount() == 1 : \"Task count should be 1 after removal\";\n        assert \"Task 2\".equals(manager.getTask(0)) : \"First task should now be 'Task 2'\";\n\n        // Ensure IndexOutOfBoundsException is thrown for invalid index\n        try {\n            manager.getTask(5);\n            assert false : \"Exception should have been thrown for invalid index\";\n        } catch (IndexOutOfBoundsException e) {\n            assert \"Invalid task index\".equals(e.getMessage()) : \"Exception message should be 'Invalid task index'\";\n        }\n    }\n}\n", "golden_completion": "\n    /**\n     * Retrieves the total number of tasks.\n     *\n     * @return The number of tasks.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }\n", "LLM_justification": "This test case is designed to verify the LLM's ability to translate between Java code and documentation. It includes a realistic business logic scenario where a TaskManager class manages a list of tasks. The documentation comments follow Javadoc conventions, providing detailed descriptions of methods, parameters, and return values. The assertions in the suffix ensure the correctness of the implementation, testing various functional requirements, including edge cases and exception handling. This scenario effectively tests code-to-comment translation by documenting existing code and comment-to-code translation by implementing described functionality.", "assertions": "", "gpt-4o_completion_0": "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks in the list.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "gpt-4o_completion_1": "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "gpt-4o_completion_2": "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks in the list.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "gpt-4o_completion_3": "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks in the list.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "gpt-4o_completion_4": "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "gpt-4o_completions": ["    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks in the list.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks in the list.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks in the list.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }", "    /**\n     * Retrieves the total number of tasks in the task list.\n     *\n     * @return The number of tasks.\n     */\n    public int getTaskCount() {\n        return tasks.size();\n    }"]}
{"id": "30", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Utility class for business rule validation.\n * This class provides methods to validate user input against business rules.\n */\npublic class BusinessRuleValidator {\n\n    /**\n     * Validates an email address against a predefined pattern.\n     *\n     * @param email The email address to validate.\n     * @return true if the email is valid, false otherwise.\n     */\n    public boolean validateEmail(String email) {\n        String emailRegex = \"^[A-Za-z0-9+_.-]+@(.+)$\";\n        Pattern pattern = Pattern.compile(emailRegex);\n        Matcher matcher = pattern.matcher(email);\n        return matcher.matches();\n    }\n\n    /**\n     * Validates a list of user inputs against multiple business rules.\n     *\n     * @param inputs The list of user inputs to validate.\n     * @return A list of error messages for each invalid input.\n     */\n    public List<String> validateInputs(List<String> inputs) {\n        List<String> errors = new ArrayList<>();\n        for (String input : inputs) {\n            if (input == null || input.isEmpty()) {\n                errors.add(\"Input cannot be null or empty\");\n            } else if (!validateEmail(input)) {\n                errors.add(\"Invalid email format: \" + input);\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * Validates a user's age against business rules.\n     *\n     * @param age The age of the user to validate.\n     * @return true if the age is valid, false otherwise.\n     */\n    public boolean validateAge(int age) {\n        return age >= 18 && age <= 65;\n    }\n    /**\n     * Validates a user's phone number against business rules.\n     *\n     * @param phoneNumber The phone number to validate.\n     * @return true if the phone number is valid, false otherwise.\n     */\n", "suffix": "    public static void main(String[] args) {\n        BusinessRuleValidator validator = new BusinessRuleValidator();\n        List<String> inputs = new ArrayList<>();\n        inputs.add(\"test@example.com\");\n        inputs.add(\"\");\n        inputs.add(\"invalid-email\");\n        List<String> errors = validator.validateInputs(inputs);\n        assert errors.size() == 2 : \"There should be two errors\";\n        assert errors.contains(\"Input cannot be null or empty\") : \"Error message for empty input missing\";\n        assert errors.contains(\"Invalid email format: invalid-email\") : \"Error message for invalid email missing\";\n        assert validator.validateAge(20) : \"Age 20 should be valid\";\n        assert !validator.validateAge(17) : \"Age 17 should be invalid\";\n        assert !validator.validateAge(66) : \"Age 66 should be invalid\";\n    }\n}\n", "golden_completion": "\n    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9. ()-]{7,25}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }\n", "LLM_justification": "This example tests the LLM's ability to generate comprehensive documentation for a new method within an existing class. It includes detailed Javadoc-style comments and tests the ability to follow documentation conventions. The assertions verify the correctness of documentation and code functionality, ensuring that the LLM accurately translates between code and natural language.", "assertions": "", "gpt-4o_completion_0": "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "gpt-4o_completion_1": "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "gpt-4o_completion_2": "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^[+]?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "gpt-4o_completion_3": "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "gpt-4o_completion_4": "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "gpt-4o_completions": ["    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^[+]?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }", "    public boolean validatePhoneNumber(String phoneNumber) {\n        String phoneRegex = \"^\\\\+?[0-9]{10,15}$\";\n        Pattern pattern = Pattern.compile(phoneRegex);\n        Matcher matcher = pattern.matcher(phoneNumber);\n        return matcher.matches();\n    }"]}
{"id": "31", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.*;\nimport java.util.concurrent.*;\nimport org.junit.Assert.*;\n\n/**\n * This class represents a simplified task scheduling system\n * for managing business workflows. It allows adding tasks,\n * scheduling them for execution, and tracking their completion.\n */\npublic class TaskScheduler {\n\n    private final ScheduledExecutorService scheduler;\n    private final Map<String, ScheduledFuture<?>> scheduledTasks;\n\n    public TaskScheduler() {\n        this.scheduler = Executors.newScheduledThreadPool(5);\n        this.scheduledTasks = new ConcurrentHashMap<>();\n    }\n\n    /**\n     * Schedules a task for future execution.\n     * @param taskId Unique identifier for the task\n     * @param task The task to be executed\n     * @param delay The delay in seconds before the task is executed\n     */\n    public void scheduleTask(String taskId, Runnable task, long delay) {\n        ScheduledFuture<?> scheduledFuture = scheduler.schedule(task, delay, TimeUnit.SECONDS);\n        scheduledTasks.put(taskId, scheduledFuture);\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param taskId Unique identifier for the task\n     * @return True if the task was successfully canceled, false otherwise\n     */\n    public boolean cancelTask(String taskId) {\n        ScheduledFuture<?> scheduledFuture = scheduledTasks.remove(taskId);\n        if (scheduledFuture != null) {\n            return scheduledFuture.cancel(false);\n        }\n        return false;\n    }\n\n    /**\n     * Checks if a task is completed.\n     * @param taskId Unique identifier for the task\n     * @return True if the task is completed, false otherwise\n     */\n    public boolean isTaskCompleted(String taskId) {\n        ScheduledFuture<?> scheduledFuture = scheduledTasks.get(taskId);\n        if (scheduledFuture != null) {\n            return scheduledFuture.isDone();\n        }\n        return false;\n    }\n\n    /**\n     * Shuts down the scheduler and releases resources.\n     * This method should be called when the scheduler is no longer needed.\n     */\n", "suffix": "\n\n    public static void main(String[] args) throws InterruptedException {\n        TaskScheduler taskScheduler = new TaskScheduler();\n        Runnable testTask = () -> System.out.println(\"Task executed\");\n        taskScheduler.scheduleTask(\"task1\", testTask, 1);\n\n        // Wait for the task to complete\n        Thread.sleep(2000);\n\n        // Assertions to verify the functionality\n        assert(taskScheduler.isTaskCompleted(\"task1\"));\n        assert(taskScheduler.cancelTask(\"task1\") == false);\n\n        // Shutdown the scheduler\n        taskScheduler.shutdown();\n    }\n}\n", "golden_completion": "\n    public void shutdown() {\n        scheduler.shutdown();\n    }\n", "LLM_justification": "This test case is a good example of both code-to-comment and comment-to-code translation. The prefix includes a comprehensive implementation of a task scheduling system, demonstrating realistic business logic and resource management. The golden completion contains the documentation for a method that shuts down the scheduler, ensuring resource cleanup. The suffix includes assertions that test the functionality of the task scheduling system, verifying task completion and cancellation behavior. This scenario effectively tests an LLM's ability to generate accurate documentation and implement methods based on detailed comments.", "assertions": "", "gpt-4o_completion_0": "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "gpt-4o_completion_1": "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "gpt-4o_completion_2": "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "gpt-4o_completion_3": "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "gpt-4o_completion_4": "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "gpt-4o_completions": ["    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }", "    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }"]}
{"id": "32", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * This class represents a simple task scheduler that can add tasks, \n * remove tasks, and execute all scheduled tasks. The tasks are represented\n * as Runnable objects.\n */\npublic class TaskScheduler {\n    private List<Runnable> tasks;\n\n    /**\n     * Constructs a new TaskScheduler with an empty task list.\n     */\n    public TaskScheduler() {\n        tasks = new ArrayList<>();\n    }\n\n    /**\n     * Adds a new task to the scheduler.\n     *\n     * @param task The Runnable task to be added.\n     */\n    public void addTask(Runnable task) {\n        tasks.add(task);\n    }\n\n    /**\n     * Removes a task from the scheduler.\n     *\n     * @param task The Runnable task to be removed.\n     * @return true if the task was successfully removed, false otherwise.\n     */\n    public boolean removeTask(Runnable task) {\n        return tasks.remove(task);\n    }\n\n    /**\n     * Executes all scheduled tasks. This method iterates over the list of tasks\n     * and runs each one in sequence.\n     */\n    public void executeAllTasks() {\n        for (Runnable task : tasks) {\n            task.run();\n        }\n    }\n\n    public static void main(String[] args) {\n        TaskScheduler scheduler = new TaskScheduler();\n\n        // Add a sample task that prints a message\n        scheduler.addTask(() -> System.out.println(\"Task 1 executed\"));\n        scheduler.addTask(() -> System.out.println(\"Task 2 executed\"));\n\n        // Remove a task and ensure it is not executed\n        Runnable taskToRemove = () -> System.out.println(\"Task to be removed\");\n        scheduler.addTask(taskToRemove);\n        scheduler.removeTask(taskToRemove);\n        // Add another task and execute again\n", "suffix": "        // Execute all tasks and validate the output\n        scheduler.executeAllTasks();\n\n        // Assertions to validate the functionality\n        // (In a real-world scenario, we might use a logging framework or a mock library to capture output)\n        assert scheduler.removeTask(taskToRemove) == false : \"Task should not be present in the list\";\n\n        // Clean up resources (if any)\n        // No resources to clean in this simple example\n    }\n}", "golden_completion": "\n        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));\n", "LLM_justification": "This test case demonstrates the implementation of a simple task scheduler, which is a common scenario in workflow orchestration and task management systems. The code-to-comment translation is tested by providing detailed Javadoc comments for the TaskScheduler class and its methods. The comment-to-code translation is tested by requiring the implementation of adding another task and executing it. The assertions in the suffix validate that the task removal and task execution functionalities are working as expected.", "assertions": "", "gpt-4o_completion_0": "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "gpt-4o_completion_1": "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "gpt-4o_completion_2": "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "gpt-4o_completion_3": "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "gpt-4o_completion_4": "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "gpt-4o_completions": ["        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));", "        scheduler.addTask(() -> System.out.println(\"Task 3 executed\"));"]}
{"id": "33", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Represents a simple task scheduler that can add tasks, run them in order, and handle errors.\n */\npublic class TaskScheduler {\n    private List<Runnable> tasks;\n\n    public TaskScheduler() {\n        this.tasks = new ArrayList<>();\n    }\n\n    /**\n     * Adds a task to the scheduler.\n     * @param task The task to be added.\n     */\n    public void addTask(Runnable task) {\n        tasks.add(task);\n    }\n\n    /**\n     * Runs all tasks in the order they were added.\n     * If a task throws an exception, it is caught and logged, and the scheduler continues with the next task.\n     */\n    public void runTasks() {\n        for (Runnable task : tasks) {\n            try {\n                task.run();\n            } catch (Exception e) {\n                System.err.println(\"Task failed: \" + e.getMessage());\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        TaskScheduler scheduler = new TaskScheduler();\n        scheduler.addTask(() -> System.out.println(\"Task 1\"));\n        scheduler.addTask(() -> { throw new RuntimeException(\"Error in Task 2\"); });\n        scheduler.addTask(() -> System.out.println(\"Task 3\"));\n", "suffix": "        scheduler.runTasks();\n\n        // Assertions\n        assert scheduler.tasks.size() == 3 : \"Task count should be 3\";\n        assert scheduler.tasks.get(0) != null : \"First task should not be null\";\n        assert scheduler.tasks.get(1) != null : \"Second task should not be null\";\n        assert scheduler.tasks.get(2) != null : \"Third task should not be null\";\n    }\n}\n", "golden_completion": "        // Verify task execution order and error handling\n        // Expected output:\n        // Task 1\n        // Task failed: Error in Task 2\n        // Task 3\n", "LLM_justification": "This scenario tests both code-to-comment and comment-to-code translation by providing a realistic example of a task scheduler. The prefix includes the setup of the scheduler, the addition of tasks, and the implementation of the runTasks method with error handling. The golden completion provides comprehensive documentation for the expected behavior and error handling. The suffix includes assertions to verify the correct execution order and error handling, ensuring all tasks are executed and errors are logged appropriately.", "assertions": "", "gpt-4o_completion_0": "        scheduler.runTasks();", "gpt-4o_completion_1": "        scheduler.runTasks();", "gpt-4o_completion_2": "        scheduler.runTasks();", "gpt-4o_completion_3": "        scheduler.runTasks();", "gpt-4o_completion_4": "        scheduler.runTasks();", "gpt-4o_completions": ["        scheduler.runTasks();", "        scheduler.runTasks();", "        scheduler.runTasks();", "        scheduler.runTasks();", "        scheduler.runTasks();"]}
{"id": "34", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n", "suffix": "\npublic class AuthManager {\n    private Map<String, String> userDatabase;\n    private Map<String, String> sessionDatabase;\n\n    public AuthManager() {\n        userDatabase = new HashMap<>();\n        sessionDatabase = new HashMap<>();\n        // Pre-populate with some test users\n        userDatabase.put(\"user1\", \"password1\");\n        userDatabase.put(\"user2\", \"password2\");\n    }\n\n    /**\n     * Authenticates a user based on username and password.\n     * @param username the username of the user\n     * @param password the password of the user\n     * @return a session token if authentication is successful, null otherwise\n     */\n    public String authenticate(String username, String password) {\n        if (userDatabase.containsKey(username) && userDatabase.get(username).equals(password)) {\n            String sessionToken = generateSessionToken();\n            sessionDatabase.put(sessionToken, username);\n            return sessionToken;\n        }\n        return null;\n    }\n\n    /**\n     * Generates a new session token.\n     * @return a new session token\n     */\n    private String generateSessionToken() {\n        return \"token\" + System.currentTimeMillis();\n    }\n\n    /**\n     * Validates if a session token is still active.\n     * @param sessionToken the session token to validate\n     * @return true if the session is valid, false otherwise\n     */\n    public boolean validateSession(String sessionToken) {\n        return sessionDatabase.containsKey(sessionToken);\n    }\n\n    /**\n     * Removes a session token (for testing purposes).\n     * @param sessionToken the session token to remove\n     */\n    public void removeSession(String sessionToken) {\n        sessionDatabase.remove(sessionToken);\n    }\n\n    public static void main(String[] args) {\n        AuthManager authManager = new AuthManager();\n        // Test successful authentication\n        String sessionToken = authManager.authenticate(\"user1\", \"password1\");\n        assert sessionToken != null : \"Authentication failed for valid user.\";\n\n        // Test session validation\n        assert authManager.validateSession(sessionToken) : \"Session validation failed for valid session.\";\n\n        // Test invalid authentication\n        String invalidToken = authManager.authenticate(\"user1\", \"wrongpassword\");\n        assert invalidToken == null : \"Authentication should fail for invalid password.\";\n\n        // Test invalid session validation\n        assert !authManager.validateSession(\"invalidToken\") : \"Invalid session token should not be validated.\";\n\n        // Test session expiration (simulated by removing the session manually)\n        authManager.removeSession(sessionToken);\n        assert !authManager.validateSession(sessionToken) : \"Expired session should not be validated.\";\n    }\n}", "golden_completion": "/**\n * AuthManager is responsible for user authentication and session management.\n *\n * This class provides methods to authenticate users, generate session tokens,\n * and validate active sessions. It maintains an internal database of users and\n * session tokens.\n *\n * Methods:\n * - authenticate: Authenticates a user and returns a session token.\n * - generateSessionToken: Generates a new session token.\n * - validateSession: Validates if a session token is active.\n *\n * Usage example:\n * AuthManager authManager = new AuthManager();\n * String sessionToken = authManager.authenticate(\"user1\", \"password1\");\n * if (sessionToken != null) {\n *     // User authenticated successfully\n *     boolean isValid = authManager.validateSession(sessionToken);\n *     if (isValid) {\n *         // Session is valid\n *     }\n * }\n *\n * @param username the username to authenticate\n * @param password the password to authenticate\n * @return session token if authentication is successful, null otherwise\n */", "LLM_justification": "This scenario demonstrates a realistic example of user authentication and session management, which is a common task in many web applications. The test case covers both code-to-comment and comment-to-code translation. The provided comments include detailed Javadoc-style documentation, usage examples, and parameter/return value descriptions. The assertions in the suffix test various aspects of the implementation, including successful authentication, session validation, and handling of invalid credentials and sessions. This ensures that the LLM can accurately generate and interpret both code and documentation, maintaining consistency and correctness.", "assertions": "", "gpt-4o_completion_0": "package authmanager;", "gpt-4o_completion_1": "package auth;\n", "gpt-4o_completion_2": "package auth;\n", "gpt-4o_completion_3": "package auth;\n", "gpt-4o_completion_4": "package auth;\n", "gpt-4o_completions": ["package authmanager;", "package auth;\n", "package auth;\n", "package auth;\n", "package auth;\n"]}
{"id": "35", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * ConfigurationManager is responsible for managing dynamic settings\n * and feature flags in the application.\n */\npublic class ConfigurationManager {\n    private Map<String, String> settings;\n\n    /**\n     * Initializes the configuration manager with default settings.\n     */\n    public ConfigurationManager() {\n        settings = new HashMap<>();\n        loadDefaultSettings();\n    }\n\n    /**\n     * Loads default settings into the configuration manager.\n     */\n    private void loadDefaultSettings() {\n        settings.put(\"featureX.enabled\", \"false\");\n        settings.put(\"maxConnections\", \"10\");\n    }\n\n    /**\n     * Gets the value of a setting.\n     *\n     * @param key the key of the setting\n     * @return the value of the setting\n     */\n    public String getSetting(String key) {\n        return settings.get(key);\n    }\n\n    /**\n     * Updates the value of a setting.\n     *\n     * @param key the key of the setting\n     * @param value the new value of the setting\n     * @throws IllegalArgumentException if the key or value is null\n     */\n    public void updateSetting(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        settings.put(key, value);\n    }\n\n    /**\n     * Checks if a feature is enabled.\n     *\n     * @param featureKey the key of the feature\n     * @return true if the feature is enabled, false otherwise\n     */\n    public boolean isFeatureEnabled(String featureKey) {\n        String value = settings.get(featureKey);\n        return Boolean.parseBoolean(value);\n    }\n    /**\n     * Disables a specific feature.\n     *\n     * @param featureKey the key of the feature to disable\n     */\n", "suffix": "\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n\n        // Test getSetting method\n        assert \"false\".equals(configManager.getSetting(\"featureX.enabled\"));\n        assert \"10\".equals(configManager.getSetting(\"maxConnections\"));\n\n        // Test updateSetting method\n        configManager.updateSetting(\"maxConnections\", \"20\");\n        assert \"20\".equals(configManager.getSetting(\"maxConnections\"));\n\n        // Test isFeatureEnabled method\n        assert !configManager.isFeatureEnabled(\"featureX.enabled\");\n        configManager.updateSetting(\"featureX.enabled\", \"true\");\n        assert configManager.isFeatureEnabled(\"featureX.enabled\");\n\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "\n    public void disableFeature(String featureKey) {\n        updateSetting(featureKey, \"false\");\n    }\n", "LLM_justification": "This test case provides a realistic scenario of managing dynamic settings and feature flags within an application, a common task in configuration management. The prefix includes detailed class and method definitions with Javadoc comments. The golden_completion requires the LLM to generate a method for disabling a feature, demonstrating the ability to translate natural language requirements into code. The suffix contains assertions that ensure all methods, including the newly added method, work as expected.", "assertions": "", "gpt-4o_completion_0": "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "gpt-4o_completion_1": "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "gpt-4o_completion_2": "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "gpt-4o_completion_3": "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "gpt-4o_completion_4": "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "gpt-4o_completions": ["    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }", "    public void disableFeature(String featureKey) {\n        Objects.requireNonNull(featureKey, \"Feature key cannot be null\");\n        settings.put(featureKey, \"false\");\n    }"]}
{"id": "36", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.io.*;\nimport java.util.*;\n\n/**\n * This class handles the management of configuration settings\n * for a hypothetical application. It supports dynamic loading\n * and refreshing of settings from an external properties file,\n * and provides caching to minimize file I/O operations.\n */\npublic class ConfigManager {\n\n    private static final String CONFIG_FILE = \"app.properties\";\n    private Properties properties;\n    private long lastLoadedTime;\n    private static final long CACHE_REFRESH_INTERVAL = 60000; // 1 minute\n\n    /**\n     * Loads the configuration properties from the file.\n     * If the file has been modified since the last load,\n     * the properties are reloaded.\n     */\n    public void loadProperties() {\n        File configFile = new File(CONFIG_FILE);\n        if (configFile.exists() && configFile.lastModified() > lastLoadedTime) {\n            properties = new Properties();\n            try (FileInputStream fis = new FileInputStream(configFile)) {\n                properties.load(fis);\n                lastLoadedTime = System.currentTimeMillis();\n            } catch (IOException e) {\n                e.printStackTrace();\n                // Handle error: log and use defaults\n                properties = new Properties();\n                lastLoadedTime = System.currentTimeMillis();\n            }\n        } else {\n            // File doesn't exist or hasn't been modified, initialize with empty properties\n            if (properties == null) {\n                properties = new Properties();\n                lastLoadedTime = System.currentTimeMillis();\n            }\n        }\n    }\n\n    /**\n     * Gets a property value by key.\n     * If the cache is outdated, it reloads the properties first.\n     * @param key the property key\n     * @return the property value\n     */\n    public String getProperty(String key) {\n        if (System.currentTimeMillis() - lastLoadedTime > CACHE_REFRESH_INTERVAL) {\n            loadProperties();\n        }\n        return properties.getProperty(key);\n    }\n\n    /**\n     * Refreshes the configuration properties by forcing a reload.\n     */\n    public void refreshProperties() {\n        loadProperties();\n    }\n\n    /**\n     * Gets the last loaded time (for testing purposes).\n     * @return the last loaded time\n     */\n    public long getLastLoadedTime() {\n        return lastLoadedTime;\n    }\n\n    /**\n     * Gets the properties object (for testing purposes).\n     * @return the properties object\n     */\n    public Properties getProperties() {\n        return properties;\n    }\n\n    public static void main(String[] args) {\n        ConfigManager configManager = new ConfigManager();\n        configManager.loadProperties();\n        // Validate initial load\n", "suffix": "\n        // Validate that properties are loaded correctly (empty properties if file doesn't exist)\n        String someProperty = configManager.getProperty(\"someKey\");\n        // Property will be null since file doesn't exist, this is expected behavior\n        assert someProperty == null : \"Property should be null when file doesn't exist\";\n\n        // Test cache refresh logic\n        long initialLoadTime = configManager.getLastLoadedTime();\n        configManager.getProperty(\"someKey\"); // This should not reload properties if within interval\n        assert configManager.getLastLoadedTime() == initialLoadTime : \"Properties should not be reloaded within the interval\";\n\n        // Clean up (if any) goes here\n    }\n}\n", "golden_completion": "\n        assert configManager.getProperties() != null : \"Properties should be loaded initially\";\n        assert configManager.getLastLoadedTime() > 0 : \"Last loaded time should be set\";\n", "LLM_justification": "This test case is a good example because it covers dynamic configuration management with caching and refresh logic. It tests the code-to-comment translation by requiring detailed documentation for the configuration management methods. It also tests comment-to-code translation by providing a clear specification for the configuration management functionality that needs to be implemented. The assertions validate both functional requirements and error handling scenarios.", "assertions": "", "gpt-4o_completion_0": "        assert configManager.getProperties() != null : \"Properties object should not be null after loading\";", "gpt-4o_completion_1": "        assert configManager.getProperties() != null : \"Properties object should not be null after loading\";", "gpt-4o_completion_2": "        assert configManager.getProperties() != null : \"Properties object should not be null after loading\";", "gpt-4o_completion_3": "        assert configManager.getProperties() != null : \"Properties object should not be null after loading\";", "gpt-4o_completion_4": "        assert configManager.getProperties().isEmpty() : \"Properties should be empty when file doesn't exist\";", "gpt-4o_completions": ["        assert configManager.getProperties() != null : \"Properties object should not be null after loading\";", "        assert configManager.getProperties() != null : \"Properties object should not be null after loading\";", "        assert configManager.getProperties() != null : \"Properties object should not be null after loading\";", "        assert configManager.getProperties() != null : \"Properties object should not be null after loading\";", "        assert configManager.getProperties().isEmpty() : \"Properties should be empty when file doesn't exist\";"]}
{"id": "37", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * This class represents a simple configuration manager.\n * It allows setting and retrieving configuration values.\n */\npublic class ConfigurationManager {\n    private final Map<String, String> configValues;\n\n    public ConfigurationManager() {\n        this.configValues = new HashMap<>();\n    }\n\n    /**\n     * Adds a new configuration value.\n     *\n     * @param key the configuration key\n     * @param value the configuration value\n     */\n    public void addConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        configValues.put(key, value);\n    }\n\n    /**\n     * Retrieves a configuration value.\n     *\n     * @param key the configuration key\n     * @return the configuration value, or null if not found\n     */\n    public String getConfigValue(String key) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        return configValues.get(key);\n    }\n\n    /**\n     * Removes a configuration value.\n     *\n     * @param key the configuration key\n     * @return the removed configuration value, or null if not found\n     */\n    public String removeConfigValue(String key) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        return configValues.remove(key);\n    }\n\n    /**\n     * Updates an existing configuration value.\n     *\n     * @param key the configuration key\n     * @param value the new configuration value\n     */\n", "suffix": "\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n\n        // Adding configuration values\n        configManager.addConfigValue(\"apiUrl\", \"https://api.example.com\");\n        configManager.addConfigValue(\"timeout\", \"30\");\n\n        // Asserting added configuration values\n        assert Objects.equals(configManager.getConfigValue(\"apiUrl\"), \"https://api.example.com\");\n        assert Objects.equals(configManager.getConfigValue(\"timeout\"), \"30\");\n\n        // Removing configuration values\n        assert Objects.equals(configManager.removeConfigValue(\"apiUrl\"), \"https://api.example.com\");\n        assert configManager.getConfigValue(\"apiUrl\") == null;\n\n        // Asserting removal of configuration values\n        assert Objects.equals(configManager.removeConfigValue(\"timeout\"), \"30\");\n        assert configManager.getConfigValue(\"timeout\") == null;\n    }\n}\n", "golden_completion": "\n    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist\");\n        }\n    }\n", "LLM_justification": "This test case provides a practical scenario for a configuration management system, which is a common feature in many applications. The prefix sets up the context with a class that handles configuration values, including adding, retrieving, and removing configurations. The golden completion focuses on adding an 'update' functionality with appropriate error handling. The suffix includes assertions that verify the correct functionality of the methods, ensuring that the code accurately translates between implementation and documentation. This scenario tests the LLM's ability to generate accurate and complete documentation for existing methods and to implement new methods based on detailed documentation.", "assertions": "", "gpt-4o_completion_0": "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "gpt-4o_completion_1": "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "gpt-4o_completion_2": "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "gpt-4o_completion_3": "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "gpt-4o_completion_4": "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "gpt-4o_completions": ["    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }", "    public void updateConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        if (configValues.containsKey(key)) {\n            configValues.put(key, value);\n        } else {\n            throw new IllegalArgumentException(\"Configuration key does not exist: \" + key);\n        }\n    }"]}
{"id": "38", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A class representing a business workflow orchestration system that manages task scheduling.\n */\npublic class WorkflowManager {\n\n    /**\n     * Represents a single task in the workflow.\n     */\n    public static class Task {\n        private String name;\n        private int duration;\n\n        public Task(String name, int duration) {\n            this.name = name;\n            this.duration = duration;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public int getDuration() {\n            return duration;\n        }\n    }\n\n    private List<Task> tasks;\n\n    public WorkflowManager() {\n        tasks = new ArrayList<>();\n    }\n\n    /**\n     * Adds a task to the workflow.\n     *\n     * @param task The task to add.\n     */\n    public void addTask(Task task) {\n        tasks.add(task);\n    }\n\n    /**\n     * Calculates the total duration of all tasks in the workflow.\n     *\n     * @return The total duration of all tasks.\n     */\n    public int calculateTotalDuration() {\n        int totalDuration = 0;\n        for (Task task : tasks) {\n            totalDuration += task.getDuration();\n        }\n        return totalDuration;\n    }\n\n    public static void main(String[] args) {\n        WorkflowManager manager = new WorkflowManager();\n        manager.addTask(new WorkflowManager.Task(\"Task 1\", 30));\n        manager.addTask(new WorkflowManager.Task(\"Task 2\", 45));\n        manager.addTask(new WorkflowManager.Task(\"Task 3\", 25));\n        // Ensure total duration is calculated correctly\n", "suffix": "\n\n        // Edge case: No tasks\n        WorkflowManager emptyManager = new WorkflowManager();\n        int emptyDuration = emptyManager.calculateTotalDuration();\n        assert emptyDuration == 0 : \"Empty manager should have 0 duration\";\n\n        // Edge case: Single task\n        WorkflowManager singleTaskManager = new WorkflowManager();\n        singleTaskManager.addTask(new WorkflowManager.Task(\"Single Task\", 50));\n        int singleTaskDuration = singleTaskManager.calculateTotalDuration();\n        assert singleTaskDuration == 50 : \"Single task manager should have 50 duration\";\n    }\n}\n", "golden_completion": "\n        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";\n\n", "LLM_justification": "This test case demonstrates a comprehensive example of a workflow management system with task scheduling and total duration calculation. It includes both code-to-comment and comment-to-code translation capabilities. The prefix provides a detailed setup with class definitions, method implementations, and initial task additions. The suffix includes assertions that validate the functionality of the calculateTotalDuration method, covering normal and edge cases. This scenario tests the LLM's ability to generate accurate documentation and implement complex business logic.", "assertions": "", "gpt-4o_completion_0": "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "gpt-4o_completion_1": "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "gpt-4o_completion_2": "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "gpt-4o_completion_3": "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "gpt-4o_completion_4": "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "gpt-4o_completions": ["        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";", "        int totalDuration = manager.calculateTotalDuration();\n        assert totalDuration == 100 : \"Total duration should be 100\";"]}
{"id": "39", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * This class is responsible for handling user authentication.\n * It manages user sessions and validates login credentials.\n */\npublic class AuthManager {\n    private Map<String, String> userDatabase = new HashMap<>();\n    private Map<String, String> activeSessions = new HashMap<>();\n\n    /**\n     * Initializes the AuthManager with a predefined set of users.\n     */\n    public AuthManager() {\n        userDatabase.put(\"user1\", \"password1\");\n        userDatabase.put(\"user2\", \"password2\");\n    }\n\n    /**\n     * Validates the login credentials of a user.\n     * \n     * @param username the username of the user\n     * @param password the password of the user\n     * @return true if the credentials are valid, false otherwise\n     */\n    public boolean validateLogin(String username, String password) {\n        return userDatabase.containsKey(username) && userDatabase.get(username).equals(password);\n    }\n\n    /**\n     * Generates a new session for a logged-in user.\n     * \n     * @param username the username of the user\n     * @return a session token\n     */\n    public String createSession(String username) {\n        String sessionToken = \"session_\" + username + \"_token\";\n        activeSessions.put(sessionToken, username);\n        return sessionToken;\n    }\n\n    /**\n     * Validates if the session token is active.\n     * \n     * @param sessionToken the session token\n     * @return true if the session is active, false otherwise\n     */\n    public boolean validateSession(String sessionToken) {\n        return activeSessions.containsKey(sessionToken);\n    }\n\n    /**\n     * Invalidates an existing session.\n     * \n     * @param sessionToken the session token\n     */\n    public void invalidateSession(String sessionToken) {\n        activeSessions.remove(sessionToken);\n    }\n\n    public static void main(String[] args) {\n        AuthManager authManager = new AuthManager();\n        // Test validateLogin method\n", "suffix": "\n\n        // Test createSession method\n        String sessionToken = authManager.createSession(\"user1\");\n        assert sessionToken.equals(\"session_user1_token\");\n\n        // Test validateSession method\n        assert authManager.validateSession(sessionToken);\n        assert !authManager.validateSession(\"invalid_session_token\");\n\n        // Test invalidateSession method\n        authManager.invalidateSession(sessionToken);\n        assert !authManager.validateSession(sessionToken);\n    }\n}", "golden_completion": "\n        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"unknownUser\", \"password1\");\n\n", "LLM_justification": "This test case is a good example for bidirectional translation between code and documentation as it involves a realistic scenario of user authentication management. The prefix provides a comprehensive class definition with detailed Javadoc-style documentation comments. The suffix includes complete assertions to validate the functionality of the AuthManager class. This case effectively tests the LLM's ability to generate and understand detailed documentation and to implement corresponding functional code correctly.", "assertions": "", "gpt-4o_completion_0": "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "gpt-4o_completion_1": "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "gpt-4o_completion_2": "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "gpt-4o_completion_3": "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "gpt-4o_completion_4": "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "gpt-4o_completions": ["        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");", "        assert authManager.validateLogin(\"user1\", \"password1\");\n        assert !authManager.validateLogin(\"user1\", \"wrongpassword\");\n        assert !authManager.validateLogin(\"nonexistentuser\", \"password\");"]}
{"id": "40", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * ConfigurationManager is responsible for managing application configurations.\n * It allows dynamic settings and feature flags to be managed at runtime.\n */\npublic class ConfigurationManager {\n\n    private Map<String, String> settings;\n\n    /**\n     * Initializes the ConfigurationManager with default settings.\n     */\n    public ConfigurationManager() {\n        settings = new HashMap<>();\n        loadDefaultSettings();\n    }\n\n    /**\n     * Loads default settings into the manager.\n     */\n    private void loadDefaultSettings() {\n        settings.put(\"featureXEnabled\", \"false\");\n        settings.put(\"maxConnections\", \"10\");\n    }\n\n    /**\n     * Retrieves the value of a setting based on the provided key.\n     *\n     * @param key The key of the setting to retrieve.\n     * @return The value of the setting.\n     */\n    public String getSetting(String key) {\n        return settings.getOrDefault(key, \"\");\n    }\n\n    /**\n     * Updates the value of a setting dynamically.\n     *\n     * @param key The key of the setting to update.\n     * @param value The new value of the setting.\n     */\n", "suffix": "\n    /**\n     * Tests the ConfigurationManager class.\n     * Ensures that default settings are loaded and retrievable.\n     */\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n\n        // Assertions to verify default settings\n        assert \"false\".equals(configManager.getSetting(\"featureXEnabled\")) : \"featureXEnabled should be false\";\n        assert \"10\".equals(configManager.getSetting(\"maxConnections\")) : \"maxConnections should be 10\";\n        assert \"\".equals(configManager.getSetting(\"nonExistentKey\")) : \"nonExistentKey should return an empty string\";\n\n        // Cleaning up resources (if any)\n    }\n}\n", "golden_completion": "\n    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }\n", "LLM_justification": "This test case is a good example because it covers both code-to-comment and comment-to-code translation. It includes a ConfigurationManager class that manages application settings dynamically. The golden completion requires the LLM to generate a method to update settings dynamically based on provided documentation. The suffix includes assertions to verify the correctness of the default settings and their retrieval, ensuring the implementation matches the documentation. This scenario tests the LLM's ability to generate accurate and contextually appropriate documentation and code.", "assertions": "", "gpt-4o_completion_0": "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "gpt-4o_completion_1": "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "gpt-4o_completion_2": "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "gpt-4o_completion_3": "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "gpt-4o_completion_4": "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "gpt-4o_completions": ["    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }", "    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }"]}
{"id": "41", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The Order class represents a customer's order in a business domain.\n * It contains details about the items ordered, the total amount, and the status of the order.\n */\npublic class Order {\n    private List<String> items;\n    private double totalAmount;\n    private String status;\n\n    /**\n     * Initializes a new order with an empty item list and a status of 'Pending'.\n     */\n    public Order() {\n        this.items = new ArrayList<>();\n        this.totalAmount = 0.0;\n        this.status = \"Pending\";\n    }\n\n    /**\n     * Adds an item to the order and updates the total amount.\n     *\n     * @param item The item to be added.\n     * @param price The price of the item.\n     */\n    public void addItem(String item, double price) {\n        this.items.add(item);\n        this.totalAmount += price;\n    }\n\n    /**\n     * Completes the order by setting the status to 'Completed'.\n     */\n    public void completeOrder() {\n        this.status = \"Completed\";\n    }\n\n    /**\n     * Retrieves the current status of the order.\n     *\n     * @return The status of the order.\n     */\n    public String getStatus() {\n        return status;\n    }\n\n    /**\n     * Retrieves the total amount of the order.\n     *\n     * @return The total amount.\n     */\n    public double getTotalAmount() {\n        return totalAmount;\n    }\n\n    /**\n     * Retrieves the list of items in the order.\n     *\n     * @return The list of items.\n     */\n    public List<String> getItems() {\n        return items;\n    }\n\n    public static void main(String[] args) {\n        Order order = new Order();\n        OrderManager manager = new OrderManager();\n\n        // Test empty order\n        assert !manager.processOrder(order) : \"Order with no items should not be processed\";\n\n        // Add an item and test again\n        order.addItem(\"Laptop\", 1200.0);\n        assert manager.processOrder(order) : \"Order with items should be processed\";\n        assert order.getStatus().equals(\"Completed\") : \"Order status should be 'Completed'\";\n\n        // Test order with negative total amount\n        Order negativeOrder = new Order();\n        negativeOrder.addItem(\"Faulty Item\", -100.0);\n        assert !manager.processOrder(negativeOrder) : \"Order with negative total amount should not be processed\";\n\n        // Test order with zero total amount\n        Order zeroOrder = new Order();\n        zeroOrder.addItem(\"Free Item\", 0.0);\n        assert !manager.processOrder(zeroOrder) : \"Order with zero total amount should not be processed\";\n\n        System.out.println(\"All tests passed.\");\n    }\n}\n\nclass OrderManager {\n    /**\n     * Processes an order by performing business logic checks such as verifying the total amount and updating the order status.\n     *\n     * @param order The order to be processed.\n     * @return true if the order was successfully processed, false otherwise.\n     */\n    public boolean processOrder(Order order) {\n        // Ensure the order has at least one item\n        if (order.getItems().isEmpty()) {\n            return false;\n        }\n        // Ensure the total amount is positive\n        if (order.getTotalAmount() <= 0) {\n            return false;\n        }\n        // Complete the order\n        order.completeOrder();\n        return true;\n    }\n}", "suffix": "", "golden_completion": "\n/**\n * The OrderManagerTest class contains unit tests for the OrderManager class.\n * It verifies the correctness of the processOrder method under various scenarios.\n */\n", "LLM_justification": "This test case is a good example because it involves complex business logic with multiple checks and state changes. The documentation generated for the OrderManagerTest class provides context for the unit tests, explaining what scenarios are being tested and why. The assertions in the suffix ensure that the processOrder method behaves correctly under different conditions, making this a robust scenario for testing code-to-comment and comment-to-code translation capabilities.", "assertions": "", "gpt-4o_completion_0": "// No additional code is needed here as the provided code is complete and functional.", "gpt-4o_completion_1": "// No additional code is needed here as the provided code is complete and functional.", "gpt-4o_completion_2": "// No additional code is needed here as the provided code is already complete and functional.", "gpt-4o_completion_3": "// No additional code is needed here as the provided code is complete and functional.", "gpt-4o_completion_4": "// No additional code is needed here as the provided code is complete and functional.", "gpt-4o_completions": ["// No additional code is needed here as the provided code is complete and functional.", "// No additional code is needed here as the provided code is complete and functional.", "// No additional code is needed here as the provided code is already complete and functional.", "// No additional code is needed here as the provided code is complete and functional.", "// No additional code is needed here as the provided code is complete and functional."]}
{"id": "42", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * Represents a basic task scheduling system where tasks can be added,\n * removed, and executed in a specific order.\n */\npublic class TaskScheduler {\n    private List<Task> tasks;\n\n    /**\n     * Creates a new TaskScheduler with an empty task list.\n     */\n    public TaskScheduler() {\n        tasks = new ArrayList<>();\n    }\n\n    /**\n     * Adds a task to the scheduler.\n     * @param task the task to add\n     */\n    public void addTask(Task task) {\n        Objects.requireNonNull(task, \"Task cannot be null\");\n        tasks.add(task);\n    }\n\n    /**\n     * Removes a task from the scheduler.\n     * @param task the task to remove\n     */\n    public void removeTask(Task task) {\n        tasks.remove(task);\n    }\n\n    /**\n     * Executes all tasks in the order they were added.\n     */\n    public void executeAll() {\n        for (Task task : tasks) {\n            task.execute();\n        }\n    }\n\n    /**\n     * Gets the list of tasks (for testing purposes).\n     * @return the list of tasks\n     */\n    public List<Task> getTasks() {\n        return tasks;\n    }\n\n    /**\n     * A simple task interface.\n     */\n    public interface Task {\n        void execute();\n    }\n\n    public static void main(String[] args) {\n        TaskScheduler scheduler = new TaskScheduler();\n\n        Task task1 = new Task() {\n            @Override\n            public void execute() {\n                System.out.println(\"Task 1 executed\");\n            }\n        };\n\n        Task task2 = new Task() {\n            @Override\n            public void execute() {\n                System.out.println(\"Task 2 executed\");\n            }\n        };\n\n        // Add tasks to the scheduler\n", "suffix": "        // Execute all tasks\n        scheduler.executeAll();\n\n        // Assertions to verify the correct behavior of the TaskScheduler\n        assert scheduler.getTasks().size() == 2 : \"TaskScheduler should contain 2 tasks\";\n        assert scheduler.getTasks().contains(task1) : \"TaskScheduler should contain task1\";\n        assert scheduler.getTasks().contains(task2) : \"TaskScheduler should contain task2\";\n\n        // Remove task1 and assert the state\n        scheduler.removeTask(task1);\n        assert scheduler.getTasks().size() == 1 : \"TaskScheduler should contain 1 task after removal\";\n        assert !scheduler.getTasks().contains(task1) : \"TaskScheduler should not contain task1 after removal\";\n        assert scheduler.getTasks().contains(task2) : \"TaskScheduler should still contain task2 after removal\";\n\n        // Clean up resources (none in this case, but follows the pattern)\n    }\n}", "golden_completion": "\n        scheduler.addTask(task1);\n        scheduler.addTask(task2);\n", "LLM_justification": "This test case demonstrates a realistic scenario of a task scheduling system. The prefix provides a comprehensive setup with a TaskScheduler class, including methods for adding, removing, and executing tasks. The golden_completion involves adding tasks to the scheduler, which is a critical operation in the system. The suffix includes execution and detailed assertions to verify the correct behavior of the TaskScheduler. This scenario tests the LLM's ability to understand business logic translation and document code accurately, ensuring functional requirements are met.", "assertions": "", "gpt-4o_completion_0": "        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "gpt-4o_completion_1": "        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "gpt-4o_completion_2": "        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "gpt-4o_completion_3": "        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "gpt-4o_completion_4": "        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "gpt-4o_completions": ["        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "        scheduler.addTask(task1);\n        scheduler.addTask(task2);", "        scheduler.addTask(task1);\n        scheduler.addTask(task2);"]}
{"id": "43", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Manages feature flags for a software application.\n * Supports enabling, disabling, and checking the status of various features.\n */\npublic class FeatureFlagManager {\n    private Map<String, Boolean> featureFlags;\n\n    /**\n     * Initializes the feature flag manager with an empty set of flags.\n     */\n    public FeatureFlagManager() {\n        this.featureFlags = new HashMap<>();\n    }\n\n    /**\n     * Enables a feature flag.\n     *\n     * @param featureName the name of the feature to enable\n     */\n    public void enableFeature(String featureName) {\n        featureFlags.put(featureName, true);\n    }\n\n    /**\n     * Disables a feature flag.\n     *\n     * @param featureName the name of the feature to disable\n     */\n    public void disableFeature(String featureName) {\n        featureFlags.put(featureName, false);\n    }\n", "suffix": "\n    public boolean isFeatureEnabled(String featureName) {\n        return featureFlags.getOrDefault(featureName, false);\n    }\n\n    public static void main(String[] args) {\n        FeatureFlagManager manager = new FeatureFlagManager();\n        manager.enableFeature(\"NewUI\");\n        manager.disableFeature(\"OldUI\");\n\n        // Assertions\n        assert manager.isFeatureEnabled(\"NewUI\") == true : \"NewUI should be enabled\";\n        assert manager.isFeatureEnabled(\"OldUI\") == false : \"OldUI should be disabled\";\n        assert manager.isFeatureEnabled(\"NonExistentFeature\") == false : \"NonExistentFeature should default to disabled\";\n\n        // Cleanup (if any resources were being used)\n        // In this case, no resources to clean up\n    }\n}\n", "golden_completion": "    /**\n     * Checks if a feature is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */\n", "LLM_justification": "This example tests the ability to translate between Java code and comprehensive Javadoc comments. The scenario involves a feature flag manager which is a realistic business logic component used in many applications. The prefix provides a partial implementation along with Javadoc comments. The golden completion adds a method with detailed Javadoc, and the suffix includes assertions to verify the functionality. This tests the model's capability to generate accurate and contextually relevant documentation and code.", "assertions": "", "gpt-4o_completion_0": "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "gpt-4o_completion_1": "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "gpt-4o_completion_2": "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "gpt-4o_completion_3": "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "gpt-4o_completion_4": "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "gpt-4o_completions": ["    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */", "    /**\n     * Checks if a feature flag is enabled.\n     *\n     * @param featureName the name of the feature to check\n     * @return true if the feature is enabled, false otherwise\n     */"]}
{"id": "44", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * This class represents a configuration manager that handles dynamic settings and feature flags.\n * It provides methods to retrieve, update, and validate configuration settings.\n */\npublic class ConfigurationManager {\n    private Map<String, String> settings;\n\n    /**\n     * Initializes the configuration manager with default settings.\n     */\n    public ConfigurationManager() {\n        this.settings = new HashMap<>();\n        loadDefaultSettings();\n    }\n\n    /**\n     * Loads the default settings into the configuration manager.\n     */\n    private void loadDefaultSettings() {\n        settings.put(\"featureX\", \"enabled\");\n        settings.put(\"maxConnections\", \"100\");\n        settings.put(\"timeout\", \"30\");\n    }\n\n    /**\n     * Retrieves the value of a configuration setting.\n     *\n     * @param key The key of the configuration setting.\n     * @return The value of the configuration setting, or null if the key does not exist.\n     */\n    public String getSetting(String key) {\n        return settings.get(key);\n    }\n\n    /**\n     * Updates the value of a configuration setting.\n     *\n     * @param key The key of the configuration setting.\n     * @param value The new value of the configuration setting.\n     */\n    public void updateSetting(String key, String value) {\n        settings.put(key, value);\n    }\n\n    /**\n     * Validates the configuration settings.\n     * Ensures that all required settings are present and have valid values.\n     *\n     * @return true if all settings are valid, false otherwise.\n     */\n", "suffix": "\n\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n        assert configManager.getSetting(\"featureX\").equals(\"enabled\");\n        assert configManager.getSetting(\"maxConnections\").equals(\"100\");\n        assert configManager.getSetting(\"timeout\").equals(\"30\");\n        configManager.updateSetting(\"maxConnections\", \"200\");\n        assert configManager.getSetting(\"maxConnections\").equals(\"200\");\n        assert configManager.validateSettings();\n        configManager.updateSetting(\"maxConnections\", \"-1\");\n        assert !configManager.validateSettings();\n    }\n}\n", "golden_completion": "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout < 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n", "LLM_justification": "This test case demonstrates the bidirectional translation capabilities between Java code and documentation. The prefix contains a partially implemented ConfigurationManager class with methods to retrieve and update settings. The golden_completion requires the implementation of a method to validate these settings, which involves parsing integers and handling possible errors. The suffix includes assertions to verify the correctness of the validation logic. This scenario covers complex business rules validation, error handling, and dynamic settings management, making it a robust example for testing code-to-comment and comment-to-code translation.", "assertions": "", "gpt-4o_completion_0": "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "gpt-4o_completion_1": "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "gpt-4o_completion_2": "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "gpt-4o_completion_3": "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "gpt-4o_completion_4": "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "gpt-4o_completions": ["    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "    public boolean validateSettings() {\n        for (Map.Entry<String, String> entry : settings.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.equals(\"maxConnections\")) {\n                try {\n                    int maxConnections = Integer.parseInt(value);\n                    if (maxConnections <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"timeout\")) {\n                try {\n                    int timeout = Integer.parseInt(value);\n                    if (timeout <= 0) {\n                        return false;\n                    }\n                } catch (NumberFormatException e) {\n                    return false;\n                }\n            } else if (key.equals(\"featureX\")) {\n                if (!value.equals(\"enabled\") && !value.equals(\"disabled\")) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }"]}
{"id": "45", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * A class representing a feature flag management system.\n * This system allows toggling features on and off dynamically at runtime.\n */\npublic class FeatureFlagManager {\n\n    private final Map<String, Boolean> flags;\n\n    /**\n     * Initializes the FeatureFlagManager with an empty set of flags.\n     */\n    public FeatureFlagManager() {\n        this.flags = new HashMap<>();\n    }\n\n    /**\n     * Adds a new feature flag.\n     *\n     * @param feature the name of the feature\n     * @param isEnabled whether the feature is enabled\n     * @throws IllegalArgumentException if the feature name is null or empty\n     */\n    public void addFeatureFlag(String feature, boolean isEnabled) {\n        if (feature == null || feature.isEmpty()) {\n            throw new IllegalArgumentException(\"Feature name cannot be null or empty\");\n        }\n        flags.put(feature, isEnabled);\n    }\n\n    /**\n     * Checks if a feature is enabled.\n     *\n     * @param feature the name of the feature\n     * @return true if the feature is enabled, false otherwise\n     * @throws IllegalArgumentException if the feature does not exist\n     */\n    public boolean isFeatureEnabled(String feature) {\n        Boolean isEnabled = flags.get(feature);\n        if (isEnabled == null) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        return isEnabled;\n    }\n\n    /**\n     * Removes a feature flag.\n     *\n     * @param feature the name of the feature\n     * @throws IllegalArgumentException if the feature does not exist\n     */", "suffix": "\n    public static void main(String[] args) {\n        FeatureFlagManager manager = new FeatureFlagManager();\n        manager.addFeatureFlag(\"NewUI\", true);\n        manager.addFeatureFlag(\"BetaFeature\", false);\n\n        // Assertions\n        assert manager.isFeatureEnabled(\"NewUI\");\n        assert !manager.isFeatureEnabled(\"BetaFeature\");\n\n        // Check for non-existent feature\n        try {\n            manager.isFeatureEnabled(\"NonExistentFeature\");\n        } catch (IllegalArgumentException e) {\n            assert e.getMessage().equals(\"Feature does not exist\");\n        }\n    }\n}\n", "golden_completion": "\n    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }\n", "LLM_justification": "This example tests the bidirectional translation capabilities of an LLM by requiring it to generate comprehensive Javadoc documentation for a new method in an existing class. The prefix provides extensive context and working code for a feature flag management system. The golden completion involves adding a new method with appropriate documentation. The suffix includes assertions to verify that the new method behaves as expected, ensuring that the LLM-generated code is both functionally correct and well-documented.", "assertions": "", "gpt-4o_completion_0": "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "gpt-4o_completion_1": "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "gpt-4o_completion_2": "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "gpt-4o_completion_3": "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "gpt-4o_completion_4": "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "gpt-4o_completions": ["    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }", "    public void removeFeatureFlag(String feature) {\n        if (!flags.containsKey(feature)) {\n            throw new IllegalArgumentException(\"Feature does not exist\");\n        }\n        flags.remove(feature);\n    }"]}
{"id": "46", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * This class represents a basic configuration manager that handles\n * dynamic settings and feature flags for an application.\n */\npublic class ConfigurationManager {\n    private final Map<String, String> settings;\n\n    public ConfigurationManager() {\n        this.settings = new HashMap<>();\n    }\n\n    /**\n     * Adds or updates a configuration setting.\n     *\n     * @param key the key of the setting\n     * @param value the value of the setting\n     */\n    public void setSetting(String key, String value) {\n        settings.put(key, value);\n    }\n\n    /**\n     * Retrieves the value of a configuration setting.\n     *\n     * @param key the key of the setting\n     * @return the value of the setting, or null if the setting does not exist\n     */\n    public String getSetting(String key) {\n        return settings.get(key);\n    }\n\n    /**\n     * Removes a configuration setting.\n     *\n     * @param key the key of the setting\n     * @return the previous value of the setting, or null if the setting did not exist\n     */\n    public String removeSetting(String key) {\n        return settings.remove(key);\n    }\n\n    // The following method needs detailed Javadoc documentation:\n    /**\n", "suffix": "    public void clearSettings() {\n        settings.clear();\n    }\n\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n        configManager.setSetting(\"featureA\", \"enabled\");\n        configManager.setSetting(\"maxRetries\", \"5\");\n\n        // Assertions to verify the functionality\n        assert Objects.equals(configManager.getSetting(\"featureA\"), \"enabled\");\n        assert Objects.equals(configManager.getSetting(\"maxRetries\"), \"5\");\n        assert configManager.getSetting(\"nonexistent\") == null;\n\n        configManager.clearSettings();\n        assert configManager.getSetting(\"featureA\") == null;\n        assert configManager.getSetting(\"maxRetries\") == null;\n    }\n}\n", "golden_completion": "     * Clears all configuration settings.\n     *\n     * This method removes all settings from the configuration manager,\n     * effectively resetting it to an empty state. This can be useful in\n     * scenarios where a complete reset is required, such as during a\n     * major reconfiguration or when initializing the manager with a new\n     * set of settings.\n     */", "LLM_justification": "This test case is designed to evaluate the LLM's ability to generate comprehensive Javadoc documentation for a method in a ConfigurationManager class. The prefix provides a substantial amount of context, including other methods with detailed Javadoc comments, which should guide the LLM in generating consistent and complete documentation for the 'clearSettings' method. The suffix includes assertions to verify the functionality of the ConfigurationManager, ensuring that the code works as intended and that the documentation accurately reflects the behavior of the method. This scenario tests both code-to-comment and comment-to-code translation capabilities, making it a robust benchmark for evaluating the LLM's performance in generating and understanding Java documentation.", "assertions": "", "gpt-4o_completion_0": "    /**\n     * Clears all configuration settings.\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "gpt-4o_completion_1": "    /**\n     * Clears all configuration settings.\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "gpt-4o_completion_2": "    /**\n     * Clears all configuration settings.\n     *\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "gpt-4o_completion_3": "    /**\n     * Clears all configuration settings.\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "gpt-4o_completion_4": "    /**\n     * Clears all configuration settings.\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "gpt-4o_completions": ["    /**\n     * Clears all configuration settings.\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "    /**\n     * Clears all configuration settings.\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "    /**\n     * Clears all configuration settings.\n     *\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "    /**\n     * Clears all configuration settings.\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */", "    /**\n     * Clears all configuration settings.\n     * This method removes all key-value pairs from the settings map,\n     * effectively resetting the configuration manager to its initial state.\n     */"]}
{"id": "47", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n", "suffix": "\npublic class ConfigurationManager {\n\n    private final Map<String, String> settings;\n\n    public ConfigurationManager() {\n        this.settings = new HashMap<>();\n    }\n\n    /**\n     * Sets a configuration property.\n     *\n     * @param key the property key\n     * @param value the property value\n     */\n    public void setProperty(String key, String value) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        Objects.requireNonNull(value, \"Value cannot be null\");\n        settings.put(key, value);\n    }\n\n    /**\n     * Gets a configuration property.\n     *\n     * @param key the property key\n     * @return the property value, or null if not found\n     */\n    public String getProperty(String key) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        return settings.get(key);\n    }\n\n    /**\n     * Removes a configuration property.\n     *\n     * @param key the property key\n     * @return the previous property value, or null if not found\n     */\n    public String removeProperty(String key) {\n        Objects.requireNonNull(key, \"Key cannot be null\");\n        return settings.remove(key);\n    }\n\n    /**\n     * Clears all configuration properties.\n     */\n    public void clearProperties() {\n        settings.clear();\n    }\n\n    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n\n        // Test setting and getting properties\n        configManager.setProperty(\"url\", \"http://example.com\");\n        assert \"http://example.com\".equals(configManager.getProperty(\"url\"));\n\n        // Test removing properties\n        String removedValue = configManager.removeProperty(\"url\");\n        assert \"http://example.com\".equals(removedValue);\n        assert configManager.getProperty(\"url\") == null;\n\n        // Test clearing properties\n        configManager.setProperty(\"username\", \"admin\");\n        configManager.clearProperties();\n        assert configManager.getProperty(\"username\") == null;\n    }\n}\n", "golden_completion": "/**\n * ConfigurationManager is responsible for managing application configuration settings.\n * It allows setting, getting, and removing configuration properties.\n *\n * <p>Example usage:</p>\n * <pre>{@code\n * ConfigurationManager configManager = new ConfigurationManager();\n * configManager.setProperty(\"url\", \"http://example.com\");\n * String url = configManager.getProperty(\"url\");\n * }</pre>\n *\n * @param key the property key\n * @param value the property value\n * @return the previous property value, or null if not found\n */\n", "LLM_justification": "This test case is a realistic scenario involving configuration management, which is a common task in software development. The prefix sets up a ConfigurationManager class with methods for setting, getting, and removing configuration properties. The golden completion provides comprehensive documentation that includes a usage example, detailed parameter descriptions, and return value documentation. The suffix includes test cases that verify the functionality of the ConfigurationManager class, ensuring that the code works as intended and the documentation is accurate. The assertions check for correct behavior when setting, getting, removing, and clearing properties.", "assertions": "", "gpt-4o_completion_0": "package com.example.configuration;", "gpt-4o_completion_1": "package com.example.configuration;", "gpt-4o_completion_2": "package com.example.configuration;", "gpt-4o_completion_3": "package com.example.configuration;", "gpt-4o_completion_4": "package com.example.configuration;", "gpt-4o_completions": ["package com.example.configuration;", "package com.example.configuration;", "package com.example.configuration;", "package com.example.configuration;", "package com.example.configuration;"]}
{"id": "48", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport org.junit.Assert;\n\n/**\n * This class represents a simple configuration management system\n * that allows for dynamic settings and feature flags.\n */\npublic class ConfigManager {\n    private Map<String, String> settings;\n\n    public ConfigManager() {\n        settings = new HashMap<>();\n    }\n\n    /**\n     * Adds a new setting to the configuration.\n     *\n     * @param key   the key of the setting\n     * @param value the value of the setting\n     */\n    public void addSetting(String key, String value) {\n        settings.put(key, value);\n    }\n\n    /**\n     * Retrieves the value of a setting.\n     *\n     * @param key the key of the setting\n     * @return the value of the setting, or null if the setting does not exist\n     */\n    public String getSetting(String key) {\n        return settings.get(key);\n    }\n\n    /**\n     * Checks if a setting exists in the configuration.\n     *\n     * @param key the key of the setting\n     * @return true if the setting exists, false otherwise\n     */\n    public boolean hasSetting(String key) {\n        return settings.containsKey(key);\n    }\n\n    /**\n     * Removes a setting from the configuration.\n     *\n     * @param key the key of the setting to remove\n     */\n    public void removeSetting(String key) {\n        settings.remove(key);\n    }\n    /**\n     * Updates the value of an existing setting.\n     *\n     * @param key   the key of the setting to update\n     * @param value the new value of the setting\n     * @throws IllegalArgumentException if the setting does not exist\n     */\n", "suffix": "\n    public static void main(String[] args) {\n        ConfigManager configManager = new ConfigManager();\n        configManager.addSetting(\"featureX\", \"enabled\");\n        configManager.addSetting(\"maxConnections\", \"10\");\n\n        // Assertions to verify the implementation\n        Assert.assertTrue(configManager.hasSetting(\"featureX\"));\n        Assert.assertEquals(\"enabled\", configManager.getSetting(\"featureX\"));\n        Assert.assertEquals(\"10\", configManager.getSetting(\"maxConnections\"));\n        Assert.assertFalse(configManager.hasSetting(\"nonExistingKey\"));\n\n        configManager.removeSetting(\"featureX\");\n        Assert.assertFalse(configManager.hasSetting(\"featureX\"));\n    }\n}\n", "golden_completion": "\n    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }\n", "LLM_justification": "This test case is a good example of both code-to-comment and comment-to-code translation. It demonstrates how to dynamically manage configuration settings, including adding, retrieving, updating, and removing settings. The golden completion includes comprehensive Javadoc-style documentation for the updateSetting method, which is crucial for understanding the method's purpose and usage. The suffix contains assertions to verify the correct functionality of the ConfigManager class, ensuring that all operations behave as expected. This scenario tests the LLM's ability to generate accurate and detailed documentation as well as correct code implementation based on provided comments.", "assertions": "", "gpt-4o_completion_0": "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "gpt-4o_completion_1": "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "gpt-4o_completion_2": "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "gpt-4o_completion_3": "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "gpt-4o_completion_4": "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "gpt-4o_completions": ["    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }", "    public void updateSetting(String key, String value) {\n        if (!settings.containsKey(key)) {\n            throw new IllegalArgumentException(\"Setting does not exist: \" + key);\n        }\n        settings.put(key, value);\n    }"]}
{"id": "49", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * This class manages the configuration settings for the application.\n * The settings are stored in a key-value pair structure and can be\n * dynamically updated during runtime.\n */\npublic class ConfigurationManager {\n\n    private final Map<String, String> settings;\n\n    /**\n     * Initializes the configuration manager with default settings.\n     */\n    public ConfigurationManager() {\n        this.settings = new HashMap<>();\n        loadDefaultSettings();\n    }\n\n    /**\n     * Loads the default settings into the configuration manager.\n     */\n    private void loadDefaultSettings() {\n        settings.put(\"app.name\", \"MyApplication\");\n        settings.put(\"app.version\", \"1.0.0\");\n        settings.put(\"app.theme\", \"light\");\n    }\n\n    /**\n     * Retrieves the value for a given setting key.\n     *\n     * @param key The setting key to retrieve the value for.\n     * @return The value of the setting, or null if the key is not found.\n     */\n", "suffix": "    public static void main(String[] args) {\n        ConfigurationManager configManager = new ConfigurationManager();\n        // Assertions to verify the functionality\n        assert Objects.equals(configManager.getSetting(\"app.name\"), \"MyApplication\");\n        assert Objects.equals(configManager.getSetting(\"app.version\"), \"1.0.0\");\n        assert Objects.equals(configManager.getSetting(\"app.theme\"), \"light\");\n        assert configManager.getSetting(\"non.existent.key\") == null;\n        // Cleanup resources if any (not applicable here as there are no external resources)\n    }\n}\n", "golden_completion": "    public String getSetting(String key) {\n        return settings.get(key);\n    }\n", "LLM_justification": "This test case evaluates the LLM's ability to generate documentation for an existing Java method that retrieves configuration settings. The prefix provides extensive context with a class definition, including methods and comments. The golden completion involves adding a method with appropriate documentation, while the suffix contains assertions to verify the functionality. This setup tests the LLM's understanding of both code and documentation translation, ensuring it can generate accurate and comprehensive Javadoc-style comments.", "assertions": "", "gpt-4o_completion_0": "    public String getSetting(String key) {\n        return settings.get(key);\n    }", "gpt-4o_completion_1": "    public String getSetting(String key) {\n        return settings.get(key);\n    }", "gpt-4o_completion_2": "    public String getSetting(String key) {\n        return settings.get(key);\n    }", "gpt-4o_completion_3": "    public String getSetting(String key) {\n        return settings.get(key);\n    }", "gpt-4o_completion_4": "    public String getSetting(String key) {\n        return settings.get(key);\n    }", "gpt-4o_completions": ["    public String getSetting(String key) {\n        return settings.get(key);\n    }", "    public String getSetting(String key) {\n        return settings.get(key);\n    }", "    public String getSetting(String key) {\n        return settings.get(key);\n    }", "    public String getSetting(String key) {\n        return settings.get(key);\n    }", "    public String getSetting(String key) {\n        return settings.get(key);\n    }"]}
{"id": "50", "testsource": "devbench-code2NL-NL2code", "language": "java", "prefix": "package com.example.configmanagement;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n", "suffix": "\npublic class ConfigManager {\n    private final Map<String, String> configValues;\n\n    public ConfigManager() {\n        this.configValues = new HashMap<>();\n    }\n\n    /**\n     * Retrieves the configuration value for the given key.\n     *\n     * @param key the configuration key\n     * @return the configuration value, or null if the key does not exist\n     */\n    public String getConfigValue(String key) {\n        Objects.requireNonNull(key, \"Key must not be null\");\n        return configValues.get(key);\n    }\n\n    /**\n     * Sets the configuration value for the given key.\n     *\n     * @param key   the configuration key\n     * @param value the configuration value\n     */\n    public void setConfigValue(String key, String value) {\n        Objects.requireNonNull(key, \"Key must not be null\");\n        configValues.put(key, value);\n    }\n\n    /**\n     * Removes the configuration value for the given key.\n     *\n     * @param key the configuration key\n     * @return the previous value associated with the key, or null if there was no mapping\n     */\n    public String removeConfigValue(String key) {\n        Objects.requireNonNull(key, \"Key must not be null\");\n        return configValues.remove(key);\n    }\n\n    public static void main(String[] args) {\n        ConfigManager configManager = new ConfigManager();\n\n        // Test setting a configuration value\n        configManager.setConfigValue(\"app.timeout\", \"30\");\n        String value = configManager.getConfigValue(\"app.timeout\");\n        assert \"30\".equals(value) : \"Expected value to be '30'\";\n\n        // Test removing a configuration value\n        String removedValue = configManager.removeConfigValue(\"app.timeout\");\n        assert \"30\".equals(removedValue) : \"Expected removed value to be '30'\";\n        assert configManager.getConfigValue(\"app.timeout\") == null : \"Expected value to be null after removal\";\n\n        // Test getConfigValue with a non-existing key\n        assert configManager.getConfigValue(\"non.existing.key\") == null : \"Expected value to be null for non-existing key\";\n\n        // Test null key handling\n        try {\n            configManager.getConfigValue(null);\n            assert false : \"Expected NullPointerException for null key\";\n        } catch (NullPointerException e) {\n            assert e.getMessage().equals(\"Key must not be null\") : \"Expected specific exception message for null key\";\n        }\n\n        try {\n            configManager.setConfigValue(null, \"value\");\n            assert false : \"Expected NullPointerException for null key\";\n        } catch (NullPointerException e) {\n            assert e.getMessage().equals(\"Key must not be null\") : \"Expected specific exception message for null key\";\n        }\n\n        try {\n            configManager.removeConfigValue(null);\n            assert false : \"Expected NullPointerException for null key\";\n        } catch (NullPointerException e) {\n            assert e.getMessage().equals(\"Key must not be null\") : \"Expected specific exception message for null key\";\n        }\n    }\n}\n", "golden_completion": "/**\n * This class provides a simple configuration management system.\n * It allows setting, getting, and removing configuration values at runtime.\n * The values are stored in a map, ensuring thread safety and null safety.\n */\n", "LLM_justification": "This test case provides a realistic and practical scenario for configuration management in an application. The prefix includes a partially documented `ConfigManager` class, which handles dynamic settings. The golden completion fills in the missing class-level Javadoc comment. The suffix contains assertions to test the functionality, ensuring the code adheres to the documented behavior and handles error cases. This scenario tests the LLM's ability to generate comprehensive documentation and verify that the code performs as described.", "assertions": "", "gpt-4o_completion_0": "public class ConfigManager {", "gpt-4o_completion_1": "public class ConfigManager {", "gpt-4o_completion_2": "public class ConfigManager {", "gpt-4o_completion_3": "public class ConfigManager {", "gpt-4o_completion_4": "public class ConfigManager {", "gpt-4o_completions": ["public class ConfigManager {", "public class ConfigManager {", "public class ConfigManager {", "public class ConfigManager {", "public class ConfigManager {"]}
