{"id": "1", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListExample {\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<>();\n\t\tlist.add(\"apple\");\n\t\tlist.add(\"banana\");\n\t\t// Add more elements to the list", "suffix": "\t\t// Verify the list contents\n\t\tassert list.size() == 3 : \"Size should be 3\";\n\t\tassert list.contains(\"cherry\") : \"List should contain 'cherry'\";\n\t\tSystem.out.println(\"All assertions passed.\");\n\t}\n}", "golden_completion": "\t\tlist.add(\"cherry\");", "LLM_justification": "This test case is a good example of data structure manipulation, specifically adding elements to a List. The pattern is clear and widely recognized, with minimal context needed to understand that an element needs to be added to the list. The prefix sets up the List and adds initial elements, while the suffix checks the size and contents of the list, providing a clear, low-context scenario.", "assertions": "", "DeepSeek-V3-0324": "\t\tlist.add(\"cherry\");"}
{"id": "2", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tlist.add(1);\n\t\tlist.add(2);", "suffix": "\n\t\tlist.add(4);\n\t\tassert list.size() == 4 : \"Size should be 4\";\n\t\tassert list.get(2) == 3 : \"Element at index 2 should be 3\";\n\t\tassert list.get(3) == 4 : \"Element at index 3 should be 4\";\n\t}\n}", "golden_completion": "\n\t\tlist.add(3);", "LLM_justification": "This test case evaluates the LLM's ability to recognize and continue a pattern of adding elements to a list. The minimal context provides the initial steps of adding elements, and the completion should logically follow the established pattern. The assertions verify the correct continuation of the sequence.", "assertions": "", "DeepSeek-V3-0324": "\t\tlist.add(3);"}
{"id": "3", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\n\npublic class StringManipulator {\n\tpublic List<String> processStrings(List<String> input) {\n\t\tList<String> result = new ArrayList<>();\n\t\tfor (String str : input) {", "suffix": "\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tStringManipulator sm = new StringManipulator();\n\t\tList<String> input = List.of(\"hello\", \"world\");\n\t\tList<String> output = sm.processStrings(input);\n\t\tassert output.size() == 2;\n\t\tassert output.get(0).equals(\"HELLO\");\n\t\tassert output.get(1).equals(\"WORLD\");\n\t}\n}", "golden_completion": "\n\t\t\tresult.add(str.toUpperCase());", "LLM_justification": "This is a good test case because it tests the model's ability to recognize a common string manipulation pattern within a loop. The context provided is minimal but sufficient to establish the expected behavior of processing each string in the list by converting it to uppercase. The assertions verify that the pattern has been correctly recognized and implemented.", "assertions": "", "DeepSeek-V3-0324": "\t\t\tresult.add(str.toUpperCase());"}
{"id": "4", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class DataManipulation {\n    public static List<String> filterStrings(List<String> input) {\n        List<String> result = new ArrayList<>();\n        for (String str : input) {\n            if (str.contains(\"test\")) {\n", "suffix": "            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<String> input = List.of(\"test1\", \"example\", \"test2\");\n        List<String> output = filterStrings(input);\n        assert output.size() == 2;\n        assert output.contains(\"test1\");\n        assert output.contains(\"test2\");\n    }\n}", "golden_completion": "                result.add(str);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a pattern involving filtering elements from a list based on a condition. The pattern is clear with minimal context: iterating over a list, checking a condition, and adding matching elements to a result list. The prefix establishes the iteration and condition check, while the suffix shows the return statement and usage of the method. The completion requires adding the matching elements to the result list, a common pattern in data manipulation tasks.", "assertions": "", "DeepSeek-V3-0324": "                result.add(str);"}
{"id": "5", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class FilterExample {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\");\n        List<String> filteredNames = names.stream()", "suffix": "        .collect(Collectors.toList());\n        // Verify the filtered names contain only those starting with 'C'\n        assert filteredNames.size() == 1;\n        assert filteredNames.contains(\"Charlie\");\n        System.out.println(\"All assertions passed.\");\n    }\n}", "golden_completion": "        .filter(name -> name.startsWith(\"C\"))", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving Java Streams API for filtering a list of strings. The context is minimal, with the prefix providing the start of a stream operation and the suffix verifying the results. The completion should demonstrate an understanding of how to use the filter method correctly.", "assertions": "", "DeepSeek-V3-0324": "                .filter(name -> name.startsWith(\"C\"))"}
{"id": "6", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tList<String> list = new ArrayList<>();\n\t\tlist.add(\"Apple\");\n\t\tlist.add(\"Banana\");\n\t\tlist.add(\"Cherry\");\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor(String item : list) {", "suffix": "\n\t\t}\n\t\tassert result.toString().equals(\"Apple-Banana-Cherry-\");\n\t}\n}", "golden_completion": "\n\t\t\tresult.append(item).append(\"-\");", "LLM_justification": "This example tests the model's ability to recognize and continue a common pattern in Java: iterating through a collection and building a concatenated string. The pattern is clear from the prefix, and the suffix includes an assertion to verify the correct behavior. The minimal context ensures the model must rely on recognizing the iteration and string building pattern.", "assertions": "", "DeepSeek-V3-0324": "\t\t\tresult.append(item).append(\"-\");"}
{"id": "7", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class ListManipulation {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"apple\");\n        list.add(\"banana\");\n        list.add(\"cherry\");\n        // Insert the new element at index 1\n", "suffix": "        assert list.size() == 4 : \"List size should be 4\";\n        assert list.get(1).equals(\"date\") : \"Element at index 1 should be 'date'\";\n        assert list.get(2).equals(\"banana\") : \"Element at index 2 should be 'banana'\";\n        System.out.println(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "        list.add(1, \"date\");", "LLM_justification": "This test case verifies the LLM's ability to recognize and correctly implement a common pattern of inserting an element into a specific index in a list. The prefix sets up the list and specifies the need to insert at index 1, while the suffix includes assertions to ensure the operation was performed correctly. The low-context nature of the task tests the model's understanding of list manipulation patterns with minimal context.", "assertions": "", "DeepSeek-V3-0324": "        list.add(1, \"date\");"}
{"id": "8", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class CustomCollection<E> extends AbstractCollection<E> {\n    private final List<E> elements;\n\n    public CustomCollection() {\n        this.elements = new ArrayList<>();\n    }\n\n    @Override\n    public Iterator<E> iterator() {", "suffix": "\n    }\n\n    @Override\n    public int size() {\n        return elements.size();\n    }\n\n    public static void main(String[] args) {\n        CustomCollection<Integer> collection = new CustomCollection<>();\n        collection.elements.add(1);\n        collection.elements.add(2);\n        collection.elements.add(3);\n        Iterator<Integer> iterator = collection.iterator();\n        assert iterator.hasNext();\n        assert iterator.next() == 1;\n        assert iterator.next() == 2;\n        assert iterator.next() == 3;\n        assert !iterator.hasNext();\n    }\n}\n", "golden_completion": "        return new Iterator<E>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < elements.size();\n            }\n\n            @Override\n            public E next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return elements.get(index++);\n            }\n        };", "LLM_justification": "This example tests the model's ability to recognize and complete a custom collection implementation with a nested iterator class. The iterator pattern is complex due to its requirement for proper state management and exception handling. The prefix sets up the collection and hints at the need for an iterator implementation. The suffix contains assertions to verify the iterator's behavior, ensuring it can traverse the collection correctly and handle edge cases. This scenario challenges the model to understand the iterator pattern and implement it correctly in the context of a custom collection.", "assertions": "", "DeepSeek-V3-0324": "        return elements.iterator();"}
{"id": "9", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class RecursiveGenericExample {\n    static class Node<T extends Node<T>> {\n        private List<T> children = new ArrayList<>();\n\n        public void addChild(T child) {", "suffix": "\n        }\n\n        public List<T> getChildren() {\n            return children;\n        }\n    }\n\n    public static void main(String[] args) {\n        Node<?> root = new Node<>();\n        Node<?> child = new Node<>();\n        root.addChild(child);\n        assert root.getChildren().contains(child);\n        assert root.getChildren().size() == 1;\n    }\n}", "golden_completion": "            children.add(child);", "LLM_justification": "This test case is a good example of recursive generic types, which are an advanced feature of Java. The code requires understanding of how to use generics with recursive type bounds and how to implement and utilize such a structure. It is not something that can be solved by simple pattern matching as it involves advanced generic programming constructs.", "assertions": "", "DeepSeek-V3-0324": "            children.add(child);"}
{"id": "10", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class Example {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        Optional<Integer> result = ", "suffix": ";\n        if (result.isPresent()) {\n            System.out.println(\"The first even number is: \" + result.get());\n            assert result.get() == 2;\n        } else {\n            System.out.println(\"No even number found\");\n        }\n    }\n}", "golden_completion": "numbers.stream().filter(n -> n % 2 == 0).findFirst()", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common Java Stream API pattern for finding the first even number in a list. The scenario requires understanding of stream operations, filtering, and optional handling with minimal context. It demonstrates usage of Java's Stream API for processing collections, which is a common but non-trivial pattern.", "assertions": "", "DeepSeek-V3-0324": "numbers.stream().filter(n -> n % 2 == 0).findFirst()"}
{"id": "11", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\npublic class GenericExample {\n    public static <T extends Comparable<T>> T max(List<T> list) {\n        if (list == null || list.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n", "suffix": "\n    }\n\n    public static void main(String[] args) {\n        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);\n        assert max(intList) == 5;\n        List<String> strList = Arrays.asList(\"apple\", \"banana\", \"pear\");\n        assert max(strList).equals(\"pear\");\n    }\n}", "golden_completion": "        T max = list.get(0);\n        for (T element : list) {\n            if (element.compareTo(max) > 0) {\n                max = element;\n            }\n        }\n        return max;", "LLM_justification": "This example tests the model's ability to handle generic programming constructs with type bounds and comparable constraints. The pattern requires understanding of generics, type inference, and comparable interfaces. The example is realistic and would challenge a senior developer due to the need to handle generic types and ensure type safety while implementing a common algorithmic pattern.", "assertions": "", "DeepSeek-V3-0324": "        T max = list.get(0);\n        for (T element : list) {\n            if (element.compareTo(max) > 0) {\n                max = element;\n            }\n        }\n        return max;"}
{"id": "12", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class CustomFilter {\n    public static <T> List<T> filter(List<T> items, Predicate<T> predicate) {\n", "suffix": "\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5);\n        List<Integer> filtered = filter(numbers, n -> n % 2 == 0);\n        assert filtered.size() == 2;\n        assert filtered.contains(2);\n        assert filtered.contains(4);\n    }\n}", "golden_completion": "        List<T> result = new ArrayList<>();\n        for (T item : items) {\n            if (predicate.test(item)) {\n                result.add(item);\n            }\n        }\n        return result;", "LLM_justification": "This example tests the model's ability to recognize and complete a generic method pattern with type inference and functional interface usage. The pattern involves filtering a list using a predicate, which is a common yet non-trivial operation requiring understanding of generics, functional interfaces, and collection manipulation. The minimal context provided should be sufficient for an experienced Java developer to identify the pattern and complete it correctly, making it a good benchmark for the model's capabilities.", "assertions": "", "DeepSeek-V3-0324": "        List<T> result = new ArrayList<>();\n        for (T item : items) {\n            if (predicate.test(item)) {\n                result.add(item);\n            }\n        }\n        return result;"}
{"id": "13", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        Map<Boolean, List<Integer>> partitioned = numbers.stream()\n", "suffix": "        .get(true).stream().mapToInt(Integer::intValue).sum();\n        assert sumEven == 6 : \"Sum of even numbers should be 6\";\n        int sumOdd = partitioned.get(false).stream().mapToInt(Integer::intValue).sum();\n        assert sumOdd == 9 : \"Sum of odd numbers should be 9\";\n    }\n}\n", "golden_completion": "        .collect(Collectors.partitioningBy(n -> n % 2 == 0));\n        int sumEven = partitioned", "LLM_justification": "This example demonstrates a complex collector composition using Java Streams. The task involves partitioning a list of integers into even and odd numbers, and then calculating the sum of each partition. The use of Collectors.partitioningBy and subsequent stream operations requires a solid understanding of Java's Stream API and its advanced features. The assertions verify the correct partitioning and summation, ensuring the logic is correctly implemented.", "assertions": "", "DeepSeek-V3-0324": "                .collect(Collectors.partitioningBy(n -> n % 2 == 0));\n        int sumEven = partitioned"}
{"id": "14", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class GenericBoundsExample {\n    public static <T extends Comparable<T>> T findMax(List<T> list) {", "suffix": "        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        Integer maxNumber = findMax(numbers);\n        assert maxNumber == 5 : \"Max number should be 5\";\n\n        List<String> words = Arrays.asList(\"apple\", \"banana\", \"cherry\");\n        String maxWord = findMax(words);\n        assert maxWord.equals(\"cherry\") : \"Max word should be cherry\";\n    }\n}", "golden_completion": "        if (list == null || list.isEmpty()) {\n            throw new IllegalArgumentException(\"List is null or empty\");\n        }\n        T max = list.get(0);\n        for (T item : list) {\n            if (item.compareTo(max) > 0) {\n                max = item;\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {", "LLM_justification": "This test case demonstrates the usage of generic type bounds with a method that finds the maximum element in a list. It requires understanding of generic type parameters, bounded type parameters, and the Comparable interface. The completion involves handling edge cases (null or empty list) and iterating through the list to find the maximum value, which are common patterns in Java programming. Assertions are provided to verify the correctness of the implementation for different types (Integer and String).", "assertions": "", "DeepSeek-V3-0324": "        if (list.isEmpty()) {\n            throw new IllegalArgumentException(\"List is empty\");\n        }\n        T max = list.get(0);\n        for (T item : list) {\n            if (item.compareTo(max) > 0) {\n                max = item;\n            }\n        }\n        return max;"}
{"id": "15", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\nimport java.util.stream.*;\n\npublic class ComplexCollectorExample {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\");\n        Map<Integer, List<String>> lengthMap = items.stream()\n                .collect(", "suffix": "                );\n        assert lengthMap.get(5).equals(Arrays.asList(\"apple\", \"grape\"));\n        assert lengthMap.get(6).equals(Arrays.asList(\"banana\", \"cherry\"));\n        assert lengthMap.get(4).equals(Arrays.asList(\"date\"));\n        assert lengthMap.get(10).equals(Arrays.asList(\"elderberry\"));\n        assert lengthMap.get(3).equals(Arrays.asList(\"fig\"));\n    }\n}", "golden_completion": "                Collectors.groupingBy(String::length)", "LLM_justification": "This example tests the model's ability to complete an advanced Java pattern involving the use of Collectors and Streams for grouping elements by a specific criterion (in this case, string length). The pattern is recognizable but requires understanding of Java's Stream API and Collectors. The assertions verify that the completion correctly groups the strings by their lengths, ensuring the model's comprehension of the pattern. This demonstrates advanced usage of the Java Collections Framework, making it a good test case for challenging a senior Java developer.", "assertions": "", "DeepSeek-V3-0324": "Collectors.groupingBy(String::length)"}
{"id": "16", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class RecursiveGenerics {\n    static class Node<T extends Comparable<T>> {\n        T value;\n        Node<T> left, right;\n\n        Node(T value) {\n            this.value = value;\n        }\n    }\n\n    public static <T extends Comparable<T>> boolean isBST(Node<T> node, T min, T max) {", "suffix": "\n    }\n\n    public static void main(String[] args) {\n        Node<Integer> root = new Node<>(10);\n        root.left = new Node<>(5);\n        root.right = new Node<>(15);\n        root.left.left = new Node<>(2);\n        root.left.right = new Node<>(8);\n        root.right.left = new Node<>(12);\n        root.right.right = new Node<>(20);\n\n        assert isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE) : \"The tree should be a valid BST\";\n    }\n}\n", "golden_completion": "        if (node == null) {\n            return true;\n        }\n        if (node.value.compareTo(min) <= 0 || node.value.compareTo(max) >= 0) {\n            return false;\n        }\n        return isBST(node.left, min, node.value) && isBST(node.right, node.value, max);", "LLM_justification": "This example tests the ability to recognize and complete a recursive generic method that checks if a binary tree is a binary search tree (BST). It involves understanding of generics with type bounds, recursion, and comparison using the Comparable interface. The pattern is complex enough to require genuine understanding of Java language semantics.", "assertions": "", "DeepSeek-V3-0324": "        if (node == null) return true;\n        if (node.value.compareTo(min) <= 0 || node.value.compareTo(max) >= 0) return false;\n        return isBST(node.left, min, node.value) && isBST(node.right, node.value, max);"}
{"id": "17", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.Optional;\n\npublic class GenericTypeInference {\n    public <T extends Comparable<T>> Optional<T> findMax(T[] array) {", "suffix": "    }\n\n    public static void main(String[] args) {\n        GenericTypeInference inference = new GenericTypeInference();\n        Integer[] numbers = {1, 2, 3, 4, 5};\n        Optional<Integer> maxNumber = inference.findMax(numbers);\n        assert maxNumber.isPresent() && maxNumber.get() == 5 : \"Test failed\";\n        String[] words = {\"apple\", \"banana\", \"cherry\"};\n        Optional<String> maxWord = inference.findMax(words);\n        assert maxWord.isPresent() && maxWord.get().equals(\"cherry\") : \"Test failed\";\n    }\n}", "golden_completion": "        if (array == null || array.length == 0) {\n            return Optional.empty();\n        }\n        T max = array[0];\n        for (T element : array) {\n            if (element.compareTo(max) > 0) {\n                max = element;\n            }\n        }\n        return Optional.of(max);", "LLM_justification": "This test case checks the model's ability to handle generic type inference with bounded type parameters. The findMax method should identify the maximum element in an array of Comparable elements, which requires understanding of generic type bounds and type inference. The assertions ensure the implementation correctly identifies the maximum element and handles edge cases like empty arrays.", "assertions": "", "DeepSeek-V3-0324": "        if (array == null || array.length == 0) {\n            return Optional.empty();\n        }\n        T max = array[0];\n        for (T element : array) {\n            if (element.compareTo(max) > 0) {\n                max = element;\n            }\n        }\n        return Optional.of(max);"}
{"id": "18", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class CompletableFutureExample {\n    public static void main(String[] args) {\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \"Hello\")\n            .thenCompose(result -> ", "suffix": "            );\n        try {\n            String finalResult = future.get();\n            assert finalResult.equals(\"Hello World\");\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "golden_completion": "            CompletableFuture.supplyAsync(() -> result + \" World\")", "LLM_justification": "This example tests the model's ability to understand and complete a complex CompletableFuture chaining pattern, which involves asynchronous computation and composition. The pattern is advanced, involving nested asynchronous tasks and the use of thenCompose for chaining futures. The minimal context requires understanding of CompletableFuture API and how to chain tasks correctly.", "assertions": "", "DeepSeek-V3-0324": "CompletableFuture.supplyAsync(() -> result + \" World\")"}
{"id": "19", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\npublic class Main {\n    public static <T extends Comparable<T>> T findMax(List<? extends T> list) {\n        if (list == null || list.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be null or empty\");\n        }\n        T max = list.get(0);\n        for (T item : list) {", "suffix": "        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        Integer maxNumber = findMax(numbers);\n        assert maxNumber == 5 : \"Expected 5 but got \" + maxNumber;\n\n        List<String> words = Arrays.asList(\"apple\", \"banana\", \"cherry\");\n        String maxWord = findMax(words);\n        assert maxWord.equals(\"cherry\") : \"Expected 'cherry' but got \" + maxWord;\n    }\n}", "golden_completion": "            if (item.compareTo(max) > 0) {\n                max = item;\n            }", "LLM_justification": "This example tests the model's ability to recognize and complete a generic method that finds the maximum element in a list using the Comparable interface. The pattern involves iterating over the list and comparing each item to the current maximum, updating the maximum as needed. This scenario involves advanced generic programming constructs, including bounded type parameters and wildcard captures, which require a deep understanding of Java generics. The assertions in the suffix ensure that the method works correctly for different types, including Integer and String.", "assertions": "", "DeepSeek-V3-0324": "            if (item.compareTo(max) > 0) {\n                max = item;\n            }"}
{"id": "20", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.List;\nimport java.util.ArrayList;\nclass GenericBuilder<T> {\n    private List<T> items = new ArrayList<>();\n    public GenericBuilder<T> addItem(T item) {", "suffix": "\n    }\n    public List<T> build() {\n        return items;\n    }\n    public static void main(String[] args) {\n        GenericBuilder<String> builder = new GenericBuilder<>();\n        List<String> result = builder.addItem(\"A\").addItem(\"B\").build();\n        assert result.size() == 2 : \"Size should be 2\";\n        assert result.get(0).equals(\"A\") : \"First item should be 'A'\";\n        assert result.get(1).equals(\"B\") : \"Second item should be 'B'\";\n    }\n}", "golden_completion": "        items.add(item);\n        return this;", "LLM_justification": "This example tests the LLM's ability to recognize and complete a builder pattern using generic method chaining in Java. The context is minimal but provides enough to identify the pattern. Assertions in the suffix ensure the builder works correctly by verifying the size and contents of the resulting list.", "assertions": "", "DeepSeek-V3-0324": "        items.add(item);\n        return this;"}
{"id": "21", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.Objects;\n\npublic class GenericExample {\n    public static <T extends Comparable<T>> T max(T a, T b) {\n        ", "suffix": "    }\n\n    public static void main(String[] args) {\n        Integer result = max(3, 5);\n        Objects.requireNonNull(result);\n        assert result == 5 : \"Expected 5 but got \" + result;\n    }\n}", "golden_completion": "        return a.compareTo(b) > 0 ? a : b;", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving generic methods with bounded type parameters in Java. The pattern requires understanding generic programming constructs and the Comparable interface to correctly implement the max method. The assertions validate that the method correctly identifies the maximum of two integers. This is an advanced pattern that goes beyond simple collection operations or string manipulations.", "assertions": "", "DeepSeek-V3-0324": "        return a.compareTo(b) > 0 ? a : b;"}
{"id": "22", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\nimport java.util.function.Function;\n\npublic class GenericExample {\n    public static <T, R> List<R> map(List<T> list, Function<T, R> mapper) {\n        List<R> result = new ArrayList<>();", "suffix": "        for (T item : list) {\n            result.add(mapper.apply(item));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        List<String> strings = map(numbers, Object::toString);\n        assert strings.equals(Arrays.asList(\"1\", \"2\", \"3\", \"4\", \"5\"));\n    }\n}", "golden_completion": "        if (list == null || mapper == null) {\n            throw new IllegalArgumentException(\"Arguments cannot be null\");\n        }", "LLM_justification": "This example tests the model's ability to recognize and complete a generic programming pattern involving a type-safe mapping operation. The completion requires understanding of null checks and exception handling, which are common in robust Java code. The context is minimal, yet it establishes the pattern of transforming a list using a function, a non-trivial operation that requires deeper understanding beyond basic iteration. The assertions ensure that the resulting list matches the expected output and that the function handles null inputs correctly.", "assertions": "", "DeepSeek-V3-0324": ""}
{"id": "23", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.Optional;\n\npublic class GenericMethodExample {\n    public static <T extends Comparable<T>> Optional<T> findMax(T a, T b) {\n        if (a.compareTo(b) > 0) {\n", "suffix": "        }\n        return Optional.of(b);\n    }\n\n    public static void main(String[] args) {\n        Optional<Integer> max = findMax(10, 20);\n        assert max.isPresent() : \"Result should be present\";\n        assert max.get() == 20 : \"Max should be 20\";\n\n        Optional<String> maxStr = findMax(\"apple\", \"banana\");\n        assert maxStr.isPresent() : \"Result should be present\";\n        assert maxStr.get().equals(\"banana\") : \"Max should be banana\";\n    }\n}", "golden_completion": "            return Optional.of(a);", "LLM_justification": "This example tests the LLM's ability to recognize and complete a generic method pattern that involves type bounds and comparison. The context provided is minimal but sufficient to infer the intended logic, requiring an understanding of generics, type bounds, and the Comparable interface. The suffix includes assertions that validate the method's correctness for different data types, ensuring that the model must correctly implement the pattern to pass the tests.", "assertions": "", "DeepSeek-V3-0324": "            return Optional.of(a);"}
{"id": "24", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\nclass Example {\n    public static <T extends Comparable<T>> T findMax(List<T> list) {\n        if (list == null || list.isEmpty()) {\n            throw new IllegalArgumentException(\"List must not be empty\");\n        }\n        T max = list.get(0);\n        for (T item : list) {", "suffix": "        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        Integer maxNumber = findMax(numbers);\n        assert maxNumber == 5 : \"Expected max number to be 5\";\n\n        List<String> words = Arrays.asList(\"apple\", \"banana\", \"cherry\");\n        String maxWord = findMax(words);\n        assert \"cherry\".equals(maxWord) : \"Expected max word to be cherry\";\n    }\n}\n", "golden_completion": "            if (item.compareTo(max) > 0) {\n                max = item;\n            }", "LLM_justification": "This example tests the model's ability to recognize and complete a generic method that finds the maximum element in a list. The method requires understanding of generics, bounded type parameters, and the Comparable interface. The prefix sets up the method and the loop, while the suffix includes assertions to verify the method's correctness with different types. The correct completion involves comparing elements using the compareTo method, which is a non-trivial pattern that requires understanding of Java's generics and Comparable interface.", "assertions": "", "DeepSeek-V3-0324": "            if (item.compareTo(max) > 0) {\n                max = item;\n            }"}
{"id": "25", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\nclass CustomList<T extends Comparable<T>> {\n    private List<T> list = new ArrayList<>();\n\n    public void addElement(T element) {\n        list.add(element);\n    }\n\n    public List<T> getSortedElements() {", "suffix": "        return list;\n    }\n\n    public static void main(String[] args) {\n        CustomList<String> customList = new CustomList<>();\n        customList.addElement(\"banana\");\n        customList.addElement(\"apple\");\n        customList.addElement(\"cherry\");\n        List<String> sortedList = customList.getSortedElements();\n        assert sortedList.get(0).equals(\"apple\");\n        assert sortedList.get(1).equals(\"banana\");\n        assert sortedList.get(2).equals(\"cherry\");\n    }\n}\n", "golden_completion": "        Collections.sort(list);\n", "LLM_justification": "This example tests the LLM's ability to recognize a pattern involving a generic class with bounded type parameters and the use of Java's Collections utility to sort a list. The completion requires understanding of generic type bounds and the correct use of the sort method. The assertions verify the correct ordering of elements, ensuring the model's generated code adheres to the expected behavior.", "assertions": "", "DeepSeek-V3-0324": "        Collections.sort(list);"}
{"id": "26", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.concurrent.*;\n\npublic class CustomThreadPool {\n    public static void main(String[] args) {\n        ExecutorService executor = ", "suffix": "\n        Future<Integer> future1 = executor.submit(() -> 1 + 1);\n        Future<Integer> future2 = executor.submit(() -> 2 + 2);\n        try {\n            assert future1.get() == 2 : \"Future1 result mismatch\";\n            assert future2.get() == 4 : \"Future2 result mismatch\";\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n", "golden_completion": "        Executors.newFixedThreadPool(2);", "LLM_justification": "This example tests the LLM's ability to recognize and complete the pattern of using a fixed thread pool with Java's ExecutorService. The context provided is minimal, focusing on the creation and usage of a thread pool, as well as handling futures. The assertions ensure the correct execution and result of the submitted tasks, while the cleanup ensures proper resource management.", "assertions": "", "DeepSeek-V3-0324": "Executors.newFixedThreadPool(2);"}
{"id": "27", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        // Find the first even number and return its square\n        Optional<Integer> result = numbers.stream()\n", "suffix": "        .findFirst();\n        assert result.isPresent();\n        assert result.get() == 4;\n    }\n}\n", "golden_completion": "            .filter(n -> n % 2 == 0)\n            .map(n -> n * n)\n", "LLM_justification": "This example tests the model's ability to recognize and complete a stream processing pattern involving filtering and mapping operations to find and transform the first even number in a list. The pattern includes common operations in Java streams and requires understanding of functional programming concepts. The suffix contains assertions to ensure the correct even number is found and squared, making it a good test case for low-context pattern matching.", "assertions": "", "DeepSeek-V3-0324": "                .filter(n -> n % 2 == 0)\n                .map(n -> n * n)"}
{"id": "28", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.concurrent.*;\nimport java.util.function.*;\n\npublic class CompletableFutureExample {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 42);\n", "suffix": "        future.thenApplyAsync(result -> result * 2).thenAcceptAsync(result -> {\n            System.out.println(\"Final Result: \" + result);\n            assert result == 84;\n        }).join();\n    }\n}", "golden_completion": "        future = future.thenApplyAsync(result -> result + 10);", "LLM_justification": "This example tests the model's ability to recognize and continue a pattern involving CompletableFuture and asynchronous operations with minimal context. The pattern involves chaining asynchronous operations, which is a common and complex task in concurrent programming. The completion requires understanding how to properly chain CompletableFuture methods and handle asynchronous execution flows.", "assertions": "", "DeepSeek-V3-0324": "        future = future.thenApplyAsync(result -> result * 2);"}
{"id": "29", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.concurrent.*;\n\npublic class CustomThreadPool {\n    private final ThreadPoolExecutor executor;\n\n    public CustomThreadPool(int poolSize) {\n        executor = new ThreadPoolExecutor(poolSize, poolSize, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());\n    }\n\n    public void submitTask(Runnable task) {\n", "suffix": "    }\n\n    public void shutdown() {\n        executor.shutdown();\n    }\n\n    public static void main(String[] args) {\n        CustomThreadPool pool = new CustomThreadPool(2);\n        pool.submitTask(() -> System.out.println(\"Task 1\"));\n        pool.submitTask(() -> System.out.println(\"Task 2\"));\n        pool.shutdown();\n        try {\n            if (!pool.executor.awaitTermination(1, TimeUnit.SECONDS)) {\n                System.out.println(\"Not all tasks finished in time.\");\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "golden_completion": "        executor.submit(task);\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving custom thread pool management and task submission. The provided context is minimal but enough to infer that the missing code involves submitting a task to the executor. The example demonstrates advanced concurrency patterns, such as creating and managing a thread pool, and includes proper resource shutdown and exception handling.", "assertions": "", "DeepSeek-V3-0324": "        executor.execute(task);"}
{"id": "30", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class CustomCollector {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\");\n        Map<Character, List<String>> groupedByFirstChar = items.stream()\n            .collect(", "suffix": "            );\n        assert groupedByFirstChar.get('a').equals(Arrays.asList(\"apple\"));\n        assert groupedByFirstChar.get('b').equals(Arrays.asList(\"banana\"));\n        assert groupedByFirstChar.get('c').equals(Arrays.asList(\"cherry\"));\n        assert groupedByFirstChar.get('d').equals(Arrays.asList(\"date\"));\n    }\n}\n", "golden_completion": "            Collectors.groupingBy(s -> s.charAt(0))", "LLM_justification": "This example tests the LLM's ability to recognize and complete a complex Java Streams API pattern using Collectors. The pattern involves grouping elements of a stream by a specific criterion, which is a common but non-trivial operation. The assertions verify that the grouping was performed correctly, ensuring the model understands the pattern and its expected outcome.", "assertions": "", "DeepSeek-V3-0324": "Collectors.groupingBy(s -> s.charAt(0))"}
{"id": "31", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\nimport java.util.function.Function;\n\npublic class GenericTypeInference {\n    public static <T> List<T> transformList(List<T> list, Function<T, T> transformer) {\n        List<T> result = new ArrayList<>();", "suffix": "\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<String> strings = Arrays.asList(\"a\", \"b\", \"c\");\n        List<String> upperStrings = transformList(strings, String::toUpperCase);\n        assert upperStrings.equals(Arrays.asList(\"A\", \"B\", \"C\"));\n    }\n}", "golden_completion": "        for (T item : list) {\n            result.add(transformer.apply(item));\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving generic type inference and higher-order functions. The pattern involves transforming elements of a list using a provided function, which is a common scenario in functional programming with generics. The completion requires understanding of generics, type inference, and functional interfaces in Java.", "assertions": "", "DeepSeek-V3-0324": "        for (T item : list) {\n            result.add(transformer.apply(item));\n        }"}
{"id": "32", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.concurrent.*;\npublic class CustomThreadPool {\n    private final ExecutorService executor;\n    public CustomThreadPool(int nThreads) {\n        this.executor = Executors.newFixedThreadPool(nThreads);\n    }\n    public <T> Future<T> submitTask(Callable<T> task) {", "suffix": "    }\n    public void shutdown() {\n        executor.shutdown();\n    }\n    public static void main(String[] args) throws Exception {\n        CustomThreadPool pool = new CustomThreadPool(2);\n        Future<Integer> future = pool.submitTask(() -> 42);\n        assert future.get() == 42 : \"Task did not return expected result\";\n        pool.shutdown();\n    }\n}", "golden_completion": "        return executor.submit(task);", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern for submitting tasks to a custom thread pool using generics and the ExecutorService framework. The prefix sets up the class and method signature, while the suffix verifies the correct behavior with assertions. This scenario requires understanding of generics, concurrency, and the Executor framework, making it a good test case for advanced Java patterns.", "assertions": "", "DeepSeek-V3-0324": "        return executor.submit(task);"}
{"id": "33", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class CustomMap<K, V> {\n    private final Map<K, V> map = new HashMap<>();\n\n    public V put(K key, V value) {\n        return map.put(key, value);\n    }\n\n    public V get(K key) {\n        return map.get(key);\n    }\n\n    public Set<K> keySet() {", "suffix": "\n    }\n\n    public static void main(String[] args) {\n        CustomMap<String, Integer> customMap = new CustomMap<>();\n        customMap.put(\"one\", 1);\n        customMap.put(\"two\", 2);\n        customMap.put(\"three\", 3);\n\n        Set<String> keys = customMap.keySet();\n        assert keys.contains(\"one\");\n        assert keys.contains(\"two\");\n        assert keys.contains(\"three\");\n        assert keys.size() == 3;\n    }\n}\n", "golden_completion": "        return map.keySet();", "LLM_justification": "This example demonstrates the use of a custom generic class `CustomMap` with advanced usage of Java Collections Framework. The pattern involves manipulating a map and retrieving its key set. The low-context scenario tests the model's ability to recognize and correctly continue the pattern of interacting with a map. The assertions in the suffix validate that the key set contains all expected elements and has the correct size.", "assertions": "", "DeepSeek-V3-0324": "        return map.keySet();"}
{"id": "34", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class GenericTypeBounds {\n    public static <T extends Comparable<T>> T findMax(T a, T b, T c) {", "suffix": "        }\n\n    public static void main(String[] args) {\n        Integer maxInt = findMax(1, 2, 3);\n        String maxStr = findMax(\"apple\", \"banana\", \"cherry\");\n        assert maxInt == 3;\n        assert maxStr.equals(\"cherry\");\n    }\n}", "golden_completion": "        T max = a;\n        if (b.compareTo(max) > 0) {\n            max = b;\n        }\n        if (c.compareTo(max) > 0) {\n            max = c;\n        }\n        return max;", "LLM_justification": "This example tests the LLM's ability to recognize and complete a method using generic type bounds with Comparable. The pattern includes type inference challenges and the use of compareTo for comparison. The code requires understanding of generics, bounds, and comparisons, making it non-trivial. The assertions validate the correctness of the method by comparing the results for Integer and String types.", "assertions": "", "DeepSeek-V3-0324": "        T max = a;\n        if (b.compareTo(max) > 0) {\n            max = b;\n        }\n        if (c.compareTo(max) > 0) {\n            max = c;\n        }\n        return max;"}
{"id": "35", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class CustomCollection<T> {\n    private Set<T> items = new HashSet<>();\n\n    public void addItem(T item) {\n        items.add(item);\n    }\n\n    public void addAll(Collection<? extends T> items) {", "suffix": "    }\n\n    public boolean containsItem(T item) {\n        return items.contains(item);\n    }\n\n    public static void main(String[] args) {\n        CustomCollection<String> collection = new CustomCollection<>();\n        collection.addItem(\"test1\");\n        collection.addAll(Arrays.asList(\"test2\", \"test3\"));\n        assert collection.containsItem(\"test1\");\n        assert collection.containsItem(\"test2\");\n        assert collection.containsItem(\"test3\");\n    }\n}\n", "golden_completion": "        for (T item : items) {\n            this.items.add(item);\n        }", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving generic programming constructs and collection manipulation. The method addAll uses a wildcard with an extends bound, which is a common but advanced pattern in Java. The expected completion involves iterating over the input collection and adding each item to the internal set, demonstrating knowledge of both generics and collection handling. The assertions in the suffix verify that the items were correctly added to the set, ensuring the completion is functionally correct.", "assertions": "", "DeepSeek-V3-0324": "        this.items.addAll(items);"}
{"id": "36", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class GenericExample {\n    public static <T extends Comparable<T>> List<T> mergeSortedLists(List<T> list1, List<T> list2) {\n        List<T> result = new ArrayList<>();\n        int i = 0, j = 0;\n", "suffix": "        while (i < list1.size()) {\n            result.add(list1.get(i++));\n        }\n        while (j < list2.size()) {\n            result.add(list2.get(j++));\n        }\n        assert result.size() == 6;\n        assert result.get(0) == 1;\n        assert result.get(1) == 2;\n        assert result.get(2) == 3;\n        assert result.get(3) == 4;\n        assert result.get(4) == 5;\n        assert result.get(5) == 6;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list1 = Arrays.asList(1, 3, 5);\n        List<Integer> list2 = Arrays.asList(2, 4, 6);\n        mergeSortedLists(list1, list2);\n    }\n}\n", "golden_completion": "        while (i < list1.size() && j < list2.size()) {\n            if (list1.get(i).compareTo(list2.get(j)) <= 0) {\n                result.add(list1.get(i++));\n            } else {\n                result.add(list2.get(j++));\n            }\n        }", "LLM_justification": "This example tests the model's ability to recognize and complete a common algorithmic pattern involving merging two sorted lists using generics and type bounds. The provided context is minimal, yet it sets up a clear pattern that requires understanding of generics, type bounds, and list manipulation. This ensures the model must demonstrate a higher level of understanding and not just simple pattern matching.", "assertions": "", "DeepSeek-V3-0324": "        while (i < list1.size() && j < list2.size()) {\n            if (list1.get(i).compareTo(list2.get(j)) < 0) {\n                result.add(list1.get(i++));\n            } else {\n                result.add(list2.get(j++));\n            }\n        }"}
{"id": "37", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\nclass RecursiveTypeBounds {\n    static class Node<T extends Comparable<T>> {\n        T value;\n        Node<T> left, right;\n\n        Node(T value) {\n            this.value = value;\n        }\n    }\n\n    static <T extends Comparable<T>> void insert(Node<T> node, T value) {", "suffix": "        if (value.compareTo(node.value) < 0) {\n            if (node.left == null) node.left = new Node<>(value);\n            else insert(node.left, value);\n        } else {\n            if (node.right == null) node.right = new Node<>(value);\n            else insert(node.right, value);\n        }\n    }\n\n    public static void main(String[] args) {\n        Node<Integer> root = new Node<>(10);\n        insert(root, 5);\n        insert(root, 20);\n        insert(root, 15);\n        assert root.left.value == 5;\n        assert root.right.value == 20;\n        assert root.right.left.value == 15;\n    }\n}", "golden_completion": "        if (node == null || value == null) throw new IllegalArgumentException();", "LLM_justification": "This example demonstrates the use of recursive type bounds with a generic method, which requires understanding of both generics and recursive type constraints. The pattern involves inserting elements into a binary search tree, which is a common data structure in computer science. This requires the model to correctly handle type bounds and recursive method calls, ensuring the values are inserted in the right place based on their natural ordering. The assertions validate the correct structure of the tree after multiple insertions, ensuring the model's completion maintains the integrity of the tree.", "assertions": "", "DeepSeek-V3-0324": "        if (node == null) return;"}
{"id": "38", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.function.Function;\nimport java.util.function.BiFunction;\nclass Operation<T, R> {\n    private final Function<T, R> function;\n    private final T input;\n    public Operation(Function<T, R> function, T input) {\n        this.function = function;\n        this.input = input;\n    }\n    public R execute() {\n        return function.apply(input);\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Function<Integer, String> intToString = i -> \"Number: \" + i;", "suffix": "\n        String result = operation.execute();\n        assert result.equals(\"Number: 5\");\n        System.out.println(\"Test passed!\");\n    }\n}", "golden_completion": "        Operation<Integer, String> operation = new Operation<>(intToString, 5);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a pattern involving a generic class, function interfaces, and method execution. The pattern involves creating an instance of a generic class with a function and an input, and then executing the function. The suffix includes assertions to verify the correctness of the pattern, ensuring that the LLM understands the use of function interfaces and generic types in Java. This example is complex enough to challenge a senior developer and requires an understanding of advanced Java features like generics and functional programming.", "assertions": "", "DeepSeek-V3-0324": "        Operation<Integer, String> operation = new Operation<>(intToString, 5);"}
{"id": "39", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.concurrent.locks.*;\n\npublic class LockFreeStack<E> {\n    private static class Node<E> {\n        final E value;\n        Node<E> next;\n\n        Node(E value) {\n            this.value = value;\n        }\n    }\n\n    private volatile Node<E> head;\n\n    public void push(E value) {\n        Node<E> newHead = new Node<>(value);\n", "suffix": "    }\n\n    private boolean compareAndSetHead(Node<E> oldHead, Node<E> newHead) {\n        synchronized (this) {\n            if (head == oldHead) {\n                head = newHead;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public E pop() {\n        Node<E> oldHead;\n        Node<E> newHead;\n        do {\n            oldHead = head;\n            if (oldHead == null) {\n                return null;\n            }\n            newHead = oldHead.next;\n        } while (!compareAndSetHead(oldHead, newHead));\n        return oldHead.value;\n    }\n\n    public static void main(String[] args) {\n        LockFreeStack<Integer> stack = new LockFreeStack<>();\n        stack.push(1);\n        stack.push(2);\n        stack.push(3);\n        assert stack.pop() == 3;\n        assert stack.pop() == 2;\n        assert stack.pop() == 1;\n        assert stack.pop() == null;\n    }\n}", "golden_completion": "        Node<E> oldHead;\n        do {\n            oldHead = head;\n            newHead.next = oldHead;\n        } while (!compareAndSetHead(oldHead, newHead));\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a complex lock-free data structure pattern with minimal context. The LockFreeStack class uses volatile and synchronized mechanisms to ensure thread safety without relying on traditional locking. The completion requires understanding of compare-and-set patterns and volatile variables, which are advanced Java concurrency features. The suffix includes robust assertions to verify the correctness of the implementation, ensuring that the stack operates as expected under concurrent conditions.", "assertions": "", "DeepSeek-V3-0324": "        Node<E> oldHead;\n        do {\n            oldHead = head;\n            newHead.next = oldHead;\n        } while (!compareAndSetHead(oldHead, newHead));"}
{"id": "40", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class CustomMap<K, V> extends HashMap<K, V> {\n    public List<V> getAllValues(K key1, K key2) {\n        List<V> values = new ArrayList<>();\n        values.add(get(key1));\n        values.add(get(key2));\n", "suffix": "        return values;\n    }\n\n    public static void main(String[] args) {\n        CustomMap<String, Integer> map = new CustomMap<>();\n        map.put(\"A\", 1);\n        map.put(\"B\", 2);\n        List<Integer> values = map.getAllValues(\"A\", \"B\");\n        assert values.size() == 2 : \"Size should be 2\";\n        assert values.contains(1) : \"Should contain value 1\";\n        assert values.contains(2) : \"Should contain value 2\";\n    }\n}\n", "golden_completion": "        if (key1.equals(key2)) {\n            values.add(get(key1));\n        }", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving custom Map methods with generic types and handling potential key equality scenarios. It requires understanding of collections, generics, and method overriding in Java.", "assertions": "", "DeepSeek-V3-0324": "        return values;"}
{"id": "41", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\nclass ComplexCollector {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\");\n        Map<Boolean, List<String>> partitioned = items.stream()\n            .collect(", "suffix": "            );\n        assert partitioned.get(true).size() == 3 : \"Expected 3 elements starting with a consonant\";\n        assert partitioned.get(false).size() == 2 : \"Expected 2 elements starting with a vowel\";\n    }\n}\n", "golden_completion": "            Collectors.partitioningBy(s -> Arrays.asList('a', 'e', 'i', 'o', 'u').contains(s.charAt(0)))", "LLM_justification": "This example tests the LLM's ability to recognize and complete a complex collector composition pattern using Java Streams API. The completion involves partitioning a list based on a condition, which is a non-trivial use of Collectors.partitioningBy. This requires understanding of higher-order functions, lambda expressions, and the Java Streams API.", "assertions": "", "DeepSeek-V3-0324": "Collectors.partitioningBy(s -> !s.matches(\"^[aeiouAEIOU].*\"))"}
{"id": "42", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class RecursiveTypeBounds {\n    public static <T extends Comparable<T>> T findMax(Collection<T> items) {\n        if (items == null || items.isEmpty()) {\n            throw new IllegalArgumentException(\"Collection cannot be null or empty\");\n        }\n        Iterator<T> iterator = items.iterator();\n", "suffix": "        while (iterator.hasNext()) {\n            T next = iterator.next();\n            if (next.compareTo(max) > 0) {\n                max = next;\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 3, 2, 5, 4);\n        Integer maxNumber = findMax(numbers);\n        assert maxNumber == 5 : \"Expected max number to be 5\";\n\n        List<String> words = Arrays.asList(\"apple\", \"banana\", \"pear\", \"grape\");\n        String maxWord = findMax(words);\n        assert maxWord.equals(\"pear\") : \"Expected max word to be 'pear'\";\n    }\n}\n", "golden_completion": "        T max = iterator.next();", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving recursive type bounds with generic parameters in Java. The scenario involves finding the maximum element in a collection of comparable items, which requires understanding of generics, type bounds, and the Comparable interface. The completion involves initializing the max variable using the iterator, a critical step that must be correctly inferred from the context. The suffix contains assertions to verify the correctness of the implementation with different types of collections.", "assertions": "", "DeepSeek-V3-0324": "        T max = iterator.next();"}
{"id": "43", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\nclass CustomCache<K, V> {\n    private final Map<K, V> cache = new HashMap<>();\n    private final int maxSize;\n\n    public CustomCache(int maxSize) {\n        this.maxSize = maxSize;\n    }\n\n    public void put(K key, V value) {\n        if (cache.size() >= maxSize) {\n            cache.remove(cache.keySet().iterator().next());\n        }\n        ", "suffix": "\n    }\n\n    public V get(K key) {\n        return cache.get(key);\n    }\n\n    public static void main(String[] args) {\n        CustomCache<String, String> cache = new CustomCache<>(2);\n        cache.put(\"key1\", \"value1\");\n        cache.put(\"key2\", \"value2\");\n        cache.put(\"key3\", \"value3\");\n\n        assert cache.get(\"key1\") == null : \"key1 should be evicted\";\n        assert cache.get(\"key2\").equals(\"value2\") : \"key2 should still be present\";\n        assert cache.get(\"key3\").equals(\"value3\") : \"key3 should still be present\";\n    }\n}\n", "golden_completion": "        cache.put(key, value);", "LLM_justification": "This example tests the model's ability to complete a method in a custom cache implementation with limited context. It involves understanding a common pattern in cache eviction where the least recently added item is removed when the cache reaches its maximum size. The prefix and suffix provide minimal context, focusing on the critical part of the pattern, i.e., ensuring the new item is added to the cache correctly. The example also includes assertions to verify the correct behavior of the cache after multiple insertions, challenging the model's understanding of how the eviction policy should work.", "assertions": "", "DeepSeek-V3-0324": "        cache.put(key, value);"}
{"id": "44", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\nclass Example {\n\tpublic static <T extends Comparable<T>> void sortList(List<T> list) {\n\t\tCollections.sort(", "suffix": "    );\n\t}\n\tpublic static void main(String[] args) {\n\t\tList<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9);\n\t\tsortList(numbers);\n\t\tassert numbers.get(0) == 1;\n\t\tassert numbers.get(1) == 1;\n\t\tassert numbers.get(2) == 3;\n\t\tassert numbers.get(3) == 4;\n\t\tassert numbers.get(4) == 5;\n\t\tassert numbers.get(5) == 9;\n\t}\n}", "golden_completion": "    list", "LLM_justification": "This example tests the LLM's ability to complete a generic method call within a context of sorting a list. The method uses bounded type parameters and generics, which requires the LLM to understand how to properly apply Collections.sort to a List of elements that implement Comparable. The assertions in the suffix verify that the list is sorted correctly, demonstrating understanding of both the method's purpose and Java's Collections framework. This example avoids trivial operations and ensures that the completion requires knowledge of generic type bounds and method invocation within Java.", "assertions": "", "DeepSeek-V3-0324": "list"}
{"id": "45", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.concurrent.atomic.AtomicInteger;\n\npublic class LockFreeCounter {\n    private AtomicInteger counter = new AtomicInteger(0);\n\n    public int incrementAndGet() {\n        ", "suffix": "    }\n\n    public static void main(String[] args) {\n        LockFreeCounter counter = new LockFreeCounter();\n        int newCount = counter.incrementAndGet();\n        assert newCount == 1 : \"Expected count to be 1 but got \" + newCount;\n    }\n}\n", "golden_completion": "        return counter.incrementAndGet();", "LLM_justification": "This test case demonstrates the lock-free data structure pattern using AtomicInteger for concurrency. It tests the model's ability to recognize the pattern of using AtomicInteger for thread-safe increments in a minimal context. The prefix sets up the class and the method signature, while the completion involves the correct usage of AtomicInteger's incrementAndGet method. The suffix includes an assertion to verify the expected behavior, ensuring that the pattern is understood and correctly implemented.", "assertions": "", "DeepSeek-V3-0324": "        return counter.incrementAndGet();"}
{"id": "46", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\nclass RecursiveType<T extends RecursiveType<T>> {\n    private List<T> elements;\n    public RecursiveType() { this.elements = new ArrayList<>(); }\n    public void addElement(T element) {", "suffix": "}\n    public T getElement(int index) { return elements.get(index); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        RecursiveType<RecursiveType<?>> root = new RecursiveType<>();\n        RecursiveType<RecursiveType<?>> child = new RecursiveType<>();\n        root.addElement(child);\n        assert root.getElement(0) == child;\n        System.out.println(\"All assertions passed.\");\n    }\n}", "golden_completion": "        elements.add(element);", "LLM_justification": "This example demonstrates the usage of recursive type bounds in generics, which is an advanced Java feature. The pattern is identifiable with minimal context, and the completion involves adding an element to a generic list with recursive type bounds. The suffix includes necessary assertions to ensure the correct functionality of the code.", "assertions": "", "DeepSeek-V3-0324": "        elements.add(element);"}
{"id": "47", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\n\npublic class CustomMap<K, V> {\n    private final Map<K, V> map = new HashMap<>();\n\n    public void put(K key, V value) {\n        map.put(key, value);\n    }\n\n    public V get(K key) {\n        return map.get(key);\n    }\n\n    public void mergeMaps(Map<? extends K, ? extends V> otherMap) {\n", "suffix": "    }\n\n    public static void main(String[] args) {\n        CustomMap<String, Integer> customMap = new CustomMap<>();\n        customMap.put(\"a\", 1);\n        customMap.put(\"b\", 2);\n        Map<String, Integer> otherMap = new HashMap<>();\n        otherMap.put(\"b\", 3);\n        otherMap.put(\"c\", 4);\n        customMap.mergeMaps(otherMap);\n        assert customMap.get(\"a\") == 1;\n        assert customMap.get(\"b\") == 3;\n        assert customMap.get(\"c\") == 4;\n    }\n}\n", "golden_completion": "        for (Map.Entry<? extends K, ? extends V> entry : otherMap.entrySet()) {\n            map.merge(entry.getKey(), entry.getValue(), (v1, v2) -> v2);\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern for merging maps with generics, utilizing the `merge` method of the `Map` interface. It requires understanding of wildcard capture and lambda expressions for merging values, which are advanced Java features.", "assertions": "", "DeepSeek-V3-0324": "        map.putAll(otherMap);"}
{"id": "48", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\npublic class GenericExample {\n\tpublic static <T extends Comparable<T>> void sortAndPrint(List<T> list) {\n\t\t", "suffix": "}\n\tpublic static void main(String[] args) {\n\t\tList<Integer> numbers = Arrays.asList(4, 3, 2, 1);\n\t\tsortAndPrint(numbers);\n\t\tassert numbers.get(0) == 1;\n\t\tassert numbers.get(1) == 2;\n\t\tassert numbers.get(2) == 3;\n\t\tassert numbers.get(3) == 4;\n\t}\n}", "golden_completion": "    Collections.sort(list);\n\t\tfor (T element : list) {\n\t\t\tSystem.out.println(element);\n\t\t}", "LLM_justification": "This example tests the model's ability to recognize and complete a generic method that sorts and prints a list of elements. The method uses a type bound with Comparable to ensure the elements can be sorted. The completion requires understanding of Java generics, type bounds, and the Collections.sort method. The suffix includes assertions to verify the list is correctly sorted and printed, ensuring the model's completion is accurate and functional.", "assertions": "", "DeepSeek-V3-0324": "\t\tCollections.sort(list);\n\t\tfor (T item : list) {\n\t\t\tSystem.out.println(item);\n\t\t}"}
{"id": "49", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.*;\npublic class CustomCollectorExample {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"apple\", \"banana\", \"orange\", \"apple\", \"banana\", \"apple\");\n        Map<String, Long> itemCount = items.stream()\n            .collect(", "suffix": "            );\n        assert itemCount.get(\"apple\") == 3 : \"Expected 3 apples, got \" + itemCount.get(\"apple\");\n        assert itemCount.get(\"banana\") == 2 : \"Expected 2 bananas, got \" + itemCount.get(\"banana\");\n        assert itemCount.get(\"orange\") == 1 : \"Expected 1 orange, got \" + itemCount.get(\"orange\");\n    }\n}\n", "golden_completion": "            Collectors.groupingBy(Function.identity(), Collectors.counting())", "LLM_justification": "This example tests the LLM's ability to recognize and complete a complex collector pattern in Java Streams. The groupingBy collector with a counting downstream collector is a non-trivial pattern that requires understanding of advanced Java Streams API features. The given prefix sets up a stream of strings, and the LLM must infer the correct way to count occurrences of each string using collectors. The assertions in the suffix verify that the completion correctly implements the pattern.", "assertions": "", "DeepSeek-V3-0324": "Collectors.groupingBy(Function.identity(), Collectors.counting())"}
{"id": "50", "testsource": "devbench-low-context", "language": "java", "prefix": "import java.util.concurrent.*;\npublic class CustomThreadPool {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        Future<Integer> future1 = executor.submit(() -> {\n            Thread.sleep(1000);\n            return 1;\n        });\n        Future<Integer> future2 = executor.submit(() -> {\n            Thread.sleep(500);\n            return 2;\n        });\n        try {", "suffix": "\n            assert result1 == 1 : \"First future did not return 1\";\n            assert result2 == 2 : \"Second future did not return 2\";\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        } finally {\n            executor.shutdown();\n        }\n    }\n}", "golden_completion": "            Integer result1 = future1.get();\n            Integer result2 = future2.get();\n", "LLM_justification": "This example tests the model's ability to understand and correctly complete code related to multi-threading and concurrency patterns in Java. Specifically, it involves using an ExecutorService to manage a fixed thread pool and submitting Callable tasks that return a Future. The correct completion requires understanding how to retrieve the results of the tasks using Future.get() and validate them using assertions. This scenario demonstrates advanced usage of Java concurrency utilities and proper exception handling patterns, making it a robust test case.", "assertions": "", "DeepSeek-V3-0324": "            int result1 = future1.get();\n            int result2 = future2.get();"}
