{"id": "1", "testsource": "synthbench-low-context", "language": "python", "prefix": "import os\n\ndef read_file(file_path):\n    try:", "suffix": "\n    finally:\n        if os.path.exists(file_path):\n            os.remove(file_path)\n\n# Test cases\ntry:\n    with open('test.txt', 'w') as f:\n        f.write('Hello, world!')\n    content = read_file('test.txt')\n    assert content == 'Hello, world!'\nexcept Exception as e:\n    assert False, f'Exception occurred: {e}'", "golden_completion": "\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        return ''", "LLM_justification": "This test case demonstrates a common pattern of file handling in Python, which involves opening a file, reading its contents, and handling the potential FileNotFoundError. The completion should recognize the need to read the file content and handle exceptions properly. The scenario is designed to test the LLM's ability to identify and continue a standard file I/O pattern with minimal context.", "assertions": "assert read_file('non_existent.txt') == '', 'Should return empty string if file does not exist'\ntry:\n    with open('example.txt', 'w') as f:\n        f.write('Example content')\n    content = read_file('example.txt')\n    assert content == 'Example content', 'Content should match written content'\nexcept Exception as e:\n    assert False, f'Exception occurred: {e}'\nfinally:\n    if os.path.exists('example.txt'):\n        os.remove('example.txt')", "o1-mini": ""}
{"id": "2", "testsource": "synthbench-low-context", "language": "python", "prefix": "import functools\nimport time\n\ndef timer(func):\n    \"\"\"Print the runtime of the decorated function\"\"\"\n    @functools.wraps(func)\n    def wrapper_timer(*args, **kwargs):\n        start_time = time.perf_counter()\n        value = func(*args, **kwargs)\n        end_time = time.perf_counter()\n        run_time = end_time - start_time\n        print(f\"Finished {func.__name__!r} in {run_time:.4f} secs\")\n        return value\n    return wrapper_timer\n\n@timer\ndef waste_some_time(num_times):\n    for _ in range(num_times):\n        sum([i**2 for i in range(10000)])\n\n@timer\ndef do_something():\n    print(\"Doing something important...\")\n", "suffix": "do_something()\n\n@timer\ndef another_function():\n    time.sleep(1)\n    return \"Done\"\n\nresult = another_function()\nassert result == \"Done\"\n", "golden_completion": "waste_some_time(5)\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete the decorator pattern. The prefix provides a detailed setup of the timer decorator, which measures the execution time of the decorated functions. The suffix demonstrates the usage of the timer decorator on a different function and includes assertions to verify the correctness of another function. The completion must correctly use the established timer decorator pattern with minimal context provided.", "assertions": "waste_some_time(5)\n", "o1-mini": ""}
