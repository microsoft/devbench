
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import statistics
import logging

class DataAnalyzer:
    def __init__(self, data):
        self.data = data
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.DEBUG)
        handler = logging.StreamHandler()
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(handler)

    def analyze_mean(self):
        try:
            mean_value = statistics.mean(self.data)


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
            self.logger.info(f'Mean value calculated: {mean_value}')

SUFFIX CODE:
----------------------------------------
        except statistics.StatisticsError as e:
            self.logger.error(f'Error calculating mean: {e}')
            raise
        return mean_value

    def analyze_median(self):
        try:
            median_value = statistics.median(self.data)
            self.logger.info(f'Median value calculated: {median_value}')
        except statistics.StatisticsError as e:
            self.logger.error(f'Error calculating median: {e}')
            raise
        return median_value

# Example usage
analyzer = DataAnalyzer([1, 2, 3, 4, 5])
mean = analyzer.analyze_mean()
median = analyzer.analyze_median()

assert mean == 3
assert median == 3

JUSTIFICATION:
----------------------------------------
This test case demonstrates logging and error handling in a scientific computing context. The pattern involves calculating statistical measures (mean and median) while logging the results and handling potential exceptions. The golden completion requires the LLM to recognize the pattern of returning the calculated value after logging it, which is established in the analyze_mean method and should be mirrored in analyze_median. This pattern is realistic and common in data analysis tasks where logging and error handling are crucial.

ASSERTIONS:
----------------------------------------
assert mean == 3
assert median == 3

================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os

class DataValidator:
    def __init__(self, schema):
        self.schema = schema

    def validate(self, data):
        for key, value in self.schema.items():
            if key not in data:
                raise ValueError(f"Missing key: {key}")
            if not isinstance(data[key], value):
                raise TypeError(f"Incorrect type for key: {key}")

# Example usage
schema = {
    'name': str,
    'age': int,
    'email': str
}

validator = DataValidator(schema)
data = {
    'name': 'John Doe',
    'age': 30,
    'email': 'john.doe@example.com'
}

# Validate the data
try:

LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    validator.validate(data)

SUFFIX CODE:
----------------------------------------
    print("Data is valid")
except (ValueError, TypeError) as e:
    print(f"Data validation error: {e}")

# Assertions
assert validator.validate({'name': 'Jane Doe', 'age': 25, 'email': 'jane.doe@example.com'}) is None

# Cleanup
try:
    os.remove('tempfile.txt')
except FileNotFoundError:
    pass

JUSTIFICATION:
----------------------------------------
This test case effectively demonstrates error handling within the context of data validation. The pattern involves raising exceptions for missing keys or incorrect types, which is common in data validation scenarios. The completion involves calling the validate method within a try-except block, a standard practice for handling potential errors. The assertions verify that the validation works correctly for valid data and that exceptions are raised appropriately for invalid data.

ASSERTIONS:
----------------------------------------
assert validator.validate({'name': 'Jane Doe', 'age': 25, 'email': 'jane.doe@example.com'}) is None
try:
    validator.validate({'name': 'Jane Doe', 'age': 'twenty-five', 'email': 'jane.doe@example.com'})
except TypeError as e:
    assert str(e) == 'Incorrect type for key: age'
try:
    validator.validate({'name': 'Jane Doe', 'email': 'jane.doe@example.com'})
except ValueError as e:
    assert str(e) == 'Missing key: age'

================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import numpy as np

class DataProcessor:
    def __init__(self, data):
        self.data = data

    def normalize(self):
        mean = np.mean(self.data)
        std = np.std(self.data)
        self.data = (self.data - mean) / std

    def clean(self):
        self.data = self.data[~np.isnan(self.data)]

    def compute_statistics(self):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        median = np.median(self.data)
        variance = np.var(self.data)

SUFFIX CODE:
----------------------------------------
        return median, variance

data = np.array([1, 2, 3, np.nan, 4, 5, 6, np.nan, 7])
processor = DataProcessor(data)
processor.clean()
processor.normalize()
median, variance = processor.compute_statistics()

assert median == 0.0, 'Expected median to be 0.0 after normalization'
assert variance == 1.0, 'Expected variance to be 1.0 after normalization'
print('All assertions passed!')

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue patterns in object-oriented programming (OOP) within the context of data validation and normalization. The completion must adhere to the pattern established in the class methods, ensuring the calculations for median and variance follow the same style and use of numpy functions as the previous methods. Assertions verify the correctness of the statistical computations after cleaning and normalization.

ASSERTIONS:
----------------------------------------
assert isinstance(processor.data, np.ndarray), 'Data should be a numpy array'
assert not np.isnan(processor.data).any(), 'Data should not contain NaN values after cleaning'
assert np.isclose(np.mean(processor.data), 0.0), 'Data mean should be close to 0 after normalization'
assert np.isclose(np.std(processor.data), 1.0), 'Data std should be close to 1 after normalization'
assert median == 0.0, 'Expected median to be 0.0 after normalization'
assert variance == 1.0, 'Expected variance to be 1.0 after normalization'
================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class DataValidator:
    def __init__(self, schema):
        self.schema = schema

    def validate(self, data):
        """Validate data against the schema."""
        errors = []
        for field, field_type in self.schema.items():
            if field not in data:
                errors.append(f"Missing field: {field}")
            elif not isinstance(data[field], field_type):
                errors.append(f"Incorrect type for field: {field}")


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        for field in data:
            if field not in self.schema:
                errors.append(f"Unexpected field: {field}")

SUFFIX CODE:
----------------------------------------

        return errors

schema = {
    "name": str,
    "age": int,
    "email": str
}

validator = DataValidator(schema)
data = {
    "name": "John Doe",
    "age": 30,
    "email": "john.doe@example.com"
}

errors = validator.validate(data)
assert errors == [], f"Unexpected errors: {errors}"

invalid_data = {
    "name": "John Doe",
    "age": "thirty",
    "email": "john.doe@example.com"
}

errors = validator.validate(invalid_data)
assert "Incorrect type for field: age" in errors, f"Expected type error for age, got: {errors}"
assert len(errors) == 1, f"Expected one error, got: {len(errors)}"

invalid_data = {
    "age": 30,
    "email": "john.doe@example.com"
}

errors = validator.validate(invalid_data)
assert "Missing field: name" in errors, f"Expected missing field error for name, got: {errors}"
assert len(errors) == 1, f"Expected one error, got: {len(errors)}"


JUSTIFICATION:
----------------------------------------
This test case involves data validation, which is a common task in many applications. The pattern here is validating data against a predefined schema, checking for missing fields and incorrect types. The golden completion adds an additional validation step for empty string values, which is a realistic and practical extension of the pattern. This tests the LLM's ability to recognize and extend validation logic appropriately.

ASSERTIONS:
----------------------------------------
schema = {
    "name": str,
    "age": int,
    "email": str
}

validator = DataValidator(schema)
data = {
    "name": "",
    "age": 30,
    "email": "john.doe@example.com"
}

errors = validator.validate(data)
assert "Empty field: name" in errors, f"Expected empty field error for name, got: {errors}"
assert len(errors) == 1, f"Expected one error, got: {len(errors)}"

================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import numpy as np

class DataAnalyzer:
    def __init__(self, data):
        self.data = data

    def mean(self):
        return np.mean(self.data)

    def variance(self):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        return np.var(self.data)


SUFFIX CODE:
----------------------------------------
    def standard_deviation(self):
        return np.std(self.data)

# Creating a sample data set
sample_data = np.array([1, 2, 3, 4, 5])
analyzer = DataAnalyzer(sample_data)

# Assertions to verify the correctness of the implemented methods
assert analyzer.mean() == 3.0
assert analyzer.standard_deviation() == np.sqrt(2.0)
assert analyzer.variance() == 2.0

# No resources to clean up in this example


JUSTIFICATION:
----------------------------------------
This is a good test case for pattern matching in Python because it involves defining a class with methods that perform statistical computations on a dataset. The pattern of using numpy functions for statistical measures is clear and the completion requires recognizing the pattern of defining methods that wrap numpy functions. The assertions verify that the methods are correctly implemented and return expected values, ensuring both functional and semantic correctness.

ASSERTIONS:
----------------------------------------
assert analyzer.mean() == 3.0
assert analyzer.standard_deviation() == np.sqrt(2.0)
assert analyzer.variance() == 2.0

================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import logging
import os

class LogManager:
    def __init__(self, log_file):
        self.log_file = log_file
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.DEBUG)
        self.handler = logging.FileHandler(self.log_file)
        self.handler.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        self.handler.setFormatter(formatter)
        self.logger.addHandler(self.handler)

    def log_info(self, message):
        self.logger.info(message)

    def log_error(self, message):
        self.logger.error(message)

    def log_warning(self, message):
        self.logger.warning(message)



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    def close(self):
        self.handler.close()
        self.logger.removeHandler(self.handler)


SUFFIX CODE:
----------------------------------------

# Creating an instance of LogManager
log_manager = LogManager('test_log.log')
log_manager.log_info('This is an info message')
log_manager.log_error('This is an error message')
log_manager.log_warning('This is a warning message')

# Verify log file content
with open('test_log.log', 'r') as f:
    logs = f.read()

assert 'This is an info message' in logs
assert 'This is an error message' in logs
assert 'This is a warning message' in logs

# Close the log manager before removing the file
log_manager.close()

# Clean up
os.remove('test_log.log')


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and extend an established pattern of logging methods within a class. The class 'LogManager' includes methods for logging info, error, and warning messages. The completion requires adding a method for logging debug messages, following the same pattern. This is a realistic scenario in system operations where logging different levels of messages is common. The assertions verify that messages are correctly logged, ensuring functional correctness.

ASSERTIONS:
----------------------------------------
log_manager = LogManager('test_log.log')
log_manager.log_debug('This is a debug message')

with open('test_log.log', 'r') as f:
    logs = f.read()

assert 'This is a debug message' in logs

# Close the log manager before removing the file
log_manager.close()

# Clean up
os.remove('test_log.log')

================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import requests

class APIClient:
    def __init__(self, base_url):
        self.base_url = base_url

    def get(self, endpoint):
        try:
            response = requests.get(f"{self.base_url}/{endpoint}")
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            print(f"GET request failed: {e}")
            return None

    def post(self, endpoint, data):
        try:


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
            response = requests.post(f"{self.base_url}/{endpoint}", json=data)

SUFFIX CODE:
----------------------------------------
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            print(f"POST request failed: {e}")
            return None

client = APIClient("https://jsonplaceholder.typicode.com")

# Test GET request
response = client.get("posts/1")
assert response is not None, "GET request should return a response"

# Test POST request
response = client.post("posts", {"title": "foo", "body": "bar", "userId": 1})
assert response is not None, "POST request should return a response"


JUSTIFICATION:
----------------------------------------
This test case is a good example for an LLM because it involves recognizing and completing a pattern in a common context: making HTTP requests in a client class. The established pattern in the `get` method involves making a request, checking the response status, and handling exceptions. The completion for the `post` method should follow the same pattern, ensuring consistency and proper error handling. The assertions test that the methods return valid responses, verifying both functionality and pattern adherence.

ASSERTIONS:
----------------------------------------
response = client.post("users", {"name": "Test User", "email": "test@example.com"})
assert response is not None, "POST request should return a response"

response = client.get("users/1")
assert response is not None, "GET request should return a response"
================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import statistics

class DataAnalyzer:
    def __init__(self, data):
        self.data = data

    def mean(self):
        return statistics.mean(self.data)

    def median(self):
        return statistics.median(self.data)

    def variance(self):
        return statistics.variance(self.data)

    # Add a method to compute the standard deviation
    def stdev(self):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        return statistics.stdev(self.data)

SUFFIX CODE:
----------------------------------------


# Example usage
analyzer = DataAnalyzer([2, 4, 4, 4, 5, 5, 7, 9])

assert analyzer.mean() == 5
assert analyzer.median() == 4.5
assert round(analyzer.variance(), 2) == 4.57
assert round(analyzer.stdev(), 2) == 2.14

print("All assertions passed.")

JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in OOP patterns within the context of scientific computing. The pattern established is the use of the statistics module to perform various statistical calculations. The completion should demonstrate an understanding of how to continue this pattern by adding a method to compute the standard deviation using the statistics module. This not only tests the LLM's ability to recognize and complete the pattern but also ensures that it adheres to best practices by leveraging existing library functions. The assertions verify the correctness of the implementation by comparing computed values with expected results.

ASSERTIONS:
----------------------------------------
assert analyzer.mean() == 5
assert analyzer.median() == 4.5
assert round(analyzer.variance(), 2) == 4.57
assert round(analyzer.stdev(), 2) == 2.14
================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import logging

class FileHandler:
    def __init__(self, filename):
        self.filename = filename
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, 'w')
        logging.info(f"Opened file {self.filename}")
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if self.file:
            self.file.close()
            logging.info(f"Closed file {self.filename}")

# Example usage of the context manager
with FileHandler('example.txt') as f:
    f.write('Hello, world!')

class DatabaseConnection:
    def __init__(self, dsn):
        self.dsn = dsn
        self.connection = None

    def __enter__(self):

LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        logging.info(f"Connecting to database {self.dsn}")
        self.connection = True  # Simulating a database connection
        return self.connection

SUFFIX CODE:
----------------------------------------


    def __exit__(self, exc_type, exc_value, traceback):
        if self.connection:
            logging.info(f"Disconnecting from database {self.dsn}")

# Example usage of the context manager
with DatabaseConnection('my_database') as conn:
    pass

# Assertions to verify both pattern adherence and functionality
assert os.path.exists('example.txt')



JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue the pattern of implementing context managers in Python. The prompt provides a complete context manager (FileHandler) for handling file operations and starts another context manager (DatabaseConnection) for database operations. The completion involves correctly implementing the __enter__ method to match the pattern established by the FileHandler class. The example also includes proper logging, resource cleanup, and assertions to ensure the context manager's functionality and pattern adherence.

ASSERTIONS:
----------------------------------------
assert os.path.exists('example.txt')

# Simulate the context manager's usage and check for expected log messages
with DatabaseConnection('my_database') as conn:
    assert conn == 'mock_connection'

# Cleanup resources
os.remove('example.txt')
================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import sqlite3

class DatabaseHandler:
    def __init__(self, db_name):
        self.db_name = db_name

    def __enter__(self):
        self.conn = sqlite3.connect(self.db_name)
        self.cursor = self.conn.cursor()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            self.conn.rollback()
        else:
            self.conn.commit()
        self.conn.close()

# Using the context manager to insert data
with DatabaseHandler('test.db') as db:
    db.cursor.execute('''CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)''')
    db.cursor.execute('''INSERT INTO users (name) VALUES ('Alice')''')
    db.cursor.execute('''INSERT INTO users (name) VALUES ('Bob')''')

# Verifying data insertion

LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
with DatabaseHandler('test.db') as db:
    db.cursor.execute('''SELECT name FROM users WHERE id = 1''')
    result = db.cursor.fetchone()

SUFFIX CODE:
----------------------------------------
    name = result[0]

import os
os.remove('test.db')

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete the pattern of using a context manager for database operations. The context manager pattern is established in the prompt and followed in the golden completion. The completion requires the LLM to correctly use the context manager to query the database and validate the results. The assertions test the functional correctness of data insertion and retrieval.

ASSERTIONS:
----------------------------------------

assert name == 'Alice'
================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import logging

class NetworkMonitor:
    def __init__(self, log_file):
        self.log_file = log_file
        self.setup_logger()

    def setup_logger(self):
        self.logger = logging.getLogger('network_monitor')
        self.logger.setLevel(logging.INFO)
        handler = logging.FileHandler(self.log_file)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))
        self.logger.addHandler(handler)

    def log_event(self, event):
        self.logger.info(event)

    def monitor(self, events):
        for event in events:


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
            if 'error' in event.lower():
                self.log_event(f"Error detected: {event}")
            else:
                self.log_event(f"Event: {event}")

SUFFIX CODE:
----------------------------------------
            if 'error' in event.lower():
                self.log_event(f"Error detected: {event}")
            else:
                self.log_event(f"Event: {event}")

    def close(self):
        # Close all handlers
        handlers = self.logger.handlers[:]
        for handler in handlers:
            handler.close()
            self.logger.removeHandler(handler)

# Example usage
monitor = NetworkMonitor('network.log')
monitor.monitor(['Connection established', 'Error: Connection lost', 'Data received'])

# Assertions
with open('network.log', 'r') as log_file:
    log_contents = log_file.read()
    assert 'Connection established' in log_contents
    assert 'Error detected: Error: Connection lost' in log_contents
    assert 'Data received' in log_contents

# Close the logger before removing the file
monitor.close()

# Clean up
import os
os.remove('network.log')


JUSTIFICATION:
----------------------------------------
This is a good test case as it involves a common pattern in system operations, specifically logging and monitoring network events. The code sets up a logger and processes events, categorizing them based on their content. The completion requires recognizing the pattern of logging different types of events and continuing it in a meaningful way. The assertions check that the log file contains the expected entries, validating both functionality and pattern adherence.

ASSERTIONS:
----------------------------------------
monitor = NetworkMonitor('network.log')
monitor.monitor(['Connection established', 'Error: Connection lost', 'Data received'])

with open('network.log', 'r') as log_file:
    log_contents = log_file.read()
    assert 'Connection event: Connection established' in log_contents
    assert 'Error detected: Error: Connection lost' in log_contents
    assert 'Event: Data received' in log_contents

# Close the logger before removing the file
monitor.close()

import os
os.remove('network.log')

================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import matplotlib.pyplot as plt
import numpy as np

class DataVisualizer:
    def __init__(self, data):
        self.data = data

    def plot_histogram(self):
        plt.hist(self.data)
        plt.title('Histogram')
        plt.xlabel('Value')
        plt.ylabel('Frequency')
        plt.show()

    def plot_scatter(self, x, y):
        plt.scatter(x, y)
        plt.title('Scatter Plot')
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        plt.show()

    def plot_line(self, x, y):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        plt.plot(x, y)

SUFFIX CODE:
----------------------------------------
        plt.title('Line Plot')
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        plt.show()

# Creating some sample data
data = np.random.randn(100)
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Creating an instance of DataVisualizer and plotting
visualizer = DataVisualizer(data)
visualizer.plot_histogram()
visualizer.plot_scatter(x, y)
visualizer.plot_line(x, y)


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and continue a pattern in object-oriented programming for plotting data using Matplotlib. The pattern involves creating methods within a class to plot different types of graphs and consistently using Matplotlib functions to do so. The golden completion demonstrates the correct continuation of this pattern by plotting a line graph with plt.plot(), matching the established pattern in the prefix and suffix.

ASSERTIONS:
----------------------------------------
assert isinstance(visualizer, DataVisualizer)
assert hasattr(visualizer, 'plot_histogram')
assert hasattr(visualizer, 'plot_scatter')
assert hasattr(visualizer, 'plot_line')
assert callable(visualizer.plot_histogram)
assert callable(visualizer.plot_scatter)
assert callable(visualizer.plot_line)
visualizer.plot_line(x, y) # This should generate a line plot without errors

================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class DataValidator:
    def __init__(self, schema):
        self.schema = schema

    def validate(self, data):
        errors = []
        for key, value in data.items():
            if key not in self.schema:
                errors.append(f"Unexpected key: {key}")
            elif not isinstance(value, self.schema[key]):
                errors.append(f"Invalid type for key: {key}")


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        for key in self.schema:
            if key not in data:
                errors.append(f"Missing required key: {key}")

SUFFIX CODE:
----------------------------------------

        return errors

data = {"name": "John", "age": 30, "email": "john.doe@example.com"}
schema = {"name": str, "age": int}

validator = DataValidator(schema)
errors = validator.validate(data)

assert errors == ["Unexpected key: email"]

# Cleanup resources if needed
# No external resources to clean up in this example

JUSTIFICATION:
----------------------------------------
This test case involves data validation, a common scenario in data processing and API design. The prompt sets up a pattern for validating data against a schema, checking for unexpected keys and invalid types. The golden completion extends this pattern by adding a check for missing keys, which is a natural continuation of the validation logic. The assertions verify that the validator correctly identifies an unexpected key in the data. This scenario tests the LLM's ability to recognize and complete a data validation pattern while maintaining proper structure and functionality.

ASSERTIONS:
----------------------------------------

assert len(errors) == 1
================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import statistics

class DataAnalysis:
    def __init__(self, data):
        self.data = data

    def mean(self):
        return statistics.mean(self.data)

    def median(self):
        return statistics.median(self.data)

    def mode(self):
        return statistics.mode(self.data)

    def variance(self):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        return statistics.variance(self.data)

SUFFIX CODE:
----------------------------------------


# Test cases
analysis = DataAnalysis([1, 2, 3, 4, 4, 5, 5, 5])
assert analysis.mean() == 3.625
assert analysis.median() == 4
assert analysis.mode() == 5


JUSTIFICATION:
----------------------------------------
This test case demonstrates a common pattern in scientific computing where statistical methods are implemented in a class to analyze data. The pattern of implementing statistical methods is established in the prefix with mean, median, and mode methods. The expected pattern continuation is to implement the variance method similarly. The provided assertions test the correctness of the methods and ensure the pattern is followed correctly. The suffix includes necessary cleanup code after the assertions.

ASSERTIONS:
----------------------------------------
assert analysis.mean() == 3.625
assert analysis.median() == 4
assert analysis.mode() == 5
assert analysis.variance() == 2.267857142857143

================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import numpy as np

class MatrixOperations:
    def __init__(self, matrix):
        self.matrix = matrix

    def transpose(self):
        return np.transpose(self.matrix)

    def invert(self):
        return np.linalg.inv(self.matrix)

    # Add a method to calculate the determinant of the matrix
    def determinant(self):

LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        return np.linalg.det(self.matrix)

SUFFIX CODE:
----------------------------------------


# Testing the MatrixOperations class
matrix = np.array([[1, 2], [3, 4]])
operations = MatrixOperations(matrix)

# Transpose test
transpose_result = operations.transpose()
assert np.array_equal(transpose_result, np.array([[1, 3], [2, 4]])), 'Transpose test failed'

# Inversion test
invert_result = operations.invert()
assert np.allclose(invert_result, np.array([[-2. ,  1. ], [ 1.5, -0.5]])), 'Inversion test failed'

# Determinant test
try:
    determinant_result = operations.determinant()
    assert np.isclose(determinant_result, -2.0), 'Determinant test failed'
except np.linalg.LinAlgError:
    print("Determinant test failed: Matrix is not invertible")

JUSTIFICATION:
----------------------------------------
This test case is a good example of OOP patterns in the context of scientific computing. The MatrixOperations class encapsulates common matrix operations like transposition, inversion, and determinant calculation. This scenario tests the LLM's ability to recognize the pattern of adding a new method to an existing class and implementing it using numpy functions. The completion must adhere to the pattern established by the transpose and invert methods. The assertions check the correctness of the transpose, invert, and determinant methods, ensuring the implementation follows the expected pattern and produces correct results. Cleanup is handled after the assertions to maintain resource integrity.

ASSERTIONS:
----------------------------------------
assert np.array_equal(transpose_result, np.array([[1, 3], [2, 4]])), 'Transpose test failed'
assert np.allclose(invert_result, np.array([[-2. ,  1. ], [ 1.5, -0.5]])), 'Inversion test failed'
assert np.isclose(determinant_result, -2.0), 'Determinant test failed'
================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import re

class DataValidator:
    def __init__(self, schema):
        self.schema = schema

    def validate(self, data):
        errors = []
        for field, rules in self.schema.items():
            value = data.get(field)
            if 'required' in rules and value is None:
                errors.append(f"{field} is required.")
            if 'type' in rules and value is not None and not isinstance(value, rules['type']):
                errors.append(f"{field} must be of type {rules['type'].__name__}.")
            if 'regex' in rules and value is not None and not re.match(rules['regex'], value):
                errors.append(f"{field} does not match the required pattern.")


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
            if 'min_length' in rules and value is not None and len(value) < rules['min_length']:
                errors.append(f"{field} must be at least {rules['min_length']} characters long.")
            if 'max_length' in rules and value is not None and len(value) > rules['max_length']:
                errors.append(f"{field} must be at most {rules['max_length']} characters long.")

SUFFIX CODE:
----------------------------------------
        return errors

schema = {
    'username': {'required': True, 'type': str, 'regex': r'^[a-zA-Z0-9_]{3,30}$'},
    'age': {'required': True, 'type': int},
    'email': {'required': False, 'type': str, 'regex': r'^[\w\.-]+@[\w\.-]+\.\w+$'}
}

validator = DataValidator(schema)

# Example data to validate
valid_data = {'username': 'test_user', 'age': 25, 'email': 'test@example.com'}
invalid_data = {'username': 'tu', 'age': 'twenty', 'email': 'invalid-email'}

# Assertions to verify the functionality
assert validator.validate(valid_data) == [], "Valid data should have no errors"
assert 'username is required.' in validator.validate({'age': 25}), "Missing username should be flagged"
assert 'age must be of type int.' in validator.validate({'username': 'user', 'age': 'twenty'}), "Invalid age type should be flagged"
assert 'email does not match the required pattern.' in validator.validate({'username': 'user', 'age': 25, 'email': 'invalid-email'}), "Invalid email should be flagged"


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and complete a pattern related to data validation. The pattern involves checking various conditions in a schema-driven validation class. The completion involves adding support for custom validation rules, which is a common pattern in data validation frameworks. The assertions ensure that the validator correctly identifies valid and invalid data based on the schema, including the new custom validation rule.

ASSERTIONS:
----------------------------------------
assert validator.validate({'username': 'valid_user', 'age': 30, 'email': 'valid@example.com'}) == [], "All fields valid"

schema_with_custom = {
    'username': {
        'required': True, 
        'type': str, 
        'regex': r'^[a-zA-Z0-9_]{3,30}$',
        'custom': lambda x: x == 'valid_user'  # Custom validation rule
    },
    'age': {'required': True, 'type': int},
    'email': {'required': False, 'type': str, 'regex': r'^[\w\.-]+@[\w\.-]+\.\w+$'}
}

validator_with_custom = DataValidator(schema_with_custom)

assert 'username failed custom validation.' in validator_with_custom.validate(
    {'username': 'invalid_user', 'age': 30, 'email': 'valid@example.com'}
), "Custom validation should be flagged"
================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import re

class DataValidator:
    def __init__(self, schema):
        self.schema = schema

    def validate(self, data):
        errors = []
        for field, constraints in self.schema.items():
            value = data.get(field)
            if 'type' in constraints and not isinstance(value, constraints['type']):
                errors.append(f"Field '{field}' should be of type {constraints['type'].__name__}")
            if 'regex' in constraints and not re.match(constraints['regex'], value):
                errors.append(f"Field '{field}' does not match pattern {constraints['regex']}")


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
            if 'min' in constraints and value < constraints['min']:
                errors.append(f"Field '{field}' should be at least {constraints['min']}")
            if 'max' in constraints and value > constraints['max']:
                errors.append(f"Field '{field}' should be at most {constraints['max']}")

SUFFIX CODE:
----------------------------------------
        if errors:
            raise ValueError(f"Validation errors: {', '.join(errors)}")
        return True

schema = {
    'name': {'type': str, 'regex': r'^[A-Za-z ]+$'},
    'age': {'type': int, 'min': 0, 'max': 120}
}
data = {'name': 'John Doe', 'age': 30}
validator = DataValidator(schema)
assert validator.validate(data) == True

invalid_data = {'name': 'John123', 'age': 150}
try:
    validator.validate(invalid_data)
except ValueError as e:
    assert str(e) == "Validation errors: Field 'name' does not match pattern ^[A-Za-z ]+$, Field 'age' should be at most 120"
finally:
    print('Validation test completed')

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern in the context of data validation within an OOP structure. The prompt sets up a class for validating data against a schema, and the completion requires the LLM to correctly add validation for minimum and maximum constraints. The pattern involves iterating over schema constraints and checking each one, which is a common real-world task in data validation. The assertions verify that the implementation correctly handles valid and invalid data cases, ensuring that both the pattern and functionality are correct.

ASSERTIONS:
----------------------------------------
assert validator.validate({'name': 'Alice', 'age': 25}) == True
try:
    validator.validate({'name': 'Alice', 'age': -5})
except ValueError as e:
    assert str(e) == "Validation errors: Field 'age' should be at least 0"
try:
    validator.validate({'name': 'Alice', 'age': 130})
except ValueError as e:
    assert str(e) == "Validation errors: Field 'age' should be at most 120"

================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class DataValidator:
    def __init__(self, schema):
        self.schema = schema

    def validate(self, data):
        errors = []
        for field, rules in self.schema.items():
            if field not in data:
                errors.append(f'Missing field: {field}')
            else:
                value = data[field]
                for rule, expected in rules.items():
                    if rule == 'type' and not isinstance(value, expected):
                        errors.append(f'Field {field} should be of type {expected.__name__}')
                    elif rule == 'min_length' and len(value) < expected:
                        errors.append(f'Field {field} should be at least {expected} characters long')


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
                    elif rule == 'max_length' and len(value) > expected:
                        errors.append(f'Field {field} should be at most {expected} characters long')
                    elif rule == 'min_value' and value < expected:
                        errors.append(f'Field {field} should be at least {expected}')
                    elif rule == 'max_value' and value > expected:
                        errors.append(f'Field {field} should be at most {expected}')

SUFFIX CODE:
----------------------------------------
        return errors

schema = {
    'name': {'type': str, 'min_length': 3},
    'age': {'type': int}
}

validator = DataValidator(schema)
data_valid = {'name': 'Alice', 'age': 30}
data_invalid = {'name': 'Al', 'age': 'thirty'}

errors_valid = validator.validate(data_valid)
errors_invalid = validator.validate(data_invalid)

assert errors_valid == []
assert errors_invalid == ['Field name should be at least 3 characters long', 'Field age should be of type int']

print('All assertions passed!')

JUSTIFICATION:
----------------------------------------
This example tests the ability to recognize and continue a pattern within a data validation context. The pattern involves iterating over schema rules and applying them to the data fields. The golden completion correctly continues this pattern by adding a check for a new rule, 'max_length', which is consistent with the existing 'type' and 'min_length' rules. The assertions ensure that the validation logic works as expected, verifying both the pattern and functionality.

ASSERTIONS:
----------------------------------------
schema = {
    'name': {'type': str, 'min_length': 3, 'max_length': 10},
    'age': {'type': int}
}

validator = DataValidator(schema)
data_valid = {'name': 'Alice', 'age': 30}
data_invalid_length = {'name': 'Aliceeeeeeee', 'age': 30}
data_invalid_type = {'name': 'Alice', 'age': 'thirty'}

errors_valid = validator.validate(data_valid)
errors_invalid_length = validator.validate(data_invalid_length)
errors_invalid_type = validator.validate(data_invalid_type)

assert errors_valid == []
assert errors_invalid_length == ['Field name should be at most 10 characters long']
assert errors_invalid_type == ['Field age should be of type int']
================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import requests

class APIClient:
    def __init__(self, base_url):
        self.base_url = base_url

    def get_data(self, endpoint):
        url = f"{self.base_url}/{endpoint}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()

    def post_data(self, endpoint, data):
        url = f"{self.base_url}/{endpoint}"
        response = requests.post(url, json=data)
        response.raise_for_status()
        return response.json()

    def delete_data(self, endpoint):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        url = f"{self.base_url}/{endpoint}"

SUFFIX CODE:
----------------------------------------
        response = requests.delete(url)
        response.raise_for_status()
        return response.json()

client = APIClient("https://jsonplaceholder.typicode.com")

response = client.get_data("posts/1")
print(f"GET response: {response}")
assert "id" in response
assert "title" in response

# Test the post_data method
data = {"title": "foo", "body": "bar", "userId": 1}
response = client.post_data("posts", data)
print(f"POST response: {response}")
assert response["title"] == "foo"
assert "id" in response

# Test the delete_data method
response = client.delete_data("posts/1")
print(f"DELETE response: {response}")
assert isinstance(response, dict)


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern involving API endpoint construction in an OOP context. The base URL is combined with the endpoint to form the full URL for the request, and the LLM needs to apply this pattern consistently across different HTTP methods. The completion should demonstrate understanding of this pattern by correctly forming the URL for the DELETE request, similar to GET and POST methods. The assertions verify that the pattern is applied correctly and that the methods function as expected.

ASSERTIONS:
----------------------------------------
assert client.base_url == "https://jsonplaceholder.typicode.com"
assert "name" in client.get_data("users/1")
assert "body" in client.get_data("comments/1")
================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import requests
from requests.exceptions import HTTPError

def fetch_data(url):
    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        return data

SUFFIX CODE:
----------------------------------------
    except HTTPError as http_err:
        print(f'HTTP error occurred: {http_err}')
    except Exception as err:
        print(f'Other error occurred: {err}')
    else:
        return data

# Test cases
url = 'https://jsonplaceholder.typicode.com/todos/1'
data = fetch_data(url)
assert isinstance(data, dict), 'Expected data to be a dictionary'
assert 'userId' in data, 'Expected key userId in data'
assert 'title' in data, 'Expected key title in data'
assert data['id'] == 1, 'Expected id to be 1'

# Cleanup
print('Finished testing')

JUSTIFICATION:
----------------------------------------
This test case checks the LLM's ability to recognize and complete a common error handling pattern in network protocols. The provided prompt sets up a try block that handles potential errors from a network request. The golden completion adds an additional specific exception handling for JSON parsing errors, which is a realistic enhancement when fetching and processing data from an API. The test verifies functional correctness by making an actual request and checking the structure of the returned data. This scenario is practical and covers error handling, API interaction, and proper use of assertions.

ASSERTIONS:
----------------------------------------
url = 'https://jsonplaceholder.typicode.com/todos/1'
data = fetch_data(url)
assert isinstance(data, dict), 'Expected data to be a dictionary'
assert 'userId' in data, 'Expected key userId in data'
assert 'title' in data, 'Expected key title in data'
assert data['id'] == 1, 'Expected id to be 1'

================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import requests
class APIClient:
    def __init__(self, base_url):
        self.base_url = base_url

    def get(self, endpoint):
        response = requests.get(f"{self.base_url}/{endpoint}")
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()

class AnalyticsClient(APIClient):
    def __init__(self, base_url, api_key=None):
        super().__init__(base_url)
        self.api_key = api_key

    def get_metrics(self, metric_type):
        response = requests.get(f"{self.base_url}/posts/{metric_type}")
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()

    def get_report(self, report_id):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        response = requests.get(f"{self.base_url}/reports/{report_id}")
        if response.status_code == 200:
            return response.json()
        else:
            response.raise_for_status()

SUFFIX CODE:
----------------------------------------


# Example usage:
client = AnalyticsClient("https://jsonplaceholder.typicode.com")

try:
    metrics = client.get_metrics("1")
    print(f"Metrics result: {metrics}")

    report = client.get_report("1")
    print(f"Report result: {report}")

    users = client.get("users/1")
    print(f"User result: {users}")

except requests.exceptions.RequestException as e:
    print(f"API request failed: {e}")

# Assertions:
import unittest.mock as mock

with mock.patch('requests.get') as mock_get:
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.json.return_value = {'data': 'mocked'}
    mock_get.return_value = mock_response

    assert client.get_metrics("daily") == {'data': 'mocked'}
    assert client.get_report("12345") == {'data': 'mocked'}



JUSTIFICATION:
----------------------------------------
This test case is a realistic example of API client patterns for an analytics context. The pattern involves making authenticated HTTP requests and handling responses based on status codes. The `golden_completion` follows the established pattern of making a request with headers, checking the status code, and returning JSON data or raising an error. The assertions verify that the pattern is correctly implemented and handles expected responses.

ASSERTIONS:
----------------------------------------
try:
    post = client.get_metrics("1")
    assert "title" in post
    assert "body" in post
    assert "userId" in post

    comment = client.get_report("1")
    assert "name" in comment
    assert "email" in comment
    assert "body" in comment

    print("All tests passed!")
except Exception as e:
    print(f"Test failed: {e}")
================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import socket
import unittest.mock as mock

class NetworkClient:
    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port
        self.sock = None

    def connect(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.host, self.port))

    def send_message(self, message: str):
        if not self.sock:
            raise ConnectionError('Client is not connected')
        self.sock.sendall(message.encode('utf-8'))

    def receive_message(self):
        if not self.sock:
            raise ConnectionError('Client is not connected')


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        data = self.sock.recv(1024)

SUFFIX CODE:
----------------------------------------
        return data.decode('utf-8')

    def close(self):
        if self.sock:
            self.sock.close()
            self.sock = None



JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in the context of network protocols (APIs, messaging, sync/async) and error handling. The task is to complete the `receive_message` method by correctly implementing the pattern of receiving data from a socket connection. The pattern involves checking the connection, receiving data, and handling it appropriately. The assertions ensure that the client can connect, send, and receive messages correctly, adhering to the established pattern of socket communication.

ASSERTIONS:
----------------------------------------
with mock.patch('socket.socket') as mock_socket:
    # Configure the mock socket
    mock_socket_instance = mock.Mock()
    mock_socket.return_value = mock_socket_instance

    # Set up the receive method to return a predefined response
    mock_socket_instance.recv.return_value = b'Hello, Server!'

    client = NetworkClient('localhost', 8080)
    client.connect()
    client.send_message('Hello, Server!')

    response = client.receive_message()
    assert isinstance(response, str)
    assert isinstance(response, str)
    client.close()

    # Verify the expected methods were called
    mock_socket_instance.connect.assert_called_once_with(('localhost', 8080))
    mock_socket_instance.sendall.assert_called_once()
    mock_socket_instance.recv.assert_called_once_with(4096)
    mock_socket_instance.close.assert_called_once()


================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import json

class ConfigLoader:
    def __init__(self, config_path):
        self.config_path = config_path
        self.config = None

    def load_config(self):
        try:
            with open(self.config_path, 'r') as file:
                self.config = json.load(file)
            return True
        except FileNotFoundError:
            print('Config file not found.')
            self.config = {}
            return False
        except json.JSONDecodeError:
            print('Error decoding JSON from config file.')
            self.config = {}
            return False

    def get_config_value(self, key):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        if self.config is None:
            self.load_config()

SUFFIX CODE:
----------------------------------------
        return self.config.get(key, None)
test_config = {
    'some_key': None,
    'some_other_key': None
}

with open('config.json', 'w') as file:
    json.dump(test_config, file)

config_loader = ConfigLoader('config.json')
config_loader.load_config()

# Assertions to verify the functionality
assert config_loader.get_config_value('some_key') == None
assert config_loader.get_config_value('some_other_key') == None

# Cleanup
if os.path.exists('config.json'):
    os.remove('config.json')

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and complete an error handling pattern in an object-oriented context. The scenario involves reading a JSON configuration file, handling potential errors, and ensuring that the configuration is loaded before accessing its values. The completion requires adding a check to raise an error if the configuration is not loaded, demonstrating understanding of error handling and proper flow control.

ASSERTIONS:
----------------------------------------
unloaded_config = ConfigLoader('nonexistent.json')
try:
    unloaded_config.get_config_value('missing_key')
except ValueError as e:
    assert str(e) == 'Config not loaded.'
================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import json
import os

class ConfigManager:
    def __init__(self, config_path):
        self.config_path = config_path
        self.config = {}

    def load_config(self):
        if not os.path.exists(self.config_path):
            raise FileNotFoundError(f"Config file not found: {self.config_path}")
        with open(self.config_path, 'r') as config_file:
            self.config = json.load(config_file)

    def save_config(self):
        with open(self.config_path, 'w') as config_file:
            json.dump(self.config, config_file)

    def get(self, key, default=None):
        return self.config.get(key, default)

    def set(self, key, value):
        self.config[key] = value

    def delete(self, key):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        if key in self.config:
            del self.config[key]

SUFFIX CODE:
----------------------------------------


# Example usage:
config_path = 'config.json'
config_manager = ConfigManager(config_path)
config_manager.set('username', 'test_user')
assert config_manager.get('username') == 'test_user'
config_manager.delete('username')
assert config_manager.get('username') is None

# Cleanup
if os.path.exists(config_path):
    os.remove(config_path)


JUSTIFICATION:
----------------------------------------
This example tests the ability to recognize and complete a pattern in a class that manages configuration data. The pattern involves typical CRUD operations (Create, Read, Update, Delete) on a configuration dictionary. The completion should appropriately implement the deletion method using a common Python idiom. The suffix code provides example usage and cleanup, ensuring that the configuration file is properly removed after the test. This scenario is practical and tests both functionality and adherence to common Python patterns.

ASSERTIONS:
----------------------------------------
config_path = 'config.json'
config_manager = ConfigManager(config_path)
config_manager.set('username', 'test_user')
assert config_manager.get('username') == 'test_user'
config_manager.delete('username')
assert config_manager.get('username') is None

# Cleanup
if os.path.exists(config_path):
    os.remove(config_path)

================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import functools

class AuthenticationError(Exception):
    pass

class Authenticator:
    def __init__(self, valid_tokens):
        self.valid_tokens = valid_tokens

    def validate_token(self, token):
        if token not in self.valid_tokens:
            raise AuthenticationError("Invalid token")

    def require_authentication(self, func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            token = kwargs.get('token')
            self.validate_token(token)
            return func(*args, **kwargs)
        return wrapper

# Usage example of the Authenticator with a secured function
valid_tokens = {'token123', 'token456'}
authenticator = Authenticator(valid_tokens)

@authenticator.require_authentication


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
def protected_function(data, token=None):
    return data

SUFFIX CODE:
----------------------------------------
def unprotected_function(data):
    return f"Unprotected data: {data}"

# Test cases
try:
    assert protected_function(data="Sensitive Data", token='token123') == "Sensitive Data"
    assert protected_function(data="More Sensitive Data", token='token456') == "More Sensitive Data"
    try:
        protected_function(data="No Token Data")
    except AuthenticationError:
        pass
    else:
        assert False, "Expected AuthenticationError"
    try:
        protected_function(data="Invalid Token Data", token='invalid')
    except AuthenticationError:
        pass
    else:
        assert False, "Expected AuthenticationError"
finally:
    # Cleanup code if any
    pass


JUSTIFICATION:
----------------------------------------
This test case evaluates an LLM's ability to recognize and continue a pattern involving the use of decorators for authentication in a security context. The Authenticator class and its require_authentication decorator establish a pattern where functions are wrapped to ensure valid tokens before execution. The completion should show the correct continuation of this pattern with a protected function that uses the decorator. The assertions verify that authentication works correctly and handles both valid and invalid tokens. This is a realistic and practical scenario for developers working with security and authentication in Python.

ASSERTIONS:
----------------------------------------
assert protected_function(data="Sensitive Data", token='token123') == "Sensitive Data"
assert protected_function(data="More Sensitive Data", token='token456') == "More Sensitive Data"
try:
    protected_function(data="No Token Data")
except AuthenticationError:
    pass
else:
    assert False, "Expected AuthenticationError"
try:
    protected_function(data="Invalid Token Data", token='invalid')
except AuthenticationError:
    pass
else:
    assert False, "Expected AuthenticationError"
================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import functools
import time

class TimeLogger:
    def __init__(self, func):
        self.func = func
        functools.update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        start_time = time.time()
        try:
            result = self.func(*args, **kwargs)
        finally:
            end_time = time.time()
            print(f"{self.func.__name__} took {end_time - start_time:.4f} seconds")
        return result

@TimeLogger


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
def add(a, b):

SUFFIX CODE:
----------------------------------------
def add(a, b):
    return a + b

@TimeLogger
def multiply(a, b):
    return a * b

# Test the decorated functions
assert add(2, 3) == 5
assert multiply(2, 3) == 6
assert add(10, 20) == 30
assert multiply(5, 4) == 20

# Ensure the decorator prints the time
import io
import sys
captured_output = io.StringIO()
sys.stdout = captured_output
add(2, 3)
sys.stdout = sys.__stdout__
assert 'add took' in captured_output.getvalue()

# Clean up
captured_output.close()


JUSTIFICATION:
----------------------------------------
This test case is a good example of decorators/metaprogramming in the context of tool automation (timing function calls). It tests the LLM's ability to recognize and continue a pattern of using a custom decorator to log the execution time of functions. The prompt establishes the pattern with the TimeLogger decorator, and the golden completion requires the LLM to apply this pattern to a new function. Assertions verify that the decorator works as intended, ensuring both pattern adherence and functionality.

ASSERTIONS:
----------------------------------------
assert subtract(5, 3) == 2
assert subtract(10, 5) == 5

# Ensure the decorator prints the time
import io
import sys
captured_output = io.StringIO()
sys.stdout = captured_output
subtract(5, 3)
sys.stdout = sys.__stdout__
assert 'subtract took' in captured_output.getvalue()

# Clean up
captured_output.close()

================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import requests

class APIClient:
    def __init__(self, base_url):
        self.base_url = base_url

    def get_resource(self, resource_id):
        url = f"{self.base_url}/{resource_id}"
        try:
            response = requests.get(url)
            response.raise_for_status()


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
            return response.json()

SUFFIX CODE:
----------------------------------------
            return response.json()
        except requests.exceptions.HTTPError as http_err:
            print(f"HTTP error occurred: {http_err}")
        except Exception as err:
            print(f"Other error occurred: {err}")
        return None

client = APIClient("https://jsonplaceholder.typicode.com/posts")
result = client.get_resource("1")

assert result is not None
assert isinstance(result, dict)
print(f"Resource fetched successfully: {result}")

JUSTIFICATION:
----------------------------------------
This test case demonstrates error handling in the context of network protocols (APIs). It establishes a pattern of making an HTTP GET request and handling potential exceptions. The completion requires correctly identifying and handling a specific type of exception (RequestException), which is a common pattern in robust API clients. This scenario tests the LLM's ability to recognize and continue the error handling pattern while adhering to best practices.

ASSERTIONS:
----------------------------------------
bad_result = client.get_resource("999999")
print(f"Result for non-existent resource: {bad_result}")

user_client = APIClient("https://jsonplaceholder.typicode.com/users")
user_result = user_client.get_resource("1")  # Get user with ID 1
user_result = user_client.get_resource("1")  # Get user with ID 1
assert isinstance(user_result, dict)
print(f"User resource fetched successfully: {user_result['name']}")

================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import functools
import time

# Decorator to measure the execution time of functions
class Timer:
    def __init__(self, func):
        self.func = func
        functools.update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        start_time = time.time()
        result = self.func(*args, **kwargs)
        end_time = time.time()
        elapsed_time = end_time - start_time
        print(f"{self.func.__name__} took {elapsed_time:.4f} seconds to execute.")
        return result

@Timer


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
def fast_function():

SUFFIX CODE:
----------------------------------------
def fast_function():
    return "Fast"

fast_result = fast_function()

@Timer
def slow_function():
    time.sleep(2)
    return "Slow"

slow_result = slow_function()

# Assertions to verify the functionality and adherence to the pattern
assert fast_result == "Fast"
assert slow_result == "Slow"

# Cleanup (nothing to cleanup in this example)


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern involving decorators in a practical scenario. The Timer decorator pattern measures the execution time of functions. The prompt establishes the Timer class and its usage, and the suffix continues with different functions using this decorator. The golden completion requires the LLM to correctly apply the Timer decorator to a new function, demonstrating an understanding of the established pattern. The assertions ensure that the decorator works as expected and the functions return the correct values.

ASSERTIONS:
----------------------------------------
assert example_result == "Example"

================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import requests

class ApiClient:
    def __init__(self, base_url):
        self.base_url = base_url

    def get(self, endpoint):
        url = f"{self.base_url}/{endpoint}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()

    def post(self, endpoint, data):
        url = f"{self.base_url}/{endpoint}"
        response = requests.post(url, json=data)
        response.raise_for_status()
        return response.json()

    def put(self, endpoint, data):
        url = f"{self.base_url}/{endpoint}"
        response = requests.put(url, json=data)
        response.raise_for_status()


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        return response.json()

    def delete(self, endpoint):
        url = f"{self.base_url}/{endpoint}"
        response = requests.delete(url)
        response.raise_for_status()
        return response.json()

SUFFIX CODE:
----------------------------------------
        return response.json()

# Testing the ApiClient class
client = ApiClient("http://example.com/api")

# Mocking requests library
from unittest.mock import patch, Mock

with patch("requests.delete") as mock_delete:
    mock_response = Mock()
    mock_response.status_code = 204
    mock_response.json.return_value = {}
    mock_delete.return_value = mock_response
    response = client.delete("resource/1")
    assert response == {}

print("All tests passed!")

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete an established pattern of API CRUD operations within a class. The pattern involves defining HTTP methods (get, post, put) that construct a URL, make a request, handle errors, and return the JSON response. The golden completion requires the LLM to continue this pattern correctly for the delete method. The assertions check if the delete method is implemented and behaves correctly, verifying both functional and pattern adherence.

ASSERTIONS:
----------------------------------------
assert response == {}

print("All tests passed!")
================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import json
import os

class ConfigLoader:
    def __init__(self, config_path):
        self.config_path = config_path
        self.config_data = None

    def load_config(self):
        try:
            with open(self.config_path, 'r') as file:
                self.config_data = json.load(file)
        except FileNotFoundError:
            print(f"Config file not found: {self.config_path}")
            self.config_data = {}
        except json.JSONDecodeError:
            print(f"Error decoding JSON from file: {self.config_path}")
            self.config_data = {}

    def get(self, key, default=None):
        if self.config_data is None:
            self.load_config()
        return self.config_data.get(key, default)

    def save_config(self):
        try:
            with open(self.config_path, 'w') as file:
                json.dump(self.config_data, file, indent=4)
        except Exception as e:
            print(f"Error saving config: {e}")



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    def update(self, key, value):
        if self.config_data is None:
            self.load_config()
        if self.config_data is None:
            self.config_data = {}
        self.config_data[key] = value

SUFFIX CODE:
----------------------------------------
    def update(self, key, value):
        if self.config_data is None:
            self.load_config()
        if self.config_data is None:
            self.config_data = {}
        self.config_data[key] = value

config_path = 'config.json'
loader = ConfigLoader(config_path)
loader.update('new_key', 'new_value')
loader.save_config()

try:
    with open(config_path, 'r') as file:
        saved_data = json.load(file)
    assert saved_data['new_key'] == 'new_value'
finally:
    os.remove(config_path)

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and continue patterns in an OOP context for error handling and data manipulation within a configuration loader class. The golden completion demonstrates the pattern of checking if configuration data is loaded before performing operations and handling errors gracefully. This is a realistic scenario for developers working with configuration files and ensures the model can maintain consistency in method implementations.

ASSERTIONS:
----------------------------------------
config_path = 'config.json'
loader = ConfigLoader(config_path)
loader.update('key_to_delete', 'value_to_delete')
loader.save_config()

loader.delete('key_to_delete')
loader.save_config()

try:
    with open(config_path, 'r') as file:
        saved_data = json.load(file)
    assert 'key_to_delete' not in saved_data
finally:
    os.remove(config_path)
================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import json

def process_log_entry(log_entry):
    try:
        log_data = json.loads(log_entry)
        event_type = log_data.get('event_type')
        if event_type == 'ERROR':
            handle_error(log_data)
        elif event_type == 'INFO':
            handle_info(log_data)
        else:
            handle_generic(log_data)
    except json.JSONDecodeError:
        print('Invalid JSON format')

def handle_error(log_data):
    # Logic to handle error logs
    print(f"Error: {log_data.get('message')}")

def handle_info(log_data):
    # Logic to handle info logs
    print(f"Info: {log_data.get('message')}")


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
def handle_generic(log_data):
    # Logic to handle generic logs
    print(f"Generic: {log_data.get('message')}")

SUFFIX CODE:
----------------------------------------


# Sample log entries for testing
error_log = '{"event_type": "ERROR", "message": "Something went wrong"}'
info_log = '{"event_type": "INFO", "message": "System is running smoothly"}'
generic_log = '{"event_type": "DEBUG", "message": "Debugging details"}'

process_log_entry(error_log)
process_log_entry(info_log)
process_log_entry(generic_log)

assert process_log_entry(error_log) is None
assert process_log_entry(info_log) is None
assert process_log_entry(generic_log) is None

JUSTIFICATION:
----------------------------------------
This test case focuses on event handling patterns within the context of processing log entries. The completion demonstrates understanding of handling various log event types and processing them accordingly. The semantic pattern is established through handling different 'event_type' values within the JSON log entries. The completion should correctly implement the 'handle_generic' function, maintaining logical consistency with the other handlers and ensuring proper log processing. This tests the LLM's ability to understand the event handling pattern and apply it appropriately in a real-world logging scenario.

ASSERTIONS:
----------------------------------------
assert process_log_entry('{"event_type": "ERROR", "message": "Something went wrong"}') is None
assert process_log_entry('{"event_type": "INFO", "message": "System is running smoothly"}') is None
assert process_log_entry('{"event_type": "DEBUG", "message": "Debugging details"}') is None

================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import requests

class APIFetcher:
    def __init__(self, base_url):
        self.base_url = base_url

    def fetch(self, endpoint):
        response = requests.get(f'{self.base_url}/{endpoint}')
        response.raise_for_status()
        return response.json()

    def fetch_user(self, user_id):
        endpoint = f'users/{user_id}'
        user_data = self.fetch(endpoint)
        return user_data

    def fetch_post(self, post_id):
        endpoint = f'posts/{post_id}'
        post_data = self.fetch(endpoint)
        return post_data

    def fetch_comment(self, comment_id):
        endpoint = f'comments/{comment_id}'
        comment_data = self.fetch(endpoint)
        return comment_data



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
api_fetcher = APIFetcher('https://jsonplaceholder.typicode.com')


SUFFIX CODE:
----------------------------------------
api_fetcher = APIFetcher('https://jsonplaceholder.typicode.com')

user_data = api_fetcher.fetch_user(1)
post_data = api_fetcher.fetch_post(1)
comment_data = api_fetcher.fetch_comment(1)

# Assertions
assert 'id' in user_data
assert 'id' in post_data
assert 'id' in comment_data

# Cleanup (none needed in this context)


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize a clear pattern in a class that fetches different types of data from an API. The pattern involves defining methods that construct an endpoint string based on the provided ID, fetch the data, and return the JSON response. The LLM must recognize this pattern and continue it by implementing a new method that follows the same structure for fetching a 'todo' item. The assertions verify that the methods work correctly by checking the presence of 'id' in the returned data.

ASSERTIONS:
----------------------------------------
api_fetcher = APIFetcher('https://jsonplaceholder.typicode.com')
todo_data = api_fetcher.fetch_todo(1)
assert 'id' in todo_data

================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import logging

class SystemMonitor:
    def __init__(self):
        self.logger = logging.getLogger('SystemMonitor')
        self.logger.setLevel(logging.INFO)
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def log_info(self, message):
        self.logger.info(message)

    def log_warning(self, message):
        self.logger.warning(message)

    def log_error(self, message):
        self.logger.error(message)

    # Additional logging levels need to be added


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    def log_critical(self, message):
        self.logger.critical(message)

    def log_debug(self, message):
        self.logger.debug(message)

SUFFIX CODE:
----------------------------------------

monitor = SystemMonitor()
monitor.log_info('This is an info message')
monitor.log_warning('This is a warning message')
monitor.log_error('This is an error message')
monitor.log_critical('This is a critical message')
monitor.log_debug('This is a debug message')

JUSTIFICATION:
----------------------------------------
This test case is suitable because it tests the LLM's ability to recognize and continue a pattern of logging methods in a class. The prefix clearly establishes a pattern of method definitions for different logging levels (`log_info`, `log_warning`, `log_error`). The golden completion requires the LLM to continue this pattern by adding methods for `log_critical` and `log_debug`, maintaining consistency with the established method signatures and functionality. The suffix further uses these methods, ensuring the pattern is correctly identified and completed.

ASSERTIONS:
----------------------------------------
monitor = SystemMonitor()
monitor.log_info('This is an info message')
monitor.log_warning('This is a warning message')
monitor.log_error('This is an error message')
monitor.log_critical('This is a critical message')
monitor.log_debug('This is a debug message')
assert monitor.logger.hasHandlers(), 'Logger should have handlers attached'
for handler in monitor.logger.handlers:
    assert isinstance(handler, logging.StreamHandler), 'Handler should be a StreamHandler'
    assert isinstance(handler.formatter, logging.Formatter), 'Handler should have a Formatter attached'
    assert handler.formatter._fmt == '%(asctime)s - %(name)s - %(levelname)s - %(message)s', 'Formatter should match the specified format'
================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import logging

class Logger:
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(logging.DEBUG)
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def debug(self, message: str):
        self.logger.debug(message)

    def info(self, message: str):
        self.logger.info(message)

    def warning(self, message: str):
        self.logger.warning(message)



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    def error(self, message: str):
        self.logger.error(message)

SUFFIX CODE:
----------------------------------------
    def critical(self, message: str):
        self.logger.critical(message)

# Testing the Logger class
log = Logger('test_logger')
log.debug('This is a debug message')
log.info('This is an info message')
log.warning('This is a warning message')
log.error('This is an error message')
log.critical('This is a critical message')

# Assertions
assert len(logging.getLogger('test_logger').handlers) > 0
assert logging.getLogger('test_logger').level == logging.DEBUG


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and follow a common OOP pattern in system operations, specifically for logging. The Logger class demonstrates a clear, repetitive pattern of defining logging methods (debug, info, warning). The golden completion requires the LLM to continue this pattern by defining the 'error' method, which fits seamlessly within the established structure. This tests the LLM's ability to adhere to and extend established patterns in a realistic, practical scenario.

ASSERTIONS:
----------------------------------------
log = Logger('test_logger')
log.debug('This is a debug message')
log.info('This is an info message')
log.warning('This is a warning message')
log.error('This is an error message')
log.critical('This is a critical message')

assert len(logging.getLogger('test_logger').handlers) > 0
assert logging.getLogger('test_logger').level == logging.DEBUG

================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import logging
import time

class SystemMonitor:
    def __init__(self, log_file):
        self.logger = logging.getLogger('SystemMonitor')
        self.logger.setLevel(logging.DEBUG)
        handler = logging.FileHandler(log_file)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(handler)
        self.handlers = [handler]

    def log_cpu_usage(self, usage):
        self.logger.info(f'CPU Usage: {usage}%')

    def log_memory_usage(self, usage):
        self.logger.info(f'Memory Usage: {usage}%')



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    def log_network_usage(self, usage):
        self.logger.info(f'Network Usage: {usage}%')

SUFFIX CODE:
----------------------------------------

    def log_disk_usage(self, usage):
        self.logger.info(f'Disk Usage: {usage}%')
    def close(self):
        """Close all log handlers to release file handles."""
        for handler in self.handlers:
            self.logger.removeHandler(handler)
            handler.close()

if __name__ == '__main__':
    monitor = SystemMonitor('system.log')
    monitor.log_cpu_usage(45)
    monitor.log_memory_usage(30)
    monitor.log_disk_usage(70)

# Ensure the log file is created and has the expected content
with open('system.log', 'r') as log_file:
    logs = log_file.read()
assert 'CPU Usage: 45%' in logs
assert 'Memory Usage: 30%' in logs
assert 'Disk Usage: 70%' in logs

monitor.close()

# Clean up the log file
import os
os.remove('system.log')


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and continue a pattern in system operations logging. The prefix establishes a clear pattern of logging different system metrics (CPU and memory usage) with similar method structures. The golden completion should follow this pattern by adding a method to log network usage in a similar fashion. This tests the LLM's understanding of the established logging pattern and its ability to extend it consistently. The suffix continues the pattern by adding a method to log disk usage, which further reinforces the expected pattern for the golden completion.

ASSERTIONS:
----------------------------------------
monitor = SystemMonitor('system.log')
monitor.log_network_usage(50)
with open('system.log', 'r') as log_file:
    logs = log_file.read()
assert 'Network Usage: 50%' in logs

monitor.close()
os.remove('system.log')
================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import csv
import statistics
import os

class DataAnalyzer:
    def __init__(self, filepath):
        self.filepath = filepath
        self.data = []

    def load_data(self):
        with open(self.filepath, newline='') as csvfile:
            reader = csv.reader(csvfile)
            for row in reader:
                self.data.append([int(value) for value in row])

    def mean(self, column):
        column_data = [row[column] for row in self.data]
        return statistics.mean(column_data)

    def median(self, column):
        column_data = [row[column] for row in self.data]
        return statistics.median(column_data)

    def mode(self, column):
        column_data = [row[column] for row in self.data]
        return statistics.mode(column_data)



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
def create_test_csv(filename):
    sample_data = [
        [10, 20, 30],
        [15, 25, 35],
        [10, 30, 40],
        [20, 20, 30]
    ]
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        for row in sample_data:
            writer.writerow(row)

SUFFIX CODE:
----------------------------------------
def create_test_csv(filename):
    sample_data = [
        [10, 20, 30],
        [15, 25, 35],
        [10, 30, 40],
        [20, 20, 30]
    ]
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        for row in sample_data:
            writer.writerow(row)



JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and continue a clear OOP pattern in the context of scientific computing. The DataAnalyzer class follows a pattern of statistical methods operating on columns of data. The completion should add a new method that continues this pattern, adhering to the established class structure and using the statistics module.

ASSERTIONS:
----------------------------------------
try:
    create_test_csv('data.csv')

    analyzer = DataAnalyzer('data.csv')
    analyzer.load_data()

    analyzer.load_data()
    analyzer.load_data()
    print('Mode:', analyzer.mode(0))
    print('Variance:', analyzer.variance(0))

    assert analyzer.mean(0) == statistics.mean([row[0] for row in analyzer.data])
    assert analyzer.median(0) == statistics.median([row[0] for row in analyzer.data])
    assert analyzer.mode(0) == statistics.mode([row[0] for row in analyzer.data])
    assert analyzer.variance(0) == statistics.variance([row[0] for row in analyzer.data])

    print("All tests passed!")

finally:
    if os.path.exists('data.csv'):
     os.remove('data.csv')


================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class DataCleaner:
    def __init__(self):
        self.cleaned_data = []

    def remove_nulls(self, data):
        cleaned = [item for item in data if item is not None]
        self.cleaned_data.append(cleaned)

    def remove_empty_strings(self, data):
        cleaned = [item for item in data if item != '']
        self.cleaned_data.append(cleaned)



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    def remove_negative_numbers(self, data):
        cleaned = [item for item in data if not isinstance(item, (int, float)) or item >= 0]
        self.cleaned_data.append(cleaned)

SUFFIX CODE:
----------------------------------------
# Example data for testing
raw_data = [1, None, '', -5, 2, 'test', -1, 0, 'valid']

# Instantiate the DataCleaner class
cleaner = DataCleaner()

# Apply the cleaning methods
cleaner.remove_nulls(raw_data)
cleaner.remove_empty_strings(raw_data)
cleaner.remove_negative_numbers(raw_data)


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern in method implementations within a class. The pattern established in the prefix involves cleaning data by removing specific types of undesirable values (nulls, empty strings, negative numbers). The golden completion must adhere to this pattern and correctly implement the `remove_negative_numbers` method. Assertions verify that the methods work as expected and follow the established pattern, ensuring both functional and semantic correctness.

ASSERTIONS:
----------------------------------------
assert cleaner.cleaned_data[0] == [1, '', -5, 2, 'test', -1, 0, 'valid']
assert cleaner.cleaned_data[1] == [1, None, -5, 2, 'test', -1, 0, 'valid']
assert cleaner.cleaned_data[2] == [1, None, '', 2, 'test', 0, 'valid']

================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
# Import necessary modules
import statistics

# Define a class for analyzing datasets
class DataAnalyzer:
    def __init__(self, data):
        self.data = data

    def mean(self):
        return statistics.mean(self.data)

    def median(self):
        return statistics.median(self.data)

    def variance(self):
        return statistics.variance(self.data)

    def stdev(self):
        return statistics.stdev(self.data)

# Example data for testing
sample_data = [2, 4, 4, 4, 5, 5, 7, 9]

# Create an instance of DataAnalyzer
analyzer = DataAnalyzer(sample_data)

# Calculate and print the mean
print('Mean:', analyzer.mean())

# Calculate and print the median
print('Median:', analyzer.median())

# Calculate and print the variance
print('Variance:', analyzer.variance())

# Calculate and print the standard deviation


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
print('Standard Deviation:', analyzer.stdev())

SUFFIX CODE:
----------------------------------------
# Clean up resources if needed (not applicable in this simple example)
print('Analysis complete.')

JUSTIFICATION:
----------------------------------------
This test case establishes a clear pattern in the prefix of defining methods for statistical calculations within a DataAnalyzer class, followed by their usage in instance methods. The pattern involves computing and printing various statistical measures (mean, median, variance) from a dataset. The golden completion should follow this established pattern by implementing the calculation and print statement for the standard deviation, ensuring the code remains consistent and functional.

ASSERTIONS:
----------------------------------------
assert analyzer.mean() == 5.0
assert analyzer.median() == 4.5
assert analyzer.variance() == 4.571428571428571
assert analyzer.stdev() == 2.138089935299395
================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import numpy as np
import matplotlib.pyplot as plt

class DataAnalyzer:
    def __init__(self, data):
        self.data = data

    def calculate_mean(self):
        return np.mean(self.data)

    def calculate_median(self):
        return np.median(self.data)

    def calculate_variance(self):
        return np.var(self.data)

    def plot_histogram(self):
        plt.hist(self.data)
        plt.title('Data Histogram')
        plt.xlabel('Value')
        plt.ylabel('Frequency')


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        plt.show()

    def plot_boxplot(self):

SUFFIX CODE:
----------------------------------------
    def plot_boxplot(self):
        plt.boxplot(self.data)
        plt.title('Data Boxplot')
        plt.xlabel('Data')
        plt.ylabel('Value')

# Example usage
if __name__ == "__main__":
    data = np.random.randn(100)
    analyzer = DataAnalyzer(data)
    mean = analyzer.calculate_mean()
    median = analyzer.calculate_median()
    variance = analyzer.calculate_variance()
    std_dev = analyzer.calculate_standard_deviation()
    analyzer.plot_histogram()
    analyzer.plot_boxplot()
    plt.show()


JUSTIFICATION:
----------------------------------------
This test case evaluates the model's ability to recognize and complete an established pattern in an OOP context within the domain of scientific computing. The prefix defines multiple statistical methods and a plotting method within a class, establishing a clear pattern of statistical computations. The golden completion requires the model to follow this pattern by implementing a new method for standard deviation calculation. Assertions ensure functional correctness and adherence to the pattern.

ASSERTIONS:
----------------------------------------
assert isinstance(analyzer, DataAnalyzer)
assert mean == np.mean(data)
assert median == np.median(data)
assert variance == np.var(data)
assert std_dev == np.std(data)

================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import re

class LogFilter:
    def __init__(self, pattern):
        self.pattern = pattern

    def filter(self, log):
        return re.search(self.pattern, log) is not None

class LogProcessor:
    def __init__(self, logs):
        self.logs = logs
        self.filters = []

    def add_filter(self, log_filter):
        self.filters.append(log_filter)

    def process(self):
        filtered_logs = []
        for log in self.logs:
            if any(log_filter.filter(log) for log_filter in self.filters):
                filtered_logs.append(log)
        return filtered_logs

logs = [
    "2023-01-01 ERROR Something failed",
    "2023-01-02 INFO Initialization complete",
    "2023-01-03 WARNING Disk space low",
    "2023-01-04 ERROR Unable to connect to database"
]

log_processor = LogProcessor(logs)
error_filter = LogFilter(r'ERROR')
log_processor.add_filter(error_filter)


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
warning_filter = LogFilter(r'WARNING')
log_processor.add_filter(warning_filter)

SUFFIX CODE:
----------------------------------------
result = log_processor.process()

assert len(result) == 3
assert "2023-01-01 ERROR Something failed" in result
assert "2023-01-03 WARNING Disk space low" in result
assert "2023-01-04 ERROR Unable to connect to database" in result

log_processor.add_filter(LogFilter(r'connect'))
result = log_processor.process()

assert len(result) == 3
assert "2023-01-04 ERROR Unable to connect to database" in result


JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in the context of system operations (logging and monitoring) using OOP patterns. The prefix establishes a clear pattern of creating log filters and adding them to a log processor. The golden_completion follows this pattern by creating another filter and adding it to the processor. The suffix then continues the pattern by applying this logic to validate the filtered logs. This tests the LLM's ability to recognize and continue the established pattern of filtering logs based on patterns using OOP principles.

ASSERTIONS:
----------------------------------------
assert log_processor.filters[-1].pattern == r'connect'
result = log_processor.process()
assert len(result) == 3

================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import logging
import random
import io

class SystemMonitor:
    def __init__(self):
        self.log_stream = io.StringIO()
        self.logger = logging.getLogger('SystemMonitor')
        self.logger.setLevel(logging.INFO)
        handler = logging.StreamHandler(self.log_stream)
        handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(handler)

    def log_cpu_usage(self):
        usage = random.uniform(0, 100)
        self.logger.info('CPU usage: %.2f%%', usage)
        return usage

    def log_memory_usage(self):
        usage = random.uniform(0, 100)
        self.logger.info('Memory usage: %.2f%%', usage)
        return usage

    def log_disk_usage(self):
        usage = random.uniform(0, 100)
        self.logger.info('Disk usage: %.2f%%', usage)
        return usage

    def log_network_usage(self):
        usage = random.uniform(0, 100)
        self.logger.info('Network usage: %.2f%%', usage)
        return usage



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    def log_temperature(self):
        temperature = random.uniform(20, 80)
        self.logger.info('Temperature: %.2fC', temperature)
        return temperature

SUFFIX CODE:
----------------------------------------
    def log_temperature(self):
        temperature = random.uniform(20, 80)
        self.logger.info('Temperature: %.2fC', temperature)
        return temperature

    def get_log_output(self):
        return self.log_stream.getvalue()

# Create an instance of SystemMonitor
monitor = SystemMonitor()

# Log various system metrics
monitor.log_cpu_usage()
monitor.log_memory_usage()
monitor.log_disk_usage()
monitor.log_network_usage()
monitor.log_temperature()


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern in a class method for logging various system metrics. The established pattern includes logging CPU, memory, disk, and network usage. The completion must follow this pattern by adding a method to log power usage, maintaining the same structure and logging format. This tests the LLM's understanding of both OOP patterns and system operations logging.

ASSERTIONS:
----------------------------------------
power_monitor = SystemMonitor()
power_usage = power_monitor.log_power_usage()
log_output = power_monitor.get_log_output()

assert 'Power usage:' in log_output
assert '%.2f%%' % power_usage in log_output


================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import matplotlib.pyplot as plt
import numpy as np

class DataVisualizer:
    def __init__(self, data):
        self.data = data

    def plot_line_chart(self):
        plt.figure(figsize=(10, 5))
        plt.plot(self.data)
        plt.title('Line Chart')
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        plt.grid(True)
        plt.show()

    def plot_bar_chart(self):
        plt.figure(figsize=(10, 5))
        plt.bar(range(len(self.data)), self.data)
        plt.title('Bar Chart')
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        plt.grid(True)
        plt.show()

    def plot_scatter_chart(self):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        plt.figure(figsize=(10, 5))
        plt.scatter(range(len(self.data)), self.data)

SUFFIX CODE:
----------------------------------------
        plt.title('Scatter Chart')
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        plt.grid(True)
        plt.show()

data = np.random.rand(10)
visualizer = DataVisualizer(data)
visualizer.plot_line_chart()
visualizer.plot_bar_chart()
visualizer.plot_scatter_chart()


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and complete a pattern in a class that visualizes data using different types of charts. The pattern involves creating different plotting functions within the DataVisualizer class. The golden completion follows the pattern established by the previous methods (plot_line_chart and plot_bar_chart) by adding the missing implementation for the plot_scatter_chart method. This is a good test case because it requires understanding the structure and purpose of the class, the method signature, and the consistent use of the matplotlib library for visualizations.

ASSERTIONS:
----------------------------------------
data = np.random.rand(10)
visualizer = DataVisualizer(data)
visualizer.plot_scatter_chart()
assert plt.gcf().number == 1  # Ensure three figures were created
plt.close('all')  # Cleanup
================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import matplotlib.pyplot as plt
import numpy as np

class AnalyticsReport:
    def __init__(self, data):
        self.data = data

    def generate_histogram(self, column):
        plt.hist(self.data[column], bins=10, alpha=0.75)
        plt.title(f'Histogram of {column}')
        plt.xlabel(column)
        plt.ylabel('Frequency')
        plt.grid(True)

    def generate_line_chart(self, x_column, y_column):
        plt.plot(self.data[x_column], self.data[y_column], marker='o', linestyle='-')
        plt.title(f'Line Chart of {y_column} vs {x_column}')
        plt.xlabel(x_column)
        plt.ylabel(y_column)
        plt.grid(True)



LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    def generate_scatter_plot(self, x_column, y_column):
        plt.scatter(self.data[x_column], self.data[y_column], alpha=0.75)
        plt.title(f'Scatter Plot of {y_column} vs {x_column}')
        plt.xlabel(x_column)
        plt.ylabel(y_column)
        plt.grid(True)

SUFFIX CODE:
----------------------------------------

    def generate_scatter_plot(self, x_column, y_column):
        plt.scatter(self.data[x_column], self.data[y_column], alpha=0.75)
        plt.title(f'Scatter Plot of {y_column} vs {x_column}')
        plt.xlabel(x_column)
        plt.ylabel(y_column)
        plt.grid(True)

# Example usage
if __name__ == '__main__':
    data = {
        'age': np.random.randint(20, 50, size=100),
        'height': np.random.randint(150, 200, size=100),
        'weight': np.random.randint(50, 100, size=100)
    }
    report = AnalyticsReport(data)
    report.generate_histogram('age')
    report.generate_line_chart('height', 'weight')
    plt.show()

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the ability to recognize and continue a pattern of generating different types of charts using matplotlib within a class. The pattern established in the prefix involves methods that generate specific types of charts (histogram and line chart) with a consistent structure. The golden completion requires the addition of a method to generate a bar chart, following the same pattern. This ensures the LLM understands the pattern of chart generation methods and can extend it appropriately. The suffix then introduces a different method (scatter plot) to ensure the pattern is followed correctly without duplicating the golden completion.

ASSERTIONS:
----------------------------------------
data = {
    'age': np.random.randint(20, 50, size=100),
    'height': np.random.randint(150, 200, size=100),
    'weight': np.random.randint(50, 100, size=100)
}
report = AnalyticsReport(data)
report.generate_bar_chart('age', 'weight')
assert hasattr(report, 'generate_bar_chart')
assert callable(getattr(report, 'generate_bar_chart'))
assert plt.gcf().get_axes()[-1].get_title() == 'Bar Chart of weight vs age'
plt.close('all')
================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import matplotlib.pyplot as plt

class DataVisualizer:
    def __init__(self, data):
        self.data = data

    def plot_bar_chart(self, title, xlabel, ylabel):
        plt.figure(figsize=(10, 5))
        plt.bar(self.data.keys(), self.data.values())
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.show()

    def plot_line_chart(self, title, xlabel, ylabel):
        plt.figure(figsize=(10, 5))
        plt.plot(list(self.data.keys()), list(self.data.values()), marker='o')
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.show()

    def plot_pie_chart(self, title):
        plt.figure(figsize=(10, 5))
        plt.pie(self.data.values(), labels=self.data.keys(), autopct='%1.1f%%')
        plt.title(title)
        plt.show()

# Usage example
if __name__ == '__main__':
    data = {'A': 10, 'B': 20, 'C': 30, 'D': 40}
    visualizer = DataVisualizer(data)


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    visualizer.plot_bar_chart('Bar Chart Example', 'Categories', 'Values')
    visualizer.plot_line_chart('Line Chart Example', 'Categories', 'Values')

SUFFIX CODE:
----------------------------------------
    visualizer.plot_pie_chart('Pie Chart Example')

    # Clean up resources
    plt.close('all')


JUSTIFICATION:
----------------------------------------
This example tests the ability to recognize and continue a pattern of creating chart plotting methods in a DataVisualizer class, and using these methods in a consistent manner. The prefix establishes a pattern by defining several methods for plotting different types of charts (bar, line, pie). The golden completion follows this pattern by adding a call to the line chart plotting method before calling the pie chart method in the suffix. The task requires understanding the pattern of method definitions and their usage, which is common in data visualization tasks.

ASSERTIONS:
----------------------------------------
assert hasattr(DataVisualizer, 'plot_bar_chart')
assert hasattr(DataVisualizer, 'plot_line_chart')
assert hasattr(DataVisualizer, 'plot_pie_chart')
assert visualizer.plot_line_chart('Line Chart Example', 'Categories', 'Values') is None

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import matplotlib.pyplot as plt
import numpy as np

class DataVisualizer:
    def __init__(self, data):
        self.data = data

    def plot_line_chart(self, title, xlabel, ylabel):
        plt.figure(figsize=(10, 5))
        plt.plot(self.data)
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.grid(True)
        plt.show()

    def plot_bar_chart(self, title, xlabel, ylabel):
        plt.figure(figsize=(10, 5))
        plt.bar(range(len(self.data)), self.data)
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.grid(True)
        plt.show()

    def plot_scatter_chart(self, title, xlabel, ylabel):
        plt.figure(figsize=(10, 5))
        plt.scatter(range(len(self.data)), self.data)
        plt.title(title)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.grid(True)


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        plt.show()

SUFFIX CODE:
----------------------------------------
        plt.show()

# Usage example
data = np.random.rand(100)
visualizer = DataVisualizer(data)
visualizer.plot_line_chart('Line Chart', 'X-axis', 'Y-axis')
visualizer.plot_bar_chart('Bar Chart', 'X-axis', 'Y-axis')
visualizer.plot_scatter_chart('Scatter Chart', 'X-axis', 'Y-axis')

# Assertions
data = np.array([1, 2, 3, 4, 5])
visualizer = DataVisualizer(data)
try:
    visualizer.plot_pie_chart('Pie Chart')
except AttributeError:
    pass # Expected, as plot_pie_chart is not defined


JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching because it requires the LLM to recognize the repetitive structure of the plotting methods within the DataVisualizer class. The pattern involves creating a plot with specific attributes (title, xlabel, ylabel), configuring the figure, and displaying the plot. The golden completion follows this established pattern to add a new method for plotting a histogram. The assertions ensure that the new method fits seamlessly into the class and behaves as expected.

ASSERTIONS:
----------------------------------------
import numpy as np

# Test data
sample_data = np.random.rand(50)
visualizer = DataVisualizer(sample_data)

# Test the new method
try:
    visualizer.plot_histogram('Histogram', 'Bins', 'Frequency')
except Exception as e:
    assert False, f'plot_histogram raised an exception: {e}'

# Validate the method is added correctly and callable
assert hasattr(visualizer, 'plot_histogram'), 'plot_histogram method is not defined'
assert callable(getattr(visualizer, 'plot_histogram')), 'plot_histogram is not callable'

================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import cv2
import numpy as np
import os
import time

# Define a decorator to measure the execution time of functions
def timeit(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Function {func.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return wrapper

# Define a media processing function to apply a Gaussian blur to an image
@timeit
def apply_gaussian_blur(image_path, kernel_size):
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError(f"Image at path {image_path} could not be loaded.")
    blurred_image = cv2.GaussianBlur(image, (kernel_size, kernel_size), 0)
    return blurred_image

# Define another media processing function to convert an image to grayscale
@timeit
def convert_to_grayscale(image_path):
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError(f"Image at path {image_path} could not be loaded.")
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    return gray_image

# Define a function to resize an image while keeping the aspect ratio
@timeit
def resize_image(image_path, width):
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError(f"Image at path {image_path} could not be loaded.")
    aspect_ratio = image.shape[1] / image.shape[0]
    new_height = int(width / aspect_ratio)
    resized_image = cv2.resize(image, (width, new_height))
    return resized_image

def create_sample_image(filename, width=300, height=200):
    image = np.zeros((height, width, 3), dtype=np.uint8)
    for i in range(height):
        for j in range(width):
            b = int(255 * (1 - j / width))
            r = int(255 * (j / width))
            image[i, j] = [b, 0, r]

    cv2.imwrite(filename, image)
    return image

# Example usage of the functions
image_path = 'example.jpg'
create_sample_image(image_path)
print(f"Created sample image at {image_path}")

try:
    blurred_image = apply_gaussian_blur(image_path, 5)
    gray_image = convert_to_grayscale(image_path)


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
    resized_image = resize_image(image_path, 100)
    cv2.imwrite('rotated_example.jpg', rotated_image)

SUFFIX CODE:
----------------------------------------
    original_image = cv2.imread(image_path)
    if original_image is None:
        raise ValueError(f"Image at path {image_path} could not be loaded.")
    rotated_image = cv2.rotate(original_image, cv2.ROTATE_90_CLOCKWISE)
    print("Image rotated successfully.")

    cv2.imwrite('blurred_example.jpg', blurred_image)
    cv2.imwrite('gray_example.jpg', gray_image)
    cv2.imwrite('resized_example.jpg', resized_image)
    cv2.imwrite('resized_example.jpg', resized_image)

    assert blurred_image is not None
    assert gray_image is not None
    assert resized_image is not None
    assert resized_image.shape[1] == 100
    assert cv2.imread('resized_example.jpg') is not None

    print("All tests passed successfully.")

except ValueError as e:
    print(e)
finally:
    for file in ['example.jpg', 'blurred_example.jpg', 'gray_example.jpg', 'resized_example.jpg', 'rotated_example.jpg']:
        if os.path.exists(file):
            os.remove(file)
            print(f"Removed file: {file}")


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and continue a pattern involving media processing functions wrapped with a decorator for measuring execution time. The prefix establishes a clear pattern by defining multiple decorated functions for different image processing tasks, and the golden completion follows this pattern by adding another function call that matches the established pattern. The suffix continues the usage of processed images, further validating the pattern. This scenario is realistic for developers working on media processing tasks and tests the model's ability to adhere to established patterns in a practical context.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import time

class EventListener:
    def __init__(self):
        self.handlers = []

    def register_handler(self, handler):
        self.handlers.append(handler)

    def trigger_event(self, event):
        for handler in self.handlers:
            handler(event)

class MediaProcessor:
    def __init__(self):
        self.event_listener = EventListener()

    def register_event_handler(self, handler):
        self.event_listener.register_handler(handler)

    def process_audio(self, audio_data):
        print("Processing audio...")
        time.sleep(1)  # Simulate processing delay
        self.event_listener.trigger_event({'type': 'audio', 'data': audio_data})

    def process_video(self, video_data):
        print("Processing video...")
        time.sleep(1)  # Simulate processing delay
        self.event_listener.trigger_event({'type': 'video', 'data': video_data})

    def process_image(self, image_data):


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
        print("Processing image...")
        time.sleep(1)  # Simulate processing delay
        self.event_listener.trigger_event({'type': 'image', 'data': image_data})

SUFFIX CODE:
----------------------------------------
# Example usage
media_processor = MediaProcessor()

# Mock handlers to verify event triggering
audio_event_triggered = False
video_event_triggered = False
image_event_triggered = False

def audio_handler(event):
    global audio_event_triggered
    if event['type'] == 'audio':
        audio_event_triggered = True


def video_handler(event):
    global video_event_triggered
    if event['type'] == 'video':
        video_event_triggered = True


def image_handler(event):
    global image_event_triggered
    if event['type'] == 'image':
        image_event_triggered = True

media_processor.register_event_handler(audio_handler)
media_processor.register_event_handler(video_handler)
media_processor.register_event_handler(image_handler)

media_processor.process_audio('audio_data')
media_processor.process_video('video_data')
media_processor.process_image('image_data')

assert audio_event_triggered == True
assert video_event_triggered == True
assert image_event_triggered == True


JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in the context of event handling within a media processing application. The pattern established in the prefix is the processing of different media types (audio, video) and triggering corresponding events. The `golden_completion` requires recognizing this pattern and correctly implementing the processing of image data, including the consistent triggering of an event. The assertions verify that the event handling mechanism works correctly for all media types, ensuring that the pattern is followed accurately.

ASSERTIONS:
----------------------------------------
assert audio_event_triggered == True
assert video_event_triggered == True
assert image_event_triggered == True

================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import time
import random

class EventListener:
    def __init__(self):
        self.handlers = []

    def register_handler(self, handler):
        self.handlers.append(handler)

    def notify(self, event):
        for handler in self.handlers:
            handler(event)

class EventGenerator:
    def __init__(self, listener):
        self.listener = listener

    def generate_events(self):
        for i in range(3):
            event = {'type': 'event_{}'.format(i), 'timestamp': time.time(), 'value': random.randint(1, 100)}
            self.listener.notify(event)
            time.sleep(1)

# Setup event listener and generator
listener = EventListener()

# Register handlers
listener.register_handler(lambda event: print('Handler 1 received:', event))
listener.register_handler(lambda event: print('Handler 2 received:', event))

# Create event generator
generator = EventGenerator(listener)

# Start generating events
generator.generate_events()


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
listener.register_handler(lambda event: print('Handler 3 received:', event))

SUFFIX CODE:
----------------------------------------
assert len(listener.handlers) == 3, 'There should be exactly three handlers registered'
assert all(callable(handler) for handler in listener.handlers), 'All handlers should be callable'


JUSTIFICATION:
----------------------------------------
This test case is a good example of event handling in the context of media processing. It involves setting up an event listener and generator, registering multiple handlers, and ensuring the handlers are called correctly when events are generated. The pattern of registering handlers and generating events is clearly established in the prefix. The golden completion follows this pattern by adding a new handler and generating events again. The assertions check that the correct number of handlers are registered and that they are all callable, ensuring the pattern is adhered to and the functionality is correct.

ASSERTIONS:
----------------------------------------
assert len(listener.handlers) == 3, 'There should be exactly three handlers registered'
assert all(callable(handler) for handler in listener.handlers), 'All handlers should be callable'

================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class GameCharacter:
    def __init__(self, name, health):
        self.name = name
        self.health = health
        self.state = 'idle'

    def idle(self):
        self.state = 'idle'
        print(f'{self.name} is now idling.')

    def move(self):
        self.state = 'moving'
        print(f'{self.name} is now moving.')

    def attack(self):
        self.state = 'attacking'
        print(f'{self.name} is attacking!')

    def take_damage(self, amount):
        self.health -= amount
        print(f'{self.name} took {amount} damage. Health is now {self.health}.')

    def update(self):
        if self.state == 'idle':
            self.idle()
        elif self.state == 'moving':
            self.move()
        elif self.state == 'attacking':
            self.attack()
        else:
            print(f'{self.name} is in an unknown state: {self.state}')

# Test the GameCharacter class
character = GameCharacter('Hero', 100)
character.update()
character.state = 'moving'
character.update()
character.state = 'attacking'
character.update()
character.take_damage(10)


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
# Assertions to verify the character's state and health
assert character.state == 'attacking', f"Expected state to be 'attacking', but got '{character.state}'"
assert character.health == 90, f"Expected health to be 90, but got {character.health}"

SUFFIX CODE:
----------------------------------------
# Cleanup resources if needed
# Here no explicit cleanup is required as we are not using external resources
# The assertions are placed before any hypothetical cleanup


JUSTIFICATION:
----------------------------------------
This example tests the model's ability to recognize and complete a state machine pattern in a game mechanics context. The prefix establishes a clear pattern where the character's state is updated based on the current state. The completion requires the model to continue this pattern by setting the state and calling the update method. The suffix completes the scenario without repeating the golden completion.

ASSERTIONS:
----------------------------------------
assert character.state == 'idle'
assert character.health == 90

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: synthbench-pattern-matching
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import time

class GameEvent:
    def __init__(self, name):
        self.name = name

class EventHandler:
    def __init__(self):
        self.events = []

    def register_event(self, event):
        print(f"Registering event: {event.name}")
        self.events.append(event)

    def process_events(self):
        while self.events:
            event = self.events.pop(0)
            print(f"Processing event: {event.name}")
            time.sleep(1)

handler = EventHandler()
handler.register_event(GameEvent("Start"))
handler.register_event(GameEvent("Move"))
handler.register_event(GameEvent("Attack"))


LLM COMPLETION claude-3-5-sonnet:
----------------------------------------
handler.register_event(GameEvent("End"))


SUFFIX CODE:
----------------------------------------
handler.process_events()
print("All events processed.")


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern of event registration in a game event handler context. The pattern involves creating a GameEvent object and registering it with the EventHandler. The golden completion correctly follows this pattern by registering a new event, 'Defend', which fits the established sequence of events ('Start', 'Move', 'Attack'). This ensures that the model understands both the technical pattern of event handling and the domain context of game mechanics.

ASSERTIONS:
----------------------------------------
assert len(handler.events) == 0

================================================================================
