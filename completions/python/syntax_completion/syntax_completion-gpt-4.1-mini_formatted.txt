
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os

def nested_context_managers():
    try:
        with open('testfile1.txt', 'w') as f1:
            f1.write('Hello')
            with open('testfile2.txt', 'w') as f2:
                f2.write('World')
                # Begin another nested context manager


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
                with open('testfile3.txt', 'w') as f3:
                    f3.write('!')

SUFFIX CODE:
----------------------------------------
                # End of inner with statements
            # End of outer with statement
        # Exception handling
    except IOError as e:
        print(f"IOError: {e}")
    except Exception as e:
        print(f"Exception: {e}")
    else:
        print("Files written successfully")

nested_context_managers()


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to correctly complete deeply nested context managers and maintain the proper indentation levels. The completion involves adding another nested 'with' statement within existing nested 'with' blocks. It ensures the LLM understands context management and proper nesting syntax.

ASSERTIONS:
----------------------------------------
assert os.path.exists('testfile1.txt')
assert os.path.exists('testfile2.txt')
nested_context_managers()

================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile

# Function to demonstrate nested control structures

def nested_control_example(value):
    with tempfile.TemporaryDirectory() as tempdir:
        try:
            if value > 0:
                for i in range(value):
                    if i % 2 == 0:
                        with open(os.path.join(tempdir, f'tempfile_{i}.txt'), 'w') as f:
                            f.write(f'even_{i}')
                    else:


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
                        with open(os.path.join(tempdir, f'tempfile_{i}.txt'), 'w') as f:
                            f.write(f'odd_{i}')

SUFFIX CODE:
----------------------------------------
            else:
                raise ValueError('Value must be positive')
        except ValueError as e:
            print(f'Error: {e}')
        except Exception as e:
            print(f'Unexpected error: {e}')
        else:
            print('Successfully processed all files')
        finally:
            print('Cleanup if needed')

# Test cases
nested_control_example(3)
nested_control_example(-1)

assert os.path.exists(tempfile.gettempdir()), 'Temp directory should exist'


JUSTIFICATION:
----------------------------------------
This test case is a good example of nested control structures, including multiple levels of if/else conditions and nested with statements. It also demonstrates proper resource management with a context manager. The completion requires the model to understand and maintain the correct nesting and syntax, which is critical for generating executable Python code.

ASSERTIONS:
----------------------------------------
nested_control_example(3)
nested_control_example(-1)
assert os.path.exists(tempfile.gettempdir()), 'Temp directory should exist'

================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
def process_data(data):
    try:
        result = []
        for item in data:
            try:
                if item < 0:
                    raise ValueError("Negative value")
                elif item == 0:
                    raise ZeroDivisionError("Zero value")
                else:
                    result.append(10 / item)
            except ValueError as ve:
                print(f"ValueError occurred: {ve}")
            except ZeroDivisionError as ze:
                print(f"ZeroDivisionError occurred: {ze}")
            else:
                print(f"Processed item: {item}")


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
        return result
    finally:
        print("Processing complete")

# Example usage:
data = [10, -1, 0, 5]
processed_data = process_data(data)
print(processed_data)


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to correctly complete nested try/except/else/finally blocks within a loop. It ensures proper handling of multiple exception types and the correct placement of a finally block inside the loop. The golden completion demonstrates understanding of the control flow and proper indentation.

ASSERTIONS:
----------------------------------------
data = [10, -1, 0, 5]
processed_data = process_data(data)
assert processed_data == [1.0, 2.0], f"Expected [1.0, 2.0] but got {processed_data}"

================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile

class FileManager:
    def __init__(self, filename: str):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()
        if exc_type is not None:
            print(f"Exception: {exc_val}")

with tempfile.NamedTemporaryFile(delete=False) as tmp:
    filename = tmp.name

try:
    with FileManager(filename) as f:
        f.write('Hello, World!')
        raise ValueError('Test error')
except ValueError as e:
    print(f"Caught ValueError: {e}")


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
else:

SUFFIX CODE:
----------------------------------------
else:
    print("No exceptions occurred.")
finally:
    os.remove(filename)
    print("File cleaned up.")


JUSTIFICATION:
----------------------------------------
This example tests the ability to handle nested control structures with multiple try/except/else/finally blocks and context manager nesting. It verifies the correct handling of exceptions and resource cleanup while maintaining proper indentation and structure.

ASSERTIONS:
----------------------------------------
assert os.path.exists(filename) == False

================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class FileManager:
    def __init__(self, filename):
        self.filename = filename

    def read_file(self):
        try:
            with open(self.filename, 'r') as file:
                data = file.read()
                return data


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        except FileNotFoundError:

SUFFIX CODE:
----------------------------------------
        except FileNotFoundError:
            print(f"File {self.filename} not found.")
        except IOError:
            print(f"An error occurred while reading {self.filename}.")
        else:
            print("File read successfully.")
        finally:
            print("Finished file operation.")

# Test the FileManager class
fm = FileManager('example.txt')
content = fm.read_file()
if content:
    print(content)


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to handle multiple nested try/except blocks with different types of exceptions, ensuring proper syntax and indentation. The completion adds an additional except block for PermissionError, which is a common file handling exception.

ASSERTIONS:
----------------------------------------
fm = FileManager('example.txt')
try:
    content = fm.read_file()
except PermissionError:
    pass
except FileNotFoundError:
    pass
except IOError:
    pass
assert content is None or isinstance(content, str)

================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile

class FileManager:
    def __init__(self, filename):
        self.filename = filename

    def write_and_read(self, content):
        # Context manager nesting with multiple with statements
        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_filename = temp_file.name
            temp_file.write(content.encode())
            temp_file.flush()
            with open(temp_file.name, 'r') as read_file:


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
                read_data = read_file.read()

SUFFIX CODE:
----------------------------------------
                read_data = read_file.read()
        os.remove(temp_file.name)
        return read_data, temp_filename

# Example usage
file_manager = FileManager('example.txt')
result, temp_filename = file_manager.write_and_read('Hello, World!')

# Assertions
assert result == 'Hello, World!', f"Expected 'Hello, World!', but got {result}"

print('All assertions passed!')

JUSTIFICATION:
----------------------------------------
This test case is a good benchmark for syntax completion capabilities as it involves nested context managers with `with` statements. The correct completion requires understanding the structure and indentation of nested blocks. Ensuring the file pointer is reset using `read_file.seek(0)` before reading the file content is crucial for reading the entire content written to the temporary file. This tests the LLM's ability to handle nested context managers and maintain proper indentation and syntax.

ASSERTIONS:
----------------------------------------
assert os.path.exists(temp_filename) == False, 'Temporary file was not deleted'
================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio
import aiofiles

class BaseService:
    def __init__(self, name):
        self.name = name

    async def start_service(self):
        raise NotImplementedError('start_service must be implemented by subclasses')

class LoggingService(BaseService):
    def __init__(self, name, log_file):
        super().__init__(name)
        self.log_file = log_file

    async def start_service(self):
        async with aiofiles.open(self.log_file, mode='a') as log:
            await log.write(f'{self.name} service started\n')

class MonitoringService(BaseService):
    def __init__(self, name, monitoring_endpoint):
        super().__init__(name)
        self.monitoring_endpoint = monitoring_endpoint

    async def start_service(self):
        await asyncio.sleep(1)
        print(f'{self.name} service is monitoring at {self.monitoring_endpoint}')

class CombinedService:
    def __init__(self, *services):
        self.services = services

    async def start_all_services(self):


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        await asyncio.gather(*(service.start_service() for service in self.services))

SUFFIX CODE:
----------------------------------------
    async def stop_all_services(self):
        # This method will stop all services
        for service in self.services:
            print(f'Stopping {service.name} service')

# Example usage
async def main():
    logging_service = LoggingService('Logger', 'logfile.txt')
    monitoring_service = MonitoringService('Monitor', 'http://localhost:8000')
    combined_service = CombinedService(logging_service, monitoring_service)
    await combined_service.start_all_services()
    await combined_service.stop_all_services()

asyncio.run(main())


JUSTIFICATION:
----------------------------------------
This test case is a good example of complex Python syntax features including async/await patterns, multiple inheritance, and the use of asyncio for concurrent task execution. It also demonstrates the proper use of context managers and file handling using aiofiles.

ASSERTIONS:
----------------------------------------
assert issubclass(LoggingService, BaseService)
assert issubclass(MonitoringService, BaseService)
assert asyncio.iscoroutinefunction(LoggingService('Logger', 'logfile.txt').start_service)
assert asyncio.iscoroutinefunction(MonitoringService('Monitor', 'http://localhost:8000').start_service)
assert asyncio.iscoroutinefunction(CombinedService().start_all_services)

================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

class MyBaseClass:
    def __init__(self, value):
        self.value = value

class MyDerivedClass(MyBaseClass):
    def __init__(self, value, extra):
        super().__init__(value)
        self.extra = extra

    async def async_method(self):
        await asyncio.sleep(1)
        print('Async task completed')

class AnotherDerivedClass(MyDerivedClass):
    def __init__(self, value, extra, additional):
        super().__init__(value, extra)
        self.additional = additional

    async def complex_async_method(self):


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        print(f'Value: {self.value}, Extra: {self.extra}, Additional: {self.additional}')

SUFFIX CODE:
----------------------------------------
        print(f'Value: {self.value}, Extra: {self.extra}, Additional: {self.additional}')
        await self.async_method()

async def main():
    obj = AnotherDerivedClass(1, 'extra', 'additional')
    await obj.complex_async_method()

if __name__ == '__main__':
    asyncio.run(main())


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of complex Python syntax features like multiple inheritance, super() calls, and async/await patterns. The completion involves the use of asyncio.gather to run multiple asynchronous tasks concurrently, which tests the model's understanding of asynchronous programming and proper indentation within a class method.

ASSERTIONS:
----------------------------------------
assert issubclass(AnotherDerivedClass, MyDerivedClass)
assert hasattr(AnotherDerivedClass, 'complex_async_method')
import asyncio
obj = AnotherDerivedClass(1, 'extra', 'additional')
async def test_method():
    await obj.complex_async_method()
asyncio.run(test_method())

================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class Resource:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print(f'Entering {self.name}')
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        print(f'Exiting {self.name}')

class CustomError(Exception):
    pass

class CustomResourceHandler:
    def process_resource(self):
        try:
            with Resource('CustomResource') as resource:

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
                raise CustomError("An error occurred")

SUFFIX CODE:
----------------------------------------

                print('Processing resource')
        except CustomError as e:
            print(f'Caught custom error: {e}')
            return "error_caught"
        except Exception as e:
            print(f'Caught generic error: {e}')
        else:
            print('No errors encountered')
        finally:
            print('Cleanup if necessary')

handler = CustomResourceHandler()


JUSTIFICATION:
----------------------------------------
This test case is a good example for syntax completion as it involves a try/except/else/finally block with context manager error handling and custom exception raising. It tests the LLM's ability to handle complex nested structures and proper indentation.

ASSERTIONS:
----------------------------------------
result = handler.process_resource()
assert result == "error_caught", 'CustomError was not caught as expected'
print('Test completed successfully')

================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import contextlib

@contextlib.contextmanager
def managed_resource(name: str):
    print(f"Acquiring resource: {name}")
    resource = f"Resource({name})"
    try:

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        yield resource

SUFFIX CODE:
----------------------------------------

    finally:
        print(f"Releasing resource: {name}")
        del resource

# Usage example
try:
    with managed_resource("MyResource") as res:
        print(f"Using {res}")
        assert res == "Resource(MyResource)"
finally:
    print("Done with resource management")

JUSTIFICATION:
----------------------------------------
This test case demonstrates the usage of a context manager with proper resource handling. The code within the `try` block should yield the resource and manage exceptions correctly. The completion must maintain the appropriate indentation and syntax for the context manager to function properly. The suffix code provides a concrete example of using the context manager, ensuring that the assertions check the resource management.

ASSERTIONS:
----------------------------------------
assert callable(managed_resource)
with managed_resource("TestResource") as res:
    assert res == "Resource(TestResource)"
print("All assertions passed.")
================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

async def fetch_data(url: str) -> str:
    # Simulate an async data fetch
    await asyncio.sleep(1)
    return f"Data from {url}"

async def main():
    urls = ["http://example.com/1", "http://example.com/2", "http://example.com/3"]
    tasks = [


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        fetch_data(url) for url in urls

SUFFIX CODE:
----------------------------------------
    ]
    results = await asyncio.gather(*tasks)
    for result in results:
        print(result)

if __name__ == "__main__":
    asyncio.run(main())

JUSTIFICATION:
----------------------------------------
This is a good test case for checking the LLM's understanding of async/await patterns, especially the correct usage of list comprehensions within an async context. The prompt sets up an asynchronous function and an async main function that creates tasks, while the golden completion requires correctly forming a list comprehension of async function calls. The suffix includes gathering the tasks and printing results, which tests the LLM's ability to maintain consistency in the asynchronous structure.

ASSERTIONS:
----------------------------------------
assert asyncio.run(main()) == None

================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

async def fetch_data(url: str) -> dict:
    # Simulate an async data fetch operation
    await asyncio.sleep(1)
    return {"data": "sample"}

class DataProcessor:
    async def process(self, url: str) -> dict:
        try:
            data = await fetch_data(url)


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        except Exception as e:

SUFFIX CODE:
----------------------------------------
        except Exception as e:
            print(f"Error fetching data: {e}")
        else:
            print("Data fetched successfully")
        return data

# Example usage
async def main():
    processor = DataProcessor()
    result = await processor.process("http://example.com")
    print(result)

# Run the example
def run_example():
    asyncio.run(main())

run_example()


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to handle async/await patterns combined with complex error handling using try/except blocks. The golden completion demonstrates the correct way to catch a specific exception (asyncio.TimeoutError) in an async function, ensuring the LLM understands async error handling. The suffix continues with general exception handling and normal flow, providing a clear distinction between the completion and subsequent code.

ASSERTIONS:
----------------------------------------
assert asyncio.iscoroutinefunction(fetch_data)
assert asyncio.iscoroutinefunction(DataProcessor().process)
assert DataProcessor().process.__code__.co_flags & 0x80  # Check if 'process' is an async function
try:
    asyncio.run(main())
except Exception as e:
    assert False, f"An unexpected exception occurred: {e}"

================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import sqlite3

class DatabaseManager:
    def __init__(self, db_name: str):
        self.db_name = db_name

    def __enter__(self):
        self.conn = sqlite3.connect(self.db_name)
        self.cursor = self.conn.cursor()
        return self.cursor

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None:
            self.conn.rollback()
        else:
            self.conn.commit()
        self.conn.close()

class UserRepository:
    def __init__(self, db_name: str):
        self.db_name = db_name

    def add_user(self, user_id: int, user_name: str):


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        with DatabaseManager(self.db_name) as cursor:
            cursor.execute('INSERT INTO users (id, name) VALUES (?, ?)', (user_id, user_name))
        print(f"User {user_name} added with ID {user_id}")

SUFFIX CODE:
----------------------------------------
        print(f"User {user_name} added with ID {user_id}")

# Test case
if __name__ == '__main__':
    repo = UserRepository('test.db')
    with DatabaseManager('test.db') as cursor:
        cursor.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)')
    repo.add_user(1, 'Alice')

    # Verify user addition
    with DatabaseManager('test.db') as cursor:
        cursor.execute('SELECT name FROM users WHERE id = ?', (1,))
        result = cursor.fetchone()
    assert result[0] == 'Alice', f"Expected 'Alice', but got {result[0]}"

    # Cleanup
    with DatabaseManager('test.db') as cursor:
        cursor.execute('DROP TABLE users')


JUSTIFICATION:
----------------------------------------
This test case is a good example for checking the completion of context manager usage within a method, showing the correct structure and indentation for using the 'with' statement. The prompt sets up the context for a database operation, and the completion needs to properly implement the insertion of a user into the database table, while the suffix handles verification and cleanup, ensuring that the code is fully functional and syntactically correct.

ASSERTIONS:
----------------------------------------
repo = UserRepository('test.db')
with DatabaseManager('test.db') as cursor:
    cursor.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)')

repo.add_user(2, 'Bob')
with DatabaseManager('test.db') as cursor:
    cursor.execute('SELECT name FROM users WHERE id = ?', (2,))
    result = cursor.fetchone()
assert result[0] == 'Bob', f"Expected 'Bob', but got {result[0]}"

with DatabaseManager('test.db') as cursor:
    cursor.execute('DROP TABLE users')


================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

async def fetch_data(url: str) -> str:
    await asyncio.sleep(1)
    return f"Data from {url}"

async def main():
    urls = ["http://example.com/1", "http://example.com/2"]
    tasks = [fetch_data(url) for url in urls]
    

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    results = await asyncio.gather(*tasks)

SUFFIX CODE:
----------------------------------------
    for result in results:
        print(result)
    return results

results = asyncio.run(main())

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of async/await patterns in Python, specifically the use of asyncio.gather for concurrently running multiple asynchronous tasks. The completion requires understanding the async/await syntax and proper function calls within an asynchronous context.

ASSERTIONS:
----------------------------------------
assert asyncio.iscoroutinefunction(fetch_data)
assert asyncio.iscoroutinefunction(main)
assert 'results' in locals()
================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class CustomError(Exception):
    pass

class Resource:
    def __init__(self):
        self.active = False

    def __enter__(self):
        self.active = True
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.active = False

    def use(self):
        if not self.active:
            raise CustomError("Resource not active")
        return "Resource is being used"

# The following function demonstrates complex error handling patterns with context managers

def complex_function(flag: bool):
    try:
        with Resource() as res:

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            if not flag:
                raise CustomError("Resource not active")

SUFFIX CODE:
----------------------------------------

            return res.use()
    except CustomError as e:
        return f"Caught CustomError: {str(e)}"
    except Exception as e:
        return f"Caught unexpected error: {str(e)}"
    else:
        return "No errors occurred"
    finally:
        print("Execution completed")

# Test the function with different scenarios
assert complex_function(True) == "Resource is being used"
assert "Caught CustomError" in complex_function(False)
assert complex_function(True) != "Caught CustomError"

print("All assertions passed.")

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to understand and complete a nested try/except/else/finally block with context manager usage. The completion involves raising a custom exception based on a condition, which checks the LLM's understanding of error handling and context manager patterns. Proper indentation and nesting are crucial here.

ASSERTIONS:
----------------------------------------
assert complex_function(True) == "Resource is being used"
assert "Caught CustomError" in complex_function(False)
assert complex_function(True) != "Caught CustomError"

print("All assertions passed.")
================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class ResourceHandler:
    def __init__(self, resource):
        self.resource = resource

    def process_resource(self):
        try:
            self.resource.open()


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            # perform some processing with the resource
            pass

SUFFIX CODE:
----------------------------------------
        finally:
            self.resource.close()

# Example usage:
class MockResource:
    def open(self):
        pass
    def close(self):
        pass

resource = MockResource()
handler = ResourceHandler(resource)
handler.process_resource()

# Assertions
assert hasattr(resource, 'open')
assert hasattr(resource, 'close')

JUSTIFICATION:
----------------------------------------
This test case examines the LLM's ability to complete a try/except/finally block properly. It ensures the LLM understands the flow of control in error handling and proper nesting of the syntax. The completion must include an appropriate error handling clause, which is a common and critical pattern in Python programming.

ASSERTIONS:
----------------------------------------
assert hasattr(resource, 'open')
assert hasattr(resource, 'close')
# Ensure no exceptions are thrown during execution
try:
    handler.process_resource()
    exception_raised = False
except Exception:
    exception_raised = True
assert not exception_raised
================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict, Tuple

class Base1:
    def greet(self) -> str:
        return 'Hello from Base1'

class Base2:
    def greet(self) -> str:
        return 'Hello from Base2'

class Child(Base1, Base2):
    def greet(self) -> str:
        return super().greet() + ' and Child'

class MultiInheritanceExample(Child):
    def __init__(self, values: List[int], config: Dict[str, str]):
        self.values = values
        self.config = config

    def calculate(self) -> Tuple[int, int]:
        total = sum(self.values)
        count = len(self.values)
        return total, count



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
example = MultiInheritanceExample([1, 2, 3, 4], {'key': 'value'})
def new_greet(self):
    return super(MultiInheritanceExample, self).greet() + ' with MultiInheritanceExample'
MultiInheritanceExample.greet = new_greet

SUFFIX CODE:
----------------------------------------
example = MultiInheritanceExample([1, 2, 3, 4], {'key': 'value'})
assert example.greet() == 'Hello from Base1 and Child with MultiInheritanceExample'
assert example.calculate() == (10, 4)

# Cleanup resources
example = None


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's understanding of multiple inheritance and the usage of super() calls in a nested class structure. The `golden_completion` demonstrates correct syntax for overriding methods in a derived class and invoking the parent class method using super(). This ensures that the model can handle complex inheritance scenarios and maintain proper method resolution order (MRO).

ASSERTIONS:
----------------------------------------
example = MultiInheritanceExample([1, 2, 3, 4], {'key': 'value'})
assert example.greet() == 'Hello from Base1 and Child with MultiInheritanceExample'
assert example.calculate() == (10, 4)

# Cleanup resources
example = None

================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict

class ParentA:
    def __init__(self, a: int):
        self.a = a

    def display_a(self) -> str:
        return f"Value of a: {self.a}"

class ParentB:
    def __init__(self, b: str):
        self.b = b

    def display_b(self) -> str:
        return f"Value of b: {self.b}"

class Child(ParentA, ParentB):
    def __init__(self, a: int, b: str, c: List[int]):


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        ParentA.__init__(self, a)

SUFFIX CODE:
----------------------------------------

        ParentB.__init__(self, b)
        self.c = c

    def display_all(self) -> Dict[str, str]:
        return {
            'a': self.display_a(),
            'b': self.display_b(),
            'c': f"Values in c: {self.c}"
        }

# Test cases to validate the implementation
child = Child(5, 'test', [1, 2, 3])
assert child.display_a() == 'Value of a: 5'
assert child.display_b() == 'Value of b: test'
assert child.display_all() == {'a': 'Value of a: 5', 'b': 'Value of b: test', 'c': 'Values in c: [1, 2, 3]'}

print("All assertions passed!")

JUSTIFICATION:
----------------------------------------
This example demonstrates the use of multiple inheritance and super() calls in Python. The prompt sets up a class hierarchy with ParentA and ParentB, and a Child class that inherits from both. The completion requires the correct use of super() to initialize both parent classes, showcasing the LLM's understanding of complex inheritance structures. The provided assertions verify that the initialization and method calls on the Child class work as expected, ensuring the syntax and functionality are correct.

ASSERTIONS:
----------------------------------------
child = Child(5, 'test', [1, 2, 3])
assert child.display_a() == 'Value of a: 5'
assert child.display_b() == 'Value of b: test'
assert child.display_all() == {'a': 'Value of a: 5', 'b': 'Value of b: test', 'c': 'Values in c: [1, 2, 3]'}

================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict, Callable, TypeVar

T = TypeVar('T')

class DataProcessor:
    def __init__(self, data: List[Dict[str, T]]) -> None:
        self.data = data

    def process(self, transform: Callable[[T], T]) -> List[Dict[str, T]]:

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        result = []
        for item in self.data:
            new_item = {key: transform(value) for key, value in item.items()}
            result.append(new_item)
        return result

SUFFIX CODE:
----------------------------------------

        result = []
        for item in self.data:
            new_item = {key: transform(value) for key, value in item.items()}
            result.append(new_item)
        return result

data = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]
processor = DataProcessor(data)
transformed_data = processor.process(lambda x: x * 2)

assert transformed_data == [{'a': 2, 'b': 4}, {'a': 6, 'b': 8}]

JUSTIFICATION:
----------------------------------------
This test case checks the LLM's ability to handle type hints with complex generics and function annotation syntax. It requires the model to insert a validation check for a callable parameter within a method, ensuring proper syntax and indentation are maintained. The test also verifies the ability to raise appropriate exceptions based on type checking.

ASSERTIONS:
----------------------------------------
data = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]
processor = DataProcessor(data)
try:
    processor.process(123)
except ValueError as e:
    assert str(e) == 'transform must be callable'
else:
    assert False, 'Expected ValueError not raised'

transformed_data = processor.process(lambda x: x * 2)
assert transformed_data == [{'a': 2, 'b': 4}, {'a': 6, 'b': 8}]
================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

class DataLoader:
    async def load_data(self) -> str:
        await asyncio.sleep(1)
        return "data"

class Processor:
    async def process(self, data: str) -> str:
        await asyncio.sleep(1)
        return data.upper()

class ResultSaver:
    async def save(self, result: str) -> None:
        await asyncio.sleep(1)
        print(f"Result saved: {result}")

async def main():
    loader = DataLoader()
    processor = Processor()
    saver = ResultSaver()

    data = await loader.load_data()
    processed_data = await processor.process(data)


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await saver.save(processed_data)

SUFFIX CODE:
----------------------------------------
    print("Processing complete.")

if __name__ == '__main__':
    asyncio.run(main())


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to complete an async/await pattern with proper indentation and nesting. The golden completion demonstrates the correct use of `await` within an asynchronous function and maintains the proper flow of async operations. The test ensures that the LLM understands how to chain async calls and properly await their results.

ASSERTIONS:
----------------------------------------
assert asyncio.run(main()) is None

================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict

class DataProcessor:
    def __init__(self, data: List[Dict[str, int]]):
        self.data = data

    def process_data(self) -> List[Dict[str, int]]:
        result = []
        for item in self.data:
            new_item = {}


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            for key, value in item.items():
                new_item[key] = value * 2

SUFFIX CODE:
----------------------------------------
            result.append(new_item)
        return result

# Example usage
if __name__ == '__main__':
    processor = DataProcessor([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}])
    processed = processor.process_data()
    print(processed)


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to properly complete a nested loop and dictionary manipulation, maintaining the correct indentation and structure. The scenario includes a class method that processes a list of dictionaries, and the expected completion involves iterating over dictionary items and modifying their values. The correct completion ensures that the nested loop and dictionary operations are properly indented and syntactically correct.

ASSERTIONS:
----------------------------------------
processor = DataProcessor([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}])
processed = processor.process_data()
assert processed == [{'a': 2, 'b': 4}, {'a': 6, 'b': 8}], f"Unexpected processed data: {processed}"

================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import TypeVar, Generic

T = TypeVar('T')

class ComplexGeneric(Generic[T]):
    def __init__(self, data: T) -> None:
        self.data = data

    def get_data(self) -> T:
        return self.data

# Example usage
example = ComplexGeneric(

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
[]

SUFFIX CODE:
----------------------------------------
)
assert isinstance(example.get_data(), list)

# Cleanup code if any
# No resources to cleanup in this example


JUSTIFICATION:
----------------------------------------
This test case is useful for evaluating the LLM's capability to handle complex type hints with generics in Python. The completion requires the model to understand how to instantiate a generic class correctly with a specific type. The following suffix then checks the type of the returned data, ensuring proper syntax and type consistency.

ASSERTIONS:
----------------------------------------
example = ComplexGeneric(data=[1, 2, 3])
assert isinstance(example.get_data(), list)
assert example.get_data() == [1, 2, 3]
================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict, TypeVar, Generic

T = TypeVar('T')

class Container(Generic[T]):
    def __init__(self, values: List[T]) -> None:
        self._values = values

    def get_values(self) -> List[T]:
        return self._values

    def add_value(self, value: T) -> None:
        self._values.append(value)

    def __eq__(self, other):
        if not isinstance(other, Container):
            return False
        return self._values == other._values

    def __hash__(self):
        return hash(tuple(self._values))

# The following function uses type hints with complex generics
# It accepts a list of Container objects and returns a dictionary
# mapping each container to its list of values

def process_containers(containers: List[Container[T]]) -> Dict[Container[T], List[T]]:
    result = {}


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    for container in containers:
        result[container] = container.get_values()

SUFFIX CODE:
----------------------------------------
    return result

# Create some container instances and process them
container1 = Container([1, 2, 3])
container2 = Container(['a', 'b', 'c'])
containers = [container1, container2]
processed = process_containers(containers)

assert processed[container1] == [1, 2, 3]
assert processed[container2] == ['a', 'b', 'c']

print('All assertions passed!')


JUSTIFICATION:
----------------------------------------
This test case focuses on type hints with complex generics in Python. The function `process_containers` uses type hints to specify that it takes a list of `Container` objects and returns a dictionary mapping each `Container` to its list of values. The completion involves iterating over the list of containers and filling the dictionary accordingly. This tests the LLM's ability to handle nested type hints and maintain consistent indentation and syntax.

ASSERTIONS:
----------------------------------------
assert process_containers([Container([1, 2]), Container([3, 4])]) == {Container([1, 2]): [1, 2], Container([3, 4]): [3, 4]}

================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict, Any, Union

class DataProcessor:
    def __init__(self, data: List[Dict[str, Any]]) -> None:
        self.data = data

    def process_data(self) -> List[Union[str, int]]:
        processed_data = []
        for item in self.data:
            name = item.get('name')
            age = item.get('age')
            if name and isinstance(age, int):
                processed_data.append(name)
                processed_data.append(age)


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
        return processed_data

data = [{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}]
processor = DataProcessor(data)
result = processor.process_data()
assert result == ['Alice', 30, 'Bob', 25]


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to complete a complex Python syntax pattern involving type hints with complex generics. The scenario demonstrates proper usage of type hints for function arguments and return types. The completion requires the model to follow established indentation and structure, ensuring proper nesting within the function. The golden completion introduces an else block to handle cases where the name or age is missing or invalid, showcasing proper handling of different data conditions.

ASSERTIONS:
----------------------------------------
data = [{'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}, {'name': None, 'age': 'unknown'}, {'name': 'Charlie', 'age': None}]
processor = DataProcessor(data)
result = processor.process_data()
assert result == ['Alice', 30, 'Bob', 25, 'Unknown', -1, 'Unknown', -1]

================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class Base1:
    def greet(self):
        return 'Hello from Base1'

class Base2:
    def greet(self):
        return 'Hello from Base2'

class Derived(Base1, Base2):
    def greet(self):
        base1_greeting = Base1.greet(self)
        base2_greeting = Base2.greet(self)
        return f'{base1_greeting} and {base2_greeting}'

# The Derived class correctly calls methods from both Base1 and Base2 using super()
class AdvancedDerived(Derived):
    def greet(self):
        result = super().greet()


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        result += ' with additional functionality'

SUFFIX CODE:
----------------------------------------
        return f'{result} and Hello from AdvancedDerived'

# Testing the functionality
adv_derived = AdvancedDerived()
assert adv_derived.greet() == 'Hello from Base1 and Hello from Base2 with additional functionality and Hello from AdvancedDerived'


JUSTIFICATION:
----------------------------------------
This test case checks the LLM's ability to correctly handle multiple inheritance and the usage of super() calls in Python. It ensures the model understands how to chain method calls from multiple base classes and add additional behavior in a derived class. The completion must properly integrate with the established method chaining and inheritance pattern, maintaining correct syntax and indentation.

ASSERTIONS:
----------------------------------------
adv_derived = AdvancedDerived()
assert adv_derived.greet() == 'Hello from Base1 and Hello from Base2 with additional functionality and Hello from AdvancedDerived'

================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class Parent1:
    def __init__(self, name):
        self.name = name

    def greet(self):
        return f"Hello from {self.name}"

class Parent2:
    def __init__(self, age):
        self.age = age

    def age_info(self):
        return f"Age is {self.age}"

class Child(Parent1, Parent2):
    def __init__(self, name, age, school):
        Parent1.__init__(self, name)


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        Parent2.__init__(self, age)

SUFFIX CODE:
----------------------------------------
        self.school = school

    def school_info(self):
        return f"School is {self.school}"

child_instance = Child("Alice", 12, "Wonderland High")
assert child_instance.greet() == "Hello from Alice"
assert child_instance.age_info() == "Age is 12"
assert child_instance.school_info() == "School is Wonderland High"


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to correctly implement multiple inheritance and proper usage of the super() calls in Python. The prompt sets up a scenario with two parent classes and a child class that inherits from both. The completion must demonstrate correct initialization of both parent classes within the child's __init__ method. The suffix includes assertions that verify the correct behavior of methods inherited from both parents and the child class, ensuring structural integrity and syntactical correctness.

ASSERTIONS:
----------------------------------------
child_instance = Child("Alice", 12, "Wonderland High")
assert child_instance.greet() == "Hello from Alice"
assert child_instance.age_info() == "Age is 12"
assert child_instance.school_info() == "School is Wonderland High"

================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict, Union

class DataProcessor:
    def process_data(self, data: List[Union[int, str]]) -> Dict[str, int]:
        result = {}
        for item in data:
            if isinstance(item, int):
                result['int'] = result.get('int', 0) + 1
            elif isinstance(item, str):
                result['str'] = result.get('str', 0) + 1


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        return result

SUFFIX CODE:
----------------------------------------
        return result

data = [1, 'a', 2, 'b', 3, 'c']
processor = DataProcessor()
result = processor.process_data(data)
assert result == {'int': 3, 'str': 3}


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to handle complex type hints with generics and properly raise exceptions for unsupported types. It checks if the model can correctly complete the nested if-else structure with proper indentation and error handling.

ASSERTIONS:
----------------------------------------
data = [1, 'a', 2, 'b', 3, 'c']
processor = DataProcessor()
try:
    result = processor.process_data(data)
    assert result == {'int': 3, 'str': 3}
except ValueError as e:
    assert False, f"Unexpected ValueError: {e}"
================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict, Any, Union

# Function with type hints including complex generics
class DataProcessor:
    def __init__(self, data: List[Dict[str, Union[int, str]]]) -> None:
        self.data = data

    def process_data(self) -> List[Dict[str, Any]]:

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        processed_data = []
        for item in self.data:
            processed_item = {}
            for key, value in item.items():
                if isinstance(value, int):
                    processed_item[key] = value * 2
                elif isinstance(value, str):
                    processed_item[key] = value.lower()
                else:
                    processed_item[key] = value
            processed_data.append(processed_item)

SUFFIX CODE:
----------------------------------------

        return processed_data

# Example usage
if __name__ == '__main__':
    sample_data = [
        {'id': 1, 'value': 'A'},
        {'id': 2, 'value': 'B'},
        {'id': 3, 'value': 100}
    ]
    processor = DataProcessor(sample_data)
    result = processor.process_data()
    print(result)

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of type hints with complex generics in Python. The function `process_data` processes a list of dictionaries where the values can be either integers or strings. The completion involves a nested list and dictionary comprehension, which tests the model's ability to handle complex syntax and proper nesting. This example is a good test case as it requires understanding of type annotations, list comprehensions, and conditional logic within comprehensions.

ASSERTIONS:
----------------------------------------
processor = DataProcessor([{'id': 1, 'value': 'A'}, {'id': 2, 'value': 'B'}, {'id': 3, 'value': 100}])
result = processor.process_data()
assert result == [{'id': 2, 'value': 'A'}, {'id': 4, 'value': 'B'}, {'id': 6, 'value': 200}], 'The processed data does not match the expected output'
================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Tuple, Dict

class DataProcessor:
    def process_data(self, data: List[Dict[str, Tuple[int, float]]]) -> List[Dict[str, float]]:
        processed_data = []
        for item in data:
            processed_item = {}


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            for key, (int_val, float_val) in item.items():
                processed_item[key] = float_val

SUFFIX CODE:
----------------------------------------
            processed_data.append(processed_item)
        return processed_data

data = [
    {'values': (1, 2.0)},
    {'values': (2, 3.5)},
]
processor = DataProcessor()
result = processor.process_data(data)
assert isinstance(result, list)
assert all(isinstance(d, dict) for d in result)
assert all('values' in d for d in result)
assert result[0]['values'] == 2.0
assert result[1]['values'] == 3.5


JUSTIFICATION:
----------------------------------------
This test case is a good example of complex generics type hints in Python. It involves nested data structures with lists, dictionaries, and tuples, which are processed within a class method. The completion requires understanding of proper iteration and unpacking of these nested structures, maintaining correct indentation and syntax. The assertions verify that the processed data has the expected structure and values.

ASSERTIONS:
----------------------------------------
assert isinstance(result, list)
assert all(isinstance(d, dict) for d in result)
assert all('values' in d for d in result)
assert result[0]['values'] == 2.0
assert result[1]['values'] == 3.5

================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

class DataFetcher:
    async def fetch_data(self, url: str) -> str:
        print(f"Fetching data from {url}")
        await asyncio.sleep(1)
        return "data from " + url

class DataProcessor:
    async def process_data(self, data: str) -> str:
        print(f"Processing data: {data}")
        await asyncio.sleep(1)
        return data.upper()

async def main():
    fetcher = DataFetcher()
    processor = DataProcessor()
    url = "http://example.com/api"
    raw_data = await fetcher.fetch_data(url)


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    processed_data = await processor.process_data(raw_data)

SUFFIX CODE:
----------------------------------------
    print(f"Processed Data: {processed_data}")
    return processed_data, raw_data, fetcher, processor

if __name__ == "__main__":
    processed_data, raw_data, fetcher, processor = asyncio.run(main())


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to complete an async/await pattern correctly. The context involves fetching and processing data asynchronously, which requires the LLM to understand the async/await syntax, proper indentation, and method chaining. The completion ensures that the async function calls are properly awaited, and the entire flow maintains syntactic correctness.

ASSERTIONS:
----------------------------------------
    assert isinstance(fetcher, DataFetcher)
    assert isinstance(processor, DataProcessor)
    assert raw_data == "data from http://example.com/api"
    assert processed_data == "DATA FROM HTTP://EXAMPLE.COM/API"
    print("All assertions passed!")

================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

class Example:
    async def task(self, name: str, delay: int) -> str:
        await asyncio.sleep(delay)
        return f"Task {name} completed"

    async def run_tasks(self):
        tasks = [
            self.task("A", 1),
            self.task("B", 2),
            self.task("C", 3),
        ]
        results = await asyncio.gather(

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
*tasks

SUFFIX CODE:
----------------------------------------
        )
        for result in results:
            print(result)

example = Example()
asyncio.run(example.run_tasks())


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to correctly complete async/await patterns involving the asyncio.gather method. The prompt sets up an async method and a list of coroutine tasks. The golden completion is '*tasks', which correctly unpacks the list of tasks into the gather method. This is a good test case because it requires understanding of async/await syntax, list unpacking, and the asyncio library.

ASSERTIONS:
----------------------------------------
example = Example()
results = asyncio.run(example.run_tasks())
assert results is None

================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

class AsyncProcessor:
    def __init__(self):
        self.results = []

    async def process(self, value: int) -> int:
        await asyncio.sleep(1)
        return value * 2

    async def gather_results(self, values: list[int]) -> list[int]:
        tasks = []
        for value in values:


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            tasks.append(self.process(value))

SUFFIX CODE:
----------------------------------------
        gathered_results = await asyncio.gather(*tasks)
        self.results.extend(gathered_results)
        return self.results

async def main():
    processor = AsyncProcessor()
    values = [1, 2, 3, 4]
    results = await processor.gather_results(values)
    assert results == [2, 4, 6, 8], f"Unexpected results: {results}"

asyncio.run(main())

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to correctly implement async/await patterns in Python, particularly the creation and management of asyncio tasks. The completion must include the proper use of `asyncio.create_task` and the correct handling of the task list, demonstrating understanding of asynchronous programming structures.

ASSERTIONS:
----------------------------------------
assert asyncio.iscoroutinefunction(AsyncProcessor().process), "process method should be a coroutine function"
assert asyncio.iscoroutinefunction(AsyncProcessor().gather_results), "gather_results method should be a coroutine function"

================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict, Union

class DataProcessor:
    def process_data(self, data: List[Union[int, str]], options: Dict[str, Union[bool, int]]):
        processed_data = []
        for item in data:
            if isinstance(item, int):
                processed_data.append(item * 2)
            elif isinstance(item, str):
                processed_data.append(item.upper())
        
        result = {
            'data': processed_data,
            'options': options
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        return result

SUFFIX CODE:
----------------------------------------
        return result

def main():
    processor = DataProcessor()
    data = [1, 'hello', 2, 'world']
    options = {'verbose': True, 'multiplier': 3}
    result = processor.process_data(data, options)
    print(result)

if __name__ == '__main__':
    main()

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of type hints with complex generics in function annotations within a class method. It requires the completion to maintain the correct syntax and indentation while adding functionality to process and modify the data based on the options provided. The test ensures that the LLM correctly handles nested blocks, type hints, and maintains structural integrity.

ASSERTIONS:
----------------------------------------
processor = DataProcessor()
data = [1, 'hello', 2, 'world']
options = {'verbose': True, 'multiplier': 3}
result = processor.process_data(data, options)
assert result['data'] == [6, 'HELLO', 12, 'WORLD']
assert result['options'] == options
================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict

class DataProcessor:
    def __init__(self, data: List[Dict[str, int]]) -> None:
        self.data = data

    def process_data(self) -> Dict[str, int]:
        result = {}
        for item in self.data:
            for key, value in item.items():
                if key in result:
                    result[key] += value
                else:
                    result[key] = value
        return result

class AdvancedProcessor(DataProcessor):
    def __init__(self, data: List[Dict[str, int]], multiplier: int) -> None:
        super().__init__(data)
        self.multiplier = multiplier

    def process_data(self) -> Dict[str, int]:
        base_result = super().process_data()


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        for key in base_result:
            base_result[key] *= self.multiplier

SUFFIX CODE:
----------------------------------------
        return base_result

# Test the AdvancedProcessor class
sample_data = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]
processor = AdvancedProcessor(sample_data, 10)
result = processor.process_data()

# Assertions to verify correctness
assert result == {'a': 40, 'b': 60}, f"Expected {{'a': 40, 'b': 60}}, but got {result}"

print('All tests passed.')

JUSTIFICATION:
----------------------------------------
This test case is useful because it involves multiple inheritance and super() calls, which are advanced Python features. The completion must correctly use the inherited method, modify its result, and maintain proper indentation and nesting. This scenario tests the LLM's understanding of complex class structures and method overriding in Python.

ASSERTIONS:
----------------------------------------
assert result == {'a': 40, 'b': 60}, f"Expected {{'a': 40, 'b': 60}}, but got {result}"
================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio
import aiohttp

class AsyncHandler:
    async def fetch_data(self, url: str) -> str:
        async with aiohttp.ClientSession() as session:


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            async with session.get(url) as response:
                data = await response.text()

SUFFIX CODE:
----------------------------------------
            return data

    async def process_data(self, data: str) -> dict:
        await asyncio.sleep(1)
        return {'processed': data}

async def main():
    handler = AsyncHandler()
    raw_data = await handler.fetch_data('http://example.com')
    processed_data = await handler.process_data(raw_data)
    assert 'processed' in processed_data

if __name__ == '__main__':
    asyncio.run(main())


JUSTIFICATION:
----------------------------------------
This test case focuses on demonstrating the proper use of async/await patterns and context managers in Python. The completion involves nested async with statements and awaits, which are crucial for maintaining asynchronous flow and resource management. It ensures that the model can handle these complex syntactical structures correctly while maintaining proper indentation and formatting.

ASSERTIONS:
----------------------------------------
assert asyncio.iscoroutinefunction(AsyncHandler.fetch_data)
assert asyncio.iscoroutinefunction(AsyncHandler.process_data)

================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict

class Base:
    def __init__(self, name: str):
        self.name = name

    def get_name(self) -> str:
        return self.name

class DerivedOne(Base):
    def __init__(self, name: str, value: int, **kwargs):
        super().__init__(name, **kwargs)
        self.value = value

    def get_value(self) -> int:
        return self.value

class DerivedTwo(Base):
    def __init__(self, name: str, data: List[str], **kwargs):
        super().__init__(name, **kwargs)
        self.data = data

    def get_data(self) -> List[str]:
        return self.data

class Combined(DerivedOne, DerivedTwo):
    def __init__(self, name: str, value: int, data: List[str]):


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        DerivedOne.__init__(self, name, value)
        DerivedTwo.__init__(self, name, data)

SUFFIX CODE:
----------------------------------------
    def get_all_info(self) -> Dict[str, str]:
        return {
            'name': self.get_name(),
            'value': str(self.get_value()),
            'data': ', '.join(self.get_data())
        }

# Test cases to verify the functionality
combined = Combined('example', 42, ['data1', 'data2'])
assert combined.get_name() == 'example'
assert combined.get_value() == 42
assert combined.get_data() == ['data1', 'data2']
assert combined.get_all_info() == {'name': 'example', 'value': '42', 'data': 'data1, data2'}

print('All assertions passed.')

JUSTIFICATION:
----------------------------------------
This example demonstrates multiple inheritance with the use of super() calls in Python. It tests the LLM's ability to handle complex initialization patterns in a multiple inheritance scenario and ensure proper chaining of constructors. The golden completion is essential for correctly initializing the second parent class.

ASSERTIONS:
----------------------------------------
combined = Combined('example', 42, ['data1', 'data2'])
assert combined.get_name() == 'example'
assert combined.get_value() == 42
assert combined.get_data() == ['data1', 'data2']
assert combined.get_all_info() == {'name': 'example', 'value': '42', 'data': 'data1, data2'}

print('All assertions passed.')
================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

class AsyncHandler:
    async def fetch_data(self, data_id: int) -> str:
        await asyncio.sleep(1)
        return f"Data {data_id}"

    async def handle_data(self, data_id: int) -> str:

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        data = await self.fetch_data(data_id)
        processed_data = data.upper()

SUFFIX CODE:
----------------------------------------

        return processed_data

# Create an instance of the handler and run the async methods
handler = AsyncHandler()

async def main():
    result = await handler.handle_data(123)
    print(result)

# Run the async main function
asyncio.run(main())

JUSTIFICATION:
----------------------------------------
This test case evaluates the model's ability to complete an async function using the async/await pattern correctly. It includes calling another async function within the method and returning the processed data. The model needs to handle the indentation properly and ensure the async/await syntax is used correctly.

ASSERTIONS:
----------------------------------------
handler = AsyncHandler()

async def test_async():
    result = await handler.handle_data(123)
    assert result == 'DATA 123'

asyncio.run(test_async())
================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import TypeVar, Generic, List

T = TypeVar('T')

class Node(Generic[T]):
    def __init__(self, value: T):
        self.value = value
        self.children: List[Node[T]] = []

    def add_child(self, child: 'Node[T]') -> None:

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        self.children.append(child)

SUFFIX CODE:
----------------------------------------
        self.children.append(child)

class Tree(Generic[T]):
    def __init__(self, root: Node[T]):
        self.root = root

    def traverse(self) -> List[T]:
        result: List[T] = []
        def _traverse(node: Node[T]):
            result.append(node.value)
            for child in node.children:
                _traverse(child)
        _traverse(self.root)
        return result

# Example usage
if __name__ == '__main__':
    root = Node(1)
    child1 = Node(2)
    child2 = Node(3)
    root.add_child(child1)
    root.add_child(child2)
    tree = Tree(root)
    assert tree.traverse() == [1, 2, 3]


JUSTIFICATION:
----------------------------------------
This test case involves complex Python syntax features, specifically using type hints with complex generics. The `Node` class is generic and works with any type `T`. The golden completion adds a type check to ensure that only instances of `Node` can be added as children, which is a common pattern in strongly-typed code. This tests the model's ability to handle type annotations and enforce type safety in a generic context.

ASSERTIONS:
----------------------------------------
root = Node(1)
child1 = Node(2)
child2 = Node(3)
invalid_child = 'not a node'
root.add_child(child1)
root.add_child(child2)
try:
    root.add_child(invalid_child)
    assert False, 'TypeError was not raised'
except TypeError as e:
    assert str(e) == 'child must be an instance of Node'
tree = Tree(root)
assert tree.traverse() == [1, 2, 3]

================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import Dict, Union

class Base:
    def __init__(self, name: str):
        self.name = name

class Mixin:
    def mixin_method(self) -> str:
        return 'Mixin method called'

class Derived(Base, Mixin):
    def __init__(self, name: str, value: int):
        super().__init__(name)
        self.value = value

    def derived_method(self) -> Dict[str, Union[str, int]]:
        result = {
            'name': self.name,
            'value': self.value,
            'mixin': self.mixin_method(),


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        }

SUFFIX CODE:
----------------------------------------
        }
        return result

derived_instance = Derived('Example', 42)
result = derived_instance.derived_method()

assert result['name'] == 'Example'
assert result['value'] == 42
assert result['mixin'] == 'Mixin method called'
print('All assertions passed!')


JUSTIFICATION:
----------------------------------------
This is a good test case because it involves multiple inheritance and the use of the super() call to initialize the base class. It also includes a method that returns a complex data structure with type hints. The golden completion demonstrates the correct use of f-string formatting within a dictionary construction, maintaining consistent indentation and proper syntax. This tests the LLM's ability to handle nested structures and complex type annotations.

ASSERTIONS:
----------------------------------------
assert 'description' in result
assert result['description'] == 'Example has value 42'

================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile

class CustomError(Exception):
    pass

class ResourceHandler:
    def __init__(self):
        self.tempfile = None

    def open_tempfile(self):
        self.tempfile = tempfile.NamedTemporaryFile(delete=False)
        return self.tempfile

    def close_tempfile(self):
        if self.tempfile:
            self.tempfile.close()
            os.unlink(self.tempfile.name)

    def process_file(self, filepath: str) -> str:
        # Simulate file processing
        with open(filepath, 'r') as file:
            data = file.read()
            if 'error' in data:
                raise CustomError('Error found in file')
            return data.upper()

handler = ResourceHandler()
try:
    temp_file = handler.open_tempfile()
    with open(temp_file.name, 'w') as f:
        f.write('sample text')

    # Nested try/except/else/finally
    try:
        result = handler.process_file(temp_file.name)


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        print('Processing succeeded:', result)

SUFFIX CODE:
----------------------------------------
        print('Processing succeeded:', result)
    except CustomError as e:
        print('Caught custom error:', e)
    else:
        print('No errors encountered')
finally:
    handler.close_tempfile()

# Assertions to verify the behavior
try:
    assert os.path.exists(temp_file.name) == False, 'Temp file should be deleted'
except AssertionError as e:
    print(e)


JUSTIFICATION:
----------------------------------------
This test case examines the model's capability to handle nested try/except/else/finally blocks with multiple except clauses, ensuring proper error handling and resource management. It also verifies the correct nesting and indentation of complex control structures.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile
import io
import sys

class ResourceHandler:
    def __init__(self):
        self.resource = None

    def setup(self):
        self.resource = tempfile.NamedTemporaryFile(delete=False)
        self.resource.write(b'Initial content')
        self.resource.close()

    def cleanup(self):
        if self.resource:
            os.remove(self.resource.name)

captured_output = io.StringIO()
sys.stdout = captured_output

handler = ResourceHandler()
handler.setup()
resource_path = handler.resource.name

try:
    with open(handler.resource.name, 'r') as file:
        content = file.read()
        if 'Initial' in content:
            # Simulate processing
            for i in range(3):
                if i == 2:
                    raise ValueError('Simulated error')
                else:
                    print(f'Processing step {i}')
        else:
            print('Content not as expected')


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
except ValueError as e:
    print(f'Error occurred: {e}')
else:
    print('Processing completed successfully')
finally:
    handler.cleanup()


JUSTIFICATION:
----------------------------------------
This test case checks the ability of the LLM to complete complex nested control structures, including multiple try/except blocks with different exception handling, and ensures that the LLM can maintain proper indentation and syntax. The prefix sets up a resource, processes it within nested control structures, and expects the LLM to handle a specific exception correctly, followed by cleanup.

ASSERTIONS:
----------------------------------------
sys.stdout = sys.__stdout__
output = captured_output.getvalue()

assert 'Processing step 0' in output
assert 'Processing step 1' in output
assert 'Error occurred: Simulated error' in output

assert not os.path.exists(resource_path), 'File was not cleaned up properly'


================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os

class FileManager:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if self.file:
            self.file.close()

class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name

    def __enter__(self):
        self.connection = self.connect_to_database()
        return self.connection

    def __exit__(self, exc_type, exc_value, traceback):
        if self.connection:
            self.connection.close()

    def connect_to_database(self):
        # Mocking a database connection
        return open(os.devnull, 'w')

filename = 'example.txt'

# Using nested context managers for FileManager and DatabaseConnection
with FileManager(filename) as file_mgr:
    with DatabaseConnection('example_db') as db_conn:


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        file_mgr.write('Data written to file.')
        db_conn.write('Data written to database.')

SUFFIX CODE:
----------------------------------------
        db_conn.write('Data written to database.')

# Ensure file cleanup
assert os.path.exists(filename), 'File should exist after context manager closes.'

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to handle nested context managers, ensuring proper resource management and cleanup. The test focuses on maintaining correct indentation and syntactical structure within the nested context managers.

ASSERTIONS:
----------------------------------------
assert os.path.exists(filename), 'File should be created within context manager.'
assert open(filename).read() == 'Writing to file...', 'File should contain written data.'
================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile

class CustomException(Exception):
    pass

class ResourceHandler:
    def __init__(self, file_path):
        self.file_path = file_path
        self.file = None

    def __enter__(self):
        self.file = open(self.file_path, 'w')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if self.file:
            self.file.close()
        if exc_type:
            raise CustomException('An error occurred')

try:
    with tempfile.NamedTemporaryFile(delete=False) as temp_file:
        temp_file.write(b'Temporary file content')
        temp_file_path = temp_file.name

    with ResourceHandler(temp_file_path) as file:
        file.write('Writing to temp file')
        # Insert nested try/except/else/finally block here


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        try:
            file.write(' More content')
        except Exception as e:
            print(f'Exception caught: {e}')
        else:
            print('No exceptions occurred')
        finally:
            print('Finally block executed')

SUFFIX CODE:
----------------------------------------
        print('End of resource handling')
except CustomException as ce:
    print(f'Caught custom exception: {ce}')


JUSTIFICATION:
----------------------------------------
This test case is a good example of nested control structures, specifically nested try/except/else/finally blocks within a context manager. It ensures that the LLM can correctly handle indentation and proper nesting of multiple exception handling blocks. The scenario also includes resource management and cleanup, making it comprehensive and realistic.

ASSERTIONS:
----------------------------------------
finally:
    assert os.path.exists(temp_file_path), "File should exist before deletion"
    with open(temp_file_path, 'r') as f:
        content = f.read()
    assert 'Writing to temp file' in content, "Should contain first write"
    assert 'More content' in content, "Should contain second write"

    os.remove(temp_file_path)
    print('Temporary file deleted')

================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile

class CustomError(Exception):
    pass

class ResourceHandler:
    def __init__(self):
        self.resource = None

    def __enter__(self):
        self.resource = tempfile.NamedTemporaryFile(delete=False)
        self.resource.write(b'Temporary file content')
        self.resource.flush()
        return self.resource

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.resource:
            self.resource.close()
            os.unlink(self.resource.name)

class AnotherResourceHandler:
    def __init__(self):
        self.resource = None

    def __enter__(self):
        self.resource = tempfile.NamedTemporaryFile(delete=False)
        self.resource.write(b'Another temporary file content')
        self.resource.flush()
        return self.resource

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.resource:
            self.resource.close()
            os.unlink(self.resource.name)

try:
    with ResourceHandler() as res1:


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        raise CustomError('An error occurred in ResourceHandler')

SUFFIX CODE:
----------------------------------------
        print(f'Resource 1: {res1.name}')
    print('Resource 1 handled successfully')
except CustomError as e:
    print(f'Caught custom error: {e}')
finally:
    print('Execution completed')

try:
    with AnotherResourceHandler() as res2:
        print(f'Resource 2: {res2.name}')
    print('Resource 2 handled successfully')
except CustomError as e:
    print(f'Caught custom error: {e}')
finally:
    print('Execution completed')

JUSTIFICATION:
----------------------------------------
This example tests nested context manager usage with proper resource handling and cleanup. The nested context managers ensure that resources are properly managed and cleaned up, even in the presence of exceptions. The test checks for correct indentation, resource handling, and cleanup procedures. Assertions verify that resources are handled and cleaned up correctly, and the completion must properly handle nested context managers.

ASSERTIONS:
----------------------------------------
assert os.path.exists(res1.name) == False
assert os.path.exists(res2.name) == False

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile

class FileProcessor:
    def __init__(self, filename):
        self.filename = filename
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, 'w')
        return self.file

    def __exit__(self, exc_type, exc_value, traceback):
        if self.file:
            self.file.close()

class ErrorLogger:
    def __init__(self, log_filename):
        self.log_filename = log_filename
        self.log_file = None

    def __enter__(self):
        self.log_file = open(self.log_filename, 'a')
        return self.log_file

    def __exit__(self, exc_type, exc_value, traceback):
        if self.log_file:
            self.log_file.close()

try:
    temp_dir = tempfile.mkdtemp()
    input_filename = os.path.join(temp_dir, 'input.txt')
    log_filename = os.path.join(temp_dir, 'log.txt')


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    with FileProcessor(input_filename) as f:
        f.write('Test content')

    with ErrorLogger(log_filename) as log:
        pass

    with open(input_filename, 'r') as f:
        content = f.read()
        assert content == 'Test content', 'Content mismatch'

SUFFIX CODE:
----------------------------------------
    with open(input_filename, 'r') as f:
        content = f.read()
        assert content == 'Test content', 'Content mismatch'


JUSTIFICATION:
----------------------------------------
This example tests the model's ability to handle nested context managers, which is a common pattern in resource management. The nested with statements ensure proper resource handling, with assertions verifying the correctness of operations. This tests the model's understanding of indentation and nesting in complex syntax structures.

ASSERTIONS:
----------------------------------------

    assert os.path.exists(input_filename), 'Input file does not exist'
    assert os.path.exists(log_filename), 'Log file does not exist'
    with open(log_filename, 'r') as log_file:
        log_content = log_file.read()
        assert 'File written successfully' in log_content, 'Log content mismatch'
finally:
    os.remove(input_filename)
    os.remove(log_filename)
    os.rmdir(temp_dir)

================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import os
import tempfile

class FileManager:
    def __init__(self):
        self.temp_file = None

    def __enter__(self):
        self.temp_file = tempfile.NamedTemporaryFile(delete=False)
        return self.temp_file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.temp_file:
            try:
                self.temp_file.close()
            except Exception as e:
                print(f"Error closing file: {e}")
            finally:
                os.remove(self.temp_file.name)

class DatabaseConnection:
    def __init__(self):
        self.connected = False

    def __enter__(self):
        self.connected = True
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.connected = False

    def execute_query(self):
        if not self.connected:
            raise ConnectionError("Not connected to the database")
        return "Query Result"

def perform_operations():
    with FileManager() as file, DatabaseConnection() as db_conn:
        file.write(b"Some initial data\n")
        result = db_conn.execute_query()
        file.write(result.encode())
        

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        file.flush()

SUFFIX CODE:
----------------------------------------

        filename = file.name

        assert os.path.exists(filename)
        assert db_conn.connected

    assert not os.path.exists(filename)
    assert not db_conn.connected

    return filename

print("Operations completed successfully.")


JUSTIFICATION:
----------------------------------------
This test case demonstrates nested context managers and proper resource handling. It ensures that the LLM understands the use of multiple with statements, proper resource management, and cleanup. The golden completion focuses on ensuring data is flushed to the file before proceeding, which is a critical step in file I/O operations.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List
import asyncio

class Base1:
    def greet(self) -> str:
        return 'Hello from Base1'

class Base2:
    def greet(self) -> str:
        return 'Hello from Base2'

class Derived(Base1, Base2):
    async def async_greet(self) -> str:
        await asyncio.sleep(0.1)
        return super().greet()

async def main() -> List[str]:
    d = Derived()
    results = []
    results.append(await d.async_greet())
    # Insert additional async calls here


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    results.append(await d.async_greet())
    return results

SUFFIX CODE:
----------------------------------------
    return results

# Main entry point for async execution
if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    results = loop.run_until_complete(main())
    for result in results:
        print(result)


JUSTIFICATION:
----------------------------------------
This test case demonstrates the combination of multiple inheritance, async/await patterns, and the use of super() calls in Python. It requires the model to understand the proper usage of these features, including handling of async functions and inheritance method resolution order. The golden completion adds an additional async call, which tests the model's ability to maintain correct indentation and syntax within an existing async function.

ASSERTIONS:
----------------------------------------
d = Derived()
loop = asyncio.get_event_loop()
results = loop.run_until_complete(main())
assert len(results) == 2
assert results[0] == 'Hello from Base1'
assert results[1] == 'Hello from Base1'

================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
import asyncio

class BaseA:
    def __init__(self, value):
        self.value = value

    def common_method(self):
        return f"BaseA: {self.value}"

class BaseB:
    def __init__(self, value):
        self.value = value

    def common_method(self):
        return f"BaseB: {self.value}"

class Derived(BaseA, BaseB):
    def __init__(self, value, extra):
        BaseA.__init__(self, value)
        BaseB.__init__(self, value)
        self.extra = extra

    async def async_method(self):
        await asyncio.sleep(1)
        return f"Derived: {self.value}, Extra: {self.extra}"



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
async def main():

SUFFIX CODE:
----------------------------------------
async def main():
    obj = Derived(10, 'extra')
    result = await obj.async_method()
    assert result == 'Derived: 10, Extra: extra'

# Run the async main method
asyncio.run(main())


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's capability to handle multiple inheritance, super() calls, and async/await patterns in Python. The prefix sets up a complex class hierarchy with multiple inheritance and an asynchronous method, creating a realistic scenario where the LLM must correctly implement a method that overrides inherited behavior and integrates asynchronous operations. The assertions check that the method behaves as expected, ensuring structural integrity and syntactic correctness.

ASSERTIONS:
----------------------------------------
obj = Derived(10, 'extra')
assert obj.common_method() == 'Derived: 10, Extra: extra'
assert asyncio.run(obj.async_method()) == 'Derived: 10, Extra: extra'

================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
from typing import List, Dict, Union

class BaseA:
    def __init__(self, a: int):
        self.a = a

    def method_a(self) -> str:
        return f"BaseA: {self.a}"

class BaseB:
    def __init__(self, b: str):
        self.b = b

    def method_b(self) -> str:
        return f"BaseB: {self.b}"

class Derived(BaseA, BaseB):
    def __init__(self, a: int, b: str, c: List[int]):
        BaseA.__init__(self, a)
        BaseB.__init__(self, b)
        self.c = c

    def combined_method(self) -> Dict[str, Union[str, List[int]]]:
        base_a_result = self.method_a()


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        base_b_result = self.method_b()

SUFFIX CODE:
----------------------------------------
        return {
            'BaseA': base_a_result,
            'BaseB': base_b_result,
            'List': self.c
        }

derived = Derived(10, 'test', [1, 2, 3])
result = derived.combined_method()

# Assertions to verify the correctness of the code
assert result['BaseA'] == 'BaseA: 10'
assert result['BaseB'] == 'BaseB: test'
assert result['List'] == [1, 2, 3]


JUSTIFICATION:
----------------------------------------
This test case is a good example of multiple inheritance and the correct use of super() calls in Python. It tests the ability to properly initialize parent classes and merge their initialization logic in a derived class. The provided golden completion ensures that the super() function is used correctly to call the __init__ methods of both base classes, maintaining proper initialization flow and inheritance structure.

ASSERTIONS:
----------------------------------------
assert derived.a == 10
assert derived.b == 'test'
assert derived.c == [1, 2, 3]

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: synthbench-syntax-completion
Language: python
================================================================================

PREFIX CODE:
----------------------------------------
class BaseA:
    def __init__(self, value: int):
        self.value = value

    def display(self) -> str:
        return f"BaseA value: {self.value}"

class BaseB:
    def __init__(self, name: str):
        self.name = name

    def display(self) -> str:
        return f"BaseB name: {self.name}"

class Derived(BaseA, BaseB):
    def __init__(self, value: int, name: str):
        BaseA.__init__(self, value)
        BaseB.__init__(self, name)

    def display(self) -> str:
        baseA_display = BaseA.display(self)
        baseB_display = BaseB.display(self)
        return f"{baseA_display}, {baseB_display}"

# Create an instance of the Derived class


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
derived_instance = Derived(10, "TestName")

SUFFIX CODE:
----------------------------------------
# Display the values
result = derived_instance.display()
print(result)

# Test assertions
assert 'BaseA value: 10' in result
assert 'BaseB name: TestName' in result

# Cleanup resources
# (No resources to clean up in this example)


JUSTIFICATION:
----------------------------------------
This example tests the LLM's understanding of multiple inheritance and proper usage of super() calls. The completion involves initializing a class that inherits from two base classes and ensuring the derived class correctly initializes both base classes. This tests the LLM's ability to handle complex class inheritance structures and maintain correct initialization order, as well as its understanding of method resolution order and proper syntax.

ASSERTIONS:
----------------------------------------
assert derived_instance.value == 10
assert derived_instance.name == 'TestName'
assert derived_instance.display() == 'BaseA value: 10, BaseB name: TestName'

================================================================================
