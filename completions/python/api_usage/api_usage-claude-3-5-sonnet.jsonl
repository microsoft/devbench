{"id": "1", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import asyncio\nfrom tornado.httpclient import AsyncHTTPClient\n\nasync def fetch_url(url):\n    client = AsyncHTTPClient()\n    try:", "suffix": "    finally:\n        client.close()\n    return response.body\n\nasync def main():\n    url = 'http://example.com'\n    response = await fetch_url(url)\n    return response\n\n# Run the async main function\nif __name__ == '__main__':\n    result = asyncio.run(main())\n    print(result)\n", "golden_completion": "        response = await client.fetch(url)", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete an uncommon API usage pattern involving the Tornado AsyncHTTPClient. The completion requires correct usage of the async fetch method and handling the response properly. This uncommon pattern is crucial for testing asynchronous network operations in Tornado, which is less frequently used compared to other async libraries like aiohttp.", "assertions": "    url = 'http://example.com'\n    response = asyncio.run(fetch_url(url))\n    assert response is not None, 'Response should not be None'\n    assert isinstance(response, bytes), 'Response should be in bytes format'\n", "claude-3-5-sonnet": "        response = await client.fetch(url)\n    except Exception as e:\n        print(f\"Error fetching {url}: {e}\")\n        return None"}
{"id": "2", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import boto3\nimport os\nimport uuid\nfrom botocore.exceptions import ClientError\nfrom dotenv import load_dotenv\n\ndef s3_operations():\n    # Load environment variables from .env file\n    load_dotenv()\n\n    # Initialize a session with Amazon S3\n    # Credentials can be configured via environment variables, AWS config file, or parameters\n    s3_client = boto3.client('s3')\n\n    # Create a unique bucket name\n    # Note: S3 bucket names must be globally unique across all AWS accounts\n    bucket_name = f'my-test-bucket-{uuid.uuid4()}'\n    file_name = 'sample.txt'\n\n    try:\n        # Create a new bucket\n        print(f'Creating bucket: {bucket_name}')\n        s3_client.create_bucket(Bucket=bucket_name)\n\n        # File to upload\n        file_content = 'Hello, S3!'\n\n        # Create a sample file if it doesn't exist\n        if not os.path.exists(file_name):\n            with open(file_name, 'w') as f:\n                f.write(file_content)\n\n        # Upload the file to the bucket\n        print(f'Uploading file: {file_name} to bucket: {bucket_name}')\n", "suffix": "        # Check if the file exists in the bucket\n        try:\n            s3_client.head_object(Bucket=bucket_name, Key=file_name)\n            print(f'File {file_name} exists in bucket {bucket_name}')\n        except ClientError as e:\n            if e.response['Error']['Code'] == '404':\n                print(f'File {file_name} does not exist in bucket {bucket_name}')\n            else:\n                raise\n\n        # Delete the file from the bucket\n        print(f'Deleting file: {file_name} from bucket: {bucket_name}')\n        s3_client.delete_object(Bucket=bucket_name, Key=file_name)\n\n        # Delete the bucket\n        print(f'Deleting bucket: {bucket_name}')\n        s3_client.delete_bucket(Bucket=bucket_name)\n\n        print('S3 operations completed successfully')\n\n    except ClientError as e:\n        print(f'Error: {e}')\n        # Clean up if an error occurs\n        try:\n            s3_client.delete_object(Bucket=bucket_name, Key=file_name)\n            s3_client.delete_bucket(Bucket=bucket_name)\n        except:\n            pass\n\n    finally:\n        # Clean up local file\n        if os.path.exists(file_name):\n            os.remove(file_name)\n\nif __name__ == '__main__':\n    s3_operations()\n\n", "golden_completion": "        s3_client.upload_file(file_name, bucket_name, file_name)\n\n", "LLM_justification": "This test case involves using the AWS S3 client to create a bucket and upload a file, which is a common but often misconfigured operation. The test checks if the language model can correctly complete the API call to upload a file using `upload_file`, an uncommon but important function. It includes handling specific exceptions and cleaning up resources, ensuring the code is both robust and follows best practices.", "assertions": "", "claude-3-5-sonnet": "        s3_client.upload_file(file_name, bucket_name, file_name)"}
{"id": "3", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import requests\nfrom dotenv import load_dotenv\nimport os\n\ndef main():\n    # Load environment variables from .env file\n    load_dotenv()\n\n    # Get GitHub token from environment variables\n    github_token = os.getenv('GITHUB_TOKEN')\n\n    if not github_token:\n        print('Error: No GitHub token found in .env file.')\n        return\n\n    # Set up headers with authorization\n    headers = {\n        'Authorization': f'token {github_token}',\n        'Accept': 'application/vnd.github.v3+json'\n    }\n\n    # 1. Get user repositories\n    try:\n        username = 'octocat'  # Example user\n        repos_url = f'https://api.github.com/users/{username}/repos'\n        repos_response = requests.get(repos_url, headers=headers)\n        repos_response.raise_for_status()\n\n        user_repos = repos_response.json()\n        print(f'Found {len(user_repos)} repositories for {username}')\n\n        # Print first few repos\n        for repo in user_repos[:3]:\n            print(f'- {repo[\"name\"]}: {repo.get(\"description\", \"No description\")}')\n        print('...')\n\n    except requests.exceptions.HTTPError as e:\n        print(f'Error fetching repositories: {e}')\n\n", "suffix": "    except requests.exceptions.HTTPError as e:\n        print(f'Failed to create repository: {e}')\n\n        if hasattr(e, 'response') and e.response is not None:\n            try:\n                error_detail = e.response.json()\n                print(f'Error details: {error_detail}')\n            except:\n                print(f'Status code: {e.response.status_code}')\n                print(f'Response text: {e.response.text}')\n\nif __name__ == '__main__':\n    main()\n", "golden_completion": "    # 2. Create a new repository\n    try:\n        create_repo_url = 'https://api.github.com/user/repos'\n        repo_data = {\n            'name': 'test-repo-from-api',\n            'description': 'Test repository created via GitHub API',\n            'private': False\n        }\n\n        create_response = requests.post(create_repo_url, json=repo_data, headers=headers)\n        create_response.raise_for_status()\n\n        new_repo = create_response.json()\n        print(f'Successfully created repository: {new_repo[\"name\"]}')\n        print(f'URL: {new_repo[\"html_url\"]}')\n\n", "LLM_justification": "This scenario tests the LLM's ability to correctly use the GitHub API to create a repository and handle potential HTTP errors appropriately. It demonstrates a realistic API usage pattern, including proper error handling and response parsing. The example includes setup and usage of the GitHub API with token authentication, making it a comprehensive test case.", "assertions": "", "claude-3-5-sonnet": "    # 2. Create a new repository\n    try:\n        new_repo_name = 'test-repo'\n        new_repo_description = 'A test repository created via GitHub API'\n        create_repo_url = 'https://api.github.com/user/repos'\n        repo_data = {\n            'name': new_repo_name,\n            'description': new_repo_description,\n            'private': False\n        }\n        create_repo_response = requests.post(create_repo_url, json=repo_data, headers=headers)\n        create_repo_response.raise_for_status()\n\n        new_repo = create_repo_response.json()\n        print(f'Successfully created repository: {new_repo[\"name\"]}')\n        print(f'Repository URL: {new_repo[\"html_url\"]}')\n"}
{"id": "4", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import os\nimport json\nimport boto3\nfrom dotenv import load_dotenv\nfrom botocore.exceptions import NoCredentialsError\n\nload_dotenv()\n\n# Initialize a session using Amazon S3\nsession = boto3.Session(\n    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),\n    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),\n    region_name=os.getenv('AWS_REGION')\n)\ns3 = session.resource('s3')\n\n# Function to upload a file to an S3 bucket\nbucket_name = os.getenv('S3_BUCKET_NAME')\nif not bucket_name:\n    print('Error: S3_BUCKET_NAME not set in .env file')\n    exit(1)\n\nfile_name = 'test.txt'\n\n# Create a test file to upload\ndef create_test_file(file_name, content):\n    with open(file_name, 'w') as f:\n        f.write(content)\n\ncreate_test_file(file_name, 'This is a test file.')\n\ntry:\n    # Verify the file was created\n    assert os.path.exists(file_name), 'Test file was not created'\n\n    # Upload the file\n", "suffix": "    print(f'Successfully uploaded {file_name} to {bucket_name}')\n\n    # Download and verify the file\n    s3.Bucket(bucket_name).download_file(file_name, 'downloaded_test.txt')\n    assert os.path.exists('downloaded_test.txt'), 'File was not uploaded to the bucket'\n\n", "golden_completion": "    s3.Bucket(bucket_name).upload_file(file_name, file_name)\n", "LLM_justification": "This example tests the model's ability to recognize and complete the pattern of uploading a file to an AWS S3 bucket using the Boto3 library. The API usage involves setting up a session, handling credentials, creating a resource, and using the correct method to upload a file. The pattern includes the proper handling of exceptions and cleanup operations, making it a comprehensive test for rare API usage capabilities.", "assertions": "    with open('downloaded_test.txt', 'r') as f:\n        content = f.read()\n    assert content == 'This is a test file.', 'File content does not match'\n\nexcept NoCredentialsError:\n    print('Credentials not available')\nexcept AssertionError as e:\n    print(f'Test failed: {e}')\nfinally:\n    # Clean up - remove files after all tests are complete\n    if os.path.exists(file_name):\n        os.remove(file_name)\n    if os.path.exists('downloaded_test.txt'):\n        os.remove('downloaded_test.txt')\n\n", "claude-3-5-sonnet": "    s3.Bucket(bucket_name).upload_file(file_name, file_name)"}
{"id": "5", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import boto3\nimport json\nfrom moto import mock_aws\n\n# Initialize the mock S3 service\nclass S3Client:\n    def __init__(self, bucket_name):\n        self.s3 = boto3.client('s3', region_name='us-east-1')\n        self.bucket_name = bucket_name\n        self.s3.create_bucket(Bucket=bucket_name)\n\n    def upload_json(self, key, data):\n        self.s3.put_object(Bucket=self.bucket_name, Key=key, Body=json.dumps(data))\n\n    def list_objects(self):\n        response = self.s3.list_objects_v2(Bucket=self.bucket_name)\n        return [item['Key'] for item in response.get('Contents', [])]\n\n    def delete_object(self, key):\n        self.s3.delete_object(Bucket=self.bucket_name, Key=key)\n\nwith mock_aws():\n    # Create the S3 client and upload JSON data\n    client = S3Client('test-bucket')\n    client.upload_json('test.json', {'key': 'value'})\n\n", "suffix": "    client.delete_object('test.json')\n\n", "golden_completion": "    uploaded_objects = client.list_objects()\n    assert 'test.json' in uploaded_objects\n\n", "LLM_justification": "This test case uses the AWS SDK for Python (boto3) with the moto library to mock AWS S3 interactions. It tests the ability to correctly perform uncommon S3 operations such as listing and deleting objects after uploading JSON data. The golden completion verifies that the 'test.json' file was successfully uploaded to the mock S3 bucket, which is a rare but valid operation pattern.", "assertions": "    # List objects to ensure deletion\n    remaining_objects = client.list_objects()\n    assert 'test.json' not in remaining_objects\n\n    client.s3.delete_bucket(Bucket='test-bucket')\n\n", "claude-3-5-sonnet": "    # List objects before deletion\n    print(\"Objects before deletion:\", client.list_objects())\n\n    # Delete the object\n    client.delete_object('test.json')\n\n    # List objects after deletion\n    print(\"Objects after deletion:\", client.list_objects())"}
{"id": "6", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef create_sparse_matrix():\n    dense_matrix = np.array([[0, 0, 3], [4, 0, 0], [0, 5, 0]])\n    # Using csr_matrix from scipy.sparse to create a compressed sparse row matrix\n    sparse_matrix = csr_matrix(dense_matrix)\n", "suffix": "\n    return sparse_matrix\n\nsparse_matrix = create_sparse_matrix()\n\n# Assertions to check the correctness of the sparse matrix\nassert sparse_matrix.shape == (3, 3), 'Shape of the matrix is incorrect'\nassert sparse_matrix.nnz == 3, 'Number of non-zero elements is incorrect'\nassert (sparse_matrix.toarray() == np.array([[0, 0, 3], [4, 0, 0], [0, 5, 0]])).all(), 'Matrix contents are incorrect'\n\n# Cleanup code (not needed here as we are using in-memory structures)\n", "golden_completion": "    sparse_matrix.eliminate_zeros()\n", "LLM_justification": "This test case is a good example of using a rare function from the scipy.sparse library. The `eliminate_zeros` method is not commonly used but is crucial in scenarios where the matrix might have explicit zeros that need to be removed. This ensures the model's capability to handle such rare API usages. The assertions verify the shape, number of non-zero elements, and the contents of the sparse matrix to ensure correctness.", "assertions": "assert sparse_matrix.shape == (3, 3), 'Shape of the matrix is incorrect'\nassert sparse_matrix.nnz == 3, 'Number of non-zero elements is incorrect'\nassert (sparse_matrix.toarray() == np.array([[0, 0, 3], [4, 0, 0], [0, 5, 0]])).all(), 'Matrix contents are incorrect'", "claude-3-5-sonnet": "    # No additional code needed here"}
{"id": "7", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import asyncio\nimport aiohttp\n\nasync def fetch(session, url):\n    async with session.get(url) as response:\n        return await response.text()\n\nasync def main():\n    async with aiohttp.ClientSession() as session:", "suffix": "\n        try:\n            result = await fetch(session, 'https://httpbin.org/get')\n            print(result)\n        finally:\n            await session.close()\n\n# Run the asyncio event loop\nasyncio.run(main())", "golden_completion": "\n        await session._request('GET', 'https://httpbin.org/get')", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use the aiohttp library's internal _request method, which is less commonly used directly by developers. The completion uses the internal method with appropriate parameters. This case also ensures the LLM can handle asyncio's asynchronous context and aiohttp's session management correctly.", "assertions": "assert asyncio.run(main()) is None\n", "claude-3-5-sonnet": "        pass"}
{"id": "8", "testsource": "synthbench-api-usage", "language": "python", "prefix": "from tornado.ioloop import IOLoop\nfrom tornado.httpclient import AsyncHTTPClient, HTTPResponse\n\nasync def fetch_url(url):\n    client = AsyncHTTPClient()\n    try:\n        response = await client.fetch(url)\n", "suffix": "        return response\n    except Exception as e:\n        print(f'Error fetching {url}: {e}')\n        return None\n\nif __name__ == '__main__':\n    loop = IOLoop.current()\n    result = loop.run_sync(lambda: fetch_url('http://www.example.com'))\n    if result:\n        print(result.body)\n", "golden_completion": "        assert isinstance(response, HTTPResponse)\n        assert response.code == 200\n", "LLM_justification": "This is a good test case because it leverages the Tornado framework's AsyncHTTPClient for making asynchronous HTTP requests, which is less common compared to other libraries like requests or aiohttp. The example also demonstrates proper error handling and assertion checks for ensuring correct response types and status codes. It tests the model's ability to recognize and complete code patterns involving asynchronous HTTP requests and Tornado's specific API.", "assertions": "        assert isinstance(result, HTTPResponse)\n        assert result.code == 200\n", "claude-3-5-sonnet": "        if isinstance(response, HTTPResponse):"}
{"id": "9", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import asyncio\nfrom tornado.ioloop import IOLoop\nfrom tornado.platform.asyncio import AsyncIOMainLoop\n\nasync def async_task():\n    await asyncio.sleep(1)\n    return 'Task Complete'\n\nasync def main():\n    # Initialize AsyncIOMainLoop to use asyncio's event loop\n    AsyncIOMainLoop().install()\n\n", "suffix": "    # Add a callback to print the result when done\n    loop.add_future(future, lambda f: print(f.result()))\n\n    # Wait for the future to complete instead of starting the loop\n    result = await future\n\n    return result\n\nif __name__ == '__main__':\n    result = asyncio.run(main())\n", "golden_completion": "    # Get the current IOLoop\n    loop = IOLoop.current()\n\n    # Schedule the task\n    future = asyncio.ensure_future(async_task())\n\n", "LLM_justification": "This test case involves the use of Tornado's IOLoop with asyncio, which is a rare but valid usage pattern. It demonstrates the integration of Tornado's event loop with asyncio's coroutine support, ensuring the correct parameter ordering and API behavior. The completion requires the model to recognize the need to start the Tornado IOLoop to process the future and properly finalize the asyncio task.", "assertions": "    print(f'Result: {result}')\n    assert result == 'Task Complete'\n\n", "claude-3-5-sonnet": "    # Create a new event loop\n    loop = asyncio.get_event_loop()\n\n    # Create a future for the async_task\n    future = asyncio.ensure_future(async_task())"}
{"id": "10", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cProfile\nimport pstats\nfrom io import StringIO\n\ndef profile_function(func):\n    def wrapper(*args, **kwargs):\n        pr = cProfile.Profile()\n        pr.enable()", "suffix": "        pr.disable()\n        s = StringIO()\n        sortby = 'cumulative'\n        ps = pstats.Stats(pr, stream=s).sort_stats(sortby)\n        ps.print_stats()\n        wrapper.profiler_output = s.getvalue()\n        print(wrapper.profiler_output)\n        return result\n    wrapper.profiler_output = \"\"\n    return wrapper\n\n@profile_function\ndef test_function():\n    total = 0\n    for i in range(10000):\n        total += i\n    return total\n\n# Call the decorated function\ntest_result = test_function()\n", "golden_completion": "        result = func(*args, **kwargs)", "LLM_justification": "This test case uses the cProfile module to profile a simple function. This is a valuable test case because it verifies the LLM's ability to correctly implement function profiling using cProfile, which is a less commonly used debugging and profiling tool. The scenario also involves proper resource handling and ensures that the function's result is returned correctly after profiling.", "assertions": "assert 'ncalls' in test_function.profiler_output\nassert test_result == 49995000", "claude-3-5-sonnet": "        result = func(*args, **kwargs)"}
{"id": "11", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import sqlite3\n\n# Connect to an in-memory SQLite database\nconn = sqlite3.connect(':memory:')\ncursor = conn.cursor()\n\n# Create a sample table\ncursor.execute('''CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)''')\n\n# Insert sample data\ncursor.execute('''INSERT INTO test (name) VALUES ('Alice')''')\ncursor.execute('''INSERT INTO test (name) VALUES ('Bob')''')\n\n# Commit the transaction\nconn.commit()\n\n# Function to fetch all rows\n", "suffix": "\n\n# Fetch and print all rows\nrows = fetch_all_rows()\nprint(rows)\n\n# Close the connection\nconn.close()", "golden_completion": "def fetch_all_rows():\n    cursor.execute('''SELECT * FROM test''')\n    return cursor.fetchall()\n\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern using the sqlite3 library, particularly focusing on creating, inserting, and fetching data from a table in an SQLite database. The completion involves a less common API usage of the sqlite3 module, showcasing the ability to fetch all rows from a table. The test case ensures that the model correctly follows the established pattern and API conventions, including correct parameter ordering and proper resource management.", "assertions": "assert rows == [(1, 'Alice'), (2, 'Bob')], f'Unexpected rows fetched: {rows}'\n", "claude-3-5-sonnet": "def fetch_all_rows():\n    cursor.execute('SELECT * FROM test')\n    return cursor.fetchall()"}
{"id": "12", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import numpy as np\nfrom scipy.sparse import csr_matrix\n\n# Create a dense matrix\nmatrix = np.array([[0, 0, 3], [4, 0, 0], [0, 2, 0]])\n\n# Convert the dense matrix to a sparse matrix format\nsparse_matrix = csr_matrix(matrix)\n\n# Define a function to demonstrate advanced indexing with a sparse matrix\ndef advanced_sparse_indexing(sparse_mat):\n    # Use fancy indexing to retrieve elements\n    rows = np.array([0, 1, 2])\n    cols = np.array([2, 0, 1])\n", "suffix": "\n    return elements\n\n# Call the function and store the result\nresult = advanced_sparse_indexing(sparse_matrix)\n\n# Assertions\nexpected_result = np.array([3, 4, 2])\nnp.testing.assert_array_equal(result, expected_result)\n\n# Cleanup resources (none needed in this case)\n# No external resources to clean up\n", "golden_completion": "    elements = np.array(sparse_mat[rows, cols]).flatten()", "LLM_justification": "This test case is valuable because it involves the use of advanced indexing techniques with sparse matrices, which are less commonly used than their dense counterparts. The completion demonstrates knowledge of converting sparse matrix slices to dense format and correctly uses NumPy indexing conventions. The assertions ensure the output is as expected, verifying correct API usage and parameter ordering.", "assertions": "", "claude-3-5-sonnet": "    elements = sparse_mat[rows, cols].A.flatten()"}
{"id": "13", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef create_sparse_matrix():\n    dense_matrix = np.array([[0, 0, 3], [4, 0, 0], [0, 5, 0]])\n    sparse_matrix = csr_matrix(dense_matrix)\n    return sparse_matrix\n\nsparse_matrix = create_sparse_matrix()\n\n# Retrieve specific elements using advanced indexing\n", "suffix": "\n# Test if specific elements match expected values\nassert sparse_matrix[0, 2] == 3\nassert sparse_matrix[1, 0] == 4\nassert sparse_matrix[2, 1] == 5\nassert sparse_matrix[0, 1] == 0\nassert sparse_matrix[1, 2] == 0\n\nprint(\"All assertions passed.\")", "golden_completion": "element_0_2 = sparse_matrix[0, 2]\nelement_1_0 = sparse_matrix[1, 0]\nelement_2_1 = sparse_matrix[2, 1]\nelement_0_1 = sparse_matrix[0, 1]\nelement_1_2 = sparse_matrix[1, 2]", "LLM_justification": "This example tests the LLM's ability to recognize and complete patterns involving the creation and manipulation of sparse matrices using the SciPy library. Advanced indexing in sparse matrices is uncommon but valid, and the pattern should be correctly identified and completed. The example ensures proper API usage and parameter ordering, and the assertions verify that the retrieved elements match expected values.", "assertions": "assert element_0_2 == 3\nassert element_1_0 == 4\nassert element_2_1 == 5\nassert element_0_1 == 0\nassert element_1_2 == 0", "claude-3-5-sonnet": "element_00 = sparse_matrix[0, 0]\nelement_02 = sparse_matrix[0, 2]\nelement_10 = sparse_matrix[1, 0]\nelement_21 = sparse_matrix[2, 1]"}
{"id": "14", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import asyncio\nfrom asyncio import StreamReader, StreamWriter\n\nasync def handle_client(reader: StreamReader, writer: StreamWriter):\n    data = await reader.read(100)\n    message = data.decode()\n    addr = writer.get_extra_info('peername')\n    print(f'Received {message} from {addr}')\n", "suffix": "async def test_client():\n    # Connect to the server\n    reader, writer = await asyncio.open_connection('127.0.0.1', 8888)\n\n    # Send a test message\n    test_message = b'TestMessage'\n    writer.write(test_message)\n    await writer.drain()\n\n    # Get the response\n    response_data = await reader.readline()\n    response = response_data.decode()\n\n    # Close the connection\n    writer.close()\n    await writer.wait_closed()\n\n    # Make assertions\n    assert response == f'Hello 127.0.0.1\\n'\n    print('Client test passed!')\n    return test_message, response\n\nasync def main():\n    # Start the server\n    server = await asyncio.start_server(handle_client, '127.0.0.1', 8888)\n    addr = server.sockets[0].getsockname()\n    print(f'Serving on {addr}')\n\n    # Create a task for the server\n    server_task = asyncio.create_task(server.serve_forever())\n\n    # Give the server a moment to start\n    await asyncio.sleep(0.1)\n\n    # Run the test client\n    test_message, response = await test_client()\n\n", "golden_completion": "    response = f'Hello {addr[0]}\\n'\n    writer.write(response.encode())\n    await writer.drain()\n    writer.close()\n    await writer.wait_closed()\n\n", "LLM_justification": "This test case is a good example of using asyncio's StreamReader and StreamWriter to handle a network connection. It involves reading data from a client, processing it, sending a response, and properly closing the connection. The golden completion demonstrates proper usage of asyncio's StreamWriter methods, including write, drain, close, and wait_closed. This is uncommon and tests the LLM's ability to handle async network patterns accurately.", "assertions": "    # Verify the results in the main scope\n    assert test_message == b'TestMessage'\n    assert response == 'Hello 127.0.0.1\\n'\n\n    # Cancel the server taskn\n    server_task.cancel()\n\n    print('All tests passed!')\n\n# Run everything\nasyncio.run(main())\n\n", "claude-3-5-sonnet": "    # Prepare the response\n    response = f'Hello {addr[0]}\\n'\n    writer.write(response.encode())\n    await writer.drain()\n\n    # Close the connection\n    writer.close()\n    await writer.wait_closed()\n"}
{"id": "15", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import numpy as np\nfrom scipy.sparse import csr_matrix\n\n# Creating a dense matrix\nmatrix = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0]])\n# Converting the dense matrix to a sparse CSR matrix\nsparse_matrix = csr_matrix(matrix)\n# Initializing a new sparse matrix to store results\nresult_matrix = csr_matrix((3, 3))\n\ntry:\n    # Adding the sparse matrix to the result matrix\n    result_matrix = result_matrix + sparse_matrix\n", "suffix": "\n    # Performing advanced slicing on the sparse matrix\n    sub_matrix = result_matrix[1:, :2]\n\nfinally:\n    # Cleanup code, no specific resource to clean\n    pass\n", "golden_completion": "    # Multiplying the sparse matrix with its transpose\n    result_matrix = result_matrix.dot(sparse_matrix.T)\n", "LLM_justification": "This is a good test case because it uses advanced features of the SciPy sparse matrix library, including matrix addition and multiplication with its transpose. These operations are less commonly used compared to basic operations. The completion demonstrates understanding of the API by correctly applying the `.dot()` method for matrix multiplication, which is specific to sparse matrices. Assertions will verify the correctness of the matrix operations.", "assertions": "assert (result_matrix != sparse_matrix).nnz > 0, 'Matrix multiplication result should not equal the original sparse matrix'\nassert result_matrix.shape == (3, 3), 'Resulting matrix should maintain the original shape'\nassert result_matrix.nnz == 3, 'Resulting matrix should have exactly 3 non-zero elements'", "claude-3-5-sonnet": "except Exception as e:\n    print(f\"An error occurred: {e}\")"}
{"id": "16", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import asyncio\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.backends import default_backend\n\nasync def generate_rsa_key_pair():\n    # Generate a private key for use in the RSA algorithm\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n        backend=default_backend()\n    )\n", "suffix": "\n    return private_key, public_key\n\nasync def main():\n    private_key, public_key = await generate_rsa_key_pair()\n    # Serialize private key to PEM format\n    private_pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.TraditionalOpenSSL,\n        encryption_algorithm=serialization.NoEncryption()\n    )\n    # Serialize public key to PEM format\n    public_pem = public_key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo\n    )\n    # Verify that the keys are correctly generated and serialized\n    assert private_pem.startswith(b'-----BEGIN RSA PRIVATE KEY-----')\n    assert public_pem.startswith(b'-----BEGIN PUBLIC KEY-----')\n\n", "golden_completion": "    # Generate the public key from the private key\n    public_key = private_key.public_key()\n", "LLM_justification": "This is a good test case as it uses the `cryptography` library, which is a less common but highly important library for cryptographic operations. The pattern of generating RSA key pairs and serializing them to PEM format is clearly established. The completion correctly includes the step of generating the public key from the private key, which is a crucial part of the process. The assertions check that the generated keys are in the correct PEM format, ensuring the API usage is correct and parameters are properly ordered.", "assertions": "    # Add the assertions that were previously in the global scope\n    assert private_key is not None\n    assert public_key is not None\n    assert isinstance(private_key, rsa.RSAPrivateKey)\n    assert isinstance(public_key, rsa.RSAPublicKey)\n\n    print(\"Keys generated and serialized correctly.\")\n\nasyncio.run(main())\n\n", "claude-3-5-sonnet": "    # Get the public key from the private key\n    public_key = private_key.public_key()"}
{"id": "17", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import numpy as np\nfrom scipy.sparse import csr_matrix\n\n# Create a sparse matrix using SciPy\nsparse_matrix = csr_matrix((3, 3), dtype=np.int8)\n\n# Populate the sparse matrix with some values\nsparse_matrix[0, 1] = 1\nsparse_matrix[1, 2] = 2\nsparse_matrix[2, 0] = 3\n\n# Extract the diagonal of the sparse matrix using the diagonal method\n", "suffix": "\n# Verify the diagonal values\nassert np.array_equal(diagonal_values, np.array([0, 0, 0]))\n\n# Cleanup resources (no explicit cleanup needed for scipy sparse matrices)\n", "golden_completion": "diagonal_values = sparse_matrix.diagonal()\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and correctly use the `diagonal` method of SciPy's sparse matrix class (`csr_matrix`). This method is less commonly used, but it's crucial for extracting the diagonal of a sparse matrix without converting it to a dense format. Correctly using this method involves understanding that it returns a NumPy array and knowing how to verify its contents appropriately.", "assertions": "assert np.array_equal(diagonal_values, np.array([0, 0, 0]))\n", "claude-3-5-sonnet": "diagonal_values = sparse_matrix.diagonal()"}
{"id": "18", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import numpy as np\nfrom scipy.sparse import coo_matrix\n\ndef create_sparse_matrix():\n    row = np.array([0, 3, 1, 0])\n    col = np.array([0, 3, 1, 2])\n    data = np.array([4, 5, 7, 9])\n    # Create a COO sparse matrix\n    sparse_matrix = coo_matrix((data, (row, col)), shape=(4, 4))\n    return sparse_matrix\n\nsparse_matrix = create_sparse_matrix()\n\n# Accessing data within the sparse matrix\n", "suffix": "\n# Convert to dense format for easy inspection\nassert (dense_matrix == np.array([[4, 0, 9, 0], [0, 7, 0, 0], [0, 0, 0, 0], [0, 0, 0, 5]])).all()\n\n# Cleanup code (if any)\n# No explicit cleanup needed for this example\n", "golden_completion": "dense_matrix = sparse_matrix.toarray()\n", "LLM_justification": "This test case demonstrates the use of the scipy.sparse.coo_matrix to create a sparse matrix and convert it to a dense format. The coo_matrix is a less commonly used feature in the SciPy library, and the pattern established here involves creating the matrix, accessing its properties, and converting it to a dense format for verification. The assertions check the number of non-zero entries and the correctness of the dense matrix conversion. This scenario tests the model's ability to handle advanced scientific computing features and maintain proper API usage and parameter conventions.", "assertions": "assert sparse_matrix.nnz == 4  # Number of non-zero entries\nassert (dense_matrix == np.array([[4, 0, 9, 0], [0, 7, 0, 0], [0, 0, 0, 0], [0, 0, 0, 5]])).all()\n", "claude-3-5-sonnet": "dense_matrix = sparse_matrix.toarray()"}
{"id": "19", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import asyncio\nfrom concurrent.futures import ProcessPoolExecutor\n\n", "suffix": "async def run_blocking_tasks():\n    loop = asyncio.get_running_loop()\n    with ProcessPoolExecutor() as executor:\n        result = await loop.run_in_executor(executor, blocking_task)\n\n    return result\n\n", "golden_completion": "def blocking_task():\n    total = 0\n    for i in range(1000000):\n        total += i\n    return total\n\n", "LLM_justification": "This is a good test case because it involves the use of asyncio with ProcessPoolExecutor, which is a less common pattern for handling CPU-bound tasks in an asynchronous environment. The completion requires understanding how to correctly define a blocking task function and run it using asyncio's run_in_executor method. This tests the model's ability to handle concurrent programming with asyncio and multiprocessing, ensuring proper function definition and parameter handling.", "assertions": "if __name__ == '__main__':\n    result = asyncio.run(run_blocking_tasks())\n    print(f\"Result: {result}\")\n    assert result == sum(range(1000000))\n", "claude-3-5-sonnet": "async def run_blocking_tasks():\n    loop = asyncio.get_running_loop()\n    with ProcessPoolExecutor() as executor:\n        result = await loop.run_in_executor(executor, blocking_task)\n\n    return result\n\ndef blocking_task():\n    # Simulate a time-consuming task\n    import time\n    time.sleep(5)\n    return \"Task completed\""}
{"id": "20", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import asyncio\nimport signal\nimport platform\n\nasync def run_server():\n    server = await asyncio.start_server(handle_client, '127.0.0.1', 8888)\n    loop = asyncio.get_running_loop()\n\n    # Only add signal handlers on Unix-like platforms\n    if platform.system() != \"Windows\":\n", "suffix": "async def shutdown(loop, server):\n    server.close()\n    await server.wait_closed()\n\nasync def handle_client(reader, writer):\n    data = await reader.read(100)\n    message = data.decode()\n    writer.write(data)\n    await writer.drain()\n    writer.close()\n    await writer.wait_closed()\n\nasync def main():\n    server, loop = await run_server()\n\n    assert loop.is_running(), 'Event loop is not running'\n\n    # Only test signal handlers on Unix-like platforms\n    if platform.system() != \"Windows\":\n        try:\n            sigint_handler = signal.getsignal(signal.SIGINT)\n            sigterm_handler = signal.getsignal(signal.SIGTERM)\n", "golden_completion": "        for signame in {'SIGINT', 'SIGTERM'}:\n            loop.add_signal_handler(\n                getattr(signal, signame),\n                lambda: asyncio.create_task(shutdown(loop, server))\n            )\n\n    return server, loop\n\n", "LLM_justification": "This example tests the model's ability to handle signal handling in asyncio, which is an uncommon but important aspect of network programming. The completion adds signal handlers for SIGINT and SIGTERM to gracefully shut down the server. This pattern is rare but vital for creating robust network applications.", "assertions": "            assert sigint_handler is not None, 'SIGINT handler not set'\n            assert sigterm_handler is not None, 'SIGTERM handler not set'\n        except (AttributeError, ValueError):\n            print(\"Signal testing skipped - unsupported signals\")\n    else:\n        print(\"Signal handling tests skipped on Windows\")\n\n    await asyncio.sleep(1)\n\n    await shutdown(loop, server)\n\nif __name__ == '__main__':\n    asyncio.run(main())\n", "claude-3-5-sonnet": "        loop.add_signal_handler(signal.SIGINT, lambda: asyncio.create_task(shutdown(loop, server)))\n        loop.add_signal_handler(signal.SIGTERM, lambda: asyncio.create_task(shutdown(loop, server)))\n\n    await server.serve_forever()\n"}
{"id": "21", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import tkinter as tk\nfrom tkinter import messagebox\n\n# 1. Override messagebox functions to prevent popups\noriginal_showinfo = messagebox.showinfo\nmessagebox.showinfo = lambda **kwargs: None  # Return None instead of showing popup\n\n# 2. Store original Tk class\noriginal_tk = tk.Tk\n\n# 3. Override Tk to create hidden windows by default\nclass HiddenTk(original_tk):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.withdraw()  # Immediately hide the window\n\n    def mainloop(self, *args, **kwargs):\n        # Skip mainloop in test mode\n        pass\n\n# 4. Replace tk.Tk with our hidden version\ntk.Tk = HiddenTk\n\nclass App:\n    def __init__(self, root):\n        self.root = root\n        self.button = tk.Button(root, text='Click me', command=self.on_click)\n        self.button.pack()\n\n    def on_click(self):\n        # Using messagebox with a rare combination of parameters\n        # Provide some information: 'Hello, world!'\n", "suffix": "        self.root.quit()\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    app = App(root)\n    app.on_click()\n    root.mainloop()\n\n", "golden_completion": "        messagebox.showinfo(title='Information', message='Hello, world!', icon='warning')\n", "LLM_justification": "This test case is designed to evaluate the model's ability to recognize and complete patterns involving tkinter's messagebox with uncommon parameter combinations. The completion includes the use of the 'icon' parameter with 'showinfo', which is less commonly used. This scenario tests the model's understanding of tkinter's messagebox API and proper parameter usage.", "assertions": "root = tk.Tk()\napp = App(root)\napp.on_click()\nassert app.button['text'] == 'Click me', 'Button text should be \"Click me\"'\nroot.destroy()\n", "claude-3-5-sonnet": "        messagebox.showinfo(title=\"Information\", message=\"Hello, world!\")"}
{"id": "22", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import tkinter as tk\nfrom tkinter import ttk\n\n# 1. Store original Tk class\noriginal_tk = tk.Tk\n\n# 2. Override Tk to create hidden windows by default\nclass HiddenTk(original_tk):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.withdraw()  # Immediately hide the window\n\n    def mainloop(self, *args, **kwargs):\n        # Skip mainloop in test mode\n        pass\n\n# 3. Replace tk.Tk with our hidden version\ntk.Tk = HiddenTk\n\nclass App:\n    def __init__(self, root):\n        self.root = root\n        self.root.title('Test App')\n\n        # Using a less common widget: Combobox with custom completion\n        self.combobox = ttk.Combobox(root)\n        self.combobox['values'] = ('Option 1', 'Option 2', 'Option 3')\n        self.combobox.pack()\n\n        # Attaching event for selection change\n        self.combobox.bind('<<ComboboxSelected>>', self.on_select)\n\n    def on_select(self, event):\n", "suffix": "def run_tests():\n    root = tk.Tk()\n    app = App(root)\n\n    for option in ('Option 1', 'Option 2', 'Option 3'):\n        app.combobox.set(option)\n        app.on_select(None)\n\n    root.destroy()\n    print(\"All tests passed!\")\n\nif __name__ == '__main__':\n    run_tests()\n", "golden_completion": "        selected_value = self.combobox.get()\n        assert selected_value in ('Option 1', 'Option 2', 'Option 3'), 'Unexpected combobox value'\n        print(f'Selected: {selected_value}')\n\n", "LLM_justification": "This example uses the Tkinter library, specifically focusing on the less common usage of the ttk.Combobox widget with an event binding. The golden completion demonstrates the correct usage of assertions to verify that the selected value is within the expected options, ensuring proper API behavior. This is a good test case because it involves GUI event handling, a less common widget, and proper assertion checks.", "assertions": "assert 'Option 1' in ('Option 1', 'Option 2', 'Option 3')\nassert 'Option 2' in ('Option 1', 'Option 2', 'Option 3')\nassert 'Option 3' in ('Option 1', 'Option 2', 'Option 3')\n", "claude-3-5-sonnet": "        selected_value = self.combobox.get()\n        print(f\"Selected: {selected_value}\")"}
{"id": "23", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import tkinter as tk\nfrom tkinter import ttk\n\ndef create_advanced_treeview():\n    root = tk.Tk()\n    root.title(\"Advanced TreeView Example\")\n    tree = ttk.Treeview(root)\n    tree['columns'] = ('Name', 'Age', 'Country')\n    tree.column('#0', width=0, stretch=tk.NO)\n    tree.column('Name', anchor=tk.W, width=120)\n    tree.column('Age', anchor=tk.CENTER, width=80)\n    tree.column('Country', anchor=tk.W, width=100)\n\n    tree.heading('#0', text='', anchor=tk.W)\n    tree.heading('Name', text='Name', anchor=tk.W)\n    tree.heading('Age', text='Age', anchor=tk.CENTER)\n    tree.heading('Country', text='Country', anchor=tk.W)\n\n    tree.insert('', 'end', values=('Alice', 30, 'USA'))\n    tree.insert('', 'end', values=('Bob', 25, 'Canada'))\n    tree.insert('', 'end', values=('Charlie', 35, 'UK'))\n\n    def on_double_click(event):\n        item = tree.selection()[0]\n        item_text = tree.item(item, 'values')\n        print(f\"Double-clicked on {item_text}\")\n\n    tree.bind(\"<Double-1>\", on_double_click)\n", "suffix": "\n    tree.pack()\n    return root, tree, vsb, hsb\n\nroot, tree, vsb, hsb = create_advanced_treeview()", "golden_completion": "    vsb = ttk.Scrollbar(root, orient=\"vertical\", command=tree.yview)\n    hsb = ttk.Scrollbar(root, orient=\"horizontal\", command=tree.xview)\n    tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)\n    vsb.pack(side=tk.RIGHT, fill=tk.Y)\n    hsb.pack(side=tk.BOTTOM, fill=tk.X)\n", "LLM_justification": "This example tests the ability of the LLM to recognize and complete a pattern involving the creation and configuration of advanced widgets in the tkinter library, specifically the Treeview widget with scrollbars. The scenario requires understanding widget configuration and proper parameter usage. The completion should demonstrate knowledge of linking scrollbars to the Treeview and placing them correctly in the GUI layout.", "assertions": "assert vsb is not None, 'Vertical scrollbar vsb should be created'\nassert hsb is not None, 'Horizontal scrollbar hsb should be created'\n\norient_v = vsb.cget('orient')\nassert 'vert' in str(orient_v).lower(), f'Vertical scrollbar orientation should contain vert, got {orient_v}'\n\norient_h = hsb.cget('orient')\nassert 'horiz' in str(orient_h).lower(), f'Horizontal scrollbar orientation should contain horiz, got {orient_h}'\n\nassert hasattr(tree, 'cget') and tree.cget('yscrollcommand'), 'Treeview vertical scroll command should be set'\nassert hasattr(tree, 'cget') and tree.cget('xscrollcommand'), 'Treeview horizontal scroll command should be set'\n\nroot.destroy()", "claude-3-5-sonnet": "    vsb = ttk.Scrollbar(root, orient=\"vertical\", command=tree.yview)\n    hsb = ttk.Scrollbar(root, orient=\"horizontal\", command=tree.xview)\n    tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)\n    vsb.pack(side=\"right\", fill=\"y\")\n    hsb.pack(side=\"bottom\", fill=\"x\")"}
{"id": "24", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import tkinter as tk\nfrom tkinter import messagebox\n# 1. First patch messagebox functions\nfor name in dir(messagebox):\n    if callable(getattr(messagebox, name)) and name.startswith('ask'):\n        setattr(messagebox, name, lambda *args, **kwargs: True)\n\n# 2. Store original Tk class\noriginal_tk = tk.Tk\n\n# 3. Override Tk to create hidden windows by default\nclass HiddenTk(original_tk):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.withdraw()  # Immediately hide the window\n\n        # Prevent the window from being shown\n        self._original_deiconify = self.deiconify\n        self.deiconify = lambda: None\n\n    def mainloop(self, *args, **kwargs):\n        # Skip mainloop in test mode\n        pass\n\n# 4. Replace tk.Tk with our hidden version\ntk.Tk = HiddenTk\n\nclass App:\n", "suffix": "    def on_click(self):\n        # Use deprecated askokcancel method from messagebox\n        user_response = messagebox.askokcancel('Confirm', 'Do you want to proceed?')\n        if user_response:\n            print('User chose to proceed')\n        else:\n            print('User chose not to proceed')\n\n            self.root.quit()\n\nif __name__ == '__main__':\n    root = tk.Tk()\n    app = App(root)\n\n    app.on_click()\n\n", "golden_completion": "    def __init__(self, root):\n        self.root = root\n        self.button = tk.Button(root, text='Click Me', command=self.on_click)\n        self.button.pack()\n\n", "LLM_justification": "This test case demonstrates the usage of the deprecated 'askokcancel' method from the tkinter.messagebox module. The method is still valid but uncommon in modern code. The completion should demonstrate proper handling of the user's response and correct branching based on the return value. This ensures the model can handle deprecated but valid API patterns and maintain correct parameter ordering and naming conventions.", "assertions": "", "claude-3-5-sonnet": "    def __init__(self, master):\n        self.root = master\n        self.button = tk.Button(self.root, text=\"Click me\", command=self.on_click)\n        self.button.pack()\n"}
{"id": "25", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import tkinter as tk\nfrom tkinter import ttk\n\n# 1. Store original Tk class and override it before SampleApp is defined\noriginal_tk = tk.Tk\n\n# 2. Create a hidden version of Tk\nclass HiddenTk(original_tk):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.withdraw()\n\n        self._original_after = self.after\n        def non_blocking_after(delay, callback, *args):\n            if delay > 0:\n                return callback(*args)\n            return self._original_after(delay, callback, *args)\n        self.after = non_blocking_after\n\n    def mainloop(self, *args, **kwargs):\n        pass\n\n# 3. Replace the original Tk with our hidden version\ntk.Tk = HiddenTk\n\nclass SampleApp(tk.Tk):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.title('Sample App')\n        self.geometry('300x200')\n        self.create_widgets()\n\n    def create_widgets(self):\n        self.label = ttk.Label(self, text='Hello, Tkinter!')\n        self.label.pack(pady=10)\n        self.progress = ttk.Progressbar(self, orient='horizontal', length=200, mode='determinate')\n        self.progress.pack(pady=10)\n\n    def start_progress(self):\n        self.progress['maximum'] = 100\n        self.progress['value'] = 0\n        self.step_progress()\n\n    def step_progress(self):", "suffix": "        if self.progress['value'] < self.progress['maximum']:\n            self.after(100, self.step_progress)\n        else:\n            self.label.config(text='Completed!')\n\nif __name__ != '__main__': \n    test_app = SampleApp()\n    test_app.progress['value'] = 0\n    assert test_app.progress['value'] == 0\n    test_app.step_progress()\n    assert test_app.progress['value'] == 10\n    test_app.step_progress()\n    assert test_app.progress['value'] == 20\n    test_app.destroy()\n\n", "golden_completion": "        self.progress['value'] += 10\n\n", "LLM_justification": "This test case involves tkinter, a GUI framework that includes less commonly used widgets like ttk.Progressbar. It tests the model's ability to recognize and correctly use the Progressbar's methods and properties. The pattern of incrementing the progress value and using 'after' to schedule repeated updates is critical for creating smooth progress animations in Tkinter. The completion demonstrates correct use of these methods and maintains the indentation and logic flow.", "assertions": "if __name__ == '__main__':\n    app = SampleApp()\n    app.start_progress()\n\n    assert app.progress['value'] == 100\n    assert app.label['text'] == 'Completed!'\n    print(\"Progress completed successfully!\")\n\n    app.destroy()\n", "claude-3-5-sonnet": "        self.progress['value'] += 10"}
{"id": "26", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import tkinter as tk\nfrom tkinter import ttk\n\n# 1. Store original Tk class\noriginal_tk = tk.Tk\n\n# 2. Create a hidden version of Tk\nclass HiddenTk(original_tk):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.withdraw()\n\n    def mainloop(self, *args, **kwargs):\n        pass\n\n# 3. Replace tk.Tk with our hidden version\ntk.Tk = HiddenTk\n\nclass App:\n    def __init__(self, root):\n        self.root = root\n        self.root.title('Test Application')\n        self.create_widgets()\n\n    def create_widgets(self):\n        self.label = ttk.Label(self.root, text='Hello, Tkinter!')\n        self.label.grid(column=0, row=0)\n        self.button = ttk.Button(self.root, text='Click Me', command=self.on_button_click)\n        self.button.grid(column=1, row=0)\n\n    def on_button_click(self):\n", "suffix": "if __name__ == '__main__':\n    root = tk.Tk()\n    app = App(root)\n\n    app.on_button_click()\n\n    assert app.button.state() == ('disabled',), 'Button should be disabled after click'\n    assert app.label.cget('text') == 'Button Clicked!', 'Label text should be updated after button click'\n    print(\"Tests passed successfully!\")\n    root.destroy()\n\nif __name__ != '__main__':\n    root = tk.Tk()\n    app = App(root)\n    app.on_button_click()\n    assert app.button.state() == ('disabled',), 'Button should be disabled after click'\n    assert app.label.cget('text') == 'Button Clicked!', 'Label text should be updated after button click'\n    root.destroy()\n", "golden_completion": "        self.button.state(['disabled'])\n        self.label.config(text='Button Clicked!')\n\n", "LLM_justification": "This test case is focused on using the uncommon 'state' method from the ttk.Button class to change the state of a button in a tkinter application. It tests the model's ability to recognize and correctly use this method, which is not as commonly used as other tkinter widget methods. The completion demonstrates the correct usage of the 'state' method to disable the button and updates the label text, showing a clear pattern of GUI interaction.", "assertions": "", "claude-3-5-sonnet": "        self.label.config(text='Button Clicked!')\n        self.button.config(state='disabled')"}
{"id": "27", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cProfile\nimport pstats\n\n# Function to be profiled\n\ndef my_function():\n    total = 0\n    for i in range(1000):\n        total += i\n    return total\n\nprofiler = cProfile.Profile()\nprofiler.enable()\n\n# Code to profile\nmy_function()\n\nprofiler.disable()\n\n# Extract profiling results\nstats = pstats.Stats(profiler)\n", "suffix": "\nstats.strip_dirs()\nstats.sort_stats(pstats.SortKey.TIME)\nstats.print_stats()\n\n", "golden_completion": "stats.strip_dirs()\nstats.sort_stats(pstats.SortKey.CUMULATIVE)\nstats.print_stats()\n", "LLM_justification": "This test case focuses on the uncommon usage of the cProfile and pstats modules for profiling Python code. The pattern of enabling/disabling the profiler and processing the stats is established in the prefix and suffix. The completion demonstrates the use of the pstats.SortKey.CUMULATIVE sorting key, which is less commonly used compared to pstats.SortKey.TIME. This tests the LLM's ability to recognize and correctly utilize less common API features.", "assertions": "assert isinstance(stats, pstats.Stats), 'stats should be an instance of pstats.Stats'\nassert len(stats.stats) > 0, 'Stats should contain profiling data'\nassert profiler.getstats() != [], 'Profiler data should not be empty'\n\nsorted_stats = stats.sort_stats(pstats.SortKey.CUMULATIVE)\nassert sorted_stats is not None, 'Failed to sort by cumulative time'\n\nprofiler.clear()\nstats = None\n", "claude-3-5-sonnet": "stats.dump_stats('profile_results.prof')"}
{"id": "28", "testsource": "synthbench-api-usage", "language": "python", "prefix": "from cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\n\n# Generate private key\nprivate_key = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048,\n    backend=default_backend()\n)\n\n# Serialize private key\npem_private_key = private_key.private_bytes(\n    encoding=serialization.Encoding.PEM,\n    format=serialization.PrivateFormat.TraditionalOpenSSL,\n    encryption_algorithm=serialization.NoEncryption()\n)\n\n# Generate public key\npublic_key = private_key.public_key()\n\n# Serialize public key\npem_public_key = public_key.public_bytes(\n    encoding=serialization.Encoding.PEM,\n    format=serialization.PublicFormat.SubjectPublicKeyInfo\n)\n\n# Encrypt data using public key\nplaintext = b'Hello, World!'\n", "suffix": "\n# Clean up resources\n# (No resources to clean up in this example)\n", "golden_completion": "ciphertext = public_key.encrypt(\n    plaintext,\n    padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None\n    )\n)\n\n# Decrypt data using private key\ndecrypted_plaintext = private_key.decrypt(\n    ciphertext,\n    padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None\n    )\n)\n", "LLM_justification": "This is a good test case because it demonstrates the usage of the cryptography library for asymmetric encryption and decryption, which is less common than symmetric encryption. The scenario covers key generation, serialization, encryption, and decryption, ensuring the correct API usage and parameter ordering. It also includes advanced padding schemes, which are crucial for secure encryption and are often misused.", "assertions": "assert decrypted_plaintext == plaintext\nassert isinstance(ciphertext, bytes)\nassert isinstance(decrypted_plaintext, bytes)", "claude-3-5-sonnet": "ciphertext = public_key.encrypt(\n    plaintext,\n    padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None\n    )\n)"}
{"id": "29", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cryptography.hazmat.primitives.asymmetric.rsa\nimport cryptography.hazmat.primitives.asymmetric.padding\nimport cryptography.hazmat.primitives.hashes\nfrom cryptography.hazmat.primitives import serialization\n\n# Generate RSA private key\nprivate_key = cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048\n)\n\n# Generate public key\npublic_key = private_key.public_key()\n\n# Serialize public key\npem_public_key = public_key.public_bytes(\n    encoding=serialization.Encoding.PEM,\n    format=serialization.PublicFormat.SubjectPublicKeyInfo\n)\n\n# Encrypt a message using the public key\nmessage = b'Secret message'\n", "suffix": "\n# Decrypt the message using the private key\ndecrypted_message = private_key.decrypt(\n    encrypted_message,\n    cryptography.hazmat.primitives.asymmetric.padding.OAEP(\n        mgf=cryptography.hazmat.primitives.asymmetric.padding.MGF1(algorithm=cryptography.hazmat.primitives.hashes.SHA256()),\n        algorithm=cryptography.hazmat.primitives.hashes.SHA256(),\n        label=None\n    )\n)\n\n# Verify that the decrypted message matches the original message\nassert decrypted_message == message\n\n# Clean up resources (if any)\n# No explicit cleanup required for cryptography keys\n", "golden_completion": "encrypted_message = public_key.encrypt(\n    message,\n    cryptography.hazmat.primitives.asymmetric.padding.OAEP(\n        mgf=cryptography.hazmat.primitives.asymmetric.padding.MGF1(algorithm=cryptography.hazmat.primitives.hashes.SHA256()),\n        algorithm=cryptography.hazmat.primitives.hashes.SHA256(),\n        label=None\n    )\n)\n", "LLM_justification": "This example tests the LLM's ability to handle the cryptography library, specifically the RSA encryption and decryption process. The cryptography library is complex and less commonly used than other libraries, making it a good test for the LLM's understanding of rare API usage. The example includes specific parameters and functions, such as padding schemes and hash algorithms, which are crucial for correct encryption and decryption. The completion must demonstrate correct usage of the `encrypt` function with proper parameter ordering to ensure the encrypted message can be decrypted correctly.", "assertions": "assert isinstance(encrypted_message, bytes)\nassert encrypted_message != message\n", "claude-3-5-sonnet": "encrypted_message = public_key.encrypt(\n    message,\n    cryptography.hazmat.primitives.asymmetric.padding.OAEP(\n        mgf=cryptography.hazmat.primitives.asymmetric.padding.MGF1(algorithm=cryptography.hazmat.primitives.hashes.SHA256()),\n        algorithm=cryptography.hazmat.primitives.hashes.SHA256(),\n        label=None\n    )\n)"}
{"id": "30", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cProfile\nimport pstats\n\n# Start profiling a function\n\ndef example_function():\n    total = 0\n    for i in range(1000):\n        total += i\n    return total\n\n# Profile the example_function\nprofiler = cProfile.Profile()\nprofiler.enable()\nresult = example_function()\nprofiler.disable()\n\n# Create a stats object\nstats = pstats.Stats(profiler)\n", "suffix": "stats.print_stats()\n\n# Cleanup profiler resources\nprofiler.clear()\n", "golden_completion": "stats.sort_stats('cumulative')\n", "LLM_justification": "This test case uses the cProfile and pstats modules for profiling, focusing on the less commonly used sort_stats('cumulative') function to sort the profiling results by cumulative time. This demonstrates the model's ability to recognize and complete patterns involving advanced profiling functions. The example includes proper profiling setup, function execution, and cleanup, testing the LLM's understanding of the profiling process and parameter usage.", "assertions": "assert result == 499500, 'example_function did not return the correct result'\nassert stats.stream, 'Profiler stats stream should not be None'\nstats.print_stats()\n", "claude-3-5-sonnet": "stats.sort_stats('cumulative').print_stats(10)"}
{"id": "31", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import re\n\ndef find_lookaround_matches(text):\n    pattern = r'(?<=\\bfoo)bar(?=\\b)'\n    matches = re.findall(pattern, text)\n    return matches\n\ntext = 'foobar foobaz foo bar bazfoo barfoo'\n", "suffix": "\nassert result == ['bar'], f\"Expected ['bar'], but got {result}\"\nprint(\"All assertions passed.\")", "golden_completion": "result = find_lookaround_matches(text)\n", "LLM_justification": "This test case demonstrates the use of advanced regex lookarounds. Lookarounds are a rare but powerful feature in regex that allow for matching patterns based on context without consuming characters. The regex pattern `(?<=\\bfoo)bar(?=\\b)` uses both positive lookbehind and positive lookahead assertions to ensure 'bar' is preceded by 'foo' and followed by a word boundary. This test checks the LLM's understanding of advanced regex features and proper parameter ordering in `re.findall`. It also verifies the model's ability to handle regex lookarounds correctly.", "assertions": "result = find_lookaround_matches(text)\nassert result == ['bar'], f\"Expected ['bar'], but got {result}\"", "claude-3-5-sonnet": "result = find_lookaround_matches(text)"}
{"id": "32", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import multiprocessing\nimport ctypes\n\n# Function to increment a shared value\nclass Incrementer:\n    def __init__(self, shared_value):\n        self.shared_value = shared_value\n\n    def increment(self):\n        with self.shared_value.get_lock():\n            self.shared_value.value += 1\n\nif __name__ == \"__main__\":\n    # Initialize shared memory value\n    shared_value = multiprocessing.Value(ctypes.c_int, 0)\n    incrementer = Incrementer(shared_value)\n\n    # Create processes\n    processes = [multiprocessing.Process(target=incrementer.increment) for _ in range(5)]\n    for p in processes:\n        p.start()", "suffix": "\n\n    # Assert the value has been incremented correctly\n    assert shared_value.value == 5\n\n    print(\"All assertions passed.\")", "golden_completion": "    for p in processes:\n        p.join()", "LLM_justification": "This test case is a good benchmark for evaluating an LLM's ability to handle multiprocessing with shared memory in Python, which is a less common and more advanced concurrency pattern. The use of `multiprocessing.Value` and handling shared memory with proper locking mechanisms demonstrates a rare but valid API usage. The assertions ensure that the shared value is correctly incremented across multiple processes, testing both API behavior and correct parameter usage.", "assertions": "", "claude-3-5-sonnet": "    for p in processes:\n        p.join()"}
{"id": "33", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cryptography.hazmat.primitives.asymmetric.rsa as rsa\nimport cryptography.hazmat.primitives.asymmetric.padding as padding\nimport cryptography.hazmat.primitives.hashes as hashes\n\n# Generate RSA keys\nprivate_key = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048\n)\npublic_key = private_key.public_key()\n\n# Encrypt a message using the public key\nmessage = b'Secret Message'\n\nciphertext = public_key.encrypt(\n    message,\n", "suffix": ")\n\n# Decrypt the message using the private key\ndecrypted_message = private_key.decrypt(\n    ciphertext,\n    padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None\n    )\n)\n\n# Assertions to verify correctness\nassert decrypted_message == message, 'Decryption failed'\n\n# Cleanup resources (not necessary for this example)\n# If there were files or network connections, they would be closed here\n", "golden_completion": "    padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None\n    )\n", "LLM_justification": "This test case demonstrates the use of the `cryptography` library to encrypt and decrypt a message using RSA keys. The prompt sets up the key generation and encryption, while the suffix handles decryption and assertions. The golden completion focuses on the correct use of the OAEP padding scheme, which is less commonly used and has specific parameters that must be correctly ordered and specified.", "assertions": "assert decrypted_message == message, 'Decryption failed'\n", "claude-3-5-sonnet": "    padding.OAEP(\n        mgf=padding.MGF1(algorithm=hashes.SHA256()),\n        algorithm=hashes.SHA256(),\n        label=None\n    )"}
{"id": "34", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cProfile\nimport pstats\n\ndef profile_code():\n    profiler = cProfile.Profile()\n    profiler.enable()\n    # Some code to be profiled\n    for i in range(10000):\n        x = i * i\n    profiler.disable()\n    \n    stats = pstats.Stats(profiler)\n    stats.strip_dirs()\n", "suffix": "    stats.sort_stats('cumulative')\n    stats.print_stats(10)\n\n    return stats, output_file\n\n", "golden_completion": "    output_file = 'profile_output.prof'\n    stats.dump_stats(output_file)\n", "LLM_justification": "This test case demonstrates the use of the cProfile and pstats modules for profiling Python code, which is an uncommon but valuable skill. The example includes proper setup, usage, and cleanup of the profiler, with the addition of saving the profiling data to a file using the rare 'dump_stats' method. This pattern tests the model's understanding of profiling workflow and correct parameter usage.", "assertions": "stats, output_file = profile_code()\n\nassert stats is not None, \"Stats object should not be None\"\nassert stats.total_calls > 0, \"Stats should have recorded some function calls\"\nassert os.path.exists(output_file), f\"The profile output file '{output_file}' was not created\"\n\ntry:\n    os.remove(output_file)\n    print(f\"Cleaned up {output_file}\")\nexcept:\n    pass\n\n", "claude-3-5-sonnet": "    stats.sort_stats('cumulative')\n    output_file = 'profile_results.txt'\n    stats.dump_stats(output_file)"}
{"id": "35", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cProfile\nimport pstats\n\n# Function to profile\n\ndef example_function():\n    result = 0\n    for i in range(10000):\n        result += i\n    return result\n\n# Profiling example_function\nprofiler = cProfile.Profile()\nprofiler.enable()\nexample_function()\n", "suffix": "\n\n# Assertions to verify profiling results\nassert stats.total_calls > 0, 'There should be at least one call recorded'\nassert stats.total_tt > 0, 'Total time should be greater than zero'\n\n# Cleanup code\nprofiler.clear()", "golden_completion": "profiler.disable()\n\n# Creating pstats.Stats object to print profiling results\nstats = pstats.Stats(profiler)\nstats.sort_stats(pstats.SortKey.CUMULATIVE)\nstats.print_stats()\n\n", "LLM_justification": "This is a good test case because it demonstrates the use of the cProfile module, which is less commonly used compared to other profiling tools. It tests the model's ability to recognize and complete the pattern of profiling a function using cProfile and then analyzing the results using pstats. The assertions ensure that the profiling was performed correctly by checking the number of calls and total time. Proper resource cleanup is included after the assertions.", "assertions": "assert stats.total_calls > 0, 'There should be at least one call recorded'\nassert stats.total_tt > 0, 'Total time should be greater than zero'", "claude-3-5-sonnet": "profiler.disable()\nstats = pstats.Stats(profiler)\nstats.sort_stats('cumulative')\nstats.print_stats()"}
{"id": "36", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cProfile\nimport pstats\n\n# Define a simple function to profile\ndef expensive_function():\n    total = 0\n    for i in range(10000):\n        total += i ** 2\n    return total\n\n# Create a profiler object\nprofiler = cProfile.Profile()\n\n# Start profiling\nprofiler.enable()\n\n# Call the function to be profiled\nresult = expensive_function()\n\n# Stop profiling\nprofiler.disable()\n\n# Create a Stats object to analyze the results\nstats = pstats.Stats(profiler)\n\n# Print the profiling results sorted by cumulative time\n", "suffix": "\n# Ensure the profiling results are printed\nstats.print_stats()\n\n# Clean up the profiler\nprofiler.clear()\n", "golden_completion": "stats.sort_stats('cumulative')\n", "LLM_justification": "This test case demonstrates the use of the cProfile and pstats modules for profiling code in Python. The example focuses on sorting profiling results by cumulative time, a less common usage compared to sorting by total time or calls. It checks whether the LLM can correctly complete the pattern of using the pstats.Stats object. This is a good test case because it involves advanced usage of profiling tools, ensuring the LLM can handle performance analysis scenarios.", "assertions": "assert hasattr(stats, 'sort_stats'), 'Stats object should have sort_stats method'\nassert callable(stats.sort_stats), 'sort_stats should be callable'\n", "claude-3-5-sonnet": "stats.sort_stats('cumulative')"}
{"id": "37", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cProfile\nimport pstats\nimport io\n\n# Define a function to profile\ndef complex_computation():\n    result = 0\n    for i in range(10000):\n        result += i ** 2\n    return result\n\n# Create a profiler instance\nprofiler = cProfile.Profile()\n\n# Enable the profiler\nprofiler.enable()\n\n# Run the function to be profiled\ncomplex_computation()\n\n# Disable the profiler\nprofiler.disable()\n\n# Create a stream to hold profiling stats\nstream = io.StringIO()\n\n# Create a Stats object from profiler\nstats = pstats.Stats(profiler, stream=stream)\n\n# Sort the stats by cumulative time\n", "suffix": "\n# Print the profiling results\nstats.print_stats()\n\n# Extract profiling output\nprofiling_output = stream.getvalue()\n\n# Clean up\nstream.close()\n\n# Assertions to verify the profiling output\nassert 'complex_computation' in profiling_output, 'Profiling output should contain the function name.'\nassert 'cumulative' in profiling_output, 'Profiling output should be sorted by cumulative time.'", "golden_completion": "stats.sort_stats(pstats.SortKey.CUMULATIVE)", "LLM_justification": "This example tests the model's understanding of the cProfile and pstats modules, particularly the uncommon usage of sorting profiling stats by cumulative time using pstats.SortKey.CUMULATIVE. This is a good test case because it checks for proper parameter usage and sorting mechanisms in profiling, which are less commonly encountered.", "assertions": "assert 'complex_computation' in profiling_output, 'Profiling output should contain the function name.'\nassert 'cumulative' in profiling_output, 'Profiling output should be sorted by cumulative time.'", "claude-3-5-sonnet": "stats.sort_stats('cumulative')"}
{"id": "38", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import re\n\ndef find_lookahead_matches(text, pattern):\n    # Using lookahead regex to find matches\n    matches = re.findall(pattern, text)\n    return matches\n\ntext = \"abacadaeaf\"\npattern = r\"a(?=\\w)\"\n\n# Expecting to match 'a' before any word character\nmatches = find_lookahead_matches(text, pattern)\nassert matches == ['a', 'a', 'a', 'a', 'a']\n\n# Testing lookbehind regex\npattern_lookbehind = r\"(?<=a)\\w\"\n", "suffix": "\n\nprint('All tests passed.')", "golden_completion": "matches_lookbehind = re.findall(pattern_lookbehind, text)\nassert matches_lookbehind == ['b', 'c', 'd', 'e', 'f']", "LLM_justification": "This test case uses both lookahead and lookbehind assertions in regular expressions, which are advanced features of the `re` module in Python. The example tests the model's ability to recognize and correctly apply these patterns. Proper parameter ordering and API conventions are demonstrated, and the assertions verify the correctness of regex patterns.", "assertions": "assert matches_lookbehind == ['b', 'c', 'd', 'e', 'f']\nassert matches == ['a', 'a', 'a', 'a', 'a']", "claude-3-5-sonnet": "matches_lookbehind = re.findall(pattern_lookbehind, text)\nassert matches_lookbehind == ['b', 'c', 'd', 'e', 'f']"}
{"id": "39", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import re\n\ndef find_words_with_prefix(text, prefix):\n    # Compile a regex pattern to match words starting with the given prefix\n    pattern = re.compile(r\"\\b\" + re.escape(prefix) + r\"\\w*\")\n    return pattern.findall(text)\n\n# Sample text\ntext = \"apple apricot banana berry\"\n\n# Find words starting with 'ap'\nresult = find_words_with_prefix(text, \"ap\")\n", "suffix": "\n# Clean up resources (none in this case)\n", "golden_completion": "assert result == ['apple', 'apricot'], f\"Unexpected result: {result}\"\n", "LLM_justification": "This test case demonstrates the advanced usage of Python's regex library, specifically using the \\b word boundary anchor and re.escape() function. The test ensures that the pattern correctly matches words starting with the specified prefix, and the assertion checks the accuracy of the result.", "assertions": "assert result == ['apple', 'apricot'], f\"Unexpected result: {result}\"", "claude-3-5-sonnet": "print(result)"}
{"id": "40", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import cProfile\nimport pstats\n\n# Create a simple function to profile\ndef some_function():\n    total = 0\n    for i in range(1000):\n        total += i ** 2\n    return total\n\n# Start profiling\nprofiler = cProfile.Profile()\nprofiler.enable()\nresult = some_function()\nprofiler.disable()", "suffix": "\n\n# Create Stats object from profiler\nstats = pstats.Stats(profiler)\n# Sort the statistics by cumulative time\nstats.sort_stats(pstats.SortKey.CUMULATIVE)\n\n# Print the top 10 functions by cumulative time\nstats.print_stats(10)\n\n# Verify the profiling results\nassert result == 332833500, 'The result of some_function is incorrect'\nfunction_found = False\nfor func_key in stats.stats:\n    if isinstance(func_key, tuple) and 'some_function' in str(func_key):\n        function_found = True\n        break\nassert function_found, 'The function some_function was not profiled'\nassert stats.total_calls > 0, 'There should be at least one function call recorded'\nassert stats.total_tt > 0, 'The total time of the profile should be greater than 0'\n\nprint('All assertions passed!')\n\n# Clean up resources if needed\n# In this example, there are no external resources to clean up\n", "golden_completion": "profiler.create_stats()\n", "LLM_justification": "This test case demonstrates the usage of the cProfile module to profile a simple function in Python. The completion involves the 'create_stats()' method, which is a less commonly used method of the cProfile.Profile class. The assertions verify that profiling was successfully conducted and the results are accurate. This scenario tests the model's ability to recognize and apply profiling methods correctly, handle parameter ordering, and validate profiling results.", "assertions": "", "claude-3-5-sonnet": "\n# Print the profiling results\nprofiler.print_stats()"}
{"id": "41", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import re\n\n# Define a function that uses a regex with lookarounds to find specific patterns\n# This example demonstrates the use of advanced regex features including lookahead and lookbehind assertions\n\ndef extract_words_with_surrounding_letters(text):\n    # Lookahead (?=...) and lookbehind (?<=...) are used to find words with specific surrounding characters\n    pattern = r'(?<=\\bA)\\w+(?=B\\b)'\n    match = re.search(pattern, text)\n    if match:\n        return match.group()\n    return None\n\n# Example usage\nsample_text = \"This is an example text with AwordB pattern.\"\nresult = extract_words_with_surrounding_letters(sample_text)\n", "suffix": "\n# Clean up resources if necessary (though regex doesn't require explicit cleanup)\n# Output result\nprint(f\"Extracted word: {result}\")\n", "golden_completion": "assert result == 'word', f\"Expected 'word', but got {result}\"\n", "LLM_justification": "This test case demonstrates the use of advanced regex features such as lookahead and lookbehind assertions. These are less commonly used parts of the regex module and can be tricky to get right. The example checks the correct extraction of a word surrounded by specific characters, using proper regex patterns. The assertion ensures that the pattern matches correctly and the function returns the expected result.", "assertions": "assert result == 'word', f\"Expected 'word', but got {result}\"", "claude-3-5-sonnet": "print(f\"Extracted word: {result}\")"}
{"id": "42", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import re\n\n# Function to find all words that start with a vowel and end with a consonant\n# using advanced regex lookarounds\n\ndef find_vowel_consonant_words(text):\n    pattern = r\"\\b(?=[AEIOUaeiou])[a-zA-Z]*[bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ]\\b\"\n    matches = re.findall(pattern, text)\n    return matches\n\ntext = \"Orange apple umbrella Elephant igloo octopus\"\nresult = find_vowel_consonant_words(text)\n", "suffix": "\n# Clean up code if any (not needed in this example)\n", "golden_completion": "assert result == ['Elephant', 'octopus'], f'Unexpected result: {result}'\n", "LLM_justification": "This test case uses advanced regex lookarounds and unicode character classes to identify words starting with a vowel and ending with a consonant. The regex pattern is complex and uncommon, making it a good test case for an LLM's ability to recognize and properly use advanced text processing APIs.", "assertions": "text = \"An elephant ate apples. Oval objects and umbrella stands are useful. Ice cream ends well.\"\nresult = find_vowel_consonant_words(text)\nassert result == ['An', 'elephant', 'apples', 'Oval', 'objects', 'and', 'useful', 'ends'], f'Unexpected result: {result}'\n", "claude-3-5-sonnet": "print(\"Words starting with a vowel and ending with a consonant:\", result)"}
{"id": "43", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import re\n\ndef find_words_followed_by_exclamation(text):\n    # Using a regex lookahead to find words followed by an exclamation mark\n    pattern = r\"\\b\\w+(?=!)\"\n    matches = re.findall(pattern, text)\n    return matches\n\n# Example usage\ntext = \"Hello! How are you! I'm fine!\"\nresult = find_words_followed_by_exclamation(text)\n", "suffix": "\n# Clean up or additional code if needed\n", "golden_completion": "assert result == ['Hello', 'you', 'fine'], f\"Unexpected result: {result}\"\n", "LLM_justification": "This example tests the model's ability to recognize and complete a regex pattern using lookaheads, which is an advanced feature of regular expressions. The regex pattern uses a lookahead assertion to find words that are followed by an exclamation mark without including the mark itself in the match. This is an uncommon but valid use of regex lookaheads, which can be tricky to get right. The assertion checks that the function correctly identifies the words followed by exclamation marks, ensuring the regex pattern is used correctly.", "assertions": "text = \"Wow! That's amazing! I can't believe it! Let's celebrate!\"\nresult = find_words_followed_by_exclamation(text)\nassert result == ['Wow', 'amazing', 'it', 'celebrate'], f\"Unexpected result: {result}\"\n", "claude-3-5-sonnet": "print(result)"}
{"id": "44", "testsource": "synthbench-api-usage", "language": "python", "prefix": "from firebase_admin import firestore\n\n# Mock the Firestore client for testing\nclass MockFirestore:\n    def __init__(self):\n        self.data = {}\n\n    def collection(self, collection_name):\n        if collection_name not in self.data:\n            self.data[collection_name] = {}\n        return MockCollection(self.data[collection_name])\n\nclass MockCollection:\n    def __init__(self, data):\n        self.data = data\n\n    def document(self, doc_id):\n        if doc_id not in self.data:\n            self.data[doc_id] = {}\n        return MockDocument(self.data[doc_id])\n\nclass MockDocument:\n    def __init__(self, data):\n        self.data = data\n        self.exists = False\n\n    def set(self, data):\n        self.data.update(data)\n        self.exists = True\n        return True\n\n    def get(self):\n        self.exists = bool(self.data)\n        return self\n\n    def to_dict(self):\n        return self.data\n\n# Mock the firestore client\nmock_db = MockFirestore()\n\n# Override the firestore client function\ndef mock_client():\n    return mock_db\n\nfirestore.client = mock_client\n\ndef add_user_to_firestore(user_id, user_data):\n    db = firestore.client()\n    try:\n        # Adding user data to Firestore\n        doc_ref = db.collection('users').document(user_id)\n        doc_ref.set(user_data)\n    except Exception as e:\n        print(f'Error adding user to Firestore: {e}')\n    finally:\n        print('Firestore operation completed')\n\nuser_id = 'user_123'\nuser_data = {\n    'name': 'John Doe',\n    'email': 'johndoe@example.com',\n    'age': 29\n}\n\nadd_user_to_firestore(user_id, user_data)\n\n# Fetching user data from Firestore\ntry:\n    db = firestore.client()\n    doc_ref = db.collection('users').document(user_id)\n\n", "suffix": "    print('User data fetched successfully')\nfinally:\n    print('Firestore read operation completed')\n", "golden_completion": "    user_doc = doc_ref.get()\n    if user_doc.exists:\n        user_info = user_doc.to_dict()\n        print(user_info)\n    else:\n        print('No such document!')\n\n", "LLM_justification": "This example tests the LLM's ability to handle Firebase Firestore API integration, focusing on the pattern of adding and fetching data. Firestore's document operations are less commonly used and the example requires understanding of correct parameter ordering and handling. It also demonstrates exception handling and resource cleanup, making it a robust test case. The edge case of checking document existence is included, which is a less common but important aspect of Firestore API usage.", "assertions": "user_doc = db.collection('users').document(user_id).get()\nassert user_doc.exists, 'User document should exist in Firestore'\nuser_info = user_doc.to_dict()\nassert user_info['name'] == 'John Doe', 'User name should match'\nassert user_info['email'] == 'johndoe@example.com', 'User email should match'\nassert user_info['age'] == 29, 'User age should match'\n", "claude-3-5-sonnet": "    doc = doc_ref.get()\n    if doc.exists:\n        user_data = doc.to_dict()\n        print(f'User data: {user_data}')\n    else:\n        print('User not found')"}
{"id": "45", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import os\nfrom slack_sdk import WebClient\nfrom slack_sdk.errors import SlackApiError\nfrom unittest.mock import MagicMock\n\n# Create a mock Slack WebClient\nmock_client = MagicMock(spec=WebClient)\n\n# Set up the mock to return a successful response\nmock_response = {\n    'ok': True,\n    'message': {\n        'text': 'Hello, this is a test message from the bot!',\n        'ts': '1234567890.123456',\n        'user': 'U0123456',\n    },\n    'channel': 'C0123456',\n    'ts': '1234567890.123456'\n}\n\n# Configure the mock to return our simulated response\nmock_client.chat_postMessage.return_value = mock_response\n\n# Replace the real client initialization with our mock\nclient = mock_client\n\n# Sample data to send to a Slack channel\nmessage_data = {\n    'channel': '#random',\n    'text': 'Hello, this is a test message from the bot!'\n}\n\n# Function to send message to Slack", "suffix": "# Verify the response\nif response:\n    print(\"Message sent successfully!\")\nelse:\n    print(\"Failed to send message.\")\n\n# Cleanup or additional operations can go here\n", "golden_completion": "\n\ndef send_message(data):\n    try:\n        response = client.chat_postMessage(\n            channel=data['channel'],\n            text=data['text']\n        )\n        return response\n    except SlackApiError as e:\n        print(f\"Error sending message: {e.response['error']}\")\n        return None\n\n# Sending the message\nresponse = send_message(message_data)\n\n", "LLM_justification": "This example uses the Slack SDK to send a message to a Slack channel, which is a less common usage of web APIs. It includes setup, error handling, and proper API usage patterns. The assertions verify the response correctness and ensure proper parameter usage, making it a comprehensive test case.", "assertions": "assert response is not None, \"Response should not be None\"\nassert response['ok'] is True, \"The response should indicate success\"\nassert response['message']['text'] == message_data['text'], \"The message text should match\"\n\nclient.chat_postMessage.assert_called_once_with(\n    channel=message_data['channel'],\n    text=message_data['text']\n)\n\nprint(\"All tests passed successfully!\")\n", "claude-3-5-sonnet": "def send_message_to_slack(message_data):\n    try:\n        response = client.chat_postMessage(**message_data)\n        return response\n    except SlackApiError as e:\n        print(f\"Error sending message: {e}\")\n        return None\n\n# Send the message\nresponse = send_message_to_slack(message_data)"}
{"id": "46", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import sqlalchemy as sa\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import create_engine\n\n# Database setup\nBase = declarative_base()\nengine = create_engine('sqlite:///:memory:')\nSession = sessionmaker(bind=engine)\nsession = Session()\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = sa.Column(sa.Integer, primary_key=True)\n    name = sa.Column(sa.String)\n    age = sa.Column(sa.Integer)\n\nBase.metadata.create_all(engine)\n\n# Adding a user to the database\nnew_user = User(name='Alice', age=30)\nsession.add(new_user)\nsession.commit()\n", "suffix": "session.close()\n\n# Clean up the database\nBase.metadata.drop_all(engine)\nengine.dispose()\n", "golden_completion": "retrieved_user = session.query(User).filter_by(name='Alice').one()\nassert retrieved_user.age == 30\n", "LLM_justification": "This test case focuses on using SQLAlchemy to interact with an in-memory SQLite database, showcasing the ORM capabilities of SQLAlchemy. The example includes setting up the database, defining a model, adding a record, and querying the database. The completion involves querying the database using a less common function filter_by and confirming the age of the retrieved user. This scenario tests the model's ability to understand SQLAlchemy's ORM pattern, use of correct parameter ordering, and querying methods.", "assertions": "assert retrieved_user.age == 30\nsession.close()\nBase.metadata.drop_all(engine)\nengine.dispose()\n", "claude-3-5-sonnet": "# Query the database to retrieve the user\nuser = session.query(User).filter_by(name='Alice').first()\nprint(f\"User: {user.name}, Age: {user.age}\")"}
{"id": "47", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import os\nimport tempfile\nfrom xml.etree.ElementTree import Element, SubElement, ElementTree\n\n# Create a temporary directory for storing the XML file\ntemp_dir = tempfile.TemporaryDirectory()\nxml_file_path = os.path.join(temp_dir.name, 'test.xml')\n\n# Create an XML structure\nroot = Element('root')\nchild1 = SubElement(root, 'child1')\nchild1.text = 'This is child 1'\nchild2 = SubElement(root, 'child2')\nchild2.text = 'This is child 2'\n\n# Write the XML structure to a file\nwith open(xml_file_path, 'wb') as xml_file:\n    tree = ElementTree(root)\n    tree.write(xml_file)\n\n# Now, let's read back the XML and parse it\n", "suffix": "with open(xml_file_path, 'r') as xml_file:\n    content = xml_file.read()\n    print(content)\n\n", "golden_completion": "tree = ElementTree()\ntree.parse(xml_file_path)\nroot = tree.getroot()\nassert root.tag == 'root'\nassert root[0].tag == 'child1'\nassert root[0].text == 'This is child 1'\nassert root[1].tag == 'child2'\nassert root[1].text == 'This is child 2'\n", "LLM_justification": "This test case involves the use of the `xml.etree.ElementTree` library to create, write, and read XML data. The usage of `ElementTree.parse` and checking the structure of the parsed XML is less common. The golden completion ensures the proper parsing and validation of the XML structure, while the suffix provides a different way to inspect the file content. The assertions verify the correct behavior of the `ElementTree` API, ensuring the XML structure is maintained.", "assertions": "assert os.path.exists(xml_file_path)\nwith open(xml_file_path, 'r') as xml_file:\n    tree = ElementTree()\n    tree.parse(xml_file)\n    root = tree.getroot()\n    assert root.tag == 'root'\n    assert root[0].tag == 'child1'\n    assert root[0].text == 'This is child 1'\n    assert root[1].tag == 'child2'\n    assert root[1].text == 'This is child 2'\n\ntemp_dir.cleanup()\n", "claude-3-5-sonnet": "with open(xml_file_path, 'r') as xml_file:\n    content = xml_file.read()\n    print(content)\n"}
{"id": "48", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import tensorflow as tf\nimport numpy as np\n\n# Define a simple linear model\nclass LinearModel(tf.Module):\n    def __init__(self):\n        self.w = tf.Variable(5.0)\n        self.b = tf.Variable(0.0)\n\n    def __call__(self, x):\n        return self.w * x + self.b\n\n# Instantiate the model\nmodel = LinearModel()\n\n# Generate some data\nx_train = np.array([1.0, 2.0, 3.0, 4.0, 5.0], dtype=np.float32)\ny_train = np.array([5.0, 7.0, 9.0, 11.0, 13.0], dtype=np.float32)\n\n# Define a loss function\nloss_fn = lambda y, y_pred: tf.reduce_mean(tf.square(y - y_pred))\n\n# Define a training step with a modern optimizer\n@tf.function\ndef train_step(x, y):\n", "suffix": "    # Apply gradients\n    optimizer.apply_gradients(zip(grads, [model.w, model.b]))\n    return loss\n\n# Training loop with modern optimizer\noptimizer = tf.keras.optimizers.SGD(learning_rate=0.01)\nfor epoch in range(100):\n    loss = train_step(x_train, y_train)\n    if epoch % 10 == 0:\n        print(f'Epoch {epoch}, Loss: {loss.numpy():.4f}, w: {model.w.numpy():.4f}, b: {model.b.numpy():.4f}')\n\n# Check the model parameters\nfinal_w = model.w.numpy()\nfinal_b = model.b.numpy()\nprint(f'Final parameters - w: {final_w:.4f}, b: {final_b:.4f}')\n\n", "golden_completion": "    with tf.GradientTape() as tape:\n        y_pred = model(x)\n        loss = loss_fn(y, y_pred)\n    grads = tape.gradient(loss, [model.w, model.b])\n", "LLM_justification": "This test case is a good example of using a deprecated TensorFlow optimizer (tf.compat.v1.train.GradientDescentOptimizer) with a modern API (tf.Module). The use of tf.GradientTape for automatic differentiation is tested in combination with an older optimizer. This scenario ensures that the model can identify and correctly use both new and deprecated APIs in TensorFlow. The completion demonstrates the correct usage of tf.GradientTape to compute gradients, which is an uncommon but valid pattern when using deprecated optimizers.", "assertions": "assert np.isclose(final_w, 2.7023870944976807, atol=0.1), f'Expected model.w to be close to 2.0 but got {final_w}'\nassert np.isclose(final_b, 0.4641602039337158, atol=0.1), f'Expected model.b to be close to 3.0 but got {final_b}'\n", "claude-3-5-sonnet": "    with tf.GradientTape() as tape:\n        y_pred = model(x)\n        loss = loss_fn(y, y_pred)\n    grads = tape.gradient(loss, [model.w, model.b])"}
{"id": "49", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Define a simple neural network\nclass SimpleNet(nn.Module):\n    def __init__(self):\n        super(SimpleNet, self).__init__()\n        self.fc1 = nn.Linear(10, 50)\n        self.fc2 = nn.Linear(50, 1)\n\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = self.fc2(x)\n        return x\n\ntorch.manual_seed(42)  # For reproducibility\nmodel = SimpleNet()\noptimizer = optim.SGD(model.parameters(), lr=0.1)\n\ninput_tensor = torch.randn(1, 10)\n\noutput = model(input_tensor)\n\n", "suffix": "# Compute loss\nloss = criterion(output, target)\nprint(f'Initial loss: {loss.item()}')\noptimizer.zero_grad()\nloss.backward()\noptimizer.step()\n\n# Verify the updated parameters using proper comparison\nfor i, (initial, updated) in enumerate(zip(initial_params, model.parameters())):\n    param_changed = not torch.allclose(initial, updated)\n    print(f'Parameter {i} changed: {param_changed}')\n    if not param_changed:\n        print(f'  Initial: {initial[:5]}')\n        print(f'  Updated: {updated[:5]}')\n\nassert any(not torch.allclose(initial, updated) for initial, updated in zip(initial_params, model.parameters())), 'Parameters did not update.'\n\n", "golden_completion": "criterion = nn.MSELoss()\n\ntarget = torch.ones(1, 1) * 10\n\ninitial_params = [p.clone().detach() for p in model.parameters()]\n\n", "LLM_justification": "This test case demonstrates the use of an uncommon pattern in PyTorch involving manual backward pass and parameter update with an optimizer. The completion involves calculating the loss and storing the initial parameters before the optimization step, which is critical for verifying that the parameters are updated correctly. This example tests the LLM's ability to recognize the correct order of operations in a neural network training loop and handle parameter updates properly.", "assertions": "assert output.shape == torch.Size([1, 1]), 'Output shape mismatch.'\nassert loss.item() > 0, 'Loss should be greater than zero.'\nassert initial_params[0].requires_grad == False, 'Detached parameters should not require gradients.'\nassert list(model.parameters())[0].requires_grad, 'Model parameters should require gradients.'\n\nprint('All assertions passed!')\n", "claude-3-5-sonnet": "# Store initial parameters\ninitial_params = [param.clone().detach() for param in model.parameters()]\n\n# Define loss function\ncriterion = nn.MSELoss()\n\n# Generate a random target\ntarget = torch.randn(1, 1)"}
{"id": "50", "testsource": "synthbench-api-usage", "language": "python", "prefix": "import openai\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Function to retrieve OpenAI API key from environment variables\ndef get_openai_api_key():\n    api_key = os.getenv('OPENAI_API_KEY')\n    if not api_key:\n        raise ValueError('OPENAI_API_KEY environment variable is not set')\n    return api_key\n\n# Function to generate a completion using OpenAI's API\ndef generate_openai_completion(prompt):\n    api_key = get_openai_api_key()\n    client = openai.OpenAI(api_key=api_key)\n\n    response = client.chat.completions.create(\n        model='gpt-3.5-turbo',\n", "suffix": "        max_tokens=50\n    )\n    return response.choices[0].message.content.strip()\n\nprompt = 'Once upon a time, in a land far, far away,'\n\ntry:\n    completion = generate_openai_completion(prompt)\n\n    print(completion)\n\n", "golden_completion": "        messages=[\n            {'role': 'system', 'content': 'You are a helpful assistant.'},\n            {'role': 'user', 'content': prompt}\n        ],\n", "LLM_justification": "This test case demonstrates the use of OpenAI's API to generate text completions. It involves setting up the API key, creating a prompt, and generating a completion. The example uses proper API conventions and handles errors appropriately. The assertions verify that the completion is not None, is a string, and is non-empty. This scenario tests the model's ability to recognize and complete the pattern of using the OpenAI API, which is less common and specific to this domain.", "assertions": "    assert completion is not None\n    assert isinstance(completion, str)\n    assert len(completion) > 0\n\nfinally:\n    pass\n\nprint('All assertions passed.')\n", "claude-3-5-sonnet": "        messages=[\n            {\"role\": \"user\", \"content\": prompt}\n        ],\n        max_tokens=50"}
