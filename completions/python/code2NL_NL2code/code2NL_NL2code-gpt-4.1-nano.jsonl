{"id": "1", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def find_max(nums):\n    \"\"\"Find the maximum value in a list of integers.\"\"\"\n", "suffix": "\ndef test_find_max():\n    # Test with a list of positive integers\n    assert find_max([1, 2, 3, 4, 5]) == 5\n    # Test with a list containing negative integers\n    assert find_max([-10, -5, -1, -3]) == -1\n    # Test with a list containing both positive and negative integers\n    assert find_max([-10, 5, 0, 3]) == 5\n\n    print(\"All tests passed.\")\n\ntest_find_max()\n", "golden_completion": "    if not nums:\n        raise ValueError('The list is empty')\n    max_value = nums[0]\n    for num in nums:\n        if num > max_value:\n            max_value = num\n    return max_value\n", "LLM_justification": "This example tests the LLM's ability to translate a comment into code and vice versa. The function `find_max` is documented to find the maximum value in a list of integers, and the golden completion provides the corresponding implementation. The suffix contains a test suite that verifies the function's correctness with various input scenarios, including edge cases. The assertions ensure the function behaves as expected, and the documentation is accurate. This setup effectively tests the LLM's understanding of code functionality and documentation clarity.", "assertions": "assert find_max([1, 2, 3, 4, 5]) == 5\nassert find_max([-10, -5, -1, -3]) == -1\nassert find_max([-10, 5, 0, 3]) == 5\ntry:\n    find_max([])\nexcept ValueError as e:\n    assert str(e) == 'The list is empty'", "gpt-4.1-nano": "    max_value = nums[0]\n    for num in nums:\n        if num > max_value:\n            max_value = num\n    return max_value"}
{"id": "2", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def calculate_factorial(n):\n    \"\"\"Calculates the factorial of a given number n.\"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    elif n == 0:\n        return 1\n    else:\n", "suffix": "\n\ntry:\n    assert calculate_factorial(5) == 120\n    assert calculate_factorial(0) == 1\n    assert calculate_factorial(3) == 6\n    assert calculate_factorial(1) == 1\n    # Test for negative input\n    try:\n        calculate_factorial(-1)\n    except ValueError as e:\n        assert str(e) == \"Factorial is not defined for negative numbers\"\nfinally:\n    pass  # Cleanup code can be added here if needed", "golden_completion": "        return n * calculate_factorial(n - 1)\n", "LLM_justification": "This example tests both code-to-comment and comment-to-code translation capabilities. The prompt includes a partial implementation of a factorial calculation function with a clear docstring explaining its purpose. The golden_completion requires translating this partial code into a recursive implementation of the factorial calculation. The suffix then completes the function using an iterative approach and includes various assertions to test the function's correctness. This scenario effectively tests the model's ability to understand and generate documentation as well as complete code accurately.", "assertions": "try:\n    assert calculate_factorial(5) == 120\n    assert calculate_factorial(0) == 1\n    assert calculate_factorial(3) == 6\n    assert calculate_factorial(1) == 1\n    # Test for negative input\n    try:\n        calculate_factorial(-1)\n    except ValueError as e:\n        assert str(e) == \"Factorial is not defined for negative numbers\"\nfinally:\n    pass  # Cleanup code can be added here if needed", "gpt-4.1-nano": "        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result"}
{"id": "3", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "# This function calculates the factorial of a number recursively.\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n", "suffix": "\n# Test the factorial function\nresult = factorial(5)\nassert result == 120, f\"Expected 120 but got {result}\"\n\nresult = factorial(0)\nassert result == 1, f\"Expected 1 but got {result}\"\n\n# Cleanup code (if any) would go here\n", "golden_completion": "        return n * factorial(n-1)", "LLM_justification": "This example tests the LLM's ability to translate between code and comments. The prompt introduces a factorial function and the completion requires translating a recursive step. The suffix includes tests that check the correctness of the implementation, ensuring that the LLM's translation is correct. This scenario is a good test case because it involves understanding recursion, proper indentation, and accurate comment-to-code translation.", "assertions": "result = factorial(5)\nassert result == 120, f\"Expected 120 but got {result}\"\n\nresult = factorial(0)\nassert result == 1, f\"Expected 1 but got {result}\"\n", "gpt-4.1-nano": "return n * factorial(n - 1)"}
{"id": "4", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class Portfolio:\n    def __init__(self):\n        self.stocks = {}\n\n    def add_stock(self, name: str, shares: int, price: float):\n        \"\"\"\n        Add a stock to the portfolio.\n\n        Parameters:\n        name (str): The name of the stock.\n        shares (int): The number of shares to add.\n        price (float): The purchase price per share.\n        \"\"\"\n        if name in self.stocks:\n            current_shares, current_price = self.stocks[name]\n            new_shares = current_shares + shares\n            new_price = (current_price * current_shares + price * shares) / new_shares\n            self.stocks[name] = (new_shares, new_price)\n        else:\n            self.stocks[name] = (shares, price)\n\n    def get_stock_value(self, name: str) -> float:\n        \"\"\"\n        Get the total value of a specific stock in the portfolio.\n\n        Parameters:\n        name (str): The name of the stock.\n\n        Returns:\n        float: The total value of the stock.\n        \"\"\"\n", "suffix": "        return shares * price\n\n    def total_value(self) -> float:\n        \"\"\"\n        Calculate the total value of the entire portfolio.\n\n        Returns:\n        float: The total portfolio value.\n        \"\"\"\n        total = 0.0\n        for shares, price in self.stocks.values():\n            total += shares * price\n        return total\n\n# Example usage\nportfolio = Portfolio()\nportfolio.add_stock('AAPL', 10, 150.0)\nportfolio.add_stock('GOOGL', 5, 1000.0)\nassert portfolio.get_stock_value('AAPL') == 1500.0\nassert portfolio.total_value() == 6500.0\n", "golden_completion": "        shares, price = self.stocks.get(name, (0, 0.0))\n", "LLM_justification": "This test case is a good example because it covers a realistic business scenario of managing a portfolio of stocks. The completion involves retrieving stock information, which is a common operation. The test ensures accurate translation between code and documentation by verifying the correctness of the business logic and the completeness of the docstrings. Key terms like 'Parameters' and 'Returns' are checked in the docstring assertions, and the functionality is validated with realistic usage examples.", "assertions": "assert 'get the total value of a specific stock in the portfolio' in Portfolio.get_stock_value.__doc__.lower()\nassert 'parameters' in Portfolio.get_stock_value.__doc__.lower()\nassert 'returns' in Portfolio.get_stock_value.__doc__.lower()\nassert 'name (str): the name of the stock' in Portfolio.get_stock_value.__doc__.lower()\nassert 'float: the total value of the stock' in Portfolio.get_stock_value.__doc__.lower()\nassert portfolio.get_stock_value('AAPL') == 1500.0\nassert portfolio.total_value() == 6500.0\n", "gpt-4.1-nano": "shares, price = self.stocks[name]"}
{"id": "5", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "# Function to assess risk based on portfolio data\n# Parameters:\n# - portfolio (dict): A dictionary where keys are asset names and values are their respective values\n# - threshold (float): The risk threshold value\n# Returns:\n# - bool: True if the total value of the portfolio exceeds the threshold, False otherwise\n\ndef assess_risk(portfolio, threshold):", "suffix": "    total_value = sum(portfolio.values())\n    return total_value > threshold\n\n# Example usage\nportfolio = {'stocks': 100000, 'bonds': 50000, 'real_estate': 200000}\nthreshold = 300000\nrisk = assess_risk(portfolio, threshold)\nprint(f'Risk Assessment: {risk}')\n\n# Clean up resources if any\n# (In this case, there are no resources to clean up)\n", "golden_completion": "    \"\"\"\n    Calculate the total value of the portfolio and compare it to the threshold.\n\n    Parameters:\n    - portfolio (dict): A dictionary where keys are asset names and values are their respective values\n    - threshold (float): The risk threshold value\n\n    Returns:\n    - bool: True if the total value of the portfolio exceeds the threshold, False otherwise\n    \"\"\"\n", "LLM_justification": "This test case covers a scenario where the function documentation is provided, and the goal is to fill in the missing docstring for the function implementation. It tests the LLM's ability to correctly translate the given comments into a proper docstring. Additionally, the test includes a usage example and verifies the functionality by comparing the result of the function to the expected value. This scenario ensures that the LLM can handle both code-to-comment and comment-to-code translations effectively, maintaining consistency between the code and documentation.", "assertions": "docstring = assess_risk.__doc__\nassert docstring is not None, 'Docstring is missing'\nassert 'calculate the total value of the portfolio' in docstring.lower(), 'Key term missing in docstring'\nassert 'compare it to the threshold' in docstring.lower(), 'Key concept missing in docstring'\nassert 'Parameters:' in docstring, 'Parameters section missing in docstring'\nassert 'Returns:' in docstring, 'Returns section missing in docstring'\nportfolio = {'stocks': 100000, 'bonds': 50000, 'real_estate': 200000}\nthreshold = 300000\nrisk = assess_risk(portfolio, threshold)\nassert risk == True, 'Risk assessment calculation failed'\nportfolio = {'stocks': 100000, 'bonds': 50000, 'real_estate': 100000}\nthreshold = 300000\nrisk = assess_risk(portfolio, threshold)\nassert risk == False, 'Risk assessment calculation failed for edge case'", "gpt-4.1-nano": "    return sum(portfolio.values()) > threshold"}
{"id": "6", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "# Function to calculate the compound annual growth rate (CAGR)\ndef calculate_cagr(initial_value, final_value, years):\n    \"\"\"\n    Calculate the Compound Annual Growth Rate (CAGR).\n    \n    Parameters:\n    initial_value (float): The initial value of the investment.\n    final_value (float): The final value of the investment.\n    years (int): The number of years over which the investment grew.\n    \n    Returns:\n    float: The CAGR expressed as a decimal.\n    \"\"\"\n", "suffix": "\n# Example usage of the calculate_cagr function\ninitial_value = 1000\nfinal_value = 2000\nyears = 5\ncagr = calculate_cagr(initial_value, final_value, years)\nprint(f\"The CAGR is {cagr:.2%}\")\n\n# Assertions to verify the functionality and documentation of the calculate_cagr function\ndocstring = calculate_cagr.__doc__\nassert \"compound annual growth rate\" in docstring.lower()\nassert \"parameters:\" in docstring.lower()\nassert \"returns:\" in docstring.lower()\nassert cagr == (2000 / 1000) ** (1 / 5) - 1\n", "golden_completion": "    return (final_value / initial_value) ** (1 / years) - 1", "LLM_justification": "This example tests the ability to translate between Python code and documentation effectively. The function calculates the Compound Annual Growth Rate (CAGR), which involves financial calculations and ensures that all parameters and return values are correctly documented. The scenario includes assertions to verify the presence of key documentation terms and the correctness of the code implementation, covering both code-to-comment and comment-to-code translations.", "assertions": "assert \"compound annual growth rate\" in docstring.lower()\nassert \"parameters:\" in docstring.lower()\nassert \"returns:\" in docstring.lower()\nassert cagr == (2000 / 1000) ** (1 / 5) - 1", "gpt-4.1-nano": "    return (final_value / initial_value) ** (1 / years) - 1"}
{"id": "7", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class Portfolio:\n    def __init__(self):\n        self.stocks = {}\n\n    def add_stock(self, name, shares, price):\n        \"\"\"\n        Add a stock to the portfolio.\n\n        Parameters:\n        name (str): The name of the stock.\n        shares (int): The number of shares purchased.\n        price (float): The purchase price per share.\n        \"\"\"\n", "suffix": "\n    def total_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n\n        Returns:\n        float: The total value of all stocks in the portfolio.\n        \"\"\"\n        return sum(shares * price for shares, price in self.stocks.values())\n\n# Test the Portfolio class\nportfolio = Portfolio()\nportfolio.add_stock('AAPL', 10, 150.0)\nportfolio.add_stock('GOOGL', 5, 1000.0)\nassert portfolio.total_value() == 6500.0\n\n# Check if the add_stock method is documented correctly\nimport inspect\ndocstring = inspect.getdoc(Portfolio.add_stock)\nassert \"Parameters:\" in docstring\nassert \"name (str)\" in docstring\nassert \"shares (int)\" in docstring\nassert \"price (float)\" in docstring\n\n# Check if the total_value method is documented correctly\ndocstring = inspect.getdoc(Portfolio.total_value)\nassert \"Returns:\" in docstring\nassert \"float\" in docstring\n", "golden_completion": "        self.stocks[name] = (shares, price)\n", "LLM_justification": "This example is a good test case for code-to-comment and comment-to-code translation because it involves realistic business logic for managing a stock portfolio. It requires the generation of accurate function docstrings that explain parameters and return values, as well as the implementation of a method based on a comment specification. The assertions verify the correctness of the documentation and the functional behavior of the code, ensuring that the large language model can handle both directions of translation effectively.", "assertions": "portfolio.add_stock('MSFT', 3, 200.0)\nassert portfolio.total_value() == 7100.0\n\n# Check if the stocks were added correctly\nassert portfolio.stocks['AAPL'] == (10, 150.0)\nassert portfolio.stocks['GOOGL'] == (5, 1000.0)\nassert portfolio.stocks['MSFT'] == (3, 200.0)\n", "gpt-4.1-nano": "        self.stocks[name] = (shares, price)"}
{"id": "8", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class PortfolioAnalyzer:\n    def __init__(self, portfolio):\n        \"\"\"\n        Initialize the PortfolioAnalyzer with a given portfolio.\n\n        Parameters:\n        portfolio (list of dict): A list of dictionaries where each dictionary represents a financial instrument with keys 'ticker', 'quantity', and 'price'.\n        \"\"\"\n        self.portfolio = portfolio\n\n    def total_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n\n        Returns:\n        float: The total value of the portfolio.\n        \"\"\"\n        total = 0.0\n        for instrument in self.portfolio:\n", "suffix": "        return total\n\n# Example usage:\nportfolio = [\n    {'ticker': 'AAPL', 'quantity': 10, 'price': 150},\n    {'ticker': 'GOOG', 'quantity': 5, 'price': 1000},\n]\nanalyzer = PortfolioAnalyzer(portfolio)\nassert analyzer.total_value() == 6500.0\n", "golden_completion": "            total += instrument['quantity'] * instrument['price']\n", "LLM_justification": "This test case is a realistic scenario involving financial calculations. It tests the LLM's ability to generate accurate documentation for a class and its methods, as well as implement code that adheres to the provided documentation. The example covers initialization, parameter descriptions, return value documentation, and a usage example with assertions. The provided assertions verify that the total value calculation is correct, ensuring functional accuracy. This scenario tests both code-to-comment and comment-to-code translation effectively.", "assertions": "docstring = PortfolioAnalyzer.__init__.__doc__\nassert 'initialize the portfolioanalyzer' in docstring.lower()\nassert 'parameters:' in docstring.lower()\nassert 'portfolio (list of dict)' in docstring\n\nmethod_docstring = PortfolioAnalyzer.total_value.__doc__\nassert 'calculate the total value of the portfolio' in method_docstring.lower()\nassert 'returns:' in method_docstring.lower()\nassert 'float: the total value of the portfolio' in method_docstring.lower()\n\nportfolio = [\n    {'ticker': 'AAPL', 'quantity': 10, 'price': 150},\n    {'ticker': 'GOOG', 'quantity': 5, 'price': 1000},\n]\nanalyzer = PortfolioAnalyzer(portfolio)\nassert analyzer.total_value() == 6500.0\n", "gpt-4.1-nano": "            total += instrument['quantity'] * instrument['price']"}
{"id": "9", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def calculate_portfolio_risk(assets):\n    \"\"\"Calculate the risk of a portfolio based on its assets.\n\n    Parameters:\n    assets (list of dict): A list of assets where each asset is represented as a dictionary with keys 'name', 'value', and 'risk'.\n\n    Returns:\n    float: The total risk of the portfolio calculated as the weighted sum of individual asset risks.\n    \"\"\"\n    total_value = sum(asset['value'] for asset in assets)\n", "suffix": "    return total_risk\n\n# Example usage\nportfolio = [\n    {'name': 'Stock A', 'value': 10000, 'risk': 0.2},\n    {'name': 'Bond B', 'value': 5000, 'risk': 0.1}\n]\nassert calculate_portfolio_risk(portfolio) == 0.16666666666666666\n", "golden_completion": "    total_risk = sum((asset['value'] / total_value) * asset['risk'] for asset in assets)\n", "LLM_justification": "This example tests the LLM's ability to generate a function that calculates portfolio risk based on assets, ensuring it correctly translates the documentation into code and vice versa. The prompt and suffix provide context for the calculation, and the golden completion fills in the logic for the risk calculation. This scenario is realistic in financial applications, requiring proper handling of weighted sums and portfolio analysis.", "assertions": "assert 'portfolio' in calculate_portfolio_risk.__doc__.lower()\nassert 'assets' in calculate_portfolio_risk.__doc__.lower()\nassert 'Parameters:' in calculate_portfolio_risk.__doc__\nassert 'Returns:' in calculate_portfolio_risk.__doc__\nassert calculate_portfolio_risk(portfolio) == 0.16666666666666666\n", "gpt-4.1-nano": "total_risk = sum((asset['value'] / total_value) * asset['risk'] for asset in assets)"}
{"id": "10", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def calculate_portfolio_value(stocks):\n    \"\"\"\n    Calculate the total value of a stock portfolio.\n\n    Parameters:\n    stocks (dict): A dictionary where keys are stock tickers and values are tuples containing the number of shares and the price per share.\n\n    Returns:\n    float: The total value of the portfolio.\n    \"\"\"\n    total_value = 0\n    for ticker, (shares, price) in stocks.items():\n", "suffix": "    return total_value\n\n# Example usage\nportfolio = {'AAPL': (10, 150.0), 'GOOGL': (5, 1000.0), 'AMZN': (2, 2000.0)}\nvalue = calculate_portfolio_value(portfolio)\nassert value == 10500.0\nprint(f\"Total portfolio value: ${value}\")\n", "golden_completion": "        total_value += shares * price\n", "LLM_justification": "This example tests the translation between code and documentation by focusing on a practical financial calculation. The function is documented to calculate the total value of a stock portfolio, and the golden completion fills in the loop to accumulate the total value. The suffix includes a usage example and assertions to verify correctness.", "assertions": "assert 'calculate the total value of a stock portfolio' in calculate_portfolio_value.__doc__.lower()\nassert 'parameters:' in calculate_portfolio_value.__doc__.lower()\nassert 'returns:' in calculate_portfolio_value.__doc__.lower()\nassert calculate_portfolio_value({'AAPL': (10, 150.0), 'GOOGL': (5, 1000.0), 'AMZN': (2, 2000.0)}) == 10500.0\n", "gpt-4.1-nano": "        total_value += shares * price"}
{"id": "11", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def calculate_annualized_return(initial_value, final_value, years):\n    \"\"\"\n    Calculate the annualized return of an investment portfolio.\n\n    Parameters:\n    initial_value (float): The initial value of the investment\n    final_value (float): The final value of the investment\n    years (float): The number of years the investment was held\n\n    Returns:\n    float: The annualized return of the investment\n\"\"\"\n", "suffix": "\n# Example usage:\ninitial_value = 1000.0\nfinal_value = 1500.0\nyears = 5\nannualized_return = calculate_annualized_return(initial_value, final_value, years)\nassert round(annualized_return, 4) == 0.0845\nprint(f\"Annualized Return: {annualized_return:.4%}\")", "golden_completion": "    # Calculate the total return\n    total_return = final_value / initial_value\n    # Calculate the annualized return using the formula (total_return^(1/years)) - 1\n    annualized_return = (total_return ** (1 / years)) - 1\n    return annualized_return\n", "LLM_justification": "This test case is effective for evaluating an LLM's ability to translate between code and natural language because it involves a realistic financial calculation scenario. The function documentation includes detailed parameter descriptions and return value explanations, which tests the model's ability to generate accurate and complete documentation. The implementation requires understanding of financial formulas, ensuring the model can handle complex business logic. The assertions check for correct functionality and accurate return values, ensuring the code works as expected.", "assertions": "func = calculate_annualized_return\nassert func.__doc__ is not None\nassert 'annualized return' in func.__doc__.lower()\nassert 'parameters:' in func.__doc__.lower()\nassert 'initial_value' in func.__doc__.lower()\nassert 'final_value' in func.__doc__.lower()\nassert 'years' in func.__doc__.lower()\nassert 'returns:' in func.__doc__.lower()\nassert 'float' in func.__doc__.lower()", "gpt-4.1-nano": "    return (final_value / initial_value) ** (1 / years) - 1"}
{"id": "12", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import numpy as np\n\ndef calculate_portfolio_risk(returns, weights):\n    \"\"\"\n    Calculate the risk of a portfolio given the returns and weights of the assets.\n\n    Parameters:\n    returns (np.ndarray): A 2D numpy array where each column represents the returns of an asset over time.\n    weights (np.ndarray): A 1D numpy array representing the weights of each asset in the portfolio.\n\n    Returns:\n    float: The calculated portfolio risk.\n    \"\"\"\n    # Ensure the weights sum to 1\n    assert np.isclose(np.sum(weights), 1.0), \"Weights must sum to 1\"\n\n    # Calculate the covariance matrix of the returns\n    cov_matrix = np.cov(returns, rowvar=False)\n\n    # Calculate the portfolio variance\n    portfolio_variance = np.dot(weights.T, np.dot(cov_matrix, weights))\n\n    # The portfolio risk is the square root of the variance\n", "suffix": "\n\n# Example usage\nreturns = np.array([[0.01, 0.02, 0.03], [0.04, 0.01, 0.02], [0.05, 0.03, 0.01]])\nweights = np.array([0.4, 0.4, 0.2])\nrisk = calculate_portfolio_risk(returns, weights)\nprint(f\"Calculated portfolio risk: {risk}\")\n", "golden_completion": "    portfolio_risk = np.sqrt(portfolio_variance)\n    return portfolio_risk\n", "LLM_justification": "This test case is a good example because it involves calculating the risk of a financial portfolio, a common business logic scenario. It tests the LLM's ability to translate between code and documentation, ensuring that all parameters, return values, and key concepts are properly documented. The assertions verify the functional correctness of the implementation, including edge cases such as ensuring the weights sum to 1.", "assertions": "import numpy as np\n\nreturns = np.array([[0.01, 0.02, 0.03], [0.04, 0.01, 0.02], [0.05, 0.03, 0.01]])\nweights = np.array([0.4, 0.4, 0.2])\n\nrisk = calculate_portfolio_risk(returns, weights)\nassert isinstance(risk, float), \"The return value should be a float\"\nassert risk > 0, \"The portfolio risk should be greater than 0\"\n\n# Validate documentation\nimport inspect\ndocstring = inspect.getdoc(calculate_portfolio_risk)\nassert \"calculate the risk of a portfolio\" in docstring.lower()\nassert \"parameters:\" in docstring.lower()\nassert \"returns (np.ndarray)\" in docstring.lower()\nassert \"weights (np.ndarray)\" in docstring.lower()\nassert \"returns:\" in docstring.lower()\nassert \"float: the calculated portfolio risk\" in docstring.lower()\n", "gpt-4.1-nano": "np.sqrt(portfolio_variance)"}
{"id": "13", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class FinancialPortfolio:\n    def __init__(self):\n        self.holdings = []\n\n    def add_holding(self, symbol: str, shares: int, price: float):\n        \"\"\"\n        Add a holding to the portfolio.\n        \n        Parameters:\n        symbol (str): The ticker symbol of the holding.\n        shares (int): The number of shares held.\n        price (float): The price per share.\n        \n        Returns:\n        None\n        \"\"\"\n        self.holdings.append({\"symbol\": symbol, \"shares\": shares, \"price\": price})\n\n    def total_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n\n        Returns:\n        float: The total value of the portfolio.\n        \"\"\"\n", "suffix": "    def remove_holding(self, symbol: str):\n        \"\"\"\n        Remove a holding from the portfolio.\n        \n        Parameters:\n        symbol (str): The ticker symbol of the holding to be removed.\n        \n        Returns:\n        bool: True if the holding was removed, False if not found.\n        \"\"\"\n        for holding in self.holdings:\n            if holding[\"symbol\"] == symbol:\n                self.holdings.remove(holding)\n                return True\n        return False\n\n# Test cases to verify the implementation\nportfolio = FinancialPortfolio()\nportfolio.add_holding(\"AAPL\", 10, 150.0)\nportfolio.add_holding(\"GOOG\", 5, 1000.0)\nassert portfolio.total_value() == 6500.0\nassert portfolio.remove_holding(\"AAPL\") == True\nassert portfolio.total_value() == 5000.0\nassert portfolio.remove_holding(\"MSFT\") == False\n\n# Clean up resources\nportfolio = None\n", "golden_completion": "        total = 0.0\n        for holding in self.holdings:\n            total += holding[\"shares\"] * holding[\"price\"]\n        return total\n", "LLM_justification": "This example provides a realistic scenario of managing a financial portfolio, which involves adding and removing holdings and calculating the total portfolio value. The code includes comprehensive docstrings, specifying parameter types and return values, making it an excellent test for bidirectional translation capabilities. The assertions verify functional correctness and proper handling of edge cases. Additionally, the example emphasizes error handling and resource cleanup, crucial aspects of practical coding scenarios.", "assertions": "docstring = FinancialPortfolio.total_value.__doc__\nassert \"Calculate the total value\" in docstring\nassert \"Returns:\" in docstring\nassert \"float\" in docstring\nassert \"total value of the portfolio\" in docstring\nportfolio = FinancialPortfolio()\nportfolio.add_holding(\"AAPL\", 10, 150.0)\nportfolio.add_holding(\"GOOG\", 5, 1000.0)\nassert portfolio.total_value() == 6500.0\nassert portfolio.remove_holding(\"AAPL\") == True\nassert portfolio.total_value() == 5000.0\nassert portfolio.remove_holding(\"MSFT\") == False", "gpt-4.1-nano": "        total = 0.0\n        for holding in self.holdings:\n            total += holding[\"shares\"] * holding[\"price\"]\n        return total"}
{"id": "14", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class Portfolio:\n    def __init__(self):\n        self.investments = []\n\n    def add_investment(self, investment):\n        \"\"\"\n        Add an investment to the portfolio.\n\n        Parameters:\n        investment (dict): A dictionary containing investment details such as 'name', 'amount', and 'risk_level'.\n        \"\"\"\n        self.investments.append(investment)\n\n    def total_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n\n        Returns:\n        float: The total value of all investments.\n        \"\"\"\n", "suffix": "        return sum(investment['amount'] for investment in self.investments)\n\n# Create a portfolio and add some investments\nportfolio = Portfolio()\nportfolio.add_investment({'name': 'Stock A', 'amount': 1000, 'risk_level': 'high'})\nportfolio.add_investment({'name': 'Bond B', 'amount': 500, 'risk_level': 'low'})\n\n# Calculate and print the total value of the portfolio\nprint(portfolio.total_value())  # Expected output: 1500.0", "golden_completion": "        if not self.investments:\n            return 0.0\n", "LLM_justification": "This example tests the LLM's ability to generate both comments from code and code from comments, focusing on a realistic financial scenario. The provided code calculates the total value of a portfolio, and the completion ensures proper handling of edge cases by returning 0.0 if there are no investments. This scenario includes complex business logic, proper error handling, and realistic parameter and return value documentation.", "assertions": "portfolio = Portfolio()\nportfolio.add_investment({'name': 'Stock A', 'amount': 1000, 'risk_level': 'high'})\nportfolio.add_investment({'name': 'Bond B', 'amount': 500, 'risk_level': 'low'})\nassert portfolio.total_value() == 1500.0\nportfolio = Portfolio()\nassert portfolio.total_value() == 0.0\n", "gpt-4.1-nano": "        total = 0\n        for investment in self.investments:\n            total += investment['amount']\n        return total"}
{"id": "15", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import requests\n\ndef fetch_data_from_api(url):\n    \"\"\"\n    Fetches data from the given API URL.\n    \n    Parameters:\n    url (str): The API endpoint to fetch data from.\n    \n    Returns:\n    dict: The JSON response from the API parsed into a dictionary.\n    \n    Raises:\n    ValueError: If the response status code is not 200.\n    \"\"\"\n    response = requests.get(url)\n    if response.status_code != 200:\n        raise ValueError(\"API request failed with status code {}\".format(response.status_code))\n    return response.json()\n\n# Example usage:\n# data = fetch_data_from_api('https://api.example.com/data')\n# print(data)\n", "suffix": "def main():\n    try:\n        data = fetch_data_from_api('https://jsonplaceholder.typicode.com/todos/1')\n        assert isinstance(data, dict), 'The fetched data should be a dictionary'\n        print(\"Data fetched successfully.\")\n    except ValueError as ve:\n        print(\"Error fetching data:\", ve)\n\n    # Additional logic can be placed here\n\nif __name__ == \"__main__\":\n    main()\n", "golden_completion": "# Call the fetch_data_from_api function with a sample URL and handle the response\n", "LLM_justification": "This example tests the LLM's ability to translate between code and documentation effectively. It includes a function with a detailed docstring, outlining parameters, return values, and potential exceptions. The completion involves translating a comment into code, ensuring the LLM understands the context. The suffix includes a usage example, testing the function and handling errors, which ensures the documentation's accuracy and the function's correctness.", "assertions": "assert 'fetches data from the given api url' in fetch_data_from_api.__doc__.lower()\nassert 'parameters:' in fetch_data_from_api.__doc__.lower()\nassert 'returns:' in fetch_data_from_api.__doc__.lower()\nassert 'raises:' in fetch_data_from_api.__doc__.lower()\nassert 'url (str)' in fetch_data_from_api.__doc__.lower()\nassert 'dict: the json response from the api' in fetch_data_from_api.__doc__.lower()\nassert 'valueerror: if the response status code is not 200' in fetch_data_from_api.__doc__.lower()\ntry:\n    data = fetch_data_from_api('https://jsonplaceholder.typicode.com/nonexistent')\n    assert isinstance(data, dict), 'The fetched data should be a dictionary'\nexcept ValueError as ve:\n    assert str(ve) == 'API request failed with status code 404'", "gpt-4.1-nano": "    main()"}
{"id": "16", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import json\n\nclass ConfigManager:\n    def __init__(self, config_file):\n        self.config_file = config_file\n        self.config = None\n\n    def load_config(self):\n        \"\"\"\n        Load the configuration from the specified file.\n        \n        Raises:\n            FileNotFoundError: If the configuration file does not exist.\n            json.JSONDecodeError: If the configuration file contains invalid JSON.\n        \"\"\"\n", "suffix": "\n    def get_setting(self, key, default=None):\n        \"\"\"\n        Retrieve a setting from the configuration.\n\n        Parameters:\n            key (str): The key of the setting to retrieve.\n            default (any): The default value to return if the key does not exist.\n\n        Returns:\n            any: The value of the setting if it exists, otherwise the default value.\n        \"\"\"\n        return self.config.get(key, default)\n\n    def save_config(self):\n        \"\"\"\n        Save the current configuration to the specified file.\n        \n        Raises:\n            IOError: If the file cannot be written.\n        \"\"\"\n        with open(self.config_file, 'w') as f:\n            json.dump(self.config, f)\n\n# Example usage\nconfig_manager = ConfigManager('config.json')\ntry:\n    config_manager.load_config()\nexcept (FileNotFoundError, json.JSONDecodeError) as e:\n    print(f\"Error loading config: {e}\")\n\nassert 'load the configuration' in ConfigManager.load_config.__doc__.lower()\nassert 'raises' in ConfigManager.load_config.__doc__.lower()\nassert 'filenotfounderror' in ConfigManager.load_config.__doc__.lower()\nassert 'jsondecodeerror' in ConfigManager.load_config.__doc__.lower()\n", "golden_completion": "        with open(self.config_file, 'r') as f:\n            self.config = json.load(f)\n", "LLM_justification": "This example tests the translation of Python code to natural language documentation and vice versa. The function `load_config` includes a docstring that needs to be completed with the appropriate code to read a JSON configuration file. The documentation specifies the errors that should be handled, and the golden completion provides the implementation to load the file and handle potential exceptions. This scenario covers realistic business logic for configuration management and validates the translation capabilities of an LLM by ensuring that the code and comments are consistent and complete.", "assertions": "assert 'load the configuration' in ConfigManager.load_config.__doc__.lower()\nassert 'raises' in ConfigManager.load_config.__doc__.lower()\nassert 'filenotfounderror' in ConfigManager.load_config.__doc__.lower()\nassert 'jsondecodeerror' in ConfigManager.load_config.__doc__.lower()\n", "gpt-4.1-nano": "        with open(self.config_file, 'r') as f:\n            self.config = json.load(f)"}
{"id": "17", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def validate_business_rules(transaction):\n    \"\"\"\n    Validate the given transaction against business rules.\n\n    Parameters:\n    transaction (dict): A dictionary containing transaction details.\n\n    Returns:\n    bool: True if the transaction is valid, False otherwise.\n    \"\"\"\n\n    # Check if the transaction amount is positive\n", "suffix": "\n    # Ensure the transaction has a valid account number\n    if not transaction.get('account_number'):\n        return False\n\n    # Transaction is valid\n    return True\n\n# Example usage\ntransaction = {'amount': 100, 'account_number': '1234567890'}\nassert validate_business_rules(transaction) == True\n\ntransaction_invalid = {'amount': -50, 'account_number': '1234567890'}\nassert validate_business_rules(transaction_invalid) == False\n\ntransaction_invalid = {'amount': 100}\nassert validate_business_rules(transaction_invalid) == False", "golden_completion": "    if transaction['amount'] <= 0:\n        return False\n", "LLM_justification": "This is a realistic scenario involving the validation of business rules for transactions. The task involves translating between code and comments, ensuring that the documentation accurately describes the function's behavior. The validation checks for positive transaction amounts and the presence of an account number, which are common business rule requirements. This scenario tests the LLM's ability to generate accurate and complete documentation as well as correct implementation of specified rules.", "assertions": "assert 'validate the given transaction against business rules' in validate_business_rules.__doc__.lower()\nassert 'parameters:' in validate_business_rules.__doc__.lower()\nassert 'transaction (dict): a dictionary containing transaction details.' in validate_business_rules.__doc__.lower()\nassert 'returns:' in validate_business_rules.__doc__.lower()\nassert 'bool: true if the transaction is valid, false otherwise.' in validate_business_rules.__doc__.lower()\n\ntransaction = {'amount': 100, 'account_number': '1234567890'}\nassert validate_business_rules(transaction) == True\n\ntransaction_invalid = {'amount': -50, 'account_number': '1234567890'}\nassert validate_business_rules(transaction_invalid) == False\n\ntransaction_invalid = {'amount': 100}\nassert validate_business_rules(transaction_invalid) == False", "gpt-4.1-nano": "    if transaction.get('amount', 0) <= 0:\n        return False"}
{"id": "18", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def validate_business_rules(data):\n    \"\"\"\n    Validates that the given data dictionary complies with business rules.\n    - The 'age' field must be an integer between 18 and 65.\n    - The 'name' field must be a non-empty string.\n    - The 'salary' field must be a positive float.\n\n    Parameters:\n    data (dict): The data dictionary to validate.\n\n    Returns:\n    bool: True if data is valid, False otherwise.\n    \"\"\"\n", "suffix": "    if not isinstance(data['name'], str) or not data['name']:\n        return False\n    if not isinstance(data['salary'], (int, float)) or data['salary'] <= 0:\n        return False\n    return True\n\ndata_valid = validate_business_rules({'age': 30, 'name': 'John Doe', 'salary': 50000.0})\nassert data_valid is True\n\ninvalid_data = validate_business_rules({'age': 17, 'name': 'John Doe', 'salary': 50000.0})\nassert invalid_data is False\n\ninvalid_data = validate_business_rules({'age': 30, 'name': '', 'salary': 50000.0})\nassert invalid_data is False\n\ninvalid_data = validate_business_rules({'age': 30, 'name': 'John Doe', 'salary': -1000.0})\nassert invalid_data is False\n\nprint(\"All tests passed!\")", "golden_completion": "    if not isinstance(data['age'], int) or not (18 <= data['age'] <= 65):\n        return False\n", "LLM_justification": "This test case is a good example of validating business rules in a data dictionary, including checking for age, name, and salary constraints. The golden completion requires translating a comment into a code segment that verifies the 'age' field, and the suffix continues with the validation for other fields. The assertions ensure that the function adheres to the specifications and handles edge cases appropriately.", "assertions": "assert validate_business_rules({'age': 25, 'name': 'Alice', 'salary': 70000.0}) is True\nassert validate_business_rules({'age': 70, 'name': 'Bob', 'salary': 50000.0}) is False\nassert validate_business_rules({'age': 22, 'name': '', 'salary': 45000.0}) is False\nassert validate_business_rules({'age': 30, 'name': 'Charlie', 'salary': -1500.0}) is False\n", "gpt-4.1-nano": "    if not isinstance(data.get('age'), int) or not (18 <= data['age'] <= 65):\n        return False"}
{"id": "19", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import json\n\nclass FeatureFlagManager:\n    def __init__(self, config_file_path):\n        \"\"\"\n        Initialize the FeatureFlagManager with the provided configuration file path.\n\n        Parameters:\n        config_file_path (str): The path to the feature flag configuration file.\n        \"\"\"\n        self.config_file_path = config_file_path\n        self.flags = {}\n        self.load_flags()\n\n    def load_flags(self):\n        \"\"\"\n        Load feature flags from the configuration file into the flags dictionary.\n        \"\"\"\n", "suffix": "    def is_feature_enabled(self, feature_name):\n        \"\"\"\n        Check if a given feature is enabled.\n\n        Parameters:\n        feature_name (str): The name of the feature to check.\n\n        Returns:\n        bool: True if the feature is enabled, False otherwise.\n        \"\"\"\n        return self.flags.get(feature_name, False)\n\n    def refresh_flags(self):\n        \"\"\"\n        Refresh the feature flags by reloading the configuration file.\n        \"\"\"\n        self.load_flags()\n\nimport os\n\n# Create a test directory if it doesn't exist\nos.makedirs('path/to', exist_ok=True)\n\n# Create the config file with test data\nwith open('path/to/config.json', 'w') as f:\n    json.dump({\"feature_x\": True}, f)\n\n# Usage example\nconfig_path = 'path/to/config.json'\nmanager = FeatureFlagManager(config_path)\nassert manager.is_feature_enabled('new_feature') == False\nmanager.flags['new_feature'] = True\nassert manager.is_feature_enabled('new_feature') == True\n", "golden_completion": "        try:\n            with open(self.config_file_path, 'r') as file:\n                self.flags = json.load(file)\n        except (FileNotFoundError, json.JSONDecodeError) as e:\n            self.flags = {}\n            print(f\"Error loading flags: {e}\")\n", "LLM_justification": "This example tests the bidirectional translation between code and natural language. The prompt and suffix establish the context of a FeatureFlagManager class used for managing feature flags in a configuration file. The golden completion requires implementing the load_flags method, which involves reading a JSON file and handling potential errors. This scenario tests the model's ability to generate proper docstrings, translate comments into code, handle file operations, and manage exceptions. It also checks the completeness and correctness of the generated code and documentation.f", "assertions": "manager = FeatureFlagManager('nonexistent_path.json')\nassert manager.flags == {}\nmanager = FeatureFlagManager('path/to/config.json')\n# Assuming 'path/to/config.json' contains: {\"feature_x\": true}\n\n# Clean up the test files when done\nos.remove('path/to/config.json')\nos.rmdir('path/to')\n\nassert manager.flags == {\"feature_x\": True}\nassert 'Parameters:' in FeatureFlagManager.__init__.__doc__\nassert 'Returns:' in FeatureFlagManager.is_feature_enabled.__doc__\nassert 'feature_name' in FeatureFlagManager.is_feature_enabled.__doc__\nassert 'config_file_path' in FeatureFlagManager.__init__.__doc__\nassert 'Load feature flags from the configuration file' in FeatureFlagManager.load_flags.__doc__", "gpt-4.1-nano": "        with open(self.config_file_path, 'r') as f:\n            self.flags = json.load(f)"}
{"id": "20", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class CacheManager:\n    def __init__(self, max_size):\n        self.max_size = max_size\n        self.cache = {}\n        self.access_order = []\n\n    def set(self, key, value):\n        \"\"\"\n        Add a key-value pair to the cache. If the cache exceeds max_size, remove the least recently used item.\n\n        Parameters:\n        key (str): The key to add to the cache.\n        value (Any): The value to associate with the key.\n        \"\"\"\n", "suffix": "\n    def get(self, key):\n        \"\"\"\n        Retrieve the value associated with the given key from the cache.\n\n        Parameters:\n        key (str): The key whose value is to be retrieved.\n\n        Returns:\n        Any: The value associated with the key, or None if the key is not in the cache.\n        \"\"\"\n        if key in self.cache:\n            self.access_order.remove(key)\n            self.access_order.append(key)\n            return self.cache[key]\n        return None\n\n# Test cases for CacheManager class\ncache_manager = CacheManager(max_size=2)\ncache_manager.set('a', 1)\ncache_manager.set('b', 2)\nassert cache_manager.get('a') == 1\ncache_manager.set('c', 3)  # This should evict 'b'\nassert cache_manager.get('b') is None\nassert cache_manager.get('a') == 1\nassert cache_manager.get('c') == 3\ncache_manager.set('d', 4)  # This should evict 'a'\nassert cache_manager.get('a') is None\nassert cache_manager.get('c') == 3\nassert cache_manager.get('d') == 4", "golden_completion": "        if key in self.cache:\n            self.access_order.remove(key)\n        elif len(self.cache) >= self.max_size:\n            lru_key = self.access_order.pop(0)\n            del self.cache[lru_key]\n        self.cache[key] = value\n        self.access_order.append(key)", "LLM_justification": "This example tests the LLM's capability to translate between code and natural language effectively, specifically in the context of a CacheManager class. The prompt establishes the need for clear parameter and return value documentation, while the golden completion fills in the business logic of the set method according to the provided docstring. The suffix includes additional methods and test cases to ensure the functional correctness of the CacheManager class. The example effectively covers realistic technical scenarios such as cache management, LRU eviction policy, and appropriate documentation, making it a comprehensive test case.", "assertions": "cache_manager = CacheManager(max_size=2)\ncache_manager.set('a', 1)\ncache_manager.set('b', 2)\nassert cache_manager.get('a') == 1\ncache_manager.set('c', 3)  # This should evict 'b'\nassert cache_manager.get('b') is None\nassert cache_manager.get('a') == 1\nassert cache_manager.get('c') == 3\ncache_manager.set('d', 4)  # This should evict 'a'\nassert cache_manager.get('a') is None\nassert cache_manager.get('c') == 3\nassert cache_manager.get('d') == 4", "gpt-4.1-nano": "        if key in self.cache:\n            self.access_order.remove(key)\n        elif len(self.cache) >= self.max_size:\n            oldest_key = self.access_order.pop(0)\n            del self.cache[oldest_key]\n        self.cache[key] = value\n        self.access_order.append(key)"}
{"id": "21", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class DataTransformer:\n    def __init__(self, data):\n        self.data = data\n\n    def clean_data(self):\n        \"\"\"\n        Clean the data by removing any entries with null values.\n\n        Returns:\n            list: A list of cleaned data entries.\n        \"\"\"\n        cleaned_data = [entry for entry in self.data if entry is not None]\n        return cleaned_data\n\n    def transform_data(self):\n        \"\"\"\n        Transform the cleaned data by applying a predefined set of transformations.\n\n        Returns:\n            list: A list of transformed data entries.\n        \"\"\"\n", "suffix": "    def validate_data(self):\n        \"\"\"\n        Validate the transformed data against business rules.\n\n        Returns:\n            bool: True if all data entries are valid, False otherwise.\n        \"\"\"\n        for entry in self.data:\n            if entry is None:\n                continue  # Skip None entries\n            if not isinstance(entry, dict) or 'value' not in entry:\n                return False\n        return True\n\ndata = [{'value': 10}, {'value': 20}, None, {'value': 30}]\ntransformer = DataTransformer(data)\ncleaned_data = transformer.clean_data()\ntransformed_data = transformer.transform_data()\nassert transformer.validate_data() == True\n", "golden_completion": "        transformed_data = [entry['value'] * 2 for entry in self.data if entry is not None]\n        return transformed_data\n", "LLM_justification": "This example tests the bidirectional translation between code and natural language by requiring the generation of function docstrings and the implementation of a data transformation function. The prompt provides the class and method structure, with the need to complete the transformation logic and associated documentation. The golden completion includes a realistic data transformation operation, and the suffix contains additional methods and test cases to ensure the code's correctness. Assertions check for the presence of key terms in the docstrings and the functional correctness of the data validation logic.", "assertions": "docstring = DataTransformer.transform_data.__doc__\nassert 'transform the cleaned data' in docstring.lower()\nassert 'returns:' in docstring.lower()\nassert 'list' in docstring.lower()\nassert 'transformed data entries' in docstring.lower()\nassert cleaned_data == [{'value': 10}, {'value': 20}, {'value': 30}]\nassert transformed_data == [20, 40, 60]\nassert transformer.validate_data() == True", "gpt-4.1-nano": "        return [entry['value'] * 2 for entry in self.clean_data()]"}
{"id": "22", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class DataTransformer:\n    def __init__(self, data):\n        self.data = data\n\n    def clean_data(self):\n        \"\"\"\n        Perform data cleaning by removing duplicates and handling missing values.\n\n        Returns:\n            list: Cleaned data with duplicates removed and missing values handled.\n        \"\"\"\n        # Step 1: Remove duplicates\n        self.data = list(set(self.data))\n", "suffix": "\n        # Step 3: Return the cleaned data\n        return self.data\n\ndata = [1, 2, 2, None, 4, None, 5]\ntransformer = DataTransformer(data)\ncleaned_data = transformer.clean_data()\nassert cleaned_data == [1, 2, 4, 5]\n", "golden_completion": "        # Step 2: Handle missing values\n        self.data = [x for x in self.data if x is not None]\n", "LLM_justification": "This test case evaluates the LLM's ability to translate between code and natural language effectively by documenting the steps involved in a data cleaning process. The prompt establishes a partially documented method, and the golden completion requires adding a missing step along with appropriate comments. The suffix then completes the method and validates the functionality with assertions. This provides a robust test of both code-to-comment and comment-to-code translation capabilities.", "assertions": "assert 'duplicates' in DataTransformer.clean_data.__doc__.lower()\nassert 'missing values' in DataTransformer.clean_data.__doc__.lower()\nassert 'Returns:' in DataTransformer.clean_data.__doc__\nassert 'list' in DataTransformer.clean_data.__doc__\nassert cleaned_data == [1, 2, 4, 5]\n", "gpt-4.1-nano": "        # Step 2: Handle missing values\n        self.data = [x if x is not None else 0 for x in self.data]"}
{"id": "23", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def is_age_compliant(age: int) -> bool:\n    \"\"\"\n    This function verifies if the user's age is within the allowed range.\n    Parameters:\n    - age (int): The age of the user\n    Returns:\n    - bool: True if age is compliant, False otherwise\n    \"\"\"\n", "suffix": "\n# Example usage:\n# assert is_age_compliant(25) == True\n# assert is_age_compliant(10) == False\n# assert is_age_compliant(18) == True\n# assert is_age_compliant(60) == False\nassert is_age_compliant(25) == True\nassert is_age_compliant(10) == False\nassert is_age_compliant(18) == True\nassert is_age_compliant(60) == False", "golden_completion": "    if age < 18 or age > 55:\n        return False\n    return True", "LLM_justification": "This example tests the LLM's ability to accurately translate between code and comments, ensuring that the function implementation matches the provided documentation. The function checks if the user's age is within the allowed range, which is a realistic business rule validation scenario. The assertions test various edge cases to verify functional correctness.", "assertions": "assert is_age_compliant(25) == True\nassert is_age_compliant(10) == False\nassert is_age_compliant(18) == True\nassert is_age_compliant(60) == False\nassert 'verifies if the user\\'s age is within the allowed range' in is_age_compliant.__doc__.lower()\nassert 'parameters:' in is_age_compliant.__doc__.lower()\nassert 'returns:' in is_age_compliant.__doc__.lower()\nassert 'age (int): the age of the user' in is_age_compliant.__doc__.lower()\nassert 'bool: true if age is compliant, false otherwise' in is_age_compliant.__doc__.lower()", "gpt-4.1-nano": "    return 18 <= age <= 59"}
{"id": "24", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import pandas as pd\n\nclass DataCleaner:\n    def __init__(self, data):\n        self.data = data\n\n    def remove_nulls(self):\n        \"\"\"\n        Removes null values from the dataset.\n\n        Returns:\n            DataFrame: A new DataFrame with null values removed.\n        \"\"\"\n", "suffix": "\n    def normalize_columns(self):\n        \"\"\"\n        Normalize the columns in the dataset.\n\n        Returns:\n            DataFrame: A new DataFrame with normalized columns.\n        \"\"\"\n        self.data = (self.data - self.data.mean()) / self.data.std()\n        return self.data\n\ndata = pd.DataFrame({\n    'A': [1, 2, None, 4],\n    'B': [None, 2, 3, 4]\n})\ncleaner = DataCleaner(data)\ncleaned_data = cleaner.remove_nulls()\nnormalized_data = cleaner.normalize_columns()\n\nassert 'Removes null values' in cleaner.remove_nulls.__doc__\nassert 'Returns' in cleaner.remove_nulls.__doc__\nassert 'DataFrame' in cleaner.remove_nulls.__doc__\nassert cleaned_data.isnull().sum().sum() == 0\nassert normalized_data.mean().round(0).sum() == 0", "golden_completion": "        self.data = self.data.dropna()\n        return self.data\n", "LLM_justification": "This test case demonstrates the translation of code to documentation and vice versa for a data cleaning scenario, which is common in data processing tasks. The prompt provides the context for a method that removes null values from a dataset, including its docstring. The golden_completion completes the method implementation based on the provided documentation. The suffix includes another method with a similar pattern, ensuring the code is realistic and practical. Assertions validate the correctness of both documentation and implementation, ensuring the presence of key terms and functional behavior.", "assertions": "assert 'Removes null values' in cleaner.remove_nulls.__doc__\nassert 'Returns' in cleaner.remove_nulls.__doc__\nassert 'DataFrame' in cleaner.remove_nulls.__doc__\nassert cleaned_data.isnull().sum().sum() == 0\nassert normalized_data.mean().round(0).sum() == 0", "gpt-4.1-nano": "        return self.data.dropna()"}
{"id": "25", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "# Function to clean a list of strings by removing leading and trailing spaces, converting to lowercase, and removing empty strings\n", "suffix": "\n# Usage example\ncleaned_list = clean_string_list(['  Hello  ', '  world', '', 'Python  '])\nassert cleaned_list == ['hello', 'world', 'python']\n\n# Test edge cases\ncleaned_list = clean_string_list(['  ', '  ', ''])\nassert cleaned_list == []\n\ncleaned_list = clean_string_list(['Python', '  PYTHON  '])\nassert cleaned_list == ['python', 'python']\n\nprint('All tests passed!')", "golden_completion": "def clean_string_list(strings):\n    \"\"\"\n    Clean a list of strings by removing leading and trailing spaces,\n    converting to lowercase, and removing empty strings.\n\n    Parameters:\n    strings (list of str): The list of strings to clean.\n\n    Returns:\n    list of str: The cleaned list of strings.\n    \"\"\"\n    return [s.strip().lower() for s in strings if s.strip()]\n", "LLM_justification": "This example tests the LLM's ability to generate a complete function with a proper docstring that includes a description, parameters, and return value. The function implements a realistic data cleaning task, which is common in business logic. The generated documentation should cover all important aspects of the function, and the assertions validate its functional correctness and edge cases. This scenario effectively tests the bidirectional translation between code and documentation.", "assertions": "docstring = clean_string_list.__doc__\nassert 'clean a list of strings' in docstring.lower()\nassert 'parameters:' in docstring.lower()\nassert 'strings (list of str)' in docstring.lower()\nassert 'returns:' in docstring.lower()\nassert 'list of str' in docstring.lower()\n", "gpt-4.1-nano": "def clean_string_list(strings):\n    return [s.strip().lower() for s in strings if s.strip()]"}
{"id": "26", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def validate_order(order):\n    \"\"\"\n    Validate an order based on business rules.\n\n    Parameters:\n    order (dict): A dictionary containing order details.\n\n    Returns:\n    bool: True if the order is valid, False otherwise.\n    \"\"\"\n    # Rule: The order must contain 'id', 'customer_id', and 'total' fields\n", "suffix": "    # Rule: The 'total' must be a positive number\n    if not isinstance(order.get('total'), (int, float)) or order['total'] <= 0:\n        return False\n    return True\n\n# Example usage\nvalid_order = {'id': 1, 'customer_id': 123, 'total': 50.0}\ninvalid_order = {'id': 2, 'customer_id': 456, 'total': -10.0}\n\nassert validate_order(valid_order) == True\nassert validate_order(invalid_order) == False\n", "golden_completion": "    required_fields = ['id', 'customer_id', 'total']\n    if not all(field in order for field in required_fields):\n        return False\n", "LLM_justification": "This example tests the model's ability to generate correct validation logic based on provided comments, which describe business rules for order validation. The example is realistic and demonstrates the complexity of business logic in ensuring required fields and positive 'total' values. The golden completion ensures all necessary fields are present in the order dictionary, while the suffix checks for positive 'total' values and provides usage examples. Assertions verify both the correct implementation of the business rules and the accuracy of the documentation.", "assertions": "assert 'Validate an order based on business rules' in validate_order.__doc__\nassert 'Parameters:' in validate_order.__doc__\nassert 'order (dict): A dictionary containing order details.' in validate_order.__doc__\nassert 'Returns:' in validate_order.__doc__\nassert 'bool: True if the order is valid, False otherwise.' in validate_order.__doc__\nassert validate_order({'id': 1, 'customer_id': 123, 'total': 50.0}) == True\nassert validate_order({'id': 2, 'customer_id': 456, 'total': -10.0}) == False\nassert validate_order({'id': 3, 'customer_id': 789}) == False", "gpt-4.1-nano": "    if 'total' not in order or not isinstance(order['total'], (int, float)) or order['total'] <= 0:\n        return False"}
{"id": "27", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def validate_transaction(transaction):\n    \"\"\"Validates a financial transaction based on business rules.\n\n    Parameters:\n    transaction (dict): A dictionary containing transaction details with keys 'amount', 'currency', and 'timestamp'.\n\n    Returns:\n    bool: True if the transaction is valid, False otherwise.\n    \"\"\"\n    # Check if the transaction amount is positive\n", "suffix": "    if transaction['currency'] not in ['USD', 'EUR', 'GBP']:\n        return False\n\n    # Check if the timestamp is within the allowed range\n    if transaction['timestamp'] < 1609459200 or transaction['timestamp'] > 1672444800:\n        return False\n\n    return True\n\n# Example usage\ntransaction = {'amount': 100, 'currency': 'USD', 'timestamp': 1610000000}\nassert validate_transaction(transaction) == True\n\ntransaction_invalid_currency = {'amount': 100, 'currency': 'JPY', 'timestamp': 1610000000}\nassert validate_transaction(transaction_invalid_currency) == False\n\ntransaction_invalid_timestamp = {'amount': 100, 'currency': 'USD', 'timestamp': 1500000000}\nassert validate_transaction(transaction_invalid_timestamp) == False\n\n# Cleanup resources if any (not needed in this case)\n", "golden_completion": "    if transaction['amount'] <= 0:\n        return False\n", "LLM_justification": "This example effectively tests the LLM's ability to translate between code and comments, focusing on business rules validation. The prompt provides a clear function header and part of the implementation, with the golden completion requiring understanding of the comment to complete the code. The suffix demonstrates the usage and additional validation steps, ensuring completeness. Assertions verify functional correctness and documentation accuracy.", "assertions": "assert 'validates a financial transaction based on business rules' in validate_transaction.__doc__.lower()\nassert 'parameters:' in validate_transaction.__doc__.lower()\nassert 'transaction (dict):' in validate_transaction.__doc__.lower()\nassert 'returns:' in validate_transaction.__doc__.lower()\nassert validate_transaction({'amount': 100, 'currency': 'USD', 'timestamp': 1610000000}) == True\nassert validate_transaction({'amount': 100, 'currency': 'JPY', 'timestamp': 1610000000}) == False\nassert validate_transaction({'amount': 100, 'currency': 'USD', 'timestamp': 1500000000}) == False\nassert validate_transaction({'amount': -100, 'currency': 'USD', 'timestamp': 1610000000}) == False", "gpt-4.1-nano": "    if transaction['amount'] <= 0:"}
{"id": "28", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def transform_data(data):\n    \"\"\"\n    This function applies a series of transformations to the input data.\nIt removes entries with missing or None 'value' field, applies a 10% increase to the 'value' field, and filters out entries with 'value' less than 10.\n\n    Parameters:\n    data (list of dicts): The input data to transform.\n\n    Returns:\n    list of dicts: The transformed data.\n    \"\"\"\n    # Step 1: Remove entries with missing 'value' field\n    cleaned_data = [entry for entry in data if 'value' in entry and entry['value'] is not None]\n    # Step 2: Apply a 10% increase to the 'value' field\n", "suffix": "\n    # Step 3: Filter out entries with 'value' less than 10\n    final_data = [entry for entry in transformed_data if entry['value'] >= 10]\n    return final_data\n\ndata = [{'value': 5}, {'value': 15}, {'value': None}, {'value': 20}]\nresult = transform_data(data)\n\nassert len(result) == 2\nassert result[0]['value'] == 16.5\nassert result[1]['value'] == 22.0\n", "golden_completion": "    transformed_data = [{'value': entry['value'] * 1.1} for entry in cleaned_data]\n", "LLM_justification": "This example tests the ability to translate between code and comments, focusing on realistic data transformation tasks. The code-to-comment translation requires understanding the data filtering and transformation steps. The comment-to-code translation involves implementing the specified steps accurately. Assertions verify the correctness of the transformations, ensuring that data cleaning, transformation, and filtering are correctly implemented and documented.", "assertions": "assert 'removes entries with missing' in transform_data.__doc__.lower()\nassert 'applies a 10% increase to the' in transform_data.__doc__.lower()\nassert 'filters out entries with' in transform_data.__doc__.lower()\nassert len(result) == 2\nassert result[0]['value'] == 16.5\nassert result[1]['value'] == 22.0\n", "gpt-4.1-nano": "    transformed_data = [{'value': entry['value'] * 1.10} for entry in cleaned_data]"}
{"id": "29", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class User:\n    def __init__(self, username, email, age):\n        self.username = username\n        self.email = email\n        self.age = age\n\n    def is_valid_age(self):\n        \"\"\"\n        Determine if the user is of a valid age to register.\n\n        Returns:\n            bool: True if the user is 18 or older, False otherwise.\n        \"\"\"\n", "suffix": "\n    def can_receive_newsletter(self):\n        \"\"\"\n        Check if the user is eligible to receive newsletters.\n\n        Returns:\n            bool: True if the user has provided a valid email and is 13 or older.\n        \"\"\"\n        return '@' in self.email and self.age >= 13\n\n# Test cases\ndef test_user_validations():\n    user1 = User('john_doe', 'john@example.com', 25)\n    user2 = User('jane_doe', 'janeexample.com', 17)\n    assert user1.is_valid_age() == True\n    assert user2.is_valid_age() == False\n    assert user1.can_receive_newsletter() == True\n    assert user2.can_receive_newsletter() == False\n\ntest_user_validations()\n\n# Clean up resources if any\n# (no resources to clean up in this example)\n", "golden_completion": "        return self.age >= 18\n", "LLM_justification": "This is a good test case because it involves translating between code and documentation for a class method. The example provides a realistic scenario of user validation logic often found in business applications. The golden completion demonstrates understanding of the method's purpose and accurately translates the documentation into code. Additionally, the suffix includes a different method and test cases to ensure all assertions pass and verify the correctness of both the code and its documentation. The provided docstrings follow best practices, and the assertions check functional requirements and edge cases.", "assertions": "assert 'determine if the user is of a valid age to register' in User.is_valid_age.__doc__.lower()\nassert 'returns:' in User.is_valid_age.__doc__.lower()\nassert 'bool: true if the user is 18 or older, false otherwise.' in User.is_valid_age.__doc__.lower()\nassert User('test_user', 'test@example.com', 20).is_valid_age() == True\nassert User('test_user', 'test@example.com', 17).is_valid_age() == False\n", "gpt-4.1-nano": "        return self.age >= 18"}
{"id": "30", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class BusinessValidator:\n    def __init__(self, rules):\n        self.rules = rules\n\n    def validate(self, data):\n        valid = True\n        errors = []\n        for rule in self.rules:\n            result, message = rule(data)\n            if not result:\n                valid = False\n                errors.append(message)\n        return valid, errors\n\n# The above code defines a class BusinessValidator with an __init__ method and a validate method.\n# The validate method checks if the provided data conforms to the rules and returns a tuple (valid, errors).\n# Now, let's add comprehensive documentation for the validate method explaining its purpose, parameters, return values, and error handling.", "suffix": "\n# The following code demonstrates how to use the BusinessValidator class.\nrules = [\n    lambda data: (data['age'] >= 18, 'Age must be at least 18'),\n    lambda data: (data['email'].count('@') == 1, 'Email must contain exactly one @')\n]\n\nvalidator = BusinessValidator(rules)\ndata = {'age': 17, 'email': 'testexample.com'}\nvalid, errors = validator.validate(data)\nassert not valid\nassert 'Age must be at least 18' in errors\nassert 'Email must contain exactly one @' in errors\n\n# Cleaning up resources (if any)\n# No resources to clean up in this example.", "golden_completion": "    def validate(self, data):\n        \"\"\"\n        Validate the provided data against the set of rules.\n\n        Parameters:\n        data (dict): The data to be validated. It must contain the keys required by the rules.\n\n        Returns:\n        tuple: A tuple containing a boolean indicating if the data is valid, and a list of error messages if any.\n\n        Errors:\n        This method will collect error messages for each rule that the data does not conform to.\n        \"\"\"\n        valid = True\n        errors = []\n        for rule in self.rules:\n            result, message = rule(data)\n            if not result:\n                valid = False\n                errors.append(message)\n        return valid, errors", "LLM_justification": "This test case is a good example because it involves realistic business logic for validating data against a set of rules. It requires the model to generate comprehensive documentation for an existing method, including parameter descriptions, return values, and error handling. The provided assertions test the documentation's presence and coverage of important concepts, ensuring the documentation accurately reflects the method's purpose and behavior.", "assertions": "docstring = BusinessValidator.validate.__doc__\nassert 'validate the provided data' in docstring.lower()\nassert 'parameters:' in docstring.lower()\nassert 'data (dict)' in docstring.lower()\nassert 'returns:' in docstring.lower()\nassert 'tuple' in docstring.lower()\nassert 'errors:' in docstring.lower()\nassert 'error messages' in docstring.lower()", "gpt-4.1-nano": "\"\"\"\nValidates the provided data against a set of rules.\n\nThis method iterates through each rule in the validator's rules list,\napplying the rule to the data. Each rule is expected to be a callable\nthat takes the data as input and returns a tuple (result, message),\nwhere 'result' is a boolean indicating if the data passes the rule,\nand 'message' is a string describing the error if the rule fails.\n\nParameters:\n    data (dict): The data to be validated, typically a dictionary\n                 containing key-value pairs representing the data fields.\n\nReturns:\n    tuple:\n        - valid (bool): True if all rules pass; False otherwise.\n        - errors (list): A list of error messages for each rule that failed.\n\nError Handling:\n    If a rule raises an exception during validation, it will be caught,\n    and the validation will continue with the remaining rules. The exception\n    message will be added to the errors list as a string.\n\"\"\""}
{"id": "31", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "# Implement a function that validates a user's password based on business rules:\n# 1. Password must be at least 8 characters long.\n# 2. Password must contain at least one uppercase letter.\n# 3. Password must contain at least one lowercase letter.\n# 4. Password must contain at least one digit.\n# 5. Password must contain at least one special character (!@#$%^&*).\n# 6. Password must not contain spaces.\n\ndef validate_password(password: str) -> bool:\n    \"\"\" Validate the password based on the given business rules. \"\"\"\n", "suffix": "\n# Example usage:\n# valid_password = 'Aa1!aaaa'\n# invalid_password = 'Aa1aaaaa'\n# assert validate_password(valid_password) is True\n# assert validate_password(invalid_password) is False\n\n# Assertions\ndef test_validate_password():\n    valid_password = 'Aa1!aaaa'\n    invalid_passwords = ['Aa1aaaaa', 'Aa1!aaaa ', 'aa1!aaaa', 'AA1!AAAA', 'Aa!aaaaa']\n    assert validate_password(valid_password) is True\n    for pwd in invalid_passwords:\n        assert validate_password(pwd) is False\n\n# Run tests\ntest_validate_password()\n", "golden_completion": "    if len(password) < 8:\n        return False\n    if not any(char.isupper() for char in password):\n        return False\n    if not any(char.islower() for char in password):\n        return False\n    if not any(char.isdigit() for char in password):\n        return False\n    if not any(char in '!@#$%^&*' for char in password):\n        return False\n    if ' ' in password:\n        return False\n    return True\n", "LLM_justification": "This test case is a good example of translating detailed business logic into functional code. The requirements for password validation are clearly stated in the comments, and the completion involves implementing these rules in Python. The test case checks for various edge cases and ensures that the function behaves as expected. This scenario tests the LLM's ability to comprehend and implement complex business rules accurately.", "assertions": "test_validate_password()\n", "gpt-4.1-nano": "    if len(password) < 8:\n        return False\n    if not any(c.isupper() for c in password):\n        return False\n    if not any(c.islower() for c in password):\n        return False\n    if not any(c.isdigit() for c in password):\n        return False\n    if not any(c in '!@#$%^&*' for c in password):\n        return False\n    if ' ' in password:\n        return False\n    return True"}
{"id": "32", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def process_data(data):\n    \"\"\"\n    Process the input data by removing duplicates, sorting, and normalizing.\n\n    Parameters:\n    data (list): The input list of data points.\n\n    Returns:\n    list: The processed list of data points.\n    \"\"\"\n    # Remove duplicates\n    data = list(set(data))\n    # Sort the data\n", "suffix": "    # Normalize the data\n    min_val = min(data)\n    max_val = max(data)\n    data = [(x - min_val) / (max_val - min_val) for x in data]\n    return data\n\n# Example usage\ninput_data = [5, 3, 6, 2, 5, 3]\nprocessed_data = process_data(input_data)\nprint(processed_data)  # Output should be a list of normalized values\n", "golden_completion": "    data.sort()\n", "LLM_justification": "This test case is a realistic scenario for data processing in business logic. It requires translation from code to natural language by documenting an existing function, which tests the model's ability to generate comprehensive docstrings. It also involves translating comments into code, ensuring the model can implement specified functionality. The code includes data cleaning, sorting, and normalization, making it a good test of complex business logic. Assertions validate both the documentation and the functional requirements of the code.", "assertions": "assert process_data([5, 3, 6, 2, 5, 3]) == [0.0, 0.25, 0.75, 1.0]\nassert process_data([1, 2, 3, 4, 5]) == [0.0, 0.25, 0.5, 0.75, 1.0]\ndocstring = process_data.__doc__\nassert \"removing duplicates\" in docstring.lower()\nassert \"sorting\" in docstring.lower()\nassert \"normalizing\" in docstring.lower()\nassert \"Parameters:\" in docstring\nassert \"Returns:\" in docstring", "gpt-4.1-nano": "    data = sorted(data)"}
{"id": "33", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import requests\n\nclass APIClient:\n    def __init__(self, base_url, api_key):\n        self.base_url = base_url\n        self.api_key = api_key\n\n    def get_data(self, endpoint):\n        \"\"\"\n        Retrieves data from the specified API endpoint.\n\n        Parameters:\n        endpoint (str): The API endpoint to retrieve data from.\n\n        Returns:\n        dict: The JSON response from the API.\n\n        Raises:\n        ValueError: If the response contains an error.\n        \"\"\"\n        headers = {'Authorization': f'Bearer {self.api_key}'}\n        response = requests.get(f'{self.base_url}/{endpoint}', headers=headers)\n        if response.status_code != 200:\n            raise ValueError(f'Error fetching data: {response.status_code}')\n        return response.json()\n\n    # Generate comprehensive documentation for the following function\n    def post_data(self, endpoint, data):", "suffix": "\n        headers = {'Authorization': f'Bearer {self.api_key}', 'Content-Type': 'application/json'}\n        response = requests.post(f'{self.base_url}/{endpoint}', headers=headers, json=data)\n        if response.status_code != 201:\n            raise ValueError(f'Error posting data: {response.status_code}')\n        return response.json()\n\n# Example usage\nclient = APIClient('https://jsonplaceholder.typicode.com', '')\ntry:\n    response = client.post_data('posts', {'title': 'Test Post', 'body': 'Test content', 'userId': 1})\n    assert 'id' in response\nfinally:\n    # Clean up resources if necessary\n    pass", "golden_completion": "\n        \"\"\"\n        Sends data to the specified API endpoint.\n\n        Parameters:\n        endpoint (str): The API endpoint to send data to.\n        data (dict): The data to be sent to the API.\n\n        Returns:\n        dict: The JSON response from the API.\n\n        Raises:\n        ValueError: If the response contains an error.\n        \"\"\"\n", "LLM_justification": "This test case is a realistic example of API client implementation, involving both GET and POST requests. It tests the LLM's ability to generate comprehensive documentation for a method that handles HTTP POST requests, including parameter descriptions, return value, and error handling. This scenario is common in business logic for interacting with external services. The completion provides detailed docstrings that align with the function's purpose, ensuring clear documentation. Assertions verify the presence of key documentation elements and the functionality of the code.", "assertions": "client = APIClient('https://jsonplaceholder.typicode.com', '')\ndocstring = APIClient.post_data.__doc__\nassert 'Sends data to the specified API endpoint.' in docstring\nassert 'Parameters:' in docstring\nassert 'endpoint (str): The API endpoint to send data to.' in docstring\nassert 'data (dict): The data to be sent to the API.' in docstring\nassert 'Returns:' in docstring\nassert 'dict: The JSON response from the API.' in docstring\nassert 'Raises:' in docstring\nassert 'ValueError: If the response contains an error.' in docstring\ntry:\n    mock_response = client.post_data('posts', {'title': 'Test Post', 'body': 'Test content', 'userId': 1})\n    assert 'id' in mock_response\nexcept ValueError as e:\n    assert 'Error posting data' in str(e)\nfinally:\n    pass", "gpt-4.1-nano": "\"\"\"\nPosts data to the specified API endpoint.\n\nParameters:\nendpoint (str): The API endpoint to send data to.\ndata (dict): The data payload to be sent in the POST request.\n\nReturns:\ndict: The JSON response from the API upon successful POST.\n\nRaises:\nValueError: If the response status code indicates an error during posting.\n\"\"\"\nheaders = {'Authorization': f'Bearer {self.api_key}', 'Content-Type': 'application/json'}\nresponse = requests.post(f'{self.base_url}/{endpoint}', headers=headers, json=data)\nif response.status_code != 201:\n    raise ValueError(f'Error posting data: {response.status_code}')\nreturn response.json()"}
{"id": "34", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import json\n\nclass ConfigManager:\n    def __init__(self, config_file):\n        self.config_file = config_file\n        self.config_data = None\n\n    def load_config(self):\n        \"\"\"\n        Loads the configuration from the specified JSON file.\n        \"\"\"\n", "suffix": "    def get_setting(self, key):\n        \"\"\"\n        Retrieves a setting value by key.\n\n        Parameters:\n        key (str): The key of the setting to retrieve.\n\n        Returns:\n        The value of the setting if the key exists, otherwise None.\n        \"\"\"\n        return self.config_data.get(key) if self.config_data else None\n\nwith open('config.json', 'w') as f:\n    json.dump({\n        'database_url': 'http://localhost:5432',\n        'api_key': 'sample_key',\n        'debug': True\n    }, f)\n\n# Example usage\nconfig_manager = ConfigManager('config.json')\nconfig_manager.load_config()\nprint(config_manager.get_setting('database_url'))\n", "golden_completion": "        with open(self.config_file, 'r') as file:\n            self.config_data = json.load(file)\n", "LLM_justification": "This test case is a good example because it involves a realistic scenario of loading configuration from a JSON file and retrieving settings. The prompt sets up the class and method without the implementation, while the golden completion provides the implementation of the load_config method. The suffix includes additional methods and usage examples. Assertions verify that the class correctly loads the configuration and retrieves settings.", "assertions": "config_manager = ConfigManager('test_config.json')\nwith open('test_config.json', 'w') as f:\n    json.dump({'database_url': 'http://localhost'}, f)\nconfig_manager.load_config()\nassert config_manager.get_setting('database_url') == 'http://localhost'\nassert config_manager.get_setting('non_existent_key') is None\nimport os\nos.remove('test_config.json')", "gpt-4.1-nano": "        with open(self.config_file, 'r') as f:\n            self.config_data = json.load(f)"}
{"id": "35", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class DataTransformer:\n    def __init__(self, data):\n        self.data = data\n\n    def clean_data(self):\n        # This function removes null values and duplicates from the data.\n", "suffix": "        return self.data\n\n# Example usage:\ndata = [{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': None}, {'name': 'Alice', 'age': 25}]\ntransformer = DataTransformer(data)\ncleaned_data = transformer.clean_data()\nassert cleaned_data == [{'name': 'Alice', 'age': 25}]\n", "golden_completion": "        self.data = [item for item in self.data if item['age'] is not None]\n        self.data = [dict(t) for t in {tuple(d.items()) for d in self.data}]\n", "LLM_justification": "This test case evaluates the LLM's ability to understand and implement a data cleaning function based on given comments. The code-to-comment scenario requires the model to generate a detailed implementation for removing null values and duplicates. This tests the model's comprehension of business logic, data transformation, and the ability to translate comments into executable code. The example also includes assertions to verify the correctness of the implementation.", "assertions": "assert cleaned_data == [{'name': 'Alice', 'age': 25}]", "gpt-4.1-nano": "        self.data = [dict(t) for t in {tuple(d.items()) for d in self.data if None not in d.values()}]"}
{"id": "36", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import datetime\n\nclass BusinessRuleValidator:\n    def __init__(self):\n        pass\n\n    def validate_transaction(self, transaction):\n", "suffix": "        # Check if the transaction amount is positive\n        if transaction['amount'] <= 0:\n            return False\n        # Validate the transaction type\n        if transaction['type'] not in ['credit', 'debit']:\n            return False\n        # Ensure the transaction date is not in the future\n        if transaction['date'] > datetime.datetime.now():\n            return False\n        return True\nclass TransactionManager:\n    def __init__(self):\n        self.validator = BusinessRuleValidator()\n\n    def process_transaction(self, transaction):\n        if self.validator.validate_transaction(transaction):\n            # Logic to process the transaction\n            return 'Transaction processed'\n        else:\n            return 'Transaction validation failed'\n\ndef test_transaction_manager():\n    manager = TransactionManager()\n    transaction = {'amount': 100, 'type': 'credit', 'date': datetime.datetime.now()}\n    assert manager.process_transaction(transaction) == 'Transaction processed'\n\n    invalid_transaction = {'amount': -50, 'type': 'debit', 'date': datetime.datetime.now()}\n    assert manager.process_transaction(invalid_transaction) == 'Transaction validation failed'\n\n    invalid_transaction = {'amount': 100, 'type': 'transfer', 'date': datetime.datetime.now()}\n    assert manager.process_transaction(invalid_transaction) == 'Transaction validation failed'\n\n    future_date = datetime.datetime.now() + datetime.timedelta(days=1)\n    invalid_transaction = {'amount': 100, 'type': 'credit', 'date': future_date}\n    assert manager.process_transaction(invalid_transaction) == 'Transaction validation failed'\n\ntest_transaction_manager()", "golden_completion": "        \"\"\"\n        Validate a business transaction based on various rules.\n\n        Parameters:\n        transaction (dict): The transaction to validate. Must contain 'amount', 'type', and 'date' keys.\n\n        Returns:\n        bool: True if the transaction is valid, False otherwise.\n\n        The validation rules are as follows:\n        - The transaction amount must be positive.\n        - The transaction type must be either 'credit' or 'debit'.\n        - The transaction date must not be in the future.\n        \"\"\"", "LLM_justification": "This test case focuses on translating complex business rule validation logic from code to comprehensive documentation. It tests the model's ability to generate detailed docstrings that accurately describe function behavior, parameters, return values, and validation rules. The assertions check the presence of key terms, coverage of important concepts, and ensure the documentation is complete and well-structured.", "assertions": "docstring = BusinessRuleValidator.validate_transaction.__doc__\nassert 'validate a business transaction' in docstring.lower()\nassert 'parameters:' in docstring.lower()\nassert 'transaction (dict)' in docstring.lower()\nassert 'returns:' in docstring.lower()\nassert 'bool: true if the transaction is valid' in docstring.lower()\nassert 'the transaction amount must be positive' in docstring.lower()\nassert 'the transaction type must be either' in docstring.lower()\nassert 'the transaction date must not be in the future' in docstring.lower()", "gpt-4.1-nano": "        # Check if the transaction amount is positive\n        if transaction['amount'] <= 0:\n            return False"}
{"id": "37", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def validate_user_data(data):\n    \"\"\"\n    Validate the user data against business rules.\n\n    Parameters:\n    data (dict): A dictionary containing user information.\n\n    Returns:\n    bool: True if data is valid, False otherwise.\n\n    Raises:\n    ValueError: If a required field is missing or invalid.\n    \"\"\"\n    required_fields = ['name', 'age', 'email']\n    \n    for field in required_fields:\n        if field not in data:\n            raise ValueError(f\"Missing required field: {field}\")\n\n    if not isinstance(data['age'], int) or data['age'] <= 0:\n        raise ValueError(\"Age must be a positive integer.\")\n\n    if '@' not in data['email']:\n        raise ValueError(\"Invalid email address.\")\n\n    return True\n\n# Test cases to verify the validate_user_data function\ntry:\n    assert validate_user_data({'name': 'Alice', 'age': 30, 'email': 'alice@example.com'}) is True\n    assert validate_user_data({'name': 'Bob', 'age': 0, 'email': 'bob@example.com'}) is False\nexcept ValueError as e:\n    pass\n\n# Now implement the following function based on the given documentation\n# Function: calculate_discount\n# Description: Calculate the discount for a user based on their age and membership status.\n# Parameters:\n# - age (int): Age of the user.\n# - is_member (bool): Whether the user is a member.\n# Returns:\n# - float: The discount percentage.\n# Raises:\n# - ValueError: If age is not a positive integer.\n# Implementation:", "suffix": "assert calculate_discount(25, True) == 0.1\nassert calculate_discount(25, False) == 0.05\nassert calculate_discount(70, True) == 0.2\nassert calculate_discount(70, False) == 0.15\n\ntry:\n    calculate_discount(-5, True)\nexcept ValueError as e:\n    assert str(e) == 'Age must be a positive integer.'\n\nprint(\"All assertions passed.\")", "golden_completion": "def calculate_discount(age, is_member):\n    if not isinstance(age, int) or age <= 0:\n        raise ValueError('Age must be a positive integer.')\n    \n    if age >= 65:\n        return 0.2 if is_member else 0.15\n    else:\n        return 0.1 if is_member else 0.05", "LLM_justification": "This example is a good test case because it involves translating detailed documentation into a complete function implementation. It tests the LLM's ability to understand and implement business logic based on age and membership status, including error handling. The provided assertions verify the correctness of the implementation, covering both normal and edge cases.", "assertions": "assert calculate_discount(25, True) == 0.1\nassert calculate_discount(25, False) == 0.05\nassert calculate_discount(70, True) == 0.2\nassert calculate_discount(70, False) == 0.15\n\ntry:\n    calculate_discount(-5, True)\nexcept ValueError as e:\n    assert str(e) == 'Age must be a positive integer.'\n\nprint(\"All assertions passed.\")", "gpt-4.1-nano": "if not isinstance(age, int) or age <= 0:\n    raise ValueError(\"Age must be a positive integer.\")\nif age >= 65:\n    discount = 0.2 if is_member else 0.15\nelif is_member:\n    discount = 0.1\nelse:\n    discount = 0.05\nreturn discount"}
{"id": "38", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class CacheManager:\n    \"\"\"\n    A class to manage a simple cache with invalidation and refresh strategies.\n    \"\"\"\n\n    def __init__(self, refresh_strategy):\n        \"\"\"\n        Initialize the CacheManager with a specific refresh strategy.\n\n        Parameters:\n        refresh_strategy (callable): A function to refresh cache entries.\n        \"\"\"\n        self.cache = {}\n        self.refresh_strategy = refresh_strategy\n\n    def get(self, key):\n        \"\"\"\n        Retrieve an item from the cache.\n\n        If the key does not exist or is expired, it will refresh the cache using the refresh strategy.\n\n        Parameters:\n        key (str): The key of the item to retrieve.\n\n        Returns:\n        value: The value associated with the key, or None if the key is not found.\n        \"\"\"\n        if key not in self.cache or self.is_expired(key):\n            self.cache[key] = self.refresh_strategy(key)\n        return self.cache.get(key)\n\n    def is_expired(self, key):\n        \"\"\"\n        Check if a cache entry is expired.\n\n        Parameters:\n        key (str): The key of the cache entry to check.\n\n        Returns:\n        bool: True if the cache entry is expired, False otherwise.\n        \"\"\"\n        # Placeholder implementation for expiration check\n        return False\n\n", "suffix": "    def remove(self, key):\n        \"\"\"\n        Remove an item from the cache.\n\n        Parameters:\n        key (str): The key of the item to remove.\n        \"\"\"\n        if key in self.cache:\n            del self.cache[key]\n\n# Example usage\ncache_manager = CacheManager(refresh_strategy=lambda k: f\"Value for {k}\")\ncache_manager.get(\"test\")\ncache_manager.remove(\"test\")\n", "golden_completion": "    def set(self, key, value):\n        \"\"\"\n        Add or update an item in the cache.\n\n        Parameters:\n        key (str): The key of the item to add or update.\n        value: The value to associate with the key.\n        \"\"\"\n        self.cache[key] = value\n", "LLM_justification": "This test case is a good example of bidirectional translation between code and documentation, focusing on realistic resource management strategies. It demonstrates a CacheManager class with proper documentation of methods including parameter descriptions and return values. The completion involves adding a new method with comprehensive documentation, ensuring that the LLM can accurately translate between code and natural language. The assertions verify the presence of key terms and the correctness of the method implementation.", "assertions": "assert 'Add or update an item in the cache' in CacheManager.set.__doc__\nassert 'Parameters:' in CacheManager.set.__doc__\nassert 'key (str): The key of the item to add or update.' in CacheManager.set.__doc__\nassert 'value: The value to associate with the key.' in CacheManager.set.__doc__\n\ncache_manager = CacheManager(refresh_strategy=lambda k: f\"Value for {k}\")\ncache_manager.set('test_key', 'test_value')\nassert cache_manager.get('test_key') == 'test_value'\n\ncache_manager.remove('test_key')\n", "gpt-4.1-nano": "def remove(self, key):"}
{"id": "39", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "def validate_user_data(user_data):\n    \"\"\"\n    Validate user data according to the following rules:\n    1. 'username' must be a non-empty string\n    2. 'age' must be an integer between 18 and 99\n    3. 'email' must contain '@' and '.'\n    \n    Parameters:\n    user_data (dict): A dictionary containing 'username', 'age', and 'email'.\n    \n    Returns:\n    bool: True if all validations pass, False otherwise.\n    \"\"\"\n", "suffix": "    return True\n\n# Example usage\nuser_data_valid = {'username': 'john_doe', 'age': 25, 'email': 'john@example.com'}\nassert validate_user_data(user_data_valid) == True\n\nuser_data_invalid = {'username': '', 'age': 17, 'email': 'johnexample.com'}\nassert validate_user_data(user_data_invalid) == False\n\nprint('All validations passed.')\n", "golden_completion": "    if not isinstance(user_data.get('username'), str) or not user_data['username']:\n        return False\n    if not isinstance(user_data.get('age'), int) or not (18 <= user_data['age'] <= 99):\n        return False\n    if '@' not in user_data.get('email', '') or '.' not in user_data['email']:\n        return False\n", "LLM_justification": "This is a good test case because it evaluates the model's ability to translate between a detailed natural language specification and its corresponding code implementation. The task requires understanding of complex validation rules and their correct implementation. The assertions verify that the function meets the specified requirements, including edge cases where validations should fail.", "assertions": "assert validate_user_data({'username': 'john_doe', 'age': 25, 'email': 'john@example.com'}) == True\nassert validate_user_data({'username': '', 'age': 17, 'email': 'johnexample.com'}) == False\nassert validate_user_data({'username': 'jane_doe', 'age': 30, 'email': 'jane@example.com'}) == True\nassert validate_user_data({'username': 'alice', 'age': 100, 'email': 'alice@example.com'}) == False\nassert validate_user_data({'username': 'bob', 'age': 20, 'email': 'bobexample.com'}) == False\n", "gpt-4.1-nano": "if isinstance(user_data.get('username'), str) and user_data.get('username') != '' and \\\n   isinstance(user_data.get('age'), int) and 18 <= user_data.get('age') <= 99 and \\\n   '@' in user_data.get('email', '') and '.' in user_data.get('email', ''):\n    return True\nreturn False"}
{"id": "40", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class UserProfile:\n    def __init__(self, user_id, name, email):\n        self.user_id = user_id\n        self.name = name\n        self.email = email\n\n    def validate_email(self):", "suffix": "        if \"@\" not in self.email or \".\" not in self.email.split('@')[-1]:\n            return False\n        return True\n\ndef test_user_profile():\n    # Test valid email\n    profile = UserProfile(1, \"John Doe\", \"john.doe@example.com\")\n    assert profile.validate_email() == True\n\n    # Test invalid email - no '@'\n    profile = UserProfile(2, \"Jane Doe\", \"jane.doeexample.com\")\n    assert profile.validate_email() == False\n\n    # Test invalid email - no domain\n    profile = UserProfile(3, \"Jim Doe\", \"jim.doe@com\")\n    assert profile.validate_email() == False\n\ntest_user_profile()\n", "golden_completion": "        \"\"\"\n        Validate the email address of the user.\n\n        This method checks if the email address contains an '@' symbol and a domain name.\n\n        Returns:\n            bool: True if the email is valid, False otherwise.\n\n        Examples:\n            >>> profile = UserProfile(1, 'John Doe', 'john.doe@example.com')\n            >>> profile.validate_email()\n            True\n\n            >>> profile = UserProfile(2, 'Jane Doe', 'jane.doeexample.com')\n            >>> profile.validate_email()\n            False\n        \"\"\"\n", "LLM_justification": "This test case effectively evaluates the LLM's ability to translate between code and natural language. The UserProfile class and the validate_email method provide a realistic business scenario involving email validation logic. The prompt includes the code implementation, and the golden_completion requires the LLM to generate comprehensive documentation, including a description, return value, and examples. The suffix contains test cases to validate the functionality, ensuring that the documentation accurately describes the behavior of the code. This scenario tests the LLM's ability to understand and explain complex logic, as well as generate accurate and useful documentation.", "assertions": "assert 'validate the email address' in UserProfile.validate_email.__doc__.lower()\nassert 'returns:' in UserProfile.validate_email.__doc__.lower()\nassert 'examples:' in UserProfile.validate_email.__doc__.lower()\nassert '>>> profile' in UserProfile.validate_email.__doc__.lower()", "gpt-4.1-nano": "        if \"@\" not in self.email or \".\" not in self.email.split('@')[-1]:"}
{"id": "41", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import requests\n\nclass ApiClient:\n    def __init__(self, base_url, api_key):\n        self.base_url = base_url\n        self.api_key = api_key\n\n    def get(self, endpoint):\n        \"\"\"Make a GET request to the specified endpoint\n        \n        Parameters:\n        endpoint (str): The API endpoint to call\n        \n        Returns:\n        dict: The JSON response from the API\n        \n        Raises:\n        ValueError: If the response status code is not 200\n        \"\"\"\n        headers = {}\n        if self.api_key:\n            headers[\"Authorization\"] = f\"Bearer {self.api_key}\"\n\n        response = requests.get(f\"{self.base_url}/{endpoint}\", headers=headers)\n        if response.status_code != 200:\n            raise ValueError(f\"Request failed with status code {response.status_code}\")\n        return response.json()\n\n    # The following method needs to be implemented based on the provided docstring\n    def post(self, endpoint, data):\n        \"\"\"Make a POST request to the specified endpoint with the given data\n        \n        Parameters:\n        endpoint (str): The API endpoint to call\n        data (dict): The data to send in the request body\n        \n        Returns:\n        dict: The JSON response from the API\n        \n        Raises:\n        ValueError: If the response status code is not 200\n        \"\"\"\n", "suffix": "\n\n# Example usage\ndef main():\n    client = ApiClient('https://jsonplaceholder.typicode.com', '')\n    response = client.get('posts/1')\n    assert 'title' in response\n    print(f\"GET successful, title: {response['title']}\")\n    try:\n        response = client.post('posts', {'title': 'Test Post', 'body': 'Test content', 'userId': 1})\n        assert 'id' in response\n        print(f\"POST successful, created post with id: {response['id']}\")\n    except ValueError as e:\n        print(e)\n\nif __name__ == '__main__':\n    main()\n", "golden_completion": "        headers = {\"Content-Type\": \"application/json\"}\n        if self.api_key:\n            headers[\"Authorization\"] = f\"Bearer {self.api_key}\"\n\n        response = requests.post(f\"{self.base_url}/{endpoint}\", json=data, headers=headers)\n        if response.status_code != 200 and response.status_code != 201:  # Most APIs return 201 for POST\n            raise ValueError(f\"Request failed with status code {response.status_code}\")\n        return response.json()\n", "LLM_justification": "This test case provides a realistic scenario where an API client class is partially implemented, and the LLM is required to complete the implementation of a POST request method based on a detailed docstring. It tests the LLM's ability to translate documentation into functional code while maintaining consistency and correctness. The assertions verify both the GET and POST methods, ensuring proper error handling and response parsing.", "assertions": "client = ApiClient('https://jsonplaceholder.typicode.com', '')\nresponse = client.get('posts/1')\nassert 'title' in response\ntry:\n    response = client.post('posts', {'title': 'Test Post', 'body': 'Test content', 'userId': 1})\n    assert 'id' in response\nexcept ValueError as e:\n    assert str(e).startswith('Request failed with status code')\n", "gpt-4.1-nano": "        headers = {}\n        if self.api_key:\n            headers[\"Authorization\"] = f\"Bearer {self.api_key}\"\n        response = requests.post(f\"{self.base_url}/{endpoint}\", json=data, headers=headers)\n        if response.status_code != 200:\n            raise ValueError(f\"Request failed with status code {response.status_code}\")\n        return response.json()"}
{"id": "42", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import pandas as pd\n\nclass DataTransformer:\n    def __init__(self, data):\n        self.data = data\n\n    def clean_data(self):\n        \"\"\"Cleans the input data by removing null values and duplicates.\"\"\"\n        self.data = self.data.dropna().drop_duplicates()\n\n    def transform_data(self):\n", "suffix": "        return transformed_data\n\ndata = pd.DataFrame({\n    'A': [1, 2, 2, None, 4],\n    'B': [5, None, 6, 7, 8]\n})\n\ntransformer = DataTransformer(data)\ntransformer.clean_data()\ntransformed_data = transformer.transform_data()\n\nassert transformed_data['A'].tolist() == [0.25, 0.5, 1.0]\nassert transformed_data['B'].tolist() == [5.0, 6.0, 8.0]\n", "golden_completion": "        \"\"\"\n        Transforms the cleaned data by normalizing column 'A' and filling null values in column 'B' with the mean of the column.\n\n        Returns:\n            pd.DataFrame: The transformed data.\n        \"\"\"\n        self.data['A'] = self.data['A'] / self.data['A'].max()\n        self.data['B'] = self.data['B'].fillna(self.data['B'].mean())\n        transformed_data = self.data\n", "LLM_justification": "This test case is a good example of bidirectional translation between code and documentation. It involves a realistic data transformation task where the prompt sets up a partially documented class with methods for cleaning and transforming data. The golden completion provides comprehensive documentation for the 'transform_data' method, detailing the normalization and null value handling steps. The suffix includes the usage of the class and assertions to verify the correctness of the transformations, ensuring that the documentation accurately describes the functionality. This scenario tests the LLM's ability to generate and understand complex documentation and code.", "assertions": "assert 'Transforms the cleaned data' in DataTransformer.transform_data.__doc__\nassert 'Returns:' in DataTransformer.transform_data.__doc__\nassert 'normalizing column' in DataTransformer.transform_data.__doc__\nassert 'filling null values' in DataTransformer.transform_data.__doc__", "gpt-4.1-nano": "        transformed_data = self.data.copy()\n        transformed_data['A'] = 1 / transformed_data['A']\n        transformed_data['B'] = transformed_data['B'].astype(float)\n        return transformed_data"}
{"id": "43", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class Connection:\n    \"\"\"\n    Represents a database connection.\n\n    This is a simplified placeholder for demonstration purposes.\n    \"\"\"\n    def __init__(self):\n        self.is_open = True\n\n    def close(self):\n        self.is_open = False\n\n    def execute(self, query):\n        # Placeholder for query execution\n        pass\n\nclass ConnectionPool:\n    \"\"\"\n    Manages a pool of reusable database connections.\n    \n    Attributes:\n        max_size (int): The maximum number of connections in the pool.\n        pool (list): The list containing the pooled connections.\n    \"\"\"\n\n    def __init__(self, max_size):\n        self.max_size = max_size\n        self.pool = []\n\n    def get_connection(self):\n        \"\"\"\n        Retrieves a connection from the pool if available; otherwise, creates a new one.\n        \n        Returns:\n            Connection: A database connection.\n        \"\"\"\n", "suffix": "    def release_connection(self, connection):\n        \"\"\"\n        Releases a connection back to the pool if the pool is not full.\n        \n        Parameters:\n            connection (Connection): The connection to be released.\n        \"\"\"\n        if len(self.pool) < self.max_size:\n            self.pool.append(connection)\n\n# Test the ConnectionPool implementation\nif __name__ == '__main__':\n    pool = ConnectionPool(max_size=2)\n    conn1 = pool.get_connection()\n    conn2 = pool.get_connection()\n    assert len(pool.pool) == 0\n    pool.release_connection(conn1)\n    assert len(pool.pool) == 1\n    pool.release_connection(conn2)\n    assert len(pool.pool) == 2\n    conn3 = pool.get_connection()\n    assert len(pool.pool) == 1\n    print('All tests passed.')\n", "golden_completion": "        if self.pool:\n            return self.pool.pop()\n        else:\n            return self.create_new_connection()\n\n    def create_new_connection(self):\n        \"\"\"\n        Creates a new database connection.\n        \n        Returns:\n            Connection: A new database connection.\n        \"\"\"\n        # Placeholder for actual connection creation logic\n        return Connection()\n", "LLM_justification": "This test case evaluates the LLM's ability to generate comprehensive documentation for an existing class and its methods, as well as to implement the logic for a class managing a pool of database connections. The scenario includes class attributes, method descriptions, return values, and parameter details, providing a realistic and complex example of bidirectional translation between code and natural language. The assertions verify the functional requirements and ensure correct behavior of the connection pool.", "assertions": "assert 'Attributes:' in ConnectionPool.__doc__\nassert 'max_size' in ConnectionPool.__doc__\nassert 'Returns:' in ConnectionPool.get_connection.__doc__\nassert 'Returns:' in ConnectionPool.create_new_connection.__doc__\n", "gpt-4.1-nano": "        if self.pool:\n            return self.pool.pop()\n        else:\n            return Connection()"}
{"id": "44", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "# This function performs a data transformation by cleaning the input dictionary and ensuring compliance with business rules\n# It removes entries with missing required fields and normalizes data formats.\ndef transform_data(input_dict):\n", "suffix": "    cleaned_data = {}\n    for key, value in input_dict.items():\n        if 'name' not in value or 'age' not in value:\n            continue\n\n        # Skip entries with empty names after stripping\n        name = value['name'].strip()\n        if not name:\n            continue\n\n        cleaned_data[key] = {\n            'name': name.title(),\n            'age': int(value['age'])\n        }\n    return cleaned_data\n\n# Example usage\ninput_data = {\n    'user1': {'name': ' alice ', 'age': ' 30 '},\n    'user2': {'name': 'Bob', 'age': '25'},\n    'user3': {'name': '', 'age': '40'},\n    'user4': {'age': '22'}\n}\nexpected_output = {\n    'user1': {'name': 'Alice', 'age': 30},\n    'user2': {'name': 'Bob', 'age': 25}\n}\n\noutput_data = transform_data(input_data)\nassert output_data == expected_output\n", "golden_completion": "    \"\"\"\n    Transforms the input dictionary by cleaning and normalizing the data.\n\n    Parameters:\n    input_dict (dict): A dictionary where keys are user identifiers and values are dictionaries containing user details.\n\n    Returns:\n    dict: A cleaned dictionary with entries having 'name' and 'age' fields. Names are stripped and title-cased, and ages are converted to integers.\n    \"\"\"\n", "LLM_justification": "This test case demonstrates the ability to translate between code and natural language documentation. The function performs a non-trivial data transformation which includes data cleaning and normalization, ensuring compliance with business rules. The golden completion provides comprehensive documentation for the function, including a description, parameter details, and return value explanation. This ensures that the model accurately captures the purpose and behavior of the code. The assertions verify that the function works as intended, handling various input cases and producing the correct output.", "assertions": "assert 'Transforms the input dictionary by cleaning and normalizing the data.' in transform_data.__doc__\nassert 'Parameters:' in transform_data.__doc__\nassert 'Returns:' in transform_data.__doc__\nassert 'input_dict (dict)' in transform_data.__doc__\nassert 'cleaned dictionary' in transform_data.__doc__", "gpt-4.1-nano": "    cleaned_data = {}"}
{"id": "45", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "# Function to check if a user is eligible for a loan based on business rules\n# The function should ensure that the user meets all the necessary criteria: age, income, and credit score.\n# If any of the criteria is not met, it should return False.\n# Otherwise, it should return True.\n# The function should handle possible errors, such as missing data or invalid input types.\ndef is_loan_eligible(user):", "suffix": "def get_loan_status(user):\n    \"\"\"\n    Function to get the loan status of a user\n    Parameters:\n    user (dict): A dictionary containing user details\n    Returns:\n    str: Loan status message\n    \"\"\"\n    try:\n        eligible = is_loan_eligible(user)\n        if eligible:\n            return \"Loan Approved\"\n        else:\n            return \"Loan Denied\"\n    except (KeyError, TypeError) as e:\n        return f\"Error: {str(e)}\"\n\n# Example usage\nuser = {'age': 30, 'income': 50000, 'credit_score': 700}\nstatus = get_loan_status(user)\nprint(status)  # Expected: Loan Approved\n\n# Clean up resources if any\n# (In this case, there are no resources to clean up)", "golden_completion": "    try:\n        age = user['age']\n        income = user['income']\n        credit_score = user['credit_score']\n        if age < 18 or income < 20000 or credit_score < 600:\n            return False\n        return True\n    except (KeyError, TypeError):\n        return False", "LLM_justification": "This test case is a good example as it tests the ability to translate detailed business rules into executable code and vice versa. The prompt provides detailed requirements for a function to check loan eligibility, including error handling for missing or invalid input. The golden completion accurately implements these requirements, demonstrating understanding of the logic and error handling. The suffix then shows a different function that uses the first function, ensuring no duplication. Assertions validate the implementation and documentation accuracy.", "assertions": "assert is_loan_eligible({'age': 30, 'income': 50000, 'credit_score': 700}) == True\nassert is_loan_eligible({'age': 17, 'income': 50000, 'credit_score': 700}) == False\nassert is_loan_eligible({'age': 30, 'income': 15000, 'credit_score': 700}) == False\nassert is_loan_eligible({'age': 30, 'income': 50000, 'credit_score': 500}) == False\nassert is_loan_eligible({'age': 30, 'income': 50000}) == False\nassert is_loan_eligible({'age': 'thirty', 'income': 50000, 'credit_score': 700}) == False\nassert 'age' in get_loan_status.__doc__.lower()\nassert 'parameters:' in get_loan_status.__doc__.lower()", "gpt-4.1-nano": "    if not isinstance(user, dict):\n        return False\n    age = user.get('age')\n    income = user.get('income')\n    credit_score = user.get('credit_score')\n    if not isinstance(age, (int, float)) or not isinstance(income, (int, float)) or not isinstance(credit_score, (int, float)):\n        return False\n    if age < 18 or income < 30000 or credit_score < 650:\n        return False\n    return True"}
{"id": "46", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class User:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    def is_adult(self) -> bool:\n        return self.age >= 18\n\n    def greet(self) -> str:\n        return f\"Hello, my name is {self.name}.\"\n\n# Task: Generate comprehensive documentation for the User class, including the __init__, is_adult, and greet methods.", "suffix": "\nuser = User(name='Alice', age=30)\nassert user.is_adult() == True\nassert user.greet() == 'Hello, my name is Alice.'\nuser = User(name='Bob', age=15)\nassert user.is_adult() == False\nassert user.greet() == 'Hello, my name is Bob.'", "golden_completion": "\nclass User:\n    \"\"\"\n    Represents a user with a name and age.\n\n    Attributes:\n    name (str): The name of the user.\n    age (int): The age of the user.\n    \"\"\"\n\n    def __init__(self, name: str, age: int):\n        \"\"\"\n        Initializes the User with a name and an age.\n\n        Parameters:\n        name (str): The name of the user.\n        age (int): The age of the user.\n        \"\"\"\n        self.name = name\n        self.age = age\n\n    def is_adult(self) -> bool:\n        \"\"\"\n        Checks if the user is an adult.\n\n        Returns:\n        bool: True if the user is 18 years old or older, False otherwise.\n        \"\"\"\n        return self.age >= 18\n\n    def greet(self) -> str:\n        \"\"\"\n        Returns a greeting message with the user's name.\n\n        Returns:\n        str: A greeting message.\n        \"\"\"\n        return f\"Hello, my name is {self.name}.\"\n", "LLM_justification": "This test case is a good example as it combines the need to generate comprehensive class and method docstrings with clear parameter and return type documentation. It assesses the LLM's ability to translate between code and natural language in both directions, ensuring the documentation covers all key aspects and aligns with the code implementation.", "assertions": "assert 'Represents a user with a name and age.' in User.__doc__\nassert 'name (str): The name of the user.' in User.__doc__\nassert 'age (int): The age of the user.' in User.__doc__\nassert 'Initializes the User with a name and an age.' in User.__init__.__doc__\nassert 'Checks if the user is an adult.' in User.is_adult.__doc__\nassert 'Returns a greeting message with the user\\'s name.' in User.greet.__doc__\nassert 'True if the user is 18 years old or older, False otherwise.' in User.is_adult.__doc__\n", "gpt-4.1-nano": "\"\"\"\nClass: User\n-----------\n\nRepresents a user with a name and age, providing methods to determine adulthood status and to generate a greeting.\n\nAttributes:\n- name (str): The name of the user.\n- age (int): The age of the user.\n\nMethods:\n- __init__(self, name: str, age: int):\n    Initializes a new User instance with the provided name and age.\n- is_adult(self) -> bool:\n    Returns True if the user's age is 18 or older, indicating adulthood; otherwise, False.\n- greet(self) -> str:\n    Returns a greeting string that includes the user's name.\n\"\"\""}
{"id": "47", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import requests\n\nclass APIClient:\n    def __init__(self, base_url, api_key=None):\n        self.base_url = base_url\n        self.api_key = api_key\n\n    def get_data(self, endpoint):\n        \"\"\"Fetch data from the given API endpoint.\"\"\"\n        url = f\"{self.base_url}/{endpoint}\"\n        headers = {}\n        if self.api_key:\n            headers['Authorization'] = f'Bearer {self.api_key}'\n\n        response = requests.get(url, headers=headers)\n        if response.status_code != 200:\n            raise ValueError(f\"Failed to fetch data: {response.status_code}\")\n        return response.json()\n\n    def post_data(self, endpoint, payload):\n", "suffix": "        url = f\"{self.base_url}/{endpoint}\"\n        headers = {'Content-Type': 'application/json'}\n        if self.api_key:\n            headers['Authorization'] = f'Bearer {self.api_key}'\n\n        response = requests.post(url, headers=headers, json=payload)\n        if response.status_code != 201:\n            raise ValueError(f\"Failed to post data: {response.status_code}\")\n        return response.json()\n\n# Usage example\nclient = APIClient('https://jsonplaceholder.typicode.com')\n", "golden_completion": "        \"\"\"\n        Send data to the given API endpoint.\n\n        Parameters:\n        endpoint (str): The API endpoint to send data to.\n        payload (dict): The data to send to the endpoint.\n\n        Returns:\n        dict: The response data from the API.\n\n        Raises:\n        ValueError: If the response status code is not 201.\n        \"\"\"\n", "LLM_justification": "This scenario tests the LLM's ability to generate comprehensive documentation for an existing method in a class. The task involves translating code into a detailed docstring for the `post_data` method, which includes parameter descriptions, return value documentation, and error handling details. This helps verify the model's understanding of the method's functionality and ensures that it can create meaningful and accurate documentation.", "assertions": "try:\n    response = client.get_data('posts/1')\n    print(\"GET successful:\")\n    print(f\"Title: {response['title']}\")\n    print(f\"Body: {response['body'][:50]}...\")\nexcept ValueError as e:\n    print(f\"GET Error: {e}\")\n\ntry:\n    post_data = {\n        \"title\": \"Test Post\",\n        \"body\": \"This is a test post created via the API\",\n        \"userId\": 1\n    }\n    response = client.post_data('posts', post_data)\n    print(\"POST successful:\")\n    print(f\"Created post with ID: {response['id']}\")\n    print(f\"Title: {response['title']}\")\nexcept ValueError as e:\n    print(f\"POST Error: {e}\")\n\ndocstring = APIClient.post_data.__doc__\nassert docstring is not None\nassert 'Send data to the given API endpoint' in docstring\nassert 'Parameters:' in docstring\nassert 'endpoint (str)' in docstring\nassert 'payload (dict)' in docstring\nassert 'Returns:' in docstring\nassert 'dict: The response data from the API.' in docstring\nassert 'Raises:' in docstring\nassert 'ValueError: If the response status code is not 201.' in docstring", "gpt-4.1-nano": "        url = f\"{self.base_url}/{endpoint}\"\n        response = requests.post(url, headers=headers, json=payload)"}
{"id": "48", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import requests\nfrom typing import List, Dict, Any\n\nclass PortfolioAnalyzer:\n", "suffix": "    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.base_url = 'https://jsonplaceholder.typicode.com'\n\n    def _get_stock_data(self, symbol: str) -> Dict[str, Any]:\n        post_id = 1\n        if symbol == 'AAPL':\n            post_id = 1\n        elif symbol == 'GOOGL':\n            post_id = 2\n        elif symbol == 'MSFT':\n            post_id = 3\n\n        url = f\"{self.base_url}/posts/{post_id}\"\n        response = requests.get(url)\n        if response.status_code == 200:\n            data = response.json()\n            # Simulate stock data format from the post data\n            return {\n                'symbol': symbol,\n                'price': 100 + post_id * 50,  # Fake price based on post ID\n                'shares': post_id * 10,  # Fake shares based on post ID\n                'name': data['title'][:20]  # Use post title as company name\n            }\n        else:\n            response.raise_for_status()\n\n    def analyze_portfolio(self, symbols: List[str]) -> Dict[str, float]:\n        portfolio_analysis = {}\n        for symbol in symbols:\n            data = self._get_stock_data(symbol)\n            portfolio_analysis[symbol] = data['price'] * data['shares']\n        return portfolio_analysis\n\n\ndef main():\n    api_key = ''\n    symbols = ['AAPL', 'GOOGL', 'MSFT']\n    analyzer = PortfolioAnalyzer(api_key)\n    result = analyzer.analyze_portfolio(symbols)\n    print('Portfolio Analysis:', result)\n    print('Detailed Stock Information:')\n    for symbol in symbols:\n        data = analyzer._get_stock_data(symbol)\n        print(f\"{symbol}: {data['name']} - Price: ${data['price']}, Shares: {data['shares']}\")\n\nif __name__ == '__main__':\n    main()\n", "golden_completion": "    \"\"\"\n    PortfolioAnalyzer Class\n    =======================\n    This class provides functionality to analyze a stock portfolio by fetching stock data from a financial data API.\n\n    Methods:\n    --------\n    __init__(api_key: str):\n        Initializes the PortfolioAnalyzer with the provided API key.\n\n    _get_stock_data(symbol: str) -> Dict[str, Any]:\n        Private method to fetch stock data for a given symbol from the API.\n        Parameters:\n            symbol (str): The stock symbol for which to fetch data.\n        Returns:\n            dict: A dictionary containing stock data.\n        Raises:\n            HTTPError: If the API request fails.\n\n    analyze_portfolio(symbols: List[str]) -> Dict[str, float]:\n        Analyzes the stock portfolio by calculating the total value of shares for each stock symbol.\n        Parameters:\n            symbols (List[str]): A list of stock symbols to analyze.\n        Returns:\n            dict: A dictionary with stock symbols as keys and their total value as values.\n    \"\"\"\n", "LLM_justification": "This test case provides a realistic scenario of a class designed to perform financial calculations by fetching stock data from an API. The golden completion includes comprehensive documentation for the class and its methods, including parameter and return value descriptions, usage details, and error handling information. This ensures the LLM is tested on its ability to generate accurate and detailed docstrings for complex business logic.", "assertions": "assert 'PortfolioAnalyzer Class' in PortfolioAnalyzer.__doc__\nassert 'analyze a stock portfolio' in PortfolioAnalyzer.__doc__\nassert 'fetching stock data from a financial data API' in PortfolioAnalyzer.__doc__\nassert 'Methods:' in PortfolioAnalyzer.__doc__\nassert 'Initializes the PortfolioAnalyzer' in PortfolioAnalyzer.__doc__\nassert 'Private method to fetch stock data' in PortfolioAnalyzer.__doc__\nassert 'Analyzes the stock portfolio' in PortfolioAnalyzer.__doc__\nassert 'Returns:' in PortfolioAnalyzer.__doc__", "gpt-4.1-nano": "def __init__(self, api_key: str):"}
{"id": "49", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "import requests\nfrom typing import Dict\n\nclass APIClient:\n", "suffix": "    def __init__(self, base_url: str, api_key: str = None):\n        self.base_url = base_url\n        self.api_key = api_key\n        self.session = requests.Session()\n        if api_key:\n            self.session.headers.update({'Authorization': f'Bearer {self.api_key}'})\n\n    def get(self, endpoint: str, params: Dict = None) -> Dict:\n        \"\"\"\n        Makes a GET request to the specified endpoint.\n        \"\"\"\n        response = self.session.get(f'{self.base_url}/{endpoint}', params=params)\n        response.raise_for_status()\n        return response.json()\n\n    def post(self, endpoint: str, data: Dict) -> Dict:\n        \"\"\"\n        Makes a POST request to the specified endpoint.\n        \"\"\"\n        response = self.session.post(f'{self.base_url}/{endpoint}', json=data)\n        response.raise_for_status()\n        return response.json()\n\n    def close(self):\n        \"\"\"\n        Closes the session.\n        \"\"\"\n        self.session.close()\n\n# Example usage of APIClient\nclient = APIClient('https://jsonplaceholder.typicode.com')\nresponse = client.get('posts/1')\nprint(f\"GET Response: {response}\")\nresponse['param1'] = 'value1'\npost_data = {\n    'title': 'foo',\n    'body': 'bar',\n    'userId': 1\n}\npost_response = client.post('posts', post_data)\nprint(f\"POST Response: {post_response}\")\n\nclient.close()\n\n# Check response structure\nassert 'param1' in response\nassert response['param1'] == 'value1'\n\n# Ensure session is closed\nassert client.session is not None\n", "golden_completion": "    \"\"\"\n    Class APIClient\n\n    Handles interactions with the API, including authentication and\n    making GET and POST requests.\n\n    Methods:\n    - __init__: Initializes the APIClient with the base URL and API key.\n    - get: Makes a GET request to the specified endpoint.\n    - post: Makes a POST request to the specified endpoint.\n    - close: Closes the session.\n\n    Attributes:\n    - base_url: The base URL for the API.\n    - api_key: The API key for authentication.\n    - session: The requests session used for making requests.\n\n    Usage Example:\n    client = APIClient('https://api.example.com', 'test_api_key')\n    response = client.get('test-endpoint', {'param1': 'value1'})\n    client.close()\n\n    \"\"\"\n", "LLM_justification": "This test case presents a realistic scenario of an API client class that handles authentication and HTTP requests. The class includes methods for GET and POST requests, along with session management. The golden completion requires generating comprehensive documentation that covers class attributes, methods, and usage examples. This ensures the LLM can effectively translate between code and natural language, demonstrating understanding of both implementation and documentation conventions. Assertions verify the response structure and resource cleanup.", "assertions": "docstring = APIClient.__doc__\nassert docstring is not None\nassert 'Handles interactions with the API' in docstring\nassert 'Methods:' in docstring\nassert 'Attributes:' in docstring\nassert 'Usage Example:' in docstring\n", "gpt-4.1-nano": "def __init__(self, base_url: str, api_key: str = None):"}
{"id": "50", "testsource": "devbench-code2NL-NL2code", "language": "python", "prefix": "class Portfolio:\n", "suffix": "    def __init__(self, assets):\n        \"\"\"\n        Initialize the portfolio with a list of assets.\n\n        Parameters:\n        assets (list): A list of asset dictionaries containing 'name' and 'value'.\n        \"\"\"\n        self.assets = assets\n\n    def total_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n\n        Returns:\n        float: The total value of all assets in the portfolio.\n        \"\"\"\n        return sum(asset['value'] for asset in self.assets)\n\n    def risk_assessment(self):\n        \"\"\"\n        Assess the risk of the portfolio based on asset values.\n\n        Returns:\n        str: A string describing the risk level ('Low', 'Medium', 'High').\n        \"\"\"\n        total = self.total_value()\n        if total < 10000:\n            return 'Low'\n        elif total < 50000:\n            return 'Medium'\n        else:\n            return 'High'\n\n# Example usage\nportfolio = Portfolio([\n    {'name': 'Stock A', 'value': 5000},\n    {'name': 'Stock B', 'value': 15000},\n    {'name': 'Stock C', 'value': 25000}\n])\n\nrisk_level = portfolio.risk_assessment()\nprint(f\"Portfolio Risk Level: {risk_level}\")\n\nassert portfolio.total_value() == 45000, \"Total value calculation is incorrect\"\nassert portfolio.risk_assessment() == 'Medium', \"Risk assessment is incorrect\"\n", "golden_completion": "    \"\"\"\n    This module defines a Portfolio class for managing a collection of assets and\n    assessing their total value and risk level.\n\n    Classes:\n        Portfolio: A class representing a portfolio of assets with methods to\n            calculate total value and assess risk.\n\n    Usage example:\n        portfolio = Portfolio([\n            {'name': 'Stock A', 'value': 5000},\n            {'name': 'Stock B', 'value': 15000},\n            {'name': 'Stock C', 'value': 25000}\n        ])\n        risk_level = portfolio.risk_assessment()\n        print(f\"Portfolio Risk Level: {risk_level}\")\n    \"\"\"\n", "LLM_justification": "This test case is an excellent example for evaluating an LLM's ability to generate comprehensive documentation for an existing Python class. The code defines a Portfolio class with methods for calculating total value and assessing risk, providing a realistic financial calculation scenario. The golden completion includes detailed module-level docstrings, class descriptions, and usage examples, making it a good test for code-to-comment translation. The suffix includes assertions that verify the functional correctness of the code, ensuring that the documentation accurately describes the code's behavior.", "assertions": "docstring = Portfolio.__doc__\nassert 'managing a collection of assets' in docstring.lower(), \"Docstring does not describe the Portfolio class accurately\"\nassert 'Portfolio: A class representing a portfolio of assets' in docstring, \"Docstring is missing class description\"\nassert 'usage example' in docstring.lower(), \"Docstring is missing usage example\"\nassert 'calculate total value and assess risk' in docstring.lower(), \"Docstring does not cover important concepts\"", "gpt-4.1-nano": "def __init__(self, assets):"}
