{"id": "1", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        Debug.Assert(numbers.Count == 5, \"List should contain 5 elements\");\n        Debug.Assert(numbers[2] == 3, \"Third element should be 3\");\n        numbers.RemoveAt(2);\n        Debug.Assert(numbers.Count == 4, \"List should contain 4 elements after removal\");\n        Debug.Assert(!numbers.Contains(3), \"List should not contain 3 after removal\");\n    }\n}\n", "golden_completion": "        // List is already initialized with the correct elements\n", "LLM_justification": "This scenario tests the LLM's ability to recognize when a List is already in the correct state and no further operations are needed. The assertions verify the list's current state and test removal operations.", "assertions": "", "DeepSeek-V3.1_completion_0": "        numbers.Add(6);\n        numbers.Remove(1);", "DeepSeek-V3.1_completion_1": "        numbers.Add(6);\n        numbers.Remove(1);", "DeepSeek-V3.1_completion_2": "        numbers.Add(6);\n        numbers.Remove(1);", "DeepSeek-V3.1_completion_3": "        numbers.Add(6);\n        numbers.Remove(1);", "DeepSeek-V3.1_completion_4": "        numbers.Add(6);\n        numbers.Remove(1);", "DeepSeek-V3.1_completions": ["        numbers.Add(6);\n        numbers.Remove(1);", "        numbers.Add(6);\n        numbers.Remove(1);", "        numbers.Add(6);\n        numbers.Remove(1);", "        numbers.Add(6);\n        numbers.Remove(1);", "        numbers.Add(6);\n        numbers.Remove(1);"]}
{"id": "2", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        numbers.Remove(3);\n        Debug.Assert(numbers.Count == 4, \"Count should be 4 after removal\");\n        Debug.Assert(!numbers.Contains(3), \"List should not contain 3 after removal\");\n    }\n}\n", "golden_completion": "        Debug.Assert(numbers.Count == 5, \"Count should be 5 initially\");\n        Debug.Assert(numbers.Contains(3), \"List should contain 3 initially\");\n", "LLM_justification": "This test case examines the model's ability to recognize and complete a pattern that verifies the initial state of a List before performing removal operations. The assertions check the list's state before the removal operation in the suffix.", "assertions": "", "DeepSeek-V3.1_completion_0": "        numbers.Remove(3);", "DeepSeek-V3.1_completion_1": "        numbers.Remove(3);", "DeepSeek-V3.1_completion_2": "        numbers.Remove(3);", "DeepSeek-V3.1_completion_3": "        numbers.Remove(3);", "DeepSeek-V3.1_completion_4": "        numbers.Remove(3);", "DeepSeek-V3.1_completions": ["        numbers.Remove(3);", "        numbers.Remove(3);", "        numbers.Remove(3);", "        numbers.Remove(3);", "        numbers.Remove(3);"]}
{"id": "3", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        int sum = 0;\n        foreach (var number in numbers)\n        {\n            sum += number;\n        }\n        Debug.Assert(sum == 12, \"Sum should be 12\");\n    }\n}\n", "golden_completion": "        numbers.Remove(3);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving List data structure manipulation. The removal of an element from the list is a common operation, and the subsequent calculation of the sum is used to verify correctness. The assertions ensure that the model understands the impact of the removal operation on the list contents.", "assertions": "", "DeepSeek-V3.1_completion_0": "int sum = 0;", "DeepSeek-V3.1_completion_1": "        numbers = new List<int> { 3, 4, 5 };", "DeepSeek-V3.1_completion_2": "        int sum = 0;", "DeepSeek-V3.1_completion_3": "int sum = 0;", "DeepSeek-V3.1_completion_4": "numbers = new List<int> { 1, 2, 3, 4, 5, -5 };", "DeepSeek-V3.1_completions": ["int sum = 0;", "        numbers = new List<int> { 3, 4, 5 };", "        int sum = 0;", "int sum = 0;", "numbers = new List<int> { 1, 2, 3, 4, 5, -5 };"]}
{"id": "4", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        List<int> squaredNumbers = new List<int>();\n", "suffix": "        Debug.Assert(squaredNumbers.Count == 5, \"The squaredNumbers list should have 5 elements.\");\n        Debug.Assert(squaredNumbers[0] == 1, \"The first element should be 1.\");\n        Debug.Assert(squaredNumbers[1] == 4, \"The second element should be 4.\");\n        Debug.Assert(squaredNumbers[2] == 9, \"The third element should be 9.\");\n        Debug.Assert(squaredNumbers[3] == 16, \"The fourth element should be 16.\");\n        Debug.Assert(squaredNumbers[4] == 25, \"The fifth element should be 25.\");\n    }\n}\n", "golden_completion": "        foreach (int number in numbers)\n        {\n            squaredNumbers.Add(number * number);\n        }\n", "LLM_justification": "This test case is a good example of low-context pattern recognition because it requires the model to understand the common pattern of iterating over a list and performing a transformation on each element (in this case, squaring the numbers). The prefix sets up the context with the list of numbers and an empty list for the squared numbers, while the golden completion provides the correct loop to fill the squaredNumbers list. The suffix contains assertions to verify the correctness of the transformation, ensuring that the model's completion is accurate.", "assertions": "", "DeepSeek-V3.1_completion_0": "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completion_1": "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completion_2": "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completion_3": "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completion_4": "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completions": ["        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }"]}
{"id": "5", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var numbers = new int[] {1, 2, 3, 4, 5};\n        int sum = 0;\n", "suffix": "        Debug.Assert(sum == 15, \"Sum should be 15\");\n        Console.WriteLine(\"Sum is correct: \" + sum);\n    }\n}\n", "golden_completion": "        foreach (var number in numbers)\n        {\n            sum += number;\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a common pattern of iterating over an array to calculate the sum of its elements. The pattern is clear and identifiable with minimal context, and the assertions ensure the correct functionality of the loop.", "assertions": "", "DeepSeek-V3.1_completion_0": "        foreach (var num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completion_1": "        foreach (var num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completion_2": "        foreach (var num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completion_3": "        foreach (var num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completion_4": "        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completions": ["        foreach (var num in numbers)\n        {\n            sum += num;\n        }", "        foreach (var num in numbers)\n        {\n            sum += num;\n        }", "        foreach (var num in numbers)\n        {\n            sum += num;\n        }", "        foreach (var num in numbers)\n        {\n            sum += num;\n        }", "        foreach (int num in numbers)\n        {\n            sum += num;\n        }"]}
{"id": "6", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4 };\n", "suffix": "        Debug.Assert(numbers.Count == 5, \"Count should be 5\");\n        Debug.Assert(numbers[4] == 5, \"Last element should be 5\");\n    }\n}\n", "golden_completion": "        numbers.Add(5);\n", "LLM_justification": "This example tests the model's ability to recognize and continue a list manipulation pattern with minimal context. The prefix sets up a list and the suffix contains assertions that verify the list's state after the completion, ensuring the model correctly adds an element to the list.", "assertions": "", "DeepSeek-V3.1_completion_0": "        numbers.Add(5);", "DeepSeek-V3.1_completion_1": "        numbers.Add(5);", "DeepSeek-V3.1_completion_2": "        numbers.Add(5);", "DeepSeek-V3.1_completion_3": "        numbers.Add(5);", "DeepSeek-V3.1_completion_4": "        numbers.Add(5);", "DeepSeek-V3.1_completions": ["        numbers.Add(5);", "        numbers.Add(5);", "        numbers.Add(5);", "        numbers.Add(5);", "        numbers.Add(5);"]}
{"id": "7", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        try\n        {\n", "suffix": "        }\n        catch (ArgumentNullException ex)\n        {\n            Debug.Assert(ex.ParamName == \"input\", \"Expected ArgumentNullException for input parameter\");\n        }\n    }\n}\n", "golden_completion": "            string input = null;\n            if (input == null)\n            {\n                throw new ArgumentNullException(nameof(input));\n            }\n", "LLM_justification": "This test case checks the LLM's ability to recognize and complete an error handling pattern involving argument validation and exception throwing. The prefix sets up a try block, and the golden completion involves throwing an ArgumentNullException when a null input is detected. The suffix handles the exception and includes an assertion to verify the correct exception was thrown, ensuring the pattern is recognized and properly implemented.", "assertions": "", "DeepSeek-V3.1_completion_0": "            string input = null;\n            if (input == null)\n            {\n                throw new ArgumentNullException(\"input\");\n            }", "DeepSeek-V3.1_completion_1": "            string input = null;\n            SomeMethod(input);", "DeepSeek-V3.1_completion_2": "            string input = null;\n            if (input == null)\n            {\n                throw new ArgumentNullException(\"input\");\n            }", "DeepSeek-V3.1_completion_3": "            string input = null;\n            if (input == null)\n            {\n                throw new ArgumentNullException(\"input\");\n            }", "DeepSeek-V3.1_completion_4": "            string input = null;\n            SomeMethod(input);", "DeepSeek-V3.1_completions": ["            string input = null;\n            if (input == null)\n            {\n                throw new ArgumentNullException(\"input\");\n            }", "            string input = null;\n            SomeMethod(input);", "            string input = null;\n            if (input == null)\n            {\n                throw new ArgumentNullException(\"input\");\n            }", "            string input = null;\n            if (input == null)\n            {\n                throw new ArgumentNullException(\"input\");\n            }", "            string input = null;\n            SomeMethod(input);"]}
{"id": "8", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n        int result = 0;\n        foreach (int number in numbers)\n        {\n", "suffix": "        }\n        Debug.Assert(result == 15, \"Sum should be 15\");\n        Console.WriteLine(\"Sum: \" + result);\n    }\n}\n", "golden_completion": "            result += number;\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete a simple iteration pattern over an array, summing its elements. The context is minimal, but the pattern is clear and common, making it an effective benchmark for low-context pattern recognition.", "assertions": "", "DeepSeek-V3.1_completion_0": "            result += number;", "DeepSeek-V3.1_completion_1": "            result += number;", "DeepSeek-V3.1_completion_2": "            result += number;", "DeepSeek-V3.1_completion_3": "            result += number;", "DeepSeek-V3.1_completion_4": "            result += number;", "DeepSeek-V3.1_completions": ["            result += number;", "            result += number;", "            result += number;", "            result += number;", "            result += number;"]}
{"id": "9", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        List<int> evenNumbers = new List<int>();\n", "suffix": "        Debug.Assert(evenNumbers.Count == 2, \"There should be 2 even numbers.\");\n        Debug.Assert(evenNumbers.Contains(2), \"List should contain 2.\");\n        Debug.Assert(evenNumbers.Contains(4), \"List should contain 4.\");\n    }\n}\n", "golden_completion": "        foreach (var number in numbers)\n        {\n            if (number % 2 == 0)\n            {\n                evenNumbers.Add(number);\n            }\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete an iterator and collection pattern. The context is minimal but provides enough information for a common pattern of filtering a collection based on a condition. The assertions verify that the correct even numbers are added to the new list.", "assertions": "", "DeepSeek-V3.1_completion_0": "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "DeepSeek-V3.1_completion_1": "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "DeepSeek-V3.1_completion_2": "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "DeepSeek-V3.1_completion_3": "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "DeepSeek-V3.1_completion_4": "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "DeepSeek-V3.1_completions": ["        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }", "        foreach (int num in numbers)\n        {\n            if (num % 2 == 0)\n            {\n                evenNumbers.Add(num);\n            }\n        }"]}
{"id": "10", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Calculator\n{\n    public int Add(int a, int b)\n    {\n", "suffix": "    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        Calculator calc = new Calculator();\n        int result = calc.Add(3, 4);\n        Debug.Assert(result == 7, \"Main: Addition result should be 7\");\n    }\n}\n", "golden_completion": "        int result = a + b;\n        Debug.Assert(result == 7, \"Addition result should be 7\");\n        return result;\n", "LLM_justification": "This scenario tests the model's ability to recognize and complete a simple arithmetic operation within a method, including proper variable declaration, assertion testing, and return statement.", "assertions": "", "DeepSeek-V3.1_completion_0": "        return a + b;", "DeepSeek-V3.1_completion_1": "        return a + b;", "DeepSeek-V3.1_completion_2": "        return a + b;", "DeepSeek-V3.1_completion_3": "        return a + b;", "DeepSeek-V3.1_completion_4": "        return a + b;", "DeepSeek-V3.1_completions": ["        return a + b;", "        return a + b;", "        return a + b;", "        return a + b;", "        return a + b;"]}
{"id": "11", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        Task<int> task = Task.Run(() =>\n        {\n            return 42;\n        });\n", "suffix": "        Debug.Assert(result == 42, \"Task result should be 42\");\n        Console.WriteLine(\"Task completed with result: \" + result);\n    }\n}", "golden_completion": "        int result = await task;\n", "LLM_justification": "This example tests the model's ability to recognize and continue an async/await pattern with minimal context. The prefix establishes the setup for an asynchronous task, and the suffix includes assertions to verify the result of the task. The golden completion demonstrates the correct usage of the await keyword to obtain the result of the task. This pattern is widely used in C# for asynchronous programming.", "assertions": "", "DeepSeek-V3.1_completion_0": "        int result = await task;", "DeepSeek-V3.1_completion_1": "        int result = await task;", "DeepSeek-V3.1_completion_2": "int result = await task;", "DeepSeek-V3.1_completion_3": "        int result = await task;", "DeepSeek-V3.1_completion_4": "        int result = await task;", "DeepSeek-V3.1_completions": ["        int result = await task;", "        int result = await task;", "int result = await task;", "        int result = await task;", "        int result = await task;"]}
{"id": "12", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n", "suffix": "        Debug.Assert(sum == 15, \"Sum should be 15\");\n    }\n}\n", "golden_completion": "        int sum = 0;\n        foreach (var num in numbers)\n        {\n            sum += num;\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize a common iterator and collection pattern. The prefix establishes an array and the suffix asserts the sum of the array elements, making it clear that a loop is needed to sum the elements. The completion must fill in the iteration logic correctly. This scenario is simple yet effective in testing the model's ability to continue a basic but universally recognized pattern in C#.", "assertions": "", "DeepSeek-V3.1_completion_0": "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completion_1": "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completion_2": "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completion_3": "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completion_4": "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "DeepSeek-V3.1_completions": ["        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }", "        int sum = 0;\n        foreach (int num in numbers)\n        {\n            sum += num;\n        }"]}
{"id": "13", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        try\n        {\n", "suffix": "        }\n        catch (InvalidOperationException ex)\n        {\n            Debug.Assert(ex.Message == \"Operation is not valid.\", \"Unexpected exception message\");\n        }\n        catch (Exception ex)\n        {\n            Debug.Assert(false, \"Unexpected exception type: \" + ex.GetType().Name);\n        }\n    }\n}\n", "golden_completion": "            throw new InvalidOperationException(\"Operation is not valid.\");\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and complete a common error handling pattern in C#. The try block is set up to throw a specific exception, and the catch block is designed to validate that the correct exception type and message are handled. This scenario tests the model's understanding of exception handling and assertion usage within minimal context.", "assertions": "", "DeepSeek-V3.1_completion_0": "            throw new InvalidOperationException(\"Operation is not valid.\");", "DeepSeek-V3.1_completion_1": "            throw new InvalidOperationException(\"Operation is not valid.\");", "DeepSeek-V3.1_completion_2": "            throw new InvalidOperationException(\"Operation is not valid.\");", "DeepSeek-V3.1_completion_3": "            throw new InvalidOperationException(\"Operation is not valid.\");", "DeepSeek-V3.1_completion_4": "            throw new InvalidOperationException(\"Operation is not valid.\");", "DeepSeek-V3.1_completions": ["            throw new InvalidOperationException(\"Operation is not valid.\");", "            throw new InvalidOperationException(\"Operation is not valid.\");", "            throw new InvalidOperationException(\"Operation is not valid.\");", "            throw new InvalidOperationException(\"Operation is not valid.\");", "            throw new InvalidOperationException(\"Operation is not valid.\");"]}
{"id": "14", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Func<int, int, int> add = ", "suffix": ";\n        int result = add(2, 3);\n        Debug.Assert(result == 5, \"The add function should return 5 when given 2 and 3.\");\n    }\n}\n", "golden_completion": "(x, y) => x + y", "LLM_justification": "This example tests the LLM's ability to recognize and complete a simple delegate pattern with a lambda expression. The prefix sets up a Func delegate, and the golden completion requires the model to complete the lambda function correctly. The suffix includes an assertion to verify the correctness of the lambda function, ensuring that it adheres to the expected pattern and functionality.", "assertions": "", "DeepSeek-V3.1_completion_0": "(a, b) => a + b;", "DeepSeek-V3.1_completion_1": "(a, b) => a + b;", "DeepSeek-V3.1_completion_2": "(x, y) => x + y;", "DeepSeek-V3.1_completion_3": "(a, b) => a + b;", "DeepSeek-V3.1_completion_4": "(x, y) => x + y;", "DeepSeek-V3.1_completions": ["(a, b) => a + b;", "(a, b) => a + b;", "(x, y) => x + y;", "(a, b) => a + b;", "(x, y) => x + y;"]}
{"id": "15", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n        int sum = 0;\n        foreach (int number in numbers)\n        {\n", "suffix": "        }\n        Debug.Assert(sum == 15, \"Sum should be 15\");\n    }\n}\n", "golden_completion": "            sum += number;\n", "LLM_justification": "This test case checks the LLM's ability to recognize and complete a common pattern of summing elements in a collection using a foreach loop. The context is minimal but should be sufficient for the model to infer the pattern. The prefix sets up the loop and the suffix includes an assertion to verify the correct sum, ensuring the model completes the pattern correctly without duplicating any code in the suffix.", "assertions": "", "DeepSeek-V3.1_completion_0": "            sum += number;", "DeepSeek-V3.1_completion_1": "            sum += number;", "DeepSeek-V3.1_completion_2": "            sum += number;", "DeepSeek-V3.1_completion_3": "            sum += number;", "DeepSeek-V3.1_completion_4": "            sum += number;", "DeepSeek-V3.1_completions": ["            sum += number;", "            sum += number;", "            sum += number;", "            sum += number;", "            sum += number;"]}
{"id": "16", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.IO;\n\npublic class ResourceExample\n{\n    public void WriteToFile(string path, string content)\n    {", "suffix": "        Debug.Assert(File.Exists(path), \"File should exist after writing.\");\n        string writtenContent = File.ReadAllText(path);\n        Debug.Assert(writtenContent == \"Hello, World!\", \"Content should match the written text.\");\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        string path = \"testfile.txt\";\n        var example = new ResourceExample();\n        example.WriteToFile(path, \"Hello, World!\");\n        File.Delete(path);\n    }\n}", "golden_completion": "        using (StreamWriter writer = new StreamWriter(path))\n        {\n            writer.Write(content);\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and continue a common resource management pattern using 'using' statements for automatic disposal of resources. The prefix sets up the method signature and the context of writing to a file, while the suffix includes assertions to verify the correct behavior. The golden completion involves the proper use of the 'using' statement to manage the StreamWriter resource.", "assertions": "", "DeepSeek-V3.1_completion_0": "        File.WriteAllText(path, content);", "DeepSeek-V3.1_completion_1": "        File.WriteAllText(path, content);", "DeepSeek-V3.1_completion_2": "try\n        {\n            File.WriteAllText(path, content);\n        }\n        catch (Exception ex)\n        {\n            Debug.Fail($\"Failed to write to file: {ex.Message}\");\n        }", "DeepSeek-V3.1_completion_3": "        File.WriteAllText(path, content);", "DeepSeek-V3.1_completion_4": "        File.WriteAllText(path, content);", "DeepSeek-V3.1_completions": ["        File.WriteAllText(path, content);", "        File.WriteAllText(path, content);", "try\n        {\n            File.WriteAllText(path, content);\n        }\n        catch (Exception ex)\n        {\n            Debug.Fail($\"Failed to write to file: {ex.Message}\");\n        }", "        File.WriteAllText(path, content);", "        File.WriteAllText(path, content);"]}
{"id": "17", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int numerator = 10;\n        int denominator = 2;\n", "suffix": "        Debug.Assert(result == 5, \"Division result should be 5\");\n        denominator = 0;\n        try\n        {\n            result = Divide(numerator, denominator);\n        }\n        catch (DivideByZeroException)\n        {\n            Debug.Assert(true, \"Caught expected DivideByZeroException\");\n        }\n    }\n\n    public static int Divide(int a, int b)\n    {\n        return a / b;\n    }\n}\n", "golden_completion": "        int result = Divide(numerator, denominator);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a common error handling pattern. The prefix sets up a division operation, and the golden completion involves performing this division. The suffix then includes assertions to verify correct behavior both for a valid division and handling a division by zero exception. This is a minimal context example that requires understanding of exception handling in C#.", "assertions": "", "DeepSeek-V3.1_completion_0": "        int result = Divide(numerator, denominator);", "DeepSeek-V3.1_completion_1": "        int result = Divide(numerator, denominator);", "DeepSeek-V3.1_completion_2": "        int result = Divide(numerator, denominator);", "DeepSeek-V3.1_completion_3": "        int result = Divide(numerator, denominator);", "DeepSeek-V3.1_completion_4": "        int result = Divide(numerator, denominator);", "DeepSeek-V3.1_completions": ["        int result = Divide(numerator, denominator);", "        int result = Divide(numerator, denominator);", "        int result = Divide(numerator, denominator);", "        int result = Divide(numerator, denominator);", "        int result = Divide(numerator, denominator);"]}
{"id": "18", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        Task<int> task = Task.Run(() => 42);\n", "suffix": "        Debug.Assert(result == 42, \"Task result should be 42\");\n        Console.WriteLine(\"Task completed successfully\");\n    }\n}\n", "golden_completion": "        int result = await task;\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete an async/await pattern with minimal context. The context provided includes an async method that initiates a task, with the expected completion involving awaiting the task's result. The assertion checks if the task's result is as expected, ensuring the correct usage of async/await.", "assertions": "", "DeepSeek-V3.1_completion_0": "        int result = await task;", "DeepSeek-V3.1_completion_1": "        int result = await task;", "DeepSeek-V3.1_completion_2": "        int result = await task;", "DeepSeek-V3.1_completion_3": "        int result = await task;", "DeepSeek-V3.1_completion_4": "        int result = await task;", "DeepSeek-V3.1_completions": ["        int result = await task;", "        int result = await task;", "        int result = await task;", "        int result = await task;", "        int result = await task;"]}
{"id": "19", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.IO;\n\npublic class ResourceManagementExample\n{\n    public void ManageResource()\n    {\n", "suffix": "    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        ResourceManagementExample example = new ResourceManagementExample();\n        example.ManageResource();\n    }\n}\n", "golden_completion": "        // Create a temporary file for demonstration\n        string fileName = \"example.txt\";\n        File.WriteAllText(fileName, \"Sample content for testing\");\n        \n        using (StreamReader reader = new StreamReader(fileName))\n        {\n            string content = reader.ReadToEnd();\n            Debug.Assert(!string.IsNullOrEmpty(content), \"File content should not be empty\");\n        }\n        \n        // Clean up\n        File.Delete(fileName);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a resource management pattern using the 'using' statement in C#. The pattern includes file creation, proper resource disposal with the using statement, and cleanup. This demonstrates a complete file management workflow.", "assertions": "", "DeepSeek-V3.1_completion_0": "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, World!\");\n        }\n        finally\n        {\n            writer?.Dispose();\n        }", "DeepSeek-V3.1_completion_1": "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, Resource Management!\");\n        }\n        finally\n        {\n            if (writer != null)\n            {\n                writer.Dispose();\n            }\n        }", "DeepSeek-V3.1_completion_2": "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, World!\");\n        }\n        finally\n        {\n            if (writer != null)\n            {\n                writer.Dispose();\n            }\n        }", "DeepSeek-V3.1_completion_3": "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, Resource Management!\");\n        }\n        finally\n        {\n            if (writer != null)\n            {\n                writer.Dispose();\n            }\n        }", "DeepSeek-V3.1_completion_4": "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, Resource Management!\");\n        }\n        finally\n        {\n            if (writer != null)\n            {\n                writer.Dispose();\n            }\n        }", "DeepSeek-V3.1_completions": ["        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, World!\");\n        }\n        finally\n        {\n            writer?.Dispose();\n        }", "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, Resource Management!\");\n        }\n        finally\n        {\n            if (writer != null)\n            {\n                writer.Dispose();\n            }\n        }", "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, World!\");\n        }\n        finally\n        {\n            if (writer != null)\n            {\n                writer.Dispose();\n            }\n        }", "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, Resource Management!\");\n        }\n        finally\n        {\n            if (writer != null)\n            {\n                writer.Dispose();\n            }\n        }", "        string filePath = \"example.txt\";\n        StreamWriter writer = null;\n        try\n        {\n            writer = new StreamWriter(filePath);\n            writer.WriteLine(\"Hello, Resource Management!\");\n        }\n        finally\n        {\n            if (writer != null)\n            {\n                writer.Dispose();\n            }\n        }"]}
{"id": "20", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.IO;\n\nclass ResourceManagementExample\n{\n    public void ProcessFile(string filePath)\n    {\n", "suffix": "        Debug.Assert(result == \"File processed\", \"The file was not processed correctly\");\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        ResourceManagementExample example = new ResourceManagementExample();\n        example.ProcessFile(\"test.txt\");\n    }\n}\n", "golden_completion": "        string result;\n        using (StreamReader reader = new StreamReader(filePath))\n        {\n            result = \"File processed\";\n        }\n", "LLM_justification": "This scenario tests the model's ability to recognize and complete a common resource management pattern using the 'using' statement for handling IDisposable resources. The prefix sets up the context by defining a method that processes a file, while the suffix includes an assertion to verify the correct functionality and the necessary cleanup. The golden completion demonstrates the proper use of the 'using' statement to ensure the StreamReader is disposed of correctly. This pattern is widely used and should be recognizable with minimal context.", "assertions": "", "DeepSeek-V3.1_completion_0": "        string content = File.ReadAllText(filePath);\n        string result = \"File processed\";", "DeepSeek-V3.1_completion_1": "        string content = File.ReadAllText(filePath);\n        string result = content.Length > 0 ? \"File processed\" : \"Empty file\";", "DeepSeek-V3.1_completion_2": "        string content = File.ReadAllText(filePath);\n        string result = \"File processed\";", "DeepSeek-V3.1_completion_3": "        string content = File.ReadAllText(filePath);\n        string result = content.Length > 0 ? \"File processed\" : \"Empty file\";", "DeepSeek-V3.1_completion_4": "        string content = File.ReadAllText(filePath);\n        string result = \"File processed\";", "DeepSeek-V3.1_completions": ["        string content = File.ReadAllText(filePath);\n        string result = \"File processed\";", "        string content = File.ReadAllText(filePath);\n        string result = content.Length > 0 ? \"File processed\" : \"Empty file\";", "        string content = File.ReadAllText(filePath);\n        string result = \"File processed\";", "        string content = File.ReadAllText(filePath);\n        string result = content.Length > 0 ? \"File processed\" : \"Empty file\";", "        string content = File.ReadAllText(filePath);\n        string result = \"File processed\";"]}
{"id": "21", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        List<int> squaredNumbers = new List<int>();\n", "suffix": "        foreach (var num in squaredNumbers)\n        {\n            Debug.Assert(num == (num / (int)Math.Sqrt(num)) * (int)Math.Sqrt(num), \"Number is not a perfect square\");\n        }\n    }\n}\n", "golden_completion": "        foreach (var number in numbers)\n        {\n            squaredNumbers.Add(number * number);\n        }\n", "LLM_justification": "This is a good test case for iterator and collection patterns. The prefix sets up a common scenario where a list of numbers needs to be transformed. The golden completion involves a common pattern of iterating over a collection and modifying another collection based on the iteration. The suffix includes assertions to check the correctness of the transformation, ensuring the pattern is recognizable with minimal context.", "assertions": "", "DeepSeek-V3.1_completion_0": "        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completion_1": "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completion_2": "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completion_3": "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completion_4": "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "DeepSeek-V3.1_completions": ["        foreach (int num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }", "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }"]}
{"id": "22", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        Debug.Assert(result.Count == 5, \"Result count should be 5\");\n        Debug.Assert(result[0] == 2, \"First element should be 2\");\n        Debug.Assert(result[4] == 10, \"Last element should be 10\");\n    }\n}\n", "golden_completion": "        var result = numbers.ConvertAll(x => x * 2);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common collection transformation pattern using ConvertAll method on a List<T>. The prefix provides minimal context, establishing a list of integers and the start of a method. The completion requires the model to recognize the need to transform the list elements using a lambda expression, which is a common use case. The suffix includes assertions to validate that the transformation was performed correctly and ensures the pattern is applied as expected.", "assertions": "", "DeepSeek-V3.1_completion_0": "        List<int> result = numbers.Select(x => x * 2).ToList();", "DeepSeek-V3.1_completion_1": "        List<int> result = numbers.Select(x => x * 2).ToList();", "DeepSeek-V3.1_completion_2": "        List<int> result = numbers.Select(x => x * 2).ToList();", "DeepSeek-V3.1_completion_3": "        List<int> result = numbers.Select(x => x * 2).ToList();", "DeepSeek-V3.1_completion_4": "        List<int> result = numbers.Select(x => x * 2).ToList();", "DeepSeek-V3.1_completions": ["        List<int> result = numbers.Select(x => x * 2).ToList();", "        List<int> result = numbers.Select(x => x * 2).ToList();", "        List<int> result = numbers.Select(x => x * 2).ToList();", "        List<int> result = numbers.Select(x => x * 2).ToList();", "        List<int> result = numbers.Select(x => x * 2).ToList();"]}
{"id": "23", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int number = 10;\n", "suffix": "        Debug.Assert(result == 55, \"The sum of the first 10 natural numbers should be 55\");\n        Console.WriteLine(\"Sum calculated correctly.\");\n    }\n}\n", "golden_completion": "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }\n", "LLM_justification": "This is a good test case because it tests the ability to recognize and complete a common algorithm pattern - summing the first 'n' natural numbers. The prefix sets up the context with the variable and method signature, while the golden_completion contains the loop logic. The suffix contains assertions to verify the result and ensures proper output, making the pattern clear and identifiable with minimal context.", "assertions": "", "DeepSeek-V3.1_completion_0": "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "DeepSeek-V3.1_completion_1": "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "DeepSeek-V3.1_completion_2": "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "DeepSeek-V3.1_completion_3": "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "DeepSeek-V3.1_completion_4": "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "DeepSeek-V3.1_completions": ["        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }", "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }"]}
{"id": "24", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n", "suffix": "        foreach (var num in evenNumbers)\n        {\n            Debug.Assert(num % 2 == 0, \"Number is not even\");\n        }\n        Console.WriteLine(\"All numbers are even.\");\n    }\n}", "golden_completion": "        var evenNumbers = System.Linq.Enumerable.Where(numbers, n => n % 2 == 0);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue an iterator and collection pattern using LINQ. The prefix sets up an array of integers and the suffix contains a foreach loop with assertions to verify even numbers. The golden completion requires the model to insert the LINQ statement to filter even numbers, a common and recognizable pattern in C#.", "assertions": "", "DeepSeek-V3.1_completion_0": "        int[] evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "DeepSeek-V3.1_completion_1": "        var evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "DeepSeek-V3.1_completion_2": "        int[] evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "DeepSeek-V3.1_completion_3": "        int[] evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "DeepSeek-V3.1_completion_4": "        int[] evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "DeepSeek-V3.1_completions": ["        int[] evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "        var evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "        int[] evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "        int[] evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();", "        int[] evenNumbers = numbers.Where(n => n % 2 == 0).ToArray();"]}
{"id": "25", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Func<int, int, int> add = ", "suffix": ";\n        int result = add(3, 4);\n        Debug.Assert(result == 7, \"Addition result should be 7\");\n    }\n}\n", "golden_completion": "(x, y) => x + y", "LLM_justification": "This example tests the LLM's ability to recognize and complete a delegate pattern. The prefix sets up a functional programming scenario using a Func delegate. The suffix includes an assertion to verify that the delegate correctly implements addition. This scenario is common and the pattern should be easily recognizable with minimal context.", "assertions": "", "DeepSeek-V3.1_completion_0": "(a, b) => a + b;", "DeepSeek-V3.1_completion_1": "        (a, b) => a + b;", "DeepSeek-V3.1_completion_2": "(x, y) => x + y;", "DeepSeek-V3.1_completion_3": "(int a, int b) => a + b;", "DeepSeek-V3.1_completion_4": "(a, b) => a + b;", "DeepSeek-V3.1_completions": ["(a, b) => a + b;", "        (a, b) => a + b;", "(x, y) => x + y;", "(int a, int b) => a + b;", "(a, b) => a + b;"]}
{"id": "26", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n", "suffix": "        Debug.Assert(PerformCalculation(2, 3) == 5, \"Test Case 1 Failed\");\n        Debug.Assert(PerformCalculation(-1, 1) == 0, \"Test Case 2 Failed\");\n        Debug.Assert(PerformCalculation(0, 0) == 0, \"Test Case 3 Failed\");\n    }\n\n    static int PerformCalculation(int a, int b)\n    {\n        return a + b;\n    }\n}\n", "golden_completion": "        int result = PerformCalculation(2, 3);\n        Console.WriteLine(result);\n", "LLM_justification": "This example tests the model's ability to recognize a simple mathematical operation pattern, specifically the addition of two integers. The context is minimal, with only a method signature and a call to the method provided. The expected behavior is clear and follows standard conventions, making it a good test for low-context pattern recognition.", "assertions": "", "DeepSeek-V3.1_completion_0": "        int result = PerformCalculation(2, 3);\n        Debug.Assert(result == 5, \"Test Case 1 Failed\");\n        result = PerformCalculation(-1, 1);\n        Debug.Assert(result == 0, \"Test Case 2 Failed\");\n        result = PerformCalculation(0, 0);\n        Debug.Assert(result == 0, \"Test Case 3 Failed\");", "DeepSeek-V3.1_completion_1": "        int a = 2, b = 3;\n        int result = PerformCalculation(a, b);", "DeepSeek-V3.1_completion_2": "        int result = PerformCalculation(2, 3);\n        result = PerformCalculation(-1, 1);\n        result = PerformCalculation(0, 0);", "DeepSeek-V3.1_completion_3": "        int result = PerformCalculation(2, 3);\n        result = PerformCalculation(-1, 1);\n        result = PerformCalculation(0, 0);", "DeepSeek-V3.1_completion_4": "        Console.WriteLine(\"All tests passed.\");", "DeepSeek-V3.1_completions": ["        int result = PerformCalculation(2, 3);\n        Debug.Assert(result == 5, \"Test Case 1 Failed\");\n        result = PerformCalculation(-1, 1);\n        Debug.Assert(result == 0, \"Test Case 2 Failed\");\n        result = PerformCalculation(0, 0);\n        Debug.Assert(result == 0, \"Test Case 3 Failed\");", "        int a = 2, b = 3;\n        int result = PerformCalculation(a, b);", "        int result = PerformCalculation(2, 3);\n        result = PerformCalculation(-1, 1);\n        result = PerformCalculation(0, 0);", "        int result = PerformCalculation(2, 3);\n        result = PerformCalculation(-1, 1);\n        result = PerformCalculation(0, 0);", "        Console.WriteLine(\"All tests passed.\");"]}
{"id": "27", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        IEnumerable<int> evens = FilterEvenNumbers(numbers);\n", "suffix": "        var evenList = new List<int>(evens);\n        Debug.Assert(evenList.Count == 2, \"Should have 2 even numbers\");\n        Debug.Assert(evenList[0] == 2, \"First even number should be 2\");\n        Debug.Assert(evenList[1] == 4, \"Second even number should be 4\");\n    }\n\n    static IEnumerable<int> FilterEvenNumbers(IEnumerable<int> numbers)\n    {\n        foreach (int number in numbers)\n        {\n            if (number % 2 == 0)\n            {\n                yield return number;\n            }\n        }\n    }\n}\n", "golden_completion": "        Debug.Assert(evens != null, \"FilterEvenNumbers should not return null\");\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern for testing iterator methods. The golden completion adds a null check before testing the filtered collection.", "assertions": "", "DeepSeek-V3.1_completion_0": "        Console.WriteLine(\"Even numbers: \" + string.Join(\", \", evens));", "DeepSeek-V3.1_completion_1": "        Console.WriteLine(\"Filtered even numbers:\");\n        foreach (var num in evens)\n        {\n            Console.WriteLine(num);\n        }", "DeepSeek-V3.1_completion_2": "        Console.WriteLine(\"Even numbers: \" + string.Join(\", \", evens));", "DeepSeek-V3.1_completion_3": "        Console.WriteLine(\"Filtered even numbers:\");\n        foreach (int num in evens)\n        {\n            Console.WriteLine(num);\n        }", "DeepSeek-V3.1_completion_4": "        Console.WriteLine(\"Even numbers: \" + string.Join(\", \", evens));", "DeepSeek-V3.1_completions": ["        Console.WriteLine(\"Even numbers: \" + string.Join(\", \", evens));", "        Console.WriteLine(\"Filtered even numbers:\");\n        foreach (var num in evens)\n        {\n            Console.WriteLine(num);\n        }", "        Console.WriteLine(\"Even numbers: \" + string.Join(\", \", evens));", "        Console.WriteLine(\"Filtered even numbers:\");\n        foreach (int num in evens)\n        {\n            Console.WriteLine(num);\n        }", "        Console.WriteLine(\"Even numbers: \" + string.Join(\", \", evens));"]}
{"id": "28", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        IEnumerator<int> enumerator = numbers.GetEnumerator();\n", "suffix": "        Debug.Assert(enumerator.MoveNext(), \"First MoveNext() should return true\");\n        Debug.Assert(enumerator.Current == 1, \"First element should be 1\");\n        Debug.Assert(enumerator.MoveNext(), \"Second MoveNext() should return true\");\n        Debug.Assert(enumerator.Current == 2, \"Second element should be 2\");\n        enumerator.Dispose();\n    }\n}\n", "golden_completion": "        // Enumerator is ready to use\n", "LLM_justification": "This example tests the LLM's ability to recognize that an enumerator is properly initialized and ready for iteration. The suffix contains the actual MoveNext() calls and assertions.", "assertions": "", "DeepSeek-V3.1_completion_0": "        while (enumerator.MoveNext())\n        {\n            // This loop is just to advance the enumerator to the end\n        }\n        enumerator.Reset();", "DeepSeek-V3.1_completion_1": "while (enumerator.MoveNext())\n        {\n            // This loop is just to advance the enumerator to the end\n        }\n        enumerator.Reset();", "DeepSeek-V3.1_completion_2": "while (enumerator.MoveNext())\n        {\n            // This loop is just to advance the enumerator to the end\n        }\n        enumerator.Reset();", "DeepSeek-V3.1_completion_3": "        while (enumerator.MoveNext())\n        {\n            // This loop is just to advance the enumerator to the end\n        }\n        enumerator.Reset();", "DeepSeek-V3.1_completion_4": "        while (enumerator.MoveNext())\n        {\n            // Enumerate through the list\n        }\n        enumerator.Reset();", "DeepSeek-V3.1_completions": ["        while (enumerator.MoveNext())\n        {\n            // This loop is just to advance the enumerator to the end\n        }\n        enumerator.Reset();", "while (enumerator.MoveNext())\n        {\n            // This loop is just to advance the enumerator to the end\n        }\n        enumerator.Reset();", "while (enumerator.MoveNext())\n        {\n            // This loop is just to advance the enumerator to the end\n        }\n        enumerator.Reset();", "        while (enumerator.MoveNext())\n        {\n            // This loop is just to advance the enumerator to the end\n        }\n        enumerator.Reset();", "        while (enumerator.MoveNext())\n        {\n            // Enumerate through the list\n        }\n        enumerator.Reset();"]}
{"id": "29", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        int sum = 0;\n        foreach (var number in numbers)\n        {\n            sum += number;\n        }\n        Debug.Assert(sum == 21, \"Sum should be 21\");\n    }\n}\n", "golden_completion": "        numbers.Add(6);\n", "LLM_justification": "This test case focuses on iterator and collection patterns in C#. It tests the model's ability to recognize and continue a pattern of manipulating and iterating through a collection. The prefix sets up a list and the beginning of the Main method, while the suffix includes assertions to verify the integrity of the collection and its sum. The model must correctly continue the pattern of modifying the collection to ensure the final sum is as expected.", "assertions": "", "DeepSeek-V3.1_completion_0": "        Console.WriteLine(\"Calculating sum of numbers:\");", "DeepSeek-V3.1_completion_1": "        int sum = 0;", "DeepSeek-V3.1_completion_2": "        Console.WriteLine(\"Calculating sum of numbers:\");", "DeepSeek-V3.1_completion_3": "        Console.WriteLine(\"Calculating sum of numbers:\");", "DeepSeek-V3.1_completion_4": "        Console.WriteLine(\"Calculating the sum of numbers...\");", "DeepSeek-V3.1_completions": ["        Console.WriteLine(\"Calculating sum of numbers:\");", "        int sum = 0;", "        Console.WriteLine(\"Calculating sum of numbers:\");", "        Console.WriteLine(\"Calculating sum of numbers:\");", "        Console.WriteLine(\"Calculating the sum of numbers...\");"]}
{"id": "30", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<int> GenerateSequence()\n    {\n", "suffix": "        Debug.Assert(sequence.MoveNext() && sequence.Current == 2, \"Second item should be 2\");\n        Debug.Assert(sequence.MoveNext() && sequence.Current == 3, \"Third item should be 3\");\n        Debug.Assert(!sequence.MoveNext(), \"Sequence should end\");\n    }\n}\n", "golden_completion": "        yield return 1;\n        yield return 2;\n        yield return 3;\n    }\n\n    public static void Main()\n    {\n        var sequence = GenerateSequence().GetEnumerator();\n        Debug.Assert(sequence.MoveNext() && sequence.Current == 1, \"First item should be 1\");\n", "LLM_justification": "This is a good test case for evaluating an LLM's ability to recognize and continue an iterator pattern using 'yield return' with minimal context. The prefix sets up an iterator method, and the golden completion is expected to continue yielding a sequence. The suffix includes assertions to verify the correctness of the generated sequence, ensuring the model understands the iterator pattern.", "assertions": "", "DeepSeek-V3.1_completion_0": "        yield return 1;\n        yield return 2;\n        yield return 3;", "DeepSeek-V3.1_completion_1": "        yield return 1;\n        yield return 2;\n        yield return 3;", "DeepSeek-V3.1_completion_2": "        yield return 1;\n        yield return 2;\n        yield return 3;", "DeepSeek-V3.1_completion_3": "        yield return 1;\n        yield return 2;\n        yield return 3;", "DeepSeek-V3.1_completion_4": "        yield return 1;\n        yield return 2;\n        yield return 3;", "DeepSeek-V3.1_completions": ["        yield return 1;\n        yield return 2;\n        yield return 3;", "        yield return 1;\n        yield return 2;\n        yield return 3;", "        yield return 1;\n        yield return 2;\n        yield return 3;", "        yield return 1;\n        yield return 2;\n        yield return 3;", "        yield return 1;\n        yield return 2;\n        yield return 3;"]}
{"id": "31", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Calculator\n{\n    public static int Multiply(int a, int b)\n    {\n", "suffix": "        return result;\n    }\n\n    public static void Main()\n    {\n        int result = Multiply(3, 4);\n        Debug.Assert(result == 12, \"3 * 4 should be 12\");\n    }\n}\n", "golden_completion": "        int result = a * b;\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a multiplication operation within a method based on minimal context. The pattern involves a common mathematical operation (multiplication) and requires the model to correctly identify and implement the core logic of the method. The assertions ensure that the method returns the correct result, validating the pattern adherence and functionality.", "assertions": "", "DeepSeek-V3.1_completion_0": "        int result = a * b;", "DeepSeek-V3.1_completion_1": "        int result = a * b;", "DeepSeek-V3.1_completion_2": "        int result = a * b;", "DeepSeek-V3.1_completion_3": "        int result = a * b;", "DeepSeek-V3.1_completion_4": "        int result = a * b;", "DeepSeek-V3.1_completions": ["        int result = a * b;", "        int result = a * b;", "        int result = a * b;", "        int result = a * b;", "        int result = a * b;"]}
{"id": "32", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Func<int, int, string> func = (x, y) => ", "suffix": ";\n        Debug.Assert(func(2, 3) == \"5\", \"The result should be 5\");\n        Debug.Assert(func(10, -5) == \"5\", \"The result should be 5\");\n    }\n}\n", "golden_completion": "(x + y).ToString()", "LLM_justification": "This is a good test case for recognizing and completing a functional programming pattern in C#. The completion involves completing a lambda function that sums two integers and returns the result as a string. The pattern requires understanding lambda expressions and the ToString method.", "assertions": "", "DeepSeek-V3.1_completion_0": "$\"{x + y}\"", "DeepSeek-V3.1_completion_1": "(x + y).ToString();", "DeepSeek-V3.1_completion_2": "$\"{x + y}\"", "DeepSeek-V3.1_completion_3": "(x + y).ToString();", "DeepSeek-V3.1_completion_4": "$\\textbackslash$\"{(x + y)}\\textbackslash$\"", "DeepSeek-V3.1_completions": ["$\"{x + y}\"", "(x + y).ToString();", "$\"{x + y}\"", "(x + y).ToString();", "$\\textbackslash$\"{(x + y)}\\textbackslash$\""]}
{"id": "33", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        var items = new List<string> { \"Test\" };\n        var item = GetItem(items, 0);\n        Debug.Assert(item == \"Test\", \"Item should be 'Test'\");\n        Debug.Assert(item != null, \"Item should not be null\");\n    }\n\n    static string GetItem(List<string> items, int index)\n    {\n", "suffix": "    }\n}\n", "golden_completion": "        return items[index];\n", "LLM_justification": "This example tests the model's ability to recognize and complete a simple list access pattern.", "assertions": "", "DeepSeek-V3.1_completion_0": "        return items[index];", "DeepSeek-V3.1_completion_1": "        return items[index];", "DeepSeek-V3.1_completion_2": "        return items[index];", "DeepSeek-V3.1_completion_3": "        return items[index];", "DeepSeek-V3.1_completion_4": "        return items[index];", "DeepSeek-V3.1_completions": ["        return items[index];", "        return items[index];", "        return items[index];", "        return items[index];", "        return items[index];"]}
{"id": "34", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Example\n{\n    public delegate int MathOperation(int a, int b);\n\n    public static int PerformOperation(MathOperation operation, int x, int y)\n    {\n", "suffix": "    }\n\n    public static void Main()\n    {\n        MathOperation add = (a, b) => a + b;\n        MathOperation subtract = (a, b) => a - b;\n        int result1 = PerformOperation(add, 10, 5);\n        int result2 = PerformOperation(subtract, 7, 5);\n        Debug.Assert(result1 == 15, \"Addition result is incorrect\");\n        Debug.Assert(result2 == 2, \"Subtraction result is incorrect\");\n    }\n}\n", "golden_completion": "        return operation(x, y);\n", "LLM_justification": "This test case is designed to evaluate the model's ability to recognize and complete a delegate pattern in C#. The example uses a delegate to perform different mathematical operations, showcasing a common use of delegates and functional programming patterns in C#.", "assertions": "", "DeepSeek-V3.1_completion_0": "        return operation(x, y);", "DeepSeek-V3.1_completion_1": "        return operation(x, y);", "DeepSeek-V3.1_completion_2": "        return operation(x, y);", "DeepSeek-V3.1_completion_3": "        return operation(x, y);", "DeepSeek-V3.1_completion_4": "        return operation(x, y);", "DeepSeek-V3.1_completions": ["        return operation(x, y);", "        return operation(x, y);", "        return operation(x, y);", "        return operation(x, y);", "        return operation(x, y);"]}
{"id": "35", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Func<int, int> square = ", "suffix": ";\n        Debug.Assert(square(2) == 4, \"Square of 2 should be 4\");\n        Debug.Assert(square(3) == 9, \"Square of 3 should be 9\");\n    }\n}", "golden_completion": "x => x * x", "LLM_justification": "This example tests the model's ability to recognize and complete a simple functional programming pattern using a delegate. The lambda expression for squaring a number is a common pattern in functional programming, and the assertions validate its correctness. The minimal context provided ensures the model must understand the lambda expression syntax and its application in C#.", "assertions": "", "DeepSeek-V3.1_completion_0": "x => x * x;", "DeepSeek-V3.1_completion_1": "x => x * x;", "DeepSeek-V3.1_completion_2": "x => x * x;", "DeepSeek-V3.1_completion_3": "x => x * x;", "DeepSeek-V3.1_completion_4": "x => x * x;", "DeepSeek-V3.1_completions": ["x => x * x;", "x => x * x;", "x => x * x;", "x => x * x;", "x => x * x;"]}
{"id": "36", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Func<int, int, bool> isEqual = ", "suffix": ";\n        Debug.Assert(isEqual(3, 3), \"3 and 3 should be equal\");\n        Debug.Assert(!isEqual(3, 4), \"3 and 4 should not be equal\");\n    }\n}\n", "golden_completion": "(a, b) => a == b", "LLM_justification": "This example tests the LLM's ability to recognize and complete a functional programming pattern in C# using delegates. The scenario involves defining a lambda function that checks for equality between two integers. The pattern is clear yet non-trivial, and the surrounding context is minimal, making it a good test of the model's ability to infer the correct logic. The suffix includes assertions to verify the correctness of the lambda function, ensuring that it behaves as expected. This tests the model's understanding of functional programming constructs and lambda expressions in C#.", "assertions": "", "DeepSeek-V3.1_completion_0": "(x, y) => x == y;", "DeepSeek-V3.1_completion_1": "(x, y) => x == y;", "DeepSeek-V3.1_completion_2": "(x, y) => x == y;", "DeepSeek-V3.1_completion_3": "(x, y) => x == y;", "DeepSeek-V3.1_completion_4": "(x, y) => x == y;", "DeepSeek-V3.1_completions": ["(x, y) => x == y;", "(x, y) => x == y;", "(x, y) => x == y;", "(x, y) => x == y;", "(x, y) => x == y;"]}
{"id": "37", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomCollection<T>\n{\n    private List<T> items = new List<T>();\n\n    public void Add(T item)\n    {\n        items.Add(item);\n    }\n\n    public IEnumerable<T> Filter(Func<T, bool> predicate)\n    {\n", "suffix": "    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var collection = new CustomCollection<int>();\n        collection.Add(1);\n        collection.Add(2);\n        collection.Add(3);\n\n        var filteredItems = collection.Filter(x => x % 2 == 0);\n        int count = 0;\n        foreach (var item in filteredItems)\n        {\n            Debug.Assert(item % 2 == 0, \"Item should be even\");\n            count++;\n        }\n        Debug.Assert(count == 1, \"There should be exactly one even item\");\n    }\n}\n", "golden_completion": "        foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete a custom iterator pattern using the 'yield return' keyword. The prefix establishes a class with a generic collection and a method signature for filtering items. The required completion involves iterating over the collection and yielding items that match a predicate. This pattern is non-trivial and requires an understanding of C# iterators and lambda expressions. The suffix contains usage of the filter method, iterating over the results, and assertions to verify correctness, ensuring the LLM completes the pattern accurately.", "assertions": "", "DeepSeek-V3.1_completion_0": "foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "DeepSeek-V3.1_completion_1": "foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "DeepSeek-V3.1_completion_2": "foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "DeepSeek-V3.1_completion_3": "        foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "DeepSeek-V3.1_completion_4": "foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "DeepSeek-V3.1_completions": ["foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "        foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }", "foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }"]}
{"id": "38", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Example {\n    public void ProcessItems<T>(IEnumerable<T> items, Action<T> action) {", "suffix": "        Debug.Assert(items != null, \"items should not be null\");\n        Debug.Assert(action != null, \"action should not be null\");\n    }\n\n    public static void Main() {\n        var example = new Example();\n        var numbers = new List<int> { 1, 2, 3, 4, 5 };\n        example.ProcessItems(numbers, n => Console.WriteLine(n));\n    }\n}\n", "golden_completion": "        foreach (var item in items) {\n            action(item);\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common pattern in C# where a generic method processes each item in a collection using an action delegate. The completion requires understanding of generics, delegates, and basic iteration patterns in C#. The prefix sets up the method signature and partial implementation, while the suffix contains assertions and test code that verifies the correct behavior of the method.", "assertions": "", "DeepSeek-V3.1_completion_0": "        foreach (var item in items)\n        {\n            action(item);\n        }", "DeepSeek-V3.1_completion_1": "        foreach (var item in items)\n        {\n            action(item);\n        }", "DeepSeek-V3.1_completion_2": "        foreach (var item in items)\n        {\n            action(item);\n        }", "DeepSeek-V3.1_completion_3": "foreach (var item in items)\n        {\n            action(item);\n        }", "DeepSeek-V3.1_completion_4": "        foreach (var item in items)\n        {\n            action(item);\n        }", "DeepSeek-V3.1_completions": ["        foreach (var item in items)\n        {\n            action(item);\n        }", "        foreach (var item in items)\n        {\n            action(item);\n        }", "        foreach (var item in items)\n        {\n            action(item);\n        }", "foreach (var item in items)\n        {\n            action(item);\n        }", "        foreach (var item in items)\n        {\n            action(item);\n        }"]}
{"id": "39", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Example\n{\n    public void ProcessData(Action<string> callback)\n    {\n        string data = \"Sample data\";\n        Debug.Assert(callback != null, \"Callback should not be null\");\n        Debug.Assert(callback.Method.Name == \"WriteLine\", \"Callback should be WriteLine\");\n", "suffix": "    }\n\n    public static void Main()\n    {\n        Example example = new Example();\n        example.ProcessData(Console.WriteLine);\n    }\n}\n", "golden_completion": "        callback(data);\n", "LLM_justification": "This is a good test case for low-context pattern matching because it requires the model to recognize a common delegate usage pattern in C#. The callback pattern is widely used in event-driven programming and functional programming in C#. The completion involves passing a string to a callback function, which is a typical use case. The minimal context provided should be sufficient for recognizing this pattern, and the assertions verify that the callback is correctly invoked and not null.", "assertions": "", "DeepSeek-V3.1_completion_0": "        callback(data);", "DeepSeek-V3.1_completion_1": "        callback(data);", "DeepSeek-V3.1_completion_2": "        callback(data);", "DeepSeek-V3.1_completion_3": "        callback(data);", "DeepSeek-V3.1_completion_4": "        callback(data);", "DeepSeek-V3.1_completions": ["        callback(data);", "        callback(data);", "        callback(data);", "        callback(data);", "        callback(data);"]}
{"id": "40", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<string> names = new List<string> { \"Alice\", \"Bob\", \"Charlie\" };\n", "suffix": "        Debug.Assert(result.Contains(\"Hello, Alice!\"), \"Missing greeting for Alice\");\n        Debug.Assert(result.Contains(\"Hello, Bob!\"), \"Missing greeting for Bob\");\n        Debug.Assert(result.Contains(\"Hello, Charlie!\"), \"Missing greeting for Charlie\");\n\n        Console.WriteLine(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "        List<string> result = new List<string>();\n        foreach (var name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete a common iterator pattern involving collection processing and string interpolation. The prefix sets up a list of names, and the suffix includes assertions to check that each name has been correctly processed into a greeting. The completion involves iterating over the list and creating personalized greeting messages, which requires understanding of foreach loops and string interpolation in C#.", "assertions": "", "DeepSeek-V3.1_completion_0": "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "DeepSeek-V3.1_completion_1": "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "DeepSeek-V3.1_completion_2": "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "DeepSeek-V3.1_completion_3": "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "DeepSeek-V3.1_completion_4": "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "DeepSeek-V3.1_completions": ["        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }", "        List<string> result = new List<string>();\n        foreach (string name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }"]}
{"id": "41", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class CustomCollection<T> : IEnumerable<T> where T : class\n{\n    private List<T> _items = new List<T>();\n\n    public void Add(T item)\n    {\n        _items.Add(item);\n    }\n\n    public IEnumerator<T> GetEnumerator()\n    {\n        return new CustomEnumerator(_items);\n    }\n\n    private class CustomEnumerator : IEnumerator<T>\n    {\n        private List<T> _items;\n        private int _position = -1;\n\n        public CustomEnumerator(List<T> items)\n        {\n            _items = items;\n        }\n\n        public bool MoveNext()\n        {\n", "suffix": "        }\n\n        public void Reset()\n        {\n            _position = -1;\n        }\n\n        public T Current\n        {\n            get\n            {\n                try\n                {\n                    return _items[_position];\n                }\n                catch (IndexOutOfRangeException)\n                {\n                    throw new InvalidOperationException();\n                }\n            }\n        }\n\n        object IEnumerator.Current => Current;\n\n        public void Dispose()\n        {\n        }\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var collection = new CustomCollection<string>();\n        collection.Add(\"A\");\n        collection.Add(\"B\");\n        collection.Add(\"C\");\n\n        var enumerator = collection.GetEnumerator();\n\n        Debug.Assert(enumerator.MoveNext(), \"MoveNext failed at position 0\");\n        Debug.Assert(enumerator.Current == \"A\", \"Current is not 'A'\");\n\n        Debug.Assert(enumerator.MoveNext(), \"MoveNext failed at position 1\");\n        Debug.Assert(enumerator.Current == \"B\", \"Current is not 'B'\");\n\n        Debug.Assert(enumerator.MoveNext(), \"MoveNext failed at position 2\");\n        Debug.Assert(enumerator.Current == \"C\", \"Current is not 'C'\");\n\n        Debug.Assert(!enumerator.MoveNext(), \"MoveNext should return false at the end\");\n    }\n}\n", "golden_completion": "            _position++;\n            return (_position < _items.Count);\n", "LLM_justification": "This example tests the model's ability to recognize and complete the pattern for implementing a custom IEnumerator<T> in C#. The prefix sets up a custom collection and enumerator, while the suffix verifies the implementation through assertions. The completion requires understanding the iterator pattern and correctly implementing the MoveNext method.", "assertions": "", "DeepSeek-V3.1_completion_0": "_position++;\n            return _position < _items.Count;", "DeepSeek-V3.1_completion_1": "            _position++;\n            return _position < _items.Count;", "DeepSeek-V3.1_completion_2": "_position++;\n            return _position < _items.Count;", "DeepSeek-V3.1_completion_3": "_position++;\n            return _position < _items.Count;", "DeepSeek-V3.1_completion_4": "            _position++;\n            return _position < _items.Count;", "DeepSeek-V3.1_completions": ["_position++;\n            return _position < _items.Count;", "            _position++;\n            return _position < _items.Count;", "_position++;\n            return _position < _items.Count;", "_position++;\n            return _position < _items.Count;", "            _position++;\n            return _position < _items.Count;"]}
{"id": "42", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class PaginatedIterator<T> : IEnumerable<T>\n{\n    private readonly List<T> _items;\n    private readonly int _pageSize;\n\n    public PaginatedIterator(List<T> items, int pageSize)\n    {\n        _items = items;\n        _pageSize = pageSize;\n    }\n\n    public IEnumerator<T> GetEnumerator()\n    {\n        return new PageEnumerator(this);\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n\n    private class PageEnumerator : IEnumerator<T>\n    {\n        private readonly PaginatedIterator<T> _iterator;\n        private int _currentIndex = -1;\n        private int _currentPage = 0;\n\n        public PageEnumerator(PaginatedIterator<T> iterator)\n        {\n            _iterator = iterator;\n        }\n\n        public bool MoveNext()\n        {", "suffix": "        }\n\n        public void Reset()\n        {\n            _currentIndex = -1;\n            _currentPage = 0;\n        }\n\n        public T Current\n        {\n            get\n            {\n                return _iterator._items[_currentIndex];\n            }\n        }\n\n        object IEnumerator.Current => Current;\n\n        public void Dispose() { }\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        PaginatedIterator<int> paginatedIterator = new PaginatedIterator<int>(numbers, 3);\n        int count = 0;\n        foreach (var number in paginatedIterator)\n        {\n            count++;\n        }\n        Debug.Assert(count == 10, \"Expected to iterate through all items in the list\");\n    }\n}\n", "golden_completion": "            _currentIndex++;\n            return _currentIndex < _iterator._items.Count;\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a simple iterator pattern. The MoveNext method should increment the index and check bounds.", "assertions": "", "DeepSeek-V3.1_completion_0": "            int start = _currentPage * _iterator._pageSize;\n            if (start >= _iterator._items.Count)\n                return false;\n\n            _currentIndex = start;\n            _currentPage++;\n            return true;", "DeepSeek-V3.1_completion_1": "            int start = _currentPage * _iterator._pageSize;\n            if (start >= _iterator._items.Count)\n                return false;\n\n            _currentIndex = start;\n            _currentPage++;\n            return true;", "DeepSeek-V3.1_completion_2": "            int start = _currentPage * _iterator._pageSize;\n            if (start >= _iterator._items.Count)\n                return false;\n\n            _currentIndex = start;\n            _currentPage++;\n            return true;", "DeepSeek-V3.1_completion_3": "            int start = _currentPage * _iterator._pageSize;\n            if (start >= _iterator._items.Count)\n                return false;\n\n            _currentIndex = start;\n            _currentPage++;\n            return true;", "DeepSeek-V3.1_completion_4": "            int start = _currentPage * _iterator._pageSize;\n            int end = Math.Min(start + _iterator._pageSize, _iterator._items.Count);\n            if (_currentIndex < end - 1)\n            {\n                _currentIndex++;\n                return true;\n            }\n            else\n            {\n                _currentPage++;\n                if (_currentPage * _iterator._pageSize < _iterator._items.Count)\n                {\n                    _currentIndex = _currentPage * _iterator._pageSize;\n                    return true;\n                }\n                else\n                {\n                    return false;\n                }\n            }", "DeepSeek-V3.1_completions": ["            int start = _currentPage * _iterator._pageSize;\n            if (start >= _iterator._items.Count)\n                return false;\n\n            _currentIndex = start;\n            _currentPage++;\n            return true;", "            int start = _currentPage * _iterator._pageSize;\n            if (start >= _iterator._items.Count)\n                return false;\n\n            _currentIndex = start;\n            _currentPage++;\n            return true;", "            int start = _currentPage * _iterator._pageSize;\n            if (start >= _iterator._items.Count)\n                return false;\n\n            _currentIndex = start;\n            _currentPage++;\n            return true;", "            int start = _currentPage * _iterator._pageSize;\n            if (start >= _iterator._items.Count)\n                return false;\n\n            _currentIndex = start;\n            _currentPage++;\n            return true;", "            int start = _currentPage * _iterator._pageSize;\n            int end = Math.Min(start + _iterator._pageSize, _iterator._items.Count);\n            if (_currentIndex < end - 1)\n            {\n                _currentIndex++;\n                return true;\n            }\n            else\n            {\n                _currentPage++;\n                if (_currentPage * _iterator._pageSize < _iterator._items.Count)\n                {\n                    _currentIndex = _currentPage * _iterator._pageSize;\n                    return true;\n                }\n                else\n                {\n                    return false;\n                }\n            }"]}
{"id": "43", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomCollection<T>\n{\n    private readonly List<T> _items = new List<T>();\n\n    public void Add(T item)\n    {\n        _items.Add(item);\n    }\n\n    public IEnumerator<T> GetEnumerator()\n    {\n", "suffix": "    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var collection = new CustomCollection<int>();\n        collection.Add(1);\n        collection.Add(2);\n        collection.Add(3);\n        var enumerator = collection.GetEnumerator();\n        Debug.Assert(enumerator.MoveNext() && enumerator.Current == 1, \"First item should be 1\");\n        Debug.Assert(enumerator.MoveNext() && enumerator.Current == 2, \"Second item should be 2\");\n        Debug.Assert(enumerator.MoveNext() && enumerator.Current == 3, \"Third item should be 3\");\n        Debug.Assert(!enumerator.MoveNext(), \"No more items should be present\");\n    }\n}", "golden_completion": "        foreach (var item in _items)\n        {\n            yield return item;\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a common pattern for implementing a custom collection with an iterator. The code demonstrates the correct usage of an iterator pattern, requiring the model to understand the use of yield return within a foreach loop over a collection. Assertions in the suffix ensure that the iterator correctly iterates over all items in the collection, verifying both the order and presence of items.", "assertions": "", "DeepSeek-V3.1_completion_0": "        return _items.GetEnumerator();", "DeepSeek-V3.1_completion_1": "foreach (var item in _items)\n        {\n            yield return item;\n        }", "DeepSeek-V3.1_completion_2": "foreach (var item in _items)\n        {\n            yield return item;\n        }", "DeepSeek-V3.1_completion_3": "        return _items.GetEnumerator();", "DeepSeek-V3.1_completion_4": "foreach (var item in _items)\n        {\n            yield return item;\n        }", "DeepSeek-V3.1_completions": ["        return _items.GetEnumerator();", "foreach (var item in _items)\n        {\n            yield return item;\n        }", "foreach (var item in _items)\n        {\n            yield return item;\n        }", "        return _items.GetEnumerator();", "foreach (var item in _items)\n        {\n            yield return item;\n        }"]}
{"id": "44", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    delegate int Operation(int x, int y);\n\n    static void Main()\n    {\n        Operation add = (x, y) => x + y;\n        Operation multiply = (x, y) => x * y;\n", "suffix": "        int sum = add(3, 4);\n        int product = multiply(3, 4);\n        Debug.Assert(sum == 7, \"Sum should be 7\");\n        Debug.Assert(product == 12, \"Product should be 12\");\n    }\n}\n", "golden_completion": "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => x / y;\n", "LLM_justification": "This example demonstrates a pattern of using delegates for basic arithmetic operations. The prefix sets up the context with addition and multiplication operations, and the golden completion introduces subtraction and division operations. The suffix contains assertions that verify the correctness of the operations, ensuring the model understands the pattern of defining and using delegates for arithmetic functions. This scenario tests the model's ability to recognize and extend a pattern with minimal context.", "assertions": "", "DeepSeek-V3.1_completion_0": "        Console.WriteLine($\"Sum: {sum}, Product: {product}\");", "DeepSeek-V3.1_completion_1": "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => x / y;", "DeepSeek-V3.1_completion_2": "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => x / y;", "DeepSeek-V3.1_completion_3": "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => y != 0 ? x / y : 0;", "DeepSeek-V3.1_completion_4": "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => x / y;", "DeepSeek-V3.1_completions": ["        Console.WriteLine($\"Sum: {sum}, Product: {product}\");", "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => x / y;", "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => x / y;", "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => y != 0 ? x / y : 0;", "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => x / y;"]}
{"id": "45", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        var items = new List<int> { 1, 2, 3, 4, 5 };\n        var result = new List<int>();\n        for (int i = 0; i < items.Count; i++)\n        {\n", "suffix": "        }\n        Debug.Assert(result.Count == 5, \"Count should be 5\");\n        Debug.Assert(result[0] == 1, \"First item should be 1\");\n        Debug.Assert(result[4] == 5, \"Last item should be 5\");\n    }\n}\n", "golden_completion": "            result.Add(items[i]);\n", "LLM_justification": "This example tests the model's ability to recognize and complete a simple collection processing pattern.", "assertions": "", "DeepSeek-V3.1_completion_0": "            result.Add(items[i]);", "DeepSeek-V3.1_completion_1": "            result.Add(items[i]);", "DeepSeek-V3.1_completion_2": "            result.Add(items[i]);", "DeepSeek-V3.1_completion_3": "            result.Add(items[i]);", "DeepSeek-V3.1_completion_4": "            result.Add(items[i]);", "DeepSeek-V3.1_completions": ["            result.Add(items[i]);", "            result.Add(items[i]);", "            result.Add(items[i]);", "            result.Add(items[i]);", "            result.Add(items[i]);"]}
{"id": "46", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static Func<int, int> CreateMultiplier(int factor)\n    {\n", "suffix": "    }\n\n    static void Main()\n    {\n        Func<int, int> multiplier = CreateMultiplier(5);\n        Debug.Assert(multiplier(2) == 10, \"Multiplier function failed\");\n        Debug.Assert(multiplier(3) == 15, \"Multiplier function failed\");\n    }\n}\n", "golden_completion": "        return x => x * factor;\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a functional programming pattern, specifically the creation of a closure that captures an external variable. The pattern involves returning a lambda function that uses the captured variable.", "assertions": "", "DeepSeek-V3.1_completion_0": "        return x => x * factor;", "DeepSeek-V3.1_completion_1": "        return x => x * factor;", "DeepSeek-V3.1_completion_2": "        return x => x * factor;", "DeepSeek-V3.1_completion_3": "        return x => x * factor;", "DeepSeek-V3.1_completion_4": "        return x => x * factor;", "DeepSeek-V3.1_completions": ["        return x => x * factor;", "        return x => x * factor;", "        return x => x * factor;", "        return x => x * factor;", "        return x => x * factor;"]}
{"id": "47", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        var items = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        var pages = new List<List<int>>();\n        int pageSize = 3;\n        for (int i = 0; i < items.Count; i += pageSize)\n        {\n", "suffix": "        }\n        Debug.Assert(pages.Count == 3, \"Expected 3 pages.\");\n        Debug.Assert(pages[0].Count == 3, \"Expected 3 items in the first page.\");\n        Debug.Assert(pages[1].Count == 3, \"Expected 3 items in the second page.\");\n        Debug.Assert(pages[2].Count == 3, \"Expected 3 items in the third page.\");\n    }\n}\n", "golden_completion": "            pages.Add(items.GetRange(i, Math.Min(pageSize, items.Count - i)));\n", "LLM_justification": "This example tests the LLM's ability to complete a simple pagination pattern using GetRange.", "assertions": "", "DeepSeek-V3.1_completion_0": "            pages.Add(items.GetRange(i, Math.Min(pageSize, items.Count - i)));", "DeepSeek-V3.1_completion_1": "var page = items.GetRange(i, Math.Min(pageSize, items.Count - i));\n            pages.Add(page);", "DeepSeek-V3.1_completion_2": "var page = items.GetRange(i, Math.Min(pageSize, items.Count - i));\n            pages.Add(page);", "DeepSeek-V3.1_completion_3": "        pages.Add(items.GetRange(i, Math.Min(pageSize, items.Count - i)));", "DeepSeek-V3.1_completion_4": "            pages.Add(items.GetRange(i, Math.Min(pageSize, items.Count - i)));", "DeepSeek-V3.1_completions": ["            pages.Add(items.GetRange(i, Math.Min(pageSize, items.Count - i)));", "var page = items.GetRange(i, Math.Min(pageSize, items.Count - i));\n            pages.Add(page);", "var page = items.GetRange(i, Math.Min(pageSize, items.Count - i));\n            pages.Add(page);", "        pages.Add(items.GetRange(i, Math.Min(pageSize, items.Count - i)));", "            pages.Add(items.GetRange(i, Math.Min(pageSize, items.Count - i)));"]}
{"id": "48", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class PagedEnumerator<T> : IEnumerator<T>\n{\n    private readonly IList<T> _collection;\n    private readonly int _pageSize;\n    private int _currentPage;\n    private int _currentIndex;\n\n    public PagedEnumerator(IList<T> collection, int pageSize)\n    {\n        _collection = collection;\n        _pageSize = pageSize;\n        _currentPage = 0;\n        _currentIndex = -1;\n    }\n", "suffix": "    public void Reset()\n    {\n        _currentPage = 0;\n        _currentIndex = -1;\n    }\n\n    public T Current => _collection[_currentPage * _pageSize + _currentIndex];\n\n    object System.Collections.IEnumerator.Current => Current;\n\n    public void Dispose() {}\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var data = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        var enumerator = new PagedEnumerator<int>(data, 3);\n        var results = new List<int>();\n        while (enumerator.MoveNext())\n        {\n            results.Add(enumerator.Current);\n        }\n        Debug.Assert(results.Count == 9, \"All elements should be iterated.\");\n        Debug.Assert(results[0] == 1 && results[8] == 9, \"The elements should be in order.\");\n    }\n}\n", "golden_completion": "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a custom IEnumerator<T> implementation pattern with complex state handling. The MoveNext() method requires understanding of pagination logic, proper state management, and correct return value semantics. This is a non-trivial pattern often encountered in production code for handling batched or paged data processing. The pattern is clear and recognizable with minimal context, and the provided assertions ensure the implementation follows the intended logic and handles edge cases correctly.", "assertions": "", "DeepSeek-V3.1_completion_0": "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }", "DeepSeek-V3.1_completion_1": "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }", "DeepSeek-V3.1_completion_2": "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }", "DeepSeek-V3.1_completion_3": "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }", "DeepSeek-V3.1_completion_4": "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return (_currentPage * _pageSize + _currentIndex) < _collection.Count;\n    }", "DeepSeek-V3.1_completions": ["    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }", "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }", "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }", "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }", "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return (_currentPage * _pageSize + _currentIndex) < _collection.Count;\n    }"]}
{"id": "49", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomEnumerator<T>\n{\n    private readonly List<T> _collection;\n    private int _currentIndex;\n\n    public CustomEnumerator(List<T> collection)\n    {\n        _collection = collection;\n        _currentIndex = -1;\n    }\n\n    public bool MoveNext()\n    {\n", "suffix": "        return _currentIndex < _collection.Count - 1;\n    }\n\n    public T Current => _collection[_currentIndex];\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var list = new List<int> { 1, 2, 3 };\n        var enumerator = new CustomEnumerator<int>(list);\n        while (enumerator.MoveNext())\n        {\n            Debug.Assert(enumerator.Current == list[enumerator.Current - 1], \"Current value does not match expected value.\");\n        }\n    }\n}", "golden_completion": "        _currentIndex++;\n", "LLM_justification": "This example tests the model's ability to recognize and complete a custom enumerator pattern in C#. The enumerator pattern is widely used and involves maintaining state with an index and checking for bounds. The golden completion focuses on updating the current index, which is crucial for the MoveNext method to function correctly. This pattern is common in production code and requires understanding of iteration state management.", "assertions": "", "DeepSeek-V3.1_completion_0": "        _currentIndex++;\n        return _currentIndex < _collection.Count;", "DeepSeek-V3.1_completion_1": "        _currentIndex++;\n        return _currentIndex < _collection.Count;", "DeepSeek-V3.1_completion_2": "        _currentIndex++;\n        return _currentIndex < _collection.Count;", "DeepSeek-V3.1_completion_3": "        _currentIndex++;\n        return _currentIndex < _collection.Count;", "DeepSeek-V3.1_completion_4": "        _currentIndex++;\n        return _currentIndex < _collection.Count;", "DeepSeek-V3.1_completions": ["        _currentIndex++;\n        return _currentIndex < _collection.Count;", "        _currentIndex++;\n        return _currentIndex < _collection.Count;", "        _currentIndex++;\n        return _currentIndex < _collection.Count;", "        _currentIndex++;\n        return _currentIndex < _collection.Count;", "        _currentIndex++;\n        return _currentIndex < _collection.Count;"]}
{"id": "50", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomEnumerator<T> : IEnumerable<T>\n{\n    private readonly List<T> _items;\n    public CustomEnumerator(List<T> items)\n    {\n        _items = items;\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        for (int i = 0; i < _items.Count; i++)\n        {\n            if (i % 2 == 0)\n            {", "suffix": "            }\n        }\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n}\n\npublic static class Program\n{\n    public static void Main(string[] args)\n    {\n        var items = new List<int> { 1, 2, 3, 4, 5 };\n        var enumerator = new CustomEnumerator<int>(items);\n        var result = new List<int>();\n        foreach (var item in enumerator)\n        {\n            result.Add(item);\n        }\n        Debug.Assert(result.Count == 3, \"Expected 3 items\");\n        Debug.Assert(result[0] == 1, \"Expected first item to be 1\");\n        Debug.Assert(result[1] == 3, \"Expected second item to be 3\");\n        Debug.Assert(result[2] == 5, \"Expected third item to be 5\");\n    }\n}\n", "golden_completion": "                yield return _items[i];", "LLM_justification": "This example tests the LLM's ability to recognize and complete a custom iterator pattern in C#. The pattern involves implementing an enumerator that returns every second item from a list using yield return.", "assertions": "", "DeepSeek-V3.1_completion_0": "                yield return _items[i];", "DeepSeek-V3.1_completion_1": "                yield return _items[i];", "DeepSeek-V3.1_completion_2": "                yield return _items[i];", "DeepSeek-V3.1_completion_3": "                yield return _items[i];", "DeepSeek-V3.1_completion_4": "                yield return _items[i];", "DeepSeek-V3.1_completions": ["                yield return _items[i];", "                yield return _items[i];", "                yield return _items[i];", "                yield return _items[i];", "                yield return _items[i];"]}
