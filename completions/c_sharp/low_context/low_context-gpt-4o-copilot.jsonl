{"id": "1", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        Debug.Assert(numbers.Count == 5, \"List should contain 5 elements\");\n        Debug.Assert(numbers[2] == 3, \"Third element should be 3\");\n        numbers.RemoveAt(2);\n        Debug.Assert(numbers.Count == 4, \"List should contain 4 elements after removal\");\n        Debug.Assert(!numbers.Contains(3), \"List should not contain 3 after removal\");\n    }\n}\n", "golden_completion": "        numbers.Add(6);\n        numbers.Insert(2, 7);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue the pattern of manipulating a List in C#. The prefix initializes a List and the suffix includes assertions to ensure the correct state of the List after manipulations. The golden completion involves adding and inserting elements into the List, which is a common pattern in List manipulations.", "assertions": "", "gpt-4o-copilot": "        Debug.Assert(numbers[0] == 1, \"First element should be 1\");"}
{"id": "2", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        numbers.Remove(3);\n        Debug.Assert(numbers.Count == 4, \"Count should be 4 after removal\");\n        Debug.Assert(!numbers.Contains(3), \"List should not contain 3 after removal\");\n    }\n}\n", "golden_completion": "        numbers.Add(6);\n        Debug.Assert(numbers.Count == 6, \"Count should be 6 after addition\");\n        Debug.Assert(numbers.Contains(6), \"List should contain 6 after addition\");\n", "LLM_justification": "This test case examines the model's ability to recognize and complete a common pattern in data structure manipulation, specifically with Lists in C#. The code checks the ability to add an element to the List and verifies the addition with assertions. The minimal context is provided through the initial List setup, and the expected behavior is clearly defined through the assertions.", "assertions": "", "gpt-4o-copilot": "        numbers.RemoveAt(2);"}
{"id": "3", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        int sum = 0;\n        foreach (var number in numbers)\n        {\n            sum += number;\n        }\n        Debug.Assert(sum == 12, \"Sum should be 12\");\n    }\n}\n", "golden_completion": "        numbers.Remove(3);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving List data structure manipulation. The removal of an element from the list is a common operation, and the subsequent calculation of the sum is used to verify correctness. The assertions ensure that the model understands the impact of the removal operation on the list contents.", "assertions": "", "gpt-4o-copilot": "        foreach (var number in numbers)"}
{"id": "4", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        List<int> squaredNumbers = new List<int>();\n", "suffix": "        Debug.Assert(squaredNumbers.Count == 5, \"The squaredNumbers list should have 5 elements.\");\n        Debug.Assert(squaredNumbers[0] == 1, \"The first element should be 1.\");\n        Debug.Assert(squaredNumbers[1] == 4, \"The second element should be 4.\");\n        Debug.Assert(squaredNumbers[2] == 9, \"The third element should be 9.\");\n        Debug.Assert(squaredNumbers[3] == 16, \"The fourth element should be 16.\");\n        Debug.Assert(squaredNumbers[4] == 25, \"The fifth element should be 25.\");\n    }\n}\n", "golden_completion": "        foreach (int number in numbers)\n        {\n            squaredNumbers.Add(number * number);\n        }\n", "LLM_justification": "This test case is a good example of low-context pattern recognition because it requires the model to understand the common pattern of iterating over a list and performing a transformation on each element (in this case, squaring the numbers). The prefix sets up the context with the list of numbers and an empty list for the squared numbers, while the golden completion provides the correct loop to fill the squaredNumbers list. The suffix contains assertions to verify the correctness of the transformation, ensuring that the model's completion is accurate.", "assertions": "", "gpt-4o-copilot": "        foreach (int number in numbers)\n        {\n            squaredNumbers.Add(number * number);\n        }"}
{"id": "5", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var numbers = new int[] {1, 2, 3, 4, 5};\n        int sum = 0;\n", "suffix": "        Debug.Assert(sum == 15, \"Sum should be 15\");\n        Console.WriteLine(\"Sum is correct: \" + sum);\n    }\n}\n", "golden_completion": "        foreach (var number in numbers)\n        {\n            sum += number;\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a common pattern of iterating over an array to calculate the sum of its elements. The pattern is clear and identifiable with minimal context, and the assertions ensure the correct functionality of the loop.", "assertions": "", "gpt-4o-copilot": "        foreach (var number in numbers)\n        {\n            sum += number;\n        }"}
{"id": "6", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4 };\n", "suffix": "        Debug.Assert(numbers.Count == 5, \"Count should be 5\");\n        Debug.Assert(numbers[4] == 5, \"Last element should be 5\");\n    }\n}\n", "golden_completion": "        numbers.Add(5);\n", "LLM_justification": "This example tests the model's ability to recognize and continue a list manipulation pattern with minimal context. The prefix sets up a list and the suffix contains assertions that verify the list's state after the completion, ensuring the model correctly adds an element to the list.", "assertions": "", "gpt-4o-copilot": "        numbers.Add(5);"}
{"id": "7", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        try\n        {\n", "suffix": "        }\n        catch (ArgumentNullException ex)\n        {\n            Debug.Assert(ex.ParamName == \"input\", \"Expected ArgumentNullException for input parameter\");\n        }\n    }\n}\n", "golden_completion": "            string input = null;\n            if (input == null)\n            {\n                throw new ArgumentNullException(nameof(input));\n            }\n", "LLM_justification": "This test case checks the LLM's ability to recognize and complete an error handling pattern involving argument validation and exception throwing. The prefix sets up a try block, and the golden completion involves throwing an ArgumentNullException when a null input is detected. The suffix handles the exception and includes an assertion to verify the correct exception was thrown, ensuring the pattern is recognized and properly implemented.", "assertions": "", "gpt-4o-copilot": "            string input = null;\n            Debug.Assert(input == null, \"Input should be null\");\n            Console.WriteLine(input.Length);"}
{"id": "8", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n        int result = 0;\n        foreach (int number in numbers)\n        {\n", "suffix": "        }\n        Debug.Assert(result == 15, \"Sum should be 15\");\n        Console.WriteLine(\"Sum: \" + result);\n    }\n}\n", "golden_completion": "            result += number;\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete a simple iteration pattern over an array, summing its elements. The context is minimal, but the pattern is clear and common, making it an effective benchmark for low-context pattern recognition.", "assertions": "", "gpt-4o-copilot": "            result += number;"}
{"id": "9", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        List<int> evenNumbers = new List<int>();\n", "suffix": "        Debug.Assert(evenNumbers.Count == 2, \"There should be 2 even numbers.\");\n        Debug.Assert(evenNumbers.Contains(2), \"List should contain 2.\");\n        Debug.Assert(evenNumbers.Contains(4), \"List should contain 4.\");\n    }\n}\n", "golden_completion": "        foreach (var number in numbers)\n        {\n            if (number % 2 == 0)\n            {\n                evenNumbers.Add(number);\n            }\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete an iterator and collection pattern. The context is minimal but provides enough information for a common pattern of filtering a collection based on a condition. The assertions verify that the correct even numbers are added to the new list.", "assertions": "", "gpt-4o-copilot": "        foreach (var number in numbers)\n        {\n            if (number % 2 == 0)\n            {\n                evenNumbers.Add(number);\n            }\n        }"}
{"id": "10", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Calculator\n{\n    public int Add(int a, int b)\n    {\n", "suffix": "        Debug.Assert(result == 7, \"Addition result should be 7\");\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        Calculator calc = new Calculator();\n        int result = calc.Add(3, 4);\n        Debug.Assert(result == 7, \"Main: Addition result should be 7\");\n    }\n}\n", "golden_completion": "        return a + b;\n", "LLM_justification": "This scenario tests the model's ability to recognize and complete a simple arithmetic operation within a method. The context is minimal, with only the method signature provided. The completion should correctly implement the addition operation, which is then verified by assertions in the suffix.", "assertions": "", "gpt-4o-copilot": "        int result = a + b;"}
{"id": "11", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        Task<int> task = Task.Run(() =>\n        {\n            return 42;\n        });\n", "suffix": "        Debug.Assert(result == 42, \"Task result should be 42\");\n        Console.WriteLine(\"Task completed with result: \" + result);\n    }\n}", "golden_completion": "        int result = await task;\n", "LLM_justification": "This example tests the model's ability to recognize and continue an async/await pattern with minimal context. The prefix establishes the setup for an asynchronous task, and the suffix includes assertions to verify the result of the task. The golden completion demonstrates the correct usage of the await keyword to obtain the result of the task. This pattern is widely used in C# for asynchronous programming.", "assertions": "", "gpt-4o-copilot": "        int result = await task;"}
{"id": "12", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n", "suffix": "        Debug.Assert(sum == 15, \"Sum should be 15\");\n    }\n}\n", "golden_completion": "        int sum = 0;\n        foreach (var num in numbers)\n        {\n            sum += num;\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize a common iterator and collection pattern. The prefix establishes an array and the suffix asserts the sum of the array elements, making it clear that a loop is needed to sum the elements. The completion must fill in the iteration logic correctly. This scenario is simple yet effective in testing the model's ability to continue a basic but universally recognized pattern in C#.", "assertions": "", "gpt-4o-copilot": "        int sum = 0;\n        foreach (int number in numbers)\n        {\n            sum += number;\n        }"}
{"id": "13", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        try\n        {\n", "suffix": "        }\n        catch (InvalidOperationException ex)\n        {\n            Debug.Assert(ex.Message == \"Operation is not valid.\", \"Unexpected exception message\");\n        }\n        catch (Exception ex)\n        {\n            Debug.Assert(false, \"Unexpected exception type: \" + ex.GetType().Name);\n        }\n    }\n}\n", "golden_completion": "            throw new InvalidOperationException(\"Operation is not valid.\");\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and complete a common error handling pattern in C#. The try block is set up to throw a specific exception, and the catch block is designed to validate that the correct exception type and message are handled. This scenario tests the model's understanding of exception handling and assertion usage within minimal context.", "assertions": "", "gpt-4o-copilot": "            throw new InvalidOperationException(\"Operation is not valid.\");"}
{"id": "14", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Func<int, int, int> add = ", "suffix": ";\n        int result = add(2, 3);\n        Debug.Assert(result == 5, \"The add function should return 5 when given 2 and 3.\");\n    }\n}\n", "golden_completion": "(x, y) => x + y", "LLM_justification": "This example tests the LLM's ability to recognize and complete a simple delegate pattern with a lambda expression. The prefix sets up a Func delegate, and the golden completion requires the model to complete the lambda function correctly. The suffix includes an assertion to verify the correctness of the lambda function, ensuring that it adheres to the expected pattern and functionality.", "assertions": "", "gpt-4o-copilot": "            (x, y) => x + y"}
{"id": "15", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n        int sum = 0;\n        foreach (int number in numbers)\n        {\n", "suffix": "        }\n        Debug.Assert(sum == 15, \"Sum should be 15\");\n    }\n}\n", "golden_completion": "            sum += number;\n", "LLM_justification": "This test case checks the LLM's ability to recognize and complete a common pattern of summing elements in a collection using a foreach loop. The context is minimal but should be sufficient for the model to infer the pattern. The prefix sets up the loop and the suffix includes an assertion to verify the correct sum, ensuring the model completes the pattern correctly without duplicating any code in the suffix.", "assertions": "", "gpt-4o-copilot": "            sum += number;"}
{"id": "16", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.IO;\n\npublic class ResourceExample\n{\n    public void WriteToFile(string path, string content)\n    {", "suffix": "        Debug.Assert(File.Exists(path), \"File should exist after writing.\");\n        string writtenContent = File.ReadAllText(path);\n        Debug.Assert(writtenContent == \"Hello, World!\", \"Content should match the written text.\");\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        string path = \"testfile.txt\";\n        var example = new ResourceExample();\n        example.WriteToFile(path, \"Hello, World!\");\n        File.Delete(path);\n    }\n}", "golden_completion": "        using (StreamWriter writer = new StreamWriter(path))\n        {\n            writer.Write(content);\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and continue a common resource management pattern using 'using' statements for automatic disposal of resources. The prefix sets up the method signature and the context of writing to a file, while the suffix includes assertions to verify the correct behavior. The golden completion involves the proper use of the 'using' statement to manage the StreamWriter resource.", "assertions": "", "gpt-4o-copilot": "        File.WriteAllText(path, content);"}
{"id": "17", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int numerator = 10;\n        int denominator = 2;\n", "suffix": "        Debug.Assert(result == 5, \"Division result should be 5\");\n        denominator = 0;\n        try\n        {\n            result = Divide(numerator, denominator);\n        }\n        catch (DivideByZeroException)\n        {\n            Debug.Assert(true, \"Caught expected DivideByZeroException\");\n        }\n    }\n\n    public static int Divide(int a, int b)\n    {\n        return a / b;\n    }\n}\n", "golden_completion": "        int result = Divide(numerator, denominator);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a common error handling pattern. The prefix sets up a division operation, and the golden completion involves performing this division. The suffix then includes assertions to verify correct behavior both for a valid division and handling a division by zero exception. This is a minimal context example that requires understanding of exception handling in C#.", "assertions": "", "gpt-4o-copilot": "        int result = Divide(numerator, denominator);"}
{"id": "18", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        Task<int> task = Task.Run(() => 42);\n", "suffix": "        Debug.Assert(result == 42, \"Task result should be 42\");\n        Console.WriteLine(\"Task completed successfully\");\n    }\n}\n", "golden_completion": "        int result = await task;\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete an async/await pattern with minimal context. The context provided includes an async method that initiates a task, with the expected completion involving awaiting the task's result. The assertion checks if the task's result is as expected, ensuring the correct usage of async/await.", "assertions": "", "gpt-4o-copilot": "        int result = await task;"}
{"id": "19", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.IO;\n\npublic class ResourceManagementExample\n{\n    public void ManageResource()\n    {\n", "suffix": "    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        ResourceManagementExample example = new ResourceManagementExample();\n        example.ManageResource();\n    }\n}\n", "golden_completion": "        using (StreamReader reader = new StreamReader(\"example.txt\"))\n        {\n            string content = reader.ReadToEnd();\n            Debug.Assert(!string.IsNullOrEmpty(content), \"File content should not be empty\");\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a resource management pattern using the 'using' statement in C#. The 'using' statement ensures that resources are properly disposed of, which is a common and essential pattern in C#. The example provides minimal context but still allows for the correct completion of the pattern. The assertions verify the functionality by checking that the file content is not empty.", "assertions": "", "gpt-4o-copilot": "        using (FileStream fileStream = new FileStream(\"example.txt\", FileMode.Create))\n        {\n            using (StreamWriter writer = new StreamWriter(fileStream))\n            {\n                writer.WriteLine(\"Hello, World!\");\n            }\n        }"}
{"id": "20", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.IO;\n\nclass ResourceManagementExample\n{\n    public void ProcessFile(string filePath)\n    {\n", "suffix": "        Debug.Assert(result == \"File processed\", \"The file was not processed correctly\");\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        ResourceManagementExample example = new ResourceManagementExample();\n        example.ProcessFile(\"test.txt\");\n    }\n}\n", "golden_completion": "        string result;\n        using (StreamReader reader = new StreamReader(filePath))\n        {\n            result = \"File processed\";\n        }\n", "LLM_justification": "This scenario tests the model's ability to recognize and complete a common resource management pattern using the 'using' statement for handling IDisposable resources. The prefix sets up the context by defining a method that processes a file, while the suffix includes an assertion to verify the correct functionality and the necessary cleanup. The golden completion demonstrates the proper use of the 'using' statement to ensure the StreamReader is disposed of correctly. This pattern is widely used and should be recognizable with minimal context.", "assertions": "", "gpt-4o-copilot": "        string result = File.ReadAllText(filePath);\n        // Simulate file processing\n        result = \"File processed\";"}
{"id": "21", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        List<int> squaredNumbers = new List<int>();\n", "suffix": "        foreach (var num in squaredNumbers)\n        {\n            Debug.Assert(num == (num / (int)Math.Sqrt(num)) * (int)Math.Sqrt(num), \"Number is not a perfect square\");\n        }\n    }\n}\n", "golden_completion": "        foreach (var number in numbers)\n        {\n            squaredNumbers.Add(number * number);\n        }\n", "LLM_justification": "This is a good test case for iterator and collection patterns. The prefix sets up a common scenario where a list of numbers needs to be transformed. The golden completion involves a common pattern of iterating over a collection and modifying another collection based on the iteration. The suffix includes assertions to check the correctness of the transformation, ensuring the pattern is recognizable with minimal context.", "assertions": "", "gpt-4o-copilot": "        foreach (var num in numbers)\n        {\n            squaredNumbers.Add(num * num);\n        }"}
{"id": "22", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        Debug.Assert(result.Count == 5, \"Result count should be 5\");\n        Debug.Assert(result[0] == 2, \"First element should be 2\");\n        Debug.Assert(result[4] == 10, \"Last element should be 10\");\n    }\n}\n", "golden_completion": "        var result = numbers.ConvertAll(x => x * 2);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common collection transformation pattern using ConvertAll method on a List<T>. The prefix provides minimal context, establishing a list of integers and the start of a method. The completion requires the model to recognize the need to transform the list elements using a lambda expression, which is a common use case. The suffix includes assertions to validate that the transformation was performed correctly and ensures the pattern is applied as expected.", "assertions": "", "gpt-4o-copilot": "        var result = numbers.Select(x => x * 2).ToList();"}
{"id": "23", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int number = 10;\n", "suffix": "        Debug.Assert(result == 55, \"The sum of the first 10 natural numbers should be 55\");\n        Console.WriteLine(\"Sum calculated correctly.\");\n    }\n}\n", "golden_completion": "        int result = 0;\n        for (int i = 1; i <= number; i++)\n        {\n            result += i;\n        }\n", "LLM_justification": "This is a good test case because it tests the ability to recognize and complete a common algorithm pattern - summing the first 'n' natural numbers. The prefix sets up the context with the variable and method signature, while the golden_completion contains the loop logic. The suffix contains assertions to verify the result and ensures proper output, making the pattern clear and identifiable with minimal context.", "assertions": "", "gpt-4o-copilot": "        int result = (number * (number + 1)) / 2;"}
{"id": "24", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n", "suffix": "        foreach (var num in evenNumbers)\n        {\n            Debug.Assert(num % 2 == 0, \"Number is not even\");\n        }\n        Console.WriteLine(\"All numbers are even.\");\n    }\n}", "golden_completion": "        var evenNumbers = System.Linq.Enumerable.Where(numbers, n => n % 2 == 0);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue an iterator and collection pattern using LINQ. The prefix sets up an array of integers and the suffix contains a foreach loop with assertions to verify even numbers. The golden completion requires the model to insert the LINQ statement to filter even numbers, a common and recognizable pattern in C#.", "assertions": "", "gpt-4o-copilot": "        var evenNumbers = Array.FindAll(numbers, n => n % 2 == 0);"}
{"id": "25", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Func<int, int, int> add = ", "suffix": ";\n        int result = add(3, 4);\n        Debug.Assert(result == 7, \"Addition result should be 7\");\n    }\n}\n", "golden_completion": "(x, y) => x + y", "LLM_justification": "This example tests the LLM's ability to recognize and complete a delegate pattern. The prefix sets up a functional programming scenario using a Func delegate. The suffix includes an assertion to verify that the delegate correctly implements addition. This scenario is common and the pattern should be easily recognizable with minimal context.", "assertions": "", "gpt-4o-copilot": "            (x, y) => x + y"}
{"id": "26", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n", "suffix": "        Debug.Assert(PerformCalculation(2, 3) == 5, \"Test Case 1 Failed\");\n        Debug.Assert(PerformCalculation(-1, 1) == 0, \"Test Case 2 Failed\");\n        Debug.Assert(PerformCalculation(0, 0) == 0, \"Test Case 3 Failed\");\n    }\n\n    static int PerformCalculation(int a, int b)\n    {\n        return a + b;\n    }\n}\n", "golden_completion": "        int result = PerformCalculation(2, 3);\n        Console.WriteLine(result);\n", "LLM_justification": "This example tests the model's ability to recognize a simple mathematical operation pattern, specifically the addition of two integers. The context is minimal, with only a method signature and a call to the method provided. The expected behavior is clear and follows standard conventions, making it a good test for low-context pattern recognition.", "assertions": "", "gpt-4o-copilot": "        Debug.Assert(PerformCalculation(2, 3) == 5, \"Test Case 1 Failed\");"}
{"id": "27", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        IEnumerable<int> evens = FilterEvenNumbers(numbers);\n", "suffix": "        Debug.Assert(evens.GetEnumerator().MoveNext() && evens.GetEnumerator().Current == 2, \"First even number should be 2\");\n        Debug.Assert(evens.GetEnumerator().MoveNext() && evens.GetEnumerator().Current == 4, \"Second even number should be 4\");\n        Debug.Assert(!evens.GetEnumerator().MoveNext(), \"No more even numbers should be present\");\n    }\n\n    static IEnumerable<int> FilterEvenNumbers(IEnumerable<int> numbers)\n    {\n        foreach (int number in numbers)\n        {\n            if (number % 2 == 0)\n            {\n                yield return number;\n            }\n        }\n    }\n}\n", "golden_completion": "        foreach (int number in numbers)\n        {\n            if (number % 2 == 0)\n            {\n                yield return number;\n            }\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a common iterator pattern for filtering a collection. The prefix sets up a list of integers, and the suffix includes assertions to verify the correct even numbers are returned. The golden completion involves yielding even numbers, which is a standard pattern for filtering collections.", "assertions": "", "gpt-4o-copilot": "        Debug.Assert(evens.GetEnumerator().MoveNext() && evens.GetEnumerator().Current == 2, \"First even number should be 2\");"}
{"id": "28", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        IEnumerator<int> enumerator = numbers.GetEnumerator();\n", "suffix": "        Debug.Assert(enumerator.MoveNext(), \"First MoveNext() should return true\");\n        Debug.Assert(enumerator.Current == 1, \"First element should be 1\");\n        Debug.Assert(enumerator.MoveNext(), \"Second MoveNext() should return true\");\n        Debug.Assert(enumerator.Current == 2, \"Second element should be 2\");\n        enumerator.Dispose();\n    }\n}\n", "golden_completion": "        enumerator.MoveNext();\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving the use of an enumerator to iterate over a collection. The prefix sets up the collection and enumerator, and the suffix contains assertions that verify the correct behavior of the enumerator after moving to the next element. The golden completion requires the LLM to identify that moving the enumerator to the next element is the next logical step in the pattern.", "assertions": "", "gpt-4o-copilot": "        Debug.Assert(enumerator.MoveNext(), \"First MoveNext() should return true\");"}
{"id": "29", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n", "suffix": "        int sum = 0;\n        foreach (var number in numbers)\n        {\n            sum += number;\n        }\n        Debug.Assert(sum == 21, \"Sum should be 21\");\n    }\n}\n", "golden_completion": "        numbers.Add(6);\n", "LLM_justification": "This test case focuses on iterator and collection patterns in C#. It tests the model's ability to recognize and continue a pattern of manipulating and iterating through a collection. The prefix sets up a list and the beginning of the Main method, while the suffix includes assertions to verify the integrity of the collection and its sum. The model must correctly continue the pattern of modifying the collection to ensure the final sum is as expected.", "assertions": "", "gpt-4o-copilot": "        numbers.Add(6);"}
{"id": "30", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<int> GenerateSequence()\n    {\n", "suffix": "        Debug.Assert(sequence.MoveNext() && sequence.Current == 2, \"Second item should be 2\");\n        Debug.Assert(sequence.MoveNext() && sequence.Current == 3, \"Third item should be 3\");\n        Debug.Assert(!sequence.MoveNext(), \"Sequence should end\");\n    }\n}\n", "golden_completion": "        yield return 1;\n        yield return 2;\n        yield return 3;\n    }\n\n    public static void Main()\n    {\n        var sequence = GenerateSequence().GetEnumerator();\n        Debug.Assert(sequence.MoveNext() && sequence.Current == 1, \"First item should be 1\");\n", "LLM_justification": "This is a good test case for evaluating an LLM's ability to recognize and continue an iterator pattern using 'yield return' with minimal context. The prefix sets up an iterator method, and the golden completion is expected to continue yielding a sequence. The suffix includes assertions to verify the correctness of the generated sequence, ensuring the model understands the iterator pattern.", "assertions": "", "gpt-4o-copilot": "        var sequence = new List<int> { 1, 2, 3 }.GetEnumerator();\n        Debug.Assert(sequence.MoveNext() && sequence.Current == 1, \"First item should be 1\");"}
{"id": "31", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Calculator\n{\n    public static int Multiply(int a, int b)\n    {\n", "suffix": "        return result;\n    }\n\n    public static void Main()\n    {\n        int result = Multiply(3, 4);\n        Debug.Assert(result == 12, \"3 * 4 should be 12\");\n    }\n}\n", "golden_completion": "        int result = a * b;\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a multiplication operation within a method based on minimal context. The pattern involves a common mathematical operation (multiplication) and requires the model to correctly identify and implement the core logic of the method. The assertions ensure that the method returns the correct result, validating the pattern adherence and functionality.", "assertions": "", "gpt-4o-copilot": "        int result = a * b;"}
{"id": "32", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Func<int, int, string> func = (x, y) => ", "suffix": ";\n        Debug.Assert(func(2, 3) == \"5\", \"The result should be 5\");\n        Debug.Assert(func(10, -5) == \"5\", \"The result should be 5\");\n    }\n}\n", "golden_completion": "((x, y) => (x + y).ToString())", "LLM_justification": "This is a good test case for recognizing and completing a functional programming pattern in C#. The completion involves creating a lambda function that sums two integers and returns the result as a string. The pattern is non-trivial and requires understanding the use of lambda expressions and the ToString method. Assertions verify correctness of the function output.", "assertions": "", "gpt-4o-copilot": "            (x + y).ToString();"}
{"id": "33", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomCollection<T>\n{\n    private List<T> _items = new List<T>();\n\n    public void AddItem(T item)\n    {\n        _items.Add(item);\n    }\n\n    public T GetItem(int index)\n    {\n", "suffix": "        Debug.Assert(result != null, \"Item should not be null\");\n    }\n\n    public static void Main()\n    {\n        var collection = new CustomCollection<string>();\n        collection.AddItem(\"Test\");\n        var item = collection.GetItem(0);\n        Debug.Assert(item == \"Test\", \"Item should be 'Test'\");\n    }\n}\n", "golden_completion": "        T result = _items[index];\n        return result;\n", "LLM_justification": "This example tests the model's ability to recognize and complete a common pattern in collection management with generics. The pattern involves adding and retrieving items from a generic list, which is a realistic use case. The context provided is minimal, requiring the model to understand the use of generics and collection methods. The suffix includes assertions to validate the correct implementation and ensure the pattern is followed correctly.", "assertions": "", "gpt-4o-copilot": "        T result = _items[index];"}
{"id": "34", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Example\n{\n    public delegate int MathOperation(int a, int b);\n\n    public static int PerformOperation(MathOperation operation, int x, int y)\n    {\n", "suffix": "    }\n\n    public static void Main()\n    {\n        MathOperation add = (a, b) => a + b;\n        MathOperation subtract = (a, b) => a - b;\n        int result1 = PerformOperation(add, 10, 5);\n        int result2 = PerformOperation(subtract, 7, 5);\n        Debug.Assert(result1 == 15, \"Addition result is incorrect\");\n        Debug.Assert(result2 == 2, \"Subtraction result is incorrect\");\n    }\n}\n", "golden_completion": "        int result = operation(x, y);\n", "LLM_justification": "This test case is designed to evaluate the model's ability to recognize and complete a delegate pattern in C#. The example uses a delegate to perform different mathematical operations, showcasing a common use of delegates and functional programming patterns in C#. The pattern is recognizable with minimal context, focusing on the correct usage of delegates and lambda expressions.", "assertions": "", "gpt-4o-copilot": "        return operation(x, y);"}
{"id": "35", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Func<int, int> square = ", "suffix": ";\n        Debug.Assert(square(2) == 4, \"Square of 2 should be 4\");\n        Debug.Assert(square(3) == 9, \"Square of 3 should be 9\");\n    }\n}", "golden_completion": "x => x * x", "LLM_justification": "This example tests the model's ability to recognize and complete a simple functional programming pattern using a delegate. The lambda expression for squaring a number is a common pattern in functional programming, and the assertions validate its correctness. The minimal context provided ensures the model must understand the lambda expression syntax and its application in C#.", "assertions": "", "gpt-4o-copilot": "            x => x * x"}
{"id": "36", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Func<int, int, bool> isEqual = ", "suffix": ";\n        Debug.Assert(isEqual(3, 3), \"3 and 3 should be equal\");\n        Debug.Assert(!isEqual(3, 4), \"3 and 4 should not be equal\");\n    }\n}\n", "golden_completion": "(a, b) => a == b", "LLM_justification": "This example tests the LLM's ability to recognize and complete a functional programming pattern in C# using delegates. The scenario involves defining a lambda function that checks for equality between two integers. The pattern is clear yet non-trivial, and the surrounding context is minimal, making it a good test of the model's ability to infer the correct logic. The suffix includes assertions to verify the correctness of the lambda function, ensuring that it behaves as expected. This tests the model's understanding of functional programming constructs and lambda expressions in C#.", "assertions": "", "gpt-4o-copilot": "        (x, y) => x == y"}
{"id": "37", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomCollection<T>\n{\n    private List<T> items = new List<T>();\n\n    public void Add(T item)\n    {\n        items.Add(item);\n    }\n\n    public IEnumerable<T> Filter(Func<T, bool> predicate)\n    {\n", "suffix": "    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var collection = new CustomCollection<int>();\n        collection.Add(1);\n        collection.Add(2);\n        collection.Add(3);\n\n        var filteredItems = collection.Filter(x => x % 2 == 0);\n        int count = 0;\n        foreach (var item in filteredItems)\n        {\n            Debug.Assert(item % 2 == 0, \"Item should be even\");\n            count++;\n        }\n        Debug.Assert(count == 1, \"There should be exactly one even item\");\n    }\n}\n", "golden_completion": "        foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete a custom iterator pattern using the 'yield return' keyword. The prefix establishes a class with a generic collection and a method signature for filtering items. The required completion involves iterating over the collection and yielding items that match a predicate. This pattern is non-trivial and requires an understanding of C# iterators and lambda expressions. The suffix contains usage of the filter method, iterating over the results, and assertions to verify correctness, ensuring the LLM completes the pattern accurately.", "assertions": "", "gpt-4o-copilot": "        foreach (var item in items)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }"}
{"id": "38", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Example {\n    public void ProcessItems<T>(IEnumerable<T> items, Action<T> action) {", "suffix": "        Debug.Assert(items != null, \"items should not be null\");\n        Debug.Assert(action != null, \"action should not be null\");\n    }\n\n    public static void Main() {\n        var example = new Example();\n        var numbers = new List<int> { 1, 2, 3, 4, 5 };\n        example.ProcessItems(numbers, n => Console.WriteLine(n));\n    }\n}\n", "golden_completion": "        foreach (var item in items) {\n            action(item);\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common pattern in C# where a generic method processes each item in a collection using an action delegate. The completion requires understanding of generics, delegates, and basic iteration patterns in C#. The prefix sets up the method signature and partial implementation, while the suffix contains assertions and test code that verifies the correct behavior of the method.", "assertions": "", "gpt-4o-copilot": "        Debug.Assert(items != null, \"items should not be null\");\n        Debug.Assert(action != null, \"action should not be null\");\n        foreach (var item in items) {\n            action(item);\n        }"}
{"id": "39", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\npublic class Example\n{\n    public void ProcessData(Action<string> callback)\n    {\n        string data = \"Sample data\";\n        Debug.Assert(callback != null, \"Callback should not be null\");\n        Debug.Assert(callback.Method.Name == \"WriteLine\", \"Callback should be WriteLine\");\n", "suffix": "    }\n\n    public static void Main()\n    {\n        Example example = new Example();\n        example.ProcessData(Console.WriteLine);\n    }\n}\n", "golden_completion": "        callback(data);\n", "LLM_justification": "This is a good test case for low-context pattern matching because it requires the model to recognize a common delegate usage pattern in C#. The callback pattern is widely used in event-driven programming and functional programming in C#. The completion involves passing a string to a callback function, which is a typical use case. The minimal context provided should be sufficient for recognizing this pattern, and the assertions verify that the callback is correctly invoked and not null.", "assertions": "", "gpt-4o-copilot": "        callback(data);"}
{"id": "40", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<string> names = new List<string> { \"Alice\", \"Bob\", \"Charlie\" };\n", "suffix": "        Debug.Assert(result.Contains(\"Hello, Alice!\"), \"Missing greeting for Alice\");\n        Debug.Assert(result.Contains(\"Hello, Bob!\"), \"Missing greeting for Bob\");\n        Debug.Assert(result.Contains(\"Hello, Charlie!\"), \"Missing greeting for Charlie\");\n\n        Console.WriteLine(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "        List<string> result = new List<string>();\n        foreach (var name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete a common iterator pattern involving collection processing and string interpolation. The prefix sets up a list of names, and the suffix includes assertions to check that each name has been correctly processed into a greeting. The completion involves iterating over the list and creating personalized greeting messages, which requires understanding of foreach loops and string interpolation in C#.", "assertions": "", "gpt-4o-copilot": "        List<string> result = new List<string>();\n        foreach (var name in names)\n        {\n            result.Add($\"Hello, {name}!\");\n        }"}
{"id": "41", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\npublic class CustomCollection<T> : IEnumerable<T> where T : class\n{\n    private List<T> _items = new List<T>();\n\n    public void Add(T item)\n    {\n        _items.Add(item);\n    }\n\n    public IEnumerator<T> GetEnumerator()\n    {\n        return new CustomEnumerator(_items);\n    }\n\n    private class CustomEnumerator : IEnumerator<T>\n    {\n        private List<T> _items;\n        private int _position = -1;\n\n        public CustomEnumerator(List<T> items)\n        {\n            _items = items;\n        }\n\n        public bool MoveNext()\n        {\n", "suffix": "        }\n\n        public void Reset()\n        {\n            _position = -1;\n        }\n\n        public T Current\n        {\n            get\n            {\n                try\n                {\n                    return _items[_position];\n                }\n                catch (IndexOutOfRangeException)\n                {\n                    throw new InvalidOperationException();\n                }\n            }\n        }\n\n        object IEnumerator.Current => Current;\n\n        public void Dispose()\n        {\n        }\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var collection = new CustomCollection<string>();\n        collection.Add(\"A\");\n        collection.Add(\"B\");\n        collection.Add(\"C\");\n\n        var enumerator = collection.GetEnumerator();\n\n        Debug.Assert(enumerator.MoveNext(), \"MoveNext failed at position 0\");\n        Debug.Assert(enumerator.Current == \"A\", \"Current is not 'A'\");\n\n        Debug.Assert(enumerator.MoveNext(), \"MoveNext failed at position 1\");\n        Debug.Assert(enumerator.Current == \"B\", \"Current is not 'B'\");\n\n        Debug.Assert(enumerator.MoveNext(), \"MoveNext failed at position 2\");\n        Debug.Assert(enumerator.Current == \"C\", \"Current is not 'C'\");\n\n        Debug.Assert(!enumerator.MoveNext(), \"MoveNext should return false at the end\");\n    }\n}\n", "golden_completion": "            _position++;\n            return (_position < _items.Count);\n", "LLM_justification": "This example tests the model's ability to recognize and complete the pattern for implementing a custom IEnumerator<T> in C#. The prefix sets up a custom collection and enumerator, while the suffix verifies the implementation through assertions. The completion requires understanding the iterator pattern and correctly implementing the MoveNext method.", "assertions": "", "gpt-4o-copilot": "            _position++;\n            return (_position < _items.Count);"}
{"id": "42", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class PaginatedIterator<T> : IEnumerable<T>\n{\n    private readonly List<T> _items;\n    private readonly int _pageSize;\n\n    public PaginatedIterator(List<T> items, int pageSize)\n    {\n        _items = items;\n        _pageSize = pageSize;\n    }\n\n    public IEnumerator<T> GetEnumerator()\n    {\n        return new PageEnumerator(this);\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n\n    private class PageEnumerator : IEnumerator<T>\n    {\n        private readonly PaginatedIterator<T> _iterator;\n        private int _currentIndex = -1;\n        private int _currentPage = 0;\n\n        public PageEnumerator(PaginatedIterator<T> iterator)\n        {\n            _iterator = iterator;\n        }\n\n        public bool MoveNext()\n        {", "suffix": "        }\n\n        public void Reset()\n        {\n            _currentIndex = -1;\n            _currentPage = 0;\n        }\n\n        public T Current\n        {\n            get\n            {\n                return _iterator._items[_currentIndex];\n            }\n        }\n\n        object IEnumerator.Current => Current;\n\n        public void Dispose() { }\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        PaginatedIterator<int> paginatedIterator = new PaginatedIterator<int>(numbers, 3);\n        int count = 0;\n        foreach (var number in paginatedIterator)\n        {\n            count++;\n        }\n        Debug.Assert(count == 10, \"Expected to iterate through all items in the list\");\n    }\n}\n", "golden_completion": "            _currentIndex++;\n            if (_currentIndex >= (_currentPage + 1) * _iterator._pageSize)\n            {\n                _currentPage++;\n                if (_currentIndex >= _iterator._items.Count)\n                {\n                    return false;\n                }\n            }\n            return true;\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a custom iterator pattern with complex yield logic. The PaginatedIterator class divides a list into pages, iterating through items page by page. The MoveNext method includes logic to handle transitions between pages, making it a good test for understanding stateful iterators and lazy evaluation.", "assertions": "", "gpt-4o-copilot": "            if (_currentIndex + 1 < _iterator._items.Count && (_currentIndex + 1) % _iterator._pageSize != 0)\n            {\n                _currentIndex++;\n                return true;\n            }\n            else if (_currentPage * _iterator._pageSize < _iterator._items.Count)\n            {\n                _currentPage++;\n                _currentIndex = _currentPage * _iterator._pageSize;\n                return _currentIndex < _iterator._items.Count;\n            }\n            return false;"}
{"id": "43", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomCollection<T>\n{\n    private readonly List<T> _items = new List<T>();\n\n    public void Add(T item)\n    {\n        _items.Add(item);\n    }\n\n    public IEnumerator<T> GetEnumerator()\n    {\n", "suffix": "    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var collection = new CustomCollection<int>();\n        collection.Add(1);\n        collection.Add(2);\n        collection.Add(3);\n        var enumerator = collection.GetEnumerator();\n        Debug.Assert(enumerator.MoveNext() && enumerator.Current == 1, \"First item should be 1\");\n        Debug.Assert(enumerator.MoveNext() && enumerator.Current == 2, \"Second item should be 2\");\n        Debug.Assert(enumerator.MoveNext() && enumerator.Current == 3, \"Third item should be 3\");\n        Debug.Assert(!enumerator.MoveNext(), \"No more items should be present\");\n    }\n}", "golden_completion": "        foreach (var item in _items)\n        {\n            yield return item;\n        }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a common pattern for implementing a custom collection with an iterator. The code demonstrates the correct usage of an iterator pattern, requiring the model to understand the use of yield return within a foreach loop over a collection. Assertions in the suffix ensure that the iterator correctly iterates over all items in the collection, verifying both the order and presence of items.", "assertions": "", "gpt-4o-copilot": "        return _items.GetEnumerator();"}
{"id": "44", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    delegate int Operation(int x, int y);\n\n    static void Main()\n    {\n        Operation add = (x, y) => x + y;\n        Operation multiply = (x, y) => x * y;\n", "suffix": "        int sum = add(3, 4);\n        int product = multiply(3, 4);\n        Debug.Assert(sum == 7, \"Sum should be 7\");\n        Debug.Assert(product == 12, \"Product should be 12\");\n    }\n}\n", "golden_completion": "        Operation subtract = (x, y) => x - y;\n        Operation divide = (x, y) => x / y;\n", "LLM_justification": "This example demonstrates a pattern of using delegates for basic arithmetic operations. The prefix sets up the context with addition and multiplication operations, and the golden completion introduces subtraction and division operations. The suffix contains assertions that verify the correctness of the operations, ensuring the model understands the pattern of defining and using delegates for arithmetic functions. This scenario tests the model's ability to recognize and extend a pattern with minimal context.", "assertions": "", "gpt-4o-copilot": "        int sum = add(3, 4);"}
{"id": "45", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomEnumerator<T>\n{\n    private readonly List<T> _items;\n    public CustomEnumerator(List<T> items)\n    {\n        _items = items;\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        for (int i = 0; i < _items.Count; i++)\n        {\n", "suffix": "        }\n    }\n\n    public static void Main()\n    {\n        var items = new List<int> { 1, 2, 3, 4, 5 };\n        var enumerator = new CustomEnumerator<int>(items);\n        var result = new List<int>();\n        foreach (var item in enumerator.GetEnumerator())\n        {\n            result.Add(item);\n        }\n        Debug.Assert(result.Count == 5, \"Count should be 5\");\n        Debug.Assert(result[0] == 1, \"First item should be 1\");\n        Debug.Assert(result[4] == 5, \"Last item should be 5\");\n    }\n}\n", "golden_completion": "            yield return _items[i];\n", "LLM_justification": "This example tests the model's ability to recognize and complete a custom enumerator pattern using yield return. The prefix sets up the structure, and the completion involves iterating over a list to yield each item. The suffix contains assertions to verify the enumerator's correctness, ensuring that the model can complete the pattern accurately. This scenario involves understanding deferred execution and custom iterator patterns, which are advanced C# concepts.", "assertions": "", "gpt-4o-copilot": "            yield return _items[i];"}
{"id": "46", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static Func<int, int> CreateMultiplier(int factor)\n    {\n", "suffix": "        Func<int, int> multiplier = CreateMultiplier(5);\n        Debug.Assert(multiplier(2) == 10, \"Multiplier function failed\");\n        Debug.Assert(multiplier(3) == 15, \"Multiplier function failed\");\n    }\n}\n", "golden_completion": "        return x => x * factor;\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a functional programming pattern, specifically the creation of a closure that captures an external variable. The pattern involves returning a lambda function that uses the captured variable, which is a common use case in C#. The prefix sets up the method signature and context, the golden completion provides the lambda function definition, and the suffix includes assertions to verify the correct behavior of the closure. This scenario requires understanding of closures and lambda expressions in C#.", "assertions": "", "gpt-4o-copilot": "        return x => x * factor;"}
{"id": "47", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomPaginator<T>\n{\n    private readonly List<T> _items;\n    private readonly int _pageSize;\n\n    public CustomPaginator(List<T> items, int pageSize)\n    {\n        _items = items;\n        _pageSize = pageSize;\n    }\n\n    public IEnumerable<IEnumerable<T>> GetPages()\n    {", "suffix": "        }\n    }\n}\n\npublic class Test\n{\n    public static void Main()\n    {\n        var items = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        var paginator = new CustomPaginator<int>(items, 3);\n        var pages = paginator.GetPages();\n        var pageList = new List<List<int>>(pages);\n\n        Debug.Assert(pageList.Count == 3, \"Expected 3 pages.\");\n        Debug.Assert(pageList[0].Count == 3, \"Expected 3 items in the first page.\");\n        Debug.Assert(pageList[1].Count == 3, \"Expected 3 items in the second page.\");\n        Debug.Assert(pageList[2].Count == 3, \"Expected 3 items in the third page.\");\n    }\n}\n", "golden_completion": "        for (int i = 0; i < _items.Count; i += _pageSize)\n        {\n            yield return _items.GetRange(i, Math.Min(_pageSize, _items.Count - i));\n", "LLM_justification": "This example tests the LLM's ability to complete a custom paginator implementation, which involves iterating over a collection and yielding pages of items. The paginator pattern is common in production code for handling large datasets in manageable chunks. The provided prefix sets up the context with the class and method definitions, while the suffix includes assertions to verify that the paginator correctly divides the list into pages. This scenario requires understanding of iterators, yield statements, and collection manipulation in C#.", "assertions": "", "gpt-4o-copilot": "        for (int i = 0; i < _items.Count; i += _pageSize)\n        {\n            yield return _items.GetRange(i, Math.Min(_pageSize, _items.Count - i));\n        }"}
{"id": "48", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class PagedEnumerator<T> : IEnumerator<T>\n{\n    private readonly IList<T> _collection;\n    private readonly int _pageSize;\n    private int _currentPage;\n    private int _currentIndex;\n\n    public PagedEnumerator(IList<T> collection, int pageSize)\n    {\n        _collection = collection;\n        _pageSize = pageSize;\n        _currentPage = 0;\n        _currentIndex = -1;\n    }\n", "suffix": "    public void Reset()\n    {\n        _currentPage = 0;\n        _currentIndex = -1;\n    }\n\n    public T Current => _collection[_currentPage * _pageSize + _currentIndex];\n\n    object System.Collections.IEnumerator.Current => Current;\n\n    public void Dispose() {}\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var data = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        var enumerator = new PagedEnumerator<int>(data, 3);\n        var results = new List<int>();\n        while (enumerator.MoveNext())\n        {\n            results.Add(enumerator.Current);\n        }\n        Debug.Assert(results.Count == 9, \"All elements should be iterated.\");\n        Debug.Assert(results[0] == 1 && results[8] == 9, \"The elements should be in order.\");\n    }\n}\n", "golden_completion": "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }\n", "LLM_justification": "This example tests the model's ability to recognize and complete a custom IEnumerator<T> implementation pattern with complex state handling. The MoveNext() method requires understanding of pagination logic, proper state management, and correct return value semantics. This is a non-trivial pattern often encountered in production code for handling batched or paged data processing. The pattern is clear and recognizable with minimal context, and the provided assertions ensure the implementation follows the intended logic and handles edge cases correctly.", "assertions": "", "gpt-4o-copilot": "    public bool MoveNext()\n    {\n        _currentIndex++;\n        if (_currentIndex >= _pageSize)\n        {\n            _currentPage++;\n            _currentIndex = 0;\n        }\n        return _currentPage * _pageSize + _currentIndex < _collection.Count;\n    }"}
{"id": "49", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomEnumerator<T>\n{\n    private readonly List<T> _collection;\n    private int _currentIndex;\n\n    public CustomEnumerator(List<T> collection)\n    {\n        _collection = collection;\n        _currentIndex = -1;\n    }\n\n    public bool MoveNext()\n    {\n", "suffix": "        return _currentIndex < _collection.Count - 1;\n    }\n\n    public T Current => _collection[_currentIndex];\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var list = new List<int> { 1, 2, 3 };\n        var enumerator = new CustomEnumerator<int>(list);\n        while (enumerator.MoveNext())\n        {\n            Debug.Assert(enumerator.Current == list[enumerator.Current - 1], \"Current value does not match expected value.\");\n        }\n    }\n}", "golden_completion": "        _currentIndex++;\n", "LLM_justification": "This example tests the model's ability to recognize and complete a custom enumerator pattern in C#. The enumerator pattern is widely used and involves maintaining state with an index and checking for bounds. The golden completion focuses on updating the current index, which is crucial for the MoveNext method to function correctly. This pattern is common in production code and requires understanding of iteration state management.", "assertions": "", "gpt-4o-copilot": "        _currentIndex++;"}
{"id": "50", "testsource": "devbench-low-context", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class CustomEnumerator<T>\n{\n    private readonly List<T> _items;\n    public CustomEnumerator(List<T> items)\n    {\n        _items = items;\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        for (int i = 0; i < _items.Count; i++)\n        {\n            if (i % 2 == 0)\n            {", "suffix": "            }\n        }\n    }\n}\n\npublic static class Program\n{\n    public static void Main(string[] args)\n    {\n        var items = new List<int> { 1, 2, 3, 4, 5 };\n        var enumerator = new CustomEnumerator<int>(items);\n        var result = new List<int>();\n        foreach (var item in enumerator.GetEnumerator())\n        {\n            result.Add(item);\n        }\n        Debug.Assert(result.Count == 3, \"Expected 3 items\");\n        Debug.Assert(result[0] == 1, \"Expected first item to be 1\");\n        Debug.Assert(result[1] == 3, \"Expected second item to be 3\");\n        Debug.Assert(result[2] == 5, \"Expected third item to be 5\");\n    }\n}\n", "golden_completion": "                yield return _items[i];", "LLM_justification": "This example tests the LLM's ability to recognize and complete a custom iterator pattern in C#. The pattern involves implementing an enumerator that returns every second item from a list, a non-trivial task that requires understanding of yield statements and custom iteration logic. The prefix establishes the context of the class and method, while the suffix verifies the implementation with assertions. This scenario ensures the model understands advanced iterator patterns and can generate correct, executable code.", "assertions": "", "gpt-4o-copilot": "                yield return _items[i];"}
