{"id": "1", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace PortfolioAnalysis\n{\n    public class Portfolio\n    {\n        private List<Stock> stocks;\n        public Portfolio()\n        {\n            stocks = new List<Stock>();\n        }\n\n        public void AddStock(Stock stock)\n        {\n            stocks.Add(stock);\n        }\n\n        public void RemoveStock(string symbol)\n        {\n            stocks.RemoveAll(stock => stock.Symbol == symbol);\n        }\n\n        public decimal CalculateTotalValue()\n        {\n            decimal totalValue = 0;\n            foreach (var stock in stocks)\n            {\n                totalValue += stock.Quantity * stock.CurrentPrice;\n            }\n            return totalValue;\n        }\n    }\n\n    public class Stock\n    {\n        public string Symbol { get; set; }\n        public int Quantity { get; set; }\n        public decimal CurrentPrice { get; set; }\n\n        public Stock(string symbol, int quantity, decimal currentPrice)\n        {\n            Symbol = symbol;\n            Quantity = quantity;\n            CurrentPrice = currentPrice;\n        }\n    }\n}\n", "suffix": "namespace PortfolioAnalysis\n{\n    public class Portfolio\n    {\n        // Method to calculate the average price of stocks in the portfolio\n        public decimal CalculateAveragePrice()\n        {\n            decimal totalPrice = 0;\n            int totalQuantity = 0;\n            foreach (var stock in stocks)\n            {\n                totalPrice += stock.CurrentPrice * stock.Quantity;\n                totalQuantity += stock.Quantity;\n            }\n            return totalQuantity > 0 ? totalPrice / totalQuantity : 0;\n        }\n\n        public static void Main(string[] args)\n        {\n            Portfolio portfolio = new Portfolio();\n            portfolio.AddStock(new Stock(\"AAPL\", 10, 150.00m));\n            portfolio.AddStock(new Stock(\"GOOGL\", 5, 2800.00m));\n            portfolio.AddStock(new Stock(\"MSFT\", 15, 300.00m));\n\n            decimal totalValue = portfolio.CalculateTotalValue();\n            Debug.Assert(totalValue == 150.00m * 10 + 2800.00m * 5 + 300.00m * 15, \"Total value calculation is incorrect.\");\n\n            decimal averagePrice = portfolio.CalculateAveragePrice();\n            Debug.Assert(averagePrice == ((150.00m * 10 + 2800.00m * 5 + 300.00m * 15) / 30), \"Average price calculation is incorrect.\");\n        }\n    }\n}\n", "golden_completion": "/// <summary>\n/// Calculates the average price of all stocks in the portfolio.\n/// </summary>\n/// <returns>The average price of the stocks.</returns>\n/// <remarks>\n/// This method calculates the average price by dividing the total value of the stocks by the total quantity of stocks.\n/// If the portfolio is empty, the method returns 0.\n/// </remarks>\n", "LLM_justification": "This test case provides a realistic example of a financial calculation in a portfolio analysis scenario. The prefix sets up the necessary context and classes, while the completion requires generating comprehensive documentation for a method. The suffix includes assertions to verify the correctness of the code implementation, making it a good test case for bidirectional translation between code and natural language. The documentation should cover the method's purpose, return value, and any important remarks.", "assertions": "", "gpt-35-turbo-completions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace PortfolioAnalysis\n{\n    public class Portfolio\n    {\n        private List<Stock> stocks;\n        public Portfolio()\n        {\n            stocks = new List<Stock>();\n        }\n\n        public void AddStock(Stock stock)\n        {\n            stocks.Add(stock);\n        }\n\n        public void RemoveStock(string symbol)\n        {\n            stocks.RemoveAll(stock => stock.Symbol == symbol);\n        }\n\n        public decimal CalculateTotalValue()\n        {\n            decimal totalValue = 0;\n            foreach (var stock in stocks)\n            {\n                totalValue += stock.Quantity * stock.CurrentPrice;\n            }\n            return totalValue;\n        }\n\n        public decimal CalculateAveragePrice()\n        {\n            decimal totalPrice = 0;\n            int totalQuantity = 0;\n            foreach (var stock in stocks)\n            {\n                totalPrice += stock.CurrentPrice * stock.Quantity;\n                totalQuantity += stock.Quantity;\n            }\n            return totalQuantity > 0 ? totalPrice / totalQuantity : 0;\n        }\n\n        public static void Main(string[] args)\n        {\n            Portfolio portfolio = new Portfolio();\n            portfolio.AddStock(new Stock(\"AAPL\", 10, 150.00m));\n            portfolio.AddStock(new Stock(\"GOOGL\", 5, 2800.00m));\n            portfolio.AddStock(new Stock(\"MSFT\", 15, 300.00m));\n\n            decimal totalValue = portfolio.CalculateTotalValue();\n            Debug.Assert(totalValue == 150.00m * 10 + 2800.00m * 5 + 300.00m * 15, \"Total value calculation is incorrect.\");\n\n            decimal averagePrice = portfolio.CalculateAveragePrice();\n            Debug.Assert(averagePrice == ((150.00m * 10 + 2800.00m * 5 + 300.00m * 15) / 30), \"Average price calculation is incorrect.\");\n        }\n    }\n\n    public class Stock\n    {\n        public string Symbol { get; set; }\n        public int Quantity { get; set; }\n        public decimal CurrentPrice { get; set; }\n\n        public Stock(string symbol, int quantity, decimal currentPrice)\n        {\n            Symbol = symbol;\n            Quantity = quantity;\n            CurrentPrice = currentPrice;\n        }\n    }\n}\n#TODO: You Code Here\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace PortfolioAnalysis\n{\n    public class Portfolio\n    {\n        private List<Stock> stocks;\n        public Portfolio()\n        {\n            stocks = new List<Stock>();\n        }\n\n        public void AddStock(Stock stock)\n        {\n            stocks.Add(stock);\n        }\n\n        public void RemoveStock(string symbol)\n        {\n            stocks.RemoveAll(stock => stock.Symbol == symbol);\n        }\n\n        public decimal CalculateTotalValue()\n        {\n            decimal totalValue = 0;\n            foreach (var stock in stocks)\n            {\n                totalValue += stock.Quantity * stock.CurrentPrice;\n            }\n            return totalValue;\n        }\n\n        public decimal CalculateAveragePrice()\n        {\n            decimal totalPrice = 0;\n            int totalQuantity = 0;\n            foreach (var stock in stocks)\n            {\n                totalPrice += stock.CurrentPrice * stock.Quantity;\n                totalQuantity += stock.Quantity;\n            }\n            return totalQuantity > 0 ? totalPrice / totalQuantity : 0;\n        }\n\n        public static void Main(string[] args)\n        {\n            Portfolio portfolio = new Portfolio();\n            portfolio.AddStock(new Stock(\"AAPL\", 10, 150.00m));\n            portfolio.AddStock(new Stock(\"GOOGL\", 5, 2800.00m));\n            portfolio.AddStock(new Stock(\"MSFT\", 15, 300.00m));\n\n            decimal totalValue = portfolio.CalculateTotalValue();\n            Debug.Assert(totalValue == 150.00m * 10 + 2800.00m * 5 + 300"}
{"id": "2", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace PortfolioAnalysis\n{\n    /// <summary>\n    /// Represents a single financial asset in a portfolio.\n    /// </summary>\n    public class Asset\n    {\n        /// <summary>\n        /// Gets or sets the name of the asset.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the value of the asset.\n        /// </summary>\n        public decimal Value { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Asset\"/> class.\n        /// </summary>\n        /// <param name=\"name\">The name of the asset.</param>\n        /// <param name=\"value\">The value of the asset.</param>\n        public Asset(string name, decimal value)\n        {\n            Name = name;\n            Value = value;\n        }\n    }\n\n    /// <summary>\n    /// Provides methods to analyze a portfolio of assets.\n    /// </summary>\n    public class Portfolio\n    {\n        private List<Asset> _assets;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Portfolio\"/> class.\n        /// </summary>\n        public Portfolio()\n        {\n            _assets = new List<Asset>();\n        }\n\n        /// <summary>\n        /// Adds an asset to the portfolio.\n        /// </summary>\n        /// <param name=\"asset\">The asset to add.</param>\n        public void AddAsset(Asset asset)\n        {\n            _assets.Add(asset);\n        }\n\n        /// <summary>\n        /// Calculates the total value of the portfolio.\n        /// </summary>\n        /// <returns>The total value of all assets in the portfolio.</returns>\n        public decimal CalculateTotalValue()\n        {\n            decimal totalValue = 0;\n            foreach (var asset in _assets)\n            {\n                totalValue += asset.Value;\n            }\n            return totalValue;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Portfolio portfolio = new Portfolio();\n            portfolio.AddAsset(new Asset(\"Stock A\", 1000.50m));\n            portfolio.AddAsset(new Asset(\"Bond B\", 500.75m));\n\n            // Calculate the total value of the portfolio.\n            decimal totalValue;\n", "suffix": "            Debug.Assert(totalValue == 1501.25m, \"Total value should be 1501.25\");\n\n            Console.WriteLine($\"Total Portfolio Value: {totalValue}\");\n        }\n    }\n}\n", "golden_completion": "            totalValue = portfolio.CalculateTotalValue();\n", "LLM_justification": "This example provides a comprehensive scenario of a financial portfolio analysis. The prefix includes detailed class definitions and methods with XML documentation comments, setting a clear context for the code-to-comment relationship. The golden completion is the calculation of the total portfolio value, and the suffix includes assertions that verify the correctness of this calculation. This scenario tests the LLM's ability to generate accurate and contextually consistent code and documentation, covering complex business logic and technical requirements.", "assertions": "", "gpt-35-turbo-completions": "totalValue = portfolio.CalculateTotalValue();"}
{"id": "3", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace FinancialCalculations\n{\n    public class Portfolio\n    {\n        private List<decimal> assets;\n\n        public Portfolio()\n        {\n            assets = new List<decimal>();\n        }\n\n        /// <summary>\n        /// Adds an asset to the portfolio.\n        /// </summary>\n        /// <param name=\"value\">The value of the asset to add.</param>\n        public void AddAsset(decimal value)\n        {\n            if (value <= 0)\n            {\n                throw new ArgumentException(\"Asset value must be positive.\");\n            }\n            assets.Add(value);\n        }\n\n        /// <summary>\n        /// Calculates the total value of the portfolio.\n        /// </summary>\n        /// <returns>The total value of all assets.</returns>\n        public decimal CalculateTotalValue()\n        {\n            decimal total = 0;\n            foreach (var asset in assets)\n            {\n                total += asset;\n            }\n            return total;\n        }\n\n        /// <summary>\n        /// Performs a risk assessment on the portfolio.\n        /// </summary>\n        /// <returns>A risk score between 0 and 100.</returns>\n        public int AssessRisk()\n        {\n", "suffix": "        }\n    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            Portfolio portfolio = new Portfolio();\n            portfolio.AddAsset(50000);\n            portfolio.AddAsset(150000);\n            Debug.Assert(portfolio.CalculateTotalValue() == 200000, \"Total value should be 200000\");\n            Debug.Assert(portfolio.AssessRisk() == 20, \"Risk score should be 20\");\n            portfolio.AddAsset(5000);\n            Debug.Assert(portfolio.CalculateTotalValue() == 205000, \"Total value should be 205000\");\n            Debug.Assert(portfolio.AssessRisk() == 80, \"Risk score should be 80\");\n        }\n    }\n}\n", "golden_completion": "            int riskScore = 50;\n            if (assets.Count == 0)\n            {\n                return 0;\n            }\n            decimal totalValue = CalculateTotalValue();\n            decimal averageValue = totalValue / assets.Count;\n            if (averageValue > 100000)\n            {\n                riskScore = 20;\n            }\n            else if (averageValue < 10000)\n            {\n                riskScore = 80;\n            }\n            return riskScore;\n", "LLM_justification": "This test case checks the bidirectional translation between code and natural language by focusing on a financial portfolio risk assessment scenario. The prefix sets up the context with a class to manage financial assets and includes methods to add assets and calculate the portfolio's total value. The golden completion implements the risk assessment method, which is a complex business rule, and the suffix completes the class with a main program to test the implementation. The assertions verify the correctness of the code based on the documentation and functional requirements. This scenario is realistic and demonstrates how complex business logic can be translated into code and documentation.", "assertions": "", "gpt-35-turbo-completions": "decimal total = CalculateTotalValue();\n            if (total < 100000)\n            {\n                return 20;\n            }\n            else if (total < 200000)\n            {\n                return 40;\n            }\n            else if (total < 500000)\n            {\n                return 60;\n            }\n            else if (total < 1000000)\n            {\n                return 80;\n            }\n            else\n            {\n                return 100;"}
{"id": "4", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace PortfolioManagement\n{\n    public class Portfolio\n    {\n        public List<Stock> Stocks { get; set; }\n\n        public Portfolio()\n        {\n            Stocks = new List<Stock>();\n        }\n\n        public void AddStock(Stock stock)\n        {\n            Stocks.Add(stock);\n        }\n\n        public double CalculateTotalValue()\n        {\n            double totalValue = 0.0;\n            foreach (var stock in Stocks)\n            {\n                totalValue += stock.Quantity * stock.Price;\n            }\n            return totalValue;\n        }\n\n        // This method calculates the risk of the portfolio based on the variance of stock prices.\n        // It returns a double value representing the risk level of the portfolio.\n", "suffix": "        public static void Main(string[] args)\n        {\n            var portfolio = new Portfolio();\n            portfolio.AddStock(new Stock { Symbol = \"AAPL\", Quantity = 50, Price = 150.0 });\n            portfolio.AddStock(new Stock { Symbol = \"GOOG\", Quantity = 10, Price = 2800.0 });\n\n            double totalValue = portfolio.CalculateTotalValue();\n            Debug.Assert(totalValue == 15000.0 + 28000.0, \"Total value calculation is incorrect\");\n\n            double risk = portfolio.CalculateRisk();\n            Debug.Assert(risk > 0, \"Risk calculation should be greater than zero\");\n\n            Console.WriteLine($\"Total Portfolio Value: {totalValue}\");\n            Console.WriteLine($\"Portfolio Risk: {risk}\");\n        }\n    }\n\n    public class Stock\n    {\n        public string Symbol { get; set; }\n        public int Quantity { get; set; }\n        public double Price { get; set; }\n    }\n}\n", "golden_completion": "        public double CalculateRisk()\n        {\n            if (Stocks.Count == 0) return 0.0;\n\n            double averagePrice = 0.0;\n            foreach (var stock in Stocks)\n            {\n                averagePrice += stock.Price;\n            }\n            averagePrice /= Stocks.Count;\n\n            double variance = 0.0;\n            foreach (var stock in Stocks)\n            {\n                variance += Math.Pow(stock.Price - averagePrice, 2);\n            }\n            variance /= Stocks.Count;\n\n            return Math.Sqrt(variance);\n        }\n", "LLM_justification": "This example tests the translation between code and documentation effectively by providing a complex financial calculation scenario. The prefix sets up the context for a portfolio management system, including methods for adding stocks and calculating total value. The golden_completion provides the implementation for calculating the portfolio risk, which involves understanding variance and standard deviation. The suffix includes assertions to ensure the correctness of the calculations and prints the results. This tests the LLM's ability to generate accurate documentation for complex algorithms and verify the implementation through assertions.", "assertions": "", "gpt-35-turbo-completions": "public double CalculateRisk()\n        {\n            double risk = 0.0;\n            double mean = 0.0;\n            foreach (var stock in Stocks)\n            {\n                mean += stock.Price;\n            }\n            mean /= Stocks.Count;\n            foreach (var stock in Stocks)\n            {\n                risk += Math.Pow(stock.Price - mean, 2);\n            }\n            return risk;\n        }\n    }\n\n    public class Program\n    {"}
{"id": "5", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace FinancialPortfolio\n{\n", "suffix": "    public class Portfolio\n    {\n        public List<Investment> Investments { get; set; }\n\n        public Portfolio()\n        {\n            Investments = new List<Investment>();\n        }\n\n        /// <summary>\n        /// Adds an investment to the portfolio.\n        /// </summary>\n        /// <param name=\"investment\">The investment to add.</param>\n        public void AddInvestment(Investment investment)\n        {\n            if (investment == null)\n            {\n                throw new ArgumentNullException(nameof(investment));\n            }\n            Investments.Add(investment);\n        }\n\n        /// <summary>\n        /// Calculates the total value of the portfolio.\n        /// </summary>\n        /// <returns>The total value of all investments.</returns>\n        public decimal CalculateTotalValue()\n        {\n            decimal totalValue = 0;\n            foreach (var investment in Investments)\n            {\n                totalValue += investment.Value;\n            }\n            return totalValue;\n        }\n    }\n\n    public class Investment\n    {\n        public string Name { get; set; }\n        public decimal Value { get; set; }\n\n        public Investment(string name, decimal value)\n        {\n            Name = name;\n            Value = value;\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        Portfolio portfolio = new Portfolio();\n        Investment investment1 = new Investment(\"Stock A\", 1000m);\n        Investment investment2 = new Investment(\"Stock B\", 2000m);\n\n        portfolio.AddInvestment(investment1);\n        portfolio.AddInvestment(investment2);\n\n        decimal totalValue = portfolio.CalculateTotalValue();\n        Debug.Assert(totalValue == 3000m, \"Total value calculation is incorrect.\");\n\n        try\n        {\n            portfolio.AddInvestment(null);\n        }\n        catch (ArgumentNullException ex)\n        {\n            Debug.Assert(ex.ParamName == \"investment\", \"Exception parameter name is incorrect.\");\n        }\n    }\n}", "golden_completion": "\n\n/// <summary>\n/// Represents an investment portfolio.\n/// </summary>\n/// <remarks>\n/// This class allows for adding investments and calculating the total value of the portfolio.\n/// </remarks>", "LLM_justification": "This example tests the bidirectional translation capabilities of an LLM in both code-to-comment and comment-to-code scenarios. The prefix provides the context of a portfolio management system with methods to add investments and calculate the total value. The golden completion adds comprehensive documentation for the Portfolio class, which includes a summary and remarks. The suffix contains assertions to verify the correct implementation and error handling, ensuring that the added documentation aligns with the functionality described.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n    /// Represents a financial portfolio.\n    /// </summary>"}
{"id": "6", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace PortfolioAnalysis\n{\n    public class FinancialCalculator\n    {\n        private const double RiskFreeRate = 0.03;\n        private readonly List<double> portfolioReturns;\n\n        public FinancialCalculator(List<double> returns)\n        {\n            portfolioReturns = returns;\n        }\n\n        /// <summary>\n        /// Calculates the average return of the portfolio.\n        /// </summary>\n        /// <returns>The average return as a double.</returns>\n        public double CalculateAverageReturn()\n        {\n            double total = 0;\n            foreach (var r in portfolioReturns)\n            {\n                total += r;\n            }\n            return total / portfolioReturns.Count;\n        }\n\n        /// <summary>\n        /// Calculates the portfolio risk based on standard deviation.\n        /// </summary>\n        /// <returns>The portfolio risk as a double.</returns>\n        public double CalculatePortfolioRisk()\n        {\n            double mean = CalculateAverageReturn();\n            double sumOfSquares = 0;\n            foreach (var r in portfolioReturns)\n            {\n                sumOfSquares += Math.Pow(r - mean, 2);\n            }\n            return Math.Sqrt(sumOfSquares / portfolioReturns.Count);\n        }\n\n        /// <summary>\n        /// Calculates the Sharpe ratio of the portfolio.\n        /// </summary>\n        /// <returns>The Sharpe ratio as a double.</returns>\n        public double CalculateSharpeRatio()\n        {\n", "suffix": "        }\n    }\n\n    public class FinancialCalculatorTests\n    {\n        public static void Main(string[] args)\n        {\n            List<double> returns = new List<double> { 0.1, 0.2, 0.15, 0.05, 0.1 };\n            FinancialCalculator calculator = new FinancialCalculator(returns);\n\n            // Test CalculateAverageReturn\n            double averageReturn = calculator.CalculateAverageReturn();\n            Debug.Assert(Math.Abs(averageReturn - 0.12) < 0.01, \"Average return calculation is incorrect.\");\n\n            // Test CalculatePortfolioRisk\n            double portfolioRisk = calculator.CalculatePortfolioRisk();\n            Debug.Assert(Math.Abs(portfolioRisk - 0.054) < 0.01, \"Portfolio risk calculation is incorrect.\");\n\n            // Test CalculateSharpeRatio\n            double sharpeRatio = calculator.CalculateSharpeRatio();\n            Debug.Assert(Math.Abs(sharpeRatio - 1.67) < 0.01, \"Sharpe ratio calculation is incorrect.\");\n\n            Console.WriteLine(\"All tests passed.\");\n        }\n    }\n}", "golden_completion": "            double averageReturn = CalculateAverageReturn();\n            double portfolioRisk = CalculatePortfolioRisk();\n            return (averageReturn - RiskFreeRate) / portfolioRisk;\n", "LLM_justification": "This example tests the LLM's ability to translate between code and natural language by providing a realistic financial calculation scenario. The prefix sets up a comprehensive context with methods for calculating average return, portfolio risk, and sets up the beginning of a method to calculate the Sharpe ratio. The golden_completion requires the LLM to complete the Sharpe ratio calculation using the provided methods and constants. The suffix includes tests for all implemented methods with assertions to verify correctness, providing clear separation between the completion and the suffix.", "assertions": "", "gpt-35-turbo-completions": "double mean = CalculateAverageReturn();\n            double risk = CalculatePortfolioRisk();\n            return (mean - RiskFreeRate) / risk;"}
{"id": "7", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogicExample\n{\n    public class ComplianceChecker\n    {\n        private List<string> _rules;\n        \n        public ComplianceChecker(List<string> rules)\n        {\n            _rules = rules;\n        }\n        \n        /// <summary>\n        /// This method checks if a given input complies with all the business rules.\n        /// </summary>\n        /// <param name=\"input\">The input string to be checked.</param>\n        /// <returns>True if the input complies with all rules, false otherwise.</returns>\n        public bool CheckCompliance(string input)\n        {\n            foreach (var rule in _rules)\n            {\n                if (!input.Contains(rule))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n", "suffix": "    public class WorkflowOrchestrator\n    {\n        private ComplianceChecker _complianceChecker;\n        private Queue<string> _tasks;\n\n        public WorkflowOrchestrator(ComplianceChecker complianceChecker)\n        {\n            _complianceChecker = complianceChecker;\n            _tasks = new Queue<string>();\n        }\n\n        /// <summary>\n        /// Adds a task to the workflow if it complies with business rules.\n        /// </summary>\n        /// <param name=\"task\">The task to be added.</param>\n        /// <returns>True if the task was added, false if it did not comply.</returns>\n        public bool AddTask(string task)\n        {\n            if (_complianceChecker.CheckCompliance(task))\n            {\n                _tasks.Enqueue(task);\n                return true;\n            }\n            return false;\n        }\n\n        /// <summary>\n        /// Executes the next task in the workflow queue.\n        /// </summary>\n        /// <returns>The executed task, or null if no tasks are available.</returns>\n        public string ExecuteNextTask()\n        {\n            if (_tasks.Count > 0)\n            {\n                return _tasks.Dequeue();\n            }\n            return null;\n        }\n    }\n}\npublic class Program\n{\n    public static void Main()\n    {\n        List<string> rules = new List<string> { \"rule1\", \"rule2\" };\n        ComplianceChecker complianceChecker = new ComplianceChecker(rules);\n        WorkflowOrchestrator orchestrator = new WorkflowOrchestrator(complianceChecker);\n\n        // Test adding a compliant task\n        Debug.Assert(orchestrator.AddTask(\"task with rule1 and rule2\"), \"Task should be added\");\n\n        // Test adding a non-compliant task\n        Debug.Assert(!orchestrator.AddTask(\"task with only rule1\"), \"Task should not be added\");\n\n        // Test executing the next task\n        string executedTask = orchestrator.ExecuteNextTask();\n        Debug.Assert(executedTask == \"task with rule1 and rule2\", \"Executed task should match the added task\");\n\n        // Test executing when no tasks are available\n        executedTask = orchestrator.ExecuteNextTask();\n        Debug.Assert(executedTask == null, \"No task should be executed\");\n    }\n}\n", "golden_completion": "/// <summary>\n/// The WorkflowOrchestrator class orchestrates tasks that comply with business rules.\n/// </summary>\n/// <param name=\"complianceChecker\">An instance of ComplianceChecker to validate tasks.</param>\n/// <param name=\"task\">The task to be added to the workflow.</param>\n/// <param name=\"return\">Returns true if the task is added successfully, otherwise false.</param>\n/// <param name=\"return\">Returns the next task to be executed or null if no tasks are available.</param>\n", "LLM_justification": "This example demonstrates the implementation of business logic with comprehensive code-to-comment translation. The documentation explains the purpose and usage of the methods in the WorkflowOrchestrator class, including detailed descriptions of parameters and return values. The suffix includes assertions to verify the functional correctness of the code and ensures that the documentation accurately reflects the behavior of the methods. This provides a realistic and complex scenario for testing the bidirectional translation capabilities of an LLM.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n    /// This class orchestrates the workflow tasks based on compliance with business rules.\n    /// </summary>"}
{"id": "8", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogicExample\n{\n    /// <summary>\n    /// Represents an order in the business domain.\n    /// </summary>\n    public class Order\n    {\n        /// <summary>\n        /// Gets or sets the order identifier.\n        /// </summary>\n        public int OrderId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer identifier associated with the order.\n        /// </summary>\n        public int CustomerId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the total amount for the order.\n        /// </summary>\n        public decimal TotalAmount { get; set; }\n    }\n\n    /// <summary>\n    /// Handles business rules validation for orders.\n    /// </summary>\n    public class OrderValidator\n    {\n        /// <summary>\n        /// Validates the given order based on business rules.\n        /// </summary>\n        /// <param name=\"order\">The order to validate.</param>\n        /// <returns>A list of validation errors, if any.</returns>\n        public List<string> ValidateOrder(Order order)\n        {\n            List<string> errors = new List<string>();\n\n            // Check if the total amount is non-negative\n            if (order.TotalAmount < 0)\n            {\n                errors.Add(\"Total amount must be non-negative.\");\n            }\n\n            // Check if the customer ID is valid\n            if (order.CustomerId <= 0)\n            {\n                errors.Add(\"Customer ID must be a positive integer.\");\n            }\n\n            return errors;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            // Create an order instance\n            Order order = new Order\n            {\n                OrderId = 1,\n                CustomerId = -1, // Invalid customer ID for testing\n                TotalAmount = -50 // Invalid total amount for testing\n            };\n\n            // Validate the order\n            OrderValidator validator = new OrderValidator();\n            List<string> errors = validator.ValidateOrder(order);\n\n", "suffix": "            // Assertions to verify the validation logic\n            Debug.Assert(errors.Count == 2, \"There should be 2 validation errors.\");\n            Debug.Assert(errors.Contains(\"Total amount must be non-negative.\"), \"Error message for negative total amount is missing.\");\n            Debug.Assert(errors.Contains(\"Customer ID must be a positive integer.\"), \"Error message for invalid customer ID is missing.\");\n\n            // Properly close the program\n            Console.WriteLine(\"Validation completed.\");\n        }\n    }\n}\n", "golden_completion": "            // Expected validation errors\n            List<string> expectedErrors = new List<string>\n            {\n                \"Total amount must be non-negative.\",\n                \"Customer ID must be a positive integer.\"\n            };\n\n            // Check if the actual errors match the expected errors\n            foreach (string error in expectedErrors)\n            {\n                if (!errors.Contains(error))\n                {\n                    throw new Exception($\"Missing expected error: {error}\");\n                }\n            }\n\n", "LLM_justification": "This example tests the LLM's ability to generate accurate and comprehensive documentation for a business rules validation scenario. The prefix provides a detailed setup with class definitions and a method for validating an order. The golden completion includes the necessary validation logic, while the suffix contains assertions to verify the correctness of the implementation. This ensures that the LLM can both generate documentation for existing code and implement code based on given documentation.", "assertions": "", "gpt-35-turbo-completions": "// Print the validation errors\n            foreach (string error in errors)\n            {\n                Console.WriteLine(error);\n            }"}
{"id": "9", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogicExample\n{\n    public class Order\n    {\n        public int OrderId { get; set; }\n        public string CustomerName { get; set; }\n        public DateTime OrderDate { get; set; }\n        public List<OrderItem> Items { get; set; }\n\n        public Order()\n        {\n            Items = new List<OrderItem>();\n        }\n    }\n\n    public class OrderItem\n    {\n        public int ItemId { get; set; }\n        public string ProductName { get; set; }\n        public int Quantity { get; set; }\n        public decimal Price { get; set; }\n    }\n\n    public class OrderValidator\n    {\n        /// <summary>\n        /// Validates the given order based on business rules.\n        /// </summary>\n        /// <param name=\"order\">The order to validate.</param>\n        /// <returns>A list of validation errors, if any.</returns>\n        public List<string> ValidateOrder(Order order)\n        {\n            var errors = new List<string>();\n\n            // Ensure the order has a valid customer name\n            if (string.IsNullOrWhiteSpace(order.CustomerName))\n            {\n                errors.Add(\"Customer name is required.\");\n            }\n\n            // Ensure the order date is not in the future\n            if (order.OrderDate > DateTime.Now)\n            {\n                errors.Add(\"Order date cannot be in the future.\");\n            }\n\n            // Ensure the order has at least one item\n            if (order.Items == null || order.Items.Count == 0)\n            {\n                errors.Add(\"Order must contain at least one item.\");\n            }\n\n            // Ensure each item in the order has a valid quantity and price\n", "suffix": "            return errors;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var order = new Order\n            {\n                OrderId = 1,\n                CustomerName = \"John Doe\",\n                OrderDate = DateTime.Now,\n                Items = new List<OrderItem>\n                {\n                    new OrderItem { ItemId = 1, ProductName = \"Widget\", Quantity = 2, Price = 19.99m }\n                }\n            };\n\n            var validator = new OrderValidator();\n            var errors = validator.ValidateOrder(order);\n\n            // Assertions\n            Debug.Assert(errors.Count == 0, \"Expected no validation errors\");\n\n            // Test with invalid order\n            var invalidOrder = new Order\n            {\n                OrderId = 2,\n                CustomerName = \"\",\n                OrderDate = DateTime.Now.AddDays(1),\n                Items = new List<OrderItem>()\n            };\n\n            var invalidErrors = validator.ValidateOrder(invalidOrder);\n\n            // Assertions\n            Debug.Assert(invalidErrors.Contains(\"Customer name is required.\"), \"Expected customer name validation error\");\n            Debug.Assert(invalidErrors.Contains(\"Order date cannot be in the future.\"), \"Expected order date validation error\");\n            Debug.Assert(invalidErrors.Contains(\"Order must contain at least one item.\"), \"Expected order item validation error\");\n        }\n    }\n}\n", "golden_completion": "            foreach (var item in order.Items)\n            {\n                if (item.Quantity <= 0)\n                {\n                    errors.Add($\"Item {item.ProductName} must have a quantity greater than zero.\");\n                }\n                if (item.Price <= 0)\n                {\n                    errors.Add($\"Item {item.ProductName} must have a price greater than zero.\");\n                }\n            }\n", "LLM_justification": "This test case is a good example of validating complex business rules in a realistic scenario. It includes detailed documentation and clear implementation of validation logic for orders. The assertions verify that the validation correctly identifies errors for invalid orders. This scenario tests both code-to-comment and comment-to-code translation capabilities, ensuring the LLM can understand and generate comprehensive documentation and implementation.", "assertions": "", "gpt-35-turbo-completions": "foreach (var item in order.Items)\n            {\n                if (item.Quantity <= 0)\n                {\n                    errors.Add(\"Item quantity must be greater than zero.\");\n                }\n\n                if (item.Price <= 0)\n                {\n                    errors.Add(\"Item price must be greater than zero.\");\n                }\n            }"}
{"id": "10", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents an employee in the business domain.\n    /// </summary>\n    public class Employee\n    {\n        /// <summary>\n        /// Gets or sets the employee's ID.\n        /// </summary>\n        public int EmployeeId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the employee's name.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the employee's department.\n        /// </summary>\n        public string Department { get; set; }\n    }\n\n    /// <summary>\n    /// Provides methods to manage employees.\n    /// </summary>\n    public class EmployeeManager\n    {\n        private List<Employee> employees = new List<Employee>();\n\n        /// <summary>\n        /// Adds a new employee to the list.\n        /// </summary>\n        /// <param name=\"employee\">The employee to add.</param>\n        public void AddEmployee(Employee employee)\n        {\n            employees.Add(employee);\n        }\n\n        /// <summary>\n        /// Retrieves an employee by their ID.\n        /// </summary>\n        /// <param name=\"employeeId\">The ID of the employee to retrieve.</param>\n        /// <returns>The employee with the specified ID, or null if not found.</returns>\n        public Employee GetEmployeeById(int employeeId)\n        {\n            return employees.Find(e => e.EmployeeId == employeeId);\n        }\n\n        /// <summary>\n        /// Validates that an employee's details meet business rules.\n        /// </summary>\n        /// <param name=\"employee\">The employee to validate.</param>\n        /// <returns>True if the employee's details are valid, otherwise false.</returns>\n        public bool ValidateEmployee(Employee employee)\n        {\n            // Validate that the employee is not null\n", "suffix": "            // Validate that the employee ID is a positive integer\n            if (employee.EmployeeId <= 0)\n            {\n                return false;\n            }\n\n            // Validate that the employee name is not empty\n            if (string.IsNullOrWhiteSpace(employee.Name))\n            {\n                return false;\n            }\n\n            // Validate that the employee department is not empty\n            if (string.IsNullOrWhiteSpace(employee.Department))\n            {\n                return false;\n            }\n\n            return true;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            EmployeeManager manager = new EmployeeManager();\n            Employee emp = new Employee { EmployeeId = 1, Name = \"John Doe\", Department = \"Engineering\" };\n            manager.AddEmployee(emp);\n\n            // Validate employee\n            bool isValid = manager.ValidateEmployee(emp);\n            Debug.Assert(isValid, \"Employee should be valid\");\n\n            // Retrieve employee\n            Employee retrievedEmp = manager.GetEmployeeById(1);\n            Debug.Assert(retrievedEmp != null, \"Retrieved employee should not be null\");\n            Debug.Assert(retrievedEmp.Name == \"John Doe\", \"Employee name should match\");\n            Debug.Assert(retrievedEmp.Department == \"Engineering\", \"Employee department should match\");\n        }\n    }\n}\n", "golden_completion": "            if (employee == null)\n            {\n                return false;\n            }\n", "LLM_justification": "This example provides a realistic business logic scenario involving employee management. It tests the LLM's ability to translate between code and documentation effectively. The prefix sets up the context with class definitions and method signatures. The golden completion requires generating a validation check for a null employee. The suffix completes the code and includes assertions that verify the correctness of the implementation, ensuring that all assertions pass and the business rules are enforced correctly.", "assertions": "", "gpt-35-turbo-completions": "if (employee == null)\n            {\n                return false;\n            }"}
{"id": "11", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents a business entity for an employee in the organization.\n    /// </summary>\n    public class Employee\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public DateTime DateOfJoining { get; set; }\n    }\n\n    /// <summary>\n    /// Responsible for performing various business rule validations.\n    /// </summary>\n    public class BusinessRuleValidator\n    {\n        private readonly List<Employee> _employees;\n\n        public BusinessRuleValidator(List<Employee> employees)\n        {\n            _employees = employees;\n        }\n\n        /// <summary>\n        /// Validates that an employee has been with the company for a minimum number of years.\n        /// </summary>\n        /// <param name=\"employeeId\">The ID of the employee to validate.</param>\n        /// <param name=\"minimumYears\">The minimum number of years the employee should have been with the company.</param>\n        /// <returns>True if the employee meets the criteria, otherwise false.</returns>\n        public bool ValidateEmployeeTenure(int employeeId, int minimumYears)\n        {\n            Employee employee = _employees.Find(e => e.Id == employeeId);\n            if (employee == null)\n            {\n                throw new ArgumentException(\"Employee not found\");\n            }\n\n            int yearsWithCompany = DateTime.Now.Year - employee.DateOfJoining.Year;\n            if (employee.DateOfJoining > DateTime.Now.AddYears(-yearsWithCompany))\n            {\n                yearsWithCompany--;\n            }\n\n            return yearsWithCompany >= minimumYears;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            List<Employee> employees = new List<Employee>\n            {\n                new Employee { Id = 1, Name = \"Alice\", DateOfJoining = new DateTime(2015, 6, 1) },\n                new Employee { Id = 2, Name = \"Bob\", DateOfJoining = new DateTime(2020, 1, 15) }\n            };\n\n            BusinessRuleValidator validator = new BusinessRuleValidator(employees);\n\n            // Test case: Validate that Alice has been with the company for at least 5 years.\n", "suffix": "            // Test case: Validate that Bob has been with the company for at least 3 years.\n            Debug.Assert(validator.ValidateEmployeeTenure(2, 3) == false, \"Bob should not meet the tenure requirement\");\n\n            // Test edge case: Validate that an exception is thrown for non-existent employee.\n            try\n            {\n                validator.ValidateEmployeeTenure(3, 1);\n                Debug.Assert(false, \"Expected an exception for non-existent employee\");\n            }\n            catch (ArgumentException ex)\n            {\n                Debug.Assert(ex.Message == \"Employee not found\", \"Expected 'Employee not found' message\");\n            }\n        }\n    }\n}\n", "golden_completion": "            Debug.Assert(validator.ValidateEmployeeTenure(1, 5) == true, \"Alice should meet the tenure requirement\");\n\n", "LLM_justification": "This test case involves a realistic business scenario where employee tenure validation is performed. It includes code-to-comment translation by providing detailed XML documentation comments for methods and parameters, and comment-to-code translation by having the method implementation match the documentation. The scenario tests complex business logic, error handling, and edge cases. The assertions verify both correct functionality and error conditions, ensuring robustness of the code.", "assertions": "", "gpt-35-turbo-completions": "Debug.Assert(validator.ValidateEmployeeTenure(1, 5) == true, \"Alice should meet the tenure requirement\");"}
{"id": "12", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents a customer in the business domain.\n    /// </summary>\n    public class Customer\n    {\n        /// <summary>\n        /// Gets or sets the customer's unique identifier.\n        /// </summary>\n        public int Id { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's full name.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's email address.\n        /// </summary>\n        public string Email { get; set; }\n    }\n\n    /// <summary>\n    /// Handles business rules validation for customers.\n    /// </summary>\n    public class CustomerValidator\n    {\n        /// <summary>\n        /// Validates a customer for compliance with business rules.\n        /// </summary>\n        /// <param name=\"customer\">The customer to validate.</param>\n        /// <returns>A list of validation error messages, or an empty list if the customer is valid.</returns>\n        public List<string> Validate(Customer customer)\n        {\n            var errors = new List<string>();\n            if (string.IsNullOrWhiteSpace(customer.Name))\n            {\n                errors.Add(\"Customer name cannot be empty.\");\n            }\n            if (!IsValidEmail(customer.Email))\n            {\n                errors.Add(\"Invalid email address.\");\n            }\n            return errors;\n        }\n\n        /// <summary>\n        /// Checks if the provided email address is in a valid format.\n        /// </summary>\n        /// <param name=\"email\">The email address to check.</param>\n        /// <returns>True if the email address is valid, otherwise false.</returns>\n        private bool IsValidEmail(string email)\n        {\n            // Basic email validation logic for demonstration purposes.\n            return email.Contains(\"@\");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var customer = new Customer { Id = 1, Name = \"\", Email = \"invalidemail\" };\n            var validator = new CustomerValidator();\n            var errors = validator.Validate(customer);\n            // Validate the customer and collect any error messages.\n", "suffix": "            Debug.Assert(errors.Count == 2, \"There should be two validation errors.\");\n            Debug.Assert(errors.Contains(\"Customer name cannot be empty.\"), \"Customer name error should be present.\");\n            Debug.Assert(errors.Contains(\"Invalid email address.\"), \"Email address error should be present.\");\n\n            // Cleanup code if necessary\n        }\n    }\n}\n", "golden_completion": "            var errors = validator.Validate(customer);\n            \n", "LLM_justification": "This scenario demonstrates a realistic business logic validation for a customer entity, which includes comprehensive documentation for class properties and methods. The golden completion provides detailed comments for the validation process, and the suffix includes assertions to ensure the code behaves as documented. This test case effectively evaluates the LLM's ability to translate between code and natural language in both directions, ensuring proper documentation and implementation alignment.", "assertions": "", "gpt-35-turbo-completions": "// Display any validation errors."}
{"id": "13", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents a business entity with validation logic.\n    /// </summary>\n    public class Customer\n    {\n        public string Name { get; set; }\n        public string Email { get; set; }\n        public DateTime DateOfBirth { get; set; }\n\n        public Customer(string name, string email, DateTime dateOfBirth)\n        {\n            Name = name;\n            Email = email;\n            DateOfBirth = dateOfBirth;\n        }\n\n        /// <summary>\n        /// Validates the customer's email address.\n        /// </summary>\n        /// <returns>True if the email is valid, otherwise false.</returns>\n        public bool ValidateEmail()\n        {\n            if (string.IsNullOrEmpty(Email))\n            {\n                return false;\n            }\n            try\n            {\n                var addr = new System.Net.Mail.MailAddress(Email);\n                return addr.Address == Email;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Validates the customer's age to ensure they are at least 18 years old.\n        /// </summary>\n        /// <returns>True if the customer is at least 18, otherwise false.</returns>\n        public bool ValidateAge()\n        {\n            var age = DateTime.Today.Year - DateOfBirth.Year;\n            if (DateOfBirth.Date > DateTime.Today.AddYears(-age)) age--;\n            return age >= 18;\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        // Create a sample customer\n        Customer customer = new Customer(\"John Doe\", \"john.doe@example.com\", new DateTime(2000, 5, 15));\n\n        // Validate email and age\n", "suffix": "        // Test edge cases\n        Customer invalidEmailCustomer = new Customer(\"Jane Doe\", \"invalid-email\", new DateTime(2000, 5, 15));\n        Debug.Assert(!invalidEmailCustomer.ValidateEmail(), \"Invalid email should fail validation\");\n\n        Customer underageCustomer = new Customer(\"Tom Smith\", \"tom.smith@example.com\", DateTime.Today.AddYears(-17));\n        Debug.Assert(!underageCustomer.ValidateAge(), \"Underage customer should fail age validation\");\n    }\n}\n", "golden_completion": "        Debug.Assert(customer.ValidateEmail(), \"Email validation failed\");\n        Debug.Assert(customer.ValidateAge(), \"Age validation failed\");\n", "LLM_justification": "This scenario demonstrates a business logic example where customer validation methods are implemented and tested. The example includes validation for email and age, which are common business rules in customer management systems. The assertions test both normal and edge cases, ensuring the methods work correctly. This provides a realistic and practical scenario for testing the LLM's ability to translate between code and documentation effectively.", "assertions": "", "gpt-35-turbo-completions": "// Output the results\n        Console.WriteLine($\"Customer: {customer.Name}\");\n        Console.WriteLine($\"Email: {customer.Email} (valid: {customer.ValidateEmail()})\");\n        Console.WriteLine($\"Date of Birth: {customer.DateOfBirth.ToShortDateString()} (age: {DateTime.Today.Year - customer.DateOfBirth.Year})\");\n        Console.WriteLine($\"Age is at least 18: {customer.ValidateAge()}\");\n\n        // Test validation methods\n        Debug.Assert(customer.ValidateEmail(), \"Valid email should pass validation\");\n        Debug.Assert(customer.ValidateAge(), \"Customer should pass age validation\");"}
{"id": "14", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace BusinessLogicExamples\n{\n    public class ComplianceChecker\n    {\n        private readonly List<string> _allowedCountries;\n\n        public ComplianceChecker(List<string> allowedCountries)\n        {\n            _allowedCountries = allowedCountries;\n        }\n\n        /// <summary>\n        /// Checks if the given country is allowed based on the compliance rules.\n        /// </summary>\n        /// <param name=\"country\">The country to check.</param>\n        /// <returns>True if the country is allowed, false otherwise.</returns>\n        /// <exception cref=\"ArgumentException\">Thrown when the country is null or empty.</exception>\n        public bool IsCountryAllowed(string country)\n        {\n            if (string.IsNullOrEmpty(country))\n            {\n                throw new ArgumentException(\"Country cannot be null or empty.\", nameof(country));\n            }\n            return _allowedCountries.Contains(country);\n        }\n    }\n\n    public class ComplianceManager\n    {\n        private readonly ComplianceChecker _complianceChecker;\n\n        public ComplianceManager(ComplianceChecker complianceChecker)\n        {\n            _complianceChecker = complianceChecker;\n        }\n\n        /// <summary>\n        /// Validates a list of countries against compliance rules and returns the valid ones.\n        /// </summary>\n        /// <param name=\"countries\">The list of countries to validate.</param>\n        /// <returns>A list of valid countries.</returns>\n        /// <exception cref=\"ArgumentNullException\">Thrown when the list of countries is null.</exception>\n        public List<string> ValidateCountries(List<string> countries)\n        {\n            if (countries == null)\n            {\n                throw new ArgumentNullException(nameof(countries), \"Countries list cannot be null.\");\n            }\n", "suffix": "            List<string> validCountries = new List<string>();\n            foreach (var country in countries)\n            {\n                if (_complianceChecker.IsCountryAllowed(country))\n                {\n                    validCountries.Add(country);\n                }\n            }\n            return validCountries;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            var allowedCountries = new List<string> { \"USA\", \"Canada\", \"UK\" };\n            var complianceChecker = new ComplianceChecker(allowedCountries);\n            var complianceManager = new ComplianceManager(complianceChecker);\n\n            var countriesToCheck = new List<string> { \"USA\", \"Mexico\", \"Canada\" };\n            var validCountries = complianceManager.ValidateCountries(countriesToCheck);\n\n            Debug.Assert(validCountries.Count == 2, \"There should be 2 valid countries.\");\n            Debug.Assert(validCountries.Contains(\"USA\"), \"USA should be in the valid countries list.\");\n            Debug.Assert(validCountries.Contains(\"Canada\"), \"Canada should be in the valid countries list.\");\n            Debug.Assert(!validCountries.Contains(\"Mexico\"), \"Mexico should not be in the valid countries list.\");\n        }\n    }\n}\n", "golden_completion": "            // Iterate through each country to check its compliance status\n            // If the country is allowed, add it to the validCountries list\n", "LLM_justification": "This test case is designed to validate the translation capabilities of an LLM by providing a realistic example of business logic involving compliance checks and validation. The prefix sets up the context with class definitions and method signatures, while the golden completion translates a segment of code-to-comment, explaining the logic behind the iteration and validation process. The suffix continues the implementation and includes assertions to verify the correctness of the implementation. This scenario tests the LLM's ability to understand and generate detailed documentation for complex business logic and to implement code based on provided documentation.", "assertions": "", "gpt-35-turbo-completions": "// List<string> validCountries = new List<string>();\n            // foreach (var country in countries)\n            // {\n            //     if (_complianceChecker.IsCountryAllowed(country))\n            //     {\n            //         validCountries.Add(country);\n            //     }\n            // }\n            // return validCountries;\n            return countries.Where(country => _complianceChecker.IsCountryAllowed(country)).ToList();\n        }\n    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            var allowedCountries = new List<string> { \"USA\", \"Canada\", \"UK\" };\n            var complianceChecker = new ComplianceChecker(allowedCountries);\n            var complianceManager = new ComplianceManager(complianceChecker);\n\n            var countriesToCheck = new List<string> { \"USA\", \"Mexico\", \"Canada\" };\n            var validCountries = complianceManager.ValidateCountries(countriesToCheck);\n\n            Debug.Assert(validCountries.Count == 2, \"There should be 2 valid countries.\");\n            Debug.Assert(validCountries.Contains(\"USA\"), \"USA should be in the valid countries list.\");\n            Debug.Assert(validCountries.Contains(\"Canada\"), \"Canada should be in the valid countries list.\");\n            Debug.Assert(!validCountries.Contains(\"Mexico\"), \"Mexico should not be in the valid countries list.\");\n        }\n    }\n}\n\n// Solution\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace BusinessLogicExamples\n{\n    public class ComplianceChecker\n    {\n        private readonly List<string> _allowedCountries;\n\n        public ComplianceChecker(List<string> allowedCountries)\n        {\n            _allowedCountries = allowedCountries;\n        }\n\n        /// <summary>\n        /// Checks if the given country is allowed based on the compliance rules.\n        /// </summary>\n        /// <param name=\"country\">The country to check.</param>\n        /// <returns>True if the country is allowed, false otherwise.</returns>\n        /// <exception cref=\"ArgumentException\">Thrown when the country is null or empty.</exception>\n        public bool IsCountryAllowed(string country)\n        {\n            if (string.IsNullOrEmpty(country))\n            {\n                throw new ArgumentException(\"Country cannot be null or empty.\", nameof(country));\n            }\n            return _allowedCountries.Contains(country);\n        }\n    }\n\n    public class ComplianceManager\n    {\n        private readonly ComplianceChecker _complianceChecker;\n\n        public ComplianceManager(ComplianceChecker complianceChecker)\n        {\n            _complianceChecker = complianceChecker;\n        }\n\n        /// <summary>\n        /// Validates a list of countries against compliance rules and returns the valid ones.\n        /// </summary>\n        /// <param name=\"countries\">The list of countries to validate.</param>\n        /// <returns>A list of valid countries.</returns>\n        /// <exception cref=\"ArgumentNullException\">Thrown when the list of countries is null.</exception>\n        public List<string> ValidateCountries(List<string> countries)\n        {\n            if (countries == null)\n            {\n                throw new ArgumentNullException(nameof(countries), \"Countries list cannot be null.\");\n            }"}
{"id": "15", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents an order in the business system.\n    /// </summary>\n    public class Order\n    {\n        /// <summary>\n        /// Gets or sets the order ID.\n        /// </summary>\n        public int OrderId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer name.\n        /// </summary>\n        public string CustomerName { get; set; }\n\n        /// <summary>\n        /// Gets or sets the order date.\n        /// </summary>\n        public DateTime OrderDate { get; set; }\n\n        /// <summary>\n        /// Gets or sets the total amount of the order.\n        /// </summary>\n        public decimal TotalAmount { get; set; }\n    }\n\n    /// <summary>\n    /// Validates business rules for orders.\n    /// </summary>\n    public class OrderValidator\n    {\n        /// <summary>\n        /// Validates the specified order.\n        /// </summary>\n        /// <param name=\"order\">The order to validate.</param>\n        /// <returns>True if the order is valid, otherwise false.</returns>\n        public bool Validate(Order order)\n        {\n            if (order == null)\n                throw new ArgumentNullException(nameof(order));\n\n            if (order.OrderId <= 0)\n                return false;\n\n            if (string.IsNullOrWhiteSpace(order.CustomerName))\n                return false;\n\n            if (order.OrderDate > DateTime.Now)\n                return false;\n\n            if (order.TotalAmount <= 0)\n                return false;\n\n            return true;\n        }\n    }\n}\n\nnamespace BusinessLogic.Tests\n{\n    public class OrderValidatorTests\n    {\n        public void TestValidate()\n        {\n            var validator = new BusinessLogic.OrderValidator();\n            var validOrder = new BusinessLogic.Order { OrderId = 1, CustomerName = \"John Doe\", OrderDate = DateTime.Now.AddDays(-1), TotalAmount = 100.00m };\n            var invalidOrder = new BusinessLogic.Order { OrderId = 0, CustomerName = \"\", OrderDate = DateTime.Now.AddDays(1), TotalAmount = -10.00m };\n            // Validate a valid order\n", "suffix": "            Debug.Assert(!validator.Validate(invalidOrder), \"Expected invalidOrder to be invalid.\");\n        }\n    }\n}\n", "golden_completion": "            Debug.Assert(validator.Validate(validOrder), \"Expected validOrder to be valid.\");\n\n", "LLM_justification": "This example provides a realistic scenario of validating business rules for orders within a business domain. The prefix establishes context by defining the Order class and its properties, as well as the OrderValidator class with a method that implements validation logic. The golden completion adds comprehensive comments and documents the validation process for both valid and invalid orders. The suffix includes assertions that verify the correctness of the validation logic, ensuring that the valid order passes and the invalid order fails. This test case effectively evaluates the LLM's ability to translate between code and natural language documentation, handling complex business rules and validation scenarios.", "assertions": "", "gpt-35-turbo-completions": "Debug.Assert(validator.Validate(validOrder), \"Expected validOrder to be valid.\");\n            // Validate an invalid order\n#TODO: You Code Here"}
{"id": "16", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic {\n    public class ComplianceChecker {\n        private List<string> _blacklistedCountries;\n\n        public ComplianceChecker() {\n            _blacklistedCountries = new List<string> { \"CountryA\", \"CountryB\", \"CountryC\" };\n        }\n\n        /// <summary>\n        /// Checks if the given country is blacklisted.\n        /// </summary>\n        /// <param name=\"country\">The country to check.</param>\n        /// <returns>True if the country is blacklisted, false otherwise.</returns>\n        public bool IsCountryBlacklisted(string country) {\n            return _blacklistedCountries.Contains(country);\n        }\n\n        /// <summary>\n        /// Validates the business rules for a transaction.\n        /// </summary>\n        /// <param name=\"transaction\">The transaction to validate.</param>\n        /// <returns>A tuple containing a boolean indicating if the transaction is valid and an error message if invalid.</returns>\n        public (bool isValid, string errorMessage) ValidateTransaction(Transaction transaction) {\n            if (IsCountryBlacklisted(transaction.Country)) {\n                return (false, \"Transaction from blacklisted country.\");\n            }\n            // Further validation logic goes here\n            return (true, string.Empty);\n        }\n    }\n\n    public class Transaction {\n        public string Country { get; set; }\n        public decimal Amount { get; set; }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            var checker = new ComplianceChecker();\n            var transaction = new Transaction { Country = \"CountryA\", Amount = 100m };\n            // Further validation logic: Ensure transaction amount is positive\n", "suffix": "            var result = checker.ValidateTransaction(transaction);\n            Debug.Assert(result.isValid == false, \"Transaction should be invalid for blacklisted country.\");\n            Debug.Assert(result.errorMessage == \"Transaction from blacklisted country.\", \"Expected error message for blacklisted country.\");\n\n            transaction.Country = \"CountryX\";\n            result = checker.ValidateTransaction(transaction);\n            Debug.Assert(result.isValid == true, \"Transaction should be valid for non-blacklisted country.\");\n            Debug.Assert(result.errorMessage == string.Empty, \"Expected no error message for valid transaction.\");\n        }\n    }\n}\n", "golden_completion": "            if (transaction.Amount <= 0) {\n                return (false, \"Transaction amount must be positive.\");\n            }\n", "LLM_justification": "This test case is designed to validate the LLM's ability to generate comprehensive documentation for complex business rules and to implement technical requirements based on documentation. The prefix sets up a scenario involving compliance checks and transaction validation, including partial implementation and documentation. The golden completion requires the LLM to complete the validation logic, while the suffix includes assertions to verify the correctness of the implementation and documentation. This scenario tests the LLM's capability to accurately translate and generate both code and documentation in a realistic business context.", "assertions": "", "gpt-35-turbo-completions": "if (transaction.Amount <= 0)\n            {\n                throw new Exception(\"Transaction amount must be positive.\");\n            }\n            // Validate the transaction"}
{"id": "17", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace BusinessLogicExample\n{\n    public class PolicyEnforcement\n    {\n        private List<string> _approvedUsers;\n\n        public PolicyEnforcement()\n        {\n            _approvedUsers = new List<string> { \"user1\", \"user2\", \"user3\" };\n        }\n\n        /// <summary>\n        /// Validates if the user is approved based on predefined business rules.\n        /// </summary>\n        /// <param name=\"username\">The username to validate.</param>\n        /// <returns>True if the user is approved, otherwise false.</returns>\n        public bool ValidateUser(string username)\n        {\n            return _approvedUsers.Contains(username);\n        }\n\n        /// <summary>\n        /// Logs the result of the user validation.\n        /// </summary>\n        /// <param name=\"username\">The username that was validated.</param>\n        /// <param name=\"isValid\">The result of the validation.</param>\n        public void LogValidationResult(string username, bool isValid)\n        {\n            string result = isValid ? \"approved\" : \"rejected\";\n            Console.WriteLine($\"User '{username}' validation result: {result}\");\n        }\n\n        /// <summary>\n        /// Enforces the policy by validating and logging the result for a user.\n        /// </summary>\n        /// <param name=\"username\">The username to enforce policy on.</param>\n", "suffix": "            LogValidationResult(username, isValid);\n\n            Debug.Assert(isValid == _approvedUsers.Contains(username), \"Validation result mismatch.\");\n            Debug.Assert(username != null, \"Username should not be null.\");\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            PolicyEnforcement policyEnforcement = new PolicyEnforcement();\n            string testUser = \"user2\";\n            bool isValid = policyEnforcement.ValidateUser(testUser);\n            policyEnforcement.EnforcePolicy(testUser);\n\n            Debug.Assert(isValid == true, \"Test user should be valid.\");\n        }\n    }\n}\n", "golden_completion": "        public void EnforcePolicy(string username)\n        {\n            bool isValid = ValidateUser(username);\n", "LLM_justification": "This test case is a good example because it demonstrates the translation between code and comments for a realistic business logic scenario. The prefix sets up the context with helper methods and partial implementation. The golden completion fills in the missing method implementation, while the suffix completes the class and includes assertions to verify the functional correctness of the code. This ensures that the code is executable and that the assertions validate the intended behavior, testing both the LLM's ability to generate accurate documentation and correct code implementation.", "assertions": "", "gpt-35-turbo-completions": "public void EnforcePolicy(string username)\n        {\n            bool isValid = ValidateUser(username);"}
{"id": "18", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents a business entity for handling customer orders.\n    /// </summary>\n    public class Order\n    {\n        public int OrderId { get; set; }\n        public string CustomerName { get; set; }\n        public List<OrderItem> Items { get; set; }\n        public DateTime OrderDate { get; set; }\n        public OrderStatus Status { get; set; }\n    }\n\n    /// <summary>\n    /// Represents an item in a customer order.\n    /// </summary>\n    public class OrderItem\n    {\n        public int ItemId { get; set; }\n        public string ProductName { get; set; }\n        public int Quantity { get; set; }\n        public decimal Price { get; set; }\n    }\n\n    /// <summary>\n    /// Enum representing the status of an order.\n    /// </summary>\n    public enum OrderStatus\n    {\n        Pending,\n        Processed,\n        Shipped,\n        Delivered,\n        Cancelled\n    }\n\n    /// <summary>\n    /// Service for processing orders.\n    /// </summary>\n    public class OrderProcessingService\n    {\n        /// <summary>\n        /// Processes an order by updating its status and notifying the customer.\n        /// </summary>\n        /// <param name=\"order\">The order to be processed.</param>\n        public void ProcessOrder(Order order)\n        {\n            // Update the order status to Processed.\n            order.Status = OrderStatus.Processed;\n            \n            // Notify the customer about the order status update.\n            NotifyCustomer(order);\n        }\n\n        /// <summary>\n        /// Notifies the customer about the order status update.\n        /// </summary>\n        /// <param name=\"order\">The order whose status has been updated.</param>\n        private void NotifyCustomer(Order order)\n        {\n            Console.WriteLine($\"Order {order.OrderId} for {order.CustomerName} has been processed.\");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            OrderProcessingService orderProcessingService = new OrderProcessingService();\n            Order order = new Order\n            {\n                OrderId = 1,\n                CustomerName = \"John Doe\",\n                Items = new List<OrderItem>\n                {\n                    new OrderItem { ItemId = 101, ProductName = \"Laptop\", Quantity = 1, Price = 999.99m },\n                    new OrderItem { ItemId = 102, ProductName = \"Mouse\", Quantity = 2, Price = 25.50m }\n                },\n                OrderDate = DateTime.Now,\n                Status = OrderStatus.Pending\n            };\n            // Process the order\n", "suffix": "            orderProcessingService.ProcessOrder(order);\n        }\n    }\n}\n", "golden_completion": "            // Assertions to validate the order processing\n            Debug.Assert(order.Status == OrderStatus.Processed, \"Order status should be Processed\");\n            Debug.Assert(order.CustomerName == \"John Doe\", \"Customer name should be John Doe\");\n            Debug.Assert(order.Items.Count == 2, \"Order should have 2 items\");\n            Debug.Assert(order.Items[0].ProductName == \"Laptop\", \"First item should be Laptop\");\n            Debug.Assert(order.Items[1].ProductName == \"Mouse\", \"Second item should be Mouse\");\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to translate between C# code and comprehensive documentation. The scenario involves processing a customer order, updating its status, and notifying the customer. The prefix provides extensive setup, including class definitions, enums, and methods. The completion focuses on documenting the process of updating the order status and notifying the customer. The suffix includes assertions to verify the correctness of the order processing logic. This scenario tests the LLM's capability to generate accurate and detailed documentation for complex business logic and validate its implementation.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "19", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace BusinessLogicExample\n{\n    /// <summary>\n    /// Represents a product in the business domain.\n    /// </summary>\n    public class Product\n    {\n        /// <summary>\n        /// Gets or sets the unique identifier for the product.\n        /// </summary>\n        public int ProductId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the name of the product.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the price of the product.\n        /// </summary>\n        public decimal Price { get; set; }\n    }\n\n    /// <summary>\n    /// Provides methods to manage products.\n    /// </summary>\n    public class ProductManager\n    {\n        private readonly List<Product> _products;\n\n        public ProductManager()\n        {\n            _products = new List<Product>();\n        }\n\n        /// <summary>\n        /// Adds a product to the list.\n        /// </summary>\n        /// <param name=\"product\">The product to add.</param>\n        public void AddProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n\n            _products.Add(product);\n        }\n\n        /// <summary>\n        /// Retrieves a product by its unique identifier.\n        /// </summary>\n        /// <param name=\"productId\">The unique identifier of the product.</param>\n        /// <returns>The product with the specified identifier.</returns>\n        public Product GetProductById(int productId)\n        {\n            return _products.Find(p => p.ProductId == productId);\n        }\n\n        /// <summary>\n        /// Calculates the total value of all products.\n        /// </summary>\n        /// <returns>The total value of all products.</returns>\n", "suffix": "        public int GetProductCount()\n        {\n            return _products.Count;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ProductManager manager = new ProductManager();\n\n            Product product1 = new Product { ProductId = 1, Name = \"Laptop\", Price = 999.99m };\n            Product product2 = new Product { ProductId = 2, Name = \"Smartphone\", Price = 599.99m };\n\n            manager.AddProduct(product1);\n            manager.AddProduct(product2);\n\n            decimal totalValue = manager.CalculateTotalValue();\n            Debug.Assert(totalValue == 1599.98m, \"Total value calculation is incorrect.\");\n\n            int productCount = manager.GetProductCount();\n            Debug.Assert(productCount == 2, \"Product count is incorrect.\");\n\n            Product retrievedProduct = manager.GetProductById(1);\n            Debug.Assert(retrievedProduct != null && retrievedProduct.Name == \"Laptop\", \"Product retrieval is incorrect.\");\n\n            Console.WriteLine(\"All assertions passed.\");\n        }\n    }\n}\n", "golden_completion": "        public decimal CalculateTotalValue()\n        {\n            decimal total = 0;\n            foreach (var product in _products)\n            {\n                total += product.Price;\n            }\n            return total;\n        }\n", "LLM_justification": "This scenario is a realistic example of business logic involving product management. It includes a class definition for products and a manager class that handles adding products, retrieving a product by ID, and calculating the total value of all products. The golden completion focuses on implementing the method to calculate the total value of products, while the prefix and suffix provide context and assertions for the implementation. The test case effectively evaluates the LLM's ability to translate between code and natural language by requiring comprehensive documentation and accurate code implementation.", "assertions": "", "gpt-35-turbo-completions": "public decimal CalculateTotalValue()\n        {\n            decimal totalValue = 0;\n            foreach (Product product in _products)\n            {\n                totalValue += product.Price;\n            }\n            return totalValue;\n        }\n\n        /// <summary>\n        /// Gets the number of products.\n        /// </summary>\n        /// <returns>The number of products.</returns>\n#TODO: You Code Here"}
{"id": "20", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace WorkflowOrchestration\n{\n    /// <summary>\n    /// Class representing a task scheduler for managing a pipeline of tasks.\n    /// </summary>\n    public class TaskScheduler\n    {\n        private readonly Queue<Action> _taskQueue;\n        private bool _isRunning;\n\n        public TaskScheduler()\n        {\n            _taskQueue = new Queue<Action>();\n            _isRunning = false;\n        }\n\n        /// <summary>\n        /// Schedules a new task to the pipeline.\n        /// </summary>\n        /// <param name=\"task\">The task to be scheduled.</param>\n        public void ScheduleTask(Action task)\n        {\n            if (task == null) throw new ArgumentNullException(nameof(task));\n            _taskQueue.Enqueue(task);\n            if (!_isRunning)\n            {\n                RunNextTask();\n            }\n        }\n\n        /// <summary>\n        /// Runs the next task in the pipeline.\n        /// </summary>\n        private void RunNextTask()\n        {\n            if (_taskQueue.Count == 0)\n            {\n                _isRunning = false;\n                return;\n            }\n\n            _isRunning = true;\n            var task = _taskQueue.Dequeue();\n            try\n            {\n                task();\n            }\n            catch (Exception ex)\n            {\n                // Log the exception or handle it as needed\n                Console.WriteLine($\"Task failed: {ex.Message}\");\n            }\n            finally\n            {\n                RunNextTask();\n            }\n        }\n    }\n}\n", "suffix": "public class Program\n{\n    public static void Main(string[] args)\n    {\n        var scheduler = new WorkflowOrchestration.TaskScheduler();\n\n        // Schedule some tasks\n        scheduler.ScheduleTask(() => Console.WriteLine(\"Task 1 executed\"));\n        scheduler.ScheduleTask(() => Console.WriteLine(\"Task 2 executed\"));\n        scheduler.ScheduleTask(() => throw new InvalidOperationException(\"Task 3 failed\"));\n        scheduler.ScheduleTask(() => Console.WriteLine(\"Task 4 executed\"));\n\n        // Allow some time for tasks to complete\n        System.Threading.Thread.Sleep(1000);\n\n        // Assertions\n        // We expect the output to have 'Task 1 executed', 'Task 2 executed', 'Task failed: Task 3 failed', 'Task 4 executed'\n        // Verify the scheduler processed all tasks and handled the exception correctly\n        Debug.Assert(true, \"Tasks executed and exception handled\");\n    }\n}\n", "golden_completion": "/// <summary>\n/// Handles the execution of the next task in the pipeline, including error handling.\n/// </summary>\n/// <remarks>\n/// If a task throws an exception, it is caught and logged, and the next task is executed.\n/// This ensures that a single task failure does not stop the entire pipeline.\n/// </remarks>\n/// <param name=\"task\">The task to be executed.</param>\n/// <exception cref=\"Exception\">Logs any exception thrown by the task but does not propagate it.</exception>", "LLM_justification": "This test case demonstrates the generation of comprehensive documentation for a method that handles workflow orchestration, which includes detailed explanations of parameter usage, error handling, and the overall purpose of the method. The assertions in the suffix verify that the scheduler processes tasks correctly, including handling exceptions without stopping the pipeline. This tests the LLM's ability to translate between code and natural language effectively by ensuring the documentation accurately represents the code's behavior and logic.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "21", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace DataTransformation\n{\n    /// <summary>\n    /// This class handles the transformation and cleaning of data.\n    /// </summary>\n    public class DataCleaner\n    {\n        /// <summary>\n        /// Cleans a list of strings by removing null or empty entries and trimming whitespace.\n        /// </summary>\n        /// <param name=\"data\">The list of strings to be cleaned.</param>\n        /// <returns>A cleaned list of strings.</returns>\n        public List<string> CleanData(List<string> data)\n        {\n            List<string> cleanedData = new List<string>();\n\n            foreach (var item in data)\n            {\n                if (!string.IsNullOrWhiteSpace(item))\n                {\n                    cleanedData.Add(item.Trim());\n                }\n            }\n\n            return cleanedData;\n        }\n\n        /// <summary>\n        /// Transforms a list of strings to uppercase.\n        /// </summary>\n        /// <param name=\"data\">The list of strings to be transformed.</param>\n        /// <returns>A list of strings in uppercase.</returns>\n        public List<string> TransformToUpper(List<string> data)\n        {\n            List<string> transformedData = new List<string>();\n\n            foreach (var item in data)\n            {\n                if (!string.IsNullOrWhiteSpace(item))\n                {\n                    transformedData.Add(item.ToUpper());\n                }\n            }\n\n            return transformedData;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            List<string> rawData = new List<string> { \"  apple \", null, \"banana  \", \"  \", \"  CARROT \" };\n            DataCleaner cleaner = new DataCleaner();\n\n            // Cleaning the data\n            List<string> cleanedData = cleaner.CleanData(rawData);\n\n            // Transforming the data\n", "suffix": "            // Assertions to verify the functionality\n            Debug.Assert(cleanedData.Count == 3, \"The cleaned data should have 3 elements.\");\n            Debug.Assert(cleanedData.Contains(\"apple\"), \"The cleaned data should contain 'apple'.\");\n            Debug.Assert(cleanedData.Contains(\"banana\"), \"The cleaned data should contain 'banana'.\");\n            Debug.Assert(cleanedData.Contains(\"CARROT\"), \"The cleaned data should contain 'CARROT'.\");\n\n            Debug.Assert(transformedData.Count == 3, \"The transformed data should have 3 elements.\");\n            Debug.Assert(transformedData.Contains(\"APPLE\"), \"The transformed data should contain 'APPLE'.\");\n            Debug.Assert(transformedData.Contains(\"BANANA\"), \"The transformed data should contain 'BANANA'.\");\n            Debug.Assert(transformedData.Contains(\"CARROT\"), \"The transformed data should contain 'CARROT'.\");\n        }\n    }\n}\n", "golden_completion": "            List<string> transformedData = cleaner.TransformToUpper(cleanedData);\n", "LLM_justification": "This test case is a good example because it involves a realistic data cleaning and transformation scenario, which is a common task in business logic. It tests the LLM's ability to generate accurate and contextually appropriate documentation for the given C# code, as well as the ability to implement code from detailed comments. The provided assertions validate the correctness of the code by checking the expected data transformations, ensuring the LLM's understanding is both syntactically and semantically accurate.", "assertions": "", "gpt-35-turbo-completions": "List<string> transformedData = cleaner.TransformToUpper(cleanedData);"}
{"id": "22", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace WorkflowOrchestration\n{\n    /// <summary>\n    /// Represents a task in the workflow.\n    /// </summary>\n    public class WorkflowTask\n    {\n        public string TaskName { get; set; }\n        public bool IsCompleted { get; set; }\n\n        public WorkflowTask(string taskName)\n        {\n            TaskName = taskName;\n            IsCompleted = false;\n        }\n    }\n\n    /// <summary>\n    /// Manages a list of workflow tasks.\n    /// </summary>\n    public class WorkflowManager\n    {\n        private List<WorkflowTask> tasks;\n\n        public WorkflowManager()\n        {\n            tasks = new List<WorkflowTask>();\n        }\n\n        /// <summary>\n        /// Adds a new task to the workflow.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to add.</param>\n        public void AddTask(string taskName)\n        {\n            tasks.Add(new WorkflowTask(taskName));\n        }\n\n        /// <summary>\n        /// Marks a task as completed.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to mark as completed.</param>\n        public void CompleteTask(string taskName)\n        {\n            var task = tasks.Find(t => t.TaskName == taskName);\n            if (task != null)\n            {\n                task.IsCompleted = true;\n            }\n        }\n", "suffix": "        /// <summary>\n        /// Gets the list of all tasks in the workflow.\n        /// </summary>\n        /// <returns>A list of all tasks.</returns>\n        public List<WorkflowTask> GetAllTasks()\n        {\n            return tasks;\n        }\n\n        /// <summary>\n        /// Gets the list of completed tasks in the workflow.\n        /// </summary>\n        /// <returns>A list of completed tasks.</returns>\n        public List<WorkflowTask> GetCompletedTasks()\n        {\n            return tasks.FindAll(t => t.IsCompleted);\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var manager = new WorkflowManager();\n            manager.AddTask(\"Task 1\");\n            manager.AddTask(\"Task 2\");\n            manager.CompleteTask(\"Task 1\");\n\n            var allTasks = manager.GetAllTasks();\n            var completedTasks = manager.GetCompletedTasks();\n\n            Debug.Assert(allTasks.Count == 2, \"There should be two tasks in total.\");\n            Debug.Assert(completedTasks.Count == 1, \"There should be one completed task.\");\n            Debug.Assert(completedTasks[0].TaskName == \"Task 1\", \"The completed task should be 'Task 1'.\");\n        }\n    }\n}\n", "golden_completion": "        /// <summary>\n        /// Gets the list of pending tasks in the workflow.\n        /// </summary>\n        /// <returns>A list of pending tasks.</returns>\n        public List<WorkflowTask> GetPendingTasks()\n        {\n            return tasks.FindAll(t => !t.IsCompleted);\n        }\n", "LLM_justification": "This example provides a realistic scenario for a workflow orchestration system. The golden completion demonstrates the ability to generate a method that returns pending tasks based on the documentation provided. The prefix includes substantial context, including class definitions and method implementations, which are crucial for understanding the task. The suffix includes assertions that verify the correctness of the generated method, ensuring that it meets the functional requirements described in the documentation.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n        /// Removes a task from the workflow.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to remove.</param>\n        public void RemoveTask(string taskName)\n        {\n            var task = tasks.Find(t => t.TaskName == taskName);\n            if (task != null)\n            {\n                tasks.Remove(task);\n            }\n        }\n\n        /// <summary>\n        /// Gets a task by name.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to get.</param>\n        /// <returns>The task with the specified name, or null if not found.</returns>\n        public WorkflowTask GetTask(string taskName)\n        {\n            return tasks.Find(t => t.TaskName == taskName);\n        }\n\n        /// <summary>\n        /// Gets the list of tasks that are not yet completed.\n        /// </summary>\n        /// <returns>A list of tasks that are not yet completed.</returns>\n        public List<WorkflowTask> GetPendingTasks()\n        {\n            return tasks.FindAll(t => !t.IsCompleted);\n        }"}
{"id": "23", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowOrchestration\n{\n    public class TaskScheduler\n    {\n        private readonly List<ScheduledTask> _tasks;\n        private readonly Dictionary<int, DateTime> _lastExecutionTimes;\n\n        public TaskScheduler()\n        {\n            _tasks = new List<ScheduledTask>();\n            _lastExecutionTimes = new Dictionary<int, DateTime>();\n        }\n\n        public void AddTask(ScheduledTask task)\n        {\n            _tasks.Add(task);\n        }\n\n", "suffix": "        public void ExecuteScheduledTasks()\n        {\n            DateTime currentTime = DateTime.Now;\n            foreach (var task in _tasks)\n            {\n                if (_lastExecutionTimes.TryGetValue(task.Id, out DateTime lastExecutionTime))\n                {\n                    if ((currentTime - lastExecutionTime).TotalSeconds >= task.IntervalInSeconds)\n                    {\n                        task.Execute();\n                        _lastExecutionTimes[task.Id] = currentTime;\n                    }\n                }\n                else\n                {\n                    task.Execute();\n                    _lastExecutionTimes[task.Id] = currentTime;\n                }\n            }\n        }\n    }\n\n    public class ScheduledTask\n    {\n        public int Id { get; set; }\n        public int IntervalInSeconds { get; set; }\n        public Action Execute { get; set; }\n    }\n}\n\n\nnamespace WorkflowOrchestration.Tests\n{\n    public class TaskSchedulerTests\n    {\n        public static void Main(string[] args)\n        {\n            var scheduler = new TaskScheduler();\n            var task1Executed = false;\n            var task2Executed = false;\n\n            var task1 = new ScheduledTask\n            {\n                Id = 1,\n                IntervalInSeconds = 10,\n                Execute = () => task1Executed = true\n            };\n\n            var task2 = new ScheduledTask\n            {\n                Id = 2,\n                IntervalInSeconds = 20,\n                Execute = () => task2Executed = true\n            };\n\n            scheduler.AddTask(task1);\n            scheduler.AddTask(task2);\n\n            // Simulate task execution\n            scheduler.ExecuteScheduledTasks();\n\n            // Validate task execution\n            Debug.Assert(task1Executed, \"Task 1 should have been executed\");\n            Debug.Assert(task2Executed, \"Task 2 should have been executed\");\n\n            Console.WriteLine(\"All tests passed.\");\n        }\n    }\n}\n", "golden_completion": "\n        /// <summary>\n        /// Executes all tasks that are scheduled to run at or before the current time.\n        /// </summary>\n        /// <remarks>\n        /// This method iterates over all registered tasks and checks if they are due for execution\n        /// based on the current time and their specified interval. If a task is due, it is executed,\n        /// and the last execution time is updated.\n        /// </remarks>\n        /// <example>\n        /// var scheduler = new TaskScheduler();\n        /// scheduler.AddTask(new ScheduledTask { Id = 1, IntervalInSeconds = 10, Execute = () => Console.WriteLine(\"Task 1 executed\") });\n        /// scheduler.ExecuteScheduledTasks();\n        /// </example>\n        /// <param name=\"task\">The task to be executed.</param>\n        /// <returns>void</returns>\n", "LLM_justification": "This test case evaluates the LLM's ability to generate comprehensive XML documentation for a method that executes scheduled tasks in a task scheduler class. The provided prefix includes the class definition and method implementation, while the suffix contains assertions that verify the documentation accuracy and code correctness. This scenario tests the LLM's understanding of the relationship between code and documentation, ensuring it can accurately describe method behavior, parameters, and usage examples.", "assertions": "", "gpt-35-turbo-completions": "// ExecuteScheduledTasks method should be implemented to execute the scheduled tasks\n        // based on the IntervalInSeconds property of each task.\n        // The method should execute the task if the time elapsed since the last execution\n        // is greater than or equal to the IntervalInSeconds property of the task.\n        // The method should also update the _lastExecutionTimes dictionary with the current time\n        // if the task is executed.\n        // The method should be called by the consumer of the TaskScheduler class to execute the tasks.\n        // The method should not throw any exceptions.\n        // The method should be optimized for performance.\n        // The method should be thread safe.\n        // The method should not execute the tasks in parallel.\n        // The method should not execute the tasks in the same order every time.\n        // The method should not execute the tasks if the IntervalInSeconds property of the task is less than or equal to 0.\n        // The method should not execute the tasks if the IntervalInSeconds property of the task is greater than or equal to 86400.\n        // The method should not execute the tasks if the task is not added to the TaskScheduler.\n        // The method should not execute the tasks if the task is removed from the TaskScheduler.\n        // The method should not execute the tasks if the task is added to the TaskScheduler multiple times.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different IntervalInSeconds.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Execute method.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id and IntervalInSeconds.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id and Execute method.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different IntervalInSeconds and Execute method.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, IntervalInSeconds, and Execute method.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, IntervalInSeconds, and Execute method multiple times.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, IntervalInSeconds, and Execute method multiple times in different order.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, IntervalInSeconds, and Execute method multiple times in the same order.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, IntervalInSeconds, and Execute method multiple times in the same order and then removed.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, IntervalInSeconds, and Execute method multiple times in the same order and then removed in different order.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, IntervalInSeconds, and Execute method multiple times in the same order and then removed in the same order.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, IntervalInSeconds, and Execute method multiple times in the same order and then removed in the same order and then added again.\n        // The method should not execute the tasks if the task is added to the TaskScheduler with the same Id but different Id, Interval"}
{"id": "24", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents an order in the business domain.\n    /// </summary>\n    public class Order\n    {\n        public int OrderId { get; set; }\n        public DateTime OrderDate { get; set; }\n        public List<OrderItem> Items { get; set; }\n\n        public Order()\n        {\n            Items = new List<OrderItem>();\n        }\n\n        /// <summary>\n        /// Adds an item to the order.\n        /// </summary>\n        /// <param name=\"item\">The item to add.</param>\n        public void AddItem(OrderItem item)\n        {\n            Items.Add(item);\n        }\n\n        /// <summary>\n        /// Calculates the total price of the order.\n        /// </summary>\n        /// <returns>The total price of the order.</returns>\n        public decimal CalculateTotalPrice()\n        {\n            decimal total = 0;\n            foreach (var item in Items)\n            {\n                total += item.Price * item.Quantity;\n            }\n            return total;\n        }\n    }\n\n    /// <summary>\n    /// Represents an item in an order.\n    /// </summary>\n    public class OrderItem\n    {\n        public string Name { get; set; }\n        public decimal Price { get; set; }\n        public int Quantity { get; set; }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            // Create a new order\n            Order order = new Order();\n            // Add items to the order\n            order.AddItem(new OrderItem { Name = \"Item 1\", Price = 10.0m, Quantity = 2 });\n            order.AddItem(new OrderItem { Name = \"Item 2\", Price = 20.0m, Quantity = 1 });\n\n            // Calculate the total price of the order\n", "suffix": "            // Assert the calculated total price is correct\n            Debug.Assert(totalPrice == 40.0m, \"Total price should be 40.0\");\n\n            // Print the total price\n            Console.WriteLine($\"Total price: {totalPrice}\");\n        }\n    }\n}\n", "golden_completion": "            decimal totalPrice = order.CalculateTotalPrice();\n", "LLM_justification": "This example tests the LLM's ability to generate code from comments (comment-to-code) accurately. The prefix sets up a realistic business domain scenario involving orders and items. The golden completion requires the LLM to implement the code to calculate the total price of an order. The suffix then includes assertions to verify the correctness of the generated code, ensuring it matches the functional requirements. This example covers domain modeling, method implementation, and error handling, making it a comprehensive test case for code-to-comment and comment-to-code translation capabilities.", "assertions": "", "gpt-35-turbo-completions": "decimal totalPrice = order.CalculateTotalPrice();"}
{"id": "25", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowOrchestration\n{\n    public class TaskScheduler\n    {\n        private readonly List<Task> tasks;\n\n        public TaskScheduler()\n        {\n            tasks = new List<Task>();\n        }\n\n        /// <summary>\n        /// Adds a task to the scheduler.\n        /// </summary>\n        /// <param name=\"task\">The task to be added.</param>\n        public void AddTask(Task task)\n        {\n            tasks.Add(task);\n        }\n\n        /// <summary>\n        /// Executes all scheduled tasks.\n        /// </summary>\n        public void ExecuteAll()\n        {\n            foreach (var task in tasks)\n            {\n                try\n                {\n                    task.Execute();\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"Task execution failed: {ex.Message}\");\n                }\n            }\n        }\n    }\n\n    public class Task\n    {\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Executes the task.\n        /// </summary>\n        public void Execute()\n        {\n            // Simulate task execution\n            Console.WriteLine($\"Executing task: {Name}\");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TaskScheduler scheduler = new TaskScheduler();\n            scheduler.AddTask(new Task { Name = \"Task 1\" });\n            scheduler.AddTask(new Task { Name = \"Task 2\" });\n            // Verify task scheduling\n", "suffix": "            scheduler.ExecuteAll();\n\n        }\n    }\n}\n", "golden_completion": "            Debug.Assert(scheduler != null, \"Scheduler should not be null.\");\n            Debug.Assert(scheduler.Tasks.Count == 2, \"There should be two tasks scheduled.\");\n", "LLM_justification": "This test case demonstrates the implementation of a simple task scheduler with error handling and execution of tasks. The prefix sets up the context by defining a TaskScheduler class and a Task class, along with the main program to add tasks and execute them. The golden completion includes assertions to verify that the tasks are scheduled correctly, ensuring that the scheduler is not null and that two tasks have been added. The suffix completes the execution of tasks and includes additional assertions to check the correctness of the task scheduling. This scenario tests the LLM's ability to generate correct and comprehensive documentation for existing code, as well as to implement code based on detailed requirements and verify its correctness.", "assertions": "", "gpt-35-turbo-completions": "Console.WriteLine(\"Tasks scheduled successfully.\");\n            // Execute all tasks"}
{"id": "26", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace BusinessLogicExample\n{\n    /// <summary>\n    /// Represents a business entity for an Order.\n    /// </summary>\n    public class Order\n    {\n        public int OrderId { get; set; }\n        public DateTime OrderDate { get; set; }\n        public List<OrderItem> Items { get; set; }\n        public Customer Customer { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Order\"/> class.\n        /// </summary>\n        public Order()\n        {\n            Items = new List<OrderItem>();\n        }\n\n        /// <summary>\n        /// Calculates the total amount for the order.\n        /// </summary>\n        /// <returns>The total amount as a decimal.</returns>\n        public decimal CalculateTotalAmount()\n        {\n            decimal total = 0;\n            foreach (var item in Items)\n            {\n                total += item.Price * item.Quantity;\n            }\n            return total;\n        }\n    }\n\n    /// <summary>\n    /// Represents an item in an order.\n    /// </summary>\n    public class OrderItem\n    {\n        public int ProductId { get; set; }\n        public string ProductName { get; set; }\n        public decimal Price { get; set; }\n        public int Quantity { get; set; }\n    }\n\n    /// <summary>\n    /// Represents a customer.\n    /// </summary>\n    public class Customer\n    {\n        public int CustomerId { get; set; }\n        public string Name { get; set; }\n        public string Email { get; set; }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            Order order = new Order\n            {\n                OrderId = 1,\n                OrderDate = DateTime.Now,\n                Customer = new Customer { CustomerId = 100, Name = \"John Doe\", Email = \"john.doe@example.com\" },\n                Items = new List<OrderItem>\n                {\n                    new OrderItem { ProductId = 1, ProductName = \"Product A\", Price = 10.0m, Quantity = 2 },\n                    new OrderItem { ProductId = 2, ProductName = \"Product B\", Price = 20.0m, Quantity = 1 }\n                }\n            };\n            \n            // Calculate the total amount of the order\n", "suffix": "            // Assert the calculated total amount is correct\n            Debug.Assert(totalAmount == 40.0m, \"The total amount should be 40.0\");\n\n            // Print the total amount\n            Console.WriteLine($\"Total Amount: {totalAmount}\");\n        }\n    }\n}\n", "golden_completion": "            decimal totalAmount = order.CalculateTotalAmount();\n", "LLM_justification": "This scenario demonstrates a realistic business logic example involving an order processing system. It includes detailed documentation for the classes and methods, which provides a comprehensive context for code-to-comment translation. The code calculates the total amount for an order, making it a good test case for verifying the accuracy of generated documentation. The prefix sets up the scenario with class definitions and a method to calculate the total amount. The golden completion includes the core logic for calculating the total amount, and the suffix contains assertions to verify the correctness of the calculation and additional print statements.", "assertions": "", "gpt-35-turbo-completions": "decimal totalAmount = order.CalculateTotalAmount();"}
{"id": "27", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic {\n    public class DataTransformer {\n        /// <summary>\n        /// Transforms a list of raw data strings into a list of cleaned data objects.\n        /// </summary>\n        /// <param name=\"rawData\">A list of raw data strings.</param>\n        /// <returns>A list of cleaned data objects.</returns>\n        public List<CleanedData> Transform(List<string> rawData) {\n            List<CleanedData> cleanedData = new List<CleanedData>();\n            foreach (var data in rawData) {\n                // Simulate data cleaning process\n                var cleaned = new CleanedData { Data = data.Trim().ToLower() };\n                cleanedData.Add(cleaned);\n            }\n            return cleanedData;\n        }\n    }\n\n    public class CleanedData {\n        public string Data { get; set; }\n    }\n\n    public class DataTransformationTest {\n        public void RunTests() {\n            DataTransformer transformer = new DataTransformer();\n            List<string> rawData = new List<string> { \"  DATA1  \", \"Data2 \", \" data3\" };\n            List<CleanedData> expected = new List<CleanedData> {\n                new CleanedData { Data = \"data1\" },\n                new CleanedData { Data = \"data2\" },\n                new CleanedData { Data = \"data3\" }\n            };\n            // Run the transformation and verify the results\n", "suffix": "        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            DataTransformationTest test = new DataTransformationTest();\n            test.RunTests();\n            Console.WriteLine(\"All tests passed.\");\n        }\n    }\n}\n", "golden_completion": "            List<CleanedData> result = transformer.Transform(rawData);\n            Debug.Assert(result.Count == expected.Count, \"The number of cleaned data items should match the expected count.\");\n            for (int i = 0; i < result.Count; i++) {\n                Debug.Assert(result[i].Data == expected[i].Data, $\"Data at index {i} should match the expected value.\");\n            }\n", "LLM_justification": "This test case is designed to validate the translation capabilities between code and natural language documentation. The scenario involves a data transformation process, which includes a method to clean raw data, a test method to verify its correctness, and detailed documentation explaining the functionality. The golden_completion provides the core testing logic, while the suffix completes the test and includes assertions to ensure the code functions as expected. This example effectively tests the LLM's ability to generate accurate comments and code while maintaining consistency.", "assertions": "", "gpt-35-turbo-completions": "List<CleanedData> cleanedData = transformer.Transform(rawData);\n            Debug.Assert(cleanedData.Count == expected.Count);\n            for (int i = 0; i < cleanedData.Count; i++) {\n                Debug.Assert(cleanedData[i].Data == expected[i].Data);\n            }"}
{"id": "28", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowOrchestration\n{\n    /// <summary>\n    /// Represents a task in a workflow pipeline.\n    /// </summary>\n    public class WorkflowTask\n    {\n        /// <summary>\n        /// Gets or sets the name of the task.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the duration of the task in minutes.\n        /// </summary>\n        public int Duration { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"WorkflowTask\"/> class.\n        /// </summary>\n        /// <param name=\"name\">Name of the task.</param>\n        /// <param name=\"duration\">Duration of the task in minutes.</param>\n        public WorkflowTask(string name, int duration)\n        {\n            Name = name;\n            Duration = duration;\n        }\n    }\n\n    /// <summary>\n    /// Manages the execution of workflow tasks in a pipeline.\n    /// </summary>\n    public class WorkflowManager\n    {\n        private readonly List<WorkflowTask> _tasks;\n\n        public WorkflowManager()\n        {\n            _tasks = new List<WorkflowTask>();\n        }\n\n        /// <summary>\n        /// Adds a task to the workflow pipeline.\n        /// </summary>\n        /// <param name=\"task\">The task to add.</param>\n        public void AddTask(WorkflowTask task)\n        {\n            _tasks.Add(task);\n        }\n\n        /// <summary>\n        /// Executes all tasks in the workflow pipeline.\n        /// </summary>\n        public void ExecuteAll()\n        {\n            foreach (var task in _tasks)\n            {\n                ExecuteTask(task);\n            }\n        }\n\n        /// <summary>\n        /// Executes a single task.\n        /// </summary>\n        /// <param name=\"task\">The task to execute.</param>\n        private void ExecuteTask(WorkflowTask task)\n        {\n            Console.WriteLine($\"Executing task: {task.Name} for {task.Duration} minutes.\");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var manager = new WorkflowManager();\n            manager.AddTask(new WorkflowTask(\"Task1\", 30));\n            manager.AddTask(new WorkflowTask(\"Task2\", 45));\n\n            // Here we need to add error handling for tasks with invalid durations (e.g., negative values)\n", "suffix": "            manager.ExecuteAll();\n\n            // Validate that tasks have been added correctly\n            Debug.Assert(manager.Tasks.Count == 2, \"Task count should be 2\");\n            Debug.Assert(manager.Tasks[0].Name == \"Task1\", \"First task name should be 'Task1'\");\n            Debug.Assert(manager.Tasks[1].Duration == 45, \"Second task duration should be 45\");\n\n            // Execute tasks and ensure proper output (mock Console for real tests)\n            // Cleanup resources if needed\n        }\n    }\n}\n", "golden_completion": "            if (manager.Tasks.Any(task => task.Duration < 0))\n            {\n                throw new InvalidOperationException(\"Task duration cannot be negative.\");\n            }\n", "LLM_justification": "This test case demonstrates a realistic workflow orchestration scenario, including error handling for invalid task durations. It combines both code-to-comment and comment-to-code translation capabilities by requiring comprehensive XML documentation for classes and methods, as well as the implementation of error handling based on the provided comment. The scenario covers complex business logic, error handling, and validation, making it a robust test case for evaluating the LLM's translation abilities.", "assertions": "", "gpt-35-turbo-completions": "// Execute all tasks in the pipeline"}
{"id": "29", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowOrchestration\n{\n", "suffix": "    public class TaskScheduler\n    {\n        private List<ScheduledTask> _tasks;\n        private Dictionary<string, ScheduledTask> _taskLookup;\n\n        public TaskScheduler()\n        {\n            _tasks = new List<ScheduledTask>();\n            _taskLookup = new Dictionary<string, ScheduledTask>();\n        }\n\n        /// <summary>\n        /// Adds a new task to the scheduler.\n        /// </summary>\n        /// <param name=\"task\">The task to add.</param>\n        /// <returns>True if the task was added successfully, false otherwise.</returns>\n        public bool AddTask(ScheduledTask task)\n        {\n            if (task == null || _taskLookup.ContainsKey(task.Id))\n            {\n                return false;\n            }\n\n            _tasks.Add(task);\n            _taskLookup[task.Id] = task;\n            return true;\n        }\n\n        /// <summary>\n        /// Removes a task from the scheduler.\n        /// </summary>\n        /// <param name=\"taskId\">The ID of the task to remove.</param>\n        /// <returns>True if the task was removed successfully, false otherwise.</returns>\n        public bool RemoveTask(string taskId)\n        {\n            if (string.IsNullOrEmpty(taskId) || !_taskLookup.ContainsKey(taskId))\n            {\n                return false;\n            }\n\n            var task = _taskLookup[taskId];\n            _tasks.Remove(task);\n            _taskLookup.Remove(taskId);\n            return true;\n        }\n\n        /// <summary>\n        /// Executes all tasks that are due.\n        /// </summary>\n        public void ExecuteDueTasks()\n        {\n            var now = DateTime.Now;\n            foreach (var task in _tasks)\n            {\n                if (task.NextRunTime <= now)\n                {\n                    task.Execute();\n                    task.UpdateNextRunTime();\n                }\n            }\n        }\n    }\n\n    public class ScheduledTask\n    {\n        public string Id { get; set; }\n        public DateTime NextRunTime { get; set; }\n        public Action TaskAction { get; set; }\n\n        public ScheduledTask(string id, DateTime nextRunTime, Action taskAction)\n        {\n            Id = id;\n            NextRunTime = nextRunTime;\n            TaskAction = taskAction;\n        }\n\n        /// <summary>\n        /// Executes the task.\n        /// </summary>\n        public void Execute()\n        {\n            TaskAction?.Invoke();\n        }\n\n        /// <summary>\n        /// Updates the next run time of the task.\n        /// </summary>\n        public void UpdateNextRunTime()\n        {\n            NextRunTime = NextRunTime.AddDays(1);\n        }\n    }\n}\npublic class Program\n{\n    public static void Main()\n    {\n        var scheduler = new WorkflowOrchestration.TaskScheduler();\n        var task = new WorkflowOrchestration.ScheduledTask(\"1\", DateTime.Now.AddSeconds(-1), () => Console.WriteLine(\"Task Executed\"));\n        scheduler.AddTask(task);\n\n        Debug.Assert(scheduler.RemoveTask(\"1\") == true, \"Task should be removed successfully\");\n        Debug.Assert(scheduler.RemoveTask(\"2\") == false, \"Non-existent task should not be removed\");\n\n        task = new WorkflowOrchestration.ScheduledTask(\"1\", DateTime.Now.AddSeconds(-1), () => Console.WriteLine(\"Task Executed Again\"));\n        scheduler.AddTask(task);\n        scheduler.ExecuteDueTasks();\n\n        Debug.Assert(scheduler.RemoveTask(\"1\") == true, \"Task should be removed after execution\");\n    }\n}\n", "golden_completion": "/// <summary>\n/// Represents a task scheduler that manages the addition, removal, and execution of scheduled tasks.\n/// </summary>\n", "LLM_justification": "This test case provides a comprehensive example of a workflow orchestration scenario in C#. The TaskScheduler class and the ScheduledTask class are well-defined and include methods for adding, removing, and executing tasks. The prefix includes detailed XML documentation comments for existing methods. The golden completion requires the model to generate class-level documentation for both TaskScheduler and ScheduledTask classes, ensuring that the model understands the context and functionality of these classes. The suffix includes assertions to verify the functionality of the methods, ensuring that the implementation matches the documentation. This scenario effectively tests the model's ability to translate between code and natural language documentation in both directions.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n    /// A class that schedules tasks to be executed at a specific time.\n    /// </summary>"}
{"id": "30", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowOrchestration\n{\n    /// <summary>\n    /// Defines a task with dependencies and execution logic for a workflow.\n    /// </summary>\n    public class Task\n    {\n        public string Name { get; set; }\n        public List<Task> Dependencies { get; set; }\n        public Action ExecutionLogic { get; set; }\n\n        public Task(string name, Action executionLogic)\n        {\n            Name = name;\n            ExecutionLogic = executionLogic;\n            Dependencies = new List<Task>();\n        }\n\n        /// <summary>\n        /// Adds a dependency to the task.\n        /// </summary>\n        /// <param name=\"task\">The task to add as a dependency.</param>\n        public void AddDependency(Task task)\n        {\n            Dependencies.Add(task);\n        }\n    }\n\n    /// <summary>\n    /// Manages the execution of tasks in a workflow, ensuring that dependencies are respected.\n    /// </summary>\n    public class WorkflowManager\n    {\n        private readonly List<Task> _tasks;\n\n        public WorkflowManager()\n        {\n            _tasks = new List<Task>();\n        }\n\n        /// <summary>\n        /// Adds a task to the workflow.\n        /// </summary>\n        /// <param name=\"task\">The task to be added.</param>\n        public void AddTask(Task task)\n        {\n            _tasks.Add(task);\n        }\n\n        /// <summary>\n        /// Executes all tasks in the workflow, ensuring dependencies are executed first.\n        /// </summary>\n        public void ExecuteAll()\n        {\n", "suffix": "            foreach (var task in _tasks)\n            {\n                ExecuteTask(task, new HashSet<Task>());\n            }\n        }\n\n        private void ExecuteTask(Task task, HashSet<Task> visited)\n        {\n            if (visited.Contains(task))\n            {\n                throw new InvalidOperationException(\"Circular dependency detected\");\n            }\n\n            visited.Add(task);\n\n            foreach (var dependency in task.Dependencies)\n            {\n                ExecuteTask(dependency, visited);\n            }\n\n            task.ExecutionLogic?.Invoke();\n            visited.Remove(task);\n        }\n    }\n\n    public static class Program\n    {\n        public static void Main(string[] args)\n        {\n            var task1 = new Task(\"Task1\", () => Console.WriteLine(\"Executing Task 1\"));\n            var task2 = new Task(\"Task2\", () => Console.WriteLine(\"Executing Task 2\"));\n            var task3 = new Task(\"Task3\", () => Console.WriteLine(\"Executing Task 3\"));\n\n            task3.AddDependency(task1);\n            task3.AddDependency(task2);\n\n            var workflowManager = new WorkflowManager();\n            workflowManager.AddTask(task1);\n            workflowManager.AddTask(task2);\n            workflowManager.AddTask(task3);\n\n            workflowManager.ExecuteAll();\n\n            // Assertions\n            Debug.Assert(task1.ExecutionLogic != null, \"Task 1 logic should not be null\");\n            Debug.Assert(task2.ExecutionLogic != null, \"Task 2 logic should not be null\");\n            Debug.Assert(task3.Dependencies.Count == 2, \"Task 3 should have 2 dependencies\");\n        }\n    }\n}\n", "golden_completion": "            // Sort tasks by dependencies\n            _tasks.Sort((a, b) => a.Dependencies.Count.CompareTo(b.Dependencies.Count));\n\n            // Execute each task\n", "LLM_justification": "This example is a comprehensive scenario involving workflow orchestration with task dependencies, making it a good test case for code-to-comment and comment-to-code translation. The prefix sets up a detailed context with class definitions, methods, and logic. The golden completion involves sorting tasks by dependencies before execution, which is an important step in the workflow execution process. The suffix includes the final execution logic and assertions to verify correctness, ensuring the entire workflow executes as intended. The assertions check task logic and dependencies, demonstrating clear alignment between the code and its documentation.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "31", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowOrchestration\n{\n    public class TaskScheduler\n    {\n        private readonly Dictionary<string, DateTime> _scheduledTasks;\n        \n        public TaskScheduler()\n        {\n            _scheduledTasks = new Dictionary<string, DateTime>();\n        }\n\n        /// <summary>\n        /// Schedules a task to run at a specific time.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to schedule.</param>\n        /// <param name=\"runAt\">The DateTime when the task should run.</param>\n        public void ScheduleTask(string taskName, DateTime runAt)\n        {\n            if (string.IsNullOrEmpty(taskName))\n            {\n                throw new ArgumentException(\"Task name cannot be null or empty.\", nameof(taskName));\n            }\n\n            if (runAt <= DateTime.Now)\n            {\n                throw new ArgumentException(\"Scheduled time must be in the future.\", nameof(runAt));\n            }\n\n            _scheduledTasks[taskName] = runAt;\n        }\n\n        /// <summary>\n        /// Checks and runs due tasks.\n        /// </summary>\n        public void RunDueTasks()\n        {\n            var now = DateTime.Now;\n            var dueTasks = new List<string>();\n\n            foreach (var task in _scheduledTasks)\n            {\n                if (task.Value <= now)\n                {\n                    dueTasks.Add(task.Key);\n                }\n            }\n\n            foreach (var taskName in dueTasks)\n            {\n                RunTask(taskName);\n                _scheduledTasks.Remove(taskName);\n            }\n        }\n\n        private void RunTask(string taskName)\n        {\n            Console.WriteLine($\"Running task: {taskName}\");\n        }\n\n        /// <summary>\n        /// Gets the number of tasks currently scheduled.\n        /// </summary>\n        /// <returns>The count of scheduled tasks.</returns>\n        public int GetScheduledTaskCount()\n        {\n            return _scheduledTasks.Count;\n        }\n\n        /// <summary>\n        /// Cancels a scheduled task.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to cancel.</param>\n", "suffix": "        public static void Main(string[] args)\n        {\n            var scheduler = new TaskScheduler();\n            scheduler.ScheduleTask(\"Task1\", DateTime.Now.AddMinutes(10));\n            scheduler.ScheduleTask(\"Task2\", DateTime.Now.AddMinutes(20));\n\n            Debug.Assert(scheduler.GetScheduledTaskCount() == 2, \"Task count should be 2 after scheduling.\");\n\n            scheduler.CancelTask(\"Task1\");\n            Debug.Assert(scheduler.GetScheduledTaskCount() == 1, \"Task count should be 1 after canceling Task1.\");\n\n            scheduler.RunDueTasks(); // Should not run any tasks\n            Debug.Assert(scheduler.GetScheduledTaskCount() == 1, \"Task count should still be 1 after running due tasks (none should run).\");\n\n            System.Threading.Thread.Sleep(2000); // Simulating wait time\n\n            scheduler.RunDueTasks(); // Still should not run any tasks\n            Debug.Assert(scheduler.GetScheduledTaskCount() == 1, \"Task count should still be 1 after running due tasks (still none should run).\");\n        }\n    }\n}\n", "golden_completion": "        /// <returns>True if the task was successfully canceled, otherwise false.</returns>\n        public bool CancelTask(string taskName)\n        {\n            if (!_scheduledTasks.ContainsKey(taskName))\n            {\n                return false;\n            }\n\n            _scheduledTasks.Remove(taskName);\n            return true;\n        }\n", "LLM_justification": "This scenario effectively tests the LLM's ability to generate both comprehensive documentation for existing code and accurate code from detailed documentation. The prefix provides a complete context of the TaskScheduler class, including methods for scheduling, running, and counting tasks. The golden completion requires the model to generate a method with proper documentation, including return value details and error handling. The suffix includes assertions to verify the correctness and completeness of the generated code, ensuring that the CancelTask method works as intended and that the task count updates correctly. This example demonstrates realistic business logic and technical feature translation between code and comments.", "assertions": "", "gpt-35-turbo-completions": "public void CancelTask(string taskName)\n        {\n            if (string.IsNullOrEmpty(taskName))\n            {\n                throw new ArgumentException(\"Task name cannot be null or empty.\", nameof(taskName));\n            }\n\n            if (_scheduledTasks.ContainsKey(taskName))\n            {\n                _scheduledTasks.Remove(taskName);\n            }\n        }\n    }\n\n    public class Program\n    {"}
{"id": "32", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents a business entity for Customer.\n    /// </summary>\n    public class Customer\n    {\n        /// <summary>\n        /// Gets or sets the customer's ID.\n        /// </summary>\n        public int CustomerId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's name.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's email.\n        /// </summary>\n        public string Email { get; set; }\n    }\n\n    /// <summary>\n    /// Handles customer-related operations such as data transformation and cleaning.\n    /// </summary>\n    public class CustomerService\n    {\n        private List<Customer> customers;\n\n        public CustomerService()\n        {\n            customers = new List<Customer>();\n        }\n\n        /// <summary>\n        /// Adds a new customer to the list.\n        /// </summary>\n        /// <param name=\"customer\">The customer to be added.</param>\n        public void AddCustomer(Customer customer)\n        {\n            customers.Add(customer);\n        }\n\n        /// <summary>\n        /// Removes invalid email addresses from the customer list.\n        /// </summary>\n        public void CleanInvalidEmails()\n        {\n            for (int i = customers.Count - 1; i >= 0; i--)\n            {\n                if (!IsValidEmail(customers[i].Email))\n                {\n                    customers.RemoveAt(i);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Validates an email address.\n        /// </summary>\n        /// <param name=\"email\">The email address to validate.</param>\n        /// <returns>True if the email is valid, otherwise false.</returns>\n        private bool IsValidEmail(string email)\n        {\n            try\n            {\n                var addr = new System.Net.Mail.MailAddress(email);\n                return addr.Address == email;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n", "suffix": "    public static void Main()\n    {\n        CustomerService service = new CustomerService();\n        service.AddCustomer(new Customer { CustomerId = 1, Name = \"John Doe\", Email = \"john.doe@example.com\" });\n        service.AddCustomer(new Customer { CustomerId = 2, Name = \"Jane Smith\", Email = \"invalid-email\" });\n        service.AddCustomer(new Customer { CustomerId = 3, Name = \"Emily Davis\", Email = \"emily.davis@example.com\" });\n\n        service.CleanInvalidEmails();\n\n        List<Customer> cleanedCustomers = service.GetCustomers();\n\n        Debug.Assert(cleanedCustomers.Count == 2, \"There should be 2 customers after cleaning invalid emails.\");\n        Debug.Assert(cleanedCustomers.Exists(c => c.Email == \"john.doe@example.com\"), \"John Doe should still be in the list.\");\n        Debug.Assert(cleanedCustomers.Exists(c => c.Email == \"emily.davis@example.com\"), \"Emily Davis should still be in the list.\");\n        Debug.Assert(!cleanedCustomers.Exists(c => c.Email == \"invalid-email\"), \"Jane Smith should have been removed due to an invalid email.\");\n    }\n}\n", "golden_completion": "        /// <summary>\n        /// Retrieves the list of customers.\n        /// </summary>\n        /// <returns>A list of customers.</returns>\n        public List<Customer> GetCustomers()\n        {\n            return customers;\n        }\n", "LLM_justification": "This example tests both code-to-comment and comment-to-code translation effectively. The prefix sets up a realistic business logic scenario with a CustomerService class handling customer data and cleaning invalid emails. The golden completion focuses on generating comprehensive documentation for a method that retrieves the list of customers, ensuring alignment between the code and comments. The suffix includes assertions to verify the functional correctness of the implementation and the accuracy of the documentation. This scenario covers complex business rules, error handling, and ensures that the documentation is thorough and accurate.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n    /// Retrieves the list of customers.\n    /// </summary>\n    /// <returns>The list of customers.</returns>\n    public List<Customer> GetCustomers()\n    {\n        return customers;\n    }\n}\n\n/// <summary>\n/// The main class.\n/// </summary>\npublic class Program\n{\n    /// <summary>\n    /// The main entry point of the application.\n    /// </summary>\n    public static void Main()\n    {\n        CustomerService service = new CustomerService();\n        service.AddCustomer(new Customer { CustomerId = 1, Name = \"John Doe\", Email = \"john.doe@example.com\" });\n        service.AddCustomer(new Customer { CustomerId = 2, Name = \"Jane Smith\", Email = \"invalid-email\" });\n        service.AddCustomer(new Customer { CustomerId = 3, Name = \"Emily Davis\", Email = \"emily.davis@example.com\" });\n\n        service.CleanInvalidEmails();\n\n        List<Customer> cleanedCustomers = service.GetCustomers();\n\n        Debug.Assert(cleanedCustomers.Count == 2, \"There should be 2 customers after cleaning invalid emails.\");\n        Debug.Assert(cleanedCustomers.Exists(c => c.Email == \"john.doe@example.com\"), \"John Doe should still be in the list.\");\n        Debug.Assert(cleanedCustomers.Exists(c => c.Email == \"emily.davis@example.com\"), \"Emily Davis should still be in the list.\");\n        Debug.Assert(!cleanedCustomers.Exists(c => c.Email == \"invalid-email\"), \"Jane Smith should have been removed due to an invalid email.\");\n    }\n}\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents a business entity for Customer.\n    /// </summary>\n    public class Customer\n    {\n        /// <summary>\n        /// Gets or sets the customer's ID.\n        /// </summary>\n        public int CustomerId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's name.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's email.\n        /// </summary>\n        public string Email { get; set; }\n    }\n\n    /// <summary>\n    /// Handles customer-related operations such as data transformation and cleaning.\n    /// </summary>\n    public class CustomerService\n    {\n        private List<Customer> customers;\n\n        public CustomerService()\n        {\n            customers = new List<Customer>();\n        }\n\n        /// <summary>\n        /// Adds a new customer to the list.\n        /// </summary>\n        /// <param name=\"customer\">The customer to be added.</param>\n        public void AddCustomer(Customer customer)\n        {\n            customers.Add(customer);\n        }\n\n        /// <summary>\n        /// Removes invalid email addresses from the customer list.\n        /// </summary>\n        public void CleanInvalidEmails()\n        {\n            for (int i = customers.Count - 1; i >= 0; i--)\n            {\n                if (!IsValidEmail(customers[i].Email))\n                {\n                    customers.RemoveAt(i);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Validates an email address.\n        /// </summary>\n        /// <param name=\"email\">The email address to validate.</param>\n        /// <returns>True if the email is valid, otherwise false.</returns>\n        private bool IsValidEmail(string email)\n        {\n            try\n            {\n                var addr = new System.Net.Mail.MailAddress(email);\n                return addr.Address == email;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n#TODO: You Code Here\n    /// <summary>\n    /// Retrieves the list of customers.\n    /// </summary>\n    /// <returns>The list of customers.</returns>\n    public List<Customer> GetCustomers()\n    {\n        return customers;\n    }\n}\n\n/// <summary>\n/// The"}
{"id": "33", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    public class DataTransformer\n    {\n        /// <summary>\n        /// Transforms the input data by applying a series of transformations.\n        /// </summary>\n        /// <param name=\"inputData\">The input data to be transformed.</param>\n        /// <returns>A list of transformed data items.</returns>\n        public List<string> TransformData(List<string> inputData)\n        {\n            List<string> transformedData = new List<string>();\n\n            foreach (var item in inputData)\n            {\n                // TODO: Apply transformations to each item\n                string transformedItem = item.ToUpper(); // Placeholder transformation\n                transformedData.Add(transformedItem);\n            }\n\n            return transformedData;\n        }\n\n        /// <summary>\n        /// Validates the transformed data.\n        /// </summary>\n        /// <param name=\"data\">The data to validate.</param>\n        /// <returns>True if validation passes, otherwise false.</returns>\n        public bool ValidateData(List<string> data)\n        {\n            foreach (var item in data)\n            {\n                if (string.IsNullOrEmpty(item))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    public class WorkflowManager\n    {\n        private readonly DataTransformer _dataTransformer;\n\n        public WorkflowManager()\n        {\n            _dataTransformer = new DataTransformer();\n        }\n\n        /// <summary>\n        /// Orchestrates the workflow by managing the data transformation and validation.\n        /// </summary>\n        public void ExecuteWorkflow()\n        {\n            List<string> rawData = new List<string> { \"data1\", \"data2\", \"data3\" };\n            List<string> transformedData = _dataTransformer.TransformData(rawData);\n            bool isValid = _dataTransformer.ValidateData(transformedData);\n            Debug.Assert(isValid, \"Data validation failed\");\n            // Ensure the data is not empty\n", "suffix": "            // Log the result\n            Console.WriteLine(\"Workflow execution completed. Data is valid: \" + isValid);\n\n            // Additional cleanup or next steps can be handled here\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            WorkflowManager workflowManager = new WorkflowManager();\n            workflowManager.ExecuteWorkflow();\n        }\n    }\n}\n", "golden_completion": "            Debug.Assert(transformedData.Count > 0, \"Transformed data should not be empty\");\n", "LLM_justification": "This example demonstrates a realistic scenario in a business logic domain involving data transformation and workflow orchestration. The task requires completing the code by adding assertions that ensure the transformed data is not empty, in addition to validating the data. The scenario includes a complex setup and meaningful context, which tests the LLM's ability to generate accurate and contextually relevant code. The provided assertions in the suffix verify the correctness of the workflow execution.", "assertions": "", "gpt-35-turbo-completions": "// Ensure the data is not empty\n            Debug.Assert(transformedData.Count > 0, \"Data is empty\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData != null, \"Data is null\");\n\n            // Ensure the data is not null\n            Debug.Assert(transformedData"}
{"id": "34", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogicExample\n{\n    public class Order\n    {\n        public int OrderId { get; set; }\n        public string Customer { get; set; }\n        public List<OrderItem> Items { get; set; }\n        public DateTime OrderDate { get; set; }\n\n        public Order(int orderId, string customer, List<OrderItem> items, DateTime orderDate)\n        {\n            OrderId = orderId;\n            Customer = customer;\n            Items = items;\n            OrderDate = orderDate;\n        }\n    }\n\n    public class OrderItem\n    {\n        public int ProductId { get; set; }\n        public string ProductName { get; set; }\n        public int Quantity { get; set; }\n        public decimal Price { get; set; }\n\n        public OrderItem(int productId, string productName, int quantity, decimal price)\n        {\n            ProductId = productId;\n            ProductName = productName;\n            Quantity = quantity;\n            Price = price;\n        }\n    }\n\n    public class OrderProcessor\n    {\n", "suffix": "        public decimal CalculateTotal(Order order)\n        {\n            decimal total = 0;\n            foreach (var item in order.Items)\n            {\n                total += item.Price * item.Quantity;\n            }\n            return total;\n        }\n\n        public void ProcessOrder(Order order)\n        {\n            decimal total = CalculateTotal(order);\n            Console.WriteLine($\"Processing Order {order.OrderId} for {order.Customer}\");\n            Console.WriteLine($\"Total Amount: {total:C}\");\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<OrderItem> items = new List<OrderItem>\n        {\n            new OrderItem(1, \"Product A\", 2, 10.5m),\n            new OrderItem(2, \"Product B\", 1, 20.0m)\n        };\n        Order order = new Order(1001, \"John Doe\", items, DateTime.Now);\n        OrderProcessor processor = new OrderProcessor();\n        processor.ProcessOrder(order);\n        Debug.Assert(processor.CalculateTotal(order) == 41.0m, \"Total amount should be 41.0\");\n        Console.WriteLine(\"All assertions passed.\");\n    }\n}\n", "golden_completion": "        /// <summary>\n        /// Processes the order and calculates the total amount.\n        /// </summary>\n        /// <param name=\"order\">The order to be processed.</param>\n        /// <returns>The total amount of the order.</returns>\n", "LLM_justification": "This example tests the LLM's ability to generate comprehensive XML documentation for a method that processes an order and calculates the total amount. The prefix sets up a realistic business scenario involving orders and order items, while the suffix contains assertions to verify the correctness of the generated documentation and code functionality. This tests both code-to-comment and comment-to-code translation capabilities effectively.", "assertions": "", "gpt-35-turbo-completions": "// Calculate the total amount of the order\n        // by summing the price of each item multiplied by its quantity\n        // and return the total amount\n        // Use the CalculateTotal method to calculate the total amount of an order\n        // and display the total amount in the ProcessOrder method\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the customer name\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order date\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the product name of each item in the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the quantity of each item in the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the price of each item in the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, order date, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, product name, quantity, and price of each item in the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, product name, quantity, and price of each item in the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, order date, product name, quantity, and price of each item in the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, product name, quantity, and price of each item in the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, product name, quantity, price, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, product name, quantity, price, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, product name, quantity, price, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, product name, quantity, price, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, product name, quantity, price, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, product name, quantity, price, and total amount of the order\n        // Use the ProcessOrder method to display the total amount of an order\n        // and the order ID, customer name, order date, product name, quantity, price, and"}
{"id": "35", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowManagement\n{\n    /// <summary>\n    /// Represents a task in the workflow pipeline.\n    /// </summary>\n    public class WorkflowTask\n    {\n        public string TaskName { get; set; }\n        public bool IsCompleted { get; set; }\n\n        public WorkflowTask(string taskName)\n        {\n            TaskName = taskName;\n            IsCompleted = false;\n        }\n    }\n\n    /// <summary>\n    /// Manages a series of workflow tasks.\n    /// </summary>\n    public class WorkflowManager\n    {\n        private List<WorkflowTask> _tasks;\n\n        public WorkflowManager()\n        {\n            _tasks = new List<WorkflowTask>();\n        }\n\n        /// <summary>\n        /// Adds a new task to the workflow.\n        /// </summary>\n        /// <param name=\"task\">The task to be added.</param>\n        public void AddTask(WorkflowTask task)\n        {\n            _tasks.Add(task);\n        }\n\n        /// <summary>\n        /// Marks a task as completed.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to mark as completed.</param>\n        /// <returns>True if the task was found and marked as completed; otherwise, false.</returns>\n        public bool CompleteTask(string taskName)\n        {\n            var task = _tasks.Find(t => t.TaskName == taskName);\n            if (task != null)\n            {\n                task.IsCompleted = true;\n                return true;\n            }\n            return false;\n        }\n\n        // The method that orchestrates the workflow by executing tasks in sequence.\n        // It should ensure all tasks are completed in the correct order.\n", "suffix": "        public bool ExecuteWorkflow()\n        {\n            foreach (var task in _tasks)\n            {\n                // Simulate task execution\n                task.IsCompleted = true;\n            }\n\n            // Check if all tasks are completed\n            bool allCompleted = _tasks.TrueForAll(t => t.IsCompleted);\n            Debug.Assert(allCompleted, \"Not all tasks were completed successfully.\");\n            return allCompleted;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var manager = new WorkflowManager();\n            manager.AddTask(new WorkflowTask(\"Task1\"));\n            manager.AddTask(new WorkflowTask(\"Task2\"));\n            manager.AddTask(new WorkflowTask(\"Task3\"));\n\n            bool result = manager.ExecuteWorkflow();\n            Debug.Assert(result, \"Workflow did not complete all tasks.\");\n        }\n    }\n}\n", "golden_completion": "        /// <summary>\n        /// Orchestrates the workflow by executing tasks in sequence.\n        /// </summary>\n        /// <returns>True if all tasks are successfully completed; otherwise, false.</returns>\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to generate comprehensive documentation for a method that orchestrates a workflow by executing tasks in sequence. The prefix sets up the context by defining the relevant classes and methods, while the golden_completion provides a detailed XML documentation comment for the ExecuteWorkflow method. The suffix includes code that continues from the golden_completion, completes the method, and adds assertions to verify the correctness of the documentation and the method's functionality. This scenario tests both code-to-comment and comment-to-code translation capabilities, ensuring the LLM can handle complex business logic and technical requirements.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "36", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents a product in the business domain.\n    /// </summary>\n    public class Product\n    {\n        /// <summary>\n        /// Gets or sets the unique identifier for the product.\n        /// </summary>\n        public int Id { get; set; }\n\n        /// <summary>\n        /// Gets or sets the name of the product.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the price of the product.\n        /// </summary>\n        public decimal Price { get; set; }\n    }\n\n    /// <summary>\n    /// Provides methods for transforming product data.\n    /// </summary>\n    public static class ProductTransformer\n    {\n        /// <summary>\n        /// Applies a discount to a list of products.\n        /// </summary>\n        /// <param name=\"products\">The list of products to which the discount will be applied.</param>\n        /// <param name=\"discountPercentage\">The discount percentage to apply.</param>\n        /// <returns>A new list of products with the discount applied.</returns>\n        public static List<Product> ApplyDiscount(List<Product> products, decimal discountPercentage)\n        {\n            List<Product> discountedProducts = new List<Product>();\n            foreach (var product in products)\n            {\n                decimal discountedPrice = product.Price - (product.Price * (discountPercentage / 100));\n                discountedProducts.Add(new Product\n                {\n                    Id = product.Id,\n                    Name = product.Name,\n                    Price = discountedPrice\n                });\n            }\n            return discountedProducts;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<Product> products = new List<Product>\n            {\n                new Product { Id = 1, Name = \"Product 1\", Price = 100 },\n                new Product { Id = 2, Name = \"Product 2\", Price = 200 }\n            };\n\n            // Apply a 10% discount to all products\n", "suffix": "\n\n            Debug.Assert(discountedProducts.Count == 2, \"The number of discounted products should be 2.\");\n            Debug.Assert(discountedProducts[0].Price == 90, \"Product 1's discounted price should be 90.\");\n            Debug.Assert(discountedProducts[1].Price == 180, \"Product 2's discounted price should be 180.\");\n\n            Console.WriteLine(\"All assertions passed.\");\n        }\n    }\n}\n", "golden_completion": "            List<Product> discountedProducts = ProductTransformer.ApplyDiscount(products, 10);\n\n", "LLM_justification": "This test case is a good example for testing code-to-comment and comment-to-code translation capabilities because it involves a realistic business scenario of applying discounts to a list of products. It includes detailed documentation comments for class definitions, method implementations, and parameters. The assertions test the correctness of the discount application logic, ensuring functional accuracy and proper error handling. The setup code in the prefix provides comprehensive context, while the golden completion and suffix demonstrate the alignment between code and comments, making it an effective benchmark for evaluating an LLM's translation abilities.", "assertions": "", "gpt-35-turbo-completions": "List<Product> discountedProducts = ProductTransformer.ApplyDiscount(products, 10);"}
{"id": "37", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace WorkflowManagement\n{\n    /// <summary>\n    /// Represents a task in the workflow.\n    /// </summary>\n    public class WorkflowTask\n    {\n        public string TaskName { get; set; }\n        public int TaskDuration { get; set; } // in minutes\n        public bool IsCompleted { get; set; }\n\n        public WorkflowTask(string taskName, int taskDuration)\n        {\n            TaskName = taskName;\n            TaskDuration = taskDuration;\n            IsCompleted = false;\n        }\n\n        /// <summary>\n        /// Completes the task.\n        /// </summary>\n        public void CompleteTask()\n        {\n            IsCompleted = true;\n        }\n    }\n\n    /// <summary>\n    /// Manages a collection of workflow tasks.\n    /// </summary>\n    public class WorkflowManager\n    {\n        private List<WorkflowTask> tasks;\n\n        public WorkflowManager()\n        {\n            tasks = new List<WorkflowTask>();\n        }\n\n        /// <summary>\n        /// Adds a task to the workflow.\n        /// </summary>\n        /// <param name=\"task\">The task to add.</param>\n        public void AddTask(WorkflowTask task)\n        {\n            tasks.Add(task);\n        }\n\n        /// <summary>\n        /// Marks a task as completed by its name.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to mark as completed.</param>\n        public void CompleteTaskByName(string taskName)\n        {\n            var task = tasks.FirstOrDefault(t => t.TaskName == taskName);\n            if (task != null)\n            {\n                task.CompleteTask();\n            }\n        }\n\n        /// <summary>\n        /// Gets the total duration of all completed tasks.\n        /// </summary>\n        /// <returns>The total duration of completed tasks in minutes.</returns>\n        public int GetTotalCompletedTaskDuration()\n        {\n            return tasks.Where(t => t.IsCompleted).Sum(t => t.TaskDuration);\n        }\n\n        /// <summary>\n        /// Gets the names of all incomplete tasks.\n        /// </summary>\n        /// <returns>A list of names of incomplete tasks.</returns>\n", "suffix": "        // Example usage\n        public static void Main(string[] args)\n        {\n            var manager = new WorkflowManager();\n            manager.AddTask(new WorkflowTask(\"Task1\", 30));\n            manager.AddTask(new WorkflowTask(\"Task2\", 45));\n            manager.CompleteTaskByName(\"Task1\");\n            manager.CompleteTaskByName(\"Task2\");\n\n            int totalCompletedDuration = manager.GetTotalCompletedTaskDuration();\n            Debug.Assert(totalCompletedDuration == 75, \"Total completed task duration should be 75 minutes\");\n        }\n    }\n}\n", "golden_completion": "        public List<string> GetIncompleteTaskNames()\n        {\n            return tasks.Where(t => !t.IsCompleted).Select(t => t.TaskName).ToList();\n        }\n", "LLM_justification": "This example provides a realistic scenario of workflow management, involving task completion and querying incomplete tasks. The prefix sets up the context with class definitions and methods, while the golden_completion adds a new method with comprehensive documentation. The suffix demonstrates usage and assertions verifying correct functionality, making it a good test case for bidirectional translation between code and documentation.", "assertions": "", "gpt-35-turbo-completions": "public List<string> GetIncompleteTaskNames()\n        {\n            return tasks.Where(t => !t.IsCompleted).Select(t => t.TaskName).ToList();\n        }\n    }\n\n    public class Program\n    {"}
{"id": "38", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n", "suffix": "    public class ETLProcessor\n    {\n        private readonly List<string> data;\n\n        public ETLProcessor()\n        {\n            data = new List<string>();\n        }\n\n        /// <summary>\n        /// Loads data from a given source.\n        /// </summary>\n        /// <param name=\"source\">The data source to load from.</param>\n        public void LoadData(string source)\n        {\n            // Simulate loading data\n            data.Add(source);\n        }\n\n        /// <summary>\n        /// Transforms the loaded data by applying a set of rules.\n        /// </summary>\n        public void TransformData()\n        {\n            for (int i = 0; i < data.Count; i++)\n            {\n                data[i] = data[i].ToUpper();\n            }\n        }\n\n        /// <summary>\n        /// Saves the transformed data to a given destination.\n        /// </summary>\n        /// <param name=\"destination\">The destination to save the data to.</param>\n        public void SaveData(string destination)\n        {\n            // Simulate saving data\n            Console.WriteLine($\"Data saved to {destination}\");\n        }\n\n        /// <summary>\n        /// Executes the ETL process: Load, Transform, and Save data.\n        /// </summary>\n        /// <param name=\"source\">The source from which to load data.</param>\n        /// <param name=\"destination\">The destination to save the data to.</param>\n        public void Execute(string source, string destination)\n        {\n            LoadData(source);\n            TransformData();\n            SaveData(destination);\n        }\n    }\n}\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        ETLProcessor processor = new ETLProcessor();\n        processor.Execute(\"SampleData\", \"OutputDestination\");\n\n        Debug.Assert(processor != null, \"Processor should not be null\");\n        Debug.Assert(args.Length == 0, \"No command line arguments expected\");\n    }\n}\n", "golden_completion": "    /// <summary>\n    /// The ETLProcessor class handles the ETL (Extract, Transform, Load) process.\n    /// It can load data from a source, transform it, and save it to a destination.\n    /// </summary>\n", "LLM_justification": "This example tests the ability to translate between code and natural language by requiring the LLM to generate comprehensive documentation for a class that handles an ETL process. The documentation should cover the class purpose, method functionalities, parameters, and overall workflow, demonstrating the LLM's capability to produce detailed and accurate descriptions of business logic in code. The assertions in the suffix validate that the code runs correctly and that the ETL process is executed as expected.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n    /// Represents a class that processes data using the ETL (Extract, Transform, Load) pattern.\n    /// </summary>"}
{"id": "39", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowOrchestration\n{\n    /// <summary>\n    /// Represents a task in the workflow.\n    /// </summary>\n    public class WorkflowTask\n    {\n        /// <summary>\n        /// The name of the task.\n        /// </summary>\n        public string TaskName { get; set; }\n\n        /// <summary>\n        /// The duration of the task in seconds.\n        /// </summary>\n        public int Duration { get; set; }\n    }\n\n    /// <summary>\n    /// Manages the execution of a workflow consisting of multiple tasks.\n    /// </summary>\n    public class WorkflowManager\n    {\n        private readonly List<WorkflowTask> tasks;\n\n        public WorkflowManager()\n        {\n            tasks = new List<WorkflowTask>();\n        }\n\n        /// <summary>\n        /// Adds a task to the workflow.\n        /// </summary>\n        /// <param name=\"task\">The task to add.</param>\n        public void AddTask(WorkflowTask task)\n        {\n            tasks.Add(task);\n        }\n\n        /// <summary>\n        /// Executes all tasks in the workflow sequentially.\n        /// </summary>\n        public void ExecuteAllTasks()\n        {\n            foreach (var task in tasks)\n            {\n                ExecuteTask(task);\n            }\n        }\n\n        /// <summary>\n        /// Executes a single task.\n        /// </summary>\n        /// <param name=\"task\">The task to execute.</param>\n        private void ExecuteTask(WorkflowTask task)\n        {\n            Console.WriteLine($\"Executing {task.TaskName} for {task.Duration} seconds...\");\n            System.Threading.Thread.Sleep(task.Duration * 1000);\n            Console.WriteLine($\"Task {task.TaskName} completed.\");\n        }\n\n        /// <summary>\n        /// Validates if the task durations are positive.\n        /// </summary>\n        /// <returns>True if all task durations are positive, false otherwise.</returns>\n", "suffix": "    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            WorkflowManager manager = new WorkflowManager();\n            manager.AddTask(new WorkflowTask { TaskName = \"Task1\", Duration = 5 });\n            manager.AddTask(new WorkflowTask { TaskName = \"Task2\", Duration = 3 });\n\n            Debug.Assert(manager.ValidateTaskDurations() == true, \"All task durations should be positive.\");\n\n            manager.ExecuteAllTasks();\n        }\n    }\n}\n", "golden_completion": "        public bool ValidateTaskDurations()\n        {\n            foreach (var task in tasks)\n            {\n                if (task.Duration <= 0)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n", "LLM_justification": "This test case is a good example for evaluating an LLM's ability to translate between C# code and documentation effectively. The scenario involves a workflow orchestration system where tasks are managed and executed. The prefix sets up the context with class definitions, method signatures, and partial implementations. The golden completion requires the LLM to complete the validation logic for task durations, which is essential for ensuring that task durations are positive. The suffix includes assertions and additional code to validate the implementation. This scenario tests the LLM's ability to understand business logic, implement technical requirements, handle errors, and generate accurate documentation.", "assertions": "", "gpt-35-turbo-completions": "public bool ValidateTaskDurations()\n        {\n            foreach (var task in tasks)\n            {\n                if (task.Duration <= 0)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }"}
{"id": "40", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    /// <summary>\n    /// Represents a business entity for handling customer orders.\n    /// </summary>\n    public class Order\n    {\n        /// <summary>\n        /// Gets or sets the order ID.\n        /// </summary>\n        public int OrderId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer ID.\n        /// </summary>\n        public int CustomerId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the order date.\n        /// </summary>\n        public DateTime OrderDate { get; set; }\n\n        /// <summary>\n        /// Gets or sets the order amount.\n        /// </summary>\n        public decimal OrderAmount { get; set; }\n    }\n\n    /// <summary>\n    /// Manages order processing logic.\n    /// </summary>\n    public class OrderManager\n    {\n        private List<Order> orders = new List<Order>();\n\n", "suffix": "        public void AddOrder(Order order)\n        {\n            if (order == null)\n            {\n                throw new ArgumentNullException(nameof(order));\n            }\n            orders.Add(order);\n        }\n\n        /// <summary>\n        /// Retrieves an order by its ID.\n        /// </summary>\n        /// <param name=\"orderId\">The ID of the order to retrieve.</param>\n        /// <returns>The order with the specified ID, or null if not found.</returns>\n        public Order GetOrderById(int orderId)\n        {\n            foreach (var order in orders)\n            {\n                if (order.OrderId == orderId)\n                {\n                    return order;\n                }\n            }\n            return null;\n        }\n\n        /// <summary>\n        /// Retrieves all orders for a specific customer.\n        /// </summary>\n        /// <param name=\"customerId\">The ID of the customer whose orders to retrieve.</param>\n        /// <returns>A list of orders for the specified customer.</returns>\n        public List<Order> GetOrdersByCustomerId(int customerId)\n        {\n            var customerOrders = new List<Order>();\n            foreach (var order in orders)\n            {\n                if (order.CustomerId == customerId)\n                {\n                    customerOrders.Add(order);\n                }\n            }\n            return customerOrders;\n        }\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        OrderManager orderManager = new OrderManager();\n        Order order1 = new Order { OrderId = 1, CustomerId = 101, OrderDate = DateTime.Now, OrderAmount = 250.00m };\n        Order order2 = new Order { OrderId = 2, CustomerId = 102, OrderDate = DateTime.Now, OrderAmount = 150.00m };\n        orderManager.AddOrder(order1);\n        orderManager.AddOrder(order2);\n\n        // Retrieve orders by customer ID\n        var customerOrders = orderManager.GetOrdersByCustomerId(101);\n        Debug.Assert(customerOrders.Count == 1, \"Expected exactly one order for customer 101.\");\n        Debug.Assert(customerOrders[0].OrderId == 1, \"Expected order ID to be 1.\");\n        Debug.Assert(customerOrders[0].OrderAmount == 250.00m, \"Expected order amount to be 250.00.\");\n\n        // Retrieve order by order ID\n        var order = orderManager.GetOrderById(2);\n        Debug.Assert(order != null, \"Expected to retrieve order with ID 2.\");\n        Debug.Assert(order.CustomerId == 102, \"Expected customer ID to be 102.\");\n        Debug.Assert(order.OrderAmount == 150.00m, \"Expected order amount to be 150.00.\");\n\n        // Test case where order ID does not exist\n        var nonExistentOrder = orderManager.GetOrderById(999);\n        Debug.Assert(nonExistentOrder == null, \"Expected null for non-existent order ID.\");\n    }\n}\n", "golden_completion": "        // Adding detailed XML documentation for the AddOrder method\n        /// <summary>\n        /// Adds a new order to the system.\n        /// </summary>\n        /// <param name=\"order\">The order to add. Must not be null.</param>\n        /// <exception cref=\"ArgumentNullException\">Thrown when the order parameter is null.</exception>\n", "LLM_justification": "This example tests the model's ability to generate comprehensive XML documentation for a method that handles adding orders to a list. It includes parameter descriptions, exception documentation, and usage context. The assertions verify the correctness of the business logic for managing orders and check edge cases such as null handling and non-existent order retrieval.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n        /// Adds a new order to the system.\n        /// </summary>\n        /// <param name=\"order\">The order to add.</param>"}
{"id": "41", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace Company.Workflow\n{\n    public class TaskScheduler\n    {\n        private readonly Dictionary<string, DateTime> _taskSchedule;\n        \n        public TaskScheduler()\n        {\n            _taskSchedule = new Dictionary<string, DateTime>();\n        }\n\n        /// <summary>\n        /// Adds a new task to the schedule.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task.</param>\n        /// <param name=\"scheduleTime\">The time when the task is scheduled to run.</param>\n        public void AddTask(string taskName, DateTime scheduleTime)\n        {\n            if (string.IsNullOrEmpty(taskName))\n            {\n                throw new ArgumentException(\"Task name cannot be null or empty.\", nameof(taskName));\n            }\n\n            if (scheduleTime <= DateTime.Now)\n            {\n                throw new ArgumentException(\"Schedule time must be in the future.\", nameof(scheduleTime));\n            }\n\n            _taskSchedule[taskName] = scheduleTime;\n        }\n\n        /// <summary>\n        /// Removes a task from the schedule.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to remove.</param>\n        /// <returns>True if the task was successfully removed, otherwise false.</returns>\n        public bool RemoveTask(string taskName)\n        {\n            return _taskSchedule.Remove(taskName);\n        }\n\n        public DateTime? GetNextScheduledTask()\n        {\n", "suffix": "        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TaskScheduler scheduler = new TaskScheduler();\n\n            // Test AddTask method\n            scheduler.AddTask(\"Task1\", DateTime.Now.AddHours(1));\n            Debug.Assert(scheduler.RemoveTask(\"Task1\") == true, \"Task1 should be removable.\");\n            Debug.Assert(scheduler.RemoveTask(\"Task1\") == false, \"Task1 should not exist anymore.\");\n\n            // Test GetNextScheduledTask method\n            DateTime? nextTask = scheduler.GetNextScheduledTask();\n            Debug.Assert(nextTask == null, \"There should be no scheduled tasks.\");\n\n            // Clean up\n            scheduler.RemoveTask(\"Task1\");\n        }\n    }\n}\n", "golden_completion": "            if (_taskSchedule.Count == 0)\n            {\n                return null;\n            }\n\n            DateTime nextTaskTime = DateTime.MaxValue;\n            foreach (var task in _taskSchedule)\n            {\n                if (task.Value < nextTaskTime)\n                {\n                    nextTaskTime = task.Value;\n                }\n            }\n            return nextTaskTime;\n", "LLM_justification": "This scenario tests the LLM's ability to handle both code-to-comment and comment-to-code translations effectively. The prefix sets up a realistic task scheduling scenario with multiple methods, including one that needs implementation and documentation. The golden completion provides a proper implementation for the GetNextScheduledTask method, demonstrating the model's ability to fill in the missing logic based on the context provided. The suffix includes assertions to verify the correctness of the implemented method and ensure the code functions as expected, focusing on both adding and removing tasks as well as retrieving the next scheduled task.", "assertions": "", "gpt-35-turbo-completions": "DateTime? nextTask = null;\n            DateTime minTime = DateTime.MaxValue;\n            foreach (var task in _taskSchedule)\n            {\n                if (task.Value < minTime)\n                {\n                    minTime = task.Value;\n                    nextTask = task.Value;\n                }\n            }\n            return nextTask;"}
{"id": "42", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    public class DataTransformation\n    {\n        /// <summary>\n        /// Cleans the input data by removing null or empty values and converting all strings to lowercase.\n        /// </summary>\n        /// <param name=\"inputData\">List of strings representing the input data.</param>\n        /// <returns>List of cleaned strings.</returns>\n        public List<string> CleanData(List<string> inputData)\n        {\n            List<string> cleanedData = new List<string>();\n            foreach (var data in inputData)\n            {\n                if (!string.IsNullOrEmpty(data))\n                {\n                    cleanedData.Add(data.ToLower());\n                }\n            }\n            return cleanedData;\n        }\n\n        /// <summary>\n        /// Transforms the input data by applying a series of rules.\n        /// </summary>\n        /// <param name=\"inputData\">List of strings representing the input data.</param>\n        /// <returns>List of transformed strings.</returns>\n", "suffix": "            return transformedData;\n        }\n\n        // Sample data for testing\n        public static void Main(string[] args)\n        {\n            DataTransformation transformer = new DataTransformation();\n            List<string> sampleData = new List<string> { \"Hello World\", \"Test Data\", \"Sample Entry\" };\n\n            // Clean Data\n            List<string> cleanedData = transformer.CleanData(sampleData);\n            Debug.Assert(cleanedData.Contains(\"hello world\"), \"Cleaned data should contain 'hello world'\");\n            Debug.Assert(cleanedData.Contains(\"test data\"), \"Cleaned data should contain 'test data'\");\n            Debug.Assert(cleanedData.Contains(\"sample entry\"), \"Cleaned data should contain 'sample entry'\");\n\n            // Transform Data\n            List<string> transformedData = transformer.TransformData(cleanedData);\n            Debug.Assert(transformedData.Contains(\"hello_world\"), \"Transformed data should contain 'hello_world'\");\n            Debug.Assert(transformedData.Contains(\"test_data\"), \"Transformed data should contain 'test_data'\");\n            Debug.Assert(transformedData.Contains(\"sample_entry\"), \"Transformed data should contain 'sample_entry'\");\n\n            Console.WriteLine(\"All assertions passed.\");\n        }\n    }\n}", "golden_completion": "        public List<string> TransformData(List<string> inputData)\n        {\n            List<string> transformedData = new List<string>();\n            foreach (var data in inputData)\n            {\n                // Placeholder for transformation logic\n                transformedData.Add(data.Replace(\" \", \"_\"));\n            }\n", "LLM_justification": "This scenario tests the ability to translate detailed method documentation into code and vice versa. It involves implementing a method based on provided comments and verifying that the implementation matches the documented behavior. The example includes complex business logic with data transformation rules, demonstrating realistic usage patterns. The assertions ensure that the implementation meets the documented requirements and handles various data scenarios correctly.", "assertions": "", "gpt-35-turbo-completions": "public List<string> TransformData(List<string> inputData)\n        {\n            List<string> transformedData = new List<string>();\n            foreach (var data in inputData)\n            {\n                string transformed = data.Replace(\" \", \"_\");\n                transformedData.Add(transformed);\n            }"}
{"id": "43", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic {\n    /// <summary>\n    /// Represents a business entity for a customer.\n    /// </summary>\n    public class Customer {\n        /// <summary>\n        /// Gets or sets the customer ID.\n        /// </summary>\n        public int CustomerID { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer name.\n        /// </summary>\n        public string CustomerName { get; set; }\n    }\n\n    /// <summary>\n    /// Handles operations related to customers.\n    /// </summary>\n    public class CustomerManager {\n        private List<Customer> customers;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"CustomerManager\"/> class.\n        /// </summary>\n        public CustomerManager() {\n            customers = new List<Customer>();\n        }\n\n        /// <summary>\n        /// Adds a new customer to the list.\n        /// </summary>\n        /// <param name=\"customer\">The customer to add.</param>\n        public void AddCustomer(Customer customer) {\n            if (customer == null) {\n                throw new ArgumentNullException(nameof(customer));\n            }\n            if (string.IsNullOrWhiteSpace(customer.CustomerName)) {\n                throw new ArgumentException(\"Customer name cannot be empty.\", nameof(customer.CustomerName));\n            }\n            customers.Add(customer);\n        }\n\n        /// <summary>\n        /// Retrieves a customer by ID.\n        /// </summary>\n        /// <param name=\"customerID\">The ID of the customer to retrieve.</param>\n        /// <returns>The customer with the specified ID, or null if not found.</returns>\n        public Customer GetCustomerByID(int customerID) {\n            return customers.Find(c => c.CustomerID == customerID);\n        }\n\n        /// <summary>\n        /// Updates the name of an existing customer.\n        /// </summary>\n        /// <param name=\"customerID\">The ID of the customer to update.</param>\n        /// <param name=\"newName\">The new name for the customer.</param>\n", "suffix": "            var customer = customers.Find(c => c.CustomerID == customerID);\n            if (customer == null) {\n                throw new KeyNotFoundException($\"No customer found with ID {customerID}\");\n            }\n            customer.CustomerName = newName;\n\n            // Assertions\n            Debug.Assert(customer.CustomerName == newName, \"Customer name was not updated correctly.\");\n        }\n    }\n\n    public class Program {\n        public static void Main(string[] args) {\n            CustomerManager manager = new CustomerManager();\n            Customer customer = new Customer { CustomerID = 1, CustomerName = \"John Doe\" };\n            manager.AddCustomer(customer);\n\n            // Test updating customer name\n            manager.UpdateCustomerName(1, \"Jane Doe\");\n            Customer updatedCustomer = manager.GetCustomerByID(1);\n            Debug.Assert(updatedCustomer.CustomerName == \"Jane Doe\", \"Customer name update failed.\");\n        }\n    }\n}\n", "golden_completion": "        public void UpdateCustomerName(int customerID, string newName) {\n            if (string.IsNullOrWhiteSpace(newName)) {\n                throw new ArgumentException(\"New name cannot be empty.\", nameof(newName));\n            }\n", "LLM_justification": "This test case is good because it covers realistic business logic involving customer management, including handling null inputs and providing meaningful error messages. It tests bidirectional translation between code and documentation by requiring detailed XML documentation comments and implementing a method based on comments. The scenario ensures clear alignment between documentation and implementation, with comprehensive documentation and relevant assertions. This allows for testing both the generation of documentation from code and the implementation of code from documentation.", "assertions": "", "gpt-35-turbo-completions": "public void UpdateCustomerName(int customerID, string newName) {\n            if (string.IsNullOrWhiteSpace(newName)) {\n                throw new ArgumentException(\"Customer name cannot be empty.\", nameof(newName));\n            }"}
{"id": "44", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Diagnostics;\n\nnamespace BusinessLogic\n{\n    public class DataTransformer\n    {\n        private List<string> _data;\n\n        public DataTransformer(List<string> data)\n        {\n            _data = data;\n        }\n\n        /// <summary>\n        /// Cleans the data by removing empty entries and trimming whitespace.\n        /// </summary>\n        /// <returns>A cleaned list of strings.</returns>\n        public List<string> CleanData()\n        {\n            List<string> cleanedData = _data.Where(d => !string.IsNullOrWhiteSpace(d)).Select(d => d.Trim()).ToList();\n            return cleanedData;\n        }\n\n        /// <summary>\n        /// Transforms the cleaned data by converting all entries to uppercase.\n        /// </summary>\n        /// <param name=\"cleanedData\">The cleaned list of strings.</param>\n        /// <returns>A transformed list of strings in uppercase.</returns>\n", "suffix": "public static void Main(string[] args)\n        {\n            List<string> rawData = new List<string> { \"  apple  \", \"  \", \"banana\", \"cherry \" };\n            DataTransformer transformer = new DataTransformer(rawData);\n            List<string> cleanedData = transformer.CleanData();\n            List<string> transformedData = transformer.TransformData(cleanedData);\n\n            Debug.Assert(transformedData.Count == 3, \"Transformed data should have 3 entries.\");\n            Debug.Assert(transformedData[0] == \"APPLE\", \"First entry should be 'APPLE'.\");\n            Debug.Assert(transformedData[1] == \"BANANA\", \"Second entry should be 'BANANA'.\");\n            Debug.Assert(transformedData[2] == \"CHERRY\", \"Third entry should be 'CHERRY'.\");\n        }\n    }\n}\n", "golden_completion": "        public List<string> TransformData(List<string> cleanedData)\n        {\n            List<string> transformedData = cleanedData.Select(d => d.ToUpper()).ToList();\n            return transformedData;\n        }\n", "LLM_justification": "This test case is a good example of a realistic business logic scenario involving data transformation. It includes comprehensive documentation for the method implementations, which is critical for code-to-comment translation testing. The given prefix provides substantial setup code, and the golden completion fills in the method implementation, demonstrating a clear alignment between documentation and implementation. The suffix includes assertions to verify that the transformation logic works correctly, ensuring that the example tests both the functional requirements and the completeness of the documentation.", "assertions": "", "gpt-35-turbo-completions": "public List<string> TransformData(List<string> cleanedData)\n        {\n            List<string> transformedData = cleanedData.Select(d => d.ToUpper()).ToList();\n            return transformedData;\n        }\n    }\n\n    public class Program\n    {"}
{"id": "45", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic {\n    /// <summary>\n    /// Represents a customer entity in the business domain.\n    /// </summary>\n    public class Customer {\n        /// <summary>\n        /// Gets or sets the customer ID.\n        /// </summary>\n        public int CustomerId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer name.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's date of birth.\n        /// </summary>\n        public DateTime DateOfBirth { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Customer\"/> class.\n        /// </summary>\n        /// <param name=\"customerId\">The customer ID.</param>\n        /// <param name=\"name\">The customer name.</param>\n        /// <param name=\"dateOfBirth\">The customer's date of birth.</param>\n        public Customer(int customerId, string name, DateTime dateOfBirth) {\n            CustomerId = customerId;\n            Name = name;\n            DateOfBirth = dateOfBirth;\n        }\n    }\n\n    /// <summary>\n    /// A service for managing customers.\n    /// </summary>\n    public class CustomerService {\n        private readonly List<Customer> customers = new List<Customer>();\n\n        /// <summary>\n        /// Adds a new customer to the service.\n        /// </summary>\n        /// <param name=\"customer\">The customer to add.</param>\n        public void AddCustomer(Customer customer) {\n            customers.Add(customer);\n        }\n\n        /// <summary>\n        /// Finds a customer by ID.\n        /// </summary>\n        /// <param name=\"customerId\">The customer ID.</param>\n        /// <returns>The customer with the specified ID, or null if not found.</returns>\n        public Customer FindCustomerById(int customerId) {\n            return customers.Find(c => c.CustomerId == customerId);\n        }\n", "suffix": "        public void RemoveCustomer(int customerId) {\n            var customer = FindCustomerById(customerId);\n            if (customer != null) {\n                customers.Remove(customer);\n            }\n        }\n\n        public static void Main(string[] args) {\n            CustomerService service = new CustomerService();\n            Customer customer1 = new Customer(1, \"John Doe\", new DateTime(1980, 1, 1));\n            Customer customer2 = new Customer(2, \"Jane Smith\", new DateTime(1990, 2, 2));\n\n            service.AddCustomer(customer1);\n            service.AddCustomer(customer2);\n\n            // Verify that customers are added\n            Debug.Assert(service.FindCustomerById(1) != null, \"Customer 1 should exist\");\n            Debug.Assert(service.FindCustomerById(2) != null, \"Customer 2 should exist\");\n\n            // Remove customer 1 and verify removal\n            service.RemoveCustomer(1);\n            Debug.Assert(service.FindCustomerById(1) == null, \"Customer 1 should be removed\");\n\n            // Verify customer 2 still exists\n            Debug.Assert(service.FindCustomerById(2) != null, \"Customer 2 should still exist\");\n        }\n    }\n}\n", "golden_completion": "        /// <summary>\n        /// Removes a customer by ID.\n        /// </summary>\n        /// <param name=\"customerId\">The customer ID.</param>\n", "LLM_justification": "This test case demonstrates the ability to translate between code and natural language by documenting a method that removes a customer by ID. The prefix sets up the customer management context, and the completion provides the required documentation. The suffix verifies the correct functionality with assertions, ensuring the documentation aligns with the implementation.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n        /// Removes a customer from the service.\n        /// </summary>\n        /// <param name=\"customerId\">The ID of the customer to remove.</param>"}
{"id": "46", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WorkflowOrchestration {\n    public class TaskScheduler {\n        private Dictionary<string, DateTime> taskSchedule;\n\n        public TaskScheduler() {\n            taskSchedule = new Dictionary<string, DateTime>();\n        }\n\n        /// <summary>\n        /// Schedules a new task.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task.</param>\n        /// <param name=\"scheduleTime\">The time at which the task is scheduled to run.</param>\n        public void ScheduleTask(string taskName, DateTime scheduleTime) {\n            if (taskSchedule.ContainsKey(taskName)) {\n                throw new InvalidOperationException(\"Task already scheduled.\");\n            }\n            taskSchedule[taskName] = scheduleTime;\n        }\n\n        /// <summary>\n        /// Cancels a scheduled task.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to cancel.</param>\n        public void CancelTask(string taskName) {\n            if (!taskSchedule.ContainsKey(taskName)) {\n                throw new KeyNotFoundException(\"Task not found.\");\n            }\n            taskSchedule.Remove(taskName);\n        }\n\n        /// <summary>\n        /// Gets the schedule time for a task.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task.</param>\n        /// <returns>The scheduled time for the task.</returns>\n        public DateTime GetTaskSchedule(string taskName) {\n            if (!taskSchedule.ContainsKey(taskName)) {\n                throw new KeyNotFoundException(\"Task not found.\");\n            }\n            return taskSchedule[taskName];\n        }\n\n        /// <summary>\n        /// Checks if a task is scheduled.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task.</param>\n        /// <returns>True if the task is scheduled, otherwise false.</returns>\n        public bool IsTaskScheduled(string taskName) {\n            return taskSchedule.ContainsKey(taskName);\n        }\n\n        // Complete the method to reschedule a task\n", "suffix": "        public void RescheduleTask(string taskName, DateTime newScheduleTime) {\n            if (!taskSchedule.ContainsKey(taskName)) {\n                throw new KeyNotFoundException(\"Task not found.\");\n            }\n            taskSchedule[taskName] = newScheduleTime;\n        }\n    }\n\n    public class TaskSchedulerTests {\n        public static void Main(string[] args) {\n            TaskScheduler scheduler = new TaskScheduler();\n            scheduler.ScheduleTask(\"Task1\", DateTime.Now.AddHours(1));\n            Debug.Assert(scheduler.IsTaskScheduled(\"Task1\"), \"Task1 should be scheduled\");\n            Debug.Assert(scheduler.GetTaskSchedule(\"Task1\") > DateTime.Now, \"Task1 schedule time should be in the future\");\n\n            scheduler.RescheduleTask(\"Task1\", DateTime.Now.AddHours(2));\n            Debug.Assert(scheduler.GetTaskSchedule(\"Task1\") > DateTime.Now.AddHours(1), \"Task1 schedule time should be updated\");\n\n            scheduler.CancelTask(\"Task1\");\n            Debug.Assert(!scheduler.IsTaskScheduled(\"Task1\"), \"Task1 should be canceled\");\n\n            Console.WriteLine(\"All tests passed.\");\n        }\n    }\n}\n", "golden_completion": "        /// <summary>\n        /// Reschedules an existing task to a new time.\n        /// </summary>\n        /// <param name=\"taskName\">The name of the task to reschedule.</param>\n        /// <param name=\"newScheduleTime\">The new time at which the task is scheduled to run.</param>\n", "LLM_justification": "This test case effectively demonstrates the translation between code and documentation by extending a class with a rescheduling method. The prefix provides substantial context, including multiple methods with XML documentation comments. The golden_completion requires the model to generate appropriate documentation for a new method, ensuring alignment with existing patterns. The suffix includes comprehensive assertions to verify the method's functionality and the accuracy of the documentation. This scenario tests the model's ability to maintain consistency and completeness in both directions of translation.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "47", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic {\n    public class DataTransformer {\n        private readonly List<int> _data;\n\n        public DataTransformer(List<int> data) {\n            _data = data ?? throw new ArgumentNullException(nameof(data));\n        }\n\n        /// <summary>\n        /// Filters the data to include only even numbers.\n        /// </summary>\n        /// <returns>List of even numbers</returns>\n        public List<int> FilterEvenNumbers() {\n            List<int> evenNumbers = new List<int>();\n            foreach (int number in _data) {\n                if (number % 2 == 0) {\n                    evenNumbers.Add(number);\n                }\n            }\n            return evenNumbers;\n        }\n\n        /// <summary>\n        /// Transforms the data by squaring each number.\n        /// </summary>\n        /// <returns>List of squared numbers</returns>\n        public List<int> SquareNumbers() {\n            List<int> squaredNumbers = new List<int>();\n            foreach (int number in _data) {\n                squaredNumbers.Add(number * number);\n            }\n            return squaredNumbers;\n        }\n\n", "suffix": "        public List<int> CleanData() {\n            _data.RemoveAll(number => number < 0);\n            _data.Sort();\n            return _data;\n        }\n\n        public static void Main(string[] args) {\n            List<int> data = new List<int> { -10, 15, 0, 23, -5, 8, -3, 7, 4 };\n            DataTransformer transformer = new DataTransformer(data);\n\n            List<int> cleanedData = transformer.CleanData();\n            Debug.Assert(cleanedData.Count == 6, \"CleanData should remove negative numbers and sort the list.\");\n            Debug.Assert(cleanedData[0] == 0 && cleanedData[1] == 4 && cleanedData[2] == 7 && cleanedData[3] == 8 && cleanedData[4] == 15 && cleanedData[5] == 23, \"CleanData did not sort correctly.\");\n\n            List<int> evenNumbers = transformer.FilterEvenNumbers();\n            Debug.Assert(evenNumbers.Count == 2, \"FilterEvenNumbers should return only the even numbers.\");\n            Debug.Assert(evenNumbers[0] == 0 && evenNumbers[1] == 4, \"FilterEvenNumbers returned incorrect values.\");\n\n            List<int> squaredNumbers = transformer.SquareNumbers();\n            Debug.Assert(squaredNumbers.Count == 6, \"SquareNumbers should return squared values.\");\n            Debug.Assert(squaredNumbers[0] == 0 && squaredNumbers[1] == 16 && squaredNumbers[2] == 49 && squaredNumbers[3] == 64 && squaredNumbers[4] == 225 && squaredNumbers[5] == 529, \"SquareNumbers returned incorrect values.\");\n        }\n    }\n}\n", "golden_completion": "        /// <summary>\n        /// Cleans the data by removing negative numbers and sorting the list.\n        /// </summary>\n        /// <returns>Cleaned and sorted list of numbers</returns>\n", "LLM_justification": "This test case is effective because it demonstrates a realistic scenario of data transformation within a business logic context. The prefix provides a substantial amount of setup code, including the definition of the DataTransformer class and its methods. The golden_completion focuses on generating comprehensive documentation for the CleanData method, detailing its purpose, return value, and behavior. The suffix includes assertions to verify the functionality of the CleanData method as well as other methods in the class, ensuring that the code performs as expected. This scenario tests both code-to-comment and comment-to-code translation capabilities, making it a valuable benchmark for evaluating an LLM's performance.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n        /// Cleans the data by removing negative numbers and sorting the list.\n        /// </summary>\n        /// <returns>Cleaned list of numbers</returns>"}
{"id": "48", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic {\n    public class ETLProcess {\n        private List<string> data;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"ETLProcess\"/> class.\n        /// </summary>\n        /// <param name=\"data\">The initial data for the ETL process.</param>\n        public ETLProcess(List<string> data) {\n            this.data = data;\n        }\n\n        /// <summary>\n        /// Cleans the data by removing any null or empty entries.\n        /// </summary>\n        public void CleanData() {\n            data.RemoveAll(entry => string.IsNullOrEmpty(entry));\n        }\n\n        /// <summary>\n        /// Transforms the data to uppercase.\n        /// </summary>\n        public void TransformData() {\n            for (int i = 0; i < data.Count; i++) {\n                data[i] = data[i].ToUpper();\n            }\n        }\n\n        // The LoadData method needs to be implemented\n", "suffix": "        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            List<string> sampleData = new List<string> { \"apple\", \"banana\", null, \"orange\", \"\" };\n            ETLProcess etl = new ETLProcess(sampleData);\n            etl.CleanData();\n            etl.TransformData();\n            etl.LoadData();\n\n            // Verify CleanData method functionality\n            Debug.Assert(!sampleData.Contains(null), \"CleanData did not remove null entries\");\n            Debug.Assert(!sampleData.Contains(\"\"), \"CleanData did not remove empty entries\");\n\n            // Verify TransformData method functionality\n            Debug.Assert(sampleData.Contains(\"APPLE\"), \"TransformData did not convert 'apple' to 'APPLE'\");\n            Debug.Assert(sampleData.Contains(\"BANANA\"), \"TransformData did not convert 'banana' to 'BANANA'\");\n            Debug.Assert(sampleData.Contains(\"ORANGE\"), \"TransformData did not convert 'orange' to 'ORANGE'\");\n\n            // Verify LoadData method functionality\n            // (Assuming LoadData prints data to console for this example)\n            etl.LoadData();\n            // Since LoadData is not yet defined, assertions for it should be added once it's implemented\n        }\n    }\n}\n", "golden_completion": "        /// <summary>\n        /// Loads the data by printing it to the console.\n        /// </summary>\n        public void LoadData() {\n            foreach (var entry in data) {\n                Console.WriteLine(entry);\n            }\n", "LLM_justification": "This example provides a realistic scenario of an ETL (Extract, Transform, Load) process often used in business data transformations. The task focuses on translating between code and documentation. The prefix includes detailed setup and context, while the golden completion provides the implementation of a method with proper XML documentation. The suffix ensures functionality is tested with assertions, verifying the accuracy of the LoadData method once implemented. This tests the LLM's ability to generate comprehensive documentation and correctly interpret and implement specified functionality.", "assertions": "", "gpt-35-turbo-completions": "/// <summary>\n        /// Loads the data.\n        /// </summary>\n        public void LoadData() {\n            foreach (string entry in data) {\n                Console.WriteLine(entry);\n            }"}
{"id": "49", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogic {\n    /// <summary>\n    /// This class represents a customer in the business domain.\n    /// </summary>\n    public class Customer {\n        /// <summary>\n        /// Gets or sets the customer ID.\n        /// </summary>\n        public int CustomerId { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's name.\n        /// </summary>\n        public string Name { get; set; }\n\n        /// <summary>\n        /// Gets or sets the customer's email.\n        /// </summary>\n        public string Email { get; set; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Customer\"/> class.\n        /// </summary>\n        /// <param name=\"customerId\">The customer ID.</param>\n        /// <param name=\"name\">The customer's name.</param>\n        /// <param name=\"email\">The customer's email.</param>\n        public Customer(int customerId, string name, string email) {\n            CustomerId = customerId;\n            Name = name;\n            Email = email;\n        }\n\n        /// <summary>\n        /// Updates the customer's email address.\n        /// </summary>\n        /// <param name=\"newEmail\">The new email address.</param>\n        public void UpdateEmail(string newEmail) {\n            if (string.IsNullOrWhiteSpace(newEmail)) {\n                throw new ArgumentException(\"Email cannot be empty.\");\n            }\n            Email = newEmail;\n        }\n    }\n\n    /// <summary>\n    /// Provides functionality to manage a collection of customers.\n    /// </summary>\n    public class CustomerManager {\n        private readonly List<Customer> _customers;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"CustomerManager\"/> class.\n        /// </summary>\n        public CustomerManager() {\n            _customers = new List<Customer>();\n        }\n\n        /// <summary>\n        /// Adds a new customer to the collection.\n        /// </summary>\n        /// <param name=\"customer\">The customer to add.</param>\n        public void AddCustomer(Customer customer) {\n            if (customer == null) {\n                throw new ArgumentNullException(nameof(customer));\n            }\n            _customers.Add(customer);\n        }\n\n        /// <summary>\n        /// Finds a customer by ID.\n        /// </summary>\n        /// <param name=\"customerId\">The ID of the customer to find.</param>\n        /// <returns>The customer if found; otherwise, null.</returns>\n        public Customer FindCustomerById(int customerId) {\n            return _customers.Find(c => c.CustomerId == customerId);\n        }\n\n        /// <summary>\n        /// Updates the email address of a customer.\n        /// </summary>\n        /// <param name=\"customerId\">The ID of the customer to update.</param>\n        /// <param name=\"newEmail\">The new email address.</param>\n        public void UpdateCustomerEmail(int customerId, string newEmail) {\n            Customer customer = FindCustomerById(customerId);\n            if (customer == null) {\n                throw new KeyNotFoundException(\"Customer not found.\");\n            }\n            customer.UpdateEmail(newEmail);\n        }\n    }\n\n    public class Program {\n        public static void Main(string[] args) {\n            CustomerManager manager = new CustomerManager();\n            manager.AddCustomer(new Customer(1, \"John Doe\", \"john@example.com\"));\n            manager.AddCustomer(new Customer(2, \"Jane Smith\", \"jane@example.com\"));\n\n            // Update the email for customer with ID 1\n", "suffix": "            // Attempt to update email for a non-existing customer\n            try {\n                manager.UpdateCustomerEmail(3, \"nonexistent@example.com\");\n            } catch (KeyNotFoundException ex) {\n                Debug.Assert(ex.Message == \"Customer not found.\", \"Expected KeyNotFoundException with message 'Customer not found.'\");\n            }\n\n            // Validate the updated email for customer with ID 1\n            Customer customer = manager.FindCustomerById(1);\n            Debug.Assert(customer.Email == \"newjohn@example.com\", \"The email for customer with ID 1 should be updated to 'newjohn@example.com'.\");\n\n            // Validate no changes to customer with ID 2\n            Customer customer2 = manager.FindCustomerById(2);\n            Debug.Assert(customer2.Email == \"jane@example.com\", \"The email for customer with ID 2 should remain 'jane@example.com'.\");\n        }\n    }\n}\n", "golden_completion": "            manager.UpdateCustomerEmail(1, \"newjohn@example.com\");\n", "LLM_justification": "This example tests the LLM's ability to generate accurate documentation for existing code, including class definitions, method implementations, and error handling. The complex business logic around managing customers and updating their emails provides a realistic scenario for both code-to-comment and comment-to-code translations. The assertions ensure that the documentation is complete and correct, checking for key terms and coverage of important concepts, as well as verifying the functional requirements and error handling in the code.", "assertions": "", "gpt-35-turbo-completions": "manager.UpdateCustomerEmail(1, \"newjohn@example.com\");\n\n            // Attempt to update email with an empty string\n            try {\n                manager.UpdateCustomerEmail(2, \"\");\n            } catch (ArgumentException ex) {\n                Debug.Assert(ex.Message == \"Email cannot be empty.\", \"Expected ArgumentException with message 'Email cannot be empty.'\");\n            }"}
{"id": "50", "testsource": "synthbench-code2NL-NL2code", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogicExample\n{\n    public class DataTransformer\n    {\n        /// <summary>\n        /// Cleanses the input data by removing null entries and trimming whitespace.\n        /// </summary>\n        /// <param name=\"inputData\">List of string data to be cleansed.</param>\n        /// <returns>List of cleansed string data.</returns>\n        public List<string> CleanseData(List<string> inputData)\n        {\n            List<string> cleansedData = new List<string>();\n            foreach (var data in inputData)\n            {\n                if (!string.IsNullOrWhiteSpace(data))\n                {\n                    cleansedData.Add(data.Trim());\n                }\n            }\n            return cleansedData;\n        }\n    }\n\n    public class WorkflowOrchestrator\n    {\n        private DataTransformer _dataTransformer;\n\n        public WorkflowOrchestrator()\n        {\n            _dataTransformer = new DataTransformer();\n        }\n\n        /// <summary>\n        /// Orchestrates the workflow of data transformation.\n        /// </summary>\n        /// <param name=\"rawData\">Raw input data for the workflow.</param>\n        /// <returns>Transformed and cleansed data.</returns>\n        public List<string> OrchestrateWorkflow(List<string> rawData)\n        {\n            return _dataTransformer.CleanseData(rawData);\n        }\n\n        /// <summary>\n        /// Handles errors during the workflow orchestration.\n        /// </summary>\n        /// <param name=\"ex\">Exception that occurred.</param>\n        /// <returns>Formatted error message.</returns>\n        public string HandleError(Exception ex)\n        {\n            return $\"Error: {ex.Message}\";\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // Initialize WorkflowOrchestrator\n        WorkflowOrchestrator orchestrator = new WorkflowOrchestrator();\n        // Define raw data for testing\n        List<string> rawData = new List<string> { \"  data1  \", null, \"  data2\", \" \", \"data3\" };\n        // Perform the orchestration\n", "suffix": "        // Handle any potential errors\n        try\n        {\n            // Orchestrate the workflow\n            List<string> result = orchestrator.OrchestrateWorkflow(rawData);\n            // Assertions to verify the correctness of the cleansed data\n            Debug.Assert(result.Count == 3, \"Expected 3 cleansed data entries.\");\n            Debug.Assert(result[0] == \"data1\", \"Expected 'data1'.\");\n            Debug.Assert(result[1] == \"data2\", \"Expected 'data2'.\");\n            Debug.Assert(result[2] == \"data3\", \"Expected 'data3'.\");\n        }\n        catch (Exception ex)\n        {\n            // Error handling\n            string errorMessage = orchestrator.HandleError(ex);\n            Debug.Assert(!string.IsNullOrEmpty(errorMessage), \"Expected a non-empty error message.\");\n        }\n    }\n}\n", "golden_completion": "        List<string> cleansedData = orchestrator.OrchestrateWorkflow(rawData);\n", "LLM_justification": "This scenario tests the LLM's ability to translate between code and natural language effectively by providing comprehensive documentation for a data transformation and workflow orchestration example. The documentation includes detailed XML comments that describe the methods and parameters, which are essential for understanding the code's functionality. The code implementation handles data cleansing and workflow orchestration, including error handling, which provides a realistic and practical example of business logic. The assertions in the suffix verify the correctness of the cleansed data and the error handling mechanism, ensuring that the generated documentation aligns with the code's functionality.", "assertions": "", "gpt-35-turbo-completions": "// Handle any potential errors\n#TODO: You Code Here\n        // Assertions to verify the correctness of the cleansed data\n#TODO: You Code Here\n    }\n}\n\n// Solution\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BusinessLogicExample\n{\n    public class DataTransformer\n    {\n        /// <summary>\n        /// Cleanses the input data by removing null entries and trimming whitespace.\n        /// </summary>\n        /// <param name=\"inputData\">List of string data to be cleansed.</param>\n        /// <returns>List of cleansed string data.</returns>\n        public List<string> CleanseData(List<string> inputData)\n        {\n            List<string> cleansedData = new List<string>();\n            foreach (var data in inputData)\n            {\n                if (!string.IsNullOrWhiteSpace(data))\n                {\n                    cleansedData.Add(data.Trim());\n                }\n            }\n            return cleansedData;\n        }\n    }\n\n    public class WorkflowOrchestrator\n    {\n        private DataTransformer _dataTransformer;\n\n        public WorkflowOrchestrator()\n        {\n            _dataTransformer = new DataTransformer();\n        }\n\n        /// <summary>\n        /// Orchestrates the workflow of data transformation.\n        /// </summary>\n        /// <param name=\"rawData\">Raw input data for the workflow.</param>\n        /// <returns>Transformed and cleansed data.</returns>\n        public List<string> OrchestrateWorkflow(List<string> rawData)\n        {\n            return _dataTransformer.CleanseData(rawData);\n        }\n\n        /// <summary>\n        /// Handles errors during the workflow orchestration.\n        /// </summary>\n        /// <param name=\"ex\">Exception that occurred.</param>\n        /// <returns>Formatted error message.</returns>\n        public string HandleError(Exception ex)\n        {\n            return $\"Error: {ex.Message}\";\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // Initialize WorkflowOrchestrator\n        WorkflowOrchestrator orchestrator = new WorkflowOrchestrator();\n        // Define raw data for testing\n        List<string> rawData = new List<string> { \"  data1  \", null, \"  data2\", \" \", \"data3\" };\n        // Perform the orchestration"}
