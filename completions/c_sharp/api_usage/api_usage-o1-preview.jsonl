{"id": "1", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing System.Diagnostics;\n\nnamespace ExampleNamespace\n{\n    public class ExampleClass\n    {\n        public class Person\n        {\n            public string Name { get; set; }\n            public int Age { get; set; }\n        }\n\n        public static void Main(string[] args)\n        {\n            // Creating a list of Person objects\n            List<Person> people = new List<Person>\n            {\n                new Person { Name = \"John Doe\", Age = 30 },\n                new Person { Name = \"Jane Smith\", Age = 25 },\n                new Person { Name = \"Samuel Johnson\", Age = 40 }\n            };\n\n            // Serialize the list to JSON string\n            string jsonString = JsonSerializer.Serialize(people);\n            Console.WriteLine(\"Serialized JSON:\");\n            Console.WriteLine(jsonString);\n\n            // Deserialize JSON string back to list of Person objects\n            List<Person> deserializedPeople;\n            try\n            {\n                deserializedPeople = JsonSerializer.Deserialize<List<Person>>(jsonString);\n            }\n            catch (JsonException ex)\n            {\n                Console.WriteLine($\"JSON deserialization error: {ex.Message}\");\n                throw;\n            }\n\n            // Verifying the deserialization result\n            Console.WriteLine(\"Deserialized Objects:\");\n            foreach (var person in deserializedPeople)\n            {\n                Console.WriteLine($\"Name: {person.Name}, Age: {person.Age}\");\n            }\n", "suffix": "            Debug.Assert(deserializedPeople.Count == 3, \"The deserialized list should contain exactly 3 people.\");\n            Debug.Assert(deserializedPeople[0].Name == \"John Doe\" && deserializedPeople[0].Age == 30, \"First person should be John Doe, Age 30.\");\n            Debug.Assert(deserializedPeople[1].Name == \"Jane Smith\" && deserializedPeople[1].Age == 25, \"Second person should be Jane Smith, Age 25.\");\n            Debug.Assert(deserializedPeople[2].Name == \"Samuel Johnson\" && deserializedPeople[2].Age == 40, \"Third person should be Samuel Johnson, Age 40.\");\n        }\n    }\n}\n", "golden_completion": "            deserializedPeople = JsonSerializer.Deserialize<List<Person>>(jsonString);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and correctly use the JsonSerializer API from System.Text.Json, which is less common than other JSON libraries like Newtonsoft.Json. It includes serialization and deserialization of complex objects, proper error handling, and validation of the deserialized data. The assertions check that the deserialization process correctly reconstructs the original list of objects, ensuring parameter correctness and accurate API usage.", "assertions": "", "o1-preview": ""}
{"id": "2", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Diagnostics;\n\nnamespace JsonParsingExample\n{\n    public class Program\n    {\n        public class Person\n        {\n            public string Name { get; set; }\n            public int Age { get; set; }\n        }\n\n        public static void Main(string[] args)\n        {\n            string jsonString = \"[{'Name':'John','Age':30},{'Name':'Jane','Age':25}]\";\n            // Parsing JSON string to a list of Person objects\n            List<Person> people = JsonSerializer.Deserialize<List<Person>>(jsonString, new JsonSerializerOptions\n            {\n                PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n            });\n\n            foreach (var person in people)\n            {\n                Console.WriteLine($\"Name: {person.Name}, Age: {person.Age}\");\n            }\n\n            // Let's now modify one of the objects and re-serialize it\n            people[0].Age = 31;\n", "suffix": "\n\n            // Assertions\n            Debug.Assert(updatedJsonString.Contains(\"31\"), \"Age update failed\");\n            Debug.Assert(updatedJsonString.Contains(\"Jane\"), \"Jane should be present in JSON\");\n        }\n    }\n}\n", "golden_completion": "            // Serialize the list back to JSON string\n            string updatedJsonString = JsonSerializer.Serialize(people, new JsonSerializerOptions\n            {\n                WriteIndented = true\n            });\n\n            Console.WriteLine(\"Updated JSON:\");\n            Console.WriteLine(updatedJsonString);\n", "LLM_justification": "This test case is a good example for testing the model's ability to recognize and complete patterns involving JSON serialization and deserialization using System.Text.Json, a less commonly used .NET Core library function. The scenario demonstrates the conversion of a JSON string to a list of objects and back to a JSON string after modification. It verifies the model's understanding of the proper usage and parameter ordering for JsonSerializer.Deserialize and JsonSerializer.Serialize methods.", "assertions": "", "o1-preview": ""}
{"id": "3", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.ML;\nusing Microsoft.ML.Data;\n\nnamespace MLNetExample\n{\n    public class HouseData\n    {\n        public float Size { get; set; }\n        public float Price { get; set; }\n    }\n\n    public class Prediction\n    {\n        [ColumnName(\"Score\")]\n        public float Price { get; set; }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var mlContext = new MLContext();\n            var data = new List<HouseData>\n            {\n                new HouseData { Size = 1.1F, Price = 1.2F },\n                new HouseData { Size = 1.9F, Price = 2.3F },\n                new HouseData { Size = 2.8F, Price = 3.0F },\n                new HouseData { Size = 3.4F, Price = 3.7F }\n            };\n            var trainingData = mlContext.Data.LoadFromEnumerable(data);\n            var pipeline = mlContext.Transforms.Concatenate(\"Features\", \"Size\")\n                .Append(mlContext.Regression.Trainers.Sdca());\n            var model = pipeline.Fit(trainingData);\n            var predictionEngine = mlContext.Model.CreatePredictionEngine<HouseData, Prediction>(model);\n            var size = new HouseData { Size = 2.5F };\n", "suffix": "\n            Debug.Assert(prediction.Price >= 2.0F && prediction.Price <= 3.5F, \"Prediction out of expected range\");\n\n            Console.WriteLine($\"Predicted price for size {size.Size}: {prediction.Price}\");\n        }\n    }\n}\n", "golden_completion": "            var prediction = predictionEngine.Predict(size);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern using ML.NET, an uncommon library for machine learning in C#. The scenario involves setting up a basic regression model, making predictions, and verifying the results with assertions. The prefix provides extensive context, including data loading, pipeline creation, model training, and prediction engine setup. The completion focuses on the prediction step, while the suffix includes assertions and output. This tests the LLM's understanding of ML.NET's API and proper usage patterns, ensuring the model can correctly predict and verify outcomes in a machine learning context.", "assertions": "", "o1-preview": ""}
{"id": "4", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.ML;\nusing Microsoft.ML.Data;\n\nnamespace MLNetExample\n{\n    public class DataModel\n    {\n        [LoadColumn(0)]\n        public float Feature1;\n        [LoadColumn(1)]\n        public float Feature2;\n        [LoadColumn(2)]\n        public float Label;\n    }\n\n    public class Prediction\n    {\n        [ColumnName(\"Score\")]\n        public float PredictedLabel;\n    }\n\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var mlContext = new MLContext();\n\n            // Load data\n            IDataView dataView = mlContext.Data.LoadFromTextFile<DataModel>(\"data.csv\", separatorChar: ',', hasHeader: true);\n\n            // Split data\n            var trainTestData = mlContext.Data.TrainTestSplit(dataView, testFraction: 0.2);\n            var trainData = trainTestData.TrainSet;\n            var testData = trainTestData.TestSet;\n\n            // Define data preparation and training pipeline\n            var pipeline = mlContext.Transforms.Concatenate(\"Features\", \"Feature1\", \"Feature2\")\n                .Append(mlContext.Transforms.NormalizeMinMax(\"Features\"))\n                .Append(mlContext.Regression.Trainers.Sdca(labelColumnName: \"Label\", maximumNumberOfIterations: 100));\n\n            // Train the model\n            var model = pipeline.Fit(trainData);\n\n            // Evaluate the model\n            var predictions = model.Transform(testData);\n            var metrics = mlContext.Regression.Evaluate(predictions, labelColumnName: \"Label\");\n\n            Console.WriteLine($\"R^2: {metrics.RSquared}\");\n            Console.WriteLine($\"RMS: {metrics.RootMeanSquaredError}\");\n\n            // Use the model for predictions\n            var predictionEngine = mlContext.Model.CreatePredictionEngine<DataModel, Prediction>(model);\n            var input = new DataModel { Feature1 = 1.5f, Feature2 = 2.3f };\n            var prediction = predictionEngine.Predict(input);\n            Console.WriteLine($\"Predicted Label: {prediction.PredictedLabel}\");\n\n            // Save the model\n            mlContext.Model.Save(model, trainData.Schema, \"model.zip\");\n\n            // Load the model\n            ITransformer loadedModel;\n            DataViewSchema modelSchema;\n            using (var fileStream = new FileStream(\"model.zip\", FileMode.Open, FileAccess.Read, FileShare.Read))\n            {\n                loadedModel = mlContext.Model.Load(fileStream, out modelSchema);\n            }\n\n            // Create prediction engine for loaded model\n            var loadedPredictionEngine = mlContext.Model.CreatePredictionEngine<DataModel, Prediction>(loadedModel);\n\n            // Make a single prediction\n            var newInput = new DataModel { Feature1 = 3.0f, Feature2 = 1.0f };\n", "suffix": "\n            Debug.Assert(newPrediction != null, \"Prediction should not be null\");\n            Debug.Assert(newPrediction.PredictedLabel > 0, \"Predicted label should be positive\");\n\n            Console.WriteLine($\"Loaded Model Predicted Label: {newPrediction.PredictedLabel}\");\n        }\n    }\n}\n", "golden_completion": "            var newPrediction = loadedPredictionEngine.Predict(newInput);\n", "LLM_justification": "This test case utilizes the ML.NET library, which is less commonly used compared to more popular machine learning libraries like TensorFlow and PyTorch. The example sets up a full machine learning pipeline from data loading, training, evaluating, saving, and reloading the model, and making predictions. The specific focus on reloading the trained model and ensuring it can still make predictions accurately is a less common but important use case. The assertions ensure that the predictions are valid and that the model behaves correctly after being loaded from disk.", "assertions": "", "o1-preview": ""}
{"id": "5", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Text.Json;\n\nnamespace RareApiUsageExample\n{\n    public class Program\n    {\n        public class Person\n        {\n            public string Name { get; set; }\n            public int Age { get; set; }\n        }\n\n        public static string SerializePerson(Person person)\n        {\n            var options = new JsonSerializerOptions\n            {\n                WriteIndented = true,\n                PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n            };\n            return JsonSerializer.Serialize(person, options);\n        }\n\n        public static Person DeserializePerson(string json)\n        {\n            var options = new JsonSerializerOptions\n            {\n                PropertyNameCaseInsensitive = true\n            };\n            return JsonSerializer.Deserialize<Person>(json, options);\n        }\n\n        public static void Main(string[] args)\n        {\n            var person = new Person { Name = \"John Doe\", Age = 30 };\n            string json = SerializePerson(person);\n            Console.WriteLine(\"Serialized JSON: \" + json);\n", "suffix": "            // Deserialize the JSON string back to a Person object\n            Person deserializedPerson = DeserializePerson(json);\n            Console.WriteLine(\"Deserialized Person: \" + deserializedPerson.Name + \", Age: \" + deserializedPerson.Age);\n\n            // Assertions to verify correctness\n            Debug.Assert(deserializedPerson.Name == \"John Doe\", \"Name should be 'John Doe'\");\n            Debug.Assert(deserializedPerson.Age == 30, \"Age should be 30\");\n\n            // Clean up resources (if any)\n            // In this case, there are no disposable resources\n        }\n    }\n}", "golden_completion": "            json = JsonSerializer.Serialize(person);\n", "LLM_justification": "This example tests the less common usage of the System.Text.Json library, specifically testing the correct serialization and deserialization of objects with various JsonSerializerOptions. The golden completion focuses on the correct parameter ordering and usage of the JsonSerializer.Serialize method. The suffix contains assertions verifying the deserialization correctness and ensuring the API's behavior matches expectations.", "assertions": "", "o1-preview": ""}
{"id": "6", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.ML;\nusing Microsoft.ML.Data;\n\nnamespace MLNetExample\n{\n    public class HouseData\n    {\n        public float Size { get; set; }\n        public float Price { get; set; }\n    }\n\n    public class Prediction\n    {\n        [ColumnName(\"Score\")]\n        public float Price { get; set; }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var mlContext = new MLContext();\n            var houseData = new List<HouseData>\n            {\n                new HouseData { Size = 1.1F, Price = 1.2F },\n                new HouseData { Size = 1.9F, Price = 2.3F },\n                new HouseData { Size = 2.8F, Price = 3.0F },\n                new HouseData { Size = 3.4F, Price = 3.7F }\n            };\n            var trainingData = mlContext.Data.LoadFromEnumerable(houseData);\n            var pipeline = mlContext.Transforms.Concatenate(\"Features\", \"Size\")\n                .Append(mlContext.Regression.Trainers.Sdca());\n            var model = pipeline.Fit(trainingData);\n            var predictionEngine = mlContext.Model.CreatePredictionEngine<HouseData, Prediction>(model);\n            // Check RSquared and MAE\n", "suffix": "            var newHouseData = new HouseData { Size = 2.5F };\n            var prediction = predictionEngine.Predict(newHouseData);\n\n            Debug.Assert(prediction.Price > 0, \"The predicted price should be greater than 0\");\n            Debug.Assert(prediction.Price < 5, \"The predicted price should be less than 5\");\n\n            // Cleanup\n            mlContext.Dispose();\n        }\n    }\n}\n", "golden_completion": "            var transformedData = model.Transform(trainingData);\n            var metrics = mlContext.Regression.Evaluate(transformedData);\n\n            Debug.Assert(metrics.RSquared > 0.5, \"R-squared should be greater than 0.5\");\n            Debug.Assert(metrics.MeanAbsoluteError < 0.5, \"Mean Absolute Error should be less than 0.5\");\n", "LLM_justification": "This example uses ML.NET, a machine learning library in .NET, to build and evaluate a regression model. The example includes uncommon evaluation metrics and setup for a machine learning pipeline, testing the LLM's ability to recognize and complete the pattern correctly. Assertions verify the correctness of the predicted values and evaluation metrics, ensuring the model's performance. The prefix sets up a comprehensive context, while the completion focuses on an uncommon API usage for model evaluation.", "assertions": "", "o1-preview": ""}
{"id": "7", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.ML;\nusing Microsoft.ML.Data;\n\nnamespace MLExample\n{\n    public class HouseData\n    {\n        public float Size { get; set; }\n        public float Price { get; set; }\n    }\n\n    public class Prediction\n    {\n        [ColumnName(\"Score\")]\n        public float Price { get; set; }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var context = new MLContext();\n            var data = new List<HouseData>\n            {\n                new HouseData { Size = 1.1F, Price = 1.2F },\n                new HouseData { Size = 1.9F, Price = 2.3F },\n                new HouseData { Size = 2.8F, Price = 3.0F }\n            };\n\n            var dataView = context.Data.LoadFromEnumerable(data);\n\n            var pipeline = context.Transforms.Concatenate(\"Features\", \"Size\")\n                .Append(context.Regression.Trainers.Sdca(labelColumnName: \"Price\", maximumNumberOfIterations: 100));\n\n            var model = pipeline.Fit(dataView);\n\n            var predictionEngine = context.Model.CreatePredictionEngine<HouseData, Prediction>(model);\n\n            var size = new HouseData { Size = 2.5F };\n\n            var prediction;\n", "suffix": "            Debug.Assert(prediction.Price > 0, \"Prediction price should be greater than 0\");\n\n            Console.WriteLine($\"Predicted price: {prediction.Price}\");\n\n            var modelPath = \"model.zip\";\n            context.Model.Save(model, dataView.Schema, modelPath);\n\n            var loadedModel = context.Model.Load(modelPath, out var modelInputSchema);\n            var loadedPredictionEngine = context.Model.CreatePredictionEngine<HouseData, Prediction>(loadedModel);\n            var loadedPrediction = loadedPredictionEngine.Predict(size);\n\n            Debug.Assert(Math.Abs(loadedPrediction.Price - prediction.Price) < 0.01, \"Loaded model prediction should be close to the original model prediction\");\n\n            Console.WriteLine($\"Loaded model predicted price: {loadedPrediction.Price}\");\n        }\n    }\n}\n", "golden_completion": "            prediction = predictionEngine.Predict(size);\n", "LLM_justification": "This example tests the model's ability to work with the ML.NET library, specifically focusing on the creation and usage of a prediction engine, and the saving and loading of a trained model. It ensures the model can handle ML.NET's uncommon APIs correctly, including proper parameter usage and prediction verification.", "assertions": "", "o1-preview": "prediction = predictionEngine.Predict(size);"}
{"id": "8", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.ML;\nusing Microsoft.ML.Data;\n\nnamespace MachineLearningExample\n{\n    public class HousingData\n    {\n        public float Size { get; set; }\n        public float Price { get; set; }\n    }\n\n    public class HousingPrediction\n    {\n        [ColumnName(\"Score\")]\n        public float Price { get; set; }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var mlContext = new MLContext();\n\n            // Sample data\n            var trainingData = new List<HousingData>\n            {\n                new HousingData { Size = 1.1F, Price = 1.2F },\n                new HousingData { Size = 1.9F, Price = 2.3F },\n                new HousingData { Size = 2.8F, Price = 3.0F },\n                new HousingData { Size = 3.4F, Price = 3.7F }\n            };\n\n            // Convert data to IDataView\n            var trainingDataView = mlContext.Data.LoadFromEnumerable(trainingData);\n\n            // Define data preparation and training pipeline\n            var pipeline = mlContext.Transforms.Concatenate(\"Features\", \"Size\")\n                .Append(mlContext.Regression.Trainers.Sdca(labelColumnName: \"Price\", maximumNumberOfIterations: 100));\n\n            // Train the model\n            var model = pipeline.Fit(trainingDataView);\n\n            // Save the model\n            var modelPath = \"model.zip\";\n            mlContext.Model.Save(model, trainingDataView.Schema, modelPath);\n\n            // Load the model\n            ITransformer loadedModel;\n            DataViewSchema modelSchema;\n            using (var fileStream = new System.IO.FileStream(modelPath, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read))\n            {\n                loadedModel = mlContext.Model.Load(fileStream, out modelSchema);\n            }\n\n            // Create prediction engine\n            var predictionEngine = mlContext.Model.CreatePredictionEngine<HousingData, HousingPrediction>(loadedModel);\n\n            // Predict\n            var size = 2.5F;\n", "suffix": "\n\n            // Assertions\n            Debug.Assert(prediction.Price > 0, \"Price should be greater than 0\");\n            Debug.Assert(prediction.Price < 5, \"Price should be less than 5\");\n\n            Console.WriteLine($\"Predicted price for size {size}: {prediction.Price}\");\n        }\n    }\n}\n", "golden_completion": "            var prediction = predictionEngine.Predict(new HousingData { Size = size });\n", "LLM_justification": "This test case demonstrates the usage of ML.NET, an uncommon machine learning library in C#. The example includes the complete process of defining data classes, preparing training data, creating and training a model, saving and loading the model, and making predictions. The code leverages less common APIs within ML.NET, such as creating a prediction engine and using the Sdca regression trainer. The assertions validate the correctness of the prediction, ensuring the model produces reasonable output, thus covering edge cases in the machine learning pipeline.", "assertions": "", "o1-preview": ""}
{"id": "9", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.ML;\nusing Microsoft.ML.Data;\nusing Microsoft.ML.Transforms;\n\nnamespace MLNetExample\n{\n    public class HousingData\n    {\n        public float Size { get; set; }\n        public float Price { get; set; }\n    }\n\n    public class HousingPrediction\n    {\n        [ColumnName(\"Score\")]\n        public float Price { get; set; }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var context = new MLContext();\n            var data = new List<HousingData>\n            {\n                new HousingData { Size = 1.1F, Price = 1.2F },\n                new HousingData { Size = 1.9F, Price = 2.3F },\n                new HousingData { Size = 2.8F, Price = 3.0F },\n                new HousingData { Size = 3.4F, Price = 3.7F }\n            };\n            var dataView = context.Data.LoadFromEnumerable(data);\n            var pipeline = context.Transforms.Concatenate(\"Features\", \"Size\")\n                .Append(context.Regression.Trainers.Sdca(labelColumnName: \"Price\", maximumNumberOfIterations: 100));\n            var model = pipeline.Fit(dataView);\n\n            var sizeData = new List<HousingData>\n            {\n                new HousingData { Size = 2.5F },\n                new HousingData { Size = 3.0F }\n            };\n            var sizeDataView = context.Data.LoadFromEnumerable(sizeData);\n", "suffix": "\n\n            var enumerator = predictedPrices.GetEnumerator();\n            enumerator.MoveNext();\n            Debug.Assert(Math.Abs(enumerator.Current.Price - 2.7F) < 0.2, \"The predicted price for size 2.5 is incorrect\");\n            enumerator.MoveNext();\n            Debug.Assert(Math.Abs(enumerator.Current.Price - 3.0F) < 0.2, \"The predicted price for size 3.0 is incorrect\");\n            enumerator.Dispose();\n        }\n    }\n}\n", "golden_completion": "            var predictions = model.Transform(sizeDataView);\n            var predictedPrices = context.Data.CreateEnumerable<HousingPrediction>(predictions, reuseRowObject: false);\n", "LLM_justification": "This example tests the LLM's ability to work with the ML.NET library, which is less commonly used compared to other machine learning libraries. The scenario includes setting up a pipeline for regression using the Sdca trainer, transforming data for predictions, and validating predictions with appropriate assertions. This demonstrates understanding of ML.NET's API and handling of predictions.", "assertions": "", "o1-preview": ""}
{"id": "10", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Threading.Channels;\nusing System.Diagnostics;\n\nnamespace ChannelExample\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var cts = new CancellationTokenSource();\n            var token = cts.Token;\n            var channel = Channel.CreateUnbounded<int>();\n            var writer = channel.Writer;\n            var reader = channel.Reader;\n\n            // Start a writer task\n            var writerTask = Task.Run(async () =>\n            {\n                for (int i = 0; i < 10; i++)\n                {\n                    await writer.WriteAsync(i, token);\n                    await Task.Delay(100, token); // simulate work\n                }\n                writer.Complete();\n            }, token);\n\n            // Start a reader task\n            var readerTask = Task.Run(async () =>\n            {\n                await foreach (var item in reader.ReadAllAsync(token))\n                {\n                    Console.WriteLine($\"Read: {item}\");\n                }\n            }, token);\n\n            // Wait for the writer to complete\n            await writerTask;\n\n            // Cancel the reader\n            cts.Cancel();\n\n            // Wait for the reader to complete\n            await readerTask;\n\n            // Create another channel for more complex example\n            var boundedChannel = Channel.CreateBounded<int>(new BoundedChannelOptions(5)\n            {\n                SingleReader = true,\n                SingleWriter = true\n            });\n\n            var boundedWriter = boundedChannel.Writer;\n            var boundedReader = boundedChannel.Reader;\n\n            var boundedWriterTask = Task.Run(async () =>\n            {\n                for (int i = 0; i < 5; i++)\n                {\n                    await boundedWriter.WriteAsync(i, token);\n                    await Task.Delay(100, token); // simulate work\n                }\n                boundedWriter.Complete();\n            }, token);\n", "suffix": "            var boundedReaderTask = Task.Run(async () =>\n            {\n                var items = new List<int>();\n                await foreach (var item in boundedReader.ReadAllAsync(token))\n                {\n                    items.Add(item);\n                }\n                Debug.Assert(items.Count == 5, \"All items should be read\");\n                Debug.Assert(items[0] == 0 && items[4] == 4, \"Items should be read in correct order\");\n            }, token);\n\n            await boundedWriterTask;\n            await boundedReaderTask;\n\n            // Clean up resources\n            cts.Dispose();\n        }\n    }\n}\n", "golden_completion": "            await boundedWriter.WriteAsync(4, token);\n", "LLM_justification": "This test case demonstrates the usage of System.Threading.Channels with bounded channels, which is an uncommon API in concurrent programming. The prefix sets up a context for writing and reading from a channel, while the golden completion involves writing the final element to the channel. The suffix contains assertions to verify the correct behavior of the channel operations, ensuring items are read in the correct order and the expected number of items are processed. This is a good test case for evaluating the model's ability to handle uncommon API usage patterns and parameter correctness in concurrent programming.", "assertions": "", "o1-preview": ""}
{"id": "11", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.ML;\nusing Microsoft.ML.Data;\nusing System.Diagnostics;\n\nnamespace RareApiUsageExample\n{\n    class Program\n    {\n        public class HousingData\n        {\n            public float Size { get; set; }\n            public float Price { get; set; }\n        }\n\n        public class Prediction\n        {\n            [ColumnName(\"Score\")]\n            public float Price { get; set; }\n        }\n\n        static void Main(string[] args)\n        {\n            var context = new MLContext();\n            var data = new List<HousingData>\n            {\n                new HousingData { Size = 1.1F, Price = 1.2F },\n                new HousingData { Size = 1.9F, Price = 2.3F },\n                new HousingData { Size = 2.8F, Price = 3.0F }\n            };\n\n            var dataView = context.Data.LoadFromEnumerable(data);\n            var pipeline = context.Transforms.Concatenate(\"Features\", \"Size\")\n                            .Append(context.Regression.Trainers.Sdca(labelColumnName: \"Price\", maximumNumberOfIterations: 100));\n\n            var model = pipeline.Fit(dataView);\n\n            var predictionFunction = context.Model.CreatePredictionEngine<HousingData, Prediction>(model);\n\n            var sizeToPredict = new HousingData { Size = 2.5F };\n", "suffix": "\n\n            Debug.Assert(predictedPrice != null, \"Prediction should not be null\");\n            Debug.Assert(predictedPrice.Price > 0, \"Predicted price should be greater than zero\");\n\n            Console.WriteLine($\"Predicted price for size {sizeToPredict.Size}: {predictedPrice.Price}\");\n        }\n    }\n}", "golden_completion": "            var predictedPrice = predictionFunction.Predict(sizeToPredict);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving ML.NET, an uncommon library for some developers. It uses the Sdca regression trainer, which may not be as commonly used as other trainers. The pattern includes setting up the ML context, loading data, creating a pipeline, fitting a model, and using a prediction engine. The assertions verify that the prediction is not null and the predicted price is a positive number. This scenario helps ensure the LLM understands the correct usage of ML.NET for regression tasks.", "assertions": "", "o1-preview": ""}
{"id": "12", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing System.Threading.Channels;\n\npublic class ChannelExample {\n    private static async Task Producer(ChannelWriter<int> writer) {\n        for (int i = 0; i < 10; i++) {\n            await writer.WriteAsync(i);\n            await Task.Delay(100); // Simulate some asynchronous work\n        }\n        writer.Complete();\n    }\n\n    private static async Task Consumer(ChannelReader<int> reader) {\n        await foreach (var item in reader.ReadAllAsync()) {\n            Console.WriteLine(item);\n        }\n    }\n\n    public static async Task Main(string[] args) {\n        var channel = Channel.CreateUnbounded<int>();\n        var producerTask = Producer(channel.Writer);\n        var consumerTask = Consumer(channel.Reader);\n        await Task.WhenAll(producerTask, consumerTask);\n    }\n}\n\npublic class TestChannelExample {\n    public static async Task TestProducerConsumer() {\n        var channel = Channel.CreateUnbounded<int>();\n", "suffix": "        // Reading from the channel and validating the output\n        var reader = channel.Reader;\n        var items = new List<int>();\n        await foreach (var item in reader.ReadAllAsync()) {\n            items.Add(item);\n        }\n\n        // Assertions to verify the channel output\n        Debug.Assert(items.Count == 10, \"The number of items produced should be 10.\");\n        for (int i = 0; i < 10; i++) {\n            Debug.Assert(items[i] == i, $\"Expected item {i} but got {items[i]}.\");\n        }\n    }\n}\n\npublic class Program {\n    public static async Task Main(string[] args) {\n        await TestChannelExample.TestProducerConsumer();\n    }\n}\n", "golden_completion": "        await Producer(channel.Writer);\n        await Consumer(channel.Reader);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete patterns involving the System.Threading.Channels library, which is less commonly used compared to other concurrent programming libraries in .NET. The pattern includes creating a producer that writes to a channel and a consumer that reads from it asynchronously. The completion demonstrates correct API usage by handling the producer and consumer tasks properly, ensuring they work together correctly. Assertions validate the behavior and correctness of the channel operations.", "assertions": "", "o1-preview": ""}
{"id": "13", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Azure;\nusing Azure.AI.TextAnalytics;\n\nnamespace RareApiUsageExample\n{\n    public class TextAnalyticsExample\n    {\n        private static readonly string endpoint = \"https://<your-text-analytics-endpoint>.cognitiveservices.azure.com/\";\n        private static readonly string apiKey = \"<your-text-analytics-api-key>\";\n\n        public static async Task Main(string[] args)\n        {\n            TextAnalyticsClient client = new TextAnalyticsClient(new Uri(endpoint), new AzureKeyCredential(apiKey));\n\n            string document = \"The quick brown fox jumps over the lazy dog.\";\n\n            // Call the rare sentiment analysis method\n            var sentiment = await AnalyzeSentimentWithOpinionMiningAsync(client, document);\n            Console.WriteLine($\"Sentiment: {sentiment.Sentiment}\");\n            foreach (var sentence in sentiment.Sentences)\n            {\n                Console.WriteLine($\"Text: {sentence.Text}\");\n                Console.WriteLine($\"Sentiment: {sentence.Sentiment}\");\n                Console.WriteLine($\"Opinions:\");\n                foreach (var opinion in sentence.Opinions)\n                {\n                    Console.WriteLine($\"Target: {opinion.Target.Text}, Sentiment: {opinion.Target.Sentiment}\");\n                    foreach (var assessment in opinion.Assessments)\n                    {\n                        Console.WriteLine($\"Assessment: {assessment.Text}, Sentiment: {assessment.Sentiment}\");\n                    }\n                }\n            }\n        }\n\n        private static async Task<AnalyzeSentimentResult> AnalyzeSentimentWithOpinionMiningAsync(TextAnalyticsClient client, string document)\n        {\n            var options = new AnalyzeSentimentOptions\n            {\n                IncludeOpinionMining = true\n            };\n", "suffix": "\n            Debug.Assert(response.Value.Sentiment == TextSentiment.Mixed || response.Value.Sentiment == TextSentiment.Positive || response.Value.Sentiment == TextSentiment.Negative, \"Sentiment should be valid\");\n            Debug.Assert(response.Value.Sentences.Count > 0, \"There should be at least one sentence in the response\");\n            return response.Value;\n        }\n    }\n}\n", "golden_completion": "            var response = await client.AnalyzeSentimentAsync(document, \"en\", options);\n", "LLM_justification": "This test case demonstrates the usage of the Azure Text Analytics API with the opinion mining feature enabled, which is a less commonly used feature. The completion involves correctly using the AnalyzeSentimentAsync method with the IncludeOpinionMining option set to true. The assertions verify that the response is not null, the sentiment value is valid, and there is at least one sentence in the response, ensuring the method's correctness.", "assertions": "", "o1-preview": ""}
{"id": "14", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Cosmos;\n\nnamespace CosmosDbExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://your-cosmos-db.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"your-primary-key\";\n        private static CosmosClient cosmosClient;\n        private static Database database;\n        private static Container container;\n\n        static async Task Main(string[] args)\n        {\n            try\n            {\n                cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n                database = await cosmosClient.CreateDatabaseIfNotExistsAsync(\"SampleDatabase\");\n                container = await database.CreateContainerIfNotExistsAsync(\"SampleContainer\", \"/partitionKey\");\n\n                await AddItemsToContainerAsync();\n            }\n            finally\n            {\n                cosmosClient?.Dispose();\n            }\n        }\n\n        private static async Task AddItemsToContainerAsync()\n        {\n            var newItem = new { id = \"1\", partitionKey = \"partition1\", name = \"Sample Item\" };\n", "suffix": "            Debug.Assert(result.StatusCode == System.Net.HttpStatusCode.Created, \"Item was not created successfully\");\n\n            var readItem = await container.ReadItemAsync<dynamic>(newItem.id, new PartitionKey(newItem.partitionKey));\n            Debug.Assert(readItem.Resource.name == \"Sample Item\", \"Item name does not match\");\n\n            await container.DeleteItemAsync<dynamic>(newItem.id, new PartitionKey(newItem.partitionKey));\n            Debug.Assert((await container.ReadItemAsync<dynamic>(newItem.id, new PartitionKey(newItem.partitionKey))).StatusCode == System.Net.HttpStatusCode.NotFound, \"Item was not deleted successfully\");\n        }\n    }\n}\n", "golden_completion": "            ItemResponse<dynamic> result = await container.CreateItemAsync(newItem, new PartitionKey(newItem.partitionKey));\n", "LLM_justification": "This example tests the model's ability to complete a task involving the Azure Cosmos DB SDK, an uncommon library for many developers. The scenario includes the creation, validation, and deletion of an item in a Cosmos DB container. The golden completion involves the correct usage of the `CreateItemAsync` method, which is crucial for interacting with Cosmos DB. The prefix sets up the Cosmos DB client, database, and container, and the suffix includes assertions to validate the correct behavior of the API usage, ensuring the item is created, read, and deleted successfully.", "assertions": "", "o1-preview": ""}
{"id": "15", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace TwitterApiExample\n{\n    public class TwitterClient\n    {\n        private readonly HttpClient _httpClient;\n        private readonly string _bearerToken;\n\n        public TwitterClient(string bearerToken)\n        {\n            _httpClient = new HttpClient();\n            _bearerToken = bearerToken;\n        }\n\n        private async Task<string> GetTwitterDataAsync(string url)\n        {\n            var request = new HttpRequestMessage(HttpMethod.Get, url);\n            request.Headers.Add(\"Authorization\", $\"Bearer {_bearerToken}\");\n\n            var response = await _httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n\n            return await response.Content.ReadAsStringAsync();\n        }\n\n        public async Task<List<string>> GetRecentTweetsAsync(string username)\n        {\n            string url = $\"https://api.twitter.com/2/tweets?username={username}\";\n            string jsonResponse = await GetTwitterDataAsync(url);\n\n            // Simulate parsing JSON response\n            List<string> tweets = new List<string>\n            {\n                \"Tweet1 from \" + username,\n                \"Tweet2 from \" + username,\n                \"Tweet3 from \" + username\n            };\n\n            return tweets;\n        }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            string bearerToken = \"YOUR_TWITTER_BEARER_TOKEN\";\n            TwitterClient client = new TwitterClient(bearerToken);\n            List<string> tweets = await client.GetRecentTweetsAsync(\"twitter\");\n", "suffix": "            // Assertions\n            Debug.Assert(tweets.Count == 3, \"Expected 3 tweets.\");\n            Debug.Assert(tweets[0].StartsWith(\"Tweet1 from twitter\"), \"First tweet does not match.\");\n            Debug.Assert(tweets[1].StartsWith(\"Tweet2 from twitter\"), \"Second tweet does not match.\");\n            Debug.Assert(tweets[2].StartsWith(\"Tweet3 from twitter\"), \"Third tweet does not match.\");\n\n            // Cleanup\n            client.Dispose();\n        }\n    }\n}\n", "golden_completion": "            // Simulate fetching tweets for the user\n            await Task.Delay(1000); // Simulate network delay\n            tweets = await client.GetRecentTweetsAsync(\"twitter\");\n", "LLM_justification": "This test case demonstrates the use of the Twitter API to fetch recent tweets for a user using HttpClient. It includes uncommon API usage patterns, such as setting up authorization headers and parsing JSON responses. The example tests the LLM's ability to recognize and continue the pattern of HTTP requests and JSON parsing, and it includes assertions to verify the correctness of the API behavior and parameter handling.", "assertions": "", "o1-preview": ""}
{"id": "16", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nnamespace SemanticKernelExample\n{\n    public class SemanticKernelIntegration\n    {\n        private const string OpenAiApiKey = \"your-openai-api-key\";\n        private const string OpenAiApiUrl = \"https://api.openai.com/v1/engines/davinci-codex/completions\";\n\n        public class OpenAiResponse\n        {\n            [JsonPropertyName(\"id\")]\n            public string Id { get; set; }\n\n            [JsonPropertyName(\"object\")]\n            public string Object { get; set; }\n\n            [JsonPropertyName(\"created\")]\n            public int Created { get; set; }\n\n            [JsonPropertyName(\"model\")]\n            public string Model { get; set; }\n\n            [JsonPropertyName(\"choices\")]\n            public List<Choice> Choices { get; set; }\n        }\n\n        public class Choice\n        {\n            [JsonPropertyName(\"text\")]\n            public string Text { get; set; }\n\n            [JsonPropertyName(\"index\")]\n            public int Index { get; set; }\n\n            [JsonPropertyName(\"logprobs\")]\n            public object Logprobs { get; set; }\n\n            [JsonPropertyName(\"finish_reason\")]\n            public string FinishReason { get; set; }\n        }\n\n        public async Task<string> GetOpenAiResponseAsync(string prompt)\n        {\n            var httpClient = new HttpClient();\n            httpClient.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {OpenAiApiKey}\");\n\n            var requestBody = new\n            {\n                prompt = prompt,\n                max_tokens = 100,\n                n = 1,\n                stop = \"\\n\"\n            };\n\n            var content = new StringContent(JsonSerializer.Serialize(requestBody), System.Text.Encoding.UTF8, \"application/json\");\n            var response = await httpClient.PostAsync(OpenAiApiUrl, content);\n            response.EnsureSuccessStatusCode();\n            var responseString = await response.Content.ReadAsStringAsync();\n\n            var openAiResponse = JsonSerializer.Deserialize<OpenAiResponse>(responseString);\n\n            return openAiResponse.Choices.FirstOrDefault()?.Text;\n        }\n    }\n}\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        var semanticKernelIntegration = new SemanticKernelExample.SemanticKernelIntegration();\n        string prompt = \"Explain the significance of the Turing test.\";\n", "suffix": "        Debug.Assert(!string.IsNullOrEmpty(result), \"The result should not be null or empty.\");\n        Debug.Assert(result.Contains(\"Turing\"), \"The result should contain the word 'Turing'.\");\n        Debug.Assert(result.Length > 10, \"The result should be longer than 10 characters.\");\n\n        Console.WriteLine(\"Assertions passed successfully.\");\n    }\n}\n", "golden_completion": "        string result = await semanticKernelIntegration.GetOpenAiResponseAsync(prompt);\n", "LLM_justification": "This test case evaluates the model's ability to recognize and complete an uncommon API usage pattern involving the .NET SDK for OpenAI. The code demonstrates how to interact with the OpenAI API, parse the response, and assert the validity of the returned data. This is a good test case because it involves asynchronous programming, HTTP requests, JSON serialization, and specific API response handling, which are less commonly used in typical coding scenarios.", "assertions": "", "o1-preview": ""}
{"id": "17", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Microsoft.Azure.Cosmos;\n\nnamespace CosmosDBExample\n{\n    public class CosmosDBHandler\n    {\n        private CosmosClient cosmosClient;\n        private Database database;\n        private Container container;\n        private const string databaseId = \"SampleDatabase\";\n        private const string containerId = \"SampleContainer\";\n\n        public CosmosDBHandler(string endpointUri, string primaryKey)\n        {\n            cosmosClient = new CosmosClient(endpointUri, primaryKey);\n        }\n\n        public async Task InitializeAsync()\n        {\n            database = await cosmosClient.CreateDatabaseIfNotExistsAsync(databaseId);\n            container = await database.CreateContainerIfNotExistsAsync(containerId, \"/partitionKey\");\n        }\n\n        public async Task AddItemAsync<T>(T item, string partitionKey)\n        {\n            await container.CreateItemAsync(item, new PartitionKey(partitionKey));\n        }\n\n        // Prefix ends here\n", "suffix": "        public async Task ReadItemAsync(string id, string partitionKey)\n        {\n            try\n            {\n                ItemResponse<dynamic> response = await container.ReadItemAsync<dynamic>(id, new PartitionKey(partitionKey));\n                Debug.Assert(response.StatusCode == System.Net.HttpStatusCode.OK, \"Item read successfully\");\n                Console.WriteLine($\"Item read: {response.Resource}\");\n            }\n            catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n                Debug.Assert(false, \"Item not found\");\n            }\n        }\n\n        public async Task DeleteItemAsync(string id, string partitionKey)\n        {\n            try\n            {\n                ItemResponse<dynamic> response = await container.DeleteItemAsync<dynamic>(id, new PartitionKey(partitionKey));\n                Debug.Assert(response.StatusCode == System.Net.HttpStatusCode.NoContent, \"Item deleted successfully\");\n            }\n            catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n                Debug.Assert(false, \"Item not found for deletion\");\n            }\n        }\n\n        public void Dispose()\n        {\n            cosmosClient?.Dispose();\n        }\n    }\n\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            string endpointUri = \"your-endpoint-uri\";\n            string primaryKey = \"your-primary-key\";\n\n            CosmosDBHandler handler = new CosmosDBHandler(endpointUri, primaryKey);\n            await handler.InitializeAsync();\n\n            var sampleItem = new { id = \"1\", partitionKey = \"sampleKey\", name = \"Sample Item\" };\n            await handler.AddItemAsync(sampleItem, \"sampleKey\");\n\n            await handler.ReadItemAsync(\"1\", \"sampleKey\");\n            await handler.DeleteItemAsync(\"1\", \"sampleKey\");\n\n            handler.Dispose();\n        }\n    }\n}\n", "golden_completion": "        public async Task UpdateItemAsync<T>(string id, T item, string partitionKey)\n        {\n            try\n            {\n                ItemResponse<T> response = await container.ReplaceItemAsync(item, id, new PartitionKey(partitionKey));\n                Debug.Assert(response.StatusCode == System.Net.HttpStatusCode.OK, \"Item updated successfully\");\n            }\n            catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n                Debug.Assert(false, \"Item not found for update\");\n            }\n        }\n", "LLM_justification": "This test case demonstrates the usage of the Azure Cosmos DB SDK for .NET, which is not a commonly used API. The focus is on testing the ability of the model to recognize and correctly implement operations such as updating an item in the Cosmos DB container. The prefix sets up the Cosmos DB client and necessary methods, while the golden completion adds the item update functionality. The suffix includes assertions to verify the behavior of the API calls, ensuring the model understands the correct parameter ordering and handles exceptions appropriately.", "assertions": "", "o1-preview": ""}
{"id": "18", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Azure.Cosmos;\n\nnamespace CosmosDBExample\n{\n    public class Program\n    {\n        private static readonly string EndpointUri = \"https://your-cosmos-db.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"your-primary-key\";\n        private static CosmosClient cosmosClient;\n        private static Database database;\n        private static Container container;\n        private const string DatabaseId = \"SampleDatabase\";\n        private const string ContainerId = \"SampleContainer\";\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                // Initialize Cosmos Client\n                cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n                await CreateDatabaseAsync();\n                await CreateContainerAsync();\n\n                // Add an item to the container\n                var sampleItem = new SampleItem { Id = \"1\", Name = \"Item1\", Description = \"This is a sample item.\" };\n                await AddItemToContainerAsync(sampleItem);\n\n                // Fetch the item from the container\n", "suffix": "                Debug.Assert(fetchedItem != null, \"Fetched item should not be null\");\n                Debug.Assert(fetchedItem.Id == \"1\", \"Fetched item ID should be '1'\");\n                Debug.Assert(fetchedItem.Name == \"Item1\", \"Fetched item Name should be 'Item1'\");\n                Debug.Assert(fetchedItem.Description == \"This is a sample item.\", \"Fetched item Description should be 'This is a sample item.'\");\n            }\n            finally\n            {\n                cosmosClient?.Dispose();\n            }\n        }\n\n        private static async Task CreateDatabaseAsync()\n        {\n            database = await cosmosClient.CreateDatabaseIfNotExistsAsync(DatabaseId);\n            Debug.Assert(database != null, \"Database should be created\");\n        }\n\n        private static async Task CreateContainerAsync()\n        {\n            container = await database.CreateContainerIfNotExistsAsync(ContainerId, \"/id\");\n            Debug.Assert(container != null, \"Container should be created\");\n        }\n\n        private static async Task AddItemToContainerAsync(SampleItem item)\n        {\n            await container.CreateItemAsync(item, new PartitionKey(item.Id));\n        }\n\n        private static async Task<SampleItem> GetItemFromContainerAsync(string id)\n        {\n            ItemResponse<SampleItem> response = await container.ReadItemAsync<SampleItem>(id, new PartitionKey(id));\n            return response.Resource;\n        }\n    }\n\n    public class SampleItem\n    {\n        public string Id { get; set; }\n        public string Name { get; set; }\n        public string Description { get; set; }\n    }\n}\n", "golden_completion": "                var fetchedItem = await GetItemFromContainerAsync(\"1\");\n", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use the Azure Cosmos DB SDK for .NET, an uncommon API for many developers. It checks the proper usage of async methods for creating a database, container, adding items, and reading items from the container. The example includes necessary assertions to verify the correct behavior of the API and ensures that resources are properly cleaned up. The pattern of using async/await with Cosmos DB SDK is clearly established, making it a good test case for recognizing and continuing the API usage.", "assertions": "", "o1-preview": ""}
{"id": "19", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Cosmos;\n\nnamespace AzureCosmosDBExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private CosmosClient cosmosClient;\n        private Database database;\n        private Container container;\n        private string databaseId = \"SampleDB\";\n        private string containerId = \"SampleContainer\";\n\n        public async Task InitializeAsync()\n        {\n            this.cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n            this.database = await this.cosmosClient.CreateDatabaseIfNotExistsAsync(databaseId);\n            this.container = await this.database.CreateContainerIfNotExistsAsync(containerId, \"/partitionKey\");\n        }\n\n        public async Task AddItemToContainerAsync()\n        {\n            var item = new { id = Guid.NewGuid().ToString(), partitionKey = \"samplePartition\", name = \"Sample Item\", description = \"This is a sample item\" };\n            try\n            {\n                ItemResponse<dynamic> response = await this.container.CreateItemAsync<dynamic>(item, new PartitionKey(item.partitionKey));\n                Console.WriteLine(\"Created item in database with id: {0}\", item.id);\n                Debug.Assert(response.StatusCode == System.Net.HttpStatusCode.Created, \"Item creation failed\");\n            }\n            catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.Conflict)\n            {\n                Console.WriteLine(\"Item with id: {0} already exists\", item.id);\n            }\n        }\n\n        static async Task Main(string[] args)\n        {\n            Program program = new Program();\n            await program.InitializeAsync();\n", "suffix": "\n\n            // Verify that the item exists in the container\n            var sqlQueryText = \"SELECT * FROM c WHERE c.partitionKey = 'samplePartition'\";\n            QueryDefinition queryDefinition = new QueryDefinition(sqlQueryText);\n            FeedIterator<dynamic> queryResultSetIterator = program.container.GetItemQueryIterator<dynamic>(queryDefinition);\n\n            while (queryResultSetIterator.HasMoreResults)\n            {\n                FeedResponse<dynamic> currentResultSet = await queryResultSetIterator.ReadNextAsync();\n                foreach (var item in currentResultSet)\n                {\n                    Debug.Assert(item.name == \"Sample Item\", \"Item name does not match\");\n                    Debug.Assert(item.description == \"This is a sample item\", \"Item description does not match\");\n                }\n            }\n\n            // Clean up resources\n            if (program.container != null) await program.container.DeleteContainerAsync();\n            if (program.database != null) await program.database.DeleteAsync();\n            if (program.cosmosClient != null) program.cosmosClient.Dispose();\n        }\n    }\n}\n", "golden_completion": "            await program.AddItemToContainerAsync();\n", "LLM_justification": "This test case demonstrates the use of Azure Cosmos DB SDK to create and query items in a container. The example provides a clear pattern of initializing the client, creating a database and container, adding an item, and querying the item. It tests the model's ability to recognize and properly use Azure Cosmos DB's API, handle exceptions, and verify results using assertions. The pattern includes correct parameter ordering, resource cleanup, and exception handling, which are crucial for robust cloud service integration.", "assertions": "", "o1-preview": ""}
{"id": "20", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Diagnostics;\nusing MongoDB.Bson;\nusing MongoDB.Driver;\n\nnamespace MongoDBExample\n{\n    public class MongoDBTest\n    {\n        private readonly IMongoCollection<BsonDocument> _collection;\n\n        public MongoDBTest()\n        {\n            var client = new MongoClient(\"mongodb://localhost:27017\");\n            var database = client.GetDatabase(\"testdb\");\n            _collection = database.GetCollection<BsonDocument>(\"testcollection\");\n        }\n\n        public void InsertDocument()\n        {\n            var document = new BsonDocument\n            {\n                { \"name\", \"test\" },\n                { \"value\", 1 }\n            };\n            _collection.InsertOne(document);\n        }\n\n        public List<BsonDocument> FindDocuments()\n        {\n            return _collection.Find(new BsonDocument()).ToList();\n        }\n\n        public void TestCRUDOperations()\n        {\n            // Insert a document\n            InsertDocument();\n\n            // Find documents\n            var documents = FindDocuments();\n            Debug.Assert(documents.Count > 0, \"Documents should be present after insertion\");\n\n            // Update document by setting 'value' to 2 where 'name' is 'test'\n", "suffix": "\n\n            // Verify update\n            Debug.Assert(updatedDocument != null && updatedDocument[\"value\"] == 2, \"Document should be updated to value 2\");\n\n            // Delete document\n            _collection.DeleteOne(new BsonDocument(\"name\", \"test\"));\n\n            // Verify deletion\n            var deletedDocument = _collection.Find(new BsonDocument(\"name\", \"test\")).FirstOrDefault();\n            Debug.Assert(deletedDocument == null, \"Document should be deleted\");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var test = new MongoDBTest();\n            test.TestCRUDOperations();\n        }\n    }\n}\n", "golden_completion": "            _collection.UpdateOne(new BsonDocument(\"name\", \"test\"), update);\n\n            // Verify update\n            var updatedDocument = _collection.Find(new BsonDocument(\"name\", \"test\")).FirstOrDefault();\n", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use MongoDB's .NET driver for CRUD operations. MongoDB APIs are less commonly used compared to other database interfaces like Entity Framework or Dapper, making this a good test case for rare API usage. The completion involves updating a document and verifying the update, which is a critical part of the CRUD operations. The assertions ensure the update operation is correctly implemented and validated, testing the model's understanding of both the API and the logical flow of operations.", "assertions": "", "o1-preview": ""}
{"id": "21", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\n\nnamespace WebApiIntegrationExample\n{\n    public class GitHubApiClient\n    {\n        private static readonly HttpClient client = new HttpClient();\n\n        public GitHubApiClient()\n        {\n            client.BaseAddress = new Uri(\"https://api.github.com/\");\n            client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"Mozilla\", \"5.0\"));\n        }\n\n        public async Task<string> GetUserRepositoriesAsync(string username)\n        {\n            if (string.IsNullOrEmpty(username))\n            {\n                throw new ArgumentException(\"Username cannot be null or empty.\", nameof(username));\n            }\n\n            HttpResponseMessage response = await client.GetAsync($\"users/{username}/repos\");\n            response.EnsureSuccessStatusCode();\n\n            return await response.Content.ReadAsStringAsync();\n        }\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                var gitHubClient = new GitHubApiClient();\n                string username = \"octocat\";\n", "suffix": "                // Verify that the response contains repositories\n                Debug.Assert(!string.IsNullOrEmpty(repos), \"The response should contain repository data.\");\n\n                // Additional test for another user\n                string anotherUsername = \"torvalds\";\n                string anotherRepos = await gitHubClient.GetUserRepositoriesAsync(anotherUsername);\n\n                Debug.Assert(!string.IsNullOrEmpty(anotherRepos), \"The response should contain repository data for another user.\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"An error occurred: {ex.Message}\");\n            }\n        }\n    }\n}\n", "golden_completion": "                string repos = await gitHubClient.GetUserRepositoriesAsync(username);\n", "LLM_justification": "This example tests the large language model's ability to recognize and complete patterns in C# code involving the integration with the GitHub API using HttpClient. The prefix sets up the context by defining a GitHubApiClient class with a method to fetch user repositories. The golden completion involves invoking the method to get repositories for a specific user. The suffix contains assertions to validate the response and additional tests for robustness. This scenario tests rare API usage capabilities and ensures proper handling of HttpClient interactions.", "assertions": "", "o1-preview": ""}
{"id": "22", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Azure.Identity;\nusing Azure.Security.KeyVault.Secrets;\n\nnamespace KeyVaultExample\n{\n    class Program\n    {\n        private static async Task Main(string[] args)\n        {\n            // Initialize KeyVault client\n            var client = new SecretClient(new Uri(\"https://your-keyvault-name.vault.azure.net/\"), new DefaultAzureCredential());\n\n            // Simulate configuration loading from KeyVault\n            var secretName = \"MySecret\";\n            KeyVaultSecret secret = null;\n            try\n            {\n                secret = await client.GetSecretAsync(secretName);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error retrieving secret: {ex.Message}\");\n            }\n\n            // Ensure secret was retrieved\n            if (secret != null)\n            {\n                Console.WriteLine($\"Secret {secretName} retrieved with value: {secret.Value}\");\n            }\n            else\n            {\n                Console.WriteLine($\"Failed to retrieve secret {secretName}\");\n            }\n\n            // Placeholder for additional logic using the secret value\n            // ...\n\n            // Now let's update the secret value\n            string newSecretValue = \"UpdatedSecretValue\";\n", "suffix": "            // Assertions\n            Debug.Assert(updatedSecret != null, \"Updated secret should not be null\");\n            Debug.Assert(updatedSecret.Value == newSecretValue, \"Updated secret value should match the new value\");\n\n            // Cleanup\n            try\n            {\n                await client.StartDeleteSecretAsync(secretName);\n                Console.WriteLine($\"Secret {secretName} deleted\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error deleting secret: {ex.Message}\");\n            }\n        }\n    }\n}\n", "golden_completion": "            KeyVaultSecret updatedSecret = null;\n            try\n            {\n                updatedSecret = await client.SetSecretAsync(secretName, newSecretValue);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Error updating secret: {ex.Message}\");\n            }\n", "LLM_justification": "This test case demonstrates the usage of the Azure KeyVault client to retrieve, update, and delete secrets. It includes error handling and assertions to ensure the secret was updated correctly. This scenario tests the LLM's ability to recognize and complete the pattern involving asynchronous API calls and proper exception handling, as well as verifying the updated value through assertions. The suffix includes assertions placed directly after the code being tested and proper cleanup of resources, ensuring the overall correctness and robustness of the example.", "assertions": "", "o1-preview": ""}
{"id": "23", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Azure.Documents.Client;\nusing System.Diagnostics;\n\nnamespace AzureCosmosDBExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-cosmos-db-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private DocumentClient client;\n\n        static async Task Main(string[] args)\n        {\n            Program p = new Program();\n            p.client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            await p.InitializeDatabaseAsync();\n        }\n\n        private async Task InitializeDatabaseAsync()\n        {\n            string databaseId = \"TestDatabase\";\n            string collectionId = \"TestCollection\";\n            await this.client.CreateDatabaseIfNotExistsAsync(new Database { Id = databaseId });\n            await this.client.CreateDocumentCollectionIfNotExistsAsync(UriFactory.CreateDatabaseUri(databaseId), new DocumentCollection { Id = collectionId });\n\n            // Insert a document into the collection\n            dynamic document = new { id = Guid.NewGuid().ToString(), Name = \"Azure Cosmos DB\" };\n            ResourceResponse<Document> response = await this.client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri(databaseId, collectionId), document);\n\n            // Retrieve the document we just created\n            Uri documentUri = UriFactory.CreateDocumentUri(databaseId, collectionId, document.id);\n", "suffix": "\n\n            // Assertions\n            Debug.Assert(retrievedDocument != null, \"Document should not be null\");\n            Debug.Assert(retrievedDocument.GetPropertyValue<string>(\"Name\") == \"Azure Cosmos DB\", \"Document should have correct 'Name' property\");\n\n            // Clean up resources\n            await this.client.DeleteDocumentAsync(documentUri);\n            await this.client.DeleteDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri(databaseId, collectionId));\n            await this.client.DeleteDatabaseAsync(UriFactory.CreateDatabaseUri(databaseId));\n        }\n    }\n}\n", "golden_completion": "            Document retrievedDocument = await this.client.ReadDocumentAsync(documentUri);\n", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use the Azure Cosmos DB .NET SDK, specifically focusing on creating, reading, and deleting documents in a Cosmos DB collection. The example includes uncommon API usage patterns such as resource cleanup and proper parameter handling. Assertions are used to verify the correctness of the document properties, and resource cleanup ensures no leftover resources in the database.", "assertions": "", "o1-preview": ""}
{"id": "24", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\n\nnamespace DeprecatedApiExample\n{\n    public class FileReader\n    {\n        private static readonly string filePath = \"data.json\";\n\n        public static async Task<Dictionary<string, string>> ReadDataFromFileAsync()\n        {\n            if (!File.Exists(filePath))\n            {\n                throw new FileNotFoundException($\"The file {filePath} does not exist.\");\n            }\n\n            string jsonData;\n            using (var reader = new StreamReader(filePath))\n            {\n                jsonData = await reader.ReadToEndAsync();\n            }\n\n            // Deserialize JSON to Dictionary\n            return DeserializeJson(jsonData);\n        }\n\n        private static Dictionary<string, string> DeserializeJson(string json)\n        {\n            // Use old API method for deserialization\n", "suffix": "\n            Debug.Assert(result != null, \"Deserialization returned null.\");\n            Debug.Assert(result.Count > 0, \"Deserialized dictionary is empty.\");\n            return result;\n        }\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                var data = await ReadDataFromFileAsync();\n                Debug.Assert(data.ContainsKey(\"exampleKey\"), \"Key 'exampleKey' is missing in the data.\");\n                Debug.Assert(data[\"exampleKey\"] == \"exampleValue\", \"Value for 'exampleKey' does not match.\");\n            }\n            catch (Exception ex)\n            {\n                Debug.Assert(false, $\"Exception thrown: {ex.Message}\");\n            }\n        }\n    }\n}\n", "golden_completion": "            var result = JsonConvert.DeserializeObject<Dictionary<string, string>>(json);\n", "LLM_justification": "This example tests the LLM's ability to recognize and correctly use a deprecated API method from Newtonsoft.Json (JsonConvert.DeserializeObject) to deserialize JSON data into a Dictionary. The prefix sets up the context of reading a JSON file asynchronously and prepares for deserialization. The completion requires the LLM to use the correct method and return type. The suffix includes assertions to ensure the deserialization works as expected and the data contains specific keys and values, which verifies the API usage and parameter handling.", "assertions": "", "o1-preview": ""}
{"id": "25", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Cosmos;\n\nnamespace AzureCosmosDBExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private CosmosClient cosmosClient;\n        private Database database;\n        private Container container;\n        private string databaseId = \"SampleDB\";\n        private string containerId = \"SampleContainer\";\n\n        public async Task InitializeCosmosAsync()\n        {\n            cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n            database = await cosmosClient.CreateDatabaseIfNotExistsAsync(databaseId);\n            container = await database.CreateContainerIfNotExistsAsync(containerId, \"/id\");\n        }\n\n        public async Task AddItemToContainerAsync<T>(T item)\n        {\n            try\n            {\n                ItemResponse<T> response = await container.CreateItemAsync(item, new PartitionKey(item.GetType().GetProperty(\"id\").GetValue(item, null).ToString()));\n                Console.WriteLine(\"Item added with status code: \" + response.StatusCode);\n            }\n            catch (CosmosException ex)\n            {\n                Console.WriteLine($\"Cosmos DB Exception with status code: {ex.StatusCode}\");\n            }\n        }\n\n        public async Task QueryItemsAsync(string queryString)\n        {\n            var query = container.GetItemQueryIterator<dynamic>(new QueryDefinition(queryString));\n            while (query.HasMoreResults)\n            {\n                foreach (var item in await query.ReadNextAsync())\n                {\n                    Console.WriteLine(item);\n                }\n            }\n        }\n\n        static async Task Main(string[] args)\n        {\n            Program p = new Program();\n            await p.InitializeCosmosAsync();\n            var newItem = new { id = Guid.NewGuid().ToString(), Name = \"Test Item\", Description = \"Description of test item\" };\n            await p.AddItemToContainerAsync(newItem);\n", "suffix": "            string queryString = \"SELECT * FROM c WHERE c.id = @id\";\n            var query = p.container.GetItemQueryIterator<dynamic>(new QueryDefinition(queryString).WithParameter(\"@id\", newItem.id));\n            while (query.HasMoreResults)\n            {\n                foreach (var item in await query.ReadNextAsync())\n                {\n                    Debug.Assert(item.id == newItem.id, \"Queried item id does not match\");\n                    Debug.Assert(item.Name == newItem.Name, \"Queried item name does not match\");\n                }\n            }\n\n            p.cosmosClient.Dispose();\n        }\n    }\n}\n", "golden_completion": "            await p.QueryItemsAsync(\"SELECT * FROM c WHERE c.id = '\" + newItem.id + \"'\");\n", "LLM_justification": "This example demonstrates the usage of the Azure Cosmos DB SDK, which is a less commonly used API in the .NET ecosystem. The example includes initializing the Cosmos DB client, creating a database and container, adding an item to the container, and querying items from the container. The completion requires the model to understand the Cosmos DB query syntax and correctly form a query string. Assertions check the integrity of the data after querying to ensure the item was added and retrieved correctly.", "assertions": "", "o1-preview": ""}
{"id": "26", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Net.Http;\n\nnamespace GitHubApiIntegration\n{\n    public class GitHubClient\n    {\n        private readonly HttpClient _httpClient;\n\n        public GitHubClient(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        public async Task<string> GetRepositoryAsync(string owner, string repo)\n        {\n            var requestUrl = $\"https://api.github.com/repos/{owner}/{repo}\";\n            var request = new HttpRequestMessage(HttpMethod.Get, requestUrl);\n            request.Headers.Add(\"User-Agent\", \"HttpClientFactory-Sample\");\n            var response = await _httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n            var content = await response.Content.ReadAsStringAsync();\n            return content;\n        }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var client = new HttpClient();\n            var gitHubClient = new GitHubClient(client);\n            try\n            {\n                // Get repository details\n                string repoDetails = await gitHubClient.GetRepositoryAsync(\"dotnet\", \"runtime\");\n                Console.WriteLine(repoDetails);\n                // Print the repo name and owner\n", "suffix": "                Debug.Assert(!string.IsNullOrEmpty(repoDetails), \"Repository details should not be empty\");\n                Debug.Assert(repoDetails.Contains(\"dotnet\"), \"Repository details should contain 'dotnet'\");\n                Debug.Assert(repoDetails.Contains(\"runtime\"), \"Repository details should contain 'runtime'\");\n            }\n            finally\n            {\n                client.Dispose();\n            }\n        }\n    }\n}\n", "golden_completion": "\n                var repoData = Newtonsoft.Json.Linq.JObject.Parse(repoDetails);\n                var repoName = repoData[\"name\"].ToString();\n                var repoOwner = repoData[\"owner\"][\"login\"].ToString();\n                Console.WriteLine($\"Repository Name: {repoName}\");\n                Console.WriteLine($\"Repository Owner: {repoOwner}\");\n", "LLM_justification": "This example demonstrates the use of the HttpClient class to interact with the GitHub API, which is a relatively rare and domain-specific API usage scenario. It tests the LLM's ability to correctly use the HttpClient for making web requests, handling JSON responses, and performing assertions to verify the correctness of the data retrieved. The scenario also includes proper resource cleanup and error handling, which are important best practices in API usage.", "assertions": "", "o1-preview": ""}
{"id": "27", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Cosmos;\n\nnamespace AzureCosmosDBExample\n{\n    public class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-cosmos-db-uri>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private static CosmosClient cosmosClient;\n        private static Database database;\n        private static Container container;\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n                database = await cosmosClient.CreateDatabaseIfNotExistsAsync(\"ExampleDatabase\");\n                container = await database.CreateContainerIfNotExistsAsync(\"ExampleContainer\", \"/partitionKey\");\n\n                await AddItemsToContainerAsync();\n            }\n            finally\n            {\n                if (cosmosClient != null)\n                {\n                    cosmosClient.Dispose();\n                }\n            }\n        }\n\n        private static async Task AddItemsToContainerAsync()\n        {\n            var items = new List<dynamic>\n            {\n                new { id = \"1\", Name = \"Item1\", Description = \"Description for Item1\", partitionKey = \"Item1\" },\n                new { id = \"2\", Name = \"Item2\", Description = \"Description for Item2\", partitionKey = \"Item2\" }\n            };\n", "suffix": "            Debug.Assert(response1.StatusCode == System.Net.HttpStatusCode.Created, \"Item 1 was not created successfully\");\n            Debug.Assert(response2.StatusCode == System.Net.HttpStatusCode.Created, \"Item 2 was not created successfully\");\n            Debug.Assert(response1.Resource.id == \"1\", \"Item 1 ID mismatch\");\n            Debug.Assert(response2.Resource.id == \"2\", \"Item 2 ID mismatch\");\n        }\n    }\n}\n", "golden_completion": "            ItemResponse<dynamic> response1 = await container.CreateItemAsync(items[0], new PartitionKey(items[0].partitionKey));\n            ItemResponse<dynamic> response2 = await container.CreateItemAsync(items[1], new PartitionKey(items[1].partitionKey));\n", "LLM_justification": "This test case demonstrates the usage of the Azure Cosmos DB SDK for creating items in a container. The prefix sets up the Cosmos client, database, and container, while the completion involves creating items in the container using the CreateItemAsync method. The suffix includes assertions to verify that the items were created successfully and that their IDs match the expected values. This scenario tests the model's understanding of the Azure Cosmos DB SDK, proper parameter ordering, and handling of asynchronous operations. The use of Debug.Assert ensures that the assertions will pass if the API is used correctly.", "assertions": "", "o1-preview": ""}
{"id": "28", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing MongoDB.Bson;\nusing MongoDB.Driver;\n\nnamespace MongoDBExample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var connectionString = \"mongodb://localhost:27017\";\n            var client = new MongoClient(connectionString);\n            var database = client.GetDatabase(\"testdb\");\n            var collection = database.GetCollection<BsonDocument>(\"testcollection\");\n\n            // Insert a sample document\n            var document = new BsonDocument\n            {\n                { \"name\", \"John Doe\" },\n                { \"age\", 30 },\n                { \"city\", \"New York\" }\n            };\n            collection.InsertOne(document);\n\n            // Retrieve the document\n            var filter = Builders<BsonDocument>.Filter.Eq(\"name\", \"John Doe\");\n            var result = collection.Find(filter).FirstOrDefault();\n            Console.WriteLine(result.ToString());\n\n            // Update the document\n            var update = Builders<BsonDocument>.Update.Set(\"age\", 31);\n            collection.UpdateOne(filter, update);\n\n            // Retrieve the updated document\n", "suffix": "            // Verify the update\n            var updatedAge = result[\"age\"].AsInt32;\n            Debug.Assert(updatedAge == 31, \"The age should be updated to 31\");\n\n            // Clean up by deleting the document\n            collection.DeleteOne(filter);\n\n            // Ensure the document is deleted\n            var deletedResult = collection.Find(filter).FirstOrDefault();\n            Debug.Assert(deletedResult == null, \"The document should be deleted\");\n        }\n    }\n}\n", "golden_completion": "            result = collection.Find(filter).FirstOrDefault();\n", "LLM_justification": "This test case involves using the MongoDB .NET driver to perform common database operations such as inserting, retrieving, updating, and deleting documents. It tests the model's understanding of MongoDB's API patterns, parameter ordering, and correct usage of the MongoDB driver. The example also includes assertions to verify the correctness of the operations, making it a comprehensive test for rare API usage capabilities.", "assertions": "", "o1-preview": ""}
{"id": "29", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Xml;\nusing System.Xml.Serialization;\n\nnamespace RareApiUsageExample\n{\n    public class Person\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n    }\n\n    public class Program\n    {\n        private static void SerializePersonListToXml(List<Person> people, string filePath)\n        {\n            XmlSerializer serializer = new XmlSerializer(typeof(List<Person>));\n            using (FileStream fs = new FileStream(filePath, FileMode.Create))\n            {\n                serializer.Serialize(fs, people);\n            }\n        }\n\n        private static List<Person> DeserializePersonListFromXml(string filePath)\n        {\n            XmlSerializer serializer = new XmlSerializer(typeof(List<Person>));\n            using (FileStream fs = new FileStream(filePath, FileMode.Open))\n            {\n                return (List<Person>)serializer.Deserialize(fs);\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            string xmlFilePath = \"people.xml\";\n            List<Person> people = new List<Person>\n            {\n                new Person { Name = \"Alice\", Age = 30 },\n                new Person { Name = \"Bob\", Age = 25 }\n            };\n            SerializePersonListToXml(people, xmlFilePath);\n\n            // Print the name and age of each person\n", "suffix": "            List<Person> deserializedPeople = DeserializePersonListFromXml(xmlFilePath);\n            Debug.Assert(deserializedPeople.Count == 2, \"Deserialized people count should be 2\");\n            Debug.Assert(deserializedPeople[0].Name == \"Alice\", \"First person's name should be Alice\");\n            Debug.Assert(deserializedPeople[0].Age == 30, \"First person's age should be 30\");\n            Debug.Assert(deserializedPeople[1].Name == \"Bob\", \"Second person's name should be Bob\");\n            Debug.Assert(deserializedPeople[1].Age == 25, \"Second person's age should be 25\");\n\n            // Cleanup\n            if (File.Exists(xmlFilePath))\n            {\n                File.Delete(xmlFilePath);\n            }\n        }\n    }\n}\n", "golden_completion": "            XmlDocument xmlDoc = new XmlDocument();\n            xmlDoc.Load(xmlFilePath);\n            XmlNodeList nodes = xmlDoc.SelectNodes(\"//Person\");\n            foreach (XmlNode node in nodes)\n            {\n                Console.WriteLine($\"Name: {node[\"Name\"].InnerText}, Age: {node[\"Age\"].InnerText}\");\n            }\n", "LLM_justification": "This example tests the model's ability to work with the XmlDocument class, an uncommon but valid API for XML manipulation. The XmlDocument class is part of the .NET Framework and provides a way to work with XML data using the DOM (Document Object Model) approach. The example includes serialization and deserialization of a list of custom objects (Person) to and from an XML file, and demonstrates how to read and query the XML file using XmlDocument. The test ensures that the model recognizes the pattern of loading an XML file, selecting nodes, and accessing their values, which is critical for working with XML in legacy systems or specific scenarios where XmlDocument is preferred.", "assertions": "", "o1-preview": ""}
{"id": "30", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Azure.Identity;\nusing Azure.Storage.Blobs;\n\nnamespace AzureBlobStorageExample\n{\n    class Program\n    {\n        private static string connectionString = \"Your_Azure_Storage_Connection_String\";\n        private static string containerName = \"example-container\";\n        private static string blobName = \"example-blob.txt\";\n        private static string localFilePath = \"./example-blob.txt\";\n\n        static async Task Main(string[] args)\n        {\n            BlobServiceClient blobServiceClient = new BlobServiceClient(connectionString);\n            BlobContainerClient containerClient = await blobServiceClient.CreateBlobContainerAsync(containerName);\n            BlobClient blobClient = containerClient.GetBlobClient(blobName);\n\n            // Upload a local file to the blob\n            Console.WriteLine(\"Uploading to Blob storage as blob:\\n\\t\" + blobClient.Uri);\n            using (FileStream uploadFileStream = File.OpenRead(localFilePath))\n            {\n                await blobClient.UploadAsync(uploadFileStream, true);\n            }\n\n            // Download the blob to a local file\n            string downloadFilePath = localFilePath.Replace(\".txt\", \"_DOWNLOADED.txt\");\n            Console.WriteLine(\"Downloading blob to\\n\\t\" + downloadFilePath);\n\n            // Function to download the blob\n", "suffix": "            using (FileStream downloadFileStream = File.OpenWrite(downloadFilePath))\n            {\n                await blobClient.DownloadToAsync(downloadFileStream);\n            }\n\n            // Verify the downloaded file exists\n            Debug.Assert(File.Exists(downloadFilePath), \"Downloaded file does not exist.\");\n\n            // Verify the contents of the downloaded file\n            string originalContent = File.ReadAllText(localFilePath);\n            string downloadedContent = File.ReadAllText(downloadFilePath);\n            Debug.Assert(originalContent == downloadedContent, \"The contents of the downloaded file do not match the original.\");\n\n            // Clean up resources\n            await containerClient.DeleteIfExistsAsync();\n            File.Delete(downloadFilePath);\n            Console.WriteLine(\"Completed successfully.\");\n        }\n    }\n}\n", "golden_completion": "            await blobClient.DownloadToAsync(downloadFilePath);\n", "LLM_justification": "This scenario demonstrates the rare use of Azure Blob Storage SDK to perform file upload and download operations, including proper resource cleanup and verification of the file contents. It tests the LLM's ability to recognize and correctly complete the pattern of blob storage operations, ensuring that the downloaded file matches the uploaded content.", "assertions": "", "o1-preview": ""}
{"id": "31", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Threading.Tasks;\n\npublic class FileProcessor\n{\n    private readonly string _inputFilePath;\n    private readonly string _outputFilePath;\n\n    public FileProcessor(string inputFilePath, string outputFilePath)\n    {\n        _inputFilePath = inputFilePath;\n        _outputFilePath = outputFilePath;\n    }\n\n    public async Task ProcessFileAsync()\n    {\n        try\n        {\n            var lines = await ReadLinesAsync();\n            var processedLines = new List<string>();\n\n            foreach (var line in lines)\n            {\n                processedLines.Add(ProcessLine(line));\n            }\n\n            await WriteLinesAsync(processedLines);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"An error occurred: {ex.Message}\");\n            throw;\n        }\n    }\n\n    private async Task<IEnumerable<string>> ReadLinesAsync()\n    {\n        var lines = new List<string>();\n        using (var reader = new StreamReader(_inputFilePath))\n        {\n            string line;\n            while ((line = await reader.ReadLineAsync()) != null)\n            {\n                lines.Add(line);\n            }\n        }\n        return lines;\n    }\n\n    private string ProcessLine(string line)\n    {\n        // Simulate line processing\n        return line.ToUpper();\n    }\n\n    private async Task WriteLinesAsync(IEnumerable<string> lines)\n    {\n        using (var writer = new StreamWriter(_outputFilePath, false))\n        {\n            foreach (var line in lines)\n            {\n                await writer.WriteLineAsync(line);\n            }\n        }\n    }\n}\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        var processor = new FileProcessor(\"input.txt\", \"output.txt\");\n", "suffix": "        Console.WriteLine(\"File processing completed.\");\n\n        // Assertions to verify the file processing\n        var expectedLines = new List<string> { \"LINE1\", \"LINE2\", \"LINE3\" };\n        var actualLines = await File.ReadAllLinesAsync(\"output.txt\");\n        Debug.Assert(expectedLines.Count == actualLines.Length, \"Line count mismatch\");\n        for (int i = 0; i < expectedLines.Count; i++)\n        {\n            Debug.Assert(expectedLines[i] == actualLines[i], $\"Line {i} mismatch\");\n        }\n    }\n}\n", "golden_completion": "        await processor.ProcessFileAsync();\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving asynchronous file reading and writing in C#. The prefix sets up the context for file processing, including reading, processing, and writing lines asynchronously. The completion requires the LLM to correctly call the ProcessFileAsync method, which is a key part of the established pattern. The suffix includes assertions to verify that the file processing completed correctly, ensuring the model understands the entire flow and can generate the correct API usage.", "assertions": "", "o1-preview": ""}
{"id": "32", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Azure;\nusing Azure.Data.Tables;\nusing Azure.Data.Tables.Models;\n\nnamespace AzureTableExample\n{\n    public class Program\n    {\n        private static string connectionString = \"UseDevelopmentStorage=true;\";\n        private static string tableName = \"SampleTable\";\n\n        public static async Task Main(string[] args)\n        {\n            TableServiceClient serviceClient = new TableServiceClient(connectionString);\n            TableClient tableClient = serviceClient.GetTableClient(tableName);\n            await tableClient.CreateIfNotExistsAsync();\n\n            Console.WriteLine(\"Created Table\");\n\n            var entity = new TableEntity(\"PartitionKey\", \"RowKey\")\n            {\n                { \"Name\", \"John Doe\" },\n                { \"Age\", 29 }\n            };\n\n            await tableClient.AddEntityAsync(entity);\n\n            Console.WriteLine(\"Added Entity\");\n\n            var retrievedEntity = await tableClient.GetEntityAsync<TableEntity>(\"PartitionKey\", \"RowKey\");\n            Console.WriteLine($\"Retrieved Entity: {retrievedEntity.Value.GetString(\"Name\")} - {retrievedEntity.Value.GetInt32(\"Age\")}\");\n\n            // Update entity\n            retrievedEntity.Value[\"Age\"] = 30;\n\n            // The following code demonstrates updating the entity in the Azure Table Storage\n", "suffix": "\n            Console.WriteLine(\"Updated Entity\");\n\n            var updatedEntity = await tableClient.GetEntityAsync<TableEntity>(\"PartitionKey\", \"RowKey\");\n            Debug.Assert(updatedEntity.Value.GetInt32(\"Age\") == 30, \"The Age should be updated to 30\");\n\n            // Cleanup\n            await tableClient.DeleteEntityAsync(\"PartitionKey\", \"RowKey\");\n            await tableClient.DeleteAsync();\n            Console.WriteLine(\"Cleaned up resources\");\n        }\n    }\n}\n", "golden_completion": "            await tableClient.UpdateEntityAsync(retrievedEntity.Value, ETag.All, TableUpdateMode.Replace);\n", "LLM_justification": "This example demonstrates the usage of the Azure.Data.Tables library, specifically focusing on updating an entity in an Azure Table Storage. The test case verifies the proper usage of the UpdateEntityAsync method with correct parameters and ensures the entity's properties are updated correctly. This scenario helps in evaluating the model's ability to understand and continue patterns involving cloud services and database interfaces. It also includes necessary assertions to verify the correct behavior and handles resource cleanup properly.", "assertions": "", "o1-preview": ""}
{"id": "33", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Azure.Documents.Client;\n\nnamespace AzureCosmosDBExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://your-service-endpoint.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"your-primary-key\";\n        private DocumentClient client;\n\n        static void Main(string[] args)\n        {\n            Program p = new Program();\n            p.RunAsync().Wait();\n        }\n\n        private async Task RunAsync()\n        {\n            this.client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            await this.client.CreateDatabaseIfNotExistsAsync(new Database { Id = \"SampleDB\" });\n            await this.client.CreateDocumentCollectionIfNotExistsAsync(UriFactory.CreateDatabaseUri(\"SampleDB\"), new DocumentCollection { Id = \"SampleCollection\" });\n            await this.CreateDocumentAsync();\n        }\n\n        private async Task CreateDocumentAsync()\n        {\n            var document = new { id = \"1\", Name = \"John Doe\", Age = 30 };\n            await this.client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri(\"SampleDB\", \"SampleCollection\"), document);\n            \n            // Adding a rare API usage for retrieving a document by id in a deprecated way\n            var options = new RequestOptions { PartitionKey = new PartitionKey(\"1\") };\n", "suffix": "\n            Debug.Assert(document != null, \"Document should not be null\");\n            Debug.Assert(document.GetPropertyValue<string>(\"Name\") == \"John Doe\", \"Document name should be 'John Doe'\");\n            Debug.Assert(document.GetPropertyValue<int>(\"Age\") == 30, \"Document age should be 30\");\n        }\n    }\n}\n", "golden_completion": "            Document document = await this.client.ReadDocumentAsync(UriFactory.CreateDocumentUri(\"SampleDB\", \"SampleCollection\", \"1\"), options);\n", "LLM_justification": "This example tests the LLM's ability to recognize and use a deprecated method for reading a document from Azure Cosmos DB using the .NET SDK. The method ReadDocumentAsync with a RequestOptions parameter is uncommon and deprecated but still valid. The pattern involves setting up a DocumentClient, creating a database and collection, adding a document, and then retrieving it using the deprecated API. Assertions check the correctness of the document retrieval, making this a good test case for verifying rare API usage capabilities.", "assertions": "", "o1-preview": ""}
{"id": "34", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Azure.Documents.Client;\nusing System.Diagnostics;\n\nnamespace AzureCosmosDBExample\n{\n    public class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private static DocumentClient client;\n\n        public static void Main(string[] args)\n        {\n            client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            RunDemoAsync().Wait();\n        }\n\n        private static async Task RunDemoAsync()\n        {\n            await client.CreateDatabaseIfNotExistsAsync(new Database { Id = \"SampleDB\" });\n            await client.CreateDocumentCollectionIfNotExistsAsync(UriFactory.CreateDatabaseUri(\"SampleDB\"), new DocumentCollection { Id = \"SampleCollection\" });\n\n            // Insert a sample document\n            dynamic sampleDocument = new { id = \"1\", Name = \"Sample Document\", Description = \"This is a sample document.\" };\n            await client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri(\"SampleDB\", \"SampleCollection\"), sampleDocument);\n\n            // Query the document using SQL\n            var queryOptions = new FeedOptions { MaxItemCount = -1 };\n", "suffix": "            var document = documents.FirstOrDefault();\n            Debug.Assert(document != null, \"Document should not be null\");\n            Debug.Assert(document.id == \"1\", \"Document id should be '1'\");\n            Debug.Assert(document.Name == \"Sample Document\", \"Document Name should be 'Sample Document'\");\n            Debug.Assert(document.Description == \"This is a sample document.\", \"Document Description should be 'This is a sample document.'\");\n\n            Console.WriteLine(\"Document retrieved successfully.\");\n\n            await client.DeleteDocumentAsync(document.SelfLink);\n            await client.DeleteDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri(\"SampleDB\", \"SampleCollection\"));\n            await client.DeleteDatabaseAsync(UriFactory.CreateDatabaseUri(\"SampleDB\"));\n\n            client.Dispose();\n        }\n    }\n}\n", "golden_completion": "            var query = client.CreateDocumentQuery(UriFactory.CreateDocumentCollectionUri(\"SampleDB\", \"SampleCollection\"), \"SELECT * FROM c WHERE c.id = '1'\", queryOptions).AsDocumentQuery();\n            var documents = await query.ExecuteNextAsync<dynamic>();\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a pattern involving the Azure Cosmos DB .NET SDK, specifically querying documents using SQL. This is a less common API usage compared to basic CRUD operations. The completion requires understanding of parameter ordering and usage of deprecated methods like `CreateDocumentQuery`.", "assertions": "", "o1-preview": ""}
{"id": "35", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nnamespace ConcurrentProgrammingExample\n{\n    public class ParallelProcessing\n    {\n        private List<int> numbers;\n        \n        public ParallelProcessing()\n        {\n            numbers = new List<int>();\n            for (int i = 0; i < 100; i++)\n            {\n                numbers.Add(i);\n            }\n        }\n        \n        public void ProcessNumbers()\n        {\n            // Initialize a list to store the results\n            List<int> results = new List<int>();\n            \n            // Use Parallel.ForEach to process the numbers in parallel\n            Parallel.ForEach(numbers, number =>\n            {\n                int result = ProcessNumber(number);\n                lock (results)\n                {\n                    results.Add(result);\n                }\n            });\n        }\n        \n        private int ProcessNumber(int number)\n        {\n            // Simulate some processing\n            return number * number;\n        }\n\n        public async Task<int> SumNumbersAsync()\n        {\n            int sum = 0;\n            foreach (int number in numbers)\n            {\n                sum += await GetNumberAsync(number);\n            }\n            return sum;\n        }\n\n        private Task<int> GetNumberAsync(int number)\n        {\n            return Task.FromResult(number);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ParallelProcessing parallelProcessing = new ParallelProcessing();\n            parallelProcessing.ProcessNumbers();\n", "suffix": "\n\n            // Assertions\n            Debug.Assert(sum == 4950, \"The sum of the numbers should be 4950.\");\n            Console.WriteLine(\"Sum of numbers: \" + sum);\n        }\n    }\n}\n", "golden_completion": "            var sumTask = parallelProcessing.SumNumbersAsync();\n            sumTask.Wait();\n            int sum = sumTask.Result;\n\n", "LLM_justification": "This example demonstrates the use of the Parallel.ForEach method from the Task Parallel Library (TPL) for concurrent processing, combined with asynchronous programming (async/await) to sum numbers asynchronously. The test case evaluates the model's ability to handle uncommon API usage patterns for parallel processing and async methods, ensuring correct parameter ordering and API behavior. The prefix provides extensive context with setup code, while the suffix includes assertions to verify the expected behavior.", "assertions": "", "o1-preview": ""}
{"id": "36", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Cosmos;\n\nnamespace CosmosDBExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private CosmosClient cosmosClient;\n        private Database database;\n        private Container container;\n\n        public async Task InitializeAsync()\n        {\n            this.cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n            this.database = await this.cosmosClient.CreateDatabaseIfNotExistsAsync(\"SampleDatabase\");\n            this.container = await this.database.CreateContainerIfNotExistsAsync(\"SampleContainer\", \"/id\");\n        }\n\n        public async Task AddItemToContainerAsync(SampleItem item)\n        {\n            try\n            {\n                ItemResponse<SampleItem> response = await this.container.CreateItemAsync<SampleItem>(item, new PartitionKey(item.Id));\n                Console.WriteLine(\"Item added successfully. Operation consumed {0} RUs.\", response.RequestCharge);\n            }\n            catch (CosmosException ex)\n            {\n                Console.WriteLine(\"Error occurred: {0}\", ex.Message);\n            }\n        }\n\n        public class SampleItem\n        {\n            public string Id { get; set; }\n            public string Name { get; set; }\n        }\n\n        static async Task Main(string[] args)\n        {\n            Program p = new Program();\n            await p.InitializeAsync();\n            SampleItem newItem = new SampleItem { Id = \"1\", Name = \"Sample Item\" };\n            await p.AddItemToContainerAsync(newItem);\n", "suffix": "\n            Debug.Assert(retrievedItem != null, \"Item should be successfully retrieved.\");\n            Debug.Assert(retrievedItem.Id == \"1\", \"Item Id should be '1'.\");\n            Debug.Assert(retrievedItem.Name == \"Sample Item\", \"Item name should be 'Sample Item'.\");\n\n            Console.WriteLine(\"All assertions passed.\");\n        }\n    }\n}\n", "golden_completion": "            ItemResponse<SampleItem> retrievedItemResponse = await p.container.ReadItemAsync<SampleItem>(\"1\", new PartitionKey(\"1\"));\n            SampleItem retrievedItem = retrievedItemResponse.Resource;\n", "LLM_justification": "This test case demonstrates the use of the Azure Cosmos DB SDK for .NET to create and read items from a Cosmos DB container. It includes proper initialization of the Cosmos client, database, and container, handling of exceptions during item creation, and validation of the retrieved item. This scenario tests the model's ability to recognize and complete the pattern involving the Azure Cosmos DB SDK, which is less commonly used compared to other database interfaces.", "assertions": "", "o1-preview": ""}
{"id": "37", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing System.Diagnostics;\n\nnamespace GitHubApiIntegration\n{\n    public class GitHubClient\n    {\n        private readonly HttpClient _httpClient;\n        private const string GitHubApiBaseUrl = \"https://api.github.com\";\n\n        public GitHubClient()\n        {\n            _httpClient = new HttpClient();\n            _httpClient.DefaultRequestHeaders.Add(\"User-Agent\", \"HttpClientFactory-Sample\");\n        }\n\n        public async Task<JObject> GetRepositoryInfoAsync(string owner, string repo)\n        {\n            if (string.IsNullOrEmpty(owner)) throw new ArgumentException(\"Owner cannot be null or empty\", nameof(owner));\n            if (string.IsNullOrEmpty(repo)) throw new ArgumentException(\"Repo cannot be null or empty\", nameof(repo));\n\n            var url = $\"{GitHubApiBaseUrl}/repos/{owner}/{repo}\";\n            var response = await _httpClient.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n\n            var content = await response.Content.ReadAsStringAsync();\n            return JObject.Parse(content);\n        }\n\n        public async Task<IList<string>> GetContributorsAsync(string owner, string repo)\n        {\n            if (string.IsNullOrEmpty(owner)) throw new ArgumentException(\"Owner cannot be null or empty\", nameof(owner));\n            if (string.IsNullOrEmpty(repo)) throw new ArgumentException(\"Repo cannot be null or empty\", nameof(repo));\n\n            var url = $\"{GitHubApiBaseUrl}/repos/{owner}/{repo}/contributors\";\n            var response = await _httpClient.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n\n            var content = await response.Content.ReadAsStringAsync();\n            var contributors = JArray.Parse(content);\n            var contributorNames = new List<string>();\n            foreach (var contributor in contributors)\n            {\n                contributorNames.Add(contributor[\"login\"].ToString());\n            }\n            return contributorNames;\n        }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var client = new GitHubClient();\n            var repoInfo = await client.GetRepositoryInfoAsync(\"octocat\", \"Hello-World\");\n            Console.WriteLine(repoInfo.ToString(Formatting.Indented));\n\n", "suffix": "            Debug.Assert(contributors.Contains(\"octocat\"), \"The repository should have a contributor named 'octocat'.\");\n            Console.WriteLine(\"All assertions passed.\");\n        }\n    }\n}\n", "golden_completion": "            var contributors = await client.GetContributorsAsync(\"octocat\", \"Hello-World\");\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and use the GitHub API through HttpClient in C#. The task involves fetching repository information and contributors, which are common but require correct API usage and error handling. The golden completion involves calling a method to get contributors and the suffix includes assertions to verify the correct API usage, ensuring the model understands the sequence and dependencies.", "assertions": "", "o1-preview": ""}
{"id": "38", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace WebApiIntegrationExample\n{\n    class GitHubApiClient\n    {\n        private readonly HttpClient _httpClient;\n\n        public GitHubApiClient(HttpClient httpClient)\n        {\n            _httpClient = httpClient;\n        }\n\n        public async Task<string> GetRepositoryDetailsAsync(string owner, string repo)\n        {\n            if (string.IsNullOrEmpty(owner))\n                throw new ArgumentException(\"Owner cannot be null or empty.\", nameof(owner));\n            if (string.IsNullOrEmpty(repo))\n                throw new ArgumentException(\"Repository cannot be null or empty.\", nameof(repo));\n\n            string url = $\"https://api.github.com/repos/{owner}/{repo}\";\n            HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, url);\n            request.Headers.Add(\"User-Agent\", \"HttpClientFactory-Sample\");\n            request.Headers.Add(\"Accept\", \"application/vnd.github.v3+json\");\n\n            HttpResponseMessage response = await _httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n\n            return await response.Content.ReadAsStringAsync();\n        }\n    }\n\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            HttpClient httpClient = new HttpClient();\n            GitHubApiClient gitHubApiClient = new GitHubApiClient(httpClient);\n", "suffix": "            string repoDetails = await gitHubApiClient.GetRepositoryDetailsAsync(\"octocat\", \"Hello-World\");\n\n            httpClient.Dispose();\n        }\n    }\n}\n", "golden_completion": "            string repoDetails = await gitHubApiClient.GetRepositoryDetailsAsync(\"octocat\", \"Hello-World\");\n", "LLM_justification": "This example tests the ability of the LLM to correctly use the HttpClient and HttpRequestMessage classes to make a GET request to the GitHub API. It checks for proper handling of HTTP headers and ensures the response is not empty. This scenario is realistic and involves uncommon API usage patterns such as setting custom headers and ensuring the response is successful.", "assertions": "", "o1-preview": ""}
{"id": "39", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Text.Json;\n\nnamespace SynthBench\n{\n    public class Program\n    {\n        public class User\n        {\n            public string Username { get; set; }\n            public int Age { get; set; }\n        }\n\n        static void Main(string[] args)\n        {\n            string jsonString = \"{ \\\"Username\\\": \\\"testuser\\\", \\\"Age\\\": 25 }\";\n            User user = null;\n\n            try\n            {\n                // Parse the JSON string into a User object\n", "suffix": "                // Additional assertions to ensure correct parsing\n                Debug.Assert(user != null, \"User object should not be null\");\n                Debug.Assert(user.Username == \"testuser\", \"Username should be 'testuser'\");\n                Debug.Assert(user.Age == 25, \"Age should be 25\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"An error occurred: {ex.Message}\");\n            }\n            finally\n            {\n                // Cleanup resources if needed (none in this case)\n            }\n        }\n    }\n}\n", "golden_completion": "                user = JsonSerializer.Deserialize<User>(jsonString);\n", "LLM_justification": "This test case demonstrates the use of the JsonSerializer.Deserialize method from System.Text.Json, which is less commonly used compared to older JSON libraries like Newtonsoft.Json. The example includes parsing a JSON string into a User object and validates the correct usage of the API with assertions. The prefix sets up the context, the golden completion shows the correct API call, and the suffix includes assertions to verify the correct parsing and parameter handling.", "assertions": "", "o1-preview": ""}
{"id": "40", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing Microsoft.Azure.Cosmos;\nusing Newtonsoft.Json;\nusing System.Threading.Tasks;\n\nnamespace CosmosDbExample\n{\n    public class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-cosmos-db-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private CosmosClient cosmosClient;\n        private Database database;\n        private Container container;\n        private readonly string databaseId = \"SampleDatabase\";\n        private readonly string containerId = \"SampleContainer\";\n\n        public static async Task Main(string[] args)\n        {\n            Program p = new Program();\n            await p.RunAsync();\n        }\n\n        public async Task RunAsync()\n        {\n            this.cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n            await this.CreateDatabaseAsync();\n            await this.CreateContainerAsync();\n            await this.AddItemsToContainerAsync();\n        }\n\n        private async Task CreateDatabaseAsync()\n        {\n            this.database = await this.cosmosClient.CreateDatabaseIfNotExistsAsync(databaseId);\n            Console.WriteLine(\"Created Database: {0}\\n\", this.database.Id);\n        }\n\n        private async Task CreateContainerAsync()\n        {\n            this.container = await this.database.CreateContainerIfNotExistsAsync(containerId, \"/partitionKey\");\n            Console.WriteLine(\"Created Container: {0}\\n\", this.container.Id);\n        }\n\n        private async Task AddItemsToContainerAsync()\n        {\n            dynamic item = new\n            {\n                id = Guid.NewGuid().ToString(),\n                partitionKey = \"Partition1\",\n                name = \"Sample Item\",\n                description = \"This is a sample item\"\n            };\n            await this.container.CreateItemAsync(item, new PartitionKey(item.partitionKey));\n            Console.WriteLine(\"Created Item: {0}\\n\", item.id);\n        }\n\n        private async Task QueryItemsAsync()\n        {\n            var sqlQueryText = \"SELECT * FROM c WHERE c.partitionKey = 'Partition1'\";\n            QueryDefinition queryDefinition = new QueryDefinition(sqlQueryText);\n            FeedIterator<dynamic> queryResultSetIterator = this.container.GetItemQueryIterator<dynamic>(queryDefinition);\n", "suffix": "\n            Debug.Assert(items.Count > 0, \"No items found.\");\n            Debug.Assert(items.All(i => i.partitionKey == \"Partition1\"), \"Incorrect partition key.\");\n\n            // Cleanup resources\n            if (this.container != null)\n            {\n                await this.container.DeleteContainerAsync();\n            }\n            if (this.database != null)\n            {\n                await this.database.DeleteAsync();\n            }\n            if (this.cosmosClient != null)\n            {\n                this.cosmosClient.Dispose();\n            }\n        }\n    }\n}\n", "golden_completion": "            List<dynamic> items = new List<dynamic>();\n            while (queryResultSetIterator.HasMoreResults)\n            {\n                FeedResponse<dynamic> currentResultSet = await queryResultSetIterator.ReadNextAsync();\n                foreach (var item in currentResultSet)\n                {\n                    items.Add(item);\n                }\n            }\n", "LLM_justification": "This test case demonstrates the usage of Azure Cosmos DB SDK for querying items using an uncommon API function GetItemQueryIterator. It tests the model's ability to correctly use the FeedIterator and FeedResponse classes to iterate over query results. The code includes proper resource cleanup and error handling, and the assertions verify that the items retrieved match the expected partition key, ensuring correctness of API usage and parameter ordering.", "assertions": "", "o1-preview": ""}
{"id": "41", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing System.Diagnostics;\n\nnamespace SynthBench\n{\n    public class MyDbContext : DbContext\n    {\n        public DbSet<User> Users { get; set; }\n\n        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n        {\n            optionsBuilder.UseInMemoryDatabase(\"TestDb\");\n        }\n    }\n\n    public class User\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n    }\n\n    public class UserRepository\n    {\n        private readonly MyDbContext _context;\n\n        public UserRepository(MyDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<User> GetUserByIdAsync(int userId)\n        {\n            return await _context.Users.FindAsync(userId);\n        }\n\n        public async Task AddUserAsync(User user)\n        {\n            _context.Users.Add(user);\n            await _context.SaveChangesAsync();\n        }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            using (var context = new MyDbContext())\n            {\n                var repository = new UserRepository(context);\n                var newUser = new User { Id = 1, Name = \"John Doe\" };\n                await repository.AddUserAsync(newUser);\n\n                // Fetch user by ID\n                var fetchedUser = await repository.GetUserByIdAsync(1);\n                Debug.Assert(fetchedUser != null, \"User should not be null\");\n                Debug.Assert(fetchedUser.Name == \"John Doe\", \"User name should be 'John Doe'\");\n\n                // Update user name\n", "suffix": "                fetchedUser.Name = \"Jane Doe\";\n                await repository.UpdateUserAsync(fetchedUser);\n\n                // Fetch updated user\n                var updatedUser = await repository.GetUserByIdAsync(1);\n                Debug.Assert(updatedUser != null, \"Updated user should not be null\");\n                Debug.Assert(updatedUser.Name == \"Jane Doe\", \"User name should be 'Jane Doe'\");\n            }\n        }\n    }\n}\n", "golden_completion": "                _context.Users.Update(fetchedUser);\n                await _context.SaveChangesAsync();\n", "LLM_justification": "This test case focuses on the usage of Entity Framework Core, specifically testing the pattern of fetching, updating, and saving entities using the DbContext. It includes uncommon methods like DbContext.Update and verifies the correct parameter ordering and API behavior through assertions. The scenario ensures proper resource management and demonstrates advanced async/await patterns.", "assertions": "", "o1-preview": ""}
{"id": "42", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Diagnostics;\n\nnamespace WebAPIIntegrationExample\n{\n    public class GitHubApiClient\n    {\n        private static readonly HttpClient client = new HttpClient();\n\n        public async Task<string> GetRepositoryDetailsAsync(string owner, string repo)\n        {\n            client.DefaultRequestHeaders.UserAgent.Clear();\n            client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"Mozilla\", \"5.0\"));\n\n            var url = $\"https://api.github.com/repos/{owner}/{repo}\";\n            var response = await client.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            var responseData = await response.Content.ReadAsStringAsync();\n\n            return responseData;\n        }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var gitHubClient = new GitHubApiClient();\n            string owner = \"octocat\";\n            string repo = \"Hello-World\";\n", "suffix": "            Debug.Assert(!string.IsNullOrEmpty(repositoryDetails), \"Repository details should not be empty\");\n            Debug.Assert(repositoryDetails.Contains(\"full_name\"), \"Repository details should contain 'full_name'\");\n            Debug.Assert(repositoryDetails.Contains(\"description\"), \"Repository details should contain 'description'\");\n            Debug.Assert(repositoryDetails.Contains(\"owner\"), \"Repository details should contain 'owner'\");\n\n            // Cleanup\n            client.Dispose();\n        }\n    }\n}\n", "golden_completion": "            string repositoryDetails = await gitHubClient.GetRepositoryDetailsAsync(owner, repo);\n", "LLM_justification": "This test case demonstrates the usage of a relatively uncommon API pattern involving the integration with GitHub's REST API using HttpClient. It tests the ability of the LLM to recognize the correct sequence of API calls and parameter usage. The assertions verify that the response contains key fields expected from a GitHub repository response, ensuring the API call was successful and correctly processed.", "assertions": "", "o1-preview": ""}
{"id": "43", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Cosmos;\nusing System.Diagnostics;\n\nnamespace AzureCosmosDbExample\n{\n    public class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private CosmosClient cosmosClient;\n        private Database database;\n        private Container container;\n        private string databaseId = \"ToDoList\";\n        private string containerId = \"Items\";\n\n        public static async Task Main(string[] args)\n        {\n            Program p = new Program();\n            await p.RunAsync();\n        }\n\n        public async Task RunAsync()\n        {\n            this.cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n            await this.CreateDatabaseAsync();\n            await this.CreateContainerAsync();\n            await this.AddItemsToContainerAsync();\n        }\n\n        private async Task CreateDatabaseAsync()\n        {\n            this.database = await this.cosmosClient.CreateDatabaseIfNotExistsAsync(databaseId);\n            Console.WriteLine(\"Created Database: {0}\", this.database.Id);\n        }\n\n        private async Task CreateContainerAsync()\n        {\n            this.container = await this.database.CreateContainerIfNotExistsAsync(containerId, \"/id\");\n            Console.WriteLine(\"Created Container: {0}\", this.container.Id);\n        }\n\n        private async Task AddItemsToContainerAsync()\n        {\n            List<ToDoItem> items = new List<ToDoItem>\n            {\n                new ToDoItem { Id = \"1\", Description = \"Buy milk\", IsComplete = false },\n                new ToDoItem { Id = \"2\", Description = \"Learn Azure Cosmos DB\", IsComplete = false }\n            };\n\n            foreach (var item in items)\n            {\n                await AddItemToContainerAsync(item);\n            }\n        }\n\n        private async Task AddItemToContainerAsync(ToDoItem item)\n        {\n            try\n            {\n                ItemResponse<ToDoItem> response = await this.container.ReadItemAsync<ToDoItem>(item.Id, new PartitionKey(item.Id));\n                Console.WriteLine(\"Item in database with id: {0} already exists\\n\", response.Resource.Id);\n            }\n            catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n", "suffix": "\n\n                // Assertions\n                Debug.Assert(createdItem != null, \"Item creation failed.\");\n                Debug.Assert(createdItem.Id == item.Id, \"Item ID does not match.\");\n                Debug.Assert(createdItem.Description == item.Description, \"Item description does not match.\");\n                Debug.Assert(createdItem.IsComplete == item.IsComplete, \"Item completion status does not match.\");\n            }\n        }\n\n        public class ToDoItem\n        {\n            public string Id { get; set; }\n            public string Description { get; set; }\n            public bool IsComplete { get; set; }\n        }\n    }\n}", "golden_completion": "                ToDoItem createdItem = await this.container.CreateItemAsync<ToDoItem>(item, new PartitionKey(item.Id));\n                Console.WriteLine(\"Created item in database with id: {0}\\n\", createdItem.Id);\n", "LLM_justification": "This test case focuses on Azure Cosmos DB integration, an uncommon API in many standard applications. It includes operations like creating databases and containers, and adding items to the database, which are crucial but not frequently encountered. Assertions verify the correctness of the item creation, ensuring that the API usage and parameter handling are accurate.", "assertions": "", "o1-preview": ""}
{"id": "44", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Diagnostics;\nusing Azure;\nusing Azure.Cosmos;\nusing Azure.Cosmos.Fluent;\n\nnamespace AzureCosmosDBExample\n{\n    public class Program\n    {\n        private static CosmosClient _client;\n        private static Database _database;\n        private static Container _container;\n\n        public static async Task Main(string[] args)\n        {\n            string endpointUri = \"https://your-cosmos-db.documents.azure.com:443/\";\n            string primaryKey = \"your-primary-key\";\n\n            _client = new CosmosClientBuilder(endpointUri, primaryKey)\n                .WithConnectionModeDirect()\n                .Build();\n\n            _database = await _client.CreateDatabaseIfNotExistsAsync(\"SampleDatabase\");\n            _container = await _database.CreateContainerIfNotExistsAsync(new ContainerProperties(\"SampleContainer\", \"/partitionKey\"));\n\n            await AddItemToContainerAsync(new SampleItem { Id = \"1\", Name = \"Sample Item\", PartitionKey = \"SamplePartition\" });\n        }\n\n        public class SampleItem\n        {\n            public string Id { get; set; }\n            public string Name { get; set; }\n            public string PartitionKey { get; set; }\n        }\n\n        private static async Task AddItemToContainerAsync(SampleItem item)\n        {\n            try\n            {\n                // Create an item in the container\n", "suffix": "                Debug.Assert(item != null, \"Item should not be null\");\n                Debug.Assert(!string.IsNullOrEmpty(item.Id), \"Item Id should not be null or empty\");\n                Debug.Assert(!string.IsNullOrEmpty(item.PartitionKey), \"Item PartitionKey should not be null or empty\");\n\n                // Read the item to see if it exists. Note ReadItemAsync will retrieve the item from the Azure Cosmos DB service\n                ItemResponse<SampleItem> response = await _container.ReadItemAsync<SampleItem>(item.Id, new PartitionKey(item.PartitionKey));\n                Debug.Assert(response != null, \"Response should not be null\");\n                Debug.Assert(response.Resource != null, \"Response resource should not be null\");\n                Debug.Assert(response.Resource.Id == item.Id, \"Response resource Id should match the item Id\");\n                Debug.Assert(response.Resource.Name == item.Name, \"Response resource Name should match the item Name\");\n                Debug.Assert(response.Resource.PartitionKey == item.PartitionKey, \"Response resource PartitionKey should match the item PartitionKey\");\n            }\n            catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n                Debug.Fail(\"Item not found\");\n            }\n            finally\n            {\n                _client.Dispose();\n            }\n        }\n    }\n}", "golden_completion": "                await _container.CreateItemAsync(item, new PartitionKey(item.PartitionKey));\n", "LLM_justification": "This example tests the ability to correctly implement the Azure Cosmos DB SDK to create an item within a container, a less common usage scenario. The scenario also includes appropriate assertions to verify the correctness of the item creation and subsequent reading operations. The test also ensures that the client and container are properly disposed of after operations, showcasing best practices in resource management.", "assertions": "", "o1-preview": ""}
{"id": "45", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing Microsoft.Azure.Cosmos;\n\nnamespace AzureCosmosDbExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-cosmos-db-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private CosmosClient cosmosClient;\n        private Database database;\n        private Container container;\n        private string databaseId = \"SampleDatabase\";\n        private string containerId = \"SampleContainer\";\n\n        static async Task Main(string[] args)\n        {\n            Program p = new Program();\n            await p.InitializeCosmosClientInstanceAsync();\n            await p.AddItemsToContainerAsync();\n        }\n\n        public async Task InitializeCosmosClientInstanceAsync()\n        {\n            this.cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n            this.database = await this.cosmosClient.CreateDatabaseIfNotExistsAsync(databaseId);\n            this.container = await this.database.CreateContainerIfNotExistsAsync(containerId, \"/PartitionKey\");\n        }\n\n        public async Task AddItemsToContainerAsync()\n        {\n            List<SampleItem> items = new List<SampleItem>\n            {\n                new SampleItem { Id = \"1\", PartitionKey = \"pk1\", Name = \"Item 1\" },\n                new SampleItem { Id = \"2\", PartitionKey = \"pk2\", Name = \"Item 2\" }\n            };\n\n            foreach (var item in items)\n            {\n                await this.AddItemAsync(item);\n            }\n        }\n\n        public async Task AddItemAsync(SampleItem item)\n        {\n", "suffix": "            Debug.Assert(item != null, \"Item should not be null\");\n            Debug.Assert(!string.IsNullOrEmpty(item.Id), \"Item Id should not be null or empty\");\n            Debug.Assert(!string.IsNullOrEmpty(item.PartitionKey), \"PartitionKey should not be null or empty\");\n            Debug.Assert(!string.IsNullOrEmpty(item.Name), \"Item Name should not be null or empty\");\n            Console.WriteLine($\"Item {item.Name} added successfully.\");\n        }\n\n        public class SampleItem\n        {\n            public string Id { get; set; }\n            public string PartitionKey { get; set; }\n            public string Name { get; set; }\n        }\n    }\n}\n", "golden_completion": "            try\n            {\n                ItemResponse<SampleItem> response = await this.container.CreateItemAsync(item, new PartitionKey(item.PartitionKey));\n                Debug.Assert(response.StatusCode == System.Net.HttpStatusCode.Created, \"Item creation failed\");\n            }\n            catch (CosmosException ex)\n            {\n                Console.WriteLine($\"Item creation failed with error: {ex.Message}\");\n                throw;\n            }\n", "LLM_justification": "This scenario tests the model's ability to recognize and complete an uncommon API usage involving Azure Cosmos DB. The example demonstrates the creation and insertion of items into a Cosmos DB container. It includes proper parameter ordering, error handling, and validation through assertions. This test case ensures the model understands the correct usage pattern of the Cosmos DB SDK and handles exceptions appropriately.", "assertions": "", "o1-preview": ""}
{"id": "46", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Azure.Documents.Client;\n\nnamespace AzureCosmosDBExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://your-service.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"your-primary-key\";\n        private static DocumentClient client;\n\n        static async Task Main(string[] args)\n        {\n            try\n            {\n                client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n                await client.OpenAsync();\n                var databaseUri = UriFactory.CreateDatabaseUri(\"ExampleDB\");\n                var collectionUri = UriFactory.CreateDocumentCollectionUri(\"ExampleDB\", \"ExampleCollection\");\n\n                // Create a new document\n                var document = new { id = \"1\", Name = \"John Doe\", Age = 30 };\n                await client.CreateDocumentAsync(collectionUri, document);\n\n                // Retrieve the document by ID\n                var retrievedDocument = await client.ReadDocumentAsync(UriFactory.CreateDocumentUri(\"ExampleDB\", \"ExampleCollection\", \"1\"));\n                Console.WriteLine($\"Retrieved document: {retrievedDocument.Resource.ToString()}\");\n\n                // Update the document\n                document = new { id = \"1\", Name = \"John Doe\", Age = 31 };\n                await client.ReplaceDocumentAsync(UriFactory.CreateDocumentUri(\"ExampleDB\", \"ExampleCollection\", \"1\"), document);\n            }\n            catch (DocumentClientException e)\n            {\n                Console.WriteLine($\"Error: {e.Message}\");\n            }\n            finally\n            {\n", "suffix": "                // Verify the document was deleted\n                try\n                {\n                    await client.ReadDocumentAsync(UriFactory.CreateDocumentUri(\"ExampleDB\", \"ExampleCollection\", \"1\"));\n                }\n                catch (DocumentClientException e) when (e.StatusCode == System.Net.HttpStatusCode.NotFound)\n                {\n                    Console.WriteLine(\"Document successfully deleted.\");\n                    Debug.Assert(true, \"Document deletion confirmed.\");\n                }\n                finally\n                {\n                    client.Dispose();\n                }\n            }\n        }\n    }\n}\n", "golden_completion": "                // Delete the document\n                await client.DeleteDocumentAsync(UriFactory.CreateDocumentUri(\"ExampleDB\", \"ExampleCollection\", \"1\"));\n", "LLM_justification": "This example tests the model's ability to recognize and complete a pattern involving Azure Cosmos DB's DocumentClient API. The task includes creating, reading, updating, and deleting a document, which covers the CRUD operations. The completion focuses on the less common delete operation, and the suffix verifies the deletion. This scenario ensures the model understands the API's method usage and parameter ordering, and the assertions validate the correct behavior of the API.", "assertions": "", "o1-preview": ""}
{"id": "47", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Azure.Documents.Client;\nusing System.Diagnostics;\n\nnamespace CosmosDBExample\n{\n    public class Program\n    {\n        private static readonly string EndpointUrl = \"https://your-service-endpoint:443/\";\n        private static readonly string PrimaryKey = \"your-primary-key\";\n        private static DocumentClient client;\n\n        public static void Main(string[] args)\n        {\n            try\n            {\n                client = new DocumentClient(new Uri(EndpointUrl), PrimaryKey);\n                CreateDatabaseIfNotExistsAsync().Wait();\n                CreateCollectionIfNotExistsAsync().Wait();\n                AddDocumentToCollectionAsync().Wait();\n            }\n            catch (DocumentClientException de)\n            {\n                Exception baseException = de.GetBaseException();\n                Console.WriteLine(\"Error: {0}, Message: {1}\", de.StatusCode, baseException.Message);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(\"Error: {0}\", e.Message);\n            }\n            finally\n            {\n                client?.Dispose();\n            }\n        }\n\n        private static async Task CreateDatabaseIfNotExistsAsync()\n        {\n            await client.CreateDatabaseIfNotExistsAsync(new Database { Id = \"SampleDB\" });\n        }\n\n        private static async Task CreateCollectionIfNotExistsAsync()\n        {\n            await client.CreateDocumentCollectionIfNotExistsAsync(UriFactory.CreateDatabaseUri(\"SampleDB\"), new DocumentCollection { Id = \"SampleCollection\" });\n        }\n\n        private static async Task AddDocumentToCollectionAsync()\n        {\n            var document = new { Id = \"1\", Name = \"Sample Document\", Description = \"This is a sample document\" };\n", "suffix": "\n            Debug.Assert(response.StatusCode == System.Net.HttpStatusCode.Created, \"Document creation failed.\");\n            Debug.Assert(response.Resource.Id == \"1\", \"Document ID does not match.\");\n            Debug.Assert(response.Resource.GetPropertyValue<string>(\"Name\") == \"Sample Document\", \"Document Name does not match.\");\n            Debug.Assert(response.Resource.GetPropertyValue<string>(\"Description\") == \"This is a sample document\", \"Document Description does not match.\");\n            Console.WriteLine(\"Document created successfully.\");\n        }\n    }\n}\n", "golden_completion": "            ResourceResponse<Document> response = await client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri(\"SampleDB\", \"SampleCollection\"), document);\n", "LLM_justification": "This scenario tests the usage of the deprecated Azure DocumentDB SDK for creating a document in a Cosmos DB collection. The example includes creating a database and a collection if they do not exist, adding a document to the collection, and verifying its creation using assertions. This is a good test case because it involves multiple steps and uncommon APIs, ensuring the model handles the entire flow correctly. The assertions validate the API behavior, parameter correctness, and return values.", "assertions": "", "o1-preview": ""}
{"id": "48", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Azure.Documents.Client;\n\nnamespace CosmosDBExample\n{\n    public class Program\n    {\n        private static readonly string EndpointUrl = \"https://<your-cosmos-db>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private static DocumentClient client;\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                client = new DocumentClient(new Uri(EndpointUrl), PrimaryKey);\n                await client.OpenAsync();\n                await CreateDatabaseIfNotExistsAsync(\"SampleDatabase\");\n                await CreateDocumentCollectionIfNotExistsAsync(\"SampleDatabase\", \"SampleCollection\");\n\n                // Adding a sample document\n                dynamic documentDefinition = new\n                {\n                    id = \"1\",\n                    Name = \"Sample Document\",\n                    Description = \"This is a sample document\"\n                };\n                await client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri(\"SampleDatabase\", \"SampleCollection\"), documentDefinition);\n\n                // Retrieving the document\n                Uri documentUri = UriFactory.CreateDocumentUri(\"SampleDatabase\", \"SampleCollection\", \"1\");\n                Document document = await client.ReadDocumentAsync(documentUri);\n\n                // Updating the document\n                document.SetPropertyValue(\"Description\", \"This is an updated sample document\");\n", "suffix": "\n\n                // Verifying the update\n                Document updatedDocument = await client.ReadDocumentAsync(documentUri);\n                Debug.Assert(updatedDocument.GetPropertyValue<string>(\"Description\") == \"This is an updated sample document\", \"Document description was not updated correctly.\");\n            }\n            finally\n            {\n                if (client != null)\n                {\n                    client.Dispose();\n                }\n            }\n        }\n\n        private static async Task CreateDatabaseIfNotExistsAsync(string databaseName)\n        {\n            try\n            {\n                await client.ReadDatabaseAsync(UriFactory.CreateDatabaseUri(databaseName));\n            }\n            catch (DocumentClientException e) when (e.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n                await client.CreateDatabaseAsync(new Database { Id = databaseName });\n            }\n        }\n\n        private static async Task CreateDocumentCollectionIfNotExistsAsync(string databaseName, string collectionName)\n        {\n            try\n            {\n                await client.ReadDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri(databaseName, collectionName));\n            }\n            catch (DocumentClientException e) when (e.StatusCode == System.Net.HttpStatusCode.NotFound)\n            {\n                await client.CreateDocumentCollectionAsync(\n                    UriFactory.CreateDatabaseUri(databaseName),\n                    new DocumentCollection { Id = collectionName },\n                    new RequestOptions { OfferThroughput = 400 });\n            }\n        }\n    }\n}\n", "golden_completion": "                await client.ReplaceDocumentAsync(documentUri, document);", "LLM_justification": "This test case involves the use of the deprecated Azure Cosmos DB DocumentClient API, which is less common in modern applications due to the introduction of the CosmosClient in the newer SDK. The scenario tests the ability to recognize and correctly use the DocumentClient for creating, reading, and updating documents in a Cosmos DB database. Assertions are included to verify the correctness of the document update operation. This setup ensures proper resource management and error handling, making it a robust example for testing rare API usage capabilities.", "assertions": "", "o1-preview": "await client.ReplaceDocumentAsync(documentUri, document);"}
{"id": "49", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Azure.Documents.Client;\n\nnamespace CosmosDBExample\n{\n    class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private DocumentClient client;\n\n        static void Main(string[] args)\n        {\n            Program p = new Program();\n            p.RunAsync().Wait();\n        }\n\n        private async Task RunAsync()\n        {\n            this.client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            await this.client.CreateDatabaseIfNotExistsAsync(new Database { Id = \"TestDatabase\" });\n            await this.client.CreateDocumentCollectionIfNotExistsAsync(UriFactory.CreateDatabaseUri(\"TestDatabase\"), new DocumentCollection { Id = \"TestCollection\" });\n            await this.CreateDocumentIfNotExists(\"TestDatabase\", \"TestCollection\", new { id = \"1\", Name = \"John Doe\", Age = 30 });\n\n            // Querying documents\n            var queryOptions = new FeedOptions { MaxItemCount = -1, EnableCrossPartitionQuery = true };\n            IQueryable<dynamic> documentQuery = this.client.CreateDocumentQuery<dynamic>(\n                UriFactory.CreateDocumentCollectionUri(\"TestDatabase\", \"TestCollection\"), queryOptions);\n\n            List<dynamic> results = new List<dynamic>();\n            foreach (var doc in documentQuery)\n            {\n                results.Add(doc);\n            }\n            Console.WriteLine(\"Documents queried: \" + results.Count);\n\n            // Ensuring document creation was successful\n            dynamic document = results.Find(d => d.id == \"1\");\n            Debug.Assert(document != null, \"Document with id 1 should exist.\");\n            Debug.Assert(document.Name == \"John Doe\", \"Document Name should be John Doe.\");\n            Debug.Assert(document.Age == 30, \"Document Age should be 30.\");\n\n            // Now, let's update the document\n            \n", "suffix": "            // Verify that the document has been updated\n            dynamic updatedDocument = this.client.ReadDocumentAsync(UriFactory.CreateDocumentUri(\"TestDatabase\", \"TestCollection\", \"1\")).Result.Resource;\n            Debug.Assert(updatedDocument != null, \"Updated document with id 1 should exist.\");\n            Debug.Assert(updatedDocument.Name == \"Jane Doe\", \"Updated document Name should be Jane Doe.\");\n            Debug.Assert(updatedDocument.Age == 35, \"Updated document Age should be 35.\");\n\n            // Clean up resources\n            await this.client.DeleteDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri(\"TestDatabase\", \"TestCollection\"));\n            await this.client.DeleteDatabaseAsync(UriFactory.CreateDatabaseUri(\"TestDatabase\"));\n        }\n\n        private async Task CreateDocumentIfNotExists(string databaseId, string collectionId, object document)\n        {\n            try\n            {\n                await this.client.ReadDocumentAsync(UriFactory.CreateDocumentUri(databaseId, collectionId, document.GetType().GetProperty(\"id\").GetValue(document, null).ToString()));\n            }\n            catch (DocumentClientException de)\n            {\n                if (de.StatusCode == System.Net.HttpStatusCode.NotFound)\n                {\n                    await this.client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri(databaseId, collectionId), document);\n                }\n                else\n                {\n                    throw;\n                }\n            }\n        }\n    }\n}\n", "golden_completion": "            document.Name = \"Jane Doe\";\n            document.Age = 35;\n            await this.client.ReplaceDocumentAsync(UriFactory.CreateDocumentUri(\"TestDatabase\", \"TestCollection\", \"1\"), document);\n", "LLM_justification": "This test case demonstrates the usage of the Azure Cosmos DB .NET SDK to perform CRUD operations on a document in a database. It specifically tests the LLM's ability to recognize and correctly use the deprecated DocumentClient API, which has been replaced by the newer CosmosClient API in recent SDK versions. The completion involves updating an existing document and ensures correct parameter ordering and API behavior through assertions. The setup and teardown logic in the prefix and suffix ensure resource cleanup and validate the successful execution of the operations.", "assertions": "", "o1-preview": ""}
{"id": "50", "testsource": "devbench-api-usage", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing Microsoft.Azure.Cosmos;\nusing System.Threading.Tasks;\n\nnamespace AzureCosmosDBExample\n{\n    public class Program\n    {\n        private static readonly string EndpointUri = \"https://<your-account>.documents.azure.com:443/\";\n        private static readonly string PrimaryKey = \"<your-primary-key>\";\n        private static CosmosClient cosmosClient;\n        private static Database database;\n        private static Container container;\n\n        public static async Task Main(string[] args)\n        {\n            try\n            {\n                cosmosClient = new CosmosClient(EndpointUri, PrimaryKey);\n                database = await cosmosClient.CreateDatabaseIfNotExistsAsync(\"SampleDatabase\");\n                container = await database.CreateContainerIfNotExistsAsync(\"SampleContainer\", \"/id\");\n\n                await AddItemToContainerAsync();\n            }\n            catch (CosmosException ex)\n            {\n                Console.WriteLine($\"Cosmos DB error: {ex.Message}\");\n            }\n            finally\n            {\n                cosmosClient?.Dispose();\n            }\n        }\n\n        private static async Task AddItemToContainerAsync()\n        {\n            var sampleItem = new { id = \"1\", Name = \"Sample Item\", Description = \"This is a sample item.\" };\n            try\n            {\n                ItemResponse<dynamic> response = await container.CreateItemAsync(sampleItem, new PartitionKey(sampleItem.id));\n                Console.WriteLine($\"Item created with status code: {response.StatusCode}\");\n", "suffix": "\n                Debug.Assert(response.Resource.id == sampleItem.id, \"Item ID does not match\");\n                Debug.Assert(response.Resource.Name == sampleItem.Name, \"Item Name does not match\");\n                Debug.Assert(response.StatusCode == System.Net.HttpStatusCode.Created, \"Item was not created successfully\");\n            }\n            catch (CosmosException ex)\n            {\n                Console.WriteLine($\"Cosmos DB error: {ex.Message}\");\n            }\n        }\n    }\n}\n", "golden_completion": "                response = await container.ReadItemAsync<dynamic>(sampleItem.id, new PartitionKey(sampleItem.id));\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving Azure Cosmos DB, an uncommon library function. The golden completion involves reading an item that was previously created, which is a typical but less common operation. The suffix includes assertions to verify the correctness of the item read operation, ensuring that the item ID and Name match the expected values and that the item was successfully created with a specific HTTP status code.", "assertions": "", "o1-preview": ""}
