{"id": "1", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace DataValidationExample\n{\n    public class DataValidator\n    {\n        private List<Func<string, bool>> validationRules;\n\n        public DataValidator()\n        {\n            validationRules = new List<Func<string, bool>>();\n        }\n\n        public void AddRule(Func<string, bool> rule)\n        {\n            validationRules.Add(rule);\n        }\n\n        public bool Validate(string input)\n        {\n            foreach (var rule in validationRules)\n            {\n                if (!rule(input))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static void Main(string[] args)\n        {\n            DataValidator validator = new DataValidator();\n\n            // Add rule to check if input is not empty\n            validator.AddRule(input => !string.IsNullOrEmpty(input));\n\n            // Add rule to check if input is a valid email\n            validator.AddRule(input => input.Contains(\"@\") && input.Contains(\".\"));\n\n            // Add rule to check if input length is greater than 5\n            validator.AddRule(input => input.Length > 5);\n\n            // Add rule to check if input contains no spaces\n", "suffix": "            // Assertions\n            Debug.Assert(validator.Validate(\"test@example.com\"), \"Valid email should pass all rules.\");\n            Debug.Assert(!validator.Validate(\"invalid\"), \"Invalid email should fail.\");\n            Debug.Assert(!validator.Validate(\"short@e.\"), \"Email too short should fail.\");\n            Debug.Assert(!validator.Validate(\"test @example.com\"), \"Email with spaces should fail.\");\n\n            Console.WriteLine(\"All assertions passed.\");\n        }\n    }\n}\n", "golden_completion": "            validator.AddRule(input => !input.Contains(\" \"));\n", "LLM_justification": "This test case examines the ability to recognize and continue a pattern of adding validation rules to a DataValidator class. The prefix sets up the class and adds three rules, establishing a clear pattern of adding lambda functions as validation rules. The golden_completion continues this pattern by adding another rule, and the suffix includes assertions that verify the functionality of the rules. This pattern is common in data validation scenarios and tests the model's understanding of higher-order functions and lambda expressions.", "assertions": "", "gpt-35-turbo-completions": "// Add rule to check if input is a valid phone number\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid date\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid URL\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid IP address\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid credit card number\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid postal code\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid password\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid username\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid social security number\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid hexadecimal color code\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid MAC address\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid UUID\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid JSON\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid XML\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid HTML\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid CSS\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SQL\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid JWT\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid Base64 string\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid MD5 hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-1 hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-256 hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-512 hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid MD5 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-1 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-256 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-512 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid MD5 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-1 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-256 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-512 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid MD5 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-1 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-256 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid SHA-512 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input is a valid MD5 file hash\n#TODO: You Code Here\n\n            // Add rule to check if input"}
{"id": "2", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace DataValidationExample\n{\n    public class DataValidator\n    {\n        private List<string> errors;\n\n        public DataValidator()\n        {\n            errors = new List<string>();\n        }\n\n        public bool ValidateUsername(string username)\n        {\n            if (string.IsNullOrEmpty(username))\n            {\n                errors.Add(\"Username cannot be null or empty.\");\n                return false;\n            }\n            if (username.Length < 6)\n            {\n                errors.Add(\"Username must be at least 6 characters long.\");\n                return false;\n            }\n            return true;\n        }\n\n        public bool ValidateEmail(string email)\n        {\n            if (string.IsNullOrEmpty(email))\n            {\n                errors.Add(\"Email cannot be null or empty.\");\n                return false;\n            }\n            if (!email.Contains(\"@\"))\n            {\n                errors.Add(\"Email must contain an '@' character.\");\n                return false;\n            }\n            return true;\n        }\n\n        public bool ValidatePhoneNumber(string phoneNumber)\n        {\n            if (string.IsNullOrEmpty(phoneNumber))\n            {\n                errors.Add(\"Phone number cannot be null or empty.\");\n                return false;\n            }\n            if (phoneNumber.Length != 10)\n            {\n                errors.Add(\"Phone number must be exactly 10 digits long.\");\n                return false;\n            }\n            return true;\n        }\n\n        public List<string> GetErrors()\n        {\n            return errors;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DataValidator validator = new DataValidator();\n            bool isUsernameValid = validator.ValidateUsername(\"user\");\n            bool isEmailValid = validator.ValidateEmail(\"user@example.com\");\n", "suffix": "            Debug.Assert(isUsernameValid == false, \"Username validation failed\");\n            Debug.Assert(isEmailValid == true, \"Email validation failed\");\n            Debug.Assert(isPhoneNumberValid == true, \"Phone number validation failed\");\n\n            List<string> errors = validator.GetErrors();\n            Debug.Assert(errors.Count == 1, \"Error count mismatch\");\n            Debug.Assert(errors[0] == \"Username must be at least 6 characters long.\", \"Error message mismatch\");\n\n            Console.WriteLine(\"All validations and assertions passed.\");\n        }\n    }\n}\n", "golden_completion": "            bool isPhoneNumberValid = validator.ValidatePhoneNumber(\"1234567890\");\n", "LLM_justification": "This test case is designed to check the pattern matching capabilities of an LLM by focusing on data validation in a realistic scenario. The prefix establishes a clear pattern for validation methods that include null/empty checks and specific format checks, followed by adding error messages to a list. The golden completion needs to follow this established pattern to validate a username, email, and phone number. The suffix includes assertions to verify the correctness of the validations and the error messages, ensuring the LLM's completion maintains the pattern and functionality.", "assertions": "", "gpt-35-turbo-completions": "bool isPhoneNumberValid = validator.ValidatePhoneNumber(\"1234567890\");"}
{"id": "3", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace ScientificComputing\n{\n    public class DataAnalyzer\n    {\n        private List<double> data;\n\n        public DataAnalyzer()\n        {\n            data = new List<double>();\n        }\n\n        public void AddData(double value)\n        {\n            data.Add(value);\n        }\n\n        public double CalculateMean()\n        {\n            if (data.Count == 0)\n                throw new InvalidOperationException(\"No data to calculate mean.\");\n\n            double sum = 0;\n            foreach (var value in data)\n            {\n                sum += value;\n            }\n            return sum / data.Count;\n        }\n\n        public double CalculateVariance()\n        {\n            if (data.Count == 0)\n                throw new InvalidOperationException(\"No data to calculate variance.\");\n\n            double mean = CalculateMean();\n            double sumOfSquares = 0;\n            foreach (var value in data)\n            {\n                sumOfSquares += Math.Pow(value - mean, 2);\n            }\n            return sumOfSquares / data.Count;\n        }\n\n        public double CalculateStandardDeviation()\n        {\n            return Math.Sqrt(CalculateVariance());\n        }\n", "suffix": "        public double CalculateSkewness()\n        {\n            if (data.Count == 0)\n                throw new InvalidOperationException(\"No data to calculate skewness.\");\n\n            double mean = CalculateMean();\n            double variance = CalculateVariance();\n            double standardDeviation = Math.Sqrt(variance);\n            double sumOfCubes = 0;\n\n            foreach (var value in data)\n            {\n                sumOfCubes += Math.Pow(value - mean, 3);\n            }\n\n            double n = data.Count;\n            return (n / ((n - 1) * (n - 2))) * (sumOfCubes / Math.Pow(standardDeviation, 3));\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            DataAnalyzer analyzer = new DataAnalyzer();\n            analyzer.AddData(1.0);\n            analyzer.AddData(2.0);\n            analyzer.AddData(3.0);\n            analyzer.AddData(4.0);\n            analyzer.AddData(5.0);\n\n            double mean = analyzer.CalculateMean();\n            double variance = analyzer.CalculateVariance();\n            double stddev = analyzer.CalculateStandardDeviation();\n            double skewness = analyzer.CalculateSkewness();\n            double kurtosis = analyzer.CalculateKurtosis();\n\n            Debug.Assert(Math.Abs(mean - 3.0) < 1e-10, \"Mean calculation is incorrect.\");\n            Debug.Assert(Math.Abs(variance - 2.0) < 1e-10, \"Variance calculation is incorrect.\");\n            Debug.Assert(Math.Abs(stddev - Math.Sqrt(2.0)) < 1e-10, \"Standard deviation calculation is incorrect.\");\n            Debug.Assert(Math.Abs(skewness - 0.0) < 1e-10, \"Skewness calculation is incorrect.\");\n        }\n    }\n}\n", "golden_completion": "        public double CalculateKurtosis()\n        {\n            if (data.Count == 0)\n                throw new InvalidOperationException(\"No data to calculate kurtosis.\");\n\n            double mean = CalculateMean();\n            double variance = CalculateVariance();\n            double standardDeviation = Math.Sqrt(variance);\n            double sumOfQuads = 0;\n\n            foreach (var value in data)\n            {\n                sumOfQuads += Math.Pow(value - mean, 4);\n            }\n\n            double n = data.Count;\n            return (n * (n + 1) * sumOfQuads / (Math.Pow(standardDeviation, 4) * (n - 1) * (n - 2) * (n - 3))) - (3 * Math.Pow(n - 1, 2) / ((n - 2) * (n - 3)));\n        }\n", "LLM_justification": "This scenario tests the LLM's ability to recognize a pattern in statistical computation methods within a class. The prefix establishes methods for calculating mean, variance, and standard deviation, illustrating a pattern in handling statistical data. The completion requires implementing a method for calculating kurtosis, which should follow the established pattern of statistical calculations. The suffix then adds an additional method for calculating skewness and includes assertions that verify the calculations for mean, variance, standard deviation, and skewness, ensuring the pattern is correctly followed and results are accurate.", "assertions": "", "gpt-35-turbo-completions": "public double CalculateKurtosis()\n        {\n            if (data.Count == 0)\n                throw new InvalidOperationException(\"No data to calculate kurtosis.\");\n\n            double mean = CalculateMean();\n            double variance = CalculateVariance();\n            double standardDeviation = Math.Sqrt(variance);\n            double sumOfQuads = 0;\n\n            foreach (var value in data)\n            {\n                sumOfQuads += Math.Pow(value - mean, 4);\n            }\n\n            double n = data.Count;\n            return (n * (n + 1) / ((n - 1) * (n - 2) * (n - 3))) * (sumOfQuads / Math.Pow(standardDeviation, 4));\n        }"}
{"id": "4", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace AnalyticsExample\n{\n    public class Metric\n    {\n        public string Name { get; }\n        public double Value { get; }\n\n        public Metric(string name, double value)\n        {\n            Name = name;\n            Value = value;\n        }\n    }\n\n    public class AnalyticsProcessor\n    {\n        private readonly List<Metric> _metrics;\n\n        public AnalyticsProcessor()\n        {\n            _metrics = new List<Metric>();\n        }\n\n        public void AddMetric(string name, double value)\n        {\n            _metrics.Add(new Metric(name, value));\n        }\n\n        public double CalculateAverage(string metricName)\n        {\n            double sum = 0;\n            int count = 0;\n            foreach (var metric in _metrics)\n            {\n                if (metric.Name == metricName)\n                {\n                    sum += metric.Value;\n                    count++;\n                }\n            }\n            return count > 0 ? sum / count : 0;\n        }\n\n        public double CalculateMax(string metricName)\n        {\n            double max = double.MinValue;\n            foreach (var metric in _metrics)\n            {\n                if (metric.Name == metricName)\n                {\n                    if (metric.Value > max)\n                    {\n                        max = metric.Value;\n                    }\n                }\n            }\n            return max;\n        }\n\n        public double CalculateMin(string metricName)\n        {\n            double min = double.MaxValue;\n            foreach (var metric in _metrics)\n            {\n                if (metric.Name == metricName)\n                {\n                    if (metric.Value < min)\n                    {\n                        min = metric.Value;\n                    }\n                }\n            }\n            return min;\n        }\n\n        // Method to calculate the sum of a specific metric\n", "suffix": "    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            AnalyticsProcessor processor = new AnalyticsProcessor();\n            processor.AddMetric(\"MetricA\", 10);\n            processor.AddMetric(\"MetricA\", 20);\n            processor.AddMetric(\"MetricA\", 30);\n            processor.AddMetric(\"MetricB\", 5);\n            processor.AddMetric(\"MetricB\", 15);\n\n            double averageA = processor.CalculateAverage(\"MetricA\");\n            double maxA = processor.CalculateMax(\"MetricA\");\n            double minA = processor.CalculateMin(\"MetricA\");\n            double sumA = processor.CalculateSum(\"MetricA\");\n\n            Debug.Assert(averageA == 20, \"Average calculation for MetricA is incorrect\");\n            Debug.Assert(maxA == 30, \"Max calculation for MetricA is incorrect\");\n            Debug.Assert(minA == 10, \"Min calculation for MetricA is incorrect\");\n            Debug.Assert(sumA == 60, \"Sum calculation for MetricA is incorrect\");\n\n            double averageB = processor.CalculateAverage(\"MetricB\");\n            double maxB = processor.CalculateMax(\"MetricB\");\n            double minB = processor.CalculateMin(\"MetricB\");\n            double sumB = processor.CalculateSum(\"MetricB\");\n\n            Debug.Assert(averageB == 10, \"Average calculation for MetricB is incorrect\");\n            Debug.Assert(maxB == 15, \"Max calculation for MetricB is incorrect\");\n            Debug.Assert(minB == 5, \"Min calculation for MetricB is incorrect\");\n            Debug.Assert(sumB == 20, \"Sum calculation for MetricB is incorrect\");\n        }\n    }\n}\n", "golden_completion": "        public double CalculateSum(string metricName)\n        {\n            double sum = 0;\n            foreach (var metric in _metrics)\n            {\n                if (metric.Name == metricName)\n                {\n                    sum += metric.Value;\n                }\n            }\n            return sum;\n        }\n    }\n", "LLM_justification": "This test case is designed to assess the ability of an LLM to recognize and complete a common pattern in analytics computation. The pattern involves iterating over a list of metrics to perform various calculations (average, max, min, sum) based on a specified metric name. The prefix establishes the pattern with methods for calculating average, max, and min values. The golden completion requires the LLM to implement a method that follows the same pattern to calculate the sum of metric values. The suffix continues with different code that verifies the correctness of all calculations through assertions. This scenario is realistic for analytics processing and tests the LLM's understanding of iteration and conditional logic in C#.", "assertions": "", "gpt-35-turbo-completions": "public double CalculateSum(string metricName)\n        {\n            double sum = 0;\n            foreach (var metric in _metrics)\n            {\n                if (metric.Name == metricName)\n                {\n                    sum += metric.Value;\n                }\n            }\n            return sum;\n        }\n    }"}
{"id": "5", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace PatternMatchingExample\n{\n    public class DataAnalyzer\n    {\n        private List<double> data;\n\n        public DataAnalyzer(List<double> inputData)\n        {\n            data = inputData;\n        }\n\n        public double CalculateMean()\n        {\n            double sum = 0;\n            foreach (var item in data)\n            {\n                sum += item;\n            }\n            return sum / data.Count;\n        }\n\n        public double CalculateMedian()\n        {\n            data.Sort();\n            int count = data.Count;\n            if (count % 2 == 0)\n            {\n                return (data[count / 2 - 1] + data[count / 2]) / 2;\n            }\n            else\n            {\n                return data[count / 2];\n            }\n        }\n\n        public double CalculateStandardDeviation()\n        {\n            double mean = CalculateMean();\n            double sumOfSquares = 0;\n            foreach (var item in data)\n            {\n                sumOfSquares += Math.Pow(item - mean, 2);\n            }\n            return Math.Sqrt(sumOfSquares / data.Count);\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            List<double> sampleData = new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };\n            DataAnalyzer analyzer = new DataAnalyzer(sampleData);\n\n            double mean = analyzer.CalculateMean();\n            double median = analyzer.CalculateMedian();\n            double standardDeviation = analyzer.CalculateStandardDeviation();\n", "suffix": "            Debug.Assert(mean == 3.5, \"Mean calculation is incorrect\");\n            Debug.Assert(median == 3.5, \"Median calculation is incorrect\");\n            Debug.Assert(Math.Abs(standardDeviation - 1.707825127659933) < 0.0001, \"Standard deviation calculation is incorrect\");\n\n            Console.WriteLine(\"All calculations are correct!\");\n        }\n    }\n}\n", "golden_completion": "            double variance = analyzer.CalculateVariance();\n            Debug.Assert(Math.Abs(variance - 2.9166666666666665) < 0.0001, \"Variance calculation is incorrect\");\n", "LLM_justification": "This example tests the LLM's ability to recognize and extend a pattern of statistical calculation methods in a class. The prefix provides methods to calculate the mean, median, and standard deviation, which follow a clear pattern of data processing. The golden completion introduces a new method for calculating variance, which logically follows the existing pattern. The suffix includes assertions to verify the correctness of all calculations, ensuring that the pattern is maintained correctly. This scenario is realistic for scientific computing and demonstrates practical use of data analysis techniques.", "assertions": "", "gpt-35-turbo-completions": "// Add assertions to validate the correctness of the calculations\n            // Use the Debug.Assert method to validate the correctness of the calculations\n            // The mean of the sample data is 3.5\n            // The median of the sample data is 3.5\n            // The standard deviation of the sample data is 1.707825127659933\n            // Use the Math.Abs method to compare the standard deviation to the expected value\n            // The Math.Abs method returns the absolute value of a number\n            // The Math.Abs method takes a double as an argument and returns a double\n            // The Math.Abs method is used to compare the standard deviation to the expected value\n            // The Math.Abs method is used to compare the standard deviation to the expected value with a tolerance of 0.0001\n            // The Debug.Assert method is used to validate the correctness of the calculations\n            // The Debug.Assert method takes a boolean as an argument\n            // The Debug.Assert method takes a string as an argument\n            // The Debug.Assert method is used to validate the correctness of the calculations\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message\n            // The Debug.Assert method is used to validate the correctness of the calculations with a message"}
{"id": "6", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace ScientificComputing\n{\n    public class DataAnalyzer\n    {\n        public static double CalculateMean(List<double> data)\n        {\n            if (data == null || data.Count == 0)\n                throw new ArgumentException(\"Data cannot be null or empty.\");\n\n            double sum = 0;\n            foreach (var value in data)\n            {\n                sum += value;\n            }\n\n            double mean = sum / data.Count;\n            return mean;\n        }\n\n        public static double CalculateMedian(List<double> data)\n        {\n            if (data == null || data.Count == 0)\n                throw new ArgumentException(\"Data cannot be null or empty.\");\n\n            data.Sort();\n            int count = data.Count;\n            if (count % 2 == 0)\n            {\n                return (data[count / 2 - 1] + data[count / 2]) / 2.0;\n            }\n            else\n            {\n                return data[count / 2];\n            }\n        }\n\n        public static double CalculateVariance(List<double> data)\n        {\n            if (data == null || data.Count == 0)\n                throw new ArgumentException(\"Data cannot be null or empty.\");\n\n            double mean = CalculateMean(data);\n            double sumOfSquares = 0;\n            foreach (var value in data)\n            {\n                sumOfSquares += Math.Pow(value - mean, 2);\n            }\n\n            return sumOfSquares / data.Count;\n        }\n\n", "suffix": "\n        public static void Main()\n        {\n            List<double> sampleData = new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0 };\n\n            double mean = CalculateMean(sampleData);\n            double median = CalculateMedian(sampleData);\n            double variance = CalculateVariance(sampleData);\n            double standardDeviation = Math.Sqrt(variance);\n\n            Debug.Assert(Math.Abs(mean - 3.0) < 0.0001, \"Mean calculation is incorrect.\");\n            Debug.Assert(Math.Abs(median - 3.0) < 0.0001, \"Median calculation is incorrect.\");\n            Debug.Assert(Math.Abs(variance - 2.0) < 0.0001, \"Variance calculation is incorrect.\");\n            Debug.Assert(Math.Abs(standardDeviation - Math.Sqrt(2.0)) < 0.0001, \"Standard Deviation calculation is incorrect.\");\n        }\n    }\n}\n", "golden_completion": "        public static double CalculateStandardDeviation(List<double> data)\n        {\n            if (data == null || data.Count == 0)\n                throw new ArgumentException(\"Data cannot be null or empty.\");\n\n            double variance = CalculateVariance(data);\n            return Math.Sqrt(variance);\n        }\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a pattern in scientific computing, specifically related to statistical calculations (mean, median, variance). The pattern involves creating a method that performs statistical analysis on a list of doubles. The golden completion should follow the established pattern of validating input, calculating an intermediate result, and returning the final value. The suffix includes assertions to verify that all statistical calculations, including the newly implemented standard deviation, are correct.", "assertions": "", "gpt-35-turbo-completions": "public static double CalculateStandardDeviation(List<double> data)\n        {\n            if (data == null || data.Count == 0)\n                throw new ArgumentException(\"Data cannot be null or empty.\");\n\n            double variance = CalculateVariance(data);\n            return Math.Sqrt(variance);\n        }\n    }\n\n    public class Program\n    {"}
{"id": "7", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace DataValidationExample\n{\n    public class DataValidator\n    {\n        public List<string> Errors { get; private set; }\n\n        public DataValidator()\n        {\n            Errors = new List<string>();\n        }\n\n        public bool ValidateEmail(string email)\n        {\n            if (string.IsNullOrEmpty(email))\n            {\n                Errors.Add(\"Email is null or empty.\");\n                return false;\n            }\n            if (!email.Contains(\"@\"))\n            {\n                Errors.Add(\"Email does not contain '@'.\");\n                return false;\n            }\n            if (!email.Contains(\".\"))\n            {\n                Errors.Add(\"Email does not contain a domain.\");\n                return false;\n            }\n            return true;\n        }\n\n        public bool ValidatePhoneNumber(string phoneNumber)\n        {\n            if (string.IsNullOrEmpty(phoneNumber))\n            {\n                Errors.Add(\"Phone number is null or empty.\");\n                return false;\n            }\n            if (phoneNumber.Length < 10)\n            {\n                Errors.Add(\"Phone number is too short.\");\n                return false;\n            }\n            foreach (char c in phoneNumber)\n            {\n                if (!char.IsDigit(c))\n                {\n                    Errors.Add(\"Phone number contains non-digit characters.\");\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public bool ValidatePassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n            {\n                Errors.Add(\"Password is null or empty.\");\n                return false;\n            }\n            if (password.Length < 8)\n            {\n                Errors.Add(\"Password is too short.\");\n                return false;\n            }\n            bool hasUpperCase = false;\n            bool hasLowerCase = false;\n            bool hasDigit = false;\n            foreach (char c in password)\n            {\n                if (char.IsUpper(c)) hasUpperCase = true;\n                if (char.IsLower(c)) hasLowerCase = true;\n                if (char.IsDigit(c)) hasDigit = true;\n            }\n            if (!hasUpperCase)\n            {\n                Errors.Add(\"Password does not contain an uppercase letter.\");\n                return false;\n            }\n            if (!hasLowerCase)\n            {\n                Errors.Add(\"Password does not contain a lowercase letter.\");\n                return false;\n            }\n            if (!hasDigit)\n            {\n                Errors.Add(\"Password does not contain a digit.\");\n                return false;\n            }\n            return true;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            DataValidator validator = new DataValidator();\n            \n            bool isEmailValid = validator.ValidateEmail(\"example@domain.com\");\n            Debug.Assert(isEmailValid, \"Email validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPhoneNumberValid = validator.ValidatePhoneNumber(\"1234567890\");\n            Debug.Assert(isPhoneNumberValid, \"Phone number validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPasswordValid = validator.ValidatePassword(\"Password1\");\n            Debug.Assert(isPasswordValid, \"Password validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n", "suffix": "        }\n    }\n}\n", "golden_completion": "            bool isUsernameValid = validator.ValidateUsername(\"validUser123\");\n            Debug.Assert(isUsernameValid, \"Username validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n", "LLM_justification": "This example establishes a clear pattern of validating different types of input data (email, phone number, password) and adding errors to a list if validation fails. It tests the LLM's ability to recognize and continue this pattern by implementing a similar validation function for usernames. The completion involves checking if the username is valid and asserting the results, following the same validation and error-handling pattern established in the prefix. The assertions ensure that the validation logic and error handling are correctly implemented.", "assertions": "", "gpt-35-turbo-completions": "bool isEmailValid2 = validator.ValidateEmail(\"example@domain\");\n            Debug.Assert(!isEmailValid2, \"Email validation failed.\");\n            Debug.Assert(validator.Errors.Count == 1, \"Unexpected errors found.\");\n\n            bool isPhoneNumberValid2 = validator.ValidatePhoneNumber(\"123456789\");\n            Debug.Assert(!isPhoneNumberValid2, \"Phone number validation failed.\");\n            Debug.Assert(validator.Errors.Count == 1, \"Unexpected errors found.\");\n\n            bool isPasswordValid2 = validator.ValidatePassword(\"password1\");\n            Debug.Assert(!isPasswordValid2, \"Password validation failed.\");\n            Debug.Assert(validator.Errors.Count == 1, \"Unexpected errors found.\");\n#TODO: You Code Here\n            bool isEmailValid3 = validator.ValidateEmail(\"\");\n            Debug.Assert(!isEmailValid3, \"Email validation failed.\");\n            Debug.Assert(validator.Errors.Count == 1, \"Unexpected errors found.\");\n\n            bool isPhoneNumberValid3 = validator.ValidatePhoneNumber(\"\");\n            Debug.Assert(!isPhoneNumberValid3, \"Phone number validation failed.\");\n            Debug.Assert(validator.Errors.Count == 1, \"Unexpected errors found.\");\n\n            bool isPasswordValid3 = validator.ValidatePassword(\"\");\n            Debug.Assert(!isPasswordValid3, \"Password validation failed.\");\n            Debug.Assert(validator.Errors.Count == 1, \"Unexpected errors found.\");\n#TODO: You Code Here\n            bool isEmailValid4 = validator.ValidateEmail(\"example@domain.com\");\n            Debug.Assert(isEmailValid4, \"Email validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPhoneNumberValid4 = validator.ValidatePhoneNumber(\"1234567890\");\n            Debug.Assert(isPhoneNumberValid4, \"Phone number validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPasswordValid4 = validator.ValidatePassword(\"Password1\");\n            Debug.Assert(isPasswordValid4, \"Password validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n#TODO: You Code Here\n            bool isEmailValid5 = validator.ValidateEmail(\"example@domain.com\");\n            Debug.Assert(isEmailValid5, \"Email validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPhoneNumberValid5 = validator.ValidatePhoneNumber(\"1234567890\");\n            Debug.Assert(isPhoneNumberValid5, \"Phone number validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPasswordValid5 = validator.ValidatePassword(\"Password1\");\n            Debug.Assert(isPasswordValid5, \"Password validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n#TODO: You Code Here\n            bool isEmailValid6 = validator.ValidateEmail(\"example@domain.com\");\n            Debug.Assert(isEmailValid6, \"Email validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPhoneNumberValid6 = validator.ValidatePhoneNumber(\"1234567890\");\n            Debug.Assert(isPhoneNumberValid6, \"Phone number validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPasswordValid6 = validator.ValidatePassword(\"Password1\");\n            Debug.Assert(isPasswordValid6, \"Password validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n#TODO: You Code Here\n            bool isEmailValid7 = validator.ValidateEmail(\"example@domain.com\");\n            Debug.Assert(isEmailValid7, \"Email validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPhoneNumberValid7 = validator.ValidatePhoneNumber(\"1234567890\");\n            Debug.Assert(isPhoneNumberValid7, \"Phone number validation failed.\");\n            Debug.Assert(validator.Errors.Count == 0, \"Unexpected errors found.\");\n\n            bool isPasswordValid7 = validator.ValidatePassword(\"Password"}
{"id": "8", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace DataValidation\n{\n    public class SchemaValidator\n    {\n        private readonly List<string> errors;\n\n        public SchemaValidator()\n        {\n            errors = new List<string>();\n        }\n\n        public bool ValidateLength(string field, int minLength, int maxLength)\n        {\n            if (field.Length < minLength || field.Length > maxLength)\n            {\n                errors.Add($\"Field '{field}' length is out of range ({minLength}-{maxLength})\");\n                return false;\n            }\n            return true;\n        }\n\n        public bool ValidateNotEmpty(string field)\n        {\n            if (string.IsNullOrEmpty(field))\n            {\n                errors.Add(\"Field cannot be empty\");\n                return false;\n            }\n            return true;\n        }\n\n        public bool ValidatePattern(string field, string pattern)\n        {\n            if (!System.Text.RegularExpressions.Regex.IsMatch(field, pattern))\n            {\n                errors.Add($\"Field '{field}' does not match the required pattern\");\n                return false;\n            }\n            return true;\n        }\n\n        // Function to validate if a string is a valid email address\n        public bool ValidateEmail(string email)\n        {\n            string emailPattern = \"^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$\";\n            return ValidatePattern(email, emailPattern);\n        }\n\n        // Function to validate if a string is a valid URL\n        public bool ValidateUrl(string url)\n        {\n            string urlPattern = \"^https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}$\";\n            return ValidatePattern(url, urlPattern);\n        }\n\n        // Function to validate if a string contains only digits\n        public bool ValidateDigitsOnly(string input)\n        {\n            string digitsPattern = \"^\\d+$\";\n            return ValidatePattern(input, digitsPattern);\n        }\n\n        public List<string> GetErrors()\n        {\n            return errors;\n        }\n    }\n\n    public static class Program\n    {\n        public static void Main()\n        {\n            SchemaValidator validator = new SchemaValidator();\n            validator.ValidateLength(\"Test\", 3, 10);\n            validator.ValidateNotEmpty(\"Test\");\n            validator.ValidatePattern(\"Test\", \"^[a-zA-Z]+$\");\n            validator.ValidateEmail(\"test@example.com\");\n            validator.ValidateUrl(\"https://example.com\");\n            validator.ValidateDigitsOnly(\"12345\");\n\n            // Validate a string to see if it contains only alphabetic characters\n", "suffix": "            bool isAlphabetic = validator.ValidatePattern(\"TestString\", \"^[a-zA-Z]+$\");\n            Debug.Assert(isAlphabetic, \"The string should contain only alphabetic characters\");\n\n            List<string> errors = validator.GetErrors();\n            Debug.Assert(errors.Count == 0, \"There should be no validation errors\");\n\n            Console.WriteLine(\"All validations passed.\");\n        }\n    }\n}\n", "golden_completion": "            validator.ValidatePattern(\"TestString\", \"^[a-zA-Z]+$\");\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue a pattern of validation functions within a schema validator class. The established pattern involves using regular expressions to validate different types of input (length, non-empty, email, URL, digits). The golden completion requires the LLM to continue the pattern by adding another validation function that checks if a string contains only alphabetic characters. This tests the LLM's understanding of the pattern and its ability to maintain consistency in function structure and naming conventions. The suffix includes assertions to ensure the validation logic works correctly and that no errors are present.", "assertions": "", "gpt-35-turbo-completions": "Debug.Assert(validator.ValidatePattern(\"TestString\", \"^[a-zA-Z]+$\"), \"The string should contain only alphabetic characters\");\n\n            // Validate a string to see if it contains only digits\n#TODO: You Code Here\n            Debug.Assert(validator.ValidatePattern(\"12345\", \"^\\d+$\"), \"The string should contain only digits\");\n\n            // Validate a string to see if it is a valid email address\n#TODO: You Code Here\n            Debug.Assert(validator.ValidateEmail(\"test@example.com\"), \"The email address should be valid\");\n\n            // Validate a string to see if it is a valid URL\n#TODO: You Code Here\n            Debug.Assert(validator.ValidateUrl(\"https://example.com\"), \"The URL should be valid\");\n\n            // Validate a string to see if it contains only alphabetic characters"}
{"id": "9", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace ScientificComputing\n{\n    public class DataAnalyzer\n    {\n        public List<double> Data { get; set; }\n\n        public DataAnalyzer()\n        {\n            Data = new List<double>();\n        }\n\n        public void AddData(double value)\n        {\n            Data.Add(value);\n        }\n\n        public double CalculateMean()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate mean.\");\n\n            double sum = 0;\n            foreach (var value in Data)\n            {\n                sum += value;\n            }\n            return sum / Data.Count;\n        }\n\n        public double CalculateVariance()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate variance.\");\n\n            double mean = CalculateMean();\n            double varianceSum = 0;\n            foreach (var value in Data)\n            {\n                varianceSum += Math.Pow(value - mean, 2);\n            }\n            return varianceSum / Data.Count;\n        }\n\n        // Pattern: Calculate standard deviation based on variance\n        public double CalculateStandardDeviation()\n        {\n            double variance = CalculateVariance();\n            return Math.Sqrt(variance);\n        }\n\n        // Pattern: Calculate median\n        public double CalculateMedian()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate median.\");\n\n            Data.Sort();\n            int midIndex = Data.Count / 2;\n            if (Data.Count % 2 == 0)\n            {\n                return (Data[midIndex - 1] + Data[midIndex]) / 2;\n            }\n            else\n            {\n                return Data[midIndex];\n            }\n        }\n        // Pattern: Calculate range\n", "suffix": "        // Continuing the pattern: Calculate mode\n        public double CalculateMode()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate mode.\");\n\n            var frequencyDict = new Dictionary<double, int>();\n            foreach (var value in Data)\n            {\n                if (frequencyDict.ContainsKey(value))\n                {\n                    frequencyDict[value]++;\n                }\n                else\n                {\n                    frequencyDict[value] = 1;\n                }\n            }\n\n            double mode = double.NaN;\n            int maxFrequency = 0;\n            foreach (var kvp in frequencyDict)\n            {\n                if (kvp.Value > maxFrequency)\n                {\n                    maxFrequency = kvp.Value;\n                    mode = kvp.Key;\n                }\n            }\n\n            Debug.Assert(!double.IsNaN(mode), \"Mode should not be NaN if data exists.\");\n            return mode;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var analyzer = new DataAnalyzer();\n            analyzer.AddData(1.0);\n            analyzer.AddData(2.0);\n            analyzer.AddData(2.0);\n            analyzer.AddData(3.0);\n            analyzer.AddData(4.0);\n\n            // Assertions for CalculateStandardDeviation\n            double stddev = analyzer.CalculateStandardDeviation();\n            Debug.Assert(Math.Abs(stddev - 1.0954) < 0.0001, \"Standard deviation calculation is incorrect.\");\n\n            // Assertions for CalculateMedian\n            double median = analyzer.CalculateMedian();\n            Debug.Assert(median == 2.0, \"Median calculation is incorrect.\");\n\n            // Assertions for CalculateMode\n            double mode = analyzer.CalculateMode();\n            Debug.Assert(mode == 2.0, \"Mode calculation is incorrect.\");\n        }\n    }\n}\n", "golden_completion": "        public double CalculateRange()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate range.\");\n\n            double min = double.MaxValue;\n            double max = double.MinValue;\n            foreach (var value in Data)\n            {\n                if (value < min) min = value;\n                if (value > max) max = value;\n            }\n            return max - min;\n        }\n", "LLM_justification": "This test case checks the LLM's ability to recognize and complete patterns in C# code related to statistical computations. The pattern involves calculating various statistical measures (mean, variance, standard deviation, median) from a list of data points. The golden completion continues this pattern by implementing a method to calculate the range, a common statistical measure. The suffix continues with a different statistical measure (mode) and includes assertions to validate the correct implementation of these methods. This scenario is realistic in the context of scientific computing and data analysis.", "assertions": "", "gpt-35-turbo-completions": "public double CalculateRange()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate range.\");\n\n            Data.Sort();\n            return Data[Data.Count - 1] - Data[0];\n        }\n\n        // Pattern: Calculate interquartile range\n        public double CalculateInterquartileRange()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate interquartile range.\");\n\n            Data.Sort();\n            int midIndex = Data.Count / 2;\n            if (Data.Count % 2 == 0)\n            {\n                List<double> lowerHalf = Data.GetRange(0, midIndex);\n                List<double> upperHalf = Data.GetRange(midIndex, midIndex);\n                return CalculateMedian(upperHalf) - CalculateMedian(lowerHalf);\n            }\n            else\n            {\n                List<double> lowerHalf = Data.GetRange(0, midIndex);\n                List<double> upperHalf = Data.GetRange(midIndex + 1, midIndex);\n                return CalculateMedian(upperHalf) - CalculateMedian(lowerHalf);\n            }\n        }\n\n        // Pattern: Calculate quartiles\n        public double CalculateFirstQuartile()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate quartiles.\");\n\n            Data.Sort();\n            int midIndex = Data.Count / 2;\n            if (Data.Count % 2 == 0)\n            {\n                List<double> lowerHalf = Data.GetRange(0, midIndex);\n                return CalculateMedian(lowerHalf);\n            }\n            else\n            {\n                List<double> lowerHalf = Data.GetRange(0, midIndex);\n                return CalculateMedian(lowerHalf);\n            }\n        }\n\n        public double CalculateThirdQuartile()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate quartiles.\");\n\n            Data.Sort();\n            int midIndex = Data.Count / 2;\n            if (Data.Count % 2 == 0)\n            {\n                List<double> upperHalf = Data.GetRange(midIndex, midIndex);\n                return CalculateMedian(upperHalf);\n            }\n            else\n            {\n                List<double> upperHalf = Data.GetRange(midIndex + 1, midIndex);\n                return CalculateMedian(upperHalf);\n            }\n        }\n\n        // Pattern: Calculate mode\n        public double CalculateMode()\n        {\n            if (Data.Count == 0) throw new InvalidOperationException(\"No data to calculate mode.\");\n\n            var frequencyDict = new Dictionary<double, int>();\n            foreach (var value in Data)\n            {\n                if (frequencyDict.ContainsKey(value))\n                {\n                    frequencyDict[value]++;\n                }\n                else\n                {\n                    frequencyDict[value] = 1;\n                }\n            }\n\n            double mode = double.NaN;\n            int maxFrequency = 0;\n            foreach (var kvp in frequencyDict)\n            {\n                if (kvp.Value > maxFrequency)\n                {\n                    maxFrequency = kvp.Value;\n                    mode = kvp.Key;\n                }\n            }\n\n            Debug.Assert(!double.IsNaN(mode), \"Mode should not be NaN if data exists.\");\n            return mode;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var analyzer = new DataAnalyzer();\n            analyzer.AddData(1.0);\n            analyzer.AddData(2.0);\n            analyzer.AddData(2.0);\n            analyzer.AddData(3.0);\n            analyzer.AddData(4.0);\n\n            // Assertions for CalculateStandardDeviation\n            double stddev = analyzer.CalculateStandardDeviation();\n            Debug.Assert(Math.Abs(stddev - 1.0954) < 0.0001, \"Standard deviation calculation is incorrect.\");\n\n            // Assertions for CalculateMedian\n            double median = analyzer.CalculateMedian();\n            Debug.Assert(median == 2.0, \"Median calculation is incorrect.\");"}
{"id": "10", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace SecurityExample\n{\n    public class EncryptionHelper\n    {\n        // Encrypts a string using a simple reversible algorithm\n        public string Encrypt(string data, string key)\n        {\n            if (string.IsNullOrEmpty(data)) throw new ArgumentNullException(nameof(data));\n            if (string.IsNullOrEmpty(key)) throw new ArgumentNullException(nameof(key));\n\n            var encrypted = new StringBuilder();\n            for (int i = 0; i < data.Length; i++)\n            {\n                encrypted.Append((char)(data[i] ^ key[i % key.Length]));\n            }\n            return encrypted.ToString();\n        }\n\n        // Decrypts a string using a simple reversible algorithm\n        public string Decrypt(string data, string key)\n        {\n            if (string.IsNullOrEmpty(data)) throw new ArgumentNullException(nameof(data));\n            if (string.IsNullOrEmpty(key)) throw new ArgumentNullException(nameof(key));\n\n            var decrypted = new StringBuilder();\n            for (int i = 0; i < data.Length; i++)\n            {\n                decrypted.Append((char)(data[i] ^ key[i % key.Length]));\n            }\n            return decrypted.ToString();\n        }\n\n        // Hashes a string using a simple hash algorithm\n        public string Hash(string data)\n        {\n            if (string.IsNullOrEmpty(data)) throw new ArgumentNullException(nameof(data));\n\n            int hash = 0;\n            for (int i = 0; i < data.Length; i++)\n            {\n                hash = (hash * 31) + data[i];\n            }\n            return hash.ToString(\"X\");\n        }\n\n        // Verifies a hash against a string\n        public bool VerifyHash(string data, string hash)\n        {\n            if (string.IsNullOrEmpty(data)) throw new ArgumentNullException(nameof(data));\n            if (string.IsNullOrEmpty(hash)) throw new ArgumentNullException(nameof(hash));\n\n            string computedHash = Hash(data);\n            return computedHash.Equals(hash, StringComparison.OrdinalIgnoreCase);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var helper = new EncryptionHelper();\n            string data = \"HelloWorld\";\n            string key = \"Key123\";\n\n            // Test encryption and decryption\n            string encrypted = helper.Encrypt(data, key);\n            Console.WriteLine($\"Encrypted: {encrypted}\");\n            string decrypted = helper.Decrypt(encrypted, key);\n            Console.WriteLine($\"Decrypted: {decrypted}\");\n            Debug.Assert(decrypted == data, \"Decryption failed\");\n", "suffix": "            // Edge case: empty data\n            try\n            {\n                helper.Encrypt(\"\", key);\n            }\n            catch (ArgumentNullException ex)\n            {\n                Debug.Assert(ex.ParamName == \"data\", \"Expected ArgumentNullException for data\");\n            }\n\n            try\n            {\n                helper.Decrypt(\"\", key);\n            }\n            catch (ArgumentNullException ex)\n            {\n                Debug.Assert(ex.ParamName == \"data\", \"Expected ArgumentNullException for data\");\n            }\n\n            try\n            {\n                helper.Hash(\"\");\n            }\n            catch (ArgumentNullException ex)\n            {\n                Debug.Assert(ex.ParamName == \"data\", \"Expected ArgumentNullException for data\");\n            }\n\n            try\n            {\n                helper.VerifyHash(\"\", hash);\n            }\n            catch (ArgumentNullException ex)\n            {\n                Debug.Assert(ex.ParamName == \"data\", \"Expected ArgumentNullException for data\");\n            }\n        }\n    }\n}\n", "golden_completion": "            // Test hashing and verification\n            string hash = helper.Hash(data);\n            Console.WriteLine($\"Hash: {hash}\");\n            bool isVerified = helper.VerifyHash(data, hash);\n            Console.WriteLine($\"Hash Verified: {isVerified}\");\n            Debug.Assert(isVerified, \"Hash verification failed\");\n", "LLM_justification": "This example tests the pattern matching capabilities of the LLM by establishing a clear pattern in the encryption, decryption, and hashing methods. The prefix includes multiple examples of error handling and method calls that follow a specific sequence and logic. The completion must follow this pattern to ensure the code remains consistent and functional. The suffix includes assertions to verify the correctness of the pattern adherence and functionality.", "assertions": "", "gpt-35-turbo-completions": "// Test hashing and verification\n            string hash = helper.Hash(data);\n            Console.WriteLine($\"Hash: {hash}\");\n            bool verified = helper.VerifyHash(data, hash);\n            Debug.Assert(verified, \"Hash verification failed\");\n#TODO: You Code Here"}
{"id": "11", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace SecurityExample\n{\n    public class EncryptionHelper\n    {\n        private static readonly byte[] Key = Encoding.UTF8.GetBytes(\"0123456789ABCDEF0123456789ABCDEF\"); // 32 bytes key\n        private static readonly byte[] IV = Encoding.UTF8.GetBytes(\"0123456789ABCDEF\"); // 16 bytes IV\n\n        // Encrypts the given plaintext using AES encryption\n        public static string Encrypt(string plainText)\n        {\n            if (plainText == null)\n                throw new ArgumentNullException(nameof(plainText));\n\n            using (Aes aesAlg = Aes.Create())\n            {\n                aesAlg.Key = Key;\n                aesAlg.IV = IV;\n                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);\n                using (System.IO.MemoryStream msEncrypt = new System.IO.MemoryStream())\n                {\n                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))\n                    {\n                        using (System.IO.StreamWriter swEncrypt = new System.IO.StreamWriter(csEncrypt))\n                        {\n                            swEncrypt.Write(plainText);\n                        }\n                        return Convert.ToBase64String(msEncrypt.ToArray());\n                    }\n                }\n            }\n        }\n\n        // Decrypts the given ciphertext using AES encryption\n        public static string Decrypt(string cipherText)\n        {\n            if (cipherText == null)\n                throw new ArgumentNullException(nameof(cipherText));\n\n            using (Aes aesAlg = Aes.Create())\n            {\n                aesAlg.Key = Key;\n                aesAlg.IV = IV;\n                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);\n                using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(cipherText)))\n                {\n                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))\n                    {\n                        using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))\n                        {\n                            return srDecrypt.ReadToEnd();\n                        }\n                    }\n                }\n            }\n        }\n\n        // Verifies the given plaintext and ciphertext match when decrypted\n        public static bool Verify(string plainText, string cipherText)\n        {\n            string decryptedText = Decrypt(cipherText);\n            return plainText == decryptedText;\n        }\n\n        // Example usage of the encryption and decryption methods\n        public static void Main(string[] args)\n        {\n            string originalText = \"Hello, World!\";\n            string encryptedText = Encrypt(originalText);\n            ", "suffix": "Debug.Assert(!string.IsNullOrEmpty(encryptedText), \"Encrypted text should not be null or empty\");\n            string decryptedText = Decrypt(encryptedText);\n            Debug.Assert(originalText == decryptedText, \"Decrypted text should match the original text\");\n\n            // Testing edge cases\n            string emptyText = \"\";\n            string encryptedEmptyText = Encrypt(emptyText);\n            Debug.Assert(Decrypt(encryptedEmptyText) == emptyText, \"Decrypted empty text should match the original empty text\");\n\n            string nullText = null;\n            try\n            {\n                Encrypt(nullText);\n                Debug.Assert(false, \"Encrypting null text should throw ArgumentNullException\");\n            }\n            catch (ArgumentNullException) { }\n\n            try\n            {\n                Decrypt(nullText);\n                Debug.Assert(false, \"Decrypting null text should throw ArgumentNullException\");\n            }\n            catch (ArgumentNullException) { }\n\n            Console.WriteLine(\"All tests passed.\");\n        }\n    }\n}\n", "golden_completion": "Debug.Assert(Verify(originalText, encryptedText), \"Verification failed: Decrypted text does not match the original text\");\n", "LLM_justification": "This example tests the LLM's ability to follow a clear pattern in encryption and decryption methods within the context of security. The prefix provides a comprehensive setup for AES encryption and decryption, establishing a pattern of using Aes.Create, ICryptoTransform, MemoryStream, and CryptoStream for the operations. The golden completion continues this pattern by verifying the integrity of the encryption/decryption process using the Verify method. The suffix then includes further assertions and edge case handling, ensuring the entire encryption-decryption cycle is robust and adheres to the established pattern.", "assertions": "", "gpt-35-turbo-completions": "// Verify that the decrypted text matches the original text"}
{"id": "12", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace SecurityExample\n{\n    public class EncryptionHelper\n    {\n        private static readonly byte[] Key = Encoding.UTF8.GetBytes(\"0123456789abcdef\");\n        private static readonly byte[] IV = Encoding.UTF8.GetBytes(\"abcdef9876543210\");\n\n        public static string EncryptString(string plainText)\n        {\n            using (Aes aesAlg = Aes.Create())\n            {\n                aesAlg.Key = Key;\n                aesAlg.IV = IV;\n\n                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);\n\n                using (System.IO.MemoryStream msEncrypt = new System.IO.MemoryStream())\n                {\n                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))\n                    {\n                        using (System.IO.StreamWriter swEncrypt = new System.IO.StreamWriter(csEncrypt))\n                        {\n                            // Write all data to the stream.\n                            swEncrypt.Write(plainText);\n                        }\n                        return Convert.ToBase64String(msEncrypt.ToArray());\n                    }\n                }\n            }\n        }\n\n        public static string DecryptString(string cipherText)\n        {\n            using (Aes aesAlg = Aes.Create())\n            {\n                aesAlg.Key = Key;\n                aesAlg.IV = IV;\n\n                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);\n\n                using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(cipherText)))\n                {\n                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))\n                    {\n                        using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))\n                        {\n                            // Read the decrypted bytes from the decrypting stream and place them in a string.\n                            return srDecrypt.ReadToEnd();\n                        }\n                    }\n                }\n            }\n        }\n\n        public static bool VerifyEncryption(string originalText)\n        {\n            string encryptedText = EncryptString(originalText);\n            string decryptedText = DecryptString(encryptedText);\n            return originalText == decryptedText;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            string testString = \"Hello, World!\";\n            string encrypted = EncryptionHelper.EncryptString(testString);\n            Console.WriteLine(\"Encrypted: \" + encrypted);\n\n            // Test pattern continuation for decryption and verification\n", "suffix": "            Console.WriteLine(\"Decrypted: \" + decrypted);\n\n            // Assertions\n            Debug.Assert(decrypted == testString, \"Decryption failed: decrypted text does not match original\");\n            Debug.Assert(EncryptionHelper.VerifyEncryption(testString), \"Verification failed: encrypted and decrypted text do not match\");\n        }\n    }\n}\n", "golden_completion": "            string decrypted = EncryptionHelper.DecryptString(encrypted);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern in error handling and encryption/decryption routines. The prefix sets up a clear pattern of using AES for encryption and decryption with proper resource management. The golden completion continues this pattern by correctly decrypting the previously encrypted string. The suffix then contains assertions to verify that the decryption works as expected and matches the original text, ensuring the pattern is followed correctly. This scenario is practical and relevant to security in software development.", "assertions": "", "gpt-35-turbo-completions": "string decrypted = EncryptionHelper.DecryptString(encrypted);"}
{"id": "13", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class MessageHandler\n    {\n        private readonly Queue<string> _messageQueue;\n        private readonly object _lockObject = new object();\n\n        public MessageHandler()\n        {\n            _messageQueue = new Queue<string>();\n        }\n\n        public void EnqueueMessage(string message)\n        {\n            lock (_lockObject)\n            {\n                _messageQueue.Enqueue(message);\n                Debug.WriteLine($\"Message Enqueued: {message}\");\n            }\n        }\n\n        public string DequeueMessage()\n        {\n            lock (_lockObject)\n            {\n                if (_messageQueue.Count > 0)\n                {\n                    string message = _messageQueue.Dequeue();\n                    Debug.WriteLine($\"Message Dequeued: {message}\");\n                    return message;\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"No messages to dequeue.\");\n                }\n            }\n        }\n\n        public int GetMessageCount()\n        {\n            lock (_lockObject)\n            {\n                return _messageQueue.Count;\n            }\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        MessageHandler handler = new MessageHandler();\n        handler.EnqueueMessage(\"Message 1\");\n        handler.EnqueueMessage(\"Message 2\");\n        handler.EnqueueMessage(\"Message 3\");\n\n        // Dequeue a message and assert the count\n        string dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 1\", \"The dequeued message should be 'Message 1'\");\n", "suffix": "        // Dequeue another message and assert the count\n        dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 3\", \"The dequeued message should be 'Message 2'\");\n\n        // Check the count of messages remaining\n        int remainingCount = handler.GetMessageCount();\n        Debug.Assert(remainingCount == 1, \"There should be one message left in the queue.\");\n\n        // Final dequeue and assert\n        dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 3\", \"The dequeued message should be 'Message 3'\");\n\n        // Ensure no messages are left\n        remainingCount = handler.GetMessageCount();\n        Debug.Assert(remainingCount == 0, \"There should be no messages left in the queue.\");\n    }\n}\n", "golden_completion": "        dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 2\", \"The dequeued message should be 'Message 2'\");\n", "LLM_justification": "This test case is a good example of pattern matching in C# because it demonstrates a common scenario in network protocols involving message queuing and synchronization. The pattern of locking, enqueuing, and dequeuing messages is clearly established. The golden completion must follow this established pattern by correctly handling message dequeueing and adhering to the locking mechanism. The suffix contains assertions that verify the correct order of messages and ensures the queue's state is as expected after operations, which helps validate the correctness of the pattern implementation.", "assertions": "", "gpt-35-turbo-completions": "// Check the count of messages remaining\n        int remainingCount = handler.GetMessageCount();\n        Debug.Assert(remainingCount == 2, \"There should be two messages left in the queue.\");\n\n        // Dequeue another message and assert the count\n        dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 2\", \"The dequeued message should be 'Message 2'\");\n\n        // Check the count of messages remaining\n        remainingCount = handler.GetMessageCount();\n        Debug.Assert(remainingCount == 1, \"There should be one message left in the queue.\");\n\n        // Final dequeue and assert\n        dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 3\", \"The dequeued message should be 'Message 3'\");\n\n        // Ensure no messages are left\n        remainingCount = handler.GetMessageCount();\n        Debug.Assert(remainingCount == 0, \"There should be no messages left in the queue.\");\n    }\n}\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class MessageHandler\n    {\n        private readonly Queue<string> _messageQueue;\n        private readonly object _lockObject = new object();\n\n        public MessageHandler()\n        {\n            _messageQueue = new Queue<string>();\n        }\n\n        public void EnqueueMessage(string message)\n        {\n            lock (_lockObject)\n            {\n                _messageQueue.Enqueue(message);\n                Debug.WriteLine($\"Message Enqueued: {message}\");\n            }\n        }\n\n        public string DequeueMessage()\n        {\n            lock (_lockObject)\n            {\n                if (_messageQueue.Count > 0)\n                {\n                    string message = _messageQueue.Dequeue();\n                    Debug.WriteLine($\"Message Dequeued: {message}\");\n                    return message;\n                }\n                else\n                {\n                    throw new InvalidOperationException(\"No messages to dequeue.\");\n                }\n            }\n        }\n\n        public int GetMessageCount()\n        {\n            lock (_lockObject)\n            {\n                return _messageQueue.Count;\n            }\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        MessageHandler handler = new MessageHandler();\n        handler.EnqueueMessage(\"Message 1\");\n        handler.EnqueueMessage(\"Message 2\");\n        handler.EnqueueMessage(\"Message 3\");\n\n        // Dequeue a message and assert the count\n        string dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 1\", \"The dequeued message should be 'Message 1'\");\n\n        // Check the count of messages remaining\n        int remainingCount = handler.GetMessageCount();\n        Debug.Assert(remainingCount == 2, \"There should be two messages left in the queue.\");\n\n        // Dequeue another message and assert the count\n        dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 2\", \"The dequeued message should be 'Message 2'\");\n\n        // Check the count of messages remaining\n        remainingCount = handler.GetMessageCount();\n        Debug.Assert(remainingCount == 1, \"There should be one message left in the queue.\");\n\n        // Final dequeue and assert\n        dequeuedMessage = handler.DequeueMessage();\n        Debug.Assert(dequeuedMessage == \"Message 3\", \"The dequeued message should be 'Message 3'\");\n\n        // Ensure no messages are left\n        remainingCount = handler.GetMessageCount();\n        Debug.Assert(remainingCount == 0, \"There should be no messages left in the queue.\");\n    }\n}\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class MessageHandler\n    {\n        private readonly Queue<string> _messageQueue;\n        private readonly object _lockObject = new object();\n\n        public MessageHandler()\n        {\n            _messageQueue = new Queue<string>();\n        }\n\n        public void EnqueueMessage(string message"}
{"id": "14", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace AnalyticsExample\n{\n    public class DataProcessor\n    {\n        private List<int> data;\n\n        public DataProcessor(List<int> initialData)\n        {\n            data = initialData;\n        }\n\n        public int CalculateSum()\n        {\n            int sum = 0;\n            foreach (var item in data)\n            {\n                sum += item;\n            }\n            return sum;\n        }\n\n        public double CalculateAverage()\n        {\n            int sum = CalculateSum();\n            return (double)sum / data.Count;\n        }\n\n        public int FindMax()\n        {\n            int max = int.MinValue;\n            foreach (var item in data)\n            {\n                if (item > max)\n                {\n                    max = item;\n                }\n            }\n            return max;\n        }\n\n        public int FindMin()\n        {\n            int min = int.MaxValue;\n            foreach (var item in data)\n            {\n                if (item < min)\n                {\n                    min = item;\n                }\n            }\n            return min;\n        }\n\n        public int CountGreaterThan(int threshold)\n        {\n            int count = 0;\n            foreach (var item in data)\n            {\n                if (item > threshold)\n                {\n                    count++;\n                }\n            }\n            return count;\n        }\n", "suffix": "        public int CountLessThan(int threshold)\n        {\n            int count = 0;\n            foreach (var item in data)\n            {\n                if (item < threshold)\n                {\n                    count++;\n                }\n            }\n            return count;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            List<int> sampleData = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            DataProcessor processor = new DataProcessor(sampleData);\n\n            Debug.Assert(processor.CountGreaterThan(5) == 5, \"CountGreaterThan(5) should be 5\");\n            Debug.Assert(processor.CountLessThan(5) == 4, \"CountLessThan(5) should be 4\");\n            Debug.Assert(processor.CountEqualTo(5) == 1, \"CountEqualTo(5) should be 1\");\n        }\n    }\n}\n", "golden_completion": "        public int CountEqualTo(int threshold)\n        {\n            int count = 0;\n            foreach (var item in data)\n            {\n                if (item == threshold)\n                {\n                    count++;\n                }\n            }\n            return count;\n        }\n", "LLM_justification": "This test case is a good example of pattern matching in C# because it involves a common scenario in analytics where different methods are created to process data in various ways. The pattern of iterating over the list and applying a condition is clearly established in the prefix with multiple methods. The LLM needs to recognize this pattern and apply it correctly to complete the CountEqualTo method. The suffix contains assertions to ensure that the completion follows the established pattern and works correctly.", "assertions": "", "gpt-35-turbo-completions": "public int CountEqualTo(int threshold)\n        {\n            int count = 0;\n            foreach (var item in data)\n            {\n                if (item == threshold)\n                {\n                    count++;\n                }\n            }\n            return count;\n        }"}
{"id": "15", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\npublic class ApiClient\n{\n    private readonly HttpClient _httpClient;\n\n    public ApiClient()\n    {\n        _httpClient = new HttpClient();\n    }\n\n    public async Task<string> GetDataAsync(string url)\n    {\n        try\n        {\n            HttpResponseMessage response = await _httpClient.GetAsync(url);\n            response.EnsureSuccessStatusCode();\n            string responseData = await response.Content.ReadAsStringAsync();\n            return responseData;\n        }\n        catch (HttpRequestException e)\n        {\n            // Log exception\n            Console.WriteLine($\"Request error: {e.Message}\");\n            return string.Empty;\n        }\n    }\n\n    public async Task<string> PostDataAsync(string url, HttpContent content)\n    {\n        try\n        {\n            HttpResponseMessage response = await _httpClient.PostAsync(url, content);\n            response.EnsureSuccessStatusCode();\n            string responseData = await response.Content.ReadAsStringAsync();\n            return responseData;\n        }\n        catch (HttpRequestException e)\n        {\n            // Log exception\n            Console.WriteLine($\"Request error: {e.Message}\");\n            return string.Empty;\n        }\n    }\n\n    public async Task<string> PutDataAsync(string url, HttpContent content)\n    {\n        try\n        {\n            HttpResponseMessage response = await _httpClient.PutAsync(url, content);\n            response.EnsureSuccessStatusCode();\n            string responseData = await response.Content.ReadAsStringAsync();\n            return responseData;\n        }\n        catch (HttpRequestException e)\n        {\n            // Log exception\n            Console.WriteLine($\"Request error: {e.Message}\");\n            return string.Empty;\n        }\n    }\n", "suffix": "    public async Task<string> DeleteDataAsync(string url)\n    {\n        try\n        {\n            HttpResponseMessage response = await _httpClient.DeleteAsync(url);\n            response.EnsureSuccessStatusCode();\n            string responseData = await response.Content.ReadAsStringAsync();\n            Debug.Assert(responseData != null, \"Response data should not be null\");\n            Debug.Assert(response.IsSuccessStatusCode, \"Response should be successful\");\n            return responseData;\n        }\n        catch (HttpRequestException e)\n        {\n            Console.WriteLine($\"Request error: {e.Message}\");\n            Debug.Assert(false, \"Exception should not be thrown\");\n            return string.Empty;\n        }\n    }\n\n    public void Dispose()\n    {\n        _httpClient.Dispose();\n    }\n}\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        ApiClient apiClient = new ApiClient();\n        string result = await apiClient.DeleteDataAsync(\"https://example.com/api/resource/1\");\n        Debug.Assert(result != null, \"Result should not be null\");\n        apiClient.Dispose();\n    }\n}\n", "golden_completion": "    public async Task<string> PatchDataAsync(string url, HttpContent content)\n    {\n        try\n        {\n            HttpResponseMessage response = await _httpClient.PatchAsync(url, content);\n            response.EnsureSuccessStatusCode();\n            string responseData = await response.Content.ReadAsStringAsync();\n            return responseData;\n        }\n        catch (HttpRequestException e)\n        {\n            // Log exception\n            Console.WriteLine($\"Request error: {e.Message}\");\n            return string.Empty;\n        }\n    }\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue the pattern of error handling in HTTP methods within an API client class. The prefix establishes a clear pattern with multiple methods demonstrating consistent error handling and response processing. The golden completion is expected to follow this pattern, adding a new method for PATCH requests with the same structure and best practices. The suffix introduces a different method (DELETE) and includes assertions to verify behavior, ensuring the LLM maintains pattern adherence and functionality.", "assertions": "", "gpt-35-turbo-completions": "public async Task<string> PatchDataAsync(string url, HttpContent content)\n    {\n        try\n        {\n            var request = new HttpRequestMessage(new HttpMethod(\"PATCH\"), url)\n            {\n                Content = content\n            };\n            HttpResponseMessage response = await _httpClient.SendAsync(request);\n            response.EnsureSuccessStatusCode();\n            string responseData = await response.Content.ReadAsStringAsync();\n            return responseData;\n        }\n        catch (HttpRequestException e)\n        {\n            // Log exception\n            Console.WriteLine($\"Request error: {e.Message}\");\n            return string.Empty;\n        }\n    }"}
{"id": "16", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public enum EnemyType\n    {\n        Goblin,\n        Orc,\n        Dragon\n    }\n\n    public class Enemy\n    {\n        public EnemyType Type { get; set; }\n        public int Health { get; set; }\n        public int AttackPower { get; set; }\n\n        public Enemy(EnemyType type, int health, int attackPower)\n        {\n            Type = type;\n            Health = health;\n            AttackPower = attackPower;\n        }\n    }\n\n    public class GameState\n    {\n        private List<Enemy> _enemies;\n\n        public GameState()\n        {\n            _enemies = new List<Enemy>();\n        }\n\n        public void AddEnemy(Enemy enemy)\n        {\n            _enemies.Add(enemy);\n        }\n\n        public void RemoveEnemy(Enemy enemy)\n        {\n            _enemies.Remove(enemy);\n        }\n\n        public Enemy FindStrongestEnemy()\n        {\n            Enemy strongest = null;\n            foreach (var enemy in _enemies)\n            {\n                if (strongest == null || enemy.AttackPower > strongest.AttackPower)\n                {\n                    strongest = enemy;\n                }\n            }\n            return strongest;\n        }\n\n        // Additional pattern of finding enemy by type\n        public Enemy FindEnemyByType(EnemyType type)\n        {\n            foreach (var enemy in _enemies)\n            {\n                if (enemy.Type == type)\n                {\n                    return enemy;\n                }\n            }\n            return null;\n        }\n\n        // Additional pattern of finding weakest enemy\n        public Enemy FindWeakestEnemy()\n        {\n            Enemy weakest = null;\n            foreach (var enemy in _enemies)\n            {\n                if (weakest == null || enemy.AttackPower < weakest.AttackPower)\n                {\n                    weakest = enemy;\n                }\n            }\n            return weakest;\n        }\n\n        // More code related to game state management...\n", "suffix": "        public void TestGameState()\n        {\n            var gameState = new GameState();\n            var goblin = new Enemy(EnemyType.Goblin, 30, 5);\n            var orc = new Enemy(EnemyType.Orc, 50, 10);\n            var dragon = new Enemy(EnemyType.Dragon, 100, 20);\n\n            gameState.AddEnemy(goblin);\n            gameState.AddEnemy(orc);\n            gameState.AddEnemy(dragon);\n\n            Debug.Assert(gameState.FindStrongestEnemy() == dragon, \"Strongest enemy should be dragon.\");\n            Debug.Assert(gameState.FindEnemyByType(EnemyType.Orc) == orc, \"Should find orc.\");\n            Debug.Assert(gameState.FindWeakestEnemy() == goblin, \"Weakest enemy should be goblin.\");\n            Debug.Assert(gameState.CountEnemiesOfType(EnemyType.Goblin) == 1, \"There should be one goblin.\");\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var gameState = new GameMechanics.GameState();\n        gameState.TestGameState();\n    }\n}", "golden_completion": "        public int CountEnemiesOfType(EnemyType type)\n        {\n            int count = 0;\n            foreach (var enemy in _enemies)\n            {\n                if (enemy.Type == type)\n                {\n                    count++;\n                }\n            }\n            return count;\n        }\n", "LLM_justification": "This test case demonstrates the pattern of implementing methods to query a collection of enemies in a game state. The prefix establishes methods for finding the strongest, weakest, and enemies by type. The golden completion continues this pattern by adding a method to count enemies of a specific type. The suffix completes the example by adding assertions to validate the functionality and pattern adherence.", "assertions": "", "gpt-35-turbo-completions": "public int CountEnemiesOfType(EnemyType type)\n        {\n            int count = 0;\n            foreach (var enemy in _enemies)\n            {\n                if (enemy.Type == type)\n                {\n                    count++;\n                }\n            }\n            return count;\n        }\n\n        // More code related to game state management...\n#TODO: You Code Here\n        public void TestGameState()\n        {\n            var gameState = new GameState();\n            var goblin = new Enemy(EnemyType.Goblin, 30, 5);\n            var orc = new Enemy(EnemyType.Orc, 50, 10);\n            var dragon = new Enemy(EnemyType.Dragon, 100, 20);\n\n            gameState.AddEnemy(goblin);\n            gameState.AddEnemy(orc);\n            gameState.AddEnemy(dragon);\n\n            Debug.Assert(gameState.FindStrongestEnemy() == dragon, \"Strongest enemy should be dragon.\");\n            Debug.Assert(gameState.FindEnemyByType(EnemyType.Orc) == orc, \"Should find orc.\");\n            Debug.Assert(gameState.FindWeakestEnemy() == goblin, \"Weakest enemy should be goblin.\");\n            Debug.Assert(gameState.CountEnemiesOfType(EnemyType.Goblin) == 1, \"There should be one goblin.\");\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var gameState = new GameMechanics.GameState();\n        gameState.TestGameState();\n    }\n}\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public enum EnemyType\n    {\n        Goblin,\n        Orc,\n        Dragon\n    }\n\n    public class Enemy\n    {\n        public EnemyType Type { get; set; }\n        public int Health { get; set; }\n        public int AttackPower { get; set; }\n\n        public Enemy(EnemyType type, int health, int attackPower)\n        {\n            Type = type;\n            Health = health;\n            AttackPower = attackPower;\n        }\n    }\n\n    public class GameState\n    {\n        private List<Enemy> _enemies;\n\n        public GameState()\n        {\n            _enemies = new List<Enemy>();\n        }\n\n        public void AddEnemy(Enemy enemy)\n        {\n            _enemies.Add(enemy);\n        }\n\n        public void RemoveEnemy(Enemy enemy)\n        {\n            _enemies.Remove(enemy);\n        }\n\n        public Enemy FindStrongestEnemy()\n        {\n            Enemy strongest = null;\n            foreach (var enemy in _enemies)\n            {\n                if (strongest == null || enemy.AttackPower > strongest.AttackPower)\n                {\n                    strongest = enemy;\n                }\n            }\n            return strongest;\n        }\n\n        // Additional pattern of finding enemy by type\n        public Enemy FindEnemyByType(EnemyType type)\n        {\n            foreach (var enemy in _enemies)\n            {\n                if (enemy.Type == type)\n                {\n                    return enemy;\n                }\n            }\n            return null;\n        }\n\n        // Additional pattern of finding weakest enemy\n        public Enemy FindWeakestEnemy()\n        {\n            Enemy weakest = null;\n            foreach (var enemy in _enemies)\n            {\n                if (weakest == null || enemy.AttackPower < weakest.AttackPower)\n                {\n                    weakest = enemy;\n                }\n            }\n            return weakest;\n        }\n\n        // More code related to game state management...\n#TODO: You Code Here\n        public int CountEnemiesOfType(EnemyType type)\n        {\n            int count = 0;\n            foreach (var enemy in _enemies)\n            {\n                if (enemy.Type == type)\n                {\n                    count++;\n                }\n            }\n            return count;\n        }\n\n        // More code related to game state management...\n#TODO: You Code Here\n        public void TestGameState()\n        {\n            var gameState = new GameState();\n            var goblin = new Enemy(EnemyType.Goblin, 30,"}
{"id": "17", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class MessageHandler\n    {\n        private readonly Queue<string> _messageQueue;\n        private readonly object _lockObject;\n\n        public MessageHandler()\n        {\n            _messageQueue = new Queue<string>();\n            _lockObject = new object();\n        }\n\n        public void EnqueueMessage(string message)\n        {\n            lock (_lockObject)\n            {\n                _messageQueue.Enqueue(message);\n                Debug.Assert(_messageQueue.Count > 0, \"Message queue should have at least one message.\");\n            }\n        }\n\n        public string DequeueMessage()\n        {\n            lock (_lockObject)\n            {\n                if (_messageQueue.Count == 0)\n                {\n                    throw new InvalidOperationException(\"No messages to dequeue.\");\n                }\n                string message = _messageQueue.Dequeue();\n                Debug.Assert(message != null, \"Dequeued message should not be null.\");\n                return message;\n            }\n        }\n\n        public int GetQueueCount()\n        {\n            lock (_lockObject)\n            {\n                return _messageQueue.Count;\n            }\n        }\n\n        public void ClearQueue()\n        {\n            lock (_lockObject)\n            {\n                _messageQueue.Clear();\n                Debug.Assert(_messageQueue.Count == 0, \"Message queue should be empty after clearing.\");\n            }\n        }\n\n        // BEGIN PATTERN: Methods interacting with _messageQueue and _lockObject\n", "suffix": "    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            MessageHandler handler = new MessageHandler();\n\n            handler.EnqueueMessage(\"Test Message 1\");\n            handler.EnqueueMessage(\"Test Message 2\");\n\n            Debug.Assert(handler.GetQueueCount() == 2, \"Queue count should be 2 after enqueuing two messages.\");\n\n            string dequeuedMessage = handler.DequeueMessage();\n            Debug.Assert(dequeuedMessage == \"Test Message 1\", \"First dequeued message should be 'Test Message 1'.\");\n\n            handler.PeekMessage(); // Should not throw\n\n            handler.ClearQueue();\n            Debug.Assert(handler.GetQueueCount() == 0, \"Queue count should be 0 after clearing queue.\");\n        }\n    }\n}\n", "golden_completion": "        public void PeekMessage()\n        {\n            lock (_lockObject)\n            {\n                if (_messageQueue.Count == 0)\n                {\n                    throw new InvalidOperationException(\"No messages to peek.\");\n                }\n                string message = _messageQueue.Peek();\n                Debug.Assert(message != null, \"Peeked message should not be null.\");\n            }\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of thread-safe operations on a message queue. The pattern involves locking the _lockObject, performing operations on the _messageQueue, and using Debug.Assert statements to verify the operations' correctness. This is a realistic scenario in network protocols where thread-safety and message handling are critical. The golden completion follows the established pattern, and the suffix validates the pattern adherence with additional operations and assertions.", "assertions": "", "gpt-35-turbo-completions": "public string PeekMessage()\n        {\n            lock (_lockObject)\n            {\n                if (_messageQueue.Count == 0)\n                {\n                    throw new InvalidOperationException(\"No messages to peek.\");\n                }\n                string message = _messageQueue.Peek();\n                Debug.Assert(message != null, \"Peeked message should not be null.\");\n                return message;\n            }\n        }\n        // END PATTERN: Methods interacting with _messageQueue and _lockObject"}
{"id": "18", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class ApiClient\n    {\n        private readonly string baseUrl;\n\n        public ApiClient(string baseUrl)\n        {\n            this.baseUrl = baseUrl;\n        }\n\n        public string GetResource(string endpoint)\n        {\n            try\n            {\n                // Simulate API call\n                if (string.IsNullOrEmpty(endpoint))\n                {\n                    throw new ArgumentException(\"Endpoint cannot be null or empty.\");\n                }\n                // Mock response for the sake of example\n                return \"{ \\\"data\\\": \\\"example\\\" }\";\n            }\n            catch (ArgumentException ex)\n            {\n                Console.WriteLine($\"Argument error: {ex.Message}\");\n                throw;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"General error: {ex.Message}\");\n                throw;\n            }\n        }\n\n        public string PostResource(string endpoint, string payload)\n        {\n            try\n            {\n                // Simulate API call\n                if (string.IsNullOrEmpty(endpoint))\n                {\n                    throw new ArgumentException(\"Endpoint cannot be null or empty.\");\n                }\n                if (string.IsNullOrEmpty(payload))\n                {\n                    throw new ArgumentException(\"Payload cannot be null or empty.\");\n                }\n                // Mock response for the sake of example\n                return \"{ \\\"status\\\": \\\"success\\\" }\";\n            }\n            catch (ArgumentException ex)\n            {\n                Console.WriteLine($\"Argument error: {ex.Message}\");\n                throw;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"General error: {ex.Message}\");\n                throw;\n            }\n        }\n", "suffix": "        public void DeleteResource(string endpoint)\n        {\n            try\n            {\n                // Simulate API call\n                if (string.IsNullOrEmpty(endpoint))\n                {\n                    throw new ArgumentException(\"Endpoint cannot be null or empty.\");\n                }\n                // Mock success for the sake of example\n                Console.WriteLine(\"Resource deleted successfully.\");\n            }\n            catch (ArgumentException ex)\n            {\n                Console.WriteLine($\"Argument error: {ex.Message}\");\n                throw;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"General error: {ex.Message}\");\n                throw;\n            }\n        }\n    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            ApiClient client = new ApiClient(\"https://api.example.com\");\n            string getResourceResult = client.GetResource(\"/resource\");\n            Debug.Assert(getResourceResult.Contains(\"example\"), \"GetResource should return example data\");\n\n            string postResourceResult = client.PostResource(\"/resource\", \"{ \\\"key\\\": \\\"value\\\" }\");\n            Debug.Assert(postResourceResult.Contains(\"success\"), \"PostResource should return success status\");\n\n            client.DeleteResource(\"/resource\");\n            // No return value to assert, just ensure no exception is thrown\n        }\n    }\n}\n", "golden_completion": "        public string PutResource(string endpoint, string payload)\n        {\n            try\n            {\n                // Simulate API call\n                if (string.IsNullOrEmpty(endpoint))\n                {\n                    throw new ArgumentException(\"Endpoint cannot be null or empty.\");\n                }\n                if (string.IsNullOrEmpty(payload))\n                {\n                    throw new ArgumentException(\"Payload cannot be null or empty.\");\n                }\n                // Mock response for the sake of example\n                return \"{ \\\"status\\\": \\\"updated\\\" }\";\n            }\n            catch (ArgumentException ex)\n            {\n                Console.WriteLine($\"Argument error: {ex.Message}\");\n                throw;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"General error: {ex.Message}\");\n                throw;\n            }\n        }\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and complete a clear pattern in error handling within the context of network protocol operations, specifically API calls. The prefix establishes a consistent structure for handling errors in API methods (GetResource and PostResource), including specific exception types and general exceptions. The golden completion requires the LLM to extend this pattern to a new method (PutResource) with similar error handling. The suffix includes a different method (DeleteResource) to further demonstrate the pattern and includes assertions to verify functionality. This scenario is realistic, practical, and tests the LLM's ability to follow established error handling conventions in C#.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "19", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class ApiClient\n    {\n        private readonly string _baseUrl;\n\n        public ApiClient(string baseUrl)\n        {\n            _baseUrl = baseUrl;\n        }\n\n        public async Task<string> GetDataAsync(string endpoint)\n        {\n            try\n            {\n                using (var client = new HttpClient())\n                {\n                    client.BaseAddress = new Uri(_baseUrl);\n                    HttpResponseMessage response = await client.GetAsync(endpoint);\n                    response.EnsureSuccessStatusCode();\n                    string data = await response.Content.ReadAsStringAsync();\n                    return data;\n                }\n            }\n            catch (HttpRequestException e)\n            {\n                Debug.WriteLine($\"Request error: {e.Message}\");\n                throw;\n            }\n        }\n\n        public async Task<string> PostDataAsync(string endpoint, HttpContent content)\n        {\n            try\n            {\n                using (var client = new HttpClient())\n                {\n                    client.BaseAddress = new Uri(_baseUrl);\n                    HttpResponseMessage response = await client.PostAsync(endpoint, content);\n                    response.EnsureSuccessStatusCode();\n                    string data = await response.Content.ReadAsStringAsync();\n                    return data;\n                }\n            }\n            catch (HttpRequestException e)\n            {\n                Debug.WriteLine($\"Request error: {e.Message}\");\n                throw;\n            }\n        }\n    }\n\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var client = new ApiClient(\"https://api.example.com\");\n            string result;", "suffix": "            Debug.Assert(result != null, \"Result should not be null\");\n            Debug.Assert(result.Contains(\"expectedValue\"), \"Result should contain 'expectedValue'\");\n\n            var postContent = new StringContent(\"{\\\"key\\\":\\\"value\\\"}\", Encoding.UTF8, \"application/json\");\n            string postResult = await client.PostDataAsync(\"/data\", postContent);\n            Debug.Assert(postResult != null, \"Post result should not be null\");\n            Debug.Assert(postResult.Contains(\"success\"), \"Post result should contain 'success'\");\n        }\n    }\n}", "golden_completion": "            result = await client.GetDataAsync(\"/data\");", "LLM_justification": "This test case is a good example of pattern matching in the context of network protocols and error handling. The pattern established in the prefix demonstrates how to properly handle HTTP GET and POST requests using async/await, including error handling and resource management. The golden completion continues this pattern by implementing another method call that follows the same structure. The suffix includes assertions to verify the correctness of the pattern continuation and ensures that the overall implementation adheres to best practices. This setup tests the LLM's ability to recognize and extend established patterns in a realistic and practical scenario.", "assertions": "", "gpt-35-turbo-completions": "result = await client.GetDataAsync(\"/data\");"}
{"id": "20", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class NetworkHandler\n    {\n        private Dictionary<int, string> _messageTypes;\n\n        public NetworkHandler()\n        {\n            _messageTypes = new Dictionary<int, string>();\n            InitializeMessageTypes();\n        }\n\n        private void InitializeMessageTypes()\n        {\n            _messageTypes.Add(100, \"ConnectionRequest\");\n            _messageTypes.Add(101, \"ConnectionResponse\");\n            _messageTypes.Add(102, \"DataTransfer\");\n        }\n\n        public string HandleMessage(int messageType, string message)\n        {\n            switch (messageType)\n            {\n                case 100:\n                    return HandleConnectionRequest(message);\n                case 101:\n                    return HandleConnectionResponse(message);\n                case 102:\n                    return HandleDataTransfer(message);\n                default:\n                    throw new InvalidOperationException(\"Unknown message type\");\n            }\n        }\n\n        private string HandleConnectionRequest(string message)\n        {\n            // Simulate handling connection request\n            return \"ConnectionRequestHandled: \" + message;\n        }\n\n        private string HandleConnectionResponse(string message)\n        {\n            // Simulate handling connection response\n            return \"ConnectionResponseHandled: \" + message;\n        }\n\n        private string HandleDataTransfer(string message)\n        {\n            // Simulate handling data transfer\n            return \"DataTransferHandled: \" + message;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            NetworkHandler handler = new NetworkHandler();\n            string response;\n", "suffix": "            // Test with an unknown message type\n            try\n            {\n                response = handler.HandleMessage(999, \"TestMessage\");\n            }\n            catch (InvalidOperationException ex)\n            {\n                Debug.Assert(ex.Message == \"Unknown message type\", \"Expected exception message\");\n            }\n\n            // Test with a known message type\n            response = handler.HandleMessage(102, \"FileTransfer\");\n            Debug.Assert(response == \"DataTransferHandled: FileTransfer\", \"Expected handled message\");\n        }\n    }\n}\n", "golden_completion": "            // Test with another known message type\n            response = handler.HandleMessage(101, \"ConnectionAck\");\n            Debug.Assert(response == \"ConnectionResponseHandled: ConnectionAck\", \"Expected handled message\");\n", "LLM_justification": "This example demonstrates a clear pattern of handling different network message types based on their message codes. The prefix sets up a dictionary of message types and provides methods to handle each type. The golden completion follows this pattern by handling a known message type and verifying the response using assertions. The suffix continues this pattern by testing an unknown message type and another known message type, ensuring that the assertions verify correct behavior. This tests the LLM's ability to recognize and continue the established pattern of message handling in a network protocol context.", "assertions": "", "gpt-35-turbo-completions": "// Test with a known message type\n            response = handler.HandleMessage(100, \"ConnectRequest\");\n            Debug.Assert(response == \"ConnectionRequestHandled: ConnectRequest\", \"Expected handled message\");\n\n            // Test with a known message type\n            response = handler.HandleMessage(101, \"ConnectResponse\");\n            Debug.Assert(response == \"ConnectionResponseHandled: ConnectResponse\", \"Expected handled message\");"}
{"id": "21", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace AnalyticsExample\n{\n    public class DataProcessor\n    {\n        private readonly List<double> _data;\n        private readonly List<double> _smoothedData;\n\n        public DataProcessor(List<double> data)\n        {\n            _data = data;\n            _smoothedData = new List<double>();\n        }\n\n        public void ProcessData()\n        {\n            // Applying a simple moving average with a window size of 3\n            for (int i = 0; i < _data.Count; i++)\n            {\n                double average = 0;\n                int count = 0;\n\n                for (int j = Math.Max(0, i - 1); j <= Math.Min(_data.Count - 1, i + 1); j++)\n                {\n                    average += _data[j];\n                    count++;\n                }\n\n                average /= count;\n                _smoothedData.Add(average);\n            }\n        }\n\n        public List<double> GetSmoothedData()\n        {\n            return _smoothedData;\n        }\n\n        public double CalculateMean()\n        {\n            double sum = 0;\n            foreach (var value in _smoothedData)\n            {\n                sum += value;\n            }\n            return sum / _smoothedData.Count;\n        }\n\n        public double CalculateVariance()\n        {\n            double mean = CalculateMean();\n            double varianceSum = 0;\n            foreach (var value in _smoothedData)\n            {\n                varianceSum += Math.Pow(value - mean, 2);\n            }\n            return varianceSum / _smoothedData.Count;\n        }\n\n        public double CalculateStandardDeviation()\n        {\n            double variance = CalculateVariance();\n", "suffix": "        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> data = new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0 };\n            DataProcessor processor = new DataProcessor(data);\n            processor.ProcessData();\n            List<double> smoothedData = processor.GetSmoothedData();\n\n            Debug.Assert(smoothedData.Count == data.Count, \"Smoothed data should have the same count as original data.\");\n            Debug.Assert(smoothedData[0] == 1.5, \"Unexpected value in smoothed data.\");\n            Debug.Assert(smoothedData[1] == 2.0, \"Unexpected value in smoothed data.\");\n            Debug.Assert(smoothedData[2] == 3.0, \"Unexpected value in smoothed data.\");\n            Debug.Assert(smoothedData[3] == 4.0, \"Unexpected value in smoothed data.\");\n            Debug.Assert(smoothedData[4] == 4.5, \"Unexpected value in smoothed data.\");\n\n            double mean = processor.CalculateMean();\n            Debug.Assert(Math.Abs(mean - 3.0) < 1e-9, \"Mean calculation is incorrect.\");\n\n            double variance = processor.CalculateVariance();\n            Debug.Assert(Math.Abs(variance - 1.25) < 1e-9, \"Variance calculation is incorrect.\");\n\n            double stdDev = processor.CalculateStandardDeviation();\n            Debug.Assert(Math.Abs(stdDev - Math.Sqrt(1.25)) < 1e-9, \"Standard deviation calculation is incorrect.\");\n        }\n    }\n}\n", "golden_completion": "            return Math.Sqrt(variance);\n", "LLM_justification": "This test case evaluates the ability to recognize and continue a pattern of statistical calculations in an analytics context. The prefix establishes the pattern of calculating statistical measures (mean, variance), and the golden_completion requires the model to complete the pattern by calculating the standard deviation. The suffix provides assertions to verify the correctness of the calculations. This scenario is realistic and tests the LLM's understanding of algorithm implementation and analytics.", "assertions": "", "gpt-35-turbo-completions": "return Math.Sqrt(variance);"}
{"id": "22", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace SecurityExample\n{\n    public static class EncryptionHelper\n    {\n        public static string EncryptString(string plainText, string key)\n        {\n            byte[] iv = new byte[16];\n            byte[] array;\n\n            using (Aes aes = Aes.Create())\n            {\n                aes.Key = Encoding.UTF8.GetBytes(key);\n                aes.IV = iv;\n\n                ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);\n\n                using (System.IO.MemoryStream memoryStream = new System.IO.MemoryStream())\n                {\n                    using (CryptoStream cryptoStream = new CryptoStream((System.IO.Stream)memoryStream, encryptor, CryptoStreamMode.Write))\n                    {\n                        using (System.IO.StreamWriter streamWriter = new System.IO.StreamWriter((System.IO.Stream)cryptoStream))\n                        {\n                            streamWriter.Write(plainText);\n                        }\n\n                        array = memoryStream.ToArray();\n                    }\n                }\n            }\n\n            return Convert.ToBase64String(array);\n        }\n\n        public static string DecryptString(string cipherText, string key)\n        {\n            byte[] iv = new byte[16];\n            byte[] buffer = Convert.FromBase64String(cipherText);\n\n            using (Aes aes = Aes.Create())\n            {\n                aes.Key = Encoding.UTF8.GetBytes(key);\n                aes.IV = iv;\n\n                ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);\n\n                using (System.IO.MemoryStream memoryStream = new System.IO.MemoryStream(buffer))\n                {\n                    using (CryptoStream cryptoStream = new CryptoStream((System.IO.Stream)memoryStream, decryptor, CryptoStreamMode.Read))\n                    {\n                        using (System.IO.StreamReader streamReader = new System.IO.StreamReader((System.IO.Stream)cryptoStream))\n                        {\n                            return streamReader.ReadToEnd();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string key = \"A very complex key!\";\n            string original = \"Sensitive data that needs encryption.\";\n\n            string encrypted = EncryptionHelper.EncryptString(original, key);\n            Console.WriteLine($\"Encrypted: {encrypted}\");\n\n            string decrypted = EncryptionHelper.DecryptString(encrypted, key);\n            Console.WriteLine($\"Decrypted: {decrypted}\");\n\n            Debug.Assert(decrypted == original, \"Decryption did not return the original text.\");\n", "suffix": "            string anotherOriginal = \"Another piece of sensitive data.\";\n            string anotherEncrypted = EncryptionHelper.EncryptString(anotherOriginal, key);\n            Console.WriteLine($\"Another Encrypted: {anotherEncrypted}\");\n\n            string anotherDecrypted = EncryptionHelper.DecryptString(anotherEncrypted, key);\n            Console.WriteLine($\"Another Decrypted: {anotherDecrypted}\");\n\n            Debug.Assert(anotherDecrypted == anotherOriginal, \"Decryption did not return the original text.\");\n        }\n    }\n}\n", "golden_completion": "            Debug.Assert(encrypted != original, \"Encrypted text should not be the same as the original text.\");\n", "LLM_justification": "This test case is a good example of pattern matching in encryption and decryption functions, which are common in security-related programming. The pattern of creating and using an AES encryptor/decryptor, writing to and reading from a CryptoStream, and converting between byte arrays and strings is established clearly. The golden completion involves asserting that the encrypted text is different from the original, which is a logical and necessary assertion in encryption scenarios. The test case includes realistic encryption and decryption operations and appropriate assertions to validate the correctness of the operations.", "assertions": "", "gpt-35-turbo-completions": "// Add another piece of sensitive data and encrypt it with the same key\n            // Then decrypt it and check if the decrypted text is the same as the original text\n            // Use the Debug.Assert method to check if the decrypted text is the same as the original text\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            // You can use the same key as the first data\n            //"}
{"id": "23", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class ApiClient\n    {\n        public string BaseUrl { get; set; }\n\n        public ApiClient(string baseUrl)\n        {\n            BaseUrl = baseUrl;\n        }\n\n        public string Get(string endpoint)\n        {\n            try\n            {\n                // Simulate a network call\n                return $\"GET response from {BaseUrl}/{endpoint}\";\n            }\n            catch (Exception ex)\n            {\n                // Log the exception (simplified for this example)\n                Console.WriteLine($\"Error during GET: {ex.Message}\");\n                throw;\n            }\n        }\n\n        public string Post(string endpoint, string data)\n        {\n            try\n            {\n                // Simulate a network call\n                return $\"POST response from {BaseUrl}/{endpoint} with data {data}\";\n            }\n            catch (Exception ex)\n            {\n                // Log the exception (simplified for this example)\n                Console.WriteLine($\"Error during POST: {ex.Message}\");\n                throw;\n            }\n        }\n\n        // Implement a Put method following the established pattern\n", "suffix": "        public string Delete(string endpoint)\n        {\n            try\n            {\n                // Simulate a network call\n                return $\"DELETE response from {BaseUrl}/{endpoint}\";\n            }\n            catch (Exception ex)\n            {\n                // Log the exception (simplified for this example)\n                Console.WriteLine($\"Error during DELETE: {ex.Message}\");\n                throw;\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            ApiClient client = new ApiClient(\"http://example.com\");\n            string putResult = client.Put(\"resource\", \"data\");\n            Debug.Assert(putResult == \"PUT response from http://example.com/resource with data data\", \"PUT method failed\");\n\n            string deleteResult = client.Delete(\"resource\");\n            Debug.Assert(deleteResult == \"DELETE response from http://example.com/resource\", \"DELETE method failed\");\n        }\n    }\n}\n", "golden_completion": "        public string Put(string endpoint, string data)\n        {\n            try\n            {\n                // Simulate a network call\n                return $\"PUT response from {BaseUrl}/{endpoint} with data {data}\";\n            }\n            catch (Exception ex)\n            {\n                // Log the exception (simplified for this example)\n                Console.WriteLine($\"Error during PUT: {ex.Message}\");\n                throw;\n            }\n        }\n", "LLM_justification": "This test case establishes a pattern of network protocol methods (GET, POST) that handle errors in a specific way within a class. The golden completion requires implementing the PUT method following the same pattern. The suffix adds a DELETE method and assertions to verify the PUT and DELETE methods' behavior. This scenario tests the LLM's ability to recognize and continue the error handling pattern consistently.", "assertions": "", "gpt-35-turbo-completions": "// Implement a Delete method following the established pattern\n#TODO: You Code Here\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            ApiClient client = new ApiClient(\"http://example.com\");\n            string getResult = client.Get(\"resource\");\n            Debug.Assert(getResult == \"GET response from http://example.com/resource\", \"GET method failed\");\n\n            string postResult = client.Post(\"resource\", \"data\");\n            Debug.Assert(postResult == \"POST response from http://example.com/resource with data data\", \"POST method failed\");\n        }\n    }\n}\n\n// Solution\nusing System;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class ApiClient\n    {\n        public string BaseUrl { get; set; }\n\n        public ApiClient(string baseUrl)\n        {\n            BaseUrl = baseUrl;\n        }\n\n        public string Get(string endpoint)\n        {\n            try\n            {\n                // Simulate a network call\n                return $\"GET response from {BaseUrl}/{endpoint}\";\n            }\n            catch (Exception ex)\n            {\n                // Log the exception (simplified for this example)\n                Console.WriteLine($\"Error during GET: {ex.Message}\");\n                throw;\n            }\n        }\n\n        public string Post(string endpoint, string data)\n        {\n            try\n            {\n                // Simulate a network call\n                return $\"POST response from {BaseUrl}/{endpoint} with data {data}\";\n            }\n            catch (Exception ex)\n            {\n                // Log the exception (simplified for this example)\n                Console.WriteLine($\"Error during POST: {ex.Message}\");\n                throw;\n            }\n        }\n\n        public string Put(string endpoint, string data)\n        {\n            try\n            {\n                // Simulate a network call\n                return $\"PUT response from {BaseUrl}/{endpoint} with data {data}\";\n            }\n            catch (Exception ex)\n            {\n                // Log the exception (simplified for this example)\n                Console.WriteLine($\"Error during PUT: {ex.Message}\");\n                throw;\n            }\n        }"}
{"id": "24", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public enum AIState\n    {\n        Idle,\n        Patrol,\n        Chase,\n        Attack\n    }\n\n    public class EnemyAI\n    {\n        private AIState _currentState;\n        private Random _random;\n\n        public EnemyAI()\n        {\n            _currentState = AIState.Idle;\n            _random = new Random();\n        }\n\n        public void UpdateState()\n        {\n            switch (_currentState)\n            {\n                case AIState.Idle:\n                    if (_random.NextDouble() < 0.5)\n                    {\n                        _currentState = AIState.Patrol;\n                    }\n                    break;\n                case AIState.Patrol:\n                    if (_random.NextDouble() < 0.3)\n                    {\n                        _currentState = AIState.Chase;\n                    }\n                    break;\n                case AIState.Chase:\n                    if (_random.NextDouble() < 0.2)\n                    {\n                        _currentState = AIState.Attack;\n                    }\n                    break;\n                case AIState.Attack:\n                    if (_random.NextDouble() < 0.1)\n                    {\n                        _currentState = AIState.Idle;\n                    }\n                    break;\n                default:\n                    throw new ArgumentOutOfRangeException();\n            }\n        }\n\n        public AIState GetCurrentState()\n        {\n            return _currentState;\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        EnemyAI enemy = new EnemyAI();\n        enemy.UpdateState();\n        AIState state1 = enemy.GetCurrentState();\n        Debug.Assert(state1 != AIState.Idle, \"State should not be Idle after first update\");\n\n", "suffix": "        enemy.UpdateState();\n        AIState state3 = enemy.GetCurrentState();\n        Debug.Assert(state3 != state2, \"State should change again after update\");\n\n        enemy.UpdateState();\n        AIState state4 = enemy.GetCurrentState();\n        Debug.Assert(state4 != state3, \"State should change yet again after update\");\n    }\n}\n", "golden_completion": "        enemy.UpdateState();\n        AIState state2 = enemy.GetCurrentState();\n        Debug.Assert(state2 != state1, \"State should change after update\");\n", "LLM_justification": "This test case demonstrates a state machine pattern within the context of game mechanics. The `EnemyAI` class manages different AI states (Idle, Patrol, Chase, Attack) and transitions between these states based on random probabilities. The `UpdateState` method updates the state, and the pattern is to call `UpdateState` and then verify that the state has changed using assertions. This pattern is established in the prefix and the golden completion. The suffix continues this pattern and includes assertions to verify that the state changes after each update. This scenario tests the LLM's ability to recognize and complete the state transition pattern correctly.", "assertions": "", "gpt-35-turbo-completions": "enemy.UpdateState();\n        AIState state2 = enemy.GetCurrentState();\n        Debug.Assert(state2 != state1, \"State should change after update\");"}
{"id": "25", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class NetworkHandler\n    {\n        private Dictionary<string, string> _apiResponses;\n\n        public NetworkHandler()\n        {\n            _apiResponses = new Dictionary<string, string>();\n        }\n\n        public void AddApiResponse(string endpoint, string response)\n        {\n            if (string.IsNullOrEmpty(endpoint))\n            {\n                throw new ArgumentException(\"Endpoint cannot be null or empty\", nameof(endpoint));\n            }\n            if (response == null)\n            {\n                throw new ArgumentNullException(nameof(response), \"Response cannot be null\");\n            }\n            _apiResponses[endpoint] = response;\n        }\n\n        public string GetApiResponse(string endpoint)\n        {\n            if (string.IsNullOrEmpty(endpoint))\n            {\n                throw new ArgumentException(\"Endpoint cannot be null or empty\", nameof(endpoint));\n            }\n\n            if (_apiResponses.TryGetValue(endpoint, out var response))\n            {\n                return response;\n            }\n            else\n            {\n                throw new KeyNotFoundException(\"Endpoint not found\");\n            }\n        }\n\n        public void RemoveApiResponse(string endpoint)\n        {\n            if (string.IsNullOrEmpty(endpoint))\n            {\n                throw new ArgumentException(\"Endpoint cannot be null or empty\", nameof(endpoint));\n            }\n\n            if (!_apiResponses.Remove(endpoint))\n            {\n                throw new KeyNotFoundException(\"Endpoint not found\");\n            }\n        }\n\n        // Begin a new method following the same error handling pattern\n        public void UpdateApiResponse(string endpoint, string newResponse)\n        {\n            if (string.IsNullOrEmpty(endpoint))\n            {\n                throw new ArgumentException(\"Endpoint cannot be null or empty\", nameof(endpoint));\n            }\n            if (newResponse == null)\n            {\n                throw new ArgumentNullException(nameof(newResponse), \"Response cannot be null\");\n            }\n", "suffix": "            _apiResponses[endpoint] = newResponse;\n        }\n\n        public static void Main(string[] args)\n        {\n            NetworkHandler handler = new NetworkHandler();\n\n            handler.AddApiResponse(\"/test\", \"Test response\");\n            Debug.Assert(handler.GetApiResponse(\"/test\") == \"Test response\", \"AddApiResponse or GetApiResponse failed\");\n\n            handler.UpdateApiResponse(\"/test\", \"Updated response\");\n            Debug.Assert(handler.GetApiResponse(\"/test\") == \"Updated response\", \"UpdateApiResponse failed\");\n\n            handler.RemoveApiResponse(\"/test\");\n            try\n            {\n                handler.GetApiResponse(\"/test\");\n                Debug.Assert(false, \"Expected KeyNotFoundException was not thrown\");\n            }\n            catch (KeyNotFoundException)\n            {\n                Debug.Assert(true);\n            }\n        }\n    }\n}\n", "golden_completion": "            if (!_apiResponses.ContainsKey(endpoint))\n            {\n                throw new KeyNotFoundException(\"Endpoint not found\");\n            }\n", "LLM_justification": "This example provides a good test case for pattern matching in error handling within a network protocol context. The pattern of argument validation and exception handling is clearly established in the prefix. The golden completion requires the LLM to continue this pattern by adding similar validation and exception handling for the new UpdateApiResponse method. The suffix includes different code that follows after the completion, including assertions to verify the correctness of the implemented pattern. This scenario is realistic and tests the LLM's ability to recognize and adhere to established C# error handling conventions.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "26", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\npublic class EncryptionService\n{\n    private readonly Aes _aes;\n\n    public EncryptionService()\n    {\n        _aes = Aes.Create();\n        _aes.KeySize = 256;\n        _aes.BlockSize = 128;\n        _aes.Padding = PaddingMode.PKCS7;\n    }\n\n    public string Encrypt(string plainText, byte[] key, byte[] iv)\n    {\n        if (string.IsNullOrEmpty(plainText)) throw new ArgumentNullException(nameof(plainText));\n        if (key == null || key.Length == 0) throw new ArgumentNullException(nameof(key));\n        if (iv == null || iv.Length == 0) throw new ArgumentNullException(nameof(iv));\n\n        byte[] encrypted;\n        using (var encryptor = _aes.CreateEncryptor(key, iv))\n        {\n            using (var ms = new System.IO.MemoryStream())\n            {\n                using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))\n                {\n                    using (var sw = new System.IO.StreamWriter(cs))\n                    {\n                        sw.Write(plainText);\n                    }\n                    encrypted = ms.ToArray();\n                }\n            }\n        }\n        return Convert.ToBase64String(encrypted);\n    }\n\n    public string Decrypt(string cipherText, byte[] key, byte[] iv)\n    {\n        if (string.IsNullOrEmpty(cipherText)) throw new ArgumentNullException(nameof(cipherText));\n        if (key == null || key.Length == 0) throw new ArgumentNullException(nameof(key));\n        if (iv == null || iv.Length == 0) throw new ArgumentNullException(nameof(iv));\n\n        byte[] buffer = Convert.FromBase64String(cipherText);\n        using (var decryptor = _aes.CreateDecryptor(key, iv))\n        {\n            using (var ms = new System.IO.MemoryStream(buffer))\n            {\n                using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))\n                {\n                    using (var sr = new System.IO.StreamReader(cs))\n                    {\n                        return sr.ReadToEnd();\n                    }\n                }\n            }\n        }\n    }\n\n    public void Dispose()\n    {\n        if (_aes != null)\n        {\n            _aes.Dispose();\n        }\n    }\n\n    // Additional method to generate random key and IV\n    public static (byte[] key, byte[] iv) GenerateKeyAndIV()\n    {\n        using (var aes = Aes.Create())\n        {\n            aes.KeySize = 256;\n            aes.BlockSize = 128;\n            aes.GenerateKey();\n            aes.GenerateIV();\n            return (aes.Key, aes.IV);\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var service = new EncryptionService();\n        var (key, iv) = EncryptionService.GenerateKeyAndIV();\n        string plainText = \"Hello, World!\";\n", "suffix": "        string decryptedText = service.Decrypt(cipherText, key, iv);\n        Debug.Assert(decryptedText == plainText, \"Decrypted text does not match the original\");\n\n        service.Dispose();\n    }\n}\n", "golden_completion": "        string cipherText = service.Encrypt(plainText, key, iv);\n", "LLM_justification": "This example is a good test case for pattern matching because it establishes a clear pattern of encryption and decryption operations with proper error handling and resource management within the EncryptionService class. The prefix sets up the encryption service, including the key and IV generation, and shows part of the encryption process. The golden completion continues this pattern by completing the encryption operation. The suffix then verifies the integrity of the decrypted text against the original plain text using assertions, ensuring the pattern is followed correctly. This scenario tests the LLM's ability to recognize and continue the encryption-decryption pattern within a security context, making it a realistic and practical example.", "assertions": "", "gpt-35-turbo-completions": "string cipherText = service.Encrypt(plainText, key, iv);\n        Debug.Assert(cipherText != plainText, \"Cipher text is the same as the original\");"}
{"id": "27", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace SynthBench.PatternMatching\n{\n    public class NetworkMessageHandler\n    {\n        private readonly Queue<string> _messageQueue;\n        private readonly object _lockObject;\n\n        public NetworkMessageHandler()\n        {\n            _messageQueue = new Queue<string>();\n            _lockObject = new object();\n        }\n\n        // Method to enqueue a message safely\n        public void EnqueueMessage(string message)\n        {\n            lock (_lockObject)\n            {\n                _messageQueue.Enqueue(message);\n                Debug.WriteLine(\"Message enqueued: \" + message);\n            }\n        }\n\n        // Method to dequeue a message safely\n        public string DequeueMessage()\n        {\n            lock (_lockObject)\n            {\n                if (_messageQueue.Count > 0)\n                {\n                    string message = _messageQueue.Dequeue();\n                    Debug.WriteLine(\"Message dequeued: \" + message);\n                    return message;\n                }\n                else\n                {\n                    Debug.WriteLine(\"No message to dequeue.\");\n                    return null;\n                }\n            }\n        }\n\n        // Method to peek at the next message safely\n        public string PeekMessage()\n        {\n            lock (_lockObject)\n            {\n                if (_messageQueue.Count > 0)\n                {\n                    string message = _messageQueue.Peek();\n                    Debug.WriteLine(\"Message peeked: \" + message);\n                    return message;\n                }\n                else\n                {\n                    Debug.WriteLine(\"No message to peek.\");\n                    return null;\n                }\n            }\n        }\n\n        // Method to check if there are any messages in the queue\n        public bool HasMessages()\n        {\n            lock (_lockObject)\n            {\n                return _messageQueue.Count > 0;\n            }\n        }\n\n        // Method to clear all messages safely\n        public void ClearMessages()\n        {\n            lock (_lockObject)\n            {\n                _messageQueue.Clear();\n                Debug.WriteLine(\"All messages cleared.\");\n            }\n        }\n", "suffix": "    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            NetworkMessageHandler handler = new NetworkMessageHandler();\n            handler.EnqueueMessage(\"First Message\");\n            handler.EnqueueMessage(\"Second Message\");\n\n            Debug.Assert(handler.GetMessageCount() == 2, \"Message count should be 2\");\n            Debug.Assert(handler.HasMessages(), \"There should be messages in the queue\");\n\n            string dequeuedMessage = handler.DequeueMessage();\n            Debug.Assert(dequeuedMessage == \"First Message\", \"Dequeued message should be 'First Message'\");\n\n            string peekedMessage = handler.PeekMessage();\n            Debug.Assert(peekedMessage == \"Second Message\", \"Peeked message should be 'Second Message'\");\n\n            handler.ClearMessages();\n            Debug.Assert(handler.GetMessageCount() == 0, \"Message count should be 0 after clearing\");\n            Debug.Assert(!handler.HasMessages(), \"There should be no messages in the queue after clearing\");\n        }\n    }\n}\n", "golden_completion": "        // Method to get the count of messages safely\n        public int GetMessageCount()\n        {\n            lock (_lockObject)\n            {\n                return _messageQueue.Count;\n            }\n        }\n", "LLM_justification": "This test case is a good example of testing pattern matching capabilities because it involves a clear and repetitive pattern of thread-safe operations on a message queue within a network message handler class. The pattern is established through multiple synchronized methods (using lock statements) that perform common queue operations like enqueue, dequeue, peek, and clear. The golden completion requires the LLM to recognize this pattern and correctly continue it by adding a new method that adheres to the established thread-safe pattern. The suffix includes assertions that test the functionality and ensure the pattern is followed correctly.", "assertions": "", "gpt-35-turbo-completions": "// Method to get the number of messages in the queue\n        public int GetMessageCount()\n        {\n            lock (_lockObject)\n            {\n                return _messageQueue.Count;\n            }\n        }"}
{"id": "28", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\n\npublic class DataEncryptor\n{\n    private readonly Aes aes;\n\n    public DataEncryptor()\n    {\n        aes = Aes.Create();\n        aes.KeySize = 256;\n        aes.BlockSize = 128;\n        aes.Mode = CipherMode.CBC;\n        aes.Padding = PaddingMode.PKCS7;\n    }\n\n    public byte[] EncryptData(string plainText)\n    {\n        if (string.IsNullOrEmpty(plainText))\n            throw new ArgumentNullException(nameof(plainText));\n\n        ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);\n\n        using (var ms = new System.IO.MemoryStream())\n        using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))\n        using (var sw = new System.IO.StreamWriter(cs))\n        {\n            sw.Write(plainText);\n            sw.Close();\n            return ms.ToArray();\n        }\n    }\n\n    public string DecryptData(byte[] cipherText)\n    {\n        if (cipherText == null || cipherText.Length == 0)\n            throw new ArgumentNullException(nameof(cipherText));\n\n        ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);\n\n        using (var ms = new System.IO.MemoryStream(cipherText))\n        using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))\n        using (var sr = new System.IO.StreamReader(cs))\n        {\n            return sr.ReadToEnd();\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        DataEncryptor encryptor = new DataEncryptor();\n        string original = \"Hello World!\";\n        byte[] encrypted = encryptor.EncryptData(original);\n        string decrypted = encryptor.DecryptData(encrypted);\n", "suffix": "        string original2 = \"Another Test String\";\n        byte[] encrypted2 = encryptor.EncryptData(original2);\n        string decrypted2 = encryptor.DecryptData(encrypted2);\n        Debug.Assert(decrypted2 == original2, \"Decryption failed for original2\");\n    }\n}\n", "golden_completion": "        Debug.Assert(decrypted == original, \"Decryption failed\");\n", "LLM_justification": "This example tests the LLM's ability to recognize the pattern of encryption and decryption using the Aes class in C#. The established pattern includes creating an encryptor or decryptor, using MemoryStream and CryptoStream for processing, and asserting the correctness of the decrypted data. The golden completion follows this pattern by asserting the correctness of the decryption. The suffix continues the pattern with a different string to validate the robustness of the implementation.", "assertions": "", "gpt-35-turbo-completions": "Debug.Assert(decrypted == original, \"Decryption failed for original\");"}
{"id": "29", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace SecurityExample\n{\n    public class EncryptionHelper\n    {\n        private readonly Aes _aes;\n\n        public EncryptionHelper()\n        {\n            _aes = Aes.Create();\n            _aes.Key = Encoding.UTF8.GetBytes(\"12345678901234567890123456789012\"); // 32 bytes for AES-256\n            _aes.IV = Encoding.UTF8.GetBytes(\"1234567890123456\"); // 16 bytes for AES\n        }\n\n        public string Encrypt(string plainText)\n        {\n            if (string.IsNullOrEmpty(plainText))\n                throw new ArgumentException(\"Plaintext cannot be null or empty.\", nameof(plainText));\n\n            using (var encryptor = _aes.CreateEncryptor(_aes.Key, _aes.IV))\n            {\n                byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);\n                byte[] encryptedBytes = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);\n                return Convert.ToBase64String(encryptedBytes);\n            }\n        }\n\n        public string Decrypt(string encryptedText)\n        {\n            if (string.IsNullOrEmpty(encryptedText))\n                throw new ArgumentException(\"Encrypted text cannot be null or empty.\", nameof(encryptedText));\n\n            using (var decryptor = _aes.CreateDecryptor(_aes.Key, _aes.IV))\n            {\n                byte[] encryptedBytes = Convert.FromBase64String(encryptedText);\n                byte[] decryptedBytes = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);\n                return Encoding.UTF8.GetString(decryptedBytes);\n            }\n        }\n\n        public void Dispose()\n        {\n            _aes?.Dispose();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var encryptionHelper = new EncryptionHelper();\n            string plainText = \"Hello, World!\";\n            string encryptedText = encryptionHelper.Encrypt(plainText);\n            Console.WriteLine($\"Encrypted: {encryptedText}\");\n", "suffix": "\n\n            Debug.Assert(decryptedText == plainText, \"Decrypted text should match the original plain text.\");\n\n            encryptionHelper.Dispose();\n        }\n    }\n}\n", "golden_completion": "            string decryptedText = encryptionHelper.Decrypt(encryptedText);\n            Console.WriteLine($\"Decrypted: {decryptedText}\");\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern in error handling and encryption within a security context. The prefix establishes a pattern of AES encryption and decryption with proper error handling. The golden completion is a continuation of this pattern, demonstrating decryption and output of the decrypted text. The suffix includes assertions to verify the correctness of the decryption process and ensures proper resource cleanup. This is a good test case as it involves realistic, practical scenarios that developers encounter when handling encryption and decryption tasks.", "assertions": "", "gpt-35-turbo-completions": "string decryptedText = encryptionHelper.Decrypt(encryptedText);\n            Console.WriteLine($\"Decrypted: {decryptedText}\");"}
{"id": "30", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace NetworkProtocolExample\n{\n    public class ApiClient\n    {\n        private readonly string _baseUrl;\n\n        public ApiClient(string baseUrl)\n        {\n            _baseUrl = baseUrl;\n        }\n\n        public async Task<string> GetAsync(string endpoint)\n        {\n            try\n            {\n                using (var client = new HttpClient())\n                {\n                    client.BaseAddress = new Uri(_baseUrl);\n                    var response = await client.GetAsync(endpoint);\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsStringAsync();\n                }\n            }\n            catch (HttpRequestException e)\n            {\n                // Log and handle the exception\n                Console.WriteLine($\"Request error: {e.Message}\");\n                return null;\n            }\n        }\n\n        public async Task<string> PostAsync(string endpoint, HttpContent content)\n        {\n            try\n            {\n                using (var client = new HttpClient())\n                {\n                    client.BaseAddress = new Uri(_baseUrl);\n                    var response = await client.PostAsync(endpoint, content);\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsStringAsync();\n                }\n            }\n            catch (HttpRequestException e)\n            {\n                // Log and handle the exception\n                Console.WriteLine($\"Request error: {e.Message}\");\n                return null;\n            }\n        }\n\n        public async Task<string> PutAsync(string endpoint, HttpContent content)\n        {", "suffix": "\n        }\n\n        public async Task<string> DeleteAsync(string endpoint)\n        {\n            try\n            {\n                using (var client = new HttpClient())\n                {\n                    client.BaseAddress = new Uri(_baseUrl);\n                    var response = await client.DeleteAsync(endpoint);\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsStringAsync();\n                }\n            }\n            catch (HttpRequestException e)\n            {\n                // Log and handle the exception\n                Console.WriteLine($\"Request error: {e.Message}\");\n                return null;\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            var apiClient = new ApiClient(\"https://api.example.com\");\n\n            var getTask = apiClient.GetAsync(\"/get-endpoint\");\n            getTask.Wait();\n            Debug.Assert(getTask.Result != null, \"GET request failed\");\n\n            var postTask = apiClient.PostAsync(\"/post-endpoint\", new StringContent(\"{\\\"key\\\":\\\"value\\\"}\", System.Text.Encoding.UTF8, \"application/json\"));\n            postTask.Wait();\n            Debug.Assert(postTask.Result != null, \"POST request failed\");\n\n            var putTask = apiClient.PutAsync(\"/put-endpoint\", new StringContent(\"{\\\"key\\\":\\\"value\\\"}\", System.Text.Encoding.UTF8, \"application/json\"));\n            putTask.Wait();\n            Debug.Assert(putTask.Result != null, \"PUT request failed\");\n\n            var deleteTask = apiClient.DeleteAsync(\"/delete-endpoint\");\n            deleteTask.Wait();\n            Debug.Assert(deleteTask.Result != null, \"DELETE request failed\");\n        }\n    }\n}\n", "golden_completion": "            try\n            {\n                using (var client = new HttpClient())\n                {\n                    client.BaseAddress = new Uri(_baseUrl);\n                    var response = await client.PutAsync(endpoint, content);\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsStringAsync();\n                }\n            }\n            catch (HttpRequestException e)\n            {\n                // Log and handle the exception\n                Console.WriteLine($\"Request error: {e.Message}\");\n                return null;\n            }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common pattern in network protocol implementations, specifically for handling different HTTP methods (GET, POST, PUT, DELETE) with proper error handling. The prefix establishes a clear pattern for asynchronous HTTP operations with error handling, and the golden completion continues this pattern by implementing the PUT method. The suffix includes assertions to verify that each method works correctly and ensures that resources are properly managed.", "assertions": "", "gpt-35-turbo-completions": "try\n            {\n                using (var client = new HttpClient())\n                {\n                    client.BaseAddress = new Uri(_baseUrl);\n                    var response = await client.PutAsync(endpoint, content);\n                    response.EnsureSuccessStatusCode();\n                    return await response.Content.ReadAsStringAsync();\n                }\n            }\n            catch (HttpRequestException e)\n            {\n                // Log and handle the exception\n                Console.WriteLine($\"Request error: {e.Message}\");\n                return null;\n            }"}
{"id": "31", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace ToolAutomation\n{\n    public class DeploymentManager\n    {\n        private Dictionary<string, string> _services;\n\n        public DeploymentManager()\n        {\n            _services = new Dictionary<string, string>();\n        }\n\n        public void AddService(string name, string version)\n        {\n            if (string.IsNullOrEmpty(name))\n            {\n                throw new ArgumentException(\"Service name cannot be null or empty\");\n            }\n            if (string.IsNullOrEmpty(version))\n            {\n                throw new ArgumentException(\"Service version cannot be null or empty\");\n            }\n            _services[name] = version;\n        }\n\n        public void RemoveService(string name)\n        {\n            if (string.IsNullOrEmpty(name))\n            {\n                throw new ArgumentException(\"Service name cannot be null or empty\");\n            }\n            if (!_services.ContainsKey(name))\n            {\n                throw new KeyNotFoundException(\"Service not found\");\n            }\n            _services.Remove(name);\n        }\n\n        public string GetServiceVersion(string name)\n        {\n            if (string.IsNullOrEmpty(name))\n            {\n                throw new ArgumentException(\"Service name cannot be null or empty\");\n            }\n            if (!_services.ContainsKey(name))\n            {\n                throw new KeyNotFoundException(\"Service not found\");\n            }\n            return _services[name];\n        }\n\n        public List<string> ListServices()\n        {\n            return new List<string>(_services.Keys);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DeploymentManager manager = new DeploymentManager();\n            manager.AddService(\"ServiceA\", \"1.0\");\n            manager.AddService(\"ServiceB\", \"1.1\");\n            manager.AddService(\"ServiceC\", \"2.0\");\n\n            try\n            {\n                string versionA = manager.GetServiceVersion(\"ServiceA\");\n                Debug.Assert(versionA == \"1.0\", \"ServiceA version should be 1.0\");\n", "suffix": "                string versionB = manager.GetServiceVersion(\"ServiceB\");\n                Debug.Assert(versionB == \"1.1\", \"ServiceB version should be 1.1\");\n\n                List<string> services = manager.ListServices();\n                Debug.Assert(services.Count == 3, \"There should be 3 services listed\");\n                Debug.Assert(services.Contains(\"ServiceA\"), \"ServiceA should be listed\");\n                Debug.Assert(services.Contains(\"ServiceB\"), \"ServiceB should be listed\");\n                Debug.Assert(services.Contains(\"ServiceC\"), \"ServiceC should be listed\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n\n            try\n            {\n                manager.RemoveService(\"ServiceA\");\n                List<string> servicesAfterRemoval = manager.ListServices();\n                Debug.Assert(servicesAfterRemoval.Count == 2, \"There should be 2 services listed after removal\");\n                Debug.Assert(!servicesAfterRemoval.Contains(\"ServiceA\"), \"ServiceA should not be listed after removal\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n    }\n}\n", "golden_completion": "                string versionC = manager.GetServiceVersion(\"ServiceC\");\n                Debug.Assert(versionC == \"2.0\", \"ServiceC version should be 2.0\");\n", "LLM_justification": "This test case demonstrates a common pattern in tool automation involving error handling and service management. The prefix establishes a pattern of adding services with checks, and retrieving service versions with error handling. The golden completion continues this pattern by retrieving and asserting the version of a specific service. The suffix then tests additional functionality by listing services and removing a service, ensuring the pattern of error handling and validation is consistently applied. The combined code ensures proper error handling, resource management, and assertion placement, making it a robust test case for an LLM's pattern matching capabilities.", "assertions": "", "gpt-35-turbo-completions": "string versionB = manager.GetServiceVersion(\"ServiceB\");\n                Debug.Assert(versionB == \"1.1\", \"ServiceB version should be 1.1\");\n\n                List<string> services = manager.ListServices();\n                Debug.Assert(services.Count == 3, \"There should be 3 services listed\");\n                Debug.Assert(services.Contains(\"ServiceA\"), \"ServiceA should be listed\");\n                Debug.Assert(services.Contains(\"ServiceB\"), \"ServiceB should be listed\");\n                Debug.Assert(services.Contains(\"ServiceC\"), \"ServiceC should be listed\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n\n            try\n            {\n                manager.RemoveService(\"ServiceA\");\n                List<string> servicesAfterRemoval = manager.ListServices();\n                Debug.Assert(servicesAfterRemoval.Count == 2, \"There should be 2 services listed after removal\");\n                Debug.Assert(!servicesAfterRemoval.Contains(\"ServiceA\"), \"ServiceA should not be listed after removal\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n    }\n}\nusing System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace ToolAutomation\n{\n    public class DeploymentManager\n    {\n        private Dictionary<string, string> _services;\n\n        public DeploymentManager()\n        {\n            _services = new Dictionary<string, string>();\n        }\n\n        public void AddService(string name, string version)\n        {\n            if (string.IsNullOrEmpty(name))\n            {\n                throw new ArgumentException(\"Service name cannot be null or empty\");\n            }\n            if (string.IsNullOrEmpty(version))\n            {\n                throw new ArgumentException(\"Service version cannot be null or empty\");\n            }\n            _services[name] = version;\n        }\n\n        public void RemoveService(string name)\n        {\n            if (string.IsNullOrEmpty(name))\n            {\n                throw new ArgumentException(\"Service name cannot be null or empty\");\n            }\n            if (!_services.ContainsKey(name))\n            {\n                throw new KeyNotFoundException(\"Service not found\");\n            }\n            _services.Remove(name);\n        }\n\n        public string GetServiceVersion(string name)\n        {\n            if (string.IsNullOrEmpty(name))\n            {\n                throw new ArgumentException(\"Service name cannot be null or empty\");\n            }\n            if (!_services.ContainsKey(name))\n            {\n                throw new KeyNotFoundException(\"Service not found\");\n            }\n            return _services[name];\n        }\n\n        public List<string> ListServices()\n        {\n            return new List<string>(_services.Keys);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DeploymentManager manager = new DeploymentManager();\n            manager.AddService(\"ServiceA\", \"1.0\");\n            manager.AddService(\"ServiceB\", \"1.1\");\n            manager.AddService(\"ServiceC\", \"2.0\");\n\n            try\n            {\n                string versionA = manager.GetServiceVersion(\"ServiceA\");\n                Debug.Assert(versionA == \"1.0\", \"ServiceA version should be 1.0\");\n#TODO: You Code Here\n                string versionB = manager.GetServiceVersion(\"ServiceB\");\n                Debug.Assert(versionB == \"1.1\", \"ServiceB version should be 1.1\");\n\n                List<string> services = manager.ListServices();\n                Debug.Assert(services.Count == 3, \"There should be 3 services listed\");\n                Debug.Assert(services.Contains(\"ServiceA\"), \"ServiceA should be listed\");\n                Debug.Assert(services.Contains(\"ServiceB\"), \"ServiceB should be listed\");\n                Debug.Assert(services.Contains(\"ServiceC\"), \"ServiceC should be listed\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n\n            try\n            {\n                manager.RemoveService(\"ServiceA\");\n                List<string> servicesAfterRemoval = manager.ListServices();\n                Debug.Assert(servicesAfterRemoval.Count == 2, \"There should be 2 services listed after removal\");\n                Debug.Assert(!"}
{"id": "32", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace PatternMatchingExample\n{\n    public class NetworkProtocolHandler\n    {\n        private Dictionary<string, string> dataStore;\n\n        public NetworkProtocolHandler()\n        {\n            dataStore = new Dictionary<string, string>();\n        }\n\n        public bool StoreData(string key, string value)\n        {\n            if (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(value))\n            {\n                return false;\n            }\n            try\n            {\n                dataStore.Add(key, value);\n                return true;\n            }\n            catch (ArgumentException ex)\n            {\n                Debug.WriteLine($\"Error storing data: {ex.Message}\");\n                return false;\n            }\n        }\n\n        public string RetrieveData(string key)\n        {\n            if (string.IsNullOrEmpty(key))\n            {\n                return null;\n            }\n            try\n            {\n                return dataStore[key];\n            }\n            catch (KeyNotFoundException ex)\n            {\n                Debug.WriteLine($\"Error retrieving data: {ex.Message}\");\n                return null;\n            }\n        }\n\n        public bool DeleteData(string key)\n        {\n            if (string.IsNullOrEmpty(key))\n            {\n                return false;\n            }\n            try\n            {\n                return dataStore.Remove(key);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine($\"Error deleting data: {ex.Message}\");\n                return false;\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            NetworkProtocolHandler handler = new NetworkProtocolHandler();\n\n            // Test storing data\n            bool storeSuccess = handler.StoreData(\"key1\", \"value1\");\n", "suffix": "            Debug.Assert(storeSuccess, \"StoreData should return true for valid key and value\");\n\n            // Test retrieving data\n            string value = handler.RetrieveData(\"key1\");\n            Debug.Assert(value == \"value1\", \"RetrieveData should return the correct value for a given key\");\n\n            // Test deleting data\n            bool deleteSuccess = handler.DeleteData(\"key1\");\n            Debug.Assert(deleteSuccess, \"DeleteData should return true for a valid key\");\n\n            // Test retrieving deleted data\n            value = handler.RetrieveData(\"key1\");\n            Debug.Assert(value == null, \"RetrieveData should return null for a deleted key\");\n\n            // Test error handling for non-existent key\n            value = handler.RetrieveData(\"nonexistent\");\n            Debug.Assert(value == null, \"RetrieveData should return null for a non-existent key\");\n        }\n    }\n}\n", "golden_completion": "            Debug.Assert(storeSuccess, \"StoreData should return true for valid key and value\");\n\n            // Test retrieving data\n            string value = handler.RetrieveData(\"key1\");\n            Debug.Assert(value == \"value1\", \"RetrieveData should return the correct value for a given key\");\n\n            // Test deleting data\n            bool deleteSuccess = handler.DeleteData(\"key1\");\n            Debug.Assert(deleteSuccess, \"DeleteData should return true for a valid key\");\n\n            // Test retrieving deleted data\n            value = handler.RetrieveData(\"key1\");\n            Debug.Assert(value == null, \"RetrieveData should return null for a deleted key\");\n\n            // Test error handling for non-existent key\n            value = handler.RetrieveData(\"nonexistent\");\n            Debug.Assert(value == null, \"RetrieveData should return null for a non-existent key\");\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern in error handling within a network protocol handler context. The prefix establishes clear patterns for error checking and exception handling in methods for storing, retrieving, and deleting data. The golden completion and suffix verify the LLM's capability to complete these patterns accurately, ensuring the correct handling of both valid and invalid inputs, as well as proper exception management.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "33", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanicsExample\n{\n    public class StateMachine\n    {\n        private enum State\n        {\n            Idle,\n            Moving,\n            Attacking,\n            Defending\n        }\n\n        private State currentState;\n\n        public StateMachine()\n        {\n            currentState = State.Idle;\n        }\n\n        public void ChangeState(State newState)\n        {\n            switch (newState)\n            {\n                case State.Idle:\n                    EnterIdleState();\n                    break;\n                case State.Moving:\n                    EnterMovingState();\n                    break;\n                case State.Attacking:\n                    EnterAttackingState();\n                    break;\n                case State.Defending:\n                    EnterDefendingState();\n                    break;\n                default:\n                    throw new ArgumentOutOfRangeException(nameof(newState), newState, null);\n            }\n            currentState = newState;\n        }\n\n        private void EnterIdleState()\n        {\n            Console.WriteLine(\"Entering Idle State\");\n        }\n\n        private void EnterMovingState()\n        {\n            Console.WriteLine(\"Entering Moving State\");\n        }\n\n        private void EnterAttackingState()\n        {\n            Console.WriteLine(\"Entering Attacking State\");\n        }\n\n        private void EnterDefendingState()\n        {\n            Console.WriteLine(\"Entering Defending State\");\n        }\n\n        public void Update()\n        {\n            switch (currentState)\n            {\n                case State.Idle:\n                    UpdateIdleState();\n                    break;\n                case State.Moving:\n                    UpdateMovingState();\n                    break;\n                case State.Attacking:\n                    UpdateAttackingState();\n                    break;\n                case State.Defending:\n                    UpdateDefendingState();\n                    break;\n            }\n        }\n\n        private void UpdateIdleState()\n        {\n            Console.WriteLine(\"Updating Idle State\");\n        }\n\n        private void UpdateMovingState()\n        {\n            Console.WriteLine(\"Updating Moving State\");\n        }\n", "suffix": "        private void UpdateDefendingState()\n        {\n            Console.WriteLine(\"Updating Defending State\");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StateMachine stateMachine = new StateMachine();\n            stateMachine.ChangeState(StateMachine.State.Idle);\n            Debug.Assert(stateMachine != null, \"StateMachine instance is null\");\n\n            stateMachine.ChangeState(StateMachine.State.Moving);\n            Debug.Assert(stateMachine != null, \"StateMachine instance is null\");\n\n            stateMachine.ChangeState(StateMachine.State.Attacking);\n            Debug.Assert(stateMachine != null, \"StateMachine instance is null\");\n\n            stateMachine.ChangeState(StateMachine.State.Defending);\n            Debug.Assert(stateMachine != null, \"StateMachine instance is null\");\n\n            stateMachine.Update();\n        }\n    }\n}\n", "golden_completion": "        private void UpdateAttackingState()\n        {\n            Console.WriteLine(\"Updating Attacking State\");\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern in a state machine implementation, which is common in game mechanics. The pattern involves defining methods for entering and updating various states. The golden completion continues this pattern by adding the 'UpdateAttackingState' method, which matches the structure and naming conventions of the other update methods. The suffix includes assertions to verify that the state machine transitions correctly and the state machine instance is not null.", "assertions": "", "gpt-35-turbo-completions": "private void UpdateAttackingState()\n        {\n            Console.WriteLine(\"Updating Attacking State\");\n        }"}
{"id": "34", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nnamespace NetworkProtocolExample {\n    public class AsyncApiHandler {\n        public async Task<string> SendRequestAsync(string url) {\n            try {\n                // Simulate sending a request\n                await Task.Delay(1000);\n                // Simulate a successful response\n                return \"Response from \" + url;\n            } catch (Exception ex) {\n                Debug.WriteLine($\"Error: {ex.Message}\");\n                throw;\n            }\n        }\n\n        public async Task<string> FetchDataAsync(string endpoint) {\n            try {\n                // Simulate fetching data\n                await Task.Delay(1000);\n                // Simulate a successful data retrieval\n                return \"Data from \" + endpoint;\n            } catch (Exception ex) {\n                Debug.WriteLine($\"Error: {ex.Message}\");\n                throw;\n            }\n        }\n\n        public async Task<string> PostDataAsync(string endpoint, string data) {\n            try {\n                // Simulate posting data\n                await Task.Delay(1000);\n                // Simulate a successful post\n                return \"Posted data to \" + endpoint;\n            } catch (Exception ex) {\n                Debug.WriteLine($\"Error: {ex.Message}\");\n                throw;\n            }\n        }\n\n        // Method to be completed\n        public async Task<string> DeleteDataAsync(string endpoint) {\n            try {\n                // Simulate deleting data\n                await Task.Delay(1000);\n", "suffix": "                Debug.Assert(false, \"This line should never be reached\");\n            } catch (Exception ex) {\n                Debug.WriteLine($\"Error: {ex.Message}\");\n                Debug.Assert(ex != null, \"Exception should not be null\");\n                throw;\n            }\n        }\n    }\n\n    public class Program {\n        public static async Task Main(string[] args) {\n            var apiHandler = new AsyncApiHandler();\n\n            var response = await apiHandler.SendRequestAsync(\"https://example.com\");\n            Debug.Assert(response == \"Response from https://example.com\", \"SendRequestAsync failed\");\n\n            var data = await apiHandler.FetchDataAsync(\"/data\");\n            Debug.Assert(data == \"Data from /data\", \"FetchDataAsync failed\");\n\n            var postData = await apiHandler.PostDataAsync(\"/post\", \"some data\");\n            Debug.Assert(postData == \"Posted data to /post\", \"PostDataAsync failed\");\n\n            var deleteResponse = await apiHandler.DeleteDataAsync(\"/delete\");\n            Debug.Assert(deleteResponse == \"Deleted data from /delete\", \"DeleteDataAsync failed\");\n        }\n    }\n}\n", "golden_completion": "                return \"Deleted data from \" + endpoint;\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of async API methods with proper error handling in a network protocol context. The pattern involves performing an async operation, handling exceptions, and returning a result string. The golden_completion requires the LLM to generate code that conforms to this established pattern, ensuring consistency and proper functionality.", "assertions": "", "gpt-35-turbo-completions": "// Simulate a successful delete\n                return \"Deleted data from \" + endpoint;\n            } catch (Exception ex) {\n                Debug.WriteLine($\"Error: {ex.Message}\");\n                throw;\n            }\n        }\n\n        public async Task<string> HandleRequestAsync(string url, string endpoint, string data) {\n            try {\n                var response = await SendRequestAsync(url);\n                var fetchedData = await FetchDataAsync(endpoint);\n                var postData = await PostDataAsync(endpoint, data);\n                var deleteResponse = await DeleteDataAsync(endpoint);\n                return response + fetchedData + postData + deleteResponse;\n            } catch (Exception ex) {\n                Debug.WriteLine($\"Error: {ex.Message}\");\n                throw;\n            }\n        }\n\n        public async Task HandleRequestWithExceptionAsync(string url, string endpoint, string data) {\n            try {\n                var response = await SendRequestAsync(url);\n                var fetchedData = await FetchDataAsync(endpoint);\n                var postData = await PostDataAsync(endpoint, data);\n                var deleteResponse = await DeleteDataAsync(endpoint);"}
{"id": "35", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public enum AIState\n    {\n        Idle,\n        Patrolling,\n        Chasing,\n        Attacking\n    }\n\n    public class AIController\n    {\n        private AIState currentState;\n        private int health;\n        private int detectionRange;\n\n        public AIController(int initialHealth, int detectionRange)\n        {\n            this.health = initialHealth;\n            this.detectionRange = detectionRange;\n            this.currentState = AIState.Idle;\n        }\n\n        public void UpdateState(int playerDistance, bool playerInSight)\n        {\n            switch (currentState)\n            {\n                case AIState.Idle:\n                    if (playerInSight && playerDistance <= detectionRange)\n                    {\n                        TransitionToState(AIState.Chasing);\n                    }\n                    break;\n                case AIState.Patrolling:\n                    if (playerInSight && playerDistance <= detectionRange)\n                    {\n                        TransitionToState(AIState.Chasing);\n                    }\n                    else if (!playerInSight)\n                    {\n                        TransitionToState(AIState.Idle);\n                    }\n                    break;\n", "suffix": "                case AIState.Attacking:\n                    if (playerDistance > detectionRange / 2)\n                    {\n                        TransitionToState(AIState.Chasing);\n                    }\n                    else if (!playerInSight)\n                    {\n                        TransitionToState(AIState.Patrolling);\n                    }\n                    break;\n                default:\n                    throw new InvalidOperationException(\"Unknown state\");\n            }\n        }\n\n        private void TransitionToState(AIState newState)\n        {\n            currentState = newState;\n            // Additional logic for transitioning state can be added here\n        }\n\n        public AIState GetCurrentState() => currentState;\n    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            AIController aiController = new AIController(initialHealth: 100, detectionRange: 50);\n            aiController.UpdateState(playerDistance: 30, playerInSight: true);\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chasing, \"AI should be in Chasing state\");\n\n            aiController.UpdateState(playerDistance: 20, playerInSight: true);\n            Debug.Assert(aiController.GetCurrentState() == AIState.Attacking, \"AI should be in Attacking state\");\n\n            aiController.UpdateState(playerDistance: 60, playerInSight: false);\n            Debug.Assert(aiController.GetCurrentState() == AIState.Patrolling, \"AI should be in Patrolling state\");\n\n            aiController.UpdateState(playerDistance: 30, playerInSight: false);\n            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, \"AI should be in Idle state\");\n        }\n    }\n}\n", "golden_completion": "                case AIState.Chasing:\n                    if (playerDistance > detectionRange || !playerInSight)\n                    {\n                        TransitionToState(AIState.Patrolling);\n                    }\n                    else if (playerDistance <= detectionRange / 2)\n                    {\n                        TransitionToState(AIState.Attacking);\n                    }\n                    break;\n", "LLM_justification": "This example tests the LLM's ability to recognize a state machine pattern and continue it correctly. The AI state transitions are clearly defined with similar logic blocks for different states. The golden completion follows the pattern established in the prefix by handling the Chasing state transitions. The suffix continues the pattern with the Attacking state and includes assertions to verify correct state transitions.", "assertions": "", "gpt-35-turbo-completions": "case AIState.Chasing:\n                    if (playerDistance <= detectionRange / 2)\n                    {\n                        TransitionToState(AIState.Attacking);\n                    }\n                    else if (!playerInSight)\n                    {\n                        TransitionToState(AIState.Patrolling);\n                    }\n                    break;"}
{"id": "36", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public class StateMachine<TState, TTrigger>\n    {\n        private readonly Dictionary<TState, Dictionary<TTrigger, TState>> _transitions;\n        private TState _currentState;\n\n        public StateMachine(TState initialState)\n        {\n            _currentState = initialState;\n            _transitions = new Dictionary<TState, Dictionary<TTrigger, TState>>();\n        }\n\n        public void AddTransition(TState fromState, TTrigger trigger, TState toState)\n        {\n            if (!_transitions.ContainsKey(fromState))\n            {\n                _transitions[fromState] = new Dictionary<TTrigger, TState>();\n            }\n            _transitions[fromState][trigger] = toState;\n        }\n\n        public void Fire(TTrigger trigger)\n        {\n            if (_transitions.ContainsKey(_currentState) && _transitions[_currentState].ContainsKey(trigger))\n            {\n                _currentState = _transitions[_currentState][trigger];\n            }\n            else\n            {\n                throw new InvalidOperationException(\"Invalid transition\");\n            }\n        }\n\n        public TState GetCurrentState()\n        {\n            return _currentState;\n        }\n    }\n\n    public static class Program\n    {\n        public static void Main()\n        {\n            var stateMachine = new StateMachine<string, string>(\"Idle\");\n            stateMachine.AddTransition(\"Idle\", \"Start\", \"Running\");\n            stateMachine.AddTransition(\"Running\", \"Stop\", \"Idle\");\n            stateMachine.AddTransition(\"Idle\", \"Pause\", \"Paused\");\n            stateMachine.AddTransition(\"Paused\", \"Resume\", \"Running\");\n", "suffix": "            stateMachine.Fire(\"Pause\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Paused\", \"State should be 'Paused'\");\n\n            stateMachine.Fire(\"Resume\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Running\", \"State should be 'Running'\");\n\n            stateMachine.Fire(\"Stop\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Idle\", \"State should be 'Idle'\");\n        }\n    }\n}\n", "golden_completion": "            stateMachine.Fire(\"Start\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Running\", \"State should be 'Running'\");\n", "LLM_justification": "This scenario tests the pattern matching capability of an LLM in the context of implementing a state machine for game mechanics. The prefix establishes a clear pattern of adding transitions and firing triggers to change states, with corresponding assertions to verify state changes. The golden completion requires the LLM to recognize the established pattern and correctly fire a transition from 'Idle' to 'Running' state. This is a practical scenario as state machines are commonly used in game development for handling different states of game characters or systems. Assertions in the suffix ensure the correct state transitions and validate the pattern adherence.", "assertions": "", "gpt-35-turbo-completions": "Debug.Assert(stateMachine.GetCurrentState() == \"Idle\", \"State should be 'Idle'\");\n\n            stateMachine.Fire(\"Start\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Running\", \"State should be 'Running'\");"}
{"id": "37", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public enum AIState\n    {\n        Idle,\n        Patrol,\n        Chase,\n        Attack\n    }\n\n    public class AIController\n    {\n        private AIState _currentState;\n        private Random _random;\n\n        public AIController()\n        {\n            _currentState = AIState.Idle;\n            _random = new Random();\n        }\n\n        public void UpdateState()\n        {\n            switch (_currentState)\n            {\n                case AIState.Idle:\n                    Debug.WriteLine(\"AI is idling.\");\n                    // Transition to Patrol\n                    _currentState = AIState.Patrol;\n                    break;\n                case AIState.Patrol:\n                    Debug.WriteLine(\"AI is patrolling.\");\n                    // Randomly transition to Chase\n                    if (_random.NextDouble() > 0.5)\n                    {\n                        _currentState = AIState.Chase;\n                    }\n                    break;\n                case AIState.Chase:\n                    Debug.WriteLine(\"AI is chasing.\");\n                    // Transition to Attack\n                    _currentState = AIState.Attack;\n                    break;\n                case AIState.Attack:\n                    Debug.WriteLine(\"AI is attacking.\");\n                    // Transition back to Idle\n                    _currentState = AIState.Idle;\n                    break;\n                default:\n                    throw new ArgumentOutOfRangeException();\n            }\n        }\n\n        public AIState GetCurrentState()\n        {\n            return _currentState;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            AIController aiController = new AIController();\n            aiController.UpdateState();\n", "suffix": "            Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Chase or stay in Patrol\");\n            aiController.UpdateState();\n        }\n    }\n}\n", "golden_completion": "            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Attack, \"State should transition to Attack\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, \"State should transition back to Idle\");\n", "LLM_justification": "This test case provides a clear pattern of state transitions in an AI state machine for game mechanics. The prefix establishes the pattern of state updates and transitions, while the golden completion continues this pattern by verifying the expected state transitions. The assertions in the suffix ensure that the state transitions are correct. This scenario tests the LLM's ability to recognize and continue the established pattern of state transitions.", "assertions": "", "gpt-35-turbo-completions": "Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Chase or stay in Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Attack, \"State should transition to Attack\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, \"State should transition to Idle\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Chase or stay in Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Attack, \"State should transition to Attack\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, \"State should transition to Idle\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Chase or stay in Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Attack, \"State should transition to Attack\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, \"State should transition to Idle\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Chase or stay in Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Attack, \"State should transition to Attack\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, \"State should transition to Idle\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Chase or stay in Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Attack, \"State should transition to Attack\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, \"State should transition to Idle\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Chase or stay in Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Attack, \"State should transition to Attack\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, \"State should transition to Idle\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, \"State should transition to Patrol\");\n            aiController.UpdateState();\n            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AI"}
{"id": "38", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace EncryptionExample\n{\n    public class AesEncryptionService\n    {\n        private readonly byte[] key;\n        private readonly byte[] iv;\n\n        public AesEncryptionService(byte[] key, byte[] iv)\n        {\n            this.key = key;\n            this.iv = iv;\n        }\n\n        public byte[] Encrypt(string plainText)\n        {\n            if (string.IsNullOrEmpty(plainText))\n                throw new ArgumentException(\"Plaintext cannot be null or empty.\");\n\n            using (var aes = System.Security.Cryptography.Aes.Create())\n            {\n                aes.Key = key;\n                aes.IV = iv;\n\n                var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);\n\n                using (var ms = new System.IO.MemoryStream())\n                {\n                    using (var cs = new System.Security.Cryptography.CryptoStream(ms, encryptor, System.Security.Cryptography.CryptoStreamMode.Write))\n                    {\n                        using (var sw = new System.IO.StreamWriter(cs))\n                        {\n                            sw.Write(plainText);\n                        }\n                        return ms.ToArray();\n                    }\n                }\n            }\n        }\n\n        public string Decrypt(byte[] cipherText)\n        {\n            if (cipherText == null || cipherText.Length == 0)\n                throw new ArgumentException(\"Ciphertext cannot be null or empty.\");\n\n            using (var aes = System.Security.Cryptography.Aes.Create())\n            {\n                aes.Key = key;\n                aes.IV = iv;\n\n                var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);\n\n                using (var ms = new System.IO.MemoryStream(cipherText))\n                {\n                    using (var cs = new System.Security.Cryptography.CryptoStream(ms, decryptor, System.Security.Cryptography.CryptoStreamMode.Read))\n                    {\n                        using (var sr = new System.IO.StreamReader(cs))\n                        {\n                            return sr.ReadToEnd();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            byte[] key = new byte[32]; // Example key (for demonstration purposes only)\n            byte[] iv = new byte[16];  // Example IV (for demonstration purposes only)\n            var encryptionService = new AesEncryptionService(key, iv);\n\n            string originalText = \"Hello, World!\";\n            byte[] encryptedText = encryptionService.Encrypt(originalText);\n            string decryptedText = encryptionService.Decrypt(encryptedText);\n\n            Debug.Assert(originalText == decryptedText, \"The decrypted text should match the original text.\");\n\n            // Additional encryption and decryption tests\n            string testText1 = \"Test 1\";\n            byte[] encryptedText1 = encryptionService.Encrypt(testText1);\n            string decryptedText1 = encryptionService.Decrypt(encryptedText1);\n            Debug.Assert(testText1 == decryptedText1, \"The decrypted text should match the original text.\");\n", "suffix": "            // Another test case for encryption and decryption\n            string testText2 = \"Another test\";\n            byte[] encryptedText2 = encryptionService.Encrypt(testText2);\n            string decryptedText2 = encryptionService.Decrypt(encryptedText2);\n            Debug.Assert(testText2 == decryptedText2, \"The decrypted text should match the original text.\");\n        }\n    }\n}\n", "golden_completion": "            string testText3 = \"Yet another test\";\n            byte[] encryptedText3 = encryptionService.Encrypt(testText3);\n            string decryptedText3 = encryptionService.Decrypt(encryptedText3);\n            Debug.Assert(testText3 == decryptedText3, \"The decrypted text should match the original text.\");\n", "LLM_justification": "This is a good test case because it demonstrates a common pattern in encryption and decryption services where the same key and IV are used to both encrypt and decrypt data. The pattern involves using the same encryption/decryption logic and verifying the results through assertions. The provided code checks the integrity of the encryption and decryption processes by ensuring that the decrypted text matches the original text. This pattern is clear, practical, and aligns with best practices in error handling and resource management in C#.", "assertions": "", "gpt-35-turbo-completions": "// Another test case for encryption and decryption\n            string testText2 = \"Another test\";\n            byte[] encryptedText2 = encryptionService.Encrypt(testText2);\n            string decryptedText2 = encryptionService.Decrypt(encryptedText2);\n            Debug.Assert(testText2 == decryptedText2, \"The decrypted text should match the original text.\");\n        }\n    }\n}\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace EncryptionExample\n{\n    public class AesEncryptionService\n    {\n        private readonly byte[] key;\n        private readonly byte[] iv;\n\n        public AesEncryptionService(byte[] key, byte[] iv)\n        {\n            this.key = key;\n            this.iv = iv;\n        }\n\n        public byte[] Encrypt(string plainText)\n        {\n            if (string.IsNullOrEmpty(plainText))\n                throw new ArgumentException(\"Plaintext cannot be null or empty.\");\n\n            using (var aes = System.Security.Cryptography.Aes.Create())\n            {\n                aes.Key = key;\n                aes.IV = iv;\n\n                var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);\n\n                using (var ms = new System.IO.MemoryStream())\n                {\n                    using (var cs = new System.Security.Cryptography.CryptoStream(ms, encryptor, System.Security.Cryptography.CryptoStreamMode.Write))\n                    {\n                        using (var sw = new System.IO.StreamWriter(cs))\n                        {\n                            sw.Write(plainText);\n                        }\n                        return ms.ToArray();\n                    }\n                }\n            }\n        }\n\n        public string Decrypt(byte[] cipherText)\n        {\n            if (cipherText == null || cipherText.Length == 0)\n                throw new ArgumentException(\"Ciphertext cannot be null or empty.\");\n\n            using (var aes = System.Security.Cryptography.Aes.Create())\n            {\n                aes.Key = key;\n                aes.IV = iv;\n\n                var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);\n\n                using (var ms = new System.IO.MemoryStream(cipherText))\n                {\n                    using (var cs = new System.Security.Cryptography.CryptoStream(ms, decryptor, System.Security.Cryptography.CryptoStreamMode.Read))\n                    {\n                        using (var sr = new System.IO.StreamReader(cs))\n                        {\n                            return sr.ReadToEnd();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            byte[] key = new byte[32]; // Example key (for demonstration purposes only)\n            byte[] iv = new byte[16];  // Example IV (for demonstration purposes only)\n            var encryptionService = new AesEncryptionService(key, iv);\n\n            string originalText = \"Hello, World!\";\n            byte[] encryptedText = encryptionService.Encrypt(originalText);\n            string decryptedText = encryptionService.Decrypt(encryptedText);\n\n            Debug.Assert(originalText == decryptedText, \"The decrypted text should match the original text.\");\n\n            // Additional encryption and decryption tests\n            string testText1 = \"Test 1\";\n            byte[] encryptedText1 = encryptionService.Encrypt(testText1);\n            string decryptedText1 = encryptionService.Decrypt(encryptedText1);\n            Debug.Assert(testText1 == decryptedText1, \"The decrypted text should match the original text.\");\n#TODO: You Code Here"}
{"id": "39", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GamePhysics\n{\n    public enum State\n    {\n        Idle,\n        Running,\n        Jumping\n    }\n\n    public interface IStateHandler\n    {\n        void EnterState(State state);\n        void ExitState(State state);\n    }\n\n    public class Character : IStateHandler\n    {\n        private State currentState;\n\n        public Character()\n        {\n            currentState = State.Idle;\n        }\n\n        public void EnterState(State state)\n        {\n            switch (state)\n            {\n                case State.Idle:\n                    Console.WriteLine(\"Entering Idle State\");\n                    break;\n                case State.Running:\n                    Console.WriteLine(\"Entering Running State\");\n                    break;\n                case State.Jumping:\n                    Console.WriteLine(\"Entering Jumping State\");\n                    break;\n                default:\n                    throw new ArgumentException(\"Invalid state\");\n            }\n            currentState = state;\n        }\n\n        public void ExitState(State state)\n        {\n            switch (state)\n            {\n                case State.Idle:\n                    Console.WriteLine(\"Exiting Idle State\");\n                    break;\n                case State.Running:\n                    Console.WriteLine(\"Exiting Running State\");\n                    break;\n                case State.Jumping:\n                    Console.WriteLine(\"Exiting Jumping State\");\n                    break;\n                default:\n                    throw new ArgumentException(\"Invalid state\");\n            }\n        }\n\n        public State GetCurrentState()\n        {\n            return currentState;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Character character = new Character();\n            character.EnterState(State.Running);\n            Debug.Assert(character.GetCurrentState() == State.Running, \"Character should be in Running state\");\n", "suffix": "            character.ExitState(State.Jumping);\n            character.EnterState(State.Idle);\n            Debug.Assert(character.GetCurrentState() == State.Idle, \"Character should be in Idle state\");\n        }\n    }\n}\n", "golden_completion": "            character.ExitState(State.Running);\n            character.EnterState(State.Jumping);\n            Debug.Assert(character.GetCurrentState() == State.Jumping, \"Character should be in Jumping state\");\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a pattern in state management for a game character. The prefix establishes the pattern of switching states, and the completion should follow this pattern by handling state transitions and verifying them using assertions. The suffix continues with different state transitions and additional assertions. This is a realistic scenario developers encounter when implementing state machines in game mechanics.", "assertions": "", "gpt-35-turbo-completions": "character.ExitState(State.Running);\n            character.EnterState(State.Jumping);\n            Debug.Assert(character.GetCurrentState() == State.Jumping, \"Character should be in Jumping state\");\n#TODO: You Code Here"}
{"id": "40", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameAI\n{\n    public class StateMachine<TState, TEvent>\n    {\n        private readonly Dictionary<TState, Dictionary<TEvent, TState>> _transitions;\n\n        public StateMachine()\n        {\n            _transitions = new Dictionary<TState, Dictionary<TEvent, TState>>();\n        }\n\n        public void AddTransition(TState fromState, TEvent evt, TState toState)\n        {\n            if (!_transitions.ContainsKey(fromState))\n            {\n                _transitions[fromState] = new Dictionary<TEvent, TState>();\n            }\n            _transitions[fromState][evt] = toState;\n        }\n\n        public TState GetNextState(TState currentState, TEvent evt)\n        {\n            if (_transitions.ContainsKey(currentState) && _transitions[currentState].ContainsKey(evt))\n            {\n                return _transitions[currentState][evt];\n            }\n            else\n            {\n                throw new InvalidOperationException(\"Invalid state transition.\");\n            }\n        }\n    }\n\n    public class GameAI\n    {\n        private readonly StateMachine<string, string> _stateMachine;\n\n        public GameAI()\n        {\n            _stateMachine = new StateMachine<string, string>();\n            InitializeStateMachine();\n        }\n\n        private void InitializeStateMachine()\n        {\n            _stateMachine.AddTransition(\"Idle\", \"SeeEnemy\", \"Attack\");\n            _stateMachine.AddTransition(\"Attack\", \"LoseEnemy\", \"Search\");\n            _stateMachine.AddTransition(\"Search\", \"FindEnemy\", \"Attack\");\n            _stateMachine.AddTransition(\"Search\", \"GiveUp\", \"Idle\");\n        }\n\n        public string GetNextState(string currentState, string evt)\n        {\n            return _stateMachine.GetNextState(currentState, evt);\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            GameAI ai = new GameAI();\n            string nextState = ai.GetNextState(\"Idle\", \"SeeEnemy\");\n            Debug.Assert(nextState == \"Attack\", \"Expected next state to be Attack\");\n            nextState = ai.GetNextState(\"Attack\", \"LoseEnemy\");\n            Debug.Assert(nextState == \"Search\", \"Expected next state to be Search\");\n", "suffix": "\n\n            try\n            {\n                nextState = ai.GetNextState(\"Idle\", \"UnknownEvent\");\n            }\n            catch (InvalidOperationException ex)\n            {\n                Debug.Assert(ex.Message == \"Invalid state transition.\", \"Expected Invalid state transition exception\");\n            }\n        }\n    }\n}\n", "golden_completion": "            nextState = ai.GetNextState(\"Search\", \"FindEnemy\");\n            Debug.Assert(nextState == \"Attack\", \"Expected next state to be Attack\");\n            nextState = ai.GetNextState(\"Search\", \"GiveUp\");\n            Debug.Assert(nextState == \"Idle\", \"Expected next state to be Idle\");\n", "LLM_justification": "This example establishes a clear pattern of adding state transitions to a state machine and querying the next state based on the current state and event. The pattern is identifiable through multiple examples of adding transitions and querying the next state. The golden completion follows this pattern by continuing the established state transition queries and verifying the results with assertions. This tests the LLM's ability to recognize and continue the pattern correctly. The assertions ensure that the state transitions work as expected, including handling invalid transitions with proper exception handling.", "assertions": "", "gpt-35-turbo-completions": "nextState = ai.GetNextState(\"Search\", \"FindEnemy\");\n            Debug.Assert(nextState == \"Attack\", \"Expected next state to be Attack\");\n            nextState = ai.GetNextState(\"Search\", \"GiveUp\");\n            Debug.Assert(nextState == \"Idle\", \"Expected next state to be Idle\");"}
{"id": "41", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\nnamespace GameAI\n{\n    public enum AIState\n    {\n        Idle,\n        Patrol,\n        Chase,\n        Attack\n    }\n\n    public class EnemyAI\n    {\n        private AIState _currentState;\n        private List<string> _patrolPoints;\n        private int _currentPatrolIndex;\n\n        public EnemyAI(List<string> patrolPoints)\n        {\n            _patrolPoints = patrolPoints;\n            _currentPatrolIndex = 0;\n            _currentState = AIState.Idle;\n        }\n\n        public void Update()\n        {\n            switch (_currentState)\n            {\n                case AIState.Idle:\n                    Debug.WriteLine(\"Enemy is idle.\");\n                    IdleBehavior();\n                    break;\n                case AIState.Patrol:\n                    Debug.WriteLine(\"Enemy is patrolling.\");\n                    PatrolBehavior();\n                    break;\n                case AIState.Chase:\n                    Debug.WriteLine(\"Enemy is chasing.\");\n                    ChaseBehavior();\n                    break;\n                case AIState.Attack:\n                    Debug.WriteLine(\"Enemy is attacking.\");\n                    AttackBehavior();\n                    break;\n            }\n        }\n\n        private void IdleBehavior()\n        {\n            // Transition to Patrol after some condition\n            _currentState = AIState.Patrol;\n        }\n\n        private void PatrolBehavior()\n        {\n            // Move to the next patrol point\n            _currentPatrolIndex = (_currentPatrolIndex + 1) % _patrolPoints.Count;\n            Debug.WriteLine($\"Moving to patrol point {_patrolPoints[_currentPatrolIndex]}.\");\n            // Transition to Chase if an enemy is spotted\n            if (EnemySpotted())\n            {\n                _currentState = AIState.Chase;\n            }\n        }\n\n        private bool EnemySpotted()\n        {\n            // Simplified enemy spotting logic\n            return new Random().Next(0, 10) > 7;\n        }\n", "suffix": "        private void ChaseBehavior()\n        {\n            // Move towards the player\n            Debug.WriteLine(\"Chasing the player.\");\n            // Transition to Attack if close enough to the player\n            if (PlayerInRange())\n            {\n                _currentState = AIState.Attack;\n            }\n        }\n\n        private bool PlayerInRange()\n        {\n            // Simplified player range check\n            return new Random().Next(0, 10) > 5;\n        }\n\n        private void AttackBehavior()\n        {\n            // Perform attack\n            Debug.WriteLine(\"Attacking the player.\");\n            // Transition back to Idle after attacking\n            _currentState = AIState.Idle;\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            List<string> patrolPoints = new List<string> { \"PointA\", \"PointB\", \"PointC\" };\n            EnemyAI enemyAI = new EnemyAI(patrolPoints);\n\n            enemyAI.Update();\n            Debug.Assert(enemyAI.GetCurrentState() == AIState.Patrol, \"Enemy should transition to Patrol from Idle.\");\n\n            enemyAI.Update();\n            Debug.Assert(enemyAI.GetCurrentState() != AIState.Idle, \"Enemy should no longer be Idle.\");\n\n            // Simulate the AI update loop\n            for (int i = 0; i < 10; i++)\n            {\n                enemyAI.Update();\n                Debug.WriteLine(enemyAI.GetCurrentState().ToString());\n            }\n        }\n    }\n}\n", "golden_completion": "        public AIState GetCurrentState()\n        {\n            return _currentState;\n        }\n", "LLM_justification": "This example tests the pattern matching capabilities of an LLM by using a state machine to manage the behavior of an enemy AI in a game. The pattern involves transitioning between different states (Idle, Patrol, Chase, Attack) based on certain conditions. The golden completion requires the LLM to correctly implement a method that adheres to this established pattern of state management, allowing the AI's current state to be queried. This scenario is realistic and practical, as state machines are commonly used in game development to manage complex behavior logic. The assertions in the suffix ensure that the state transitions occur as expected, verifying both pattern adherence and functionality.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "42", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace SecurityExample\n{\n    public class EncryptionService\n    {\n        private readonly Aes _aes;\n\n        public EncryptionService()\n        {\n            _aes = Aes.Create();\n            _aes.Key = Encoding.UTF8.GetBytes(\"A key that is 32 bytes long........\");\n            _aes.IV = Encoding.UTF8.GetBytes(\"16 bytes IV......\");\n        }\n\n        public byte[] Encrypt(string plainText)\n        {\n            byte[] encrypted;\n            using (var encryptor = _aes.CreateEncryptor(_aes.Key, _aes.IV))\n            {\n                var plainBytes = Encoding.UTF8.GetBytes(plainText);\n                encrypted = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);\n            }\n            return encrypted;\n        }\n\n        public string Decrypt(byte[] encryptedBytes)\n        {\n            string decrypted;\n            using (var decryptor = _aes.CreateDecryptor(_aes.Key, _aes.IV))\n            {\n                var decryptedBytes = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);\n                decrypted = Encoding.UTF8.GetString(decryptedBytes);\n            }\n            return decrypted;\n        }\n\n        public void Dispose()\n        {\n            if (_aes != null)\n            {\n                _aes.Dispose();\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var encryptionService = new EncryptionService();\n            var secretMessage = \"Hello, world!\";\n            var encryptedMessage = encryptionService.Encrypt(secretMessage);\n            var decryptedMessage = encryptionService.Decrypt(encryptedMessage);\n", "suffix": "            Debug.Assert(decryptedMessage == secretMessage, \"Decryption failed: the decrypted message does not match the original.\");\n            Console.WriteLine(\"Encryption and decryption succeeded.\");\n\n            encryptionService.Dispose();\n        }\n    }\n}\n", "golden_completion": "            Debug.Assert(encryptedMessage.Length > 0, \"Encryption failed: the encrypted message is empty.\");\n", "LLM_justification": "This example tests an LLM's ability to recognize and complete a pattern in error handling within the domain of security (encryption). The pattern is established by showing encryption and decryption methods that use Aes for secure data handling. The golden completion continues this pattern by adding an appropriate assertion to check the length of the encrypted message, ensuring it is not empty. This is realistic as it is common practice to verify that encryption operations produce a valid non-empty output. The suffix includes further assertions and proper cleanup of resources, ensuring all assertions pass before disposing of the encryption service.", "assertions": "", "gpt-35-turbo-completions": "Console.WriteLine($\"Original message: {secretMessage}\");\n            Console.WriteLine($\"Encrypted message: {Convert.ToBase64String(encryptedMessage)}\");\n            Console.WriteLine($\"Decrypted message: {decryptedMessage}\");"}
{"id": "43", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\npublic class EncryptionUtility\n{\n    private const string Key = \"E546C8DF278CD5931069B522E695D4F2\";\n    private const string IV = \"A8AFC1B7C3D4E2F8\";\n\n    public static string Encrypt(string plainText)\n    {\n        using (Aes aesAlg = Aes.Create())\n        {\n            aesAlg.Key = Encoding.UTF8.GetBytes(Key);\n            aesAlg.IV = Encoding.UTF8.GetBytes(IV);\n            ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);\n            using (System.IO.MemoryStream msEncrypt = new System.IO.MemoryStream())\n            {\n                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))\n                {\n                    using (System.IO.StreamWriter swEncrypt = new System.IO.StreamWriter(csEncrypt))\n                    {\n                        swEncrypt.Write(plainText);\n                    }\n                    return Convert.ToBase64String(msEncrypt.ToArray());\n                }\n            }\n        }\n    }\n\n    public static string Decrypt(string cipherText)\n    {\n        using (Aes aesAlg = Aes.Create())\n        {\n            aesAlg.Key = Encoding.UTF8.GetBytes(Key);\n            aesAlg.IV = Encoding.UTF8.GetBytes(IV);\n            ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);\n            using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(cipherText)))\n            {\n                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))\n                {\n                    using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))\n                    {\n                        return srDecrypt.ReadToEnd();\n                    }\n                }\n            }\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string original = \"Sensitive data\";\n        string encrypted = EncryptionUtility.Encrypt(original);\n        Debug.Assert(!string.IsNullOrEmpty(encrypted), \"Encryption failed\");\n        string decrypted = EncryptionUtility.Decrypt(encrypted);\n        Debug.Assert(decrypted == original, \"Decryption failed\");\n", "suffix": "    }\n}\n", "golden_completion": "        string yetAnotherOriginal = \"Yet another piece of data\";\n        string yetAnotherEncrypted = EncryptionUtility.Encrypt(yetAnotherOriginal);\n        Debug.Assert(!string.IsNullOrEmpty(yetAnotherEncrypted), \"Encryption failed for yet another piece of data\");\n        string yetAnotherDecrypted = EncryptionUtility.Decrypt(yetAnotherEncrypted);\n        Debug.Assert(yetAnotherDecrypted == yetAnotherOriginal, \"Decryption failed for yet another piece of data\");\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving encryption and decryption operations. The pattern involves encrypting a string, checking that the encrypted string is not null or empty, decrypting the encrypted string, and verifying that the decrypted string matches the original. This pattern is established clearly in the prefix and requires the LLM to correctly follow the pattern in the golden completion. The suffix continues the pattern with different data, ensuring consistency and correctness. Assertions are included to validate the functionality and adherence to the established pattern.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "44", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameAI\n{\n    public class StateMachine<TState, TEvent>\n    {\n        private readonly Dictionary<TState, Dictionary<TEvent, TState>> transitions;\n        private TState currentState;\n\n        public StateMachine(TState initialState)\n        {\n            currentState = initialState;\n            transitions = new Dictionary<TState, Dictionary<TEvent, TState>>();\n        }\n\n        public void AddTransition(TState fromState, TEvent eventTrigger, TState toState)\n        {\n            if (!transitions.ContainsKey(fromState))\n            {\n                transitions[fromState] = new Dictionary<TEvent, TState>();\n            }\n            transitions[fromState][eventTrigger] = toState;\n        }\n\n        public void TriggerEvent(TEvent eventTrigger)\n        {\n            if (transitions.ContainsKey(currentState) && transitions[currentState].ContainsKey(eventTrigger))\n            {\n                currentState = transitions[currentState][eventTrigger];\n            }\n            else\n            {\n                throw new InvalidOperationException(\"Invalid state transition\");\n            }\n        }\n\n        public TState GetCurrentState()\n        {\n            return currentState;\n        }\n    }\n\n    public enum GameState\n    {\n        Start,\n        Playing,\n        GameOver\n    }\n\n    public enum GameEvent\n    {\n        Begin,\n        Win,\n        Lose\n    }\n\n    public class Game\n    {\n        private StateMachine<GameState, GameEvent> stateMachine;\n\n        public Game()\n        {\n            stateMachine = new StateMachine<GameState, GameEvent>(GameState.Start);\n            stateMachine.AddTransition(GameState.Start, GameEvent.Begin, GameState.Playing);\n            stateMachine.AddTransition(GameState.Playing, GameEvent.Win, GameState.GameOver);\n            stateMachine.AddTransition(GameState.Playing, GameEvent.Lose, GameState.GameOver);\n        }\n\n        public void StartGame()\n        {\n            stateMachine.TriggerEvent(GameEvent.Begin);\n        }\n\n        public void WinGame()\n        {\n            stateMachine.TriggerEvent(GameEvent.Win);\n        }\n\n        public void LoseGame()\n        {\n            stateMachine.TriggerEvent(GameEvent.Lose);\n        }\n\n        public GameState GetCurrentState()\n        {\n            return stateMachine.GetCurrentState();\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            Game game = new Game();\n            game.StartGame();\n            Debug.Assert(game.GetCurrentState() == GameState.Playing, \"Game should be in Playing state after StartGame\");\n", "suffix": "            game.WinGame();\n            Debug.Assert(game.GetCurrentState() == GameState.GameOver, \"Game should be in GameOver state after WinGame\");\n\n            game = new Game();\n            game.StartGame();\n            game.LoseGame();\n            Debug.Assert(game.GetCurrentState() == GameState.GameOver, \"Game should be in GameOver state after LoseGame\");\n        }\n    }\n}\n", "golden_completion": "            game.LoseGame();\n            Debug.Assert(game.GetCurrentState() == GameState.GameOver, \"Game should be in GameOver state after LoseGame\");\n", "LLM_justification": "This test case is a good example because it establishes a clear pattern in the implementation of a state machine for a game. The pattern includes adding transitions and triggering events to change states. The golden completion follows this pattern by triggering an event and checking the state change. The suffix completes the pattern with different event triggers and assertions to verify correct state transitions. This setup tests the LLM's ability to recognize and continue the established pattern while ensuring functionality through assertions.", "assertions": "", "gpt-35-turbo-completions": "game = new Game();\n            game.StartGame();\n            game.WinGame();\n            Debug.Assert(game.GetCurrentState() == GameState.GameOver, \"Game should be in GameOver state after WinGame\");\n\n            game = new Game();\n            game.StartGame();\n            game.LoseGame();\n            Debug.Assert(game.GetCurrentState() == GameState.GameOver, \"Game should be in GameOver state after LoseGame\");\n        }\n    }\n}\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameAI\n{\n    public class StateMachine<TState, TEvent>\n    {\n        private readonly Dictionary<TState, Dictionary<TEvent, TState>> transitions;\n        private TState currentState;\n\n        public StateMachine(TState initialState)\n        {\n            currentState = initialState;\n            transitions = new Dictionary<TState, Dictionary<TEvent, TState>>();\n        }\n\n        public void AddTransition(TState fromState, TEvent eventTrigger, TState toState)\n        {\n            if (!transitions.ContainsKey(fromState))\n            {\n                transitions[fromState] = new Dictionary<TEvent, TState>();\n            }\n            transitions[fromState][eventTrigger] = toState;\n        }\n\n        public void TriggerEvent(TEvent eventTrigger)\n        {\n            if (transitions.ContainsKey(currentState) && transitions[currentState].ContainsKey(eventTrigger))\n            {\n                currentState = transitions[currentState][eventTrigger];\n            }\n            else\n            {\n                throw new InvalidOperationException(\"Invalid state transition\");\n            }\n        }\n\n        public TState GetCurrentState()\n        {\n            return currentState;\n        }\n    }\n\n    public enum GameState\n    {\n        Start,\n        Playing,\n        GameOver\n    }\n\n    public enum GameEvent\n    {\n        Begin,\n        Win,\n        Lose\n    }\n\n    public class Game\n    {\n        private StateMachine<GameState, GameEvent> stateMachine;\n\n        public Game()\n        {\n            stateMachine = new StateMachine<GameState, GameEvent>(GameState.Start);\n            stateMachine.AddTransition(GameState.Start, GameEvent.Begin, GameState.Playing);\n            stateMachine.AddTransition(GameState.Playing, GameEvent.Win, GameState.GameOver);\n            stateMachine.AddTransition(GameState.Playing, GameEvent.Lose, GameState.GameOver);\n        }\n\n        public void StartGame()\n        {\n            stateMachine.TriggerEvent(GameEvent.Begin);\n        }\n\n        public void WinGame()\n        {\n            stateMachine.TriggerEvent(GameEvent.Win);\n        }\n\n        public void LoseGame()\n        {\n            stateMachine.TriggerEvent(GameEvent.Lose);\n        }\n\n        public GameState GetCurrentState()\n        {\n            return stateMachine.GetCurrentState();\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            Game game = new Game();\n            game.StartGame();\n            Debug.Assert(game.GetCurrentState() == GameState.Playing, \"Game should be in Playing state after StartGame\");\n#TODO: You Code Here\n            game = new Game();\n            game.StartGame();"}
{"id": "45", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\npublic class EncryptionUtility\n{\n    public string EncryptString(string plainText, string key)\n    {\n        using (Aes aesAlg = Aes.Create())\n        {\n            aesAlg.Key = Encoding.UTF8.GetBytes(key);\n            aesAlg.IV = new byte[16]; // Zero IV for simplicity\n\n            ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);\n\n            using (var msEncrypt = new System.IO.MemoryStream())\n            {\n                using (var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))\n                {\n                    using (var swEncrypt = new System.IO.StreamWriter(csEncrypt))\n                    {\n                        swEncrypt.Write(plainText);\n                    }\n                    return Convert.ToBase64String(msEncrypt.ToArray());\n                }\n            }\n        }\n    }\n\n    public string DecryptString(string cipherText, string key)\n    {\n        using (Aes aesAlg = Aes.Create())\n        {\n            aesAlg.Key = Encoding.UTF8.GetBytes(key);\n            aesAlg.IV = new byte[16]; // Zero IV for simplicity\n\n            ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);\n\n            using (var msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(cipherText)))\n            {\n                using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))\n                {\n                    using (var srDecrypt = new System.IO.StreamReader(csDecrypt))\n                    {\n                        return srDecrypt.ReadToEnd();\n                    }\n                }\n            }\n        }\n    }\n\n    // Encryption and decryption using RSA\n    public string EncryptStringRSA(string plainText, RSA rsa)\n    {\n        byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);\n        byte[] encryptedBytes = rsa.Encrypt(plainBytes, RSAEncryptionPadding.OaepSHA256);\n        return Convert.ToBase64String(encryptedBytes);\n    }\n\n    public string DecryptStringRSA(string cipherText, RSA rsa)\n    {\n        byte[] cipherBytes = Convert.FromBase64String(cipherText);\n        byte[] decryptedBytes = rsa.Decrypt(cipherBytes, RSAEncryptionPadding.OaepSHA256);\n        return Encoding.UTF8.GetString(decryptedBytes);\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var util = new EncryptionUtility();\n        string key = \"0123456789abcdef\"; // 16 bytes key\n        string originalText = \"Hello, World!\";\n\n        // Symmetric Encryption\n        string encryptedText = util.EncryptString(originalText, key);\n        string decryptedText = util.DecryptString(encryptedText, key);\n        Debug.Assert(decryptedText == originalText, \"Symmetric encryption/decryption failed\");\n", "suffix": "        using (RSA rsa = RSA.Create())\n        {\n            rsa.KeySize = 2048;\n            string rsaEncrypted = util.EncryptStringRSA(originalText, rsa);\n            string rsaDecrypted = util.DecryptStringRSA(rsaEncrypted, rsa);\n            Debug.Assert(rsaDecrypted == originalText, \"RSA encryption/decryption failed\");\n        }\n\n        Console.WriteLine(\"All encryption tests passed successfully.\");\n    }\n}\n", "golden_completion": "        Debug.Assert(encryptedText != originalText, \"Symmetric encryption did not change the text\");\n        Debug.Assert(!string.IsNullOrEmpty(encryptedText), \"Encrypted text should not be null or empty\");\n", "LLM_justification": "This scenario demonstrates a clear pattern of encryption and decryption using both symmetric (AES) and asymmetric (RSA) algorithms. The pattern of encryption followed by decryption and validation through assertions is evident. The golden_completion reinforces this pattern with additional assertions to ensure encryption actually alters the text and results are not null or empty, which are common checks in encryption routines. This pattern is realistic and practical, ensuring the LLM can recognize and continue the established encryption/decryption validation process.", "assertions": "", "gpt-35-turbo-completions": "// Asymmetric Encryption"}
{"id": "46", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public class StateMachine<TState, TEvent>\n    {\n        private readonly Dictionary<TState, Dictionary<TEvent, TState>> _transitions;\n        private TState _currentState;\n\n        public StateMachine(TState initialState)\n        {\n            _currentState = initialState;\n            _transitions = new Dictionary<TState, Dictionary<TEvent, TState>>();\n        }\n\n        public void AddTransition(TState fromState, TEvent eventTrigger, TState toState)\n        {\n            if (!_transitions.ContainsKey(fromState))\n            {\n                _transitions[fromState] = new Dictionary<TEvent, TState>();\n            }\n            _transitions[fromState][eventTrigger] = toState;\n        }\n\n        public void FireEvent(TEvent eventTrigger)\n        {\n            if (_transitions.ContainsKey(_currentState) && _transitions[_currentState].ContainsKey(eventTrigger))\n            {\n                _currentState = _transitions[_currentState][eventTrigger];\n            }\n            else\n            {\n                throw new InvalidOperationException(\"Invalid state transition\");\n            }\n        }\n\n        public TState GetCurrentState()\n        {\n            return _currentState;\n        }\n    }\n\n    public class StateMachineTest\n    {\n        public static void Main(string[] args)\n        {\n            var stateMachine = new StateMachine<string, string>(\"Idle\");\n            stateMachine.AddTransition(\"Idle\", \"Start\", \"Running\");\n            stateMachine.AddTransition(\"Running\", \"Stop\", \"Idle\");\n            stateMachine.AddTransition(\"Running\", \"Pause\", \"Paused\");\n            stateMachine.AddTransition(\"Paused\", \"Resume\", \"Running\");\n\n            stateMachine.FireEvent(\"Start\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Running\", \"State should be Running after Start event\");\n\n            stateMachine.FireEvent(\"Pause\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Paused\", \"State should be Paused after Pause event\");\n\n            stateMachine.FireEvent(\"Resume\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Running\", \"State should be Running after Resume event\");\n", "suffix": "        }\n    }\n}\n", "golden_completion": "            stateMachine.FireEvent(\"Stop\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Idle\", \"State should be Idle after Stop event\");\n\n            try\n            {\n                stateMachine.FireEvent(\"InvalidEvent\");\n            }\n            catch (InvalidOperationException ex)\n            {\n                Debug.Assert(ex.Message == \"Invalid state transition\", \"Exception message should be 'Invalid state transition'\");\n            }\n", "LLM_justification": "This example tests the pattern matching capabilities in the context of implementing a state machine for game mechanics. The prefix sets up the state machine with transitions and tests some state changes. The golden completion follows the pattern of firing events and asserting state transitions, while also handling invalid transitions with appropriate error handling. The suffix continues with additional event firings and assertions. This scenario is practical and tests the LLM's ability to recognize and continue established patterns in error handling and state management.", "assertions": "", "gpt-35-turbo-completions": "stateMachine.FireEvent(\"Stop\");\n            Debug.Assert(stateMachine.GetCurrentState() == \"Idle\", \"State should be Idle after Stop event\");\n            Console.WriteLine(\"All tests passed\");"}
{"id": "47", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\npublic class AlgorithmDemo\n{\n    public static int Fibonacci(int n)\n    {\n        if (n <= 1) return n;\n        return Fibonacci(n - 1) + Fibonacci(n - 2);\n    }\n\n    public static bool IsPrime(int number)\n    {\n        if (number <= 1) return false;\n        if (number == 2) return true;\n        if (number % 2 == 0) return false;\n        for (int i = 3; i <= Math.Sqrt(number); i += 2)\n        {\n            if (number % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    public static int Factorial(int n)\n    {\n        if (n <= 1) return 1;\n        return n * Factorial(n - 1);\n    }\n", "suffix": "    public static void Main(string[] args)\n    {\n        int fib10 = Fibonacci(10);\n        Debug.Assert(fib10 == 55, \"Fibonacci(10) should be 55\");\n\n        bool isPrime7 = IsPrime(7);\n        Debug.Assert(isPrime7 == true, \"IsPrime(7) should be true\");\n\n        int fact5 = Factorial(5);\n        Debug.Assert(fact5 == 120, \"Factorial(5) should be 120\");\n    }\n}\n", "golden_completion": "    public static int SumOfSquares(int n)\n    {\n        int sum = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            sum += i * i;\n        }\n        return sum;\n    }\n", "LLM_justification": "This is a good test case because it involves algorithm implementation, a common pattern in C# programming. The prefix sets up a clear pattern by defining three well-known mathematical functions (Fibonacci, IsPrime, and Factorial) using both recursion and iteration. The golden completion should follow this pattern by implementing another mathematical algorithm (SumOfSquares) using a similar approach. The suffix includes execution code and assertions that verify the correctness of the implemented algorithms, ensuring that the pattern is adhered to and the functionality is correct.", "assertions": "", "gpt-35-turbo-completions": "public static int GCD(int a, int b)\n    {\n        if (b == 0) return a;\n        return GCD(b, a % b);\n    }\n\n    public static int LCM(int a, int b)\n    {\n        return a * b / GCD(a, b);\n    }\n\n    public static int BinarySearch(int[] arr, int target)\n    {\n        int left = 0;\n        int right = arr.Length - 1;\n        while (left <= right)\n        {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] == target) return mid;\n            if (arr[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return -1;\n    }\n\n    public static int[] BubbleSort(int[] arr)\n    {\n        for (int i = 0; i < arr.Length - 1; i++)\n        {\n            for (int j = 0; j < arr.Length - i - 1; j++)\n            {\n                if (arr[j] > arr[j + 1])\n                {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n        return arr;\n    }\n\n    public static int[] QuickSort(int[] arr)\n    {\n        if (arr.Length <= 1) return arr;\n        int pivot = arr[0];\n        List<int> left = new List<int>();\n        List<int> right = new List<int>();\n        for (int i = 1; i < arr.Length; i++)\n        {\n            if (arr[i] < pivot) left.Add(arr[i]);\n            else right.Add(arr[i]);\n        }\n        return QuickSort(left.ToArray())\n            .Append(pivot)\n            .Concat(QuickSort(right.ToArray()))\n            .ToArray();\n    }\n\n    public static int[] MergeSort(int[] arr)\n    {\n        if (arr.Length <= 1) return arr;\n        int mid = arr.Length / 2;\n        int[] left = new int[mid];\n        int[] right = new int[arr.Length - mid];\n        Array.Copy(arr, 0, left, 0, mid);\n        Array.Copy(arr, mid, right, 0, arr.Length - mid);\n        return Merge(MergeSort(left), MergeSort(right));\n    }\n\n    private static int[] Merge(int[] left, int[] right)\n    {\n        int[] result = new int[left.Length + right.Length];\n        int i = 0, j = 0, k = 0;\n        while (i < left.Length && j < right.Length)\n        {\n            if (left[i] < right[j]) result[k++] = left[i++];\n            else result[k++] = right[j++];\n        }\n        while (i < left.Length) result[k++] = left[i++];\n        while (j < right.Length) result[k++] = right[j++];\n        return result;\n    }\n\n    public static int[] SelectionSort(int[] arr)\n    {\n        for (int i = 0; i < arr.Length - 1; i++)\n        {\n            int minIndex = i;\n            for (int j = i + 1; j < arr.Length; j++)\n            {\n                if (arr[j] < arr[minIndex]) minIndex = j;\n            }\n            int temp = arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp;\n        }\n        return arr;\n    }\n\n    public static int[] InsertionSort(int[] arr)\n    {\n        for (int i = 1; i < arr.Length; i++)\n        {\n            int key = arr[i];\n            int j = i - 1;\n            while (j >= 0 && arr[j] >"}
{"id": "48", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public class StateMachine<TState>\n    {\n        private readonly Dictionary<TState, Action> _stateActions;\n        private TState _currentState;\n\n        public StateMachine()\n        {\n            _stateActions = new Dictionary<TState, Action>();\n        }\n\n        public void AddState(TState state, Action action)\n        {\n            if (state == null) throw new ArgumentNullException(nameof(state));\n            if (action == null) throw new ArgumentNullException(nameof(action));\n            _stateActions[state] = action;\n        }\n\n        public void ChangeState(TState newState)\n        {\n            if (!_stateActions.ContainsKey(newState)) throw new InvalidOperationException(\"State not defined\");\n            _currentState = newState;\n        }\n\n        public void Update()\n        {\n            if (_currentState == null) throw new InvalidOperationException(\"Current state is not set\");\n            _stateActions[_currentState]?.Invoke();\n        }\n    }\n\n    public enum GameStates\n    {\n        MainMenu,\n        Playing,\n        Paused,\n        GameOver\n    }\n\n    public class Game\n    {\n        private StateMachine<GameStates> _stateMachine;\n\n        public Game()\n        {\n            _stateMachine = new StateMachine<GameStates>();\n            InitializeStates();\n        }\n\n        private void InitializeStates()\n        {\n            _stateMachine.AddState(GameStates.MainMenu, MainMenu);\n            _stateMachine.AddState(GameStates.Playing, Playing);\n            _stateMachine.AddState(GameStates.Paused, Paused);\n            _stateMachine.AddState(GameStates.GameOver, GameOver);\n        }\n\n        private void MainMenu()\n        {\n            Console.WriteLine(\"In Main Menu\");\n        }\n\n        private void Playing()\n        {\n            Console.WriteLine(\"Game is Playing\");\n        }\n\n        private void Paused()\n        {\n            Console.WriteLine(\"Game is Paused\");\n        }\n\n        private void GameOver()\n        {\n            Console.WriteLine(\"Game Over\");\n        }\n\n        public void StartGame()\n        {\n            _stateMachine.ChangeState(GameStates.MainMenu);\n            _stateMachine.Update();\n        }\n", "suffix": "        public void PauseGame()\n        {\n            _stateMachine.ChangeState(GameStates.Paused);\n            _stateMachine.Update();\n            Debug.Assert(_stateMachine != null, \"State machine should not be null\");\n        }\n\n        public void EndGame()\n        {\n            _stateMachine.ChangeState(GameStates.GameOver);\n            _stateMachine.Update();\n            Debug.Assert(_stateMachine != null, \"State machine should not be null\");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Game game = new Game();\n            game.StartGame();\n            game.PauseGame();\n            game.EndGame();\n        }\n    }\n}\n", "golden_completion": "        public void ResumeGame()\n        {\n            _stateMachine.ChangeState(GameStates.Playing);\n            _stateMachine.Update();\n            Debug.Assert(_stateMachine != null, \"State machine should not be null\");\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of state transitions within a state machine for a game. The prefix establishes the pattern of adding states and transitioning between them, and the golden completion requires the LLM to continue this pattern by adding a method to resume the game. The suffix then adds additional state transitions and assertions to ensure the correct functioning and pattern adherence.", "assertions": "", "gpt-35-turbo-completions": ""}
{"id": "49", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GameMechanics\n{\n    public class StateMachine\n    {\n        private Dictionary<string, Action> _states;\n        private string _currentState;\n\n        public StateMachine()\n        {\n            _states = new Dictionary<string, Action>();\n            _currentState = string.Empty;\n        }\n\n        public void AddState(string name, Action action)\n        {\n            if (!_states.ContainsKey(name))\n            {\n                _states[name] = action;\n            }\n        }\n\n        public void SetState(string name)\n        {\n            if (_states.ContainsKey(name))\n            {\n                _currentState = name;\n            }\n        }\n\n        public void Update()\n        {\n            if (_states.ContainsKey(_currentState))\n            {\n                _states[_currentState].Invoke();\n            }\n        }\n\n        // Pattern: Adding a new state\n        // Example states\n        public void InitializeStates()\n        {\n            AddState(\"Idle\", Idle);\n            AddState(\"Running\", Running);\n            AddState(\"Jumping\", Jumping);\n        }\n\n        private void Idle()\n        {\n            Console.WriteLine(\"State: Idle\");\n        }\n\n        private void Running()\n        {\n            Console.WriteLine(\"State: Running\");\n        }\n", "suffix": "        public void TestStateMachine()\n        {\n            InitializeStates();\n            SetState(\"Idle\");\n            Update();\n            Debug.Assert(_currentState == \"Idle\", \"Expected state to be 'Idle'\");\n            SetState(\"Running\");\n            Update();\n            Debug.Assert(_currentState == \"Running\", \"Expected state to be 'Running'\");\n            SetState(\"Jumping\");\n            Update();\n            Debug.Assert(_currentState == \"Jumping\", \"Expected state to be 'Jumping'\");\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            StateMachine stateMachine = new StateMachine();\n            stateMachine.TestStateMachine();\n        }\n    }\n}\n", "golden_completion": "        private void Jumping()\n        {\n            Console.WriteLine(\"State: Jumping\");\n        }\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of adding new states to a state machine in a game mechanics context. The prefix establishes a clear pattern of adding states with specific methods, and the golden completion requires adding another state following the same pattern. The suffix includes test cases to verify that the state machine behaves correctly, making it a robust test for pattern matching and functional correctness.", "assertions": "", "gpt-35-turbo-completions": "private void Jumping()\n        {\n            Console.WriteLine(\"State: Jumping\");\n        }\n\n        // Pattern: State machine\n        // Example state machine"}
{"id": "50", "testsource": "synthbench-pattern-matching", "language": "c_sharp", "prefix": "using System;\nusing System.Diagnostics;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace SecurityExample\n{\n    public class EncryptionHelper\n    {\n        private readonly Aes _aes;\n\n        public EncryptionHelper()\n        {\n            _aes = Aes.Create();\n            _aes.Key = Encoding.UTF8.GetBytes(\"a very strong key123\");\n            _aes.IV = Encoding.UTF8.GetBytes(\"a strong IV 123456\");\n        }\n\n        public byte[] Encrypt(string plainText)\n        {\n            if (string.IsNullOrEmpty(plainText))\n                throw new ArgumentException(\"plainText cannot be null or empty\", nameof(plainText));\n\n            using (var encryptor = _aes.CreateEncryptor(_aes.Key, _aes.IV))\n            {\n                byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);\n                return PerformCryptography(plainBytes, encryptor);\n            }\n        }\n\n        public string Decrypt(byte[] cipherText)\n        {\n            if (cipherText == null || cipherText.Length == 0)\n                throw new ArgumentException(\"cipherText cannot be null or empty\", nameof(cipherText));\n\n            using (var decryptor = _aes.CreateDecryptor(_aes.Key, _aes.IV))\n            {\n                byte[] plainBytes = PerformCryptography(cipherText, decryptor);\n                return Encoding.UTF8.GetString(plainBytes);\n            }\n        }\n\n        private byte[] PerformCryptography(byte[] data, ICryptoTransform cryptoTransform)\n        {\n            using (var memoryStream = new System.IO.MemoryStream())\n            using (var cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write))\n            {\n                cryptoStream.Write(data, 0, data.Length);\n                cryptoStream.FlushFinalBlock();\n                return memoryStream.ToArray();\n            }\n        }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            EncryptionHelper helper = new EncryptionHelper();\n\n            string original = \"This is a test.\";\n            byte[] encrypted = helper.Encrypt(original);\n", "suffix": "            string decrypted = helper.Decrypt(encrypted);\n\n            Debug.Assert(decrypted == original, \"Decryption did not return the original text\");\n\n            // Test with empty string\n            try\n            {\n                helper.Encrypt(\"\");\n            }\n            catch (ArgumentException ex)\n            {\n                Debug.Assert(ex.ParamName == \"plainText\", \"Exception parameter name is incorrect\");\n            }\n\n            // Test with null string\n            try\n            {\n                helper.Encrypt(null);\n            }\n            catch (ArgumentException ex)\n            {\n                Debug.Assert(ex.ParamName == \"plainText\", \"Exception parameter name is incorrect\");\n            }\n\n            // Test with null byte array\n            try\n            {\n                helper.Decrypt(null);\n            }\n            catch (ArgumentException ex)\n            {\n                Debug.Assert(ex.ParamName == \"cipherText\", \"Exception parameter name is incorrect\");\n            }\n\n            // Test with empty byte array\n            try\n            {\n                helper.Decrypt(new byte[0]);\n            }\n            catch (ArgumentException ex)\n            {\n                Debug.Assert(ex.ParamName == \"cipherText\", \"Exception parameter name is incorrect\");\n            }\n        }\n    }\n}\n", "golden_completion": "            Debug.Assert(encrypted != null && encrypted.Length > 0, \"Encryption failed\");\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of error handling in a security context, specifically within encryption and decryption functions. The prefix sets up the EncryptionHelper class with methods for Encrypt and Decrypt, including error handling for invalid input. The golden_completion ensures that the encryption result is not null or empty, adhering to the established pattern of input validation and error handling. The suffix continues with further tests and assertions to validate the functionality and error handling of the Encrypt and Decrypt methods.", "assertions": "", "gpt-35-turbo-completions": "Debug.Assert(encrypted != null, \"Encryption did not return any data\");\n\n            Debug.Assert(encrypted.Length > 0, \"Encryption did not return any data\");\n\n            Debug.Assert(encrypted.Length != Encoding.UTF8.GetBytes(original).Length, \"Encrypted data is the same length as original data\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 == 0, \"Encrypted data is not a multiple of 16 bytes\");\n\n            Debug.Assert(encrypted.Length % 16 =="}
