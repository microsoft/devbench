
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace DataValidationExample
{
    public class DataValidator
    {
        private List<Func<string, bool>> validationRules;

        public DataValidator()
        {
            validationRules = new List<Func<string, bool>>();
        }

        public void AddRule(Func<string, bool> rule)
        {
            validationRules.Add(rule);
        }

        public bool Validate(string input)
        {
            foreach (var rule in validationRules)
            {
                if (!rule(input))
                {
                    return false;
                }
            }
            return true;
        }

        public static void Main(string[] args)
        {
            DataValidator validator = new DataValidator();

            // Add rule to check if input is not empty
            validator.AddRule(input => !string.IsNullOrEmpty(input));

            // Add rule to check if input is a valid email
            validator.AddRule(input => input.Contains("@") && input.Contains("."));

            // Add rule to check if input length is greater than 5
            validator.AddRule(input => input.Length > 5);

            // Add rule to check if input contains no spaces


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            validator.AddRule(input => !input.Contains(" "));

SUFFIX CODE:
----------------------------------------
            // Assertions
            Debug.Assert(validator.Validate("test@example.com"), "Valid email should pass all rules.");
            Debug.Assert(!validator.Validate("invalid"), "Invalid email should fail.");
            Debug.Assert(!validator.Validate("short@e."), "Email too short should fail.");
            Debug.Assert(!validator.Validate("test @example.com"), "Email with spaces should fail.");

            Console.WriteLine("All assertions passed.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case examines the ability to recognize and continue a pattern of adding validation rules to a DataValidator class. The prefix sets up the class and adds three rules, establishing a clear pattern of adding lambda functions as validation rules. The golden_completion continues this pattern by adding another rule, and the suffix includes assertions that verify the functionality of the rules. This pattern is common in data validation scenarios and tests the model's understanding of higher-order functions and lambda expressions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace DataValidationExample
{
    public class DataValidator
    {
        private List<string> errors;

        public DataValidator()
        {
            errors = new List<string>();
        }

        public bool ValidateUsername(string username)
        {
            if (string.IsNullOrEmpty(username))
            {
                errors.Add("Username cannot be null or empty.");
                return false;
            }
            if (username.Length < 6)
            {
                errors.Add("Username must be at least 6 characters long.");
                return false;
            }
            return true;
        }

        public bool ValidateEmail(string email)
        {
            if (string.IsNullOrEmpty(email))
            {
                errors.Add("Email cannot be null or empty.");
                return false;
            }
            if (!email.Contains("@"))
            {
                errors.Add("Email must contain an '@' character.");
                return false;
            }
            return true;
        }

        public bool ValidatePhoneNumber(string phoneNumber)
        {
            if (string.IsNullOrEmpty(phoneNumber))
            {
                errors.Add("Phone number cannot be null or empty.");
                return false;
            }
            if (phoneNumber.Length != 10)
            {
                errors.Add("Phone number must be exactly 10 digits long.");
                return false;
            }
            return true;
        }

        public List<string> GetErrors()
        {
            return errors;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            DataValidator validator = new DataValidator();
            bool isUsernameValid = validator.ValidateUsername("user");
            bool isEmailValid = validator.ValidateEmail("user@example.com");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            bool isPhoneNumberValid = validator.ValidatePhoneNumber("1234567890");

SUFFIX CODE:
----------------------------------------
            Debug.Assert(isUsernameValid == false, "Username validation failed");
            Debug.Assert(isEmailValid == true, "Email validation failed");
            Debug.Assert(isPhoneNumberValid == true, "Phone number validation failed");

            List<string> errors = validator.GetErrors();
            Debug.Assert(errors.Count == 1, "Error count mismatch");
            Debug.Assert(errors[0] == "Username must be at least 6 characters long.", "Error message mismatch");

            Console.WriteLine("All validations and assertions passed.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is designed to check the pattern matching capabilities of an LLM by focusing on data validation in a realistic scenario. The prefix establishes a clear pattern for validation methods that include null/empty checks and specific format checks, followed by adding error messages to a list. The golden completion needs to follow this established pattern to validate a username, email, and phone number. The suffix includes assertions to verify the correctness of the validations and the error messages, ensuring the LLM's completion maintains the pattern and functionality.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace ScientificComputing
{
    public class DataAnalyzer
    {
        private List<double> data;

        public DataAnalyzer()
        {
            data = new List<double>();
        }

        public void AddData(double value)
        {
            data.Add(value);
        }

        public double CalculateMean()
        {
            if (data.Count == 0)
                throw new InvalidOperationException("No data to calculate mean.");

            double sum = 0;
            foreach (var value in data)
            {
                sum += value;
            }
            return sum / data.Count;
        }

        public double CalculateVariance()
        {
            if (data.Count == 0)
                throw new InvalidOperationException("No data to calculate variance.");

            double mean = CalculateMean();
            double sumOfSquares = 0;
            foreach (var value in data)
            {
                sumOfSquares += Math.Pow(value - mean, 2);
            }
            return sumOfSquares / data.Count;
        }

        public double CalculateStandardDeviation()
        {
            return Math.Sqrt(CalculateVariance());
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        public double CalculateKurtosis()
        {
            if (data.Count == 0)
                throw new InvalidOperationException("No data to calculate kurtosis.");

            double mean = CalculateMean();
            double variance = CalculateVariance();
            double standardDeviation = Math.Sqrt(variance);
            double sumOfQuads = 0;

            foreach (var value in data)
            {
                sumOfQuads += Math.Pow(value - mean, 4);
            }

            double n = data.Count;
            double numerator = (n * (n + 1) * sumOfQuads) - (3 * Math.Pow(sumOfQuads, 2) * (n - 1));
            double denominator = (n - 1) * (n - 2) * (n - 3) * Math.Pow(standardDeviation, 4);

            return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * (sumOfQuads / Math.Pow(standardDeviation, 4)) - (3 * Math.Pow(n - 1, 2) / ((n - 2) * (n - 3)));
        }

SUFFIX CODE:
----------------------------------------
        public double CalculateSkewness()
        {
            if (data.Count == 0)
                throw new InvalidOperationException("No data to calculate skewness.");

            double mean = CalculateMean();
            double variance = CalculateVariance();
            double standardDeviation = Math.Sqrt(variance);
            double sumOfCubes = 0;

            foreach (var value in data)
            {
                sumOfCubes += Math.Pow(value - mean, 3);
            }

            double n = data.Count;
            return (n / ((n - 1) * (n - 2))) * (sumOfCubes / Math.Pow(standardDeviation, 3));
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            DataAnalyzer analyzer = new DataAnalyzer();
            analyzer.AddData(1.0);
            analyzer.AddData(2.0);
            analyzer.AddData(3.0);
            analyzer.AddData(4.0);
            analyzer.AddData(5.0);

            double mean = analyzer.CalculateMean();
            double variance = analyzer.CalculateVariance();
            double stddev = analyzer.CalculateStandardDeviation();
            double skewness = analyzer.CalculateSkewness();
            double kurtosis = analyzer.CalculateKurtosis();

            Debug.Assert(Math.Abs(mean - 3.0) < 1e-10, "Mean calculation is incorrect.");
            Debug.Assert(Math.Abs(variance - 2.0) < 1e-10, "Variance calculation is incorrect.");
            Debug.Assert(Math.Abs(stddev - Math.Sqrt(2.0)) < 1e-10, "Standard deviation calculation is incorrect.");
            Debug.Assert(Math.Abs(skewness - 0.0) < 1e-10, "Skewness calculation is incorrect.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize a pattern in statistical computation methods within a class. The prefix establishes methods for calculating mean, variance, and standard deviation, illustrating a pattern in handling statistical data. The completion requires implementing a method for calculating kurtosis, which should follow the established pattern of statistical calculations. The suffix then adds an additional method for calculating skewness and includes assertions that verify the calculations for mean, variance, standard deviation, and skewness, ensuring the pattern is correctly followed and results are accurate.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace AnalyticsExample
{
    public class Metric
    {
        public string Name { get; }
        public double Value { get; }

        public Metric(string name, double value)
        {
            Name = name;
            Value = value;
        }
    }

    public class AnalyticsProcessor
    {
        private readonly List<Metric> _metrics;

        public AnalyticsProcessor()
        {
            _metrics = new List<Metric>();
        }

        public void AddMetric(string name, double value)
        {
            _metrics.Add(new Metric(name, value));
        }

        public double CalculateAverage(string metricName)
        {
            double sum = 0;
            int count = 0;
            foreach (var metric in _metrics)
            {
                if (metric.Name == metricName)
                {
                    sum += metric.Value;
                    count++;
                }
            }
            return count > 0 ? sum / count : 0;
        }

        public double CalculateMax(string metricName)
        {
            double max = double.MinValue;
            foreach (var metric in _metrics)
            {
                if (metric.Name == metricName)
                {
                    if (metric.Value > max)
                    {
                        max = metric.Value;
                    }
                }
            }
            return max;
        }

        public double CalculateMin(string metricName)
        {
            double min = double.MaxValue;
            foreach (var metric in _metrics)
            {
                if (metric.Name == metricName)
                {
                    if (metric.Value < min)
                    {
                        min = metric.Value;
                    }
                }
            }
            return min;
        }

        // Method to calculate the sum of a specific metric


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
public double CalculateSum(string metricName)
{
    double sum = 0;
    foreach (var metric in _metrics)
    {
        if (metric.Name == metricName)
        {
            sum += metric.Value;
        }
    }
    return sum;
}

SUFFIX CODE:
----------------------------------------
    public class Program
    {
        public static void Main(string[] args)
        {
            AnalyticsProcessor processor = new AnalyticsProcessor();
            processor.AddMetric("MetricA", 10);
            processor.AddMetric("MetricA", 20);
            processor.AddMetric("MetricA", 30);
            processor.AddMetric("MetricB", 5);
            processor.AddMetric("MetricB", 15);

            double averageA = processor.CalculateAverage("MetricA");
            double maxA = processor.CalculateMax("MetricA");
            double minA = processor.CalculateMin("MetricA");
            double sumA = processor.CalculateSum("MetricA");

            Debug.Assert(averageA == 20, "Average calculation for MetricA is incorrect");
            Debug.Assert(maxA == 30, "Max calculation for MetricA is incorrect");
            Debug.Assert(minA == 10, "Min calculation for MetricA is incorrect");
            Debug.Assert(sumA == 60, "Sum calculation for MetricA is incorrect");

            double averageB = processor.CalculateAverage("MetricB");
            double maxB = processor.CalculateMax("MetricB");
            double minB = processor.CalculateMin("MetricB");
            double sumB = processor.CalculateSum("MetricB");

            Debug.Assert(averageB == 10, "Average calculation for MetricB is incorrect");
            Debug.Assert(maxB == 15, "Max calculation for MetricB is incorrect");
            Debug.Assert(minB == 5, "Min calculation for MetricB is incorrect");
            Debug.Assert(sumB == 20, "Sum calculation for MetricB is incorrect");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is designed to assess the ability of an LLM to recognize and complete a common pattern in analytics computation. The pattern involves iterating over a list of metrics to perform various calculations (average, max, min, sum) based on a specified metric name. The prefix establishes the pattern with methods for calculating average, max, and min values. The golden completion requires the LLM to implement a method that follows the same pattern to calculate the sum of metric values. The suffix continues with different code that verifies the correctness of all calculations through assertions. This scenario is realistic for analytics processing and tests the LLM's understanding of iteration and conditional logic in C#.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace PatternMatchingExample
{
    public class DataAnalyzer
    {
        private List<double> data;

        public DataAnalyzer(List<double> inputData)
        {
            data = inputData;
        }

        public double CalculateMean()
        {
            double sum = 0;
            foreach (var item in data)
            {
                sum += item;
            }
            return sum / data.Count;
        }

        public double CalculateMedian()
        {
            data.Sort();
            int count = data.Count;
            if (count % 2 == 0)
            {
                return (data[count / 2 - 1] + data[count / 2]) / 2;
            }
            else
            {
                return data[count / 2];
            }
        }

        public double CalculateStandardDeviation()
        {
            double mean = CalculateMean();
            double sumOfSquares = 0;
            foreach (var item in data)
            {
                sumOfSquares += Math.Pow(item - mean, 2);
            }
            return Math.Sqrt(sumOfSquares / data.Count);
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            List<double> sampleData = new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };
            DataAnalyzer analyzer = new DataAnalyzer(sampleData);

            double mean = analyzer.CalculateMean();
            double median = analyzer.CalculateMedian();
            double standardDeviation = analyzer.CalculateStandardDeviation();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            Console.WriteLine($"Mean: {mean}");
            Console.WriteLine($"Median: {median}");
            Console.WriteLine($"Standard Deviation: {standardDeviation}");

SUFFIX CODE:
----------------------------------------
            Debug.Assert(mean == 3.5, "Mean calculation is incorrect");
            Debug.Assert(median == 3.5, "Median calculation is incorrect");
            Debug.Assert(Math.Abs(standardDeviation - 1.707825127659933) < 0.0001, "Standard deviation calculation is incorrect");

            Console.WriteLine("All calculations are correct!");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and extend a pattern of statistical calculation methods in a class. The prefix provides methods to calculate the mean, median, and standard deviation, which follow a clear pattern of data processing. The golden completion introduces a new method for calculating variance, which logically follows the existing pattern. The suffix includes assertions to verify the correctness of all calculations, ensuring that the pattern is maintained correctly. This scenario is realistic for scientific computing and demonstrates practical use of data analysis techniques.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Collections.Generic;

namespace ScientificComputing
{
    public class DataAnalyzer
    {
        public static double CalculateMean(List<double> data)
        {
            if (data == null || data.Count == 0)
                throw new ArgumentException("Data cannot be null or empty.");

            double sum = 0;
            foreach (var value in data)
            {
                sum += value;
            }

            double mean = sum / data.Count;
            return mean;
        }

        public static double CalculateMedian(List<double> data)
        {
            if (data == null || data.Count == 0)
                throw new ArgumentException("Data cannot be null or empty.");

            data.Sort();
            int count = data.Count;
            if (count % 2 == 0)
            {
                return (data[count / 2 - 1] + data[count / 2]) / 2.0;
            }
            else
            {
                return data[count / 2];
            }
        }

        public static double CalculateVariance(List<double> data)
        {
            if (data == null || data.Count == 0)
                throw new ArgumentException("Data cannot be null or empty.");

            double mean = CalculateMean(data);
            double sumOfSquares = 0;
            foreach (var value in data)
            {
                sumOfSquares += Math.Pow(value - mean, 2);
            }

            return sumOfSquares / data.Count;
        }



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        public static double CalculateStandardDeviation(List<double> data)
        {
            double variance = CalculateVariance(data);
            return Math.Sqrt(variance);
        }

SUFFIX CODE:
----------------------------------------

        public static void Main()
        {
            List<double> sampleData = new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0 };

            double mean = CalculateMean(sampleData);
            double median = CalculateMedian(sampleData);
            double variance = CalculateVariance(sampleData);
            double standardDeviation = Math.Sqrt(variance);

            Debug.Assert(Math.Abs(mean - 3.0) < 0.0001, "Mean calculation is incorrect.");
            Debug.Assert(Math.Abs(median - 3.0) < 0.0001, "Median calculation is incorrect.");
            Debug.Assert(Math.Abs(variance - 2.0) < 0.0001, "Variance calculation is incorrect.");
            Debug.Assert(Math.Abs(standardDeviation - Math.Sqrt(2.0)) < 0.0001, "Standard Deviation calculation is incorrect.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and complete a pattern in scientific computing, specifically related to statistical calculations (mean, median, variance). The pattern involves creating a method that performs statistical analysis on a list of doubles. The golden completion should follow the established pattern of validating input, calculating an intermediate result, and returning the final value. The suffix includes assertions to verify that all statistical calculations, including the newly implemented standard deviation, are correct.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace DataValidationExample
{
    public class DataValidator
    {
        public List<string> Errors { get; private set; }

        public DataValidator()
        {
            Errors = new List<string>();
        }

        public bool ValidateEmail(string email)
        {
            if (string.IsNullOrEmpty(email))
            {
                Errors.Add("Email is null or empty.");
                return false;
            }
            if (!email.Contains("@"))
            {
                Errors.Add("Email does not contain '@'.");
                return false;
            }
            if (!email.Contains("."))
            {
                Errors.Add("Email does not contain a domain.");
                return false;
            }
            return true;
        }

        public bool ValidatePhoneNumber(string phoneNumber)
        {
            if (string.IsNullOrEmpty(phoneNumber))
            {
                Errors.Add("Phone number is null or empty.");
                return false;
            }
            if (phoneNumber.Length < 10)
            {
                Errors.Add("Phone number is too short.");
                return false;
            }
            foreach (char c in phoneNumber)
            {
                if (!char.IsDigit(c))
                {
                    Errors.Add("Phone number contains non-digit characters.");
                    return false;
                }
            }
            return true;
        }

        public bool ValidatePassword(string password)
        {
            if (string.IsNullOrEmpty(password))
            {
                Errors.Add("Password is null or empty.");
                return false;
            }
            if (password.Length < 8)
            {
                Errors.Add("Password is too short.");
                return false;
            }
            bool hasUpperCase = false;
            bool hasLowerCase = false;
            bool hasDigit = false;
            foreach (char c in password)
            {
                if (char.IsUpper(c)) hasUpperCase = true;
                if (char.IsLower(c)) hasLowerCase = true;
                if (char.IsDigit(c)) hasDigit = true;
            }
            if (!hasUpperCase)
            {
                Errors.Add("Password does not contain an uppercase letter.");
                return false;
            }
            if (!hasLowerCase)
            {
                Errors.Add("Password does not contain a lowercase letter.");
                return false;
            }
            if (!hasDigit)
            {
                Errors.Add("Password does not contain a digit.");
                return false;
            }
            return true;
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            DataValidator validator = new DataValidator();
            
            bool isEmailValid = validator.ValidateEmail("example@domain.com");
            Debug.Assert(isEmailValid, "Email validation failed.");
            Debug.Assert(validator.Errors.Count == 0, "Unexpected errors found.");

            bool isPhoneNumberValid = validator.ValidatePhoneNumber("1234567890");
            Debug.Assert(isPhoneNumberValid, "Phone number validation failed.");
            Debug.Assert(validator.Errors.Count == 0, "Unexpected errors found.");

            bool isPasswordValid = validator.ValidatePassword("Password1");
            Debug.Assert(isPasswordValid, "Password validation failed.");
            Debug.Assert(validator.Errors.Count == 0, "Unexpected errors found.");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            bool isEmailInvalid = validator.ValidateEmail("");
            Debug.Assert(!isEmailInvalid, "Email validation should fail for empty string.");
            Debug.Assert(validator.Errors.Count > 0, "Errors should be recorded for invalid email.");
            validator.Errors.Clear();

            bool isPhoneNumberInvalid = validator.ValidatePhoneNumber("12345abc");
            Debug.Assert(!isPhoneNumberInvalid, "Phone number validation should fail for invalid input.");
            Debug.Assert(validator.Errors.Count > 0, "Errors should be recorded for invalid phone number.");
            validator.Errors.Clear();

            bool isPasswordInvalid = validator.ValidatePassword("pass");
            Debug.Assert(!isPasswordInvalid, "Password validation should fail for short password.");
            Debug.Assert(validator.Errors.Count > 0, "Errors should be recorded for invalid password.");
            validator.Errors.Clear();

SUFFIX CODE:
----------------------------------------
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example establishes a clear pattern of validating different types of input data (email, phone number, password) and adding errors to a list if validation fails. It tests the LLM's ability to recognize and continue this pattern by implementing a similar validation function for usernames. The completion involves checking if the username is valid and asserting the results, following the same validation and error-handling pattern established in the prefix. The assertions ensure that the validation logic and error handling are correctly implemented.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace DataValidation
{
    public class SchemaValidator
    {
        private readonly List<string> errors;

        public SchemaValidator()
        {
            errors = new List<string>();
        }

        public bool ValidateLength(string field, int minLength, int maxLength)
        {
            if (field.Length < minLength || field.Length > maxLength)
            {
                errors.Add($"Field '{field}' length is out of range ({minLength}-{maxLength})");
                return false;
            }
            return true;
        }

        public bool ValidateNotEmpty(string field)
        {
            if (string.IsNullOrEmpty(field))
            {
                errors.Add("Field cannot be empty");
                return false;
            }
            return true;
        }

        public bool ValidatePattern(string field, string pattern)
        {
            if (!System.Text.RegularExpressions.Regex.IsMatch(field, pattern))
            {
                errors.Add($"Field '{field}' does not match the required pattern");
                return false;
            }
            return true;
        }

        // Function to validate if a string is a valid email address
        public bool ValidateEmail(string email)
        {
            string emailPattern = "^[^@\s]+@[^@\s]+\.[^@\s]+$";
            return ValidatePattern(email, emailPattern);
        }

        // Function to validate if a string is a valid URL
        public bool ValidateUrl(string url)
        {
            string urlPattern = "^https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}$";
            return ValidatePattern(url, urlPattern);
        }

        // Function to validate if a string contains only digits
        public bool ValidateDigitsOnly(string input)
        {
            string digitsPattern = "^\d+$";
            return ValidatePattern(input, digitsPattern);
        }

        public List<string> GetErrors()
        {
            return errors;
        }
    }

    public static class Program
    {
        public static void Main()
        {
            SchemaValidator validator = new SchemaValidator();
            validator.ValidateLength("Test", 3, 10);
            validator.ValidateNotEmpty("Test");
            validator.ValidatePattern("Test", "^[a-zA-Z]+$");
            validator.ValidateEmail("test@example.com");
            validator.ValidateUrl("https://example.com");
            validator.ValidateDigitsOnly("12345");

            // Validate a string to see if it contains only alphabetic characters


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            bool isAlphabetic = validator.ValidatePattern("TestString", "^[a-zA-Z]+$");

SUFFIX CODE:
----------------------------------------
            bool isAlphabetic = validator.ValidatePattern("TestString", "^[a-zA-Z]+$");
            Debug.Assert(isAlphabetic, "The string should contain only alphabetic characters");

            List<string> errors = validator.GetErrors();
            Debug.Assert(errors.Count == 0, "There should be no validation errors");

            Console.WriteLine("All validations passed.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and continue a pattern of validation functions within a schema validator class. The established pattern involves using regular expressions to validate different types of input (length, non-empty, email, URL, digits). The golden completion requires the LLM to continue the pattern by adding another validation function that checks if a string contains only alphabetic characters. This tests the LLM's understanding of the pattern and its ability to maintain consistency in function structure and naming conventions. The suffix includes assertions to ensure the validation logic works correctly and that no errors are present.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace ScientificComputing
{
    public class DataAnalyzer
    {
        public List<double> Data { get; set; }

        public DataAnalyzer()
        {
            Data = new List<double>();
        }

        public void AddData(double value)
        {
            Data.Add(value);
        }

        public double CalculateMean()
        {
            if (Data.Count == 0) throw new InvalidOperationException("No data to calculate mean.");

            double sum = 0;
            foreach (var value in Data)
            {
                sum += value;
            }
            return sum / Data.Count;
        }

        public double CalculateVariance()
        {
            if (Data.Count == 0) throw new InvalidOperationException("No data to calculate variance.");

            double mean = CalculateMean();
            double varianceSum = 0;
            foreach (var value in Data)
            {
                varianceSum += Math.Pow(value - mean, 2);
            }
            return varianceSum / Data.Count;
        }

        // Pattern: Calculate standard deviation based on variance
        public double CalculateStandardDeviation()
        {
            double variance = CalculateVariance();
            return Math.Sqrt(variance);
        }

        // Pattern: Calculate median
        public double CalculateMedian()
        {
            if (Data.Count == 0) throw new InvalidOperationException("No data to calculate median.");

            Data.Sort();
            int midIndex = Data.Count / 2;
            if (Data.Count % 2 == 0)
            {
                return (Data[midIndex - 1] + Data[midIndex]) / 2;
            }
            else
            {
                return Data[midIndex];
            }
        }
        // Pattern: Calculate range


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
public double CalculateRange()
{
    if (Data.Count == 0) throw new InvalidOperationException("No data to calculate range.");

    double min = double.MaxValue;
    double max = double.MinValue;

    foreach (var value in Data)
    {
        if (value < min) min = value;
        if (value > max) max = value;
    }

    return max - min;
}

SUFFIX CODE:
----------------------------------------
        // Continuing the pattern: Calculate mode
        public double CalculateMode()
        {
            if (Data.Count == 0) throw new InvalidOperationException("No data to calculate mode.");

            var frequencyDict = new Dictionary<double, int>();
            foreach (var value in Data)
            {
                if (frequencyDict.ContainsKey(value))
                {
                    frequencyDict[value]++;
                }
                else
                {
                    frequencyDict[value] = 1;
                }
            }

            double mode = double.NaN;
            int maxFrequency = 0;
            foreach (var kvp in frequencyDict)
            {
                if (kvp.Value > maxFrequency)
                {
                    maxFrequency = kvp.Value;
                    mode = kvp.Key;
                }
            }

            Debug.Assert(!double.IsNaN(mode), "Mode should not be NaN if data exists.");
            return mode;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var analyzer = new DataAnalyzer();
            analyzer.AddData(1.0);
            analyzer.AddData(2.0);
            analyzer.AddData(2.0);
            analyzer.AddData(3.0);
            analyzer.AddData(4.0);

            // Assertions for CalculateStandardDeviation
            double stddev = analyzer.CalculateStandardDeviation();
            Debug.Assert(Math.Abs(stddev - 1.0954) < 0.0001, "Standard deviation calculation is incorrect.");

            // Assertions for CalculateMedian
            double median = analyzer.CalculateMedian();
            Debug.Assert(median == 2.0, "Median calculation is incorrect.");

            // Assertions for CalculateMode
            double mode = analyzer.CalculateMode();
            Debug.Assert(mode == 2.0, "Mode calculation is incorrect.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case checks the LLM's ability to recognize and complete patterns in C# code related to statistical computations. The pattern involves calculating various statistical measures (mean, variance, standard deviation, median) from a list of data points. The golden completion continues this pattern by implementing a method to calculate the range, a common statistical measure. The suffix continues with a different statistical measure (mode) and includes assertions to validate the correct implementation of these methods. This scenario is realistic in the context of scientific computing and data analysis.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Text;

namespace SecurityExample
{
    public class EncryptionHelper
    {
        // Encrypts a string using a simple reversible algorithm
        public string Encrypt(string data, string key)
        {
            if (string.IsNullOrEmpty(data)) throw new ArgumentNullException(nameof(data));
            if (string.IsNullOrEmpty(key)) throw new ArgumentNullException(nameof(key));

            var encrypted = new StringBuilder();
            for (int i = 0; i < data.Length; i++)
            {
                encrypted.Append((char)(data[i] ^ key[i % key.Length]));
            }
            return encrypted.ToString();
        }

        // Decrypts a string using a simple reversible algorithm
        public string Decrypt(string data, string key)
        {
            if (string.IsNullOrEmpty(data)) throw new ArgumentNullException(nameof(data));
            if (string.IsNullOrEmpty(key)) throw new ArgumentNullException(nameof(key));

            var decrypted = new StringBuilder();
            for (int i = 0; i < data.Length; i++)
            {
                decrypted.Append((char)(data[i] ^ key[i % key.Length]));
            }
            return decrypted.ToString();
        }

        // Hashes a string using a simple hash algorithm
        public string Hash(string data)
        {
            if (string.IsNullOrEmpty(data)) throw new ArgumentNullException(nameof(data));

            int hash = 0;
            for (int i = 0; i < data.Length; i++)
            {
                hash = (hash * 31) + data[i];
            }
            return hash.ToString("X");
        }

        // Verifies a hash against a string
        public bool VerifyHash(string data, string hash)
        {
            if (string.IsNullOrEmpty(data)) throw new ArgumentNullException(nameof(data));
            if (string.IsNullOrEmpty(hash)) throw new ArgumentNullException(nameof(hash));

            string computedHash = Hash(data);
            return computedHash.Equals(hash, StringComparison.OrdinalIgnoreCase);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var helper = new EncryptionHelper();
            string data = "HelloWorld";
            string key = "Key123";

            // Test encryption and decryption
            string encrypted = helper.Encrypt(data, key);
            Console.WriteLine($"Encrypted: {encrypted}");
            string decrypted = helper.Decrypt(encrypted, key);
            Console.WriteLine($"Decrypted: {decrypted}");
            Debug.Assert(decrypted == data, "Decryption failed");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            string hash = helper.Hash(data);

SUFFIX CODE:
----------------------------------------
            // Edge case: empty data
            try
            {
                helper.Encrypt("", key);
            }
            catch (ArgumentNullException ex)
            {
                Debug.Assert(ex.ParamName == "data", "Expected ArgumentNullException for data");
            }

            try
            {
                helper.Decrypt("", key);
            }
            catch (ArgumentNullException ex)
            {
                Debug.Assert(ex.ParamName == "data", "Expected ArgumentNullException for data");
            }

            try
            {
                helper.Hash("");
            }
            catch (ArgumentNullException ex)
            {
                Debug.Assert(ex.ParamName == "data", "Expected ArgumentNullException for data");
            }

            try
            {
                helper.VerifyHash("", hash);
            }
            catch (ArgumentNullException ex)
            {
                Debug.Assert(ex.ParamName == "data", "Expected ArgumentNullException for data");
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the pattern matching capabilities of the LLM by establishing a clear pattern in the encryption, decryption, and hashing methods. The prefix includes multiple examples of error handling and method calls that follow a specific sequence and logic. The completion must follow this pattern to ensure the code remains consistent and functional. The suffix includes assertions to verify the correctness of the pattern adherence and functionality.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

namespace SecurityExample
{
    public class EncryptionHelper
    {
        private static readonly byte[] Key = Encoding.UTF8.GetBytes("0123456789ABCDEF0123456789ABCDEF"); // 32 bytes key
        private static readonly byte[] IV = Encoding.UTF8.GetBytes("0123456789ABCDEF"); // 16 bytes IV

        // Encrypts the given plaintext using AES encryption
        public static string Encrypt(string plainText)
        {
            if (plainText == null)
                throw new ArgumentNullException(nameof(plainText));

            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;
                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);
                using (System.IO.MemoryStream msEncrypt = new System.IO.MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (System.IO.StreamWriter swEncrypt = new System.IO.StreamWriter(csEncrypt))
                        {
                            swEncrypt.Write(plainText);
                        }
                        return Convert.ToBase64String(msEncrypt.ToArray());
                    }
                }
            }
        }

        // Decrypts the given ciphertext using AES encryption
        public static string Decrypt(string cipherText)
        {
            if (cipherText == null)
                throw new ArgumentNullException(nameof(cipherText));

            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);
                using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(cipherText)))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))
                        {
                            return srDecrypt.ReadToEnd();
                        }
                    }
                }
            }
        }

        // Verifies the given plaintext and ciphertext match when decrypted
        public static bool Verify(string plainText, string cipherText)
        {
            string decryptedText = Decrypt(cipherText);
            return plainText == decryptedText;
        }

        // Example usage of the encryption and decryption methods
        public static void Main(string[] args)
        {
            string originalText = "Hello, World!";
            string encryptedText = Encrypt(originalText);
            

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
Debug.Assert(!string.IsNullOrEmpty(encryptedText), "Encrypted text should not be null or empty");

SUFFIX CODE:
----------------------------------------
Debug.Assert(!string.IsNullOrEmpty(encryptedText), "Encrypted text should not be null or empty");
            string decryptedText = Decrypt(encryptedText);
            Debug.Assert(originalText == decryptedText, "Decrypted text should match the original text");

            // Testing edge cases
            string emptyText = "";
            string encryptedEmptyText = Encrypt(emptyText);
            Debug.Assert(Decrypt(encryptedEmptyText) == emptyText, "Decrypted empty text should match the original empty text");

            string nullText = null;
            try
            {
                Encrypt(nullText);
                Debug.Assert(false, "Encrypting null text should throw ArgumentNullException");
            }
            catch (ArgumentNullException) { }

            try
            {
                Decrypt(nullText);
                Debug.Assert(false, "Decrypting null text should throw ArgumentNullException");
            }
            catch (ArgumentNullException) { }

            Console.WriteLine("All tests passed.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to follow a clear pattern in encryption and decryption methods within the context of security. The prefix provides a comprehensive setup for AES encryption and decryption, establishing a pattern of using Aes.Create, ICryptoTransform, MemoryStream, and CryptoStream for the operations. The golden completion continues this pattern by verifying the integrity of the encryption/decryption process using the Verify method. The suffix then includes further assertions and edge case handling, ensuring the entire encryption-decryption cycle is robust and adheres to the established pattern.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

namespace SecurityExample
{
    public class EncryptionHelper
    {
        private static readonly byte[] Key = Encoding.UTF8.GetBytes("0123456789abcdef");
        private static readonly byte[] IV = Encoding.UTF8.GetBytes("abcdef9876543210");

        public static string EncryptString(string plainText)
        {
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;

                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

                using (System.IO.MemoryStream msEncrypt = new System.IO.MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (System.IO.StreamWriter swEncrypt = new System.IO.StreamWriter(csEncrypt))
                        {
                            // Write all data to the stream.
                            swEncrypt.Write(plainText);
                        }
                        return Convert.ToBase64String(msEncrypt.ToArray());
                    }
                }
            }
        }

        public static string DecryptString(string cipherText)
        {
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;

                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

                using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(cipherText)))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))
                        {
                            // Read the decrypted bytes from the decrypting stream and place them in a string.
                            return srDecrypt.ReadToEnd();
                        }
                    }
                }
            }
        }

        public static bool VerifyEncryption(string originalText)
        {
            string encryptedText = EncryptString(originalText);
            string decryptedText = DecryptString(encryptedText);
            return originalText == decryptedText;
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            string testString = "Hello, World!";
            string encrypted = EncryptionHelper.EncryptString(testString);
            Console.WriteLine("Encrypted: " + encrypted);

            // Test pattern continuation for decryption and verification


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            string decrypted = EncryptionHelper.DecryptString(encrypted);

SUFFIX CODE:
----------------------------------------
            Console.WriteLine("Decrypted: " + decrypted);

            // Assertions
            Debug.Assert(decrypted == testString, "Decryption failed: decrypted text does not match original");
            Debug.Assert(EncryptionHelper.VerifyEncryption(testString), "Verification failed: encrypted and decrypted text do not match");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern in error handling and encryption/decryption routines. The prefix sets up a clear pattern of using AES for encryption and decryption with proper resource management. The golden completion continues this pattern by correctly decrypting the previously encrypted string. The suffix then contains assertions to verify that the decryption works as expected and matches the original text, ensuring the pattern is followed correctly. This scenario is practical and relevant to security in software development.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace NetworkProtocolExample
{
    public class MessageHandler
    {
        private readonly Queue<string> _messageQueue;
        private readonly object _lockObject = new object();

        public MessageHandler()
        {
            _messageQueue = new Queue<string>();
        }

        public void EnqueueMessage(string message)
        {
            lock (_lockObject)
            {
                _messageQueue.Enqueue(message);
                Debug.WriteLine($"Message Enqueued: {message}");
            }
        }

        public string DequeueMessage()
        {
            lock (_lockObject)
            {
                if (_messageQueue.Count > 0)
                {
                    string message = _messageQueue.Dequeue();
                    Debug.WriteLine($"Message Dequeued: {message}");
                    return message;
                }
                else
                {
                    throw new InvalidOperationException("No messages to dequeue.");
                }
            }
        }

        public int GetMessageCount()
        {
            lock (_lockObject)
            {
                return _messageQueue.Count;
            }
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        MessageHandler handler = new MessageHandler();
        handler.EnqueueMessage("Message 1");
        handler.EnqueueMessage("Message 2");
        handler.EnqueueMessage("Message 3");

        // Dequeue a message and assert the count
        string dequeuedMessage = handler.DequeueMessage();
        Debug.Assert(dequeuedMessage == "Message 1", "The dequeued message should be 'Message 1'");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
Debug.Assert(handler.GetMessageCount() == 2, "There should be two messages left in the queue.");

SUFFIX CODE:
----------------------------------------
        // Dequeue another message and assert the count
        dequeuedMessage = handler.DequeueMessage();
        Debug.Assert(dequeuedMessage == "Message 3", "The dequeued message should be 'Message 2'");

        // Check the count of messages remaining
        int remainingCount = handler.GetMessageCount();
        Debug.Assert(remainingCount == 1, "There should be one message left in the queue.");

        // Final dequeue and assert
        dequeuedMessage = handler.DequeueMessage();
        Debug.Assert(dequeuedMessage == "Message 3", "The dequeued message should be 'Message 3'");

        // Ensure no messages are left
        remainingCount = handler.GetMessageCount();
        Debug.Assert(remainingCount == 0, "There should be no messages left in the queue.");
    }
}


JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in C# because it demonstrates a common scenario in network protocols involving message queuing and synchronization. The pattern of locking, enqueuing, and dequeuing messages is clearly established. The golden completion must follow this established pattern by correctly handling message dequeueing and adhering to the locking mechanism. The suffix contains assertions that verify the correct order of messages and ensures the queue's state is as expected after operations, which helps validate the correctness of the pattern implementation.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace AnalyticsExample
{
    public class DataProcessor
    {
        private List<int> data;

        public DataProcessor(List<int> initialData)
        {
            data = initialData;
        }

        public int CalculateSum()
        {
            int sum = 0;
            foreach (var item in data)
            {
                sum += item;
            }
            return sum;
        }

        public double CalculateAverage()
        {
            int sum = CalculateSum();
            return (double)sum / data.Count;
        }

        public int FindMax()
        {
            int max = int.MinValue;
            foreach (var item in data)
            {
                if (item > max)
                {
                    max = item;
                }
            }
            return max;
        }

        public int FindMin()
        {
            int min = int.MaxValue;
            foreach (var item in data)
            {
                if (item < min)
                {
                    min = item;
                }
            }
            return min;
        }

        public int CountGreaterThan(int threshold)
        {
            int count = 0;
            foreach (var item in data)
            {
                if (item > threshold)
                {
                    count++;
                }
            }
            return count;
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        public int CountEqualTo(int threshold)
        {
            int count = 0;
            foreach (var item in data)
            {
                if (item == threshold)
                {
                    count++;
                }
            }
            return count;
        }

SUFFIX CODE:
----------------------------------------
        public int CountLessThan(int threshold)
        {
            int count = 0;
            foreach (var item in data)
            {
                if (item < threshold)
                {
                    count++;
                }
            }
            return count;
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            List<int> sampleData = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            DataProcessor processor = new DataProcessor(sampleData);

            Debug.Assert(processor.CountGreaterThan(5) == 5, "CountGreaterThan(5) should be 5");
            Debug.Assert(processor.CountLessThan(5) == 4, "CountLessThan(5) should be 4");
            Debug.Assert(processor.CountEqualTo(5) == 1, "CountEqualTo(5) should be 1");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in C# because it involves a common scenario in analytics where different methods are created to process data in various ways. The pattern of iterating over the list and applying a condition is clearly established in the prefix with multiple methods. The LLM needs to recognize this pattern and apply it correctly to complete the CountEqualTo method. The suffix contains assertions to ensure that the completion follows the established pattern and works correctly.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Net.Http;
using System.Threading.Tasks;

public class ApiClient
{
    private readonly HttpClient _httpClient;

    public ApiClient()
    {
        _httpClient = new HttpClient();
    }

    public async Task<string> GetDataAsync(string url)
    {
        try
        {
            HttpResponseMessage response = await _httpClient.GetAsync(url);
            response.EnsureSuccessStatusCode();
            string responseData = await response.Content.ReadAsStringAsync();
            return responseData;
        }
        catch (HttpRequestException e)
        {
            // Log exception
            Console.WriteLine($"Request error: {e.Message}");
            return string.Empty;
        }
    }

    public async Task<string> PostDataAsync(string url, HttpContent content)
    {
        try
        {
            HttpResponseMessage response = await _httpClient.PostAsync(url, content);
            response.EnsureSuccessStatusCode();
            string responseData = await response.Content.ReadAsStringAsync();
            return responseData;
        }
        catch (HttpRequestException e)
        {
            // Log exception
            Console.WriteLine($"Request error: {e.Message}");
            return string.Empty;
        }
    }

    public async Task<string> PutDataAsync(string url, HttpContent content)
    {
        try
        {
            HttpResponseMessage response = await _httpClient.PutAsync(url, content);
            response.EnsureSuccessStatusCode();
            string responseData = await response.Content.ReadAsStringAsync();
            return responseData;
        }
        catch (HttpRequestException e)
        {
            // Log exception
            Console.WriteLine($"Request error: {e.Message}");
            return string.Empty;
        }
    }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
    public async Task<string> DeleteDataAsync(string url)
    {
        try
        {
            HttpResponseMessage response = await _httpClient.DeleteAsync(url);
            response.EnsureSuccessStatusCode();
            string responseData = await response.Content.ReadAsStringAsync();
            Debug.Assert(responseData != null, "Response data should not be null");
            Debug.Assert(response.IsSuccessStatusCode, "Response should be successful");
            return responseData;
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine($"Request error: {e.Message}");
            Debug.Assert(false, "Exception should not be thrown");
            return string.Empty;
        }
    }

    public void Dispose()
    {
        _httpClient.Dispose();
    }
}

public class Program
{
    public static async Task Main(string[] args)
    {
        ApiClient apiClient = new ApiClient();
        string result = await apiClient.DeleteDataAsync("https://example.com/api/resource/1");
        Debug.Assert(result != null, "Result should not be null");
        apiClient.Dispose();
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue the pattern of error handling in HTTP methods within an API client class. The prefix establishes a clear pattern with multiple methods demonstrating consistent error handling and response processing. The golden completion is expected to follow this pattern, adding a new method for PATCH requests with the same structure and best practices. The suffix introduces a different method (DELETE) and includes assertions to verify behavior, ensuring the LLM maintains pattern adherence and functionality.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanics
{
    public enum EnemyType
    {
        Goblin,
        Orc,
        Dragon
    }

    public class Enemy
    {
        public EnemyType Type { get; set; }
        public int Health { get; set; }
        public int AttackPower { get; set; }

        public Enemy(EnemyType type, int health, int attackPower)
        {
            Type = type;
            Health = health;
            AttackPower = attackPower;
        }
    }

    public class GameState
    {
        private List<Enemy> _enemies;

        public GameState()
        {
            _enemies = new List<Enemy>();
        }

        public void AddEnemy(Enemy enemy)
        {
            _enemies.Add(enemy);
        }

        public void RemoveEnemy(Enemy enemy)
        {
            _enemies.Remove(enemy);
        }

        public Enemy FindStrongestEnemy()
        {
            Enemy strongest = null;
            foreach (var enemy in _enemies)
            {
                if (strongest == null || enemy.AttackPower > strongest.AttackPower)
                {
                    strongest = enemy;
                }
            }
            return strongest;
        }

        // Additional pattern of finding enemy by type
        public Enemy FindEnemyByType(EnemyType type)
        {
            foreach (var enemy in _enemies)
            {
                if (enemy.Type == type)
                {
                    return enemy;
                }
            }
            return null;
        }

        // Additional pattern of finding weakest enemy
        public Enemy FindWeakestEnemy()
        {
            Enemy weakest = null;
            foreach (var enemy in _enemies)
            {
                if (weakest == null || enemy.AttackPower < weakest.AttackPower)
                {
                    weakest = enemy;
                }
            }
            return weakest;
        }

        // More code related to game state management...


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        public int CountEnemiesOfType(EnemyType type)
        {
            int count = 0;
            foreach (var enemy in _enemies)
            {
                if (enemy.Type == type)
                {
                    count++;
                }
            }
            return count;
        }

SUFFIX CODE:
----------------------------------------
        public void TestGameState()
        {
            var gameState = new GameState();
            var goblin = new Enemy(EnemyType.Goblin, 30, 5);
            var orc = new Enemy(EnemyType.Orc, 50, 10);
            var dragon = new Enemy(EnemyType.Dragon, 100, 20);

            gameState.AddEnemy(goblin);
            gameState.AddEnemy(orc);
            gameState.AddEnemy(dragon);

            Debug.Assert(gameState.FindStrongestEnemy() == dragon, "Strongest enemy should be dragon.");
            Debug.Assert(gameState.FindEnemyByType(EnemyType.Orc) == orc, "Should find orc.");
            Debug.Assert(gameState.FindWeakestEnemy() == goblin, "Weakest enemy should be goblin.");
            Debug.Assert(gameState.CountEnemiesOfType(EnemyType.Goblin) == 1, "There should be one goblin.");
        }
    }
}

public class Program
{
    public static void Main()
    {
        var gameState = new GameMechanics.GameState();
        gameState.TestGameState();
    }
}

JUSTIFICATION:
----------------------------------------
This test case demonstrates the pattern of implementing methods to query a collection of enemies in a game state. The prefix establishes methods for finding the strongest, weakest, and enemies by type. The golden completion continues this pattern by adding a method to count enemies of a specific type. The suffix completes the example by adding assertions to validate the functionality and pattern adherence.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace NetworkProtocolExample
{
    public class MessageHandler
    {
        private readonly Queue<string> _messageQueue;
        private readonly object _lockObject;

        public MessageHandler()
        {
            _messageQueue = new Queue<string>();
            _lockObject = new object();
        }

        public void EnqueueMessage(string message)
        {
            lock (_lockObject)
            {
                _messageQueue.Enqueue(message);
                Debug.Assert(_messageQueue.Count > 0, "Message queue should have at least one message.");
            }
        }

        public string DequeueMessage()
        {
            lock (_lockObject)
            {
                if (_messageQueue.Count == 0)
                {
                    throw new InvalidOperationException("No messages to dequeue.");
                }
                string message = _messageQueue.Dequeue();
                Debug.Assert(message != null, "Dequeued message should not be null.");
                return message;
            }
        }

        public int GetQueueCount()
        {
            lock (_lockObject)
            {
                return _messageQueue.Count;
            }
        }

        public void ClearQueue()
        {
            lock (_lockObject)
            {
                _messageQueue.Clear();
                Debug.Assert(_messageQueue.Count == 0, "Message queue should be empty after clearing.");
            }
        }

        // BEGIN PATTERN: Methods interacting with _messageQueue and _lockObject


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        public string PeekMessage()
        {
            lock (_lockObject)
            {
                if (_messageQueue.Count == 0)
                {
                    throw new InvalidOperationException("No messages to peek.");
                }
                string message = _messageQueue.Peek();
                Debug.Assert(message != null, "Peeked message should not be null.");
                return message;
            }
        }

SUFFIX CODE:
----------------------------------------
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            MessageHandler handler = new MessageHandler();

            handler.EnqueueMessage("Test Message 1");
            handler.EnqueueMessage("Test Message 2");

            Debug.Assert(handler.GetQueueCount() == 2, "Queue count should be 2 after enqueuing two messages.");

            string dequeuedMessage = handler.DequeueMessage();
            Debug.Assert(dequeuedMessage == "Test Message 1", "First dequeued message should be 'Test Message 1'.");

            handler.PeekMessage(); // Should not throw

            handler.ClearQueue();
            Debug.Assert(handler.GetQueueCount() == 0, "Queue count should be 0 after clearing queue.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of thread-safe operations on a message queue. The pattern involves locking the _lockObject, performing operations on the _messageQueue, and using Debug.Assert statements to verify the operations' correctness. This is a realistic scenario in network protocols where thread-safety and message handling are critical. The golden completion follows the established pattern, and the suffix validates the pattern adherence with additional operations and assertions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace NetworkProtocolExample
{
    public class ApiClient
    {
        private readonly string baseUrl;

        public ApiClient(string baseUrl)
        {
            this.baseUrl = baseUrl;
        }

        public string GetResource(string endpoint)
        {
            try
            {
                // Simulate API call
                if (string.IsNullOrEmpty(endpoint))
                {
                    throw new ArgumentException("Endpoint cannot be null or empty.");
                }
                // Mock response for the sake of example
                return "{ \"data\": \"example\" }";
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($"Argument error: {ex.Message}");
                throw;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"General error: {ex.Message}");
                throw;
            }
        }

        public string PostResource(string endpoint, string payload)
        {
            try
            {
                // Simulate API call
                if (string.IsNullOrEmpty(endpoint))
                {
                    throw new ArgumentException("Endpoint cannot be null or empty.");
                }
                if (string.IsNullOrEmpty(payload))
                {
                    throw new ArgumentException("Payload cannot be null or empty.");
                }
                // Mock response for the sake of example
                return "{ \"status\": \"success\" }";
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($"Argument error: {ex.Message}");
                throw;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"General error: {ex.Message}");
                throw;
            }
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
        public void DeleteResource(string endpoint)
        {
            try
            {
                // Simulate API call
                if (string.IsNullOrEmpty(endpoint))
                {
                    throw new ArgumentException("Endpoint cannot be null or empty.");
                }
                // Mock success for the sake of example
                Console.WriteLine("Resource deleted successfully.");
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($"Argument error: {ex.Message}");
                throw;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"General error: {ex.Message}");
                throw;
            }
        }
    }

    public class Program
    {
        public static void Main()
        {
            ApiClient client = new ApiClient("https://api.example.com");
            string getResourceResult = client.GetResource("/resource");
            Debug.Assert(getResourceResult.Contains("example"), "GetResource should return example data");

            string postResourceResult = client.PostResource("/resource", "{ \"key\": \"value\" }");
            Debug.Assert(postResourceResult.Contains("success"), "PostResource should return success status");

            client.DeleteResource("/resource");
            // No return value to assert, just ensure no exception is thrown
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and complete a clear pattern in error handling within the context of network protocol operations, specifically API calls. The prefix establishes a consistent structure for handling errors in API methods (GetResource and PostResource), including specific exception types and general exceptions. The golden completion requires the LLM to extend this pattern to a new method (PutResource) with similar error handling. The suffix includes a different method (DeleteResource) to further demonstrate the pattern and includes assertions to verify functionality. This scenario is realistic, practical, and tests the LLM's ability to follow established error handling conventions in C#.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;

namespace NetworkProtocolExample
{
    public class ApiClient
    {
        private readonly string _baseUrl;

        public ApiClient(string baseUrl)
        {
            _baseUrl = baseUrl;
        }

        public async Task<string> GetDataAsync(string endpoint)
        {
            try
            {
                using (var client = new HttpClient())
                {
                    client.BaseAddress = new Uri(_baseUrl);
                    HttpResponseMessage response = await client.GetAsync(endpoint);
                    response.EnsureSuccessStatusCode();
                    string data = await response.Content.ReadAsStringAsync();
                    return data;
                }
            }
            catch (HttpRequestException e)
            {
                Debug.WriteLine($"Request error: {e.Message}");
                throw;
            }
        }

        public async Task<string> PostDataAsync(string endpoint, HttpContent content)
        {
            try
            {
                using (var client = new HttpClient())
                {
                    client.BaseAddress = new Uri(_baseUrl);
                    HttpResponseMessage response = await client.PostAsync(endpoint, content);
                    response.EnsureSuccessStatusCode();
                    string data = await response.Content.ReadAsStringAsync();
                    return data;
                }
            }
            catch (HttpRequestException e)
            {
                Debug.WriteLine($"Request error: {e.Message}");
                throw;
            }
        }
    }

    class Program
    {
        static async Task Main(string[] args)
        {
            var client = new ApiClient("https://api.example.com");
            string result;

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            result = await client.GetDataAsync("/data");

SUFFIX CODE:
----------------------------------------
            Debug.Assert(result != null, "Result should not be null");
            Debug.Assert(result.Contains("expectedValue"), "Result should contain 'expectedValue'");

            var postContent = new StringContent("{\"key\":\"value\"}", Encoding.UTF8, "application/json");
            string postResult = await client.PostDataAsync("/data", postContent);
            Debug.Assert(postResult != null, "Post result should not be null");
            Debug.Assert(postResult.Contains("success"), "Post result should contain 'success'");
        }
    }
}

JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in the context of network protocols and error handling. The pattern established in the prefix demonstrates how to properly handle HTTP GET and POST requests using async/await, including error handling and resource management. The golden completion continues this pattern by implementing another method call that follows the same structure. The suffix includes assertions to verify the correctness of the pattern continuation and ensures that the overall implementation adheres to best practices. This setup tests the LLM's ability to recognize and extend established patterns in a realistic and practical scenario.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace NetworkProtocolExample
{
    public class NetworkHandler
    {
        private Dictionary<int, string> _messageTypes;

        public NetworkHandler()
        {
            _messageTypes = new Dictionary<int, string>();
            InitializeMessageTypes();
        }

        private void InitializeMessageTypes()
        {
            _messageTypes.Add(100, "ConnectionRequest");
            _messageTypes.Add(101, "ConnectionResponse");
            _messageTypes.Add(102, "DataTransfer");
        }

        public string HandleMessage(int messageType, string message)
        {
            switch (messageType)
            {
                case 100:
                    return HandleConnectionRequest(message);
                case 101:
                    return HandleConnectionResponse(message);
                case 102:
                    return HandleDataTransfer(message);
                default:
                    throw new InvalidOperationException("Unknown message type");
            }
        }

        private string HandleConnectionRequest(string message)
        {
            // Simulate handling connection request
            return "ConnectionRequestHandled: " + message;
        }

        private string HandleConnectionResponse(string message)
        {
            // Simulate handling connection response
            return "ConnectionResponseHandled: " + message;
        }

        private string HandleDataTransfer(string message)
        {
            // Simulate handling data transfer
            return "DataTransferHandled: " + message;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            NetworkHandler handler = new NetworkHandler();
            string response;


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            response = handler.HandleMessage(100, "Connect");
            Debug.Assert(response == "ConnectionRequestHandled: Connect", "Expected handled message");

SUFFIX CODE:
----------------------------------------
            // Test with an unknown message type
            try
            {
                response = handler.HandleMessage(999, "TestMessage");
            }
            catch (InvalidOperationException ex)
            {
                Debug.Assert(ex.Message == "Unknown message type", "Expected exception message");
            }

            // Test with a known message type
            response = handler.HandleMessage(102, "FileTransfer");
            Debug.Assert(response == "DataTransferHandled: FileTransfer", "Expected handled message");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example demonstrates a clear pattern of handling different network message types based on their message codes. The prefix sets up a dictionary of message types and provides methods to handle each type. The golden completion follows this pattern by handling a known message type and verifying the response using assertions. The suffix continues this pattern by testing an unknown message type and another known message type, ensuring that the assertions verify correct behavior. This tests the LLM's ability to recognize and continue the established pattern of message handling in a network protocol context.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Collections.Generic;

namespace AnalyticsExample
{
    public class DataProcessor
    {
        private readonly List<double> _data;
        private readonly List<double> _smoothedData;

        public DataProcessor(List<double> data)
        {
            _data = data;
            _smoothedData = new List<double>();
        }

        public void ProcessData()
        {
            // Applying a simple moving average with a window size of 3
            for (int i = 0; i < _data.Count; i++)
            {
                double average = 0;
                int count = 0;

                for (int j = Math.Max(0, i - 1); j <= Math.Min(_data.Count - 1, i + 1); j++)
                {
                    average += _data[j];
                    count++;
                }

                average /= count;
                _smoothedData.Add(average);
            }
        }

        public List<double> GetSmoothedData()
        {
            return _smoothedData;
        }

        public double CalculateMean()
        {
            double sum = 0;
            foreach (var value in _smoothedData)
            {
                sum += value;
            }
            return sum / _smoothedData.Count;
        }

        public double CalculateVariance()
        {
            double mean = CalculateMean();
            double varianceSum = 0;
            foreach (var value in _smoothedData)
            {
                varianceSum += Math.Pow(value - mean, 2);
            }
            return varianceSum / _smoothedData.Count;
        }

        public double CalculateStandardDeviation()
        {
            double variance = CalculateVariance();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            return Math.Sqrt(variance);

SUFFIX CODE:
----------------------------------------
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            List<double> data = new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0 };
            DataProcessor processor = new DataProcessor(data);
            processor.ProcessData();
            List<double> smoothedData = processor.GetSmoothedData();

            Debug.Assert(smoothedData.Count == data.Count, "Smoothed data should have the same count as original data.");
            Debug.Assert(smoothedData[0] == 1.5, "Unexpected value in smoothed data.");
            Debug.Assert(smoothedData[1] == 2.0, "Unexpected value in smoothed data.");
            Debug.Assert(smoothedData[2] == 3.0, "Unexpected value in smoothed data.");
            Debug.Assert(smoothedData[3] == 4.0, "Unexpected value in smoothed data.");
            Debug.Assert(smoothedData[4] == 4.5, "Unexpected value in smoothed data.");

            double mean = processor.CalculateMean();
            Debug.Assert(Math.Abs(mean - 3.0) < 1e-9, "Mean calculation is incorrect.");

            double variance = processor.CalculateVariance();
            Debug.Assert(Math.Abs(variance - 1.25) < 1e-9, "Variance calculation is incorrect.");

            double stdDev = processor.CalculateStandardDeviation();
            Debug.Assert(Math.Abs(stdDev - Math.Sqrt(1.25)) < 1e-9, "Standard deviation calculation is incorrect.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case evaluates the ability to recognize and continue a pattern of statistical calculations in an analytics context. The prefix establishes the pattern of calculating statistical measures (mean, variance), and the golden_completion requires the model to complete the pattern by calculating the standard deviation. The suffix provides assertions to verify the correctness of the calculations. This scenario is realistic and tests the LLM's understanding of algorithm implementation and analytics.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

namespace SecurityExample
{
    public static class EncryptionHelper
    {
        public static string EncryptString(string plainText, string key)
        {
            byte[] iv = new byte[16];
            byte[] array;

            using (Aes aes = Aes.Create())
            {
                aes.Key = Encoding.UTF8.GetBytes(key);
                aes.IV = iv;

                ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

                using (System.IO.MemoryStream memoryStream = new System.IO.MemoryStream())
                {
                    using (CryptoStream cryptoStream = new CryptoStream((System.IO.Stream)memoryStream, encryptor, CryptoStreamMode.Write))
                    {
                        using (System.IO.StreamWriter streamWriter = new System.IO.StreamWriter((System.IO.Stream)cryptoStream))
                        {
                            streamWriter.Write(plainText);
                        }

                        array = memoryStream.ToArray();
                    }
                }
            }

            return Convert.ToBase64String(array);
        }

        public static string DecryptString(string cipherText, string key)
        {
            byte[] iv = new byte[16];
            byte[] buffer = Convert.FromBase64String(cipherText);

            using (Aes aes = Aes.Create())
            {
                aes.Key = Encoding.UTF8.GetBytes(key);
                aes.IV = iv;

                ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

                using (System.IO.MemoryStream memoryStream = new System.IO.MemoryStream(buffer))
                {
                    using (CryptoStream cryptoStream = new CryptoStream((System.IO.Stream)memoryStream, decryptor, CryptoStreamMode.Read))
                    {
                        using (System.IO.StreamReader streamReader = new System.IO.StreamReader((System.IO.Stream)cryptoStream))
                        {
                            return streamReader.ReadToEnd();
                        }
                    }
                }
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            string key = "A very complex key!";
            string original = "Sensitive data that needs encryption.";

            string encrypted = EncryptionHelper.EncryptString(original, key);
            Console.WriteLine($"Encrypted: {encrypted}");

            string decrypted = EncryptionHelper.DecryptString(encrypted, key);
            Console.WriteLine($"Decrypted: {decrypted}");

            Debug.Assert(decrypted == original, "Decryption did not return the original text.");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
            string anotherOriginal = "Another piece of sensitive data.";
            string anotherEncrypted = EncryptionHelper.EncryptString(anotherOriginal, key);
            Console.WriteLine($"Another Encrypted: {anotherEncrypted}");

            string anotherDecrypted = EncryptionHelper.DecryptString(anotherEncrypted, key);
            Console.WriteLine($"Another Decrypted: {anotherDecrypted}");

            Debug.Assert(anotherDecrypted == anotherOriginal, "Decryption did not return the original text.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in encryption and decryption functions, which are common in security-related programming. The pattern of creating and using an AES encryptor/decryptor, writing to and reading from a CryptoStream, and converting between byte arrays and strings is established clearly. The golden completion involves asserting that the encrypted text is different from the original, which is a logical and necessary assertion in encryption scenarios. The test case includes realistic encryption and decryption operations and appropriate assertions to validate the correctness of the operations.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;

namespace NetworkProtocolExample
{
    public class ApiClient
    {
        public string BaseUrl { get; set; }

        public ApiClient(string baseUrl)
        {
            BaseUrl = baseUrl;
        }

        public string Get(string endpoint)
        {
            try
            {
                // Simulate a network call
                return $"GET response from {BaseUrl}/{endpoint}";
            }
            catch (Exception ex)
            {
                // Log the exception (simplified for this example)
                Console.WriteLine($"Error during GET: {ex.Message}");
                throw;
            }
        }

        public string Post(string endpoint, string data)
        {
            try
            {
                // Simulate a network call
                return $"POST response from {BaseUrl}/{endpoint} with data {data}";
            }
            catch (Exception ex)
            {
                // Log the exception (simplified for this example)
                Console.WriteLine($"Error during POST: {ex.Message}");
                throw;
            }
        }

        // Implement a Put method following the established pattern


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        public string Put(string endpoint, string data)
        {
            try
            {
                // Simulate a network call
                return $"PUT response from {BaseUrl}/{endpoint} with data {data}";
            }
            catch (Exception ex)
            {
                // Log the exception (simplified for this example)
                Console.WriteLine($"Error during PUT: {ex.Message}");
                throw;
            }
        }

SUFFIX CODE:
----------------------------------------
        public string Delete(string endpoint)
        {
            try
            {
                // Simulate a network call
                return $"DELETE response from {BaseUrl}/{endpoint}";
            }
            catch (Exception ex)
            {
                // Log the exception (simplified for this example)
                Console.WriteLine($"Error during DELETE: {ex.Message}");
                throw;
            }
        }
    }

    class Program
    {
        static void Main()
        {
            ApiClient client = new ApiClient("http://example.com");
            string putResult = client.Put("resource", "data");
            Debug.Assert(putResult == "PUT response from http://example.com/resource with data data", "PUT method failed");

            string deleteResult = client.Delete("resource");
            Debug.Assert(deleteResult == "DELETE response from http://example.com/resource", "DELETE method failed");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case establishes a pattern of network protocol methods (GET, POST) that handle errors in a specific way within a class. The golden completion requires implementing the PUT method following the same pattern. The suffix adds a DELETE method and assertions to verify the PUT and DELETE methods' behavior. This scenario tests the LLM's ability to recognize and continue the error handling pattern consistently.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanics
{
    public enum AIState
    {
        Idle,
        Patrol,
        Chase,
        Attack
    }

    public class EnemyAI
    {
        private AIState _currentState;
        private Random _random;

        public EnemyAI()
        {
            _currentState = AIState.Idle;
            _random = new Random();
        }

        public void UpdateState()
        {
            switch (_currentState)
            {
                case AIState.Idle:
                    if (_random.NextDouble() < 0.5)
                    {
                        _currentState = AIState.Patrol;
                    }
                    break;
                case AIState.Patrol:
                    if (_random.NextDouble() < 0.3)
                    {
                        _currentState = AIState.Chase;
                    }
                    break;
                case AIState.Chase:
                    if (_random.NextDouble() < 0.2)
                    {
                        _currentState = AIState.Attack;
                    }
                    break;
                case AIState.Attack:
                    if (_random.NextDouble() < 0.1)
                    {
                        _currentState = AIState.Idle;
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public AIState GetCurrentState()
        {
            return _currentState;
        }
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        EnemyAI enemy = new EnemyAI();
        enemy.UpdateState();
        AIState state1 = enemy.GetCurrentState();
        Debug.Assert(state1 != AIState.Idle, "State should not be Idle after first update");



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        AIState state2 = enemy.GetCurrentState();

SUFFIX CODE:
----------------------------------------
        enemy.UpdateState();
        AIState state3 = enemy.GetCurrentState();
        Debug.Assert(state3 != state2, "State should change again after update");

        enemy.UpdateState();
        AIState state4 = enemy.GetCurrentState();
        Debug.Assert(state4 != state3, "State should change yet again after update");
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates a state machine pattern within the context of game mechanics. The `EnemyAI` class manages different AI states (Idle, Patrol, Chase, Attack) and transitions between these states based on random probabilities. The `UpdateState` method updates the state, and the pattern is to call `UpdateState` and then verify that the state has changed using assertions. This pattern is established in the prefix and the golden completion. The suffix continues this pattern and includes assertions to verify that the state changes after each update. This scenario tests the LLM's ability to recognize and complete the state transition pattern correctly.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace NetworkProtocolExample
{
    public class NetworkHandler
    {
        private Dictionary<string, string> _apiResponses;

        public NetworkHandler()
        {
            _apiResponses = new Dictionary<string, string>();
        }

        public void AddApiResponse(string endpoint, string response)
        {
            if (string.IsNullOrEmpty(endpoint))
            {
                throw new ArgumentException("Endpoint cannot be null or empty", nameof(endpoint));
            }
            if (response == null)
            {
                throw new ArgumentNullException(nameof(response), "Response cannot be null");
            }
            _apiResponses[endpoint] = response;
        }

        public string GetApiResponse(string endpoint)
        {
            if (string.IsNullOrEmpty(endpoint))
            {
                throw new ArgumentException("Endpoint cannot be null or empty", nameof(endpoint));
            }

            if (_apiResponses.TryGetValue(endpoint, out var response))
            {
                return response;
            }
            else
            {
                throw new KeyNotFoundException("Endpoint not found");
            }
        }

        public void RemoveApiResponse(string endpoint)
        {
            if (string.IsNullOrEmpty(endpoint))
            {
                throw new ArgumentException("Endpoint cannot be null or empty", nameof(endpoint));
            }

            if (!_apiResponses.Remove(endpoint))
            {
                throw new KeyNotFoundException("Endpoint not found");
            }
        }

        // Begin a new method following the same error handling pattern
        public void UpdateApiResponse(string endpoint, string newResponse)
        {
            if (string.IsNullOrEmpty(endpoint))
            {
                throw new ArgumentException("Endpoint cannot be null or empty", nameof(endpoint));
            }
            if (newResponse == null)
            {
                throw new ArgumentNullException(nameof(newResponse), "Response cannot be null");
            }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            if (!_apiResponses.ContainsKey(endpoint))
            {
                throw new KeyNotFoundException("Endpoint not found");
            }

SUFFIX CODE:
----------------------------------------
            _apiResponses[endpoint] = newResponse;
        }

        public static void Main(string[] args)
        {
            NetworkHandler handler = new NetworkHandler();

            handler.AddApiResponse("/test", "Test response");
            Debug.Assert(handler.GetApiResponse("/test") == "Test response", "AddApiResponse or GetApiResponse failed");

            handler.UpdateApiResponse("/test", "Updated response");
            Debug.Assert(handler.GetApiResponse("/test") == "Updated response", "UpdateApiResponse failed");

            handler.RemoveApiResponse("/test");
            try
            {
                handler.GetApiResponse("/test");
                Debug.Assert(false, "Expected KeyNotFoundException was not thrown");
            }
            catch (KeyNotFoundException)
            {
                Debug.Assert(true);
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example provides a good test case for pattern matching in error handling within a network protocol context. The pattern of argument validation and exception handling is clearly established in the prefix. The golden completion requires the LLM to continue this pattern by adding similar validation and exception handling for the new UpdateApiResponse method. The suffix includes different code that follows after the completion, including assertions to verify the correctness of the implemented pattern. This scenario is realistic and tests the LLM's ability to recognize and adhere to established C# error handling conventions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

public class EncryptionService
{
    private readonly Aes _aes;

    public EncryptionService()
    {
        _aes = Aes.Create();
        _aes.KeySize = 256;
        _aes.BlockSize = 128;
        _aes.Padding = PaddingMode.PKCS7;
    }

    public string Encrypt(string plainText, byte[] key, byte[] iv)
    {
        if (string.IsNullOrEmpty(plainText)) throw new ArgumentNullException(nameof(plainText));
        if (key == null || key.Length == 0) throw new ArgumentNullException(nameof(key));
        if (iv == null || iv.Length == 0) throw new ArgumentNullException(nameof(iv));

        byte[] encrypted;
        using (var encryptor = _aes.CreateEncryptor(key, iv))
        {
            using (var ms = new System.IO.MemoryStream())
            {
                using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                {
                    using (var sw = new System.IO.StreamWriter(cs))
                    {
                        sw.Write(plainText);
                    }
                    encrypted = ms.ToArray();
                }
            }
        }
        return Convert.ToBase64String(encrypted);
    }

    public string Decrypt(string cipherText, byte[] key, byte[] iv)
    {
        if (string.IsNullOrEmpty(cipherText)) throw new ArgumentNullException(nameof(cipherText));
        if (key == null || key.Length == 0) throw new ArgumentNullException(nameof(key));
        if (iv == null || iv.Length == 0) throw new ArgumentNullException(nameof(iv));

        byte[] buffer = Convert.FromBase64String(cipherText);
        using (var decryptor = _aes.CreateDecryptor(key, iv))
        {
            using (var ms = new System.IO.MemoryStream(buffer))
            {
                using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                {
                    using (var sr = new System.IO.StreamReader(cs))
                    {
                        return sr.ReadToEnd();
                    }
                }
            }
        }
    }

    public void Dispose()
    {
        if (_aes != null)
        {
            _aes.Dispose();
        }
    }

    // Additional method to generate random key and IV
    public static (byte[] key, byte[] iv) GenerateKeyAndIV()
    {
        using (var aes = Aes.Create())
        {
            aes.KeySize = 256;
            aes.BlockSize = 128;
            aes.GenerateKey();
            aes.GenerateIV();
            return (aes.Key, aes.IV);
        }
    }
}

public class Program
{
    public static void Main()
    {
        var service = new EncryptionService();
        var (key, iv) = EncryptionService.GenerateKeyAndIV();
        string plainText = "Hello, World!";


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        string cipherText = service.Encrypt(plainText, key, iv);

SUFFIX CODE:
----------------------------------------
        string decryptedText = service.Decrypt(cipherText, key, iv);
        Debug.Assert(decryptedText == plainText, "Decrypted text does not match the original");

        service.Dispose();
    }
}


JUSTIFICATION:
----------------------------------------
This example is a good test case for pattern matching because it establishes a clear pattern of encryption and decryption operations with proper error handling and resource management within the EncryptionService class. The prefix sets up the encryption service, including the key and IV generation, and shows part of the encryption process. The golden completion continues this pattern by completing the encryption operation. The suffix then verifies the integrity of the decrypted text against the original plain text using assertions, ensuring the pattern is followed correctly. This scenario tests the LLM's ability to recognize and continue the encryption-decryption pattern within a security context, making it a realistic and practical example.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace SynthBench.PatternMatching
{
    public class NetworkMessageHandler
    {
        private readonly Queue<string> _messageQueue;
        private readonly object _lockObject;

        public NetworkMessageHandler()
        {
            _messageQueue = new Queue<string>();
            _lockObject = new object();
        }

        // Method to enqueue a message safely
        public void EnqueueMessage(string message)
        {
            lock (_lockObject)
            {
                _messageQueue.Enqueue(message);
                Debug.WriteLine("Message enqueued: " + message);
            }
        }

        // Method to dequeue a message safely
        public string DequeueMessage()
        {
            lock (_lockObject)
            {
                if (_messageQueue.Count > 0)
                {
                    string message = _messageQueue.Dequeue();
                    Debug.WriteLine("Message dequeued: " + message);
                    return message;
                }
                else
                {
                    Debug.WriteLine("No message to dequeue.");
                    return null;
                }
            }
        }

        // Method to peek at the next message safely
        public string PeekMessage()
        {
            lock (_lockObject)
            {
                if (_messageQueue.Count > 0)
                {
                    string message = _messageQueue.Peek();
                    Debug.WriteLine("Message peeked: " + message);
                    return message;
                }
                else
                {
                    Debug.WriteLine("No message to peek.");
                    return null;
                }
            }
        }

        // Method to check if there are any messages in the queue
        public bool HasMessages()
        {
            lock (_lockObject)
            {
                return _messageQueue.Count > 0;
            }
        }

        // Method to clear all messages safely
        public void ClearMessages()
        {
            lock (_lockObject)
            {
                _messageQueue.Clear();
                Debug.WriteLine("All messages cleared.");
            }
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        // Method to get the current count of messages safely
        public int GetMessageCount()
        {
            lock (_lockObject)
            {
                return _messageQueue.Count;
            }
        }

SUFFIX CODE:
----------------------------------------
    }

    public class Program
    {
        public static void Main()
        {
            NetworkMessageHandler handler = new NetworkMessageHandler();
            handler.EnqueueMessage("First Message");
            handler.EnqueueMessage("Second Message");

            Debug.Assert(handler.GetMessageCount() == 2, "Message count should be 2");
            Debug.Assert(handler.HasMessages(), "There should be messages in the queue");

            string dequeuedMessage = handler.DequeueMessage();
            Debug.Assert(dequeuedMessage == "First Message", "Dequeued message should be 'First Message'");

            string peekedMessage = handler.PeekMessage();
            Debug.Assert(peekedMessage == "Second Message", "Peeked message should be 'Second Message'");

            handler.ClearMessages();
            Debug.Assert(handler.GetMessageCount() == 0, "Message count should be 0 after clearing");
            Debug.Assert(!handler.HasMessages(), "There should be no messages in the queue after clearing");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is a good example of testing pattern matching capabilities because it involves a clear and repetitive pattern of thread-safe operations on a message queue within a network message handler class. The pattern is established through multiple synchronized methods (using lock statements) that perform common queue operations like enqueue, dequeue, peek, and clear. The golden completion requires the LLM to recognize this pattern and correctly continue it by adding a new method that adheres to the established thread-safe pattern. The suffix includes assertions that test the functionality and ensure the pattern is followed correctly.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;

public class DataEncryptor
{
    private readonly Aes aes;

    public DataEncryptor()
    {
        aes = Aes.Create();
        aes.KeySize = 256;
        aes.BlockSize = 128;
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;
    }

    public byte[] EncryptData(string plainText)
    {
        if (string.IsNullOrEmpty(plainText))
            throw new ArgumentNullException(nameof(plainText));

        ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

        using (var ms = new System.IO.MemoryStream())
        using (var cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
        using (var sw = new System.IO.StreamWriter(cs))
        {
            sw.Write(plainText);
            sw.Close();
            return ms.ToArray();
        }
    }

    public string DecryptData(byte[] cipherText)
    {
        if (cipherText == null || cipherText.Length == 0)
            throw new ArgumentNullException(nameof(cipherText));

        ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

        using (var ms = new System.IO.MemoryStream(cipherText))
        using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
        using (var sr = new System.IO.StreamReader(cs))
        {
            return sr.ReadToEnd();
        }
    }
}

public class Program
{
    public static void Main()
    {
        DataEncryptor encryptor = new DataEncryptor();
        string original = "Hello World!";
        byte[] encrypted = encryptor.EncryptData(original);
        string decrypted = encryptor.DecryptData(encrypted);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        Debug.Assert(decrypted == original, "Decryption failed for original");

SUFFIX CODE:
----------------------------------------
        string original2 = "Another Test String";
        byte[] encrypted2 = encryptor.EncryptData(original2);
        string decrypted2 = encryptor.DecryptData(encrypted2);
        Debug.Assert(decrypted2 == original2, "Decryption failed for original2");
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize the pattern of encryption and decryption using the Aes class in C#. The established pattern includes creating an encryptor or decryptor, using MemoryStream and CryptoStream for processing, and asserting the correctness of the decrypted data. The golden completion follows this pattern by asserting the correctness of the decryption. The suffix continues the pattern with a different string to validate the robustness of the implementation.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

namespace SecurityExample
{
    public class EncryptionHelper
    {
        private readonly Aes _aes;

        public EncryptionHelper()
        {
            _aes = Aes.Create();
            _aes.Key = Encoding.UTF8.GetBytes("12345678901234567890123456789012"); // 32 bytes for AES-256
            _aes.IV = Encoding.UTF8.GetBytes("1234567890123456"); // 16 bytes for AES
        }

        public string Encrypt(string plainText)
        {
            if (string.IsNullOrEmpty(plainText))
                throw new ArgumentException("Plaintext cannot be null or empty.", nameof(plainText));

            using (var encryptor = _aes.CreateEncryptor(_aes.Key, _aes.IV))
            {
                byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);
                byte[] encryptedBytes = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);
                return Convert.ToBase64String(encryptedBytes);
            }
        }

        public string Decrypt(string encryptedText)
        {
            if (string.IsNullOrEmpty(encryptedText))
                throw new ArgumentException("Encrypted text cannot be null or empty.", nameof(encryptedText));

            using (var decryptor = _aes.CreateDecryptor(_aes.Key, _aes.IV))
            {
                byte[] encryptedBytes = Convert.FromBase64String(encryptedText);
                byte[] decryptedBytes = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
                return Encoding.UTF8.GetString(decryptedBytes);
            }
        }

        public void Dispose()
        {
            _aes?.Dispose();
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var encryptionHelper = new EncryptionHelper();
            string plainText = "Hello, World!";
            string encryptedText = encryptionHelper.Encrypt(plainText);
            Console.WriteLine($"Encrypted: {encryptedText}");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            string decryptedText = encryptionHelper.Decrypt(encryptedText);
            Console.WriteLine($"Decrypted: {decryptedText}");

SUFFIX CODE:
----------------------------------------


            Debug.Assert(decryptedText == plainText, "Decrypted text should match the original plain text.");

            encryptionHelper.Dispose();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern in error handling and encryption within a security context. The prefix establishes a pattern of AES encryption and decryption with proper error handling. The golden completion is a continuation of this pattern, demonstrating decryption and output of the decrypted text. The suffix includes assertions to verify the correctness of the decryption process and ensures proper resource cleanup. This is a good test case as it involves realistic, practical scenarios that developers encounter when handling encryption and decryption tasks.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace NetworkProtocolExample
{
    public class ApiClient
    {
        private readonly string _baseUrl;

        public ApiClient(string baseUrl)
        {
            _baseUrl = baseUrl;
        }

        public async Task<string> GetAsync(string endpoint)
        {
            try
            {
                using (var client = new HttpClient())
                {
                    client.BaseAddress = new Uri(_baseUrl);
                    var response = await client.GetAsync(endpoint);
                    response.EnsureSuccessStatusCode();
                    return await response.Content.ReadAsStringAsync();
                }
            }
            catch (HttpRequestException e)
            {
                // Log and handle the exception
                Console.WriteLine($"Request error: {e.Message}");
                return null;
            }
        }

        public async Task<string> PostAsync(string endpoint, HttpContent content)
        {
            try
            {
                using (var client = new HttpClient())
                {
                    client.BaseAddress = new Uri(_baseUrl);
                    var response = await client.PostAsync(endpoint, content);
                    response.EnsureSuccessStatusCode();
                    return await response.Content.ReadAsStringAsync();
                }
            }
            catch (HttpRequestException e)
            {
                // Log and handle the exception
                Console.WriteLine($"Request error: {e.Message}");
                return null;
            }
        }

        public async Task<string> PutAsync(string endpoint, HttpContent content)
        {

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            try
            {
                using (var client = new HttpClient())
                {
                    client.BaseAddress = new Uri(_baseUrl);
                    var response = await client.PutAsync(endpoint, content);
                    response.EnsureSuccessStatusCode();
                    return await response.Content.ReadAsStringAsync();
                }
            }
            catch (HttpRequestException e)
            {
                Console.WriteLine($"Request error: {e.Message}");
                return null;
            }

SUFFIX CODE:
----------------------------------------

        }

        public async Task<string> DeleteAsync(string endpoint)
        {
            try
            {
                using (var client = new HttpClient())
                {
                    client.BaseAddress = new Uri(_baseUrl);
                    var response = await client.DeleteAsync(endpoint);
                    response.EnsureSuccessStatusCode();
                    return await response.Content.ReadAsStringAsync();
                }
            }
            catch (HttpRequestException e)
            {
                // Log and handle the exception
                Console.WriteLine($"Request error: {e.Message}");
                return null;
            }
        }

        public static void Main(string[] args)
        {
            var apiClient = new ApiClient("https://api.example.com");

            var getTask = apiClient.GetAsync("/get-endpoint");
            getTask.Wait();
            Debug.Assert(getTask.Result != null, "GET request failed");

            var postTask = apiClient.PostAsync("/post-endpoint", new StringContent("{\"key\":\"value\"}", System.Text.Encoding.UTF8, "application/json"));
            postTask.Wait();
            Debug.Assert(postTask.Result != null, "POST request failed");

            var putTask = apiClient.PutAsync("/put-endpoint", new StringContent("{\"key\":\"value\"}", System.Text.Encoding.UTF8, "application/json"));
            putTask.Wait();
            Debug.Assert(putTask.Result != null, "PUT request failed");

            var deleteTask = apiClient.DeleteAsync("/delete-endpoint");
            deleteTask.Wait();
            Debug.Assert(deleteTask.Result != null, "DELETE request failed");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a common pattern in network protocol implementations, specifically for handling different HTTP methods (GET, POST, PUT, DELETE) with proper error handling. The prefix establishes a clear pattern for asynchronous HTTP operations with error handling, and the golden completion continues this pattern by implementing the PUT method. The suffix includes assertions to verify that each method works correctly and ensures that resources are properly managed.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Collections.Generic;

namespace ToolAutomation
{
    public class DeploymentManager
    {
        private Dictionary<string, string> _services;

        public DeploymentManager()
        {
            _services = new Dictionary<string, string>();
        }

        public void AddService(string name, string version)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("Service name cannot be null or empty");
            }
            if (string.IsNullOrEmpty(version))
            {
                throw new ArgumentException("Service version cannot be null or empty");
            }
            _services[name] = version;
        }

        public void RemoveService(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("Service name cannot be null or empty");
            }
            if (!_services.ContainsKey(name))
            {
                throw new KeyNotFoundException("Service not found");
            }
            _services.Remove(name);
        }

        public string GetServiceVersion(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("Service name cannot be null or empty");
            }
            if (!_services.ContainsKey(name))
            {
                throw new KeyNotFoundException("Service not found");
            }
            return _services[name];
        }

        public List<string> ListServices()
        {
            return new List<string>(_services.Keys);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            DeploymentManager manager = new DeploymentManager();
            manager.AddService("ServiceA", "1.0");
            manager.AddService("ServiceB", "1.1");
            manager.AddService("ServiceC", "2.0");

            try
            {
                string versionA = manager.GetServiceVersion("ServiceA");
                Debug.Assert(versionA == "1.0", "ServiceA version should be 1.0");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
                string versionB = manager.GetServiceVersion("ServiceB");

SUFFIX CODE:
----------------------------------------
                string versionB = manager.GetServiceVersion("ServiceB");
                Debug.Assert(versionB == "1.1", "ServiceB version should be 1.1");

                List<string> services = manager.ListServices();
                Debug.Assert(services.Count == 3, "There should be 3 services listed");
                Debug.Assert(services.Contains("ServiceA"), "ServiceA should be listed");
                Debug.Assert(services.Contains("ServiceB"), "ServiceB should be listed");
                Debug.Assert(services.Contains("ServiceC"), "ServiceC should be listed");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

            try
            {
                manager.RemoveService("ServiceA");
                List<string> servicesAfterRemoval = manager.ListServices();
                Debug.Assert(servicesAfterRemoval.Count == 2, "There should be 2 services listed after removal");
                Debug.Assert(!servicesAfterRemoval.Contains("ServiceA"), "ServiceA should not be listed after removal");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case demonstrates a common pattern in tool automation involving error handling and service management. The prefix establishes a pattern of adding services with checks, and retrieving service versions with error handling. The golden completion continues this pattern by retrieving and asserting the version of a specific service. The suffix then tests additional functionality by listing services and removing a service, ensuring the pattern of error handling and validation is consistently applied. The combined code ensures proper error handling, resource management, and assertion placement, making it a robust test case for an LLM's pattern matching capabilities.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace PatternMatchingExample
{
    public class NetworkProtocolHandler
    {
        private Dictionary<string, string> dataStore;

        public NetworkProtocolHandler()
        {
            dataStore = new Dictionary<string, string>();
        }

        public bool StoreData(string key, string value)
        {
            if (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(value))
            {
                return false;
            }
            try
            {
                dataStore.Add(key, value);
                return true;
            }
            catch (ArgumentException ex)
            {
                Debug.WriteLine($"Error storing data: {ex.Message}");
                return false;
            }
        }

        public string RetrieveData(string key)
        {
            if (string.IsNullOrEmpty(key))
            {
                return null;
            }
            try
            {
                return dataStore[key];
            }
            catch (KeyNotFoundException ex)
            {
                Debug.WriteLine($"Error retrieving data: {ex.Message}");
                return null;
            }
        }

        public bool DeleteData(string key)
        {
            if (string.IsNullOrEmpty(key))
            {
                return false;
            }
            try
            {
                return dataStore.Remove(key);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error deleting data: {ex.Message}");
                return false;
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            NetworkProtocolHandler handler = new NetworkProtocolHandler();

            // Test storing data
            bool storeSuccess = handler.StoreData("key1", "value1");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            Debug.Assert(storeSuccess, "StoreData should return true for valid key and value");

SUFFIX CODE:
----------------------------------------
            Debug.Assert(storeSuccess, "StoreData should return true for valid key and value");

            // Test retrieving data
            string value = handler.RetrieveData("key1");
            Debug.Assert(value == "value1", "RetrieveData should return the correct value for a given key");

            // Test deleting data
            bool deleteSuccess = handler.DeleteData("key1");
            Debug.Assert(deleteSuccess, "DeleteData should return true for a valid key");

            // Test retrieving deleted data
            value = handler.RetrieveData("key1");
            Debug.Assert(value == null, "RetrieveData should return null for a deleted key");

            // Test error handling for non-existent key
            value = handler.RetrieveData("nonexistent");
            Debug.Assert(value == null, "RetrieveData should return null for a non-existent key");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern in error handling within a network protocol handler context. The prefix establishes clear patterns for error checking and exception handling in methods for storing, retrieving, and deleting data. The golden completion and suffix verify the LLM's capability to complete these patterns accurately, ensuring the correct handling of both valid and invalid inputs, as well as proper exception management.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanicsExample
{
    public class StateMachine
    {
        private enum State
        {
            Idle,
            Moving,
            Attacking,
            Defending
        }

        private State currentState;

        public StateMachine()
        {
            currentState = State.Idle;
        }

        public void ChangeState(State newState)
        {
            switch (newState)
            {
                case State.Idle:
                    EnterIdleState();
                    break;
                case State.Moving:
                    EnterMovingState();
                    break;
                case State.Attacking:
                    EnterAttackingState();
                    break;
                case State.Defending:
                    EnterDefendingState();
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(newState), newState, null);
            }
            currentState = newState;
        }

        private void EnterIdleState()
        {
            Console.WriteLine("Entering Idle State");
        }

        private void EnterMovingState()
        {
            Console.WriteLine("Entering Moving State");
        }

        private void EnterAttackingState()
        {
            Console.WriteLine("Entering Attacking State");
        }

        private void EnterDefendingState()
        {
            Console.WriteLine("Entering Defending State");
        }

        public void Update()
        {
            switch (currentState)
            {
                case State.Idle:
                    UpdateIdleState();
                    break;
                case State.Moving:
                    UpdateMovingState();
                    break;
                case State.Attacking:
                    UpdateAttackingState();
                    break;
                case State.Defending:
                    UpdateDefendingState();
                    break;
            }
        }

        private void UpdateIdleState()
        {
            Console.WriteLine("Updating Idle State");
        }

        private void UpdateMovingState()
        {
            Console.WriteLine("Updating Moving State");
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        private void UpdateAttackingState()
        {
            Console.WriteLine("Updating Attacking State");
        }

SUFFIX CODE:
----------------------------------------
        private void UpdateDefendingState()
        {
            Console.WriteLine("Updating Defending State");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            StateMachine stateMachine = new StateMachine();
            stateMachine.ChangeState(StateMachine.State.Idle);
            Debug.Assert(stateMachine != null, "StateMachine instance is null");

            stateMachine.ChangeState(StateMachine.State.Moving);
            Debug.Assert(stateMachine != null, "StateMachine instance is null");

            stateMachine.ChangeState(StateMachine.State.Attacking);
            Debug.Assert(stateMachine != null, "StateMachine instance is null");

            stateMachine.ChangeState(StateMachine.State.Defending);
            Debug.Assert(stateMachine != null, "StateMachine instance is null");

            stateMachine.Update();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern in a state machine implementation, which is common in game mechanics. The pattern involves defining methods for entering and updating various states. The golden completion continues this pattern by adding the 'UpdateAttackingState' method, which matches the structure and naming conventions of the other update methods. The suffix includes assertions to verify that the state machine transitions correctly and the state machine instance is not null.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Threading.Tasks;

namespace NetworkProtocolExample {
    public class AsyncApiHandler {
        public async Task<string> SendRequestAsync(string url) {
            try {
                // Simulate sending a request
                await Task.Delay(1000);
                // Simulate a successful response
                return "Response from " + url;
            } catch (Exception ex) {
                Debug.WriteLine($"Error: {ex.Message}");
                throw;
            }
        }

        public async Task<string> FetchDataAsync(string endpoint) {
            try {
                // Simulate fetching data
                await Task.Delay(1000);
                // Simulate a successful data retrieval
                return "Data from " + endpoint;
            } catch (Exception ex) {
                Debug.WriteLine($"Error: {ex.Message}");
                throw;
            }
        }

        public async Task<string> PostDataAsync(string endpoint, string data) {
            try {
                // Simulate posting data
                await Task.Delay(1000);
                // Simulate a successful post
                return "Posted data to " + endpoint;
            } catch (Exception ex) {
                Debug.WriteLine($"Error: {ex.Message}");
                throw;
            }
        }

        // Method to be completed
        public async Task<string> DeleteDataAsync(string endpoint) {
            try {
                // Simulate deleting data
                await Task.Delay(1000);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
                return "Deleted data from " + endpoint;

SUFFIX CODE:
----------------------------------------
                Debug.Assert(false, "This line should never be reached");
            } catch (Exception ex) {
                Debug.WriteLine($"Error: {ex.Message}");
                Debug.Assert(ex != null, "Exception should not be null");
                throw;
            }
        }
    }

    public class Program {
        public static async Task Main(string[] args) {
            var apiHandler = new AsyncApiHandler();

            var response = await apiHandler.SendRequestAsync("https://example.com");
            Debug.Assert(response == "Response from https://example.com", "SendRequestAsync failed");

            var data = await apiHandler.FetchDataAsync("/data");
            Debug.Assert(data == "Data from /data", "FetchDataAsync failed");

            var postData = await apiHandler.PostDataAsync("/post", "some data");
            Debug.Assert(postData == "Posted data to /post", "PostDataAsync failed");

            var deleteResponse = await apiHandler.DeleteDataAsync("/delete");
            Debug.Assert(deleteResponse == "Deleted data from /delete", "DeleteDataAsync failed");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of async API methods with proper error handling in a network protocol context. The pattern involves performing an async operation, handling exceptions, and returning a result string. The golden_completion requires the LLM to generate code that conforms to this established pattern, ensuring consistency and proper functionality.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanics
{
    public enum AIState
    {
        Idle,
        Patrolling,
        Chasing,
        Attacking
    }

    public class AIController
    {
        private AIState currentState;
        private int health;
        private int detectionRange;

        public AIController(int initialHealth, int detectionRange)
        {
            this.health = initialHealth;
            this.detectionRange = detectionRange;
            this.currentState = AIState.Idle;
        }

        public void UpdateState(int playerDistance, bool playerInSight)
        {
            switch (currentState)
            {
                case AIState.Idle:
                    if (playerInSight && playerDistance <= detectionRange)
                    {
                        TransitionToState(AIState.Chasing);
                    }
                    break;
                case AIState.Patrolling:
                    if (playerInSight && playerDistance <= detectionRange)
                    {
                        TransitionToState(AIState.Chasing);
                    }
                    else if (!playerInSight)
                    {
                        TransitionToState(AIState.Idle);
                    }
                    break;


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
                case AIState.Chasing:
                    if (playerDistance <= detectionRange / 2 && playerInSight)
                    {
                        TransitionToState(AIState.Attacking);
                    }
                    else if (!playerInSight)
                    {
                        TransitionToState(AIState.Patrolling);
                    }
                    break;

SUFFIX CODE:
----------------------------------------
                case AIState.Attacking:
                    if (playerDistance > detectionRange / 2)
                    {
                        TransitionToState(AIState.Chasing);
                    }
                    else if (!playerInSight)
                    {
                        TransitionToState(AIState.Patrolling);
                    }
                    break;
                default:
                    throw new InvalidOperationException("Unknown state");
            }
        }

        private void TransitionToState(AIState newState)
        {
            currentState = newState;
            // Additional logic for transitioning state can be added here
        }

        public AIState GetCurrentState() => currentState;
    }

    public class Program
    {
        public static void Main()
        {
            AIController aiController = new AIController(initialHealth: 100, detectionRange: 50);
            aiController.UpdateState(playerDistance: 30, playerInSight: true);
            Debug.Assert(aiController.GetCurrentState() == AIState.Chasing, "AI should be in Chasing state");

            aiController.UpdateState(playerDistance: 20, playerInSight: true);
            Debug.Assert(aiController.GetCurrentState() == AIState.Attacking, "AI should be in Attacking state");

            aiController.UpdateState(playerDistance: 60, playerInSight: false);
            Debug.Assert(aiController.GetCurrentState() == AIState.Patrolling, "AI should be in Patrolling state");

            aiController.UpdateState(playerDistance: 30, playerInSight: false);
            Debug.Assert(aiController.GetCurrentState() == AIState.Idle, "AI should be in Idle state");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize a state machine pattern and continue it correctly. The AI state transitions are clearly defined with similar logic blocks for different states. The golden completion follows the pattern established in the prefix by handling the Chasing state transitions. The suffix continues the pattern with the Attacking state and includes assertions to verify correct state transitions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanics
{
    public class StateMachine<TState, TTrigger>
    {
        private readonly Dictionary<TState, Dictionary<TTrigger, TState>> _transitions;
        private TState _currentState;

        public StateMachine(TState initialState)
        {
            _currentState = initialState;
            _transitions = new Dictionary<TState, Dictionary<TTrigger, TState>>();
        }

        public void AddTransition(TState fromState, TTrigger trigger, TState toState)
        {
            if (!_transitions.ContainsKey(fromState))
            {
                _transitions[fromState] = new Dictionary<TTrigger, TState>();
            }
            _transitions[fromState][trigger] = toState;
        }

        public void Fire(TTrigger trigger)
        {
            if (_transitions.ContainsKey(_currentState) && _transitions[_currentState].ContainsKey(trigger))
            {
                _currentState = _transitions[_currentState][trigger];
            }
            else
            {
                throw new InvalidOperationException("Invalid transition");
            }
        }

        public TState GetCurrentState()
        {
            return _currentState;
        }
    }

    public static class Program
    {
        public static void Main()
        {
            var stateMachine = new StateMachine<string, string>("Idle");
            stateMachine.AddTransition("Idle", "Start", "Running");
            stateMachine.AddTransition("Running", "Stop", "Idle");
            stateMachine.AddTransition("Idle", "Pause", "Paused");
            stateMachine.AddTransition("Paused", "Resume", "Running");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            stateMachine.Fire("Start");

SUFFIX CODE:
----------------------------------------
            stateMachine.Fire("Pause");
            Debug.Assert(stateMachine.GetCurrentState() == "Paused", "State should be 'Paused'");

            stateMachine.Fire("Resume");
            Debug.Assert(stateMachine.GetCurrentState() == "Running", "State should be 'Running'");

            stateMachine.Fire("Stop");
            Debug.Assert(stateMachine.GetCurrentState() == "Idle", "State should be 'Idle'");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This scenario tests the pattern matching capability of an LLM in the context of implementing a state machine for game mechanics. The prefix establishes a clear pattern of adding transitions and firing triggers to change states, with corresponding assertions to verify state changes. The golden completion requires the LLM to recognize the established pattern and correctly fire a transition from 'Idle' to 'Running' state. This is a practical scenario as state machines are commonly used in game development for handling different states of game characters or systems. Assertions in the suffix ensure the correct state transitions and validate the pattern adherence.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanics
{
    public enum AIState
    {
        Idle,
        Patrol,
        Chase,
        Attack
    }

    public class AIController
    {
        private AIState _currentState;
        private Random _random;

        public AIController()
        {
            _currentState = AIState.Idle;
            _random = new Random();
        }

        public void UpdateState()
        {
            switch (_currentState)
            {
                case AIState.Idle:
                    Debug.WriteLine("AI is idling.");
                    // Transition to Patrol
                    _currentState = AIState.Patrol;
                    break;
                case AIState.Patrol:
                    Debug.WriteLine("AI is patrolling.");
                    // Randomly transition to Chase
                    if (_random.NextDouble() > 0.5)
                    {
                        _currentState = AIState.Chase;
                    }
                    break;
                case AIState.Chase:
                    Debug.WriteLine("AI is chasing.");
                    // Transition to Attack
                    _currentState = AIState.Attack;
                    break;
                case AIState.Attack:
                    Debug.WriteLine("AI is attacking.");
                    // Transition back to Idle
                    _currentState = AIState.Idle;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public AIState GetCurrentState()
        {
            return _currentState;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            AIController aiController = new AIController();
            aiController.UpdateState();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            Console.WriteLine($"Current State: {aiController.GetCurrentState()}");

SUFFIX CODE:
----------------------------------------
            Debug.Assert(aiController.GetCurrentState() == AIState.Patrol, "State should transition to Patrol");
            aiController.UpdateState();
            Debug.Assert(aiController.GetCurrentState() == AIState.Chase || aiController.GetCurrentState() == AIState.Patrol, "State should transition to Chase or stay in Patrol");
            aiController.UpdateState();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case provides a clear pattern of state transitions in an AI state machine for game mechanics. The prefix establishes the pattern of state updates and transitions, while the golden completion continues this pattern by verifying the expected state transitions. The assertions in the suffix ensure that the state transitions are correct. This scenario tests the LLM's ability to recognize and continue the established pattern of state transitions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace EncryptionExample
{
    public class AesEncryptionService
    {
        private readonly byte[] key;
        private readonly byte[] iv;

        public AesEncryptionService(byte[] key, byte[] iv)
        {
            this.key = key;
            this.iv = iv;
        }

        public byte[] Encrypt(string plainText)
        {
            if (string.IsNullOrEmpty(plainText))
                throw new ArgumentException("Plaintext cannot be null or empty.");

            using (var aes = System.Security.Cryptography.Aes.Create())
            {
                aes.Key = key;
                aes.IV = iv;

                var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

                using (var ms = new System.IO.MemoryStream())
                {
                    using (var cs = new System.Security.Cryptography.CryptoStream(ms, encryptor, System.Security.Cryptography.CryptoStreamMode.Write))
                    {
                        using (var sw = new System.IO.StreamWriter(cs))
                        {
                            sw.Write(plainText);
                        }
                        return ms.ToArray();
                    }
                }
            }
        }

        public string Decrypt(byte[] cipherText)
        {
            if (cipherText == null || cipherText.Length == 0)
                throw new ArgumentException("Ciphertext cannot be null or empty.");

            using (var aes = System.Security.Cryptography.Aes.Create())
            {
                aes.Key = key;
                aes.IV = iv;

                var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

                using (var ms = new System.IO.MemoryStream(cipherText))
                {
                    using (var cs = new System.Security.Cryptography.CryptoStream(ms, decryptor, System.Security.Cryptography.CryptoStreamMode.Read))
                    {
                        using (var sr = new System.IO.StreamReader(cs))
                        {
                            return sr.ReadToEnd();
                        }
                    }
                }
            }
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            byte[] key = new byte[32]; // Example key (for demonstration purposes only)
            byte[] iv = new byte[16];  // Example IV (for demonstration purposes only)
            var encryptionService = new AesEncryptionService(key, iv);

            string originalText = "Hello, World!";
            byte[] encryptedText = encryptionService.Encrypt(originalText);
            string decryptedText = encryptionService.Decrypt(encryptedText);

            Debug.Assert(originalText == decryptedText, "The decrypted text should match the original text.");

            // Additional encryption and decryption tests
            string testText1 = "Test 1";
            byte[] encryptedText1 = encryptionService.Encrypt(testText1);
            string decryptedText1 = encryptionService.Decrypt(encryptedText1);
            Debug.Assert(testText1 == decryptedText1, "The decrypted text should match the original text.");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            string testText3 = "Final test";
            byte[] encryptedText3 = encryptionService.Encrypt(testText3);
            string decryptedText3 = encryptionService.Decrypt(encryptedText3);
            Debug.Assert(testText3 == decryptedText3, "The decrypted text should match the original text.");

SUFFIX CODE:
----------------------------------------
            // Another test case for encryption and decryption
            string testText2 = "Another test";
            byte[] encryptedText2 = encryptionService.Encrypt(testText2);
            string decryptedText2 = encryptionService.Decrypt(encryptedText2);
            Debug.Assert(testText2 == decryptedText2, "The decrypted text should match the original text.");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This is a good test case because it demonstrates a common pattern in encryption and decryption services where the same key and IV are used to both encrypt and decrypt data. The pattern involves using the same encryption/decryption logic and verifying the results through assertions. The provided code checks the integrity of the encryption and decryption processes by ensuring that the decrypted text matches the original text. This pattern is clear, practical, and aligns with best practices in error handling and resource management in C#.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GamePhysics
{
    public enum State
    {
        Idle,
        Running,
        Jumping
    }

    public interface IStateHandler
    {
        void EnterState(State state);
        void ExitState(State state);
    }

    public class Character : IStateHandler
    {
        private State currentState;

        public Character()
        {
            currentState = State.Idle;
        }

        public void EnterState(State state)
        {
            switch (state)
            {
                case State.Idle:
                    Console.WriteLine("Entering Idle State");
                    break;
                case State.Running:
                    Console.WriteLine("Entering Running State");
                    break;
                case State.Jumping:
                    Console.WriteLine("Entering Jumping State");
                    break;
                default:
                    throw new ArgumentException("Invalid state");
            }
            currentState = state;
        }

        public void ExitState(State state)
        {
            switch (state)
            {
                case State.Idle:
                    Console.WriteLine("Exiting Idle State");
                    break;
                case State.Running:
                    Console.WriteLine("Exiting Running State");
                    break;
                case State.Jumping:
                    Console.WriteLine("Exiting Jumping State");
                    break;
                default:
                    throw new ArgumentException("Invalid state");
            }
        }

        public State GetCurrentState()
        {
            return currentState;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Character character = new Character();
            character.EnterState(State.Running);
            Debug.Assert(character.GetCurrentState() == State.Running, "Character should be in Running state");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            character.ExitState(State.Running);

SUFFIX CODE:
----------------------------------------
            character.ExitState(State.Jumping);
            character.EnterState(State.Idle);
            Debug.Assert(character.GetCurrentState() == State.Idle, "Character should be in Idle state");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and complete a pattern in state management for a game character. The prefix establishes the pattern of switching states, and the completion should follow this pattern by handling state transitions and verifying them using assertions. The suffix continues with different state transitions and additional assertions. This is a realistic scenario developers encounter when implementing state machines in game mechanics.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameAI
{
    public class StateMachine<TState, TEvent>
    {
        private readonly Dictionary<TState, Dictionary<TEvent, TState>> _transitions;

        public StateMachine()
        {
            _transitions = new Dictionary<TState, Dictionary<TEvent, TState>>();
        }

        public void AddTransition(TState fromState, TEvent evt, TState toState)
        {
            if (!_transitions.ContainsKey(fromState))
            {
                _transitions[fromState] = new Dictionary<TEvent, TState>();
            }
            _transitions[fromState][evt] = toState;
        }

        public TState GetNextState(TState currentState, TEvent evt)
        {
            if (_transitions.ContainsKey(currentState) && _transitions[currentState].ContainsKey(evt))
            {
                return _transitions[currentState][evt];
            }
            else
            {
                throw new InvalidOperationException("Invalid state transition.");
            }
        }
    }

    public class GameAI
    {
        private readonly StateMachine<string, string> _stateMachine;

        public GameAI()
        {
            _stateMachine = new StateMachine<string, string>();
            InitializeStateMachine();
        }

        private void InitializeStateMachine()
        {
            _stateMachine.AddTransition("Idle", "SeeEnemy", "Attack");
            _stateMachine.AddTransition("Attack", "LoseEnemy", "Search");
            _stateMachine.AddTransition("Search", "FindEnemy", "Attack");
            _stateMachine.AddTransition("Search", "GiveUp", "Idle");
        }

        public string GetNextState(string currentState, string evt)
        {
            return _stateMachine.GetNextState(currentState, evt);
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            GameAI ai = new GameAI();
            string nextState = ai.GetNextState("Idle", "SeeEnemy");
            Debug.Assert(nextState == "Attack", "Expected next state to be Attack");
            nextState = ai.GetNextState("Attack", "LoseEnemy");
            Debug.Assert(nextState == "Search", "Expected next state to be Search");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            nextState = ai.GetNextState("Search", "GiveUp");
            Debug.Assert(nextState == "Idle", "Expected next state to be Idle");

SUFFIX CODE:
----------------------------------------


            try
            {
                nextState = ai.GetNextState("Idle", "UnknownEvent");
            }
            catch (InvalidOperationException ex)
            {
                Debug.Assert(ex.Message == "Invalid state transition.", "Expected Invalid state transition exception");
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example establishes a clear pattern of adding state transitions to a state machine and querying the next state based on the current state and event. The pattern is identifiable through multiple examples of adding transitions and querying the next state. The golden completion follows this pattern by continuing the established state transition queries and verifying the results with assertions. This tests the LLM's ability to recognize and continue the pattern correctly. The assertions ensure that the state transitions work as expected, including handling invalid transitions with proper exception handling.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Collections.Generic;

namespace GameAI
{
    public enum AIState
    {
        Idle,
        Patrol,
        Chase,
        Attack
    }

    public class EnemyAI
    {
        private AIState _currentState;
        private List<string> _patrolPoints;
        private int _currentPatrolIndex;

        public EnemyAI(List<string> patrolPoints)
        {
            _patrolPoints = patrolPoints;
            _currentPatrolIndex = 0;
            _currentState = AIState.Idle;
        }

        public void Update()
        {
            switch (_currentState)
            {
                case AIState.Idle:
                    Debug.WriteLine("Enemy is idle.");
                    IdleBehavior();
                    break;
                case AIState.Patrol:
                    Debug.WriteLine("Enemy is patrolling.");
                    PatrolBehavior();
                    break;
                case AIState.Chase:
                    Debug.WriteLine("Enemy is chasing.");
                    ChaseBehavior();
                    break;
                case AIState.Attack:
                    Debug.WriteLine("Enemy is attacking.");
                    AttackBehavior();
                    break;
            }
        }

        private void IdleBehavior()
        {
            // Transition to Patrol after some condition
            _currentState = AIState.Patrol;
        }

        private void PatrolBehavior()
        {
            // Move to the next patrol point
            _currentPatrolIndex = (_currentPatrolIndex + 1) % _patrolPoints.Count;
            Debug.WriteLine($"Moving to patrol point {_patrolPoints[_currentPatrolIndex]}.");
            // Transition to Chase if an enemy is spotted
            if (EnemySpotted())
            {
                _currentState = AIState.Chase;
            }
        }

        private bool EnemySpotted()
        {
            // Simplified enemy spotting logic
            return new Random().Next(0, 10) > 7;
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        public AIState GetCurrentState()
        {
            return _currentState;
        }

SUFFIX CODE:
----------------------------------------
        private void ChaseBehavior()
        {
            // Move towards the player
            Debug.WriteLine("Chasing the player.");
            // Transition to Attack if close enough to the player
            if (PlayerInRange())
            {
                _currentState = AIState.Attack;
            }
        }

        private bool PlayerInRange()
        {
            // Simplified player range check
            return new Random().Next(0, 10) > 5;
        }

        private void AttackBehavior()
        {
            // Perform attack
            Debug.WriteLine("Attacking the player.");
            // Transition back to Idle after attacking
            _currentState = AIState.Idle;
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            List<string> patrolPoints = new List<string> { "PointA", "PointB", "PointC" };
            EnemyAI enemyAI = new EnemyAI(patrolPoints);

            enemyAI.Update();
            Debug.Assert(enemyAI.GetCurrentState() == AIState.Patrol, "Enemy should transition to Patrol from Idle.");

            enemyAI.Update();
            Debug.Assert(enemyAI.GetCurrentState() != AIState.Idle, "Enemy should no longer be Idle.");

            // Simulate the AI update loop
            for (int i = 0; i < 10; i++)
            {
                enemyAI.Update();
                Debug.WriteLine(enemyAI.GetCurrentState().ToString());
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the pattern matching capabilities of an LLM by using a state machine to manage the behavior of an enemy AI in a game. The pattern involves transitioning between different states (Idle, Patrol, Chase, Attack) based on certain conditions. The golden completion requires the LLM to correctly implement a method that adheres to this established pattern of state management, allowing the AI's current state to be queried. This scenario is realistic and practical, as state machines are commonly used in game development to manage complex behavior logic. The assertions in the suffix ensure that the state transitions occur as expected, verifying both pattern adherence and functionality.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

namespace SecurityExample
{
    public class EncryptionService
    {
        private readonly Aes _aes;

        public EncryptionService()
        {
            _aes = Aes.Create();
            _aes.Key = Encoding.UTF8.GetBytes("A key that is 32 bytes long........");
            _aes.IV = Encoding.UTF8.GetBytes("16 bytes IV......");
        }

        public byte[] Encrypt(string plainText)
        {
            byte[] encrypted;
            using (var encryptor = _aes.CreateEncryptor(_aes.Key, _aes.IV))
            {
                var plainBytes = Encoding.UTF8.GetBytes(plainText);
                encrypted = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);
            }
            return encrypted;
        }

        public string Decrypt(byte[] encryptedBytes)
        {
            string decrypted;
            using (var decryptor = _aes.CreateDecryptor(_aes.Key, _aes.IV))
            {
                var decryptedBytes = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
                decrypted = Encoding.UTF8.GetString(decryptedBytes);
            }
            return decrypted;
        }

        public void Dispose()
        {
            if (_aes != null)
            {
                _aes.Dispose();
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var encryptionService = new EncryptionService();
            var secretMessage = "Hello, world!";
            var encryptedMessage = encryptionService.Encrypt(secretMessage);
            var decryptedMessage = encryptionService.Decrypt(encryptedMessage);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            Console.WriteLine($"Original: {secretMessage}");
            Console.WriteLine($"Encrypted (base64): {Convert.ToBase64String(encryptedMessage)}");
            Console.WriteLine($"Decrypted: {decryptedMessage}");

SUFFIX CODE:
----------------------------------------
            Debug.Assert(decryptedMessage == secretMessage, "Decryption failed: the decrypted message does not match the original.");
            Console.WriteLine("Encryption and decryption succeeded.");

            encryptionService.Dispose();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests an LLM's ability to recognize and complete a pattern in error handling within the domain of security (encryption). The pattern is established by showing encryption and decryption methods that use Aes for secure data handling. The golden completion continues this pattern by adding an appropriate assertion to check the length of the encrypted message, ensuring it is not empty. This is realistic as it is common practice to verify that encryption operations produce a valid non-empty output. The suffix includes further assertions and proper cleanup of resources, ensuring all assertions pass before disposing of the encryption service.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

public class EncryptionUtility
{
    private const string Key = "E546C8DF278CD5931069B522E695D4F2";
    private const string IV = "A8AFC1B7C3D4E2F8";

    public static string Encrypt(string plainText)
    {
        using (Aes aesAlg = Aes.Create())
        {
            aesAlg.Key = Encoding.UTF8.GetBytes(Key);
            aesAlg.IV = Encoding.UTF8.GetBytes(IV);
            ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);
            using (System.IO.MemoryStream msEncrypt = new System.IO.MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (System.IO.StreamWriter swEncrypt = new System.IO.StreamWriter(csEncrypt))
                    {
                        swEncrypt.Write(plainText);
                    }
                    return Convert.ToBase64String(msEncrypt.ToArray());
                }
            }
        }
    }

    public static string Decrypt(string cipherText)
    {
        using (Aes aesAlg = Aes.Create())
        {
            aesAlg.Key = Encoding.UTF8.GetBytes(Key);
            aesAlg.IV = Encoding.UTF8.GetBytes(IV);
            ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);
            using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(cipherText)))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))
                    {
                        return srDecrypt.ReadToEnd();
                    }
                }
            }
        }
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        string original = "Sensitive data";
        string encrypted = EncryptionUtility.Encrypt(original);
        Debug.Assert(!string.IsNullOrEmpty(encrypted), "Encryption failed");
        string decrypted = EncryptionUtility.Decrypt(encrypted);
        Debug.Assert(decrypted == original, "Decryption failed");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        Console.WriteLine($"Original: {original}");
        Console.WriteLine($"Encrypted: {encrypted}");
        Console.WriteLine($"Decrypted: {decrypted}");

SUFFIX CODE:
----------------------------------------
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern involving encryption and decryption operations. The pattern involves encrypting a string, checking that the encrypted string is not null or empty, decrypting the encrypted string, and verifying that the decrypted string matches the original. This pattern is established clearly in the prefix and requires the LLM to correctly follow the pattern in the golden completion. The suffix continues the pattern with different data, ensuring consistency and correctness. Assertions are included to validate the functionality and adherence to the established pattern.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameAI
{
    public class StateMachine<TState, TEvent>
    {
        private readonly Dictionary<TState, Dictionary<TEvent, TState>> transitions;
        private TState currentState;

        public StateMachine(TState initialState)
        {
            currentState = initialState;
            transitions = new Dictionary<TState, Dictionary<TEvent, TState>>();
        }

        public void AddTransition(TState fromState, TEvent eventTrigger, TState toState)
        {
            if (!transitions.ContainsKey(fromState))
            {
                transitions[fromState] = new Dictionary<TEvent, TState>();
            }
            transitions[fromState][eventTrigger] = toState;
        }

        public void TriggerEvent(TEvent eventTrigger)
        {
            if (transitions.ContainsKey(currentState) && transitions[currentState].ContainsKey(eventTrigger))
            {
                currentState = transitions[currentState][eventTrigger];
            }
            else
            {
                throw new InvalidOperationException("Invalid state transition");
            }
        }

        public TState GetCurrentState()
        {
            return currentState;
        }
    }

    public enum GameState
    {
        Start,
        Playing,
        GameOver
    }

    public enum GameEvent
    {
        Begin,
        Win,
        Lose
    }

    public class Game
    {
        private StateMachine<GameState, GameEvent> stateMachine;

        public Game()
        {
            stateMachine = new StateMachine<GameState, GameEvent>(GameState.Start);
            stateMachine.AddTransition(GameState.Start, GameEvent.Begin, GameState.Playing);
            stateMachine.AddTransition(GameState.Playing, GameEvent.Win, GameState.GameOver);
            stateMachine.AddTransition(GameState.Playing, GameEvent.Lose, GameState.GameOver);
        }

        public void StartGame()
        {
            stateMachine.TriggerEvent(GameEvent.Begin);
        }

        public void WinGame()
        {
            stateMachine.TriggerEvent(GameEvent.Win);
        }

        public void LoseGame()
        {
            stateMachine.TriggerEvent(GameEvent.Lose);
        }

        public GameState GetCurrentState()
        {
            return stateMachine.GetCurrentState();
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            Game game = new Game();
            game.StartGame();
            Debug.Assert(game.GetCurrentState() == GameState.Playing, "Game should be in Playing state after StartGame");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            game.WinGame();

SUFFIX CODE:
----------------------------------------
            game.WinGame();
            Debug.Assert(game.GetCurrentState() == GameState.GameOver, "Game should be in GameOver state after WinGame");

            game = new Game();
            game.StartGame();
            game.LoseGame();
            Debug.Assert(game.GetCurrentState() == GameState.GameOver, "Game should be in GameOver state after LoseGame");
        }
    }
}


JUSTIFICATION:
----------------------------------------
This test case is a good example because it establishes a clear pattern in the implementation of a state machine for a game. The pattern includes adding transitions and triggering events to change states. The golden completion follows this pattern by triggering an event and checking the state change. The suffix completes the pattern with different event triggers and assertions to verify correct state transitions. This setup tests the LLM's ability to recognize and continue the established pattern while ensuring functionality through assertions.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

public class EncryptionUtility
{
    public string EncryptString(string plainText, string key)
    {
        using (Aes aesAlg = Aes.Create())
        {
            aesAlg.Key = Encoding.UTF8.GetBytes(key);
            aesAlg.IV = new byte[16]; // Zero IV for simplicity

            ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

            using (var msEncrypt = new System.IO.MemoryStream())
            {
                using (var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (var swEncrypt = new System.IO.StreamWriter(csEncrypt))
                    {
                        swEncrypt.Write(plainText);
                    }
                    return Convert.ToBase64String(msEncrypt.ToArray());
                }
            }
        }
    }

    public string DecryptString(string cipherText, string key)
    {
        using (Aes aesAlg = Aes.Create())
        {
            aesAlg.Key = Encoding.UTF8.GetBytes(key);
            aesAlg.IV = new byte[16]; // Zero IV for simplicity

            ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

            using (var msDecrypt = new System.IO.MemoryStream(Convert.FromBase64String(cipherText)))
            {
                using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (var srDecrypt = new System.IO.StreamReader(csDecrypt))
                    {
                        return srDecrypt.ReadToEnd();
                    }
                }
            }
        }
    }

    // Encryption and decryption using RSA
    public string EncryptStringRSA(string plainText, RSA rsa)
    {
        byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);
        byte[] encryptedBytes = rsa.Encrypt(plainBytes, RSAEncryptionPadding.OaepSHA256);
        return Convert.ToBase64String(encryptedBytes);
    }

    public string DecryptStringRSA(string cipherText, RSA rsa)
    {
        byte[] cipherBytes = Convert.FromBase64String(cipherText);
        byte[] decryptedBytes = rsa.Decrypt(cipherBytes, RSAEncryptionPadding.OaepSHA256);
        return Encoding.UTF8.GetString(decryptedBytes);
    }
}

public class Program
{
    public static void Main()
    {
        var util = new EncryptionUtility();
        string key = "0123456789abcdef"; // 16 bytes key
        string originalText = "Hello, World!";

        // Symmetric Encryption
        string encryptedText = util.EncryptString(originalText, key);
        string decryptedText = util.DecryptString(encryptedText, key);
        Debug.Assert(decryptedText == originalText, "Symmetric encryption/decryption failed");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
        using (RSA rsa = RSA.Create())
        {
            rsa.KeySize = 2048;
            string rsaEncrypted = util.EncryptStringRSA(originalText, rsa);
            string rsaDecrypted = util.DecryptStringRSA(rsaEncrypted, rsa);
            Debug.Assert(rsaDecrypted == originalText, "RSA encryption/decryption failed");
        }

        Console.WriteLine("All encryption tests passed successfully.");
    }
}


JUSTIFICATION:
----------------------------------------
This scenario demonstrates a clear pattern of encryption and decryption using both symmetric (AES) and asymmetric (RSA) algorithms. The pattern of encryption followed by decryption and validation through assertions is evident. The golden_completion reinforces this pattern with additional assertions to ensure encryption actually alters the text and results are not null or empty, which are common checks in encryption routines. This pattern is realistic and practical, ensuring the LLM can recognize and continue the established encryption/decryption validation process.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanics
{
    public class StateMachine<TState, TEvent>
    {
        private readonly Dictionary<TState, Dictionary<TEvent, TState>> _transitions;
        private TState _currentState;

        public StateMachine(TState initialState)
        {
            _currentState = initialState;
            _transitions = new Dictionary<TState, Dictionary<TEvent, TState>>();
        }

        public void AddTransition(TState fromState, TEvent eventTrigger, TState toState)
        {
            if (!_transitions.ContainsKey(fromState))
            {
                _transitions[fromState] = new Dictionary<TEvent, TState>();
            }
            _transitions[fromState][eventTrigger] = toState;
        }

        public void FireEvent(TEvent eventTrigger)
        {
            if (_transitions.ContainsKey(_currentState) && _transitions[_currentState].ContainsKey(eventTrigger))
            {
                _currentState = _transitions[_currentState][eventTrigger];
            }
            else
            {
                throw new InvalidOperationException("Invalid state transition");
            }
        }

        public TState GetCurrentState()
        {
            return _currentState;
        }
    }

    public class StateMachineTest
    {
        public static void Main(string[] args)
        {
            var stateMachine = new StateMachine<string, string>("Idle");
            stateMachine.AddTransition("Idle", "Start", "Running");
            stateMachine.AddTransition("Running", "Stop", "Idle");
            stateMachine.AddTransition("Running", "Pause", "Paused");
            stateMachine.AddTransition("Paused", "Resume", "Running");

            stateMachine.FireEvent("Start");
            Debug.Assert(stateMachine.GetCurrentState() == "Running", "State should be Running after Start event");

            stateMachine.FireEvent("Pause");
            Debug.Assert(stateMachine.GetCurrentState() == "Paused", "State should be Paused after Pause event");

            stateMachine.FireEvent("Resume");
            Debug.Assert(stateMachine.GetCurrentState() == "Running", "State should be Running after Resume event");


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            stateMachine.FireEvent("Stop");
            Debug.Assert(stateMachine.GetCurrentState() == "Idle", "State should be Idle after Stop event");

SUFFIX CODE:
----------------------------------------
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the pattern matching capabilities in the context of implementing a state machine for game mechanics. The prefix sets up the state machine with transitions and tests some state changes. The golden completion follows the pattern of firing events and asserting state transitions, while also handling invalid transitions with appropriate error handling. The suffix continues with additional event firings and assertions. This scenario is practical and tests the LLM's ability to recognize and continue established patterns in error handling and state management.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

public class AlgorithmDemo
{
    public static int Fibonacci(int n)
    {
        if (n <= 1) return n;
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }

    public static bool IsPrime(int number)
    {
        if (number <= 1) return false;
        if (number == 2) return true;
        if (number % 2 == 0) return false;
        for (int i = 3; i <= Math.Sqrt(number); i += 2)
        {
            if (number % i == 0)
                return false;
        }
        return true;
    }

    public static int Factorial(int n)
    {
        if (n <= 1) return 1;
        return n * Factorial(n - 1);
    }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
    public static void Main(string[] args)
    {
        int fib10 = Fibonacci(10);
        Debug.Assert(fib10 == 55, "Fibonacci(10) should be 55");

        bool isPrime7 = IsPrime(7);
        Debug.Assert(isPrime7 == true, "IsPrime(7) should be true");

        int fact5 = Factorial(5);
        Debug.Assert(fact5 == 120, "Factorial(5) should be 120");
    }
}


JUSTIFICATION:
----------------------------------------
This is a good test case because it involves algorithm implementation, a common pattern in C# programming. The prefix sets up a clear pattern by defining three well-known mathematical functions (Fibonacci, IsPrime, and Factorial) using both recursion and iteration. The golden completion should follow this pattern by implementing another mathematical algorithm (SumOfSquares) using a similar approach. The suffix includes execution code and assertions that verify the correctness of the implemented algorithms, ensuring that the pattern is adhered to and the functionality is correct.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanics
{
    public class StateMachine<TState>
    {
        private readonly Dictionary<TState, Action> _stateActions;
        private TState _currentState;

        public StateMachine()
        {
            _stateActions = new Dictionary<TState, Action>();
        }

        public void AddState(TState state, Action action)
        {
            if (state == null) throw new ArgumentNullException(nameof(state));
            if (action == null) throw new ArgumentNullException(nameof(action));
            _stateActions[state] = action;
        }

        public void ChangeState(TState newState)
        {
            if (!_stateActions.ContainsKey(newState)) throw new InvalidOperationException("State not defined");
            _currentState = newState;
        }

        public void Update()
        {
            if (_currentState == null) throw new InvalidOperationException("Current state is not set");
            _stateActions[_currentState]?.Invoke();
        }
    }

    public enum GameStates
    {
        MainMenu,
        Playing,
        Paused,
        GameOver
    }

    public class Game
    {
        private StateMachine<GameStates> _stateMachine;

        public Game()
        {
            _stateMachine = new StateMachine<GameStates>();
            InitializeStates();
        }

        private void InitializeStates()
        {
            _stateMachine.AddState(GameStates.MainMenu, MainMenu);
            _stateMachine.AddState(GameStates.Playing, Playing);
            _stateMachine.AddState(GameStates.Paused, Paused);
            _stateMachine.AddState(GameStates.GameOver, GameOver);
        }

        private void MainMenu()
        {
            Console.WriteLine("In Main Menu");
        }

        private void Playing()
        {
            Console.WriteLine("Game is Playing");
        }

        private void Paused()
        {
            Console.WriteLine("Game is Paused");
        }

        private void GameOver()
        {
            Console.WriteLine("Game Over");
        }

        public void StartGame()
        {
            _stateMachine.ChangeState(GameStates.MainMenu);
            _stateMachine.Update();
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        public void PlayGame()
        {
            _stateMachine.ChangeState(GameStates.Playing);
            _stateMachine.Update();
            Debug.Assert(_stateMachine != null, "State machine should not be null");
        }

SUFFIX CODE:
----------------------------------------
        public void PauseGame()
        {
            _stateMachine.ChangeState(GameStates.Paused);
            _stateMachine.Update();
            Debug.Assert(_stateMachine != null, "State machine should not be null");
        }

        public void EndGame()
        {
            _stateMachine.ChangeState(GameStates.GameOver);
            _stateMachine.Update();
            Debug.Assert(_stateMachine != null, "State machine should not be null");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Game game = new Game();
            game.StartGame();
            game.PauseGame();
            game.EndGame();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of state transitions within a state machine for a game. The prefix establishes the pattern of adding states and transitioning between them, and the golden completion requires the LLM to continue this pattern by adding a method to resume the game. The suffix then adds additional state transitions and assertions to ensure the correct functioning and pattern adherence.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace GameMechanics
{
    public class StateMachine
    {
        private Dictionary<string, Action> _states;
        private string _currentState;

        public StateMachine()
        {
            _states = new Dictionary<string, Action>();
            _currentState = string.Empty;
        }

        public void AddState(string name, Action action)
        {
            if (!_states.ContainsKey(name))
            {
                _states[name] = action;
            }
        }

        public void SetState(string name)
        {
            if (_states.ContainsKey(name))
            {
                _currentState = name;
            }
        }

        public void Update()
        {
            if (_states.ContainsKey(_currentState))
            {
                _states[_currentState].Invoke();
            }
        }

        // Pattern: Adding a new state
        // Example states
        public void InitializeStates()
        {
            AddState("Idle", Idle);
            AddState("Running", Running);
            AddState("Jumping", Jumping);
        }

        private void Idle()
        {
            Console.WriteLine("State: Idle");
        }

        private void Running()
        {
            Console.WriteLine("State: Running");
        }


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        private void Jumping()
        {
            Console.WriteLine("State: Jumping");
        }

SUFFIX CODE:
----------------------------------------
        public void TestStateMachine()
        {
            InitializeStates();
            SetState("Idle");
            Update();
            Debug.Assert(_currentState == "Idle", "Expected state to be 'Idle'");
            SetState("Running");
            Update();
            Debug.Assert(_currentState == "Running", "Expected state to be 'Running'");
            SetState("Jumping");
            Update();
            Debug.Assert(_currentState == "Jumping", "Expected state to be 'Jumping'");
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            StateMachine stateMachine = new StateMachine();
            stateMachine.TestStateMachine();
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of adding new states to a state machine in a game mechanics context. The prefix establishes a clear pattern of adding states with specific methods, and the golden completion requires adding another state following the same pattern. The suffix includes test cases to verify that the state machine behaves correctly, making it a robust test for pattern matching and functional correctness.

ASSERTIONS:
----------------------------------------

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: synthbench-pattern-matching
Language: c_sharp
================================================================================

PREFIX CODE:
----------------------------------------
using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;

namespace SecurityExample
{
    public class EncryptionHelper
    {
        private readonly Aes _aes;

        public EncryptionHelper()
        {
            _aes = Aes.Create();
            _aes.Key = Encoding.UTF8.GetBytes("a very strong key123");
            _aes.IV = Encoding.UTF8.GetBytes("a strong IV 123456");
        }

        public byte[] Encrypt(string plainText)
        {
            if (string.IsNullOrEmpty(plainText))
                throw new ArgumentException("plainText cannot be null or empty", nameof(plainText));

            using (var encryptor = _aes.CreateEncryptor(_aes.Key, _aes.IV))
            {
                byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);
                return PerformCryptography(plainBytes, encryptor);
            }
        }

        public string Decrypt(byte[] cipherText)
        {
            if (cipherText == null || cipherText.Length == 0)
                throw new ArgumentException("cipherText cannot be null or empty", nameof(cipherText));

            using (var decryptor = _aes.CreateDecryptor(_aes.Key, _aes.IV))
            {
                byte[] plainBytes = PerformCryptography(cipherText, decryptor);
                return Encoding.UTF8.GetString(plainBytes);
            }
        }

        private byte[] PerformCryptography(byte[] data, ICryptoTransform cryptoTransform)
        {
            using (var memoryStream = new System.IO.MemoryStream())
            using (var cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write))
            {
                cryptoStream.Write(data, 0, data.Length);
                cryptoStream.FlushFinalBlock();
                return memoryStream.ToArray();
            }
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            EncryptionHelper helper = new EncryptionHelper();

            string original = "This is a test.";
            byte[] encrypted = helper.Encrypt(original);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
            string decrypted = helper.Decrypt(encrypted);

SUFFIX CODE:
----------------------------------------
            string decrypted = helper.Decrypt(encrypted);

            Debug.Assert(decrypted == original, "Decryption did not return the original text");

            // Test with empty string
            try
            {
                helper.Encrypt("");
            }
            catch (ArgumentException ex)
            {
                Debug.Assert(ex.ParamName == "plainText", "Exception parameter name is incorrect");
            }

            // Test with null string
            try
            {
                helper.Encrypt(null);
            }
            catch (ArgumentException ex)
            {
                Debug.Assert(ex.ParamName == "plainText", "Exception parameter name is incorrect");
            }

            // Test with null byte array
            try
            {
                helper.Decrypt(null);
            }
            catch (ArgumentException ex)
            {
                Debug.Assert(ex.ParamName == "cipherText", "Exception parameter name is incorrect");
            }

            // Test with empty byte array
            try
            {
                helper.Decrypt(new byte[0]);
            }
            catch (ArgumentException ex)
            {
                Debug.Assert(ex.ParamName == "cipherText", "Exception parameter name is incorrect");
            }
        }
    }
}


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of error handling in a security context, specifically within encryption and decryption functions. The prefix sets up the EncryptionHelper class with methods for Encrypt and Decrypt, including error handling for invalid input. The golden_completion ensures that the encryption result is not null or empty, adhering to the established pattern of input validation and error handling. The suffix continues with further tests and assertions to validate the functionality and error handling of the Encrypt and Decrypt methods.

ASSERTIONS:
----------------------------------------

================================================================================
