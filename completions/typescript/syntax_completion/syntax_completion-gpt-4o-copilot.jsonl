{"id": "1", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\nimport path from 'path';\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\ninterface Response<T> {\n    data: T;\n    status: number;\n    error?: string;\n}\n\nfunction fetchDataFromFile(filePath: string): Promise<Response<User[]>> {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject({ data: [], status: 500, error: err.message });\n                return;\n            }\n            try {\n                const users: User[] = JSON.parse(data);\n                resolve({ data: users, status: 200 });\n            } catch (parseErr) {\n                reject({ data: [], status: 500, error: parseErr.message });\n            }\n        });\n    });\n}\n\nasync function processUserData(filePath: string): Promise<void> {\n    try {\n        const response = await fetchDataFromFile(filePath);\n        if (response.status === 200) {\n            for (const user of response.data) {\n                console.log(`Processing user: ${user.name}`);\n                if (user.email.endsWith('@example.com')) {\n                    console.log(`User ${user.name} has a valid email.`);\n                } else {\n                    console.log(`User ${user.name} has an invalid email.`);\n                }\n            }\n        } else {\n            console.error(`Failed to fetch data: ${response.error}`);\n        }\n    } catch (err) {\n        console.error(`Error processing user data: ${err}`);\n    }\n}\n\n// Example usage\nconst filePath = path.join(__dirname, 'users.json');\nprocessUserData(filePath)\n", "suffix": "\nconsole.log('User data processing complete.');\nfs.unlink(filePath, (err) => {\n    if (err) {\n        console.error(`Error deleting file: ${err.message}`);\n    } else {\n        console.log('Temporary file deleted successfully.');\n    }\n});\n", "golden_completion": "\n    .then(() => console.log('User data processing complete.'))\n    .catch(err => console.error(`Failed to process user data: ${err.message}`));\n", "LLM_justification": "This example tests the model's ability to handle nested control structures, including async/await patterns with proper typing, and error handling in Promise chains. The setup involves reading from a file, parsing JSON data, iterating over the data, and performing conditional checks, followed by appropriate logging and error handling. The completion requires the model to correctly chain a Promise with then/catch blocks and maintain proper indentation and syntax.", "assertions": "import assert from 'assert';\n\nasync function testProcessUserData() {\n    const filePath = path.join(__dirname, 'users.json');\n    fs.writeFileSync(filePath, JSON.stringify([{ id: 1, name: 'John Doe', email: 'john@example.com' }, { id: 2, name: 'Jane Smith', email: 'jane@invalid.com' }]));\n\n    let consoleOutput: string[] = [];\n    const originalConsoleLog = console.log;\n    const originalConsoleError = console.error;\n\n    console.log = (message: string) => { consoleOutput.push(message); };\n    console.error = (message: string) => { consoleOutput.push(message); };\n\n    await processUserData(filePath);\n\n    assert(consoleOutput.includes('Processing user: John Doe'), 'Should log processing John Doe');\n    assert(consoleOutput.includes('User John Doe has a valid email.'), 'Should log valid email for John Doe');\n    assert(consoleOutput.includes('Processing user: Jane Smith'), 'Should log processing Jane Smith');\n    assert(consoleOutput.includes('User Jane Smith has an invalid email.'), 'Should log invalid email for Jane Smith');\n\n    console.log = originalConsoleLog;\n    console.error = originalConsoleError;\n\n    assert(fs.existsSync(filePath), 'The file should exist before deletion');\n\n    fs.unlinkSync(filePath);\n}\n\ntestProcessUserData().then(() => console.log('All tests passed')).catch(err => console.error(`Test failed: ${err.message}`));\n", "gpt-4o-copilot": "    .then(() => {\n        console.log('User data processing complete.');\n    })"}
{"id": "2", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import * as assert from 'assert';\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\ninterface Admin extends User {\n    role: 'admin';\n}\n\ninterface Guest extends User {\n    role: 'guest';\n}\n\ntype Person = Admin | Guest;\n\nfunction isAdmin(person: Person): person is Admin {\n    return person.role === 'admin';\n}\n\nfunction isGuest(person: Person): person is Guest {\n    return person.role === 'guest';\n}\n\nconst people: Person[] = [\n    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' },\n    { id: 2, name: 'Bob', email: 'bob@example.com', role: 'guest' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com', role: 'admin' },\n    { id: 4, name: 'Dave', email: 'dave@example.com', role: 'guest' }\n];\n\nfunction getEmailsOfAdmins(people: Person[]): string[] {\n    return people\n        .filter(isAdmin)\n        .map((admin) => admin.email);\n}\n\nfunction getEmailsOfGuests(people: Person[]): string[] {\n    return people\n        .filter(isGuest)\n        .map((guest) => guest.email);\n}\n\n// Usage\nconst adminEmails = getEmailsOfAdmins(people);\nconst guestEmails = getEmailsOfGuests(people);\n\n// Assertions\nassert.deepStrictEqual(adminEmails, ['alice@example.com', 'charlie@example.com']);\nassert.deepStrictEqual(guestEmails, ['bob@example.com', 'dave@example.com']);\n\n// Now, we will add a nested control structure that processes both admins and guests differently\nfunction processPeople(people: Person[]): void {", "suffix": "}\n\n// Call the function\nprocessPeople(people);\n\n// Assertions to verify the nested control structures work as expected\nassert.strictEqual(console.log.calledWith('Processing admin: Alice'), true);\nassert.strictEqual(console.log.calledWith('Processing guest: Bob'), true);\nassert.strictEqual(console.log.calledWith('Processing admin: Charlie'), true);\nassert.strictEqual(console.log.calledWith('Processing guest: Dave'), true);\n\n// Cleanup\nconsole.log.restore();", "golden_completion": "\n    for (const person of people) {\n        if (isAdmin(person)) {\n            console.log(`Processing admin: ${person.name}`);\n        } else if (isGuest(person)) {\n            console.log(`Processing guest: ${person.name}`);\n        }\n    }\n", "LLM_justification": "This test case is an excellent example to benchmark syntax completion capabilities, as it involves nested control structures (if/else conditions within a loop) and proper type guarding with TypeScript type predicates. It demonstrates the need for maintaining correct indentation, syntax, and type annotations within the nested blocks, ensuring that the completion integrates seamlessly with both preceding and following code. Additionally, assertions verify that the completion correctly processes and logs the intended output, making it a comprehensive test for structural integrity and correctness.", "assertions": "assert.strictEqual(console.log.calledWith('Processing admin: Alice'), true);\nassert.strictEqual(console.log.calledWith('Processing guest: Bob'), true);\nassert.strictEqual(console.log.calledWith('Processing admin: Charlie'), true);\nassert.strictEqual(console.log.calledWith('Processing guest: Dave'), true);", "gpt-4o-copilot": "    people.forEach(person => {\n        if (isAdmin(person)) {\n            console.log(`Processing admin: ${person.name}`);\n        } else if (isGuest(person)) {\n            console.log(`Processing guest: ${person.name}`);\n        }\n    });"}
{"id": "3", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import assert from 'assert';\n\n// Define a custom error class\nclass CustomError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\n// Utility function that may throw an error\nfunction riskyOperation(flag: boolean): string {\n    if (flag) {\n        throw new CustomError('An error occurred during riskyOperation');\n    }\n    return 'Operation successful';\n}\n\n// A function that performs multiple risky operations\nasync function performOperations(): Promise<string[]> {\n    const results: string[] = [];\n    for (let i = 0; i < 3; i++) {\n        try {\n            const result = riskyOperation(i % 2 === 0);\n            results.push(result);\n        } catch (error) {\n            if (error instanceof CustomError) {\n                console.error('Caught custom error:', error.message);\n                results.push('Custom error handled');\n            } else {\n                console.error('Caught unknown error:', error);\n                throw error;\n            }\n        } finally {\n            console.log('Cleanup resources for iteration:', i);\n        }\n    }\n    return results;\n}\n\n// Main function to run the operations\nasync function main() {\n    let finalResults: string[] = [];\n    try {\n        finalResults = await performOperations();\n    } catch (error) {\n        console.error('Error in main function:', error);\n    }\n\n", "suffix": "\n    console.log('Operations completed with results:', finalResults);\n}\n\n// Execute the main function\nmain();\n", "golden_completion": "    assert(Array.isArray(finalResults), 'Expected finalResults to be an array');\n    assert(finalResults.length === 3, 'Expected three results in finalResults');\n    assert(finalResults[0] === 'Operation successful', 'First result should be successful');\n    assert(finalResults[1] === 'Custom error handled', 'Second result should handle custom error');\n    assert(finalResults[2] === 'Operation successful', 'Third result should be successful');\n", "LLM_justification": "This test case demonstrates nested control structures, including try/catch with multiple catch/finally blocks, in a realistic scenario. It verifies the LLM's ability to handle complex error handling patterns and nested loops. The assertions ensure that the expected behavior and types are correct, making it a comprehensive test for syntax completion capabilities.", "assertions": "assert(Array.isArray(finalResults), 'Expected finalResults to be an array');\nassert(finalResults.length === 3, 'Expected three results in finalResults');\nassert(finalResults[0] === 'Operation successful', 'First result should be successful');\nassert(finalResults[1] === 'Custom error handled', 'Second result should handle custom error');\nassert(finalResults[2] === 'Operation successful', 'Third result should be successful');", "gpt-4o-copilot": "    assert.deepStrictEqual(finalResults, ['Custom error handled', 'Operation successful', 'Custom error handled']);"}
{"id": "4", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { assert } from 'chai';\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    roles: string[];\n}\n\ninterface Admin extends User {\n    adminSince: Date;\n}\n\ninterface Guest extends User {\n    guestExpiration: Date;\n}\n\ntype UserType = Admin | Guest;\n\nfunction isAdmin(user: UserType): user is Admin {\n    return (user as Admin).adminSince !== undefined;\n}\n\nfunction isGuest(user: UserType): user is Guest {\n    return (user as Guest).guestExpiration !== undefined;\n}\n\nconst users: UserType[] = [\n    { id: 1, name: 'Alice', email: 'alice@example.com', roles: ['user'], adminSince: new Date('2020-01-01') },\n    { id: 2, name: 'Bob', email: 'bob@example.com', roles: ['guest'], guestExpiration: new Date('2022-01-01') },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com', roles: ['user', 'admin'], adminSince: new Date('2019-06-15') },\n    { id: 4, name: 'David', email: 'david@example.com', roles: ['guest'], guestExpiration: new Date('2021-12-31') }\n];\n\nfunction getUserRoles(user: UserType): string {\n    if (isAdmin(user)) {\n        return `Admin since: ${user.adminSince.toDateString()}`;\n    } else if (isGuest(user)) {\n        return `Guest until: ${user.guestExpiration.toDateString()}`;\n    } else {\n        return 'Regular User';\n    }\n}\n\n// The following code needs to be completed to handle more complex conditions\nfunction getUserInfo(user: UserType): string {\n    let info = `User Info: ${user.name} (${user.email})\\nRoles: ${user.roles.join(', ')}`;\n", "suffix": "\n    return info;\n}\n\n// Test cases\nconst userInfo1 = getUserInfo(users[0]);\nassert.include(userInfo1, 'Admin since', 'Admin user should display admin information');\nconst userInfo2 = getUserInfo(users[1]);\nassert.include(userInfo2, 'Guest until', 'Guest user should display guest information');\nconst userInfo3 = getUserInfo(users[2]);\nassert.include(userInfo3, 'Admin since', 'Admin user should display admin information');\nconst userInfo4 = getUserInfo(users[3]);\nassert.include(userInfo4, 'Guest until', 'Guest user should display guest information');\n", "golden_completion": "\n    if (isAdmin(user)) {\n        info += `\\nAdmin since: ${user.adminSince.toDateString()}`;\n    } else if (isGuest(user)) {\n        info += `\\nGuest until: ${user.guestExpiration.toDateString()}`;\n    }\n", "LLM_justification": "This test case evaluates the LLM's ability to complete nested control structures, specifically if/else conditions with type guards, within a TypeScript function. The completion must handle different user types (Admin and Guest) and append relevant information to the user info string accordingly. This scenario tests the LLM's understanding of TypeScript-specific syntax, type guards, and correct handling of conditional logic based on type checks.", "assertions": "assert.include(getUserInfo(users[0]), 'Admin since', 'Admin user should display admin information');\nassert.include(getUserInfo(users[1]), 'Guest until', 'Guest user should display guest information');\nassert.include(getUserInfo(users[2]), 'Admin since', 'Admin user should display admin information');\nassert.include(getUserInfo(users[3]), 'Guest until', 'Guest user should display guest information');", "gpt-4o-copilot": "    info += `\\n${getUserRoles(user)}`;"}
{"id": "5", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n// Utility function to simulate a delayed promise\nfunction delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Custom error classes\nclass NetworkError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'NetworkError';\n    }\n}\n\nclass DatabaseError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'DatabaseError';\n    }\n}\n\n// Example function that simulates network and database operations\nasync function fetchData(): Promise<string> {\n    await delay(1000); // Simulate network delay\n    if (Math.random() > 0.5) {\n        throw new NetworkError('Failed to fetch data from the network');\n    }\n    return 'Network data';\n}\n\nasync function saveData(data: string): Promise<void> {\n    await delay(500); // Simulate database delay\n    if (Math.random() > 0.5) {\n        throw new DatabaseError('Failed to save data to the database');\n    }\n}\n\n// Main function demonstrating nested try/catch with multiple catch blocks\nasync function processData() {\n    let data: string = '';\n    try {\n        data = await fetchData();\n", "suffix": "    } catch (error) {\n        if (error instanceof NetworkError) {\n            console.error('Network error:', error.message);\n        } else {\n            console.error('Unexpected error:', error);\n        }\n    }\n    if (data) {\n        try {\n            await saveData(data);\n            console.log('Data saved successfully');\n        } catch (error) {\n            if (error instanceof DatabaseError) {\n                console.error('Database error:', error.message);\n            } else {\n                console.error('Unexpected error:', error);\n            }\n        }\n    }\n}\n\n// Execute the main function and handle any unexpected errors\nprocessData().catch(error => console.error('Unhandled error:', error));\n", "golden_completion": "        try {\n            await saveData(data);\n            console.log('Data saved successfully');\n        } catch (error) {\n            if (error instanceof DatabaseError) {\n                console.error('Database error:', error.message);\n            } else {\n                console.error('Unexpected error:', error);\n            }\n        }\n", "LLM_justification": "This test case is a good example of nested control structures in TypeScript, specifically demonstrating nested try/catch blocks with multiple catch conditions. It tests the model's ability to handle complex error handling patterns while maintaining proper syntax and indentation. The use of custom error classes and asynchronous functions adds realism to the scenario, making it a comprehensive test of the model's completion capabilities.", "assertions": "import { strict as assert } from 'assert';\n\n(async function testProcessData() {\n    let consoleOutput: string[] = [];\n    const originalConsoleError = console.error;\n    const originalConsoleLog = console.log;\n    console.error = (message: string) => consoleOutput.push(`error: ${message}`);\n    console.log = (message: string) => consoleOutput.push(`log: ${message}`);\n\n    try {\n        await processData();\n        assert(consoleOutput.includes('log: Data saved successfully') || consoleOutput.some(msg => msg.startsWith('error: Network error:')) || consoleOutput.some(msg => msg.startsWith('error: Database error:')));\n    } finally {\n        console.error = originalConsoleError;\n        console.log = originalConsoleLog;\n    }\n})();\n", "gpt-4o-copilot": "    } catch (error) {\n        console.error('Error fetching data:', error);"}
{"id": "6", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\ninterface User {\n\tid: number;\n\tname: string;\n\temail: string;\n}\n\ninterface ApiResponse<T> {\n\tstatus: number;\n\tdata: T;\n}\n\nfunction fetchUser(userId: number): Promise<ApiResponse<User>> {\n\treturn new Promise((resolve, reject) => {\n\t\t// Simulating an API call\n\t\tsetTimeout(() => {\n\t\t\tif (userId === 1) {\n\t\t\t\tresolve({ status: 200, data: { id: 1, name: 'John Doe', email: 'john.doe@example.com' } });\n\t\t\t} else {\n\t\t\t\treject(new Error('User not found'));\n\t\t\t}\n\t\t}, 1000);\n\t});\n}\n\nasync function getUserData(userId: number): Promise<string> {\n\ttry {\n\t\tconst response = await fetchUser(userId);\n\t\tif (response.status === 200) {\n\t\t\treturn `User: ${response.data.name}, Email: ${response.data.email}`;\n\t\t} else {\n\t\t\tthrow new Error('Failed to fetch user data');\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\treturn `Error: ${error.message}`;\n\t\t} else {\n\t\t\treturn 'Unknown error occurred';\n\t\t}\n\t} finally {\n\t\tconsole.log('Fetch user data attempt completed');\n\t}\n}\n\nasync function main() {\n\tconst userId = 1;\n\tconst result = await getUserData(userId);\n\tassert.strictEqual(result, 'User: John Doe, Email: john.doe@example.com');\n\tconsole.log(result);\n}\n", "suffix": "\n\nasync function anotherUserFunction() {\n\tconst userId = 2;\n\tconst result = await getUserData(userId);\n\tassert.strictEqual(result, 'Error: User not found');\n\tconsole.log(result);\n}\nanotherUserFunction().catch(err => console.error(err));", "golden_completion": "\nmain().catch(err => console.error(err));\n\n", "LLM_justification": "This test case is a good example because it demonstrates the use of nested control structures, including try/catch blocks with async/await patterns, proper error handling with typed errors, and promise handling. The code also includes assertions to verify the correctness of the results. The completion must maintain proper indentation and syntax consistency. It checks the LLM's ability to handle nested and complex control flow structures unique to TypeScript.", "assertions": "assert.strictEqual(await getUserData(1), 'User: John Doe, Email: john.doe@example.com');\nassert.strictEqual(await getUserData(2), 'Error: User not found');", "gpt-4o-copilot": "main().catch(err => console.error(err));"}
{"id": "7", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n// Define a basic interface with generics\ninterface Response<T> {\n    data: T;\n    status: number;\n    error?: string;\n}\n\n// Create a function that fetches data and returns a Promise<Response<T>>\nasync function fetchData<T>(url: string): Promise<Response<T>> {\n    const response = await fetch(url);\n    const data = await response.json();\n    if (response.ok) {\n        return {\n            data,\n            status: response.status,\n        };\n    } else {\n        return {\n            data: data as T,\n            status: response.status,\n            error: data.message,\n        };\n    }\n}\n\n// A function that performs some business logic and handles async/await\nasync function processData(url: string) {\n    try {\n        const result = await fetchData<{name: string; age: number;}>(url);\n        if (result.error) {\n            throw new Error(result.error);\n        }\n        return result.data;\n    } catch (error) {\n        console.error('Error processing data:', error);\n        throw error;\n    }\n}\n\n// A utility function to validate the fetched data\nfunction validateData(data: {name: string; age: number;}): boolean {\n    return typeof data.name === 'string' && typeof data.age === 'number';\n}\n\n// Example usage of the processData function with error handling\n(async () => {\n    const testUrl = 'https://api.example.com/user';\n    try {\n        const userData = await processData(testUrl);\n        if (validateData(userData)) {\n            console.log('User data is valid:', userData);\n        } else {\n            console.error('Invalid user data:', userData);\n        }\n        ", "suffix": "console.log('Data processing complete');\n    } catch (e) {\n        console.error('Failed to process data:', e);\n    }\n})();\n", "golden_completion": "assert(validateData(userData), 'Fetched data validation failed');\n", "LLM_justification": "This example tests the LLM's ability to complete an async/await pattern with proper typing. It includes error handling and type validation, which are critical in TypeScript. The example ensures that the LLM understands the context of validating fetched data and asserting its correctness before proceeding. The assertion verifies type correctness and structural integrity of the fetched data.", "assertions": "assert(validateData({ name: 'John Doe', age: 30 }), 'Static data validation failed');\n(async () => {\n    const testUrl = 'https://api.example.com/user';\n    const userData = await processData(testUrl);\n    assert(validateData(userData), 'Fetched data validation failed');\n})();", "gpt-4o-copilot": "    } finally {"}
{"id": "8", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { assert } from 'assert';\n\ninterface User {\n\tid: number;\n\tname: string;\n\tage: number;\n}\n\ninterface Admin extends User {\n\trole: string;\n}\n\nclass Person {\n\tprotected name: string;\n\tprotected age: number;\n\n\tconstructor(name: string, age: number) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\n\tgetDetails(): string {\n\t\treturn `${this.name}, ${this.age} years old`;\n\t}\n}\n\nclass Administrator extends Person implements Admin {\n\tid: number;\n\trole: string;\n\n\tconstructor(id: number, name: string, age: number, role: string) {\n\t\tsuper(name, age);\n\t\tthis.id = id;\n\t\tthis.role = role;\n\t}\n\n\tgetDetails(): string {\n\t\treturn `${super.getDetails()}, Role: ${this.role}`;\n\t}\n}\n\nconst person = new Person('Alice', 30);\nconst admin = new Administrator(1, 'Bob', 40, 'Manager');\n\nconsole.log(person.getDetails()); // Output: Alice, 30 years old\nconsole.log(admin.getDetails()); // Output: Bob, 40 years old, Role: Manager\n\nfunction isAdmin(user: User): user is Admin {\n\treturn (user as Admin).role !== undefined;\n}\n\nconst users: User[] = [\n\t{id: 1, name: 'Alice', age: 30},\n\t{id: 2, name: 'Bob', age: 40, role: 'Manager'} as Admin,\n\t{id: 3, name: 'Charlie', age: 35}\n];\n\nconst adminUsers = users.filter(isAdmin);\nconsole.log(adminUsers); // Output: [{id: 2, name: 'Bob', age: 40, role: 'Manager'}]\n", "suffix": "console.log(nonAdminUsers); // Output: [{id: 1, name: 'Alice', age: 30}, {id: 3, name: 'Charlie', age: 35}]\n\n// Assertions\ndeclare const assert: any;\nassert(adminUsers.length === 1);\nassert(adminUsers[0].role === 'Manager');\nassert(nonAdminUsers.length === 2);\nassert(nonAdminUsers[0].name === 'Alice');\nassert(nonAdminUsers[1].name === 'Charlie');\n", "golden_completion": "const nonAdminUsers = users.filter(user => !isAdmin(user));", "LLM_justification": "This test case is a good example of complex TypeScript syntax patterns involving class inheritance, type guards, and array filtering with type predicates. It tests the model's ability to handle advanced TypeScript features like type assertions, type guards, and interfaces with extending classes. The assertions verify the correctness of filtering logic and type guard application.", "assertions": "assert(adminUsers.length === 1);\nassert(adminUsers[0].role === 'Manager');\nassert(nonAdminUsers.length === 2);\nassert(nonAdminUsers[0].name === 'Alice');\nassert(nonAdminUsers[1].name === 'Charlie');", "gpt-4o-copilot": "const nonAdminUsers = users.filter(user => !isAdmin(user));"}
{"id": "9", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\ninterface Admin extends User {\n    role: 'admin';\n}\n\ninterface Guest extends User {\n    role: 'guest';\n}\n\n// Type guard to check if the user is an Admin\nfunction isAdmin(user: User): user is Admin {\n    return (user as Admin).role === 'admin';\n}\n\n// Type guard to check if the user is a Guest\nfunction isGuest(user: User): user is Guest {\n    return (user as Guest).role === 'guest';\n}\n\nclass UserManager {\n    private users: User[] = [];\n\n    constructor(initialUsers: User[]) {\n        this.users = initialUsers;\n    }\n\n    addUser(user: User): void {\n        this.users.push(user);\n    }\n\n    getUserById(id: number): User | undefined {\n        return this.users.find(user => user.id === id);\n    }\n\n    getAdmins(): Admin[] {\n        return this.users.filter(isAdmin);\n    }\n\n    getGuests(): Guest[] {\n        return this.users.filter(isGuest);\n    }\n}\n\nconst initialUsers: User[] = [\n    { id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' },\n    { id: 2, name: 'Bob', email: 'bob@example.com', role: 'guest' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com', role: 'admin' }\n];\n\nconst userManager = new UserManager(initialUsers);\n\n// Check initial state of users\nassert.strictEqual(userManager.getAdmins().length, 2);\nassert.strictEqual(userManager.getGuests().length, 1);\n\n// Add a new user\nconst newUser: User = { id: 4, name: 'Dave', email: 'dave@example.com', role: 'guest' };\nuserManager.addUser(newUser);\n\n// Assertions after adding a new user\nassert.strictEqual(userManager.getUserById(4)?.name, 'Dave');\nassert.strictEqual(userManager.getGuests().length, 2);\n\n// Testing type guards\nconst adminUser: User = { id: 5, name: 'Eve', email: 'eve@example.com', role: 'admin' };\nconst guestUser: User = { id: 6, name: 'Frank', email: 'frank@example.com', role: 'guest' };\n\nassert.strictEqual(isAdmin(adminUser), true);\nassert.strictEqual(isGuest(guestUser), true);\nassert.strictEqual(isAdmin(guestUser), false);\n\n// Start of golden completion\n", "suffix": "\n\n// Add another user and check\nconst anotherUser: User = { id: 7, name: 'George', email: 'george@example.com', role: 'guest' };\nuserManager.addUser(anotherUser);\nassert.strictEqual(userManager.getGuests().length, 3);\nassert.strictEqual(userManager.getUserById(7)?.email, 'george@example.com');\n\nconsole.log('All assertions passed.');", "golden_completion": "assert.strictEqual(isGuest(adminUser), false);\n\n// Additional assertions for type guards\nassert.strictEqual(isAdmin({ id: 8, name: 'Hank', email: 'hank@example.com', role: 'guest' }), false);\nassert.strictEqual(isGuest({ id: 9, name: 'Ivy', email: 'ivy@example.com', role: 'admin' }), false);\n", "LLM_justification": "This test case provides a comprehensive examination of advanced type operations and type guards in TypeScript. By defining interfaces with type guards and testing them with various user roles, it checks the LLM's ability to correctly implement and utilize type guards. The scenario includes nested and complex type annotations with extensive assertions to ensure type correctness and proper implementation. The completion section focuses on filling in additional assertions to test type guard functionality, which is crucial for verifying the LLM's understanding of TypeScript's type system.", "assertions": "assert.strictEqual(isGuest(adminUser), false);\nassert.strictEqual(isAdmin({ id: 8, name: 'Hank', email: 'hank@example.com', role: 'guest' }), false);\nassert.strictEqual(isGuest({ id: 9, name: 'Ivy', email: 'ivy@example.com', role: 'admin' }), false);\n", "gpt-4o-copilot": "assert.strictEqual(userManager.getAdmins().length, 2);\nassert.strictEqual(userManager.getGuests().length, 3);"}
{"id": "10", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\ninterface User {\n\tid: number;\n\tname: string;\n\temail: string;\n}\n\ninterface Admin extends User {\n\tadminSince: Date;\n}\n\ninterface Guest extends User {\n\tvisitDate: Date;\n}\n\ntype UserType = Admin | Guest;\n\nfunction isUserType(user: any): user is UserType {\n\treturn 'id' in user && 'name' in user && 'email' in user && ('adminSince' in user || 'visitDate' in user);\n}\n\nclass UserManager<T extends UserType> {\n\tprivate users: T[] = [];\n\n\taddUser(user: T): void {\n\t\tif (isUserType(user)) {\n\t\t\tthis.users.push(user);\n\t\t} else {\n\t\t\tthrow new Error('Invalid user type');\n\t\t}\n\t}\n\n\tgetUserById(id: number): T | undefined {\n\t\treturn this.users.find(user => user.id === id);\n\t}\n\n\tremoveUser(id: number): void {\n\t\tthis.users = this.users.filter(user => user.id !== id);\n\t}\n\n\tlistUsers(): T[] {\n\t\treturn this.users;\n\t}\n}\n\nconst adminManager = new UserManager<Admin>();\nconst guestManager = new UserManager<Guest>();\n\nadminManager.addUser({ id: 1, name: 'Alice', email: 'alice@example.com', adminSince: new Date() });\nguestManager.addUser({ id: 2, name: 'Bob', email: 'bob@example.com', visitDate: new Date() });\n\ntry {\n\tconst adminUser = adminManager.getUserById(1);\n\tconst guestUser = guestManager.getUserById(2);\n\tif (adminUser) {\n\t\tconsole.log('Admin User:', adminUser);\n\t}\n\tif (guestUser) {\n\t\tconsole.log('Guest User:', guestUser);\n\t}\n\tadminManager.removeUser(1);\n\tguestManager.removeUser(2);\n\tconsole.log('Users after removal:');\n\tconsole.log('Admins:', adminManager.listUsers());\n\tconsole.log('Guests:', guestManager.listUsers());\n} catch (error) {\n\tconsole.error('An error occurred:', error);\n}\n", "suffix": "\nconsole.log('All operations completed.');\n", "golden_completion": "\nadminManager.addUser({ id: 3, name: 'Charlie', email: 'charlie@example.com', adminSince: new Date() });\nguestManager.addUser({ id: 4, name: 'Dave', email: 'dave@example.com', visitDate: new Date() });\n", "LLM_justification": "This test case checks the understanding of TypeScript's advanced type operations (unions, intersections, type guards) and class inheritance with typed parameters. The prefix sets up a complex scenario with multiple interfaces, type guards, and class methods, which are extended by the golden completion. The suffix continues with different operations, ensuring that the completion is distinct and properly integrated within the existing structure.", "assertions": "import assert from 'assert';\n\nconst adminUser = adminManager.getUserById(3);\nconst guestUser = guestManager.getUserById(4);\n\nassert(adminUser !== undefined, 'Admin user should be defined');\nassert(adminUser?.name === 'Charlie', 'Admin user name should be Charlie');\nassert(guestUser !== undefined, 'Guest user should be defined');\nassert(guestUser?.name === 'Dave', 'Guest user name should be Dave');\n", "gpt-4o-copilot": "fs.writeFileSync('users.json', JSON.stringify({ admins: adminManager.listUsers(), guests: guestManager.listUsers() }));"}
{"id": "11", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n// Define a generic interface for a repository\ninterface Repository<T> {\n    getById(id: string): T | null;\n    save(item: T): void;\n}\n\n// Define a User type\ninterface User {\n    id: string;\n    name: string;\n    email: string;\n}\n\n// Implement a UserRepository using the Repository interface\nclass UserRepository implements Repository<User> {\n    private users: User[] = [];\n\n    getById(id: string): User | null {\n        return this.users.find(user => user.id === id) || null;\n    }\n\n    save(user: User): void {\n        const existingUserIndex = this.users.findIndex(u => u.id === user.id);\n        if (existingUserIndex !== -1) {\n            this.users[existingUserIndex] = user;\n        } else {\n            this.users.push(user);\n        }\n    }\n}\n\n// Define a generic service class\nclass Service<T> {\n    constructor(protected repository: Repository<T>) {}\n\n    getById(id: string): T | null {\n        return this.repository.getById(id);\n    }\n\n    save(item: T): void {\n        this.repository.save(item);\n    }\n}\n\n// Implement a UserService extending the generic Service class\nclass UserService extends Service<User> {\n    constructor(repository: UserRepository) {\n        super(repository);\n    }\n\n    // Custom method to find users by email\n    findByEmail(email: string): User | null {\n        return this.repository.getById(email) as User;\n    }\n}\n\n// Instantiate UserRepository and UserService\nconst userRepository = new UserRepository();\nconst userService = new UserService(userRepository);\n\n// Add some users to the repository\nuserService.save({ id: '1', name: 'Alice', email: 'alice@example.com' });\nuserService.save({ id: '2', name: 'Bob', email: 'bob@example.com' });\n\n// Use the service to fetch users\nconst user1 = userService.getById('1');\nconst user2 = userService.getById('2');\n\n// Find by email\n", "suffix": "const user3 = userService.getById('3');\n\n// Assertions\nassert(user1 !== null && user1.name === 'Alice');\nassert(user2 !== null && user2.name === 'Bob');\nassert(user3 === null);\n\n// Clean up resources\nuserService.save = function () {};\nuserRepository.save = function () {};\nuserRepository.getById = function () { return null; };\n", "golden_completion": "const userByEmail = userService.findByEmail('alice@example.com');\n\n// Assertions\n", "LLM_justification": "This test case evaluates the LLM's ability to handle complex TypeScript syntax involving class inheritance, generic types, and method overriding. The prefix sets up a realistic scenario with a generic repository and service pattern, while the golden completion requires the LLM to correctly implement and use a method specific to the subclass. This tests not only syntactic correctness but also an understanding of TypeScript's type system and class inheritance.", "assertions": "assert(userByEmail !== null && userByEmail.name === 'Alice');", "gpt-4o-copilot": "const user3 = userService.findByEmail('charlie@example.com');"}
{"id": "12", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n// Define a generic interface for a key-value pair\ninterface KeyValuePair<K, V> {\n    key: K;\n    value: V;\n}\n\n// Define a class that implements the KeyValuePair interface\nclass Pair<K, V> implements KeyValuePair<K, V> {\n    constructor(public key: K, public value: V) {}\n}\n\n// Define a generic function that takes two pairs and returns a new pair with merged keys and values\nfunction mergePairs<K1, V1, K2, V2>(pair1: KeyValuePair<K1, V1>, pair2: KeyValuePair<K2, V2>): KeyValuePair<[K1, K2], [V1, V2]> {\n    return new Pair(\n        [pair1.key, pair2.key],\n        [pair1.value, pair2.value]\n    );\n}\n\n// Define a class that holds a collection of pairs\nclass PairCollection<K, V> {\n    private pairs: KeyValuePair<K, V>[] = [];\n\n    // Add a pair to the collection\n    addPair(pair: KeyValuePair<K, V>): void {\n        this.pairs.push(pair);\n    }\n\n    // Get a pair by index\n    getPair(index: number): KeyValuePair<K, V> | undefined {\n        return this.pairs[index];\n    }\n\n    // Merge all pairs in the collection\n    mergeAllPairs(): KeyValuePair<K[], V[]> {\n        const keys: K[] = [];\n        const values: V[] = [];\n        for (const pair of this.pairs) {\n            keys.push(pair.key);\n            values.push(pair.value);\n        }\n        return new Pair(keys, values);\n    }\n}\n\n// Create some pairs\nconst pair1 = new Pair('key1', 1);\nconst pair2 = new Pair('key2', 2);\nconst pair3 = new Pair('key3', 3);\n\n// Create a pair collection and add pairs to it\nconst pairCollection = new PairCollection<string, number>();\npairCollection.addPair(pair1);\npairCollection.addPair(pair2);\npairCollection.addPair(pair3);\n\n// Merge all pairs in the collection\nconst mergedPair = pairCollection.mergeAllPairs();\n\n// Assertions to verify the correctness of the merged pair\nassert.deepStrictEqual(mergedPair.key, ['key1', 'key2', 'key3']);\nassert.deepStrictEqual(mergedPair.value, [1, 2, 3]);\n", "suffix": "\n\n// Create a new merged pair from two existing pairs\nconst newMergedPair = mergePairs(pair1, pair2);\nassert.deepStrictEqual(newMergedPair.key, ['key1', 'key2']);\nassert.deepStrictEqual(newMergedPair.value, [1, 2]);\n", "golden_completion": "assert.deepStrictEqual(pairCollection.getPair(0), pair1);\nassert.deepStrictEqual(pairCollection.getPair(1), pair2);\nassert.deepStrictEqual(pairCollection.getPair(2), pair3);\n\n", "LLM_justification": "This test case demonstrates the use of complex TypeScript syntax features, including generics in interfaces and classes, along with advanced type operations. The prefix sets up a comprehensive context with type definitions, class implementations, and a generic function. The completion requires understanding of how to work with these types and maintain proper typing and structure. Assertions ensure that the behavior is correct, and the suffix continues with additional assertions to verify the integrity of the entire structure.", "assertions": "assert.deepStrictEqual(mergedPair.key, ['key1', 'key2', 'key3']);\nassert.deepStrictEqual(mergedPair.value, [1, 2, 3]);\nassert.deepStrictEqual(pairCollection.getPair(0), pair1);\nassert.deepStrictEqual(pairCollection.getPair(1), pair2);\nassert.deepStrictEqual(pairCollection.getPair(2), pair3);\nassert.deepStrictEqual(newMergedPair.key, ['key1', 'key2']);\nassert.deepStrictEqual(newMergedPair.value, [1, 2]);\n", "gpt-4o-copilot": "console.log('All assertions passed.');"}
{"id": "13", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import * as fs from 'fs';\n\ninterface FileWriter {\n\twrite(content: string): FileWriter;\n\tappend(content: string): FileWriter;\n\tclose(): void;\n}\n\nclass FileWriterImpl implements FileWriter {\n\tprivate fileDescriptor: number;\n\n\tconstructor(filePath: string) {\n\t\tthis.fileDescriptor = fs.openSync(filePath, 'w');\n\t}\n\n\twrite(content: string): FileWriter {\n\t\tfs.writeSync(this.fileDescriptor, content);\n\t\treturn this;\n\t}\n\n\tappend(content: string): FileWriter {\n\t\tfs.writeSync(this.fileDescriptor, content);\n\t\treturn this;\n\t}\n\n\tclose(): void {\n\t\tfs.closeSync(this.fileDescriptor);\n\t}\n}\n\nfunction createFileWriter(filePath: string): FileWriter {\n\treturn new FileWriterImpl(filePath);\n}\n\n// Usage example\nconst writer = createFileWriter('example.txt');\n", "suffix": "writer.append(' More text.').close();\n\n// Assertions\nimport assert from 'assert';\n\nconst writtenContent = fs.readFileSync('example.txt', 'utf8');\nassert.strictEqual(writtenContent, 'Hello, World! More text.');\n\n// Cleanup\nfs.unlinkSync('example.txt');\n", "golden_completion": "writer.write('Hello, World!').", "LLM_justification": "This test case checks the ability of the LLM to handle fluent interface structures with proper return types. The prefix sets up a file writer class with a fluent interface, allowing method chaining. The golden completion requires the LLM to correctly use method chaining to write content to a file. The suffix verifies the correctness of the written content and performs cleanup. This scenario tests the LLM's understanding of method chaining, type inference, and proper resource management.", "assertions": "const writtenContent = fs.readFileSync('example.txt', 'utf8');\nassert.strictEqual(writtenContent, 'Hello, World! More text.');", "gpt-4o-copilot": "writer.write('Hello, World!');"}
{"id": "14", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n// Define a custom error class hierarchy\nclass CustomError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nclass NotFoundError extends CustomError {\n    constructor(message: string) {\n        super(message);\n        this.name = 'NotFoundError';\n    }\n}\n\nclass ValidationError extends CustomError {\n    constructor(message: string) {\n        super(message);\n        this.name = 'ValidationError';\n    }\n}\n\n// Function that simulates some operations and may throw custom errors\nfunction riskyOperation(shouldFail: boolean): string {\n    if (shouldFail) {\n        throw new ValidationError('Validation failed');\n    }\n    return 'Success';\n}\n\n// Function to handle errors and perform transformations\nfunction handleError(error: unknown): string {\n    if (error instanceof ValidationError) {\n        return `Handled ValidationError: ${error.message}`;\n    } else if (error instanceof NotFoundError) {\n        return `Handled NotFoundError: ${error.message}`;\n    } else if (error instanceof CustomError) {\n        return `Handled CustomError: ${error.message}`;\n    }\n    return 'Unhandled error';\n}\n\n// Function that wraps the risky operation and handles errors\nfunction performOperation(shouldFail: boolean): string {\n    try {\n        const result = riskyOperation(shouldFail);\n        return result;\n    } catch (error) {", "suffix": "    }\n}\n\n// Assertions to verify the behavior of the performOperation function\nassert.strictEqual(performOperation(false), 'Success', 'Expected operation to succeed');\nassert.strictEqual(performOperation(true), 'Handled ValidationError: Validation failed', 'Expected a handled validation error');\n\n// Cleanup code (if any) would go here\n\nconsole.log('All assertions passed.');", "golden_completion": "        const errorMessage = handleError(error);\n        console.error(errorMessage);\n        return errorMessage;", "LLM_justification": "This test case is a good example because it covers custom error handling with a hierarchy of errors, and it includes proper type guards and error transformation patterns. The golden completion demonstrates a complex multi-line try/catch structure, error transformation, and nesting. Assertions validate that the function handles both success and error cases correctly, ensuring type safety and proper exception management.", "assertions": "assert.strictEqual(performOperation(false), 'Success', 'Expected operation to succeed');\nassert.strictEqual(performOperation(true), 'Handled ValidationError: Validation failed', 'Expected a handled validation error');", "gpt-4o-copilot": "        return handleError(error);"}
{"id": "15", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n// Define a custom error class hierarchy\nclass CustomError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'CustomError';\n\t}\n}\n\nclass NotFoundError extends CustomError {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NotFoundError';\n\t}\n}\n\nclass ValidationError extends CustomError {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ValidationError';\n\t}\n}\n\n// Error transformation function\nfunction transformError(error: any): CustomError {\n\tif (error instanceof NotFoundError) {\n\t\treturn new CustomError(`Resource not found: ${error.message}`);\n\t} else if (error instanceof ValidationError) {\n\t\treturn new CustomError(`Validation failed: ${error.message}`);\n\t} else {\n\t\treturn new CustomError(`Unknown error: ${error.message}`);\n\t}\n}\n\n// Simulated function that may throw different errors\nfunction riskyOperation(value: string): string {\n\tif (value === 'notfound') {\n\t\tthrow new NotFoundError('The requested item was not found');\n\t} else if (value === 'invalid') {\n\t\tthrow new ValidationError('The provided value is invalid');\n\t}\n\treturn `Processed value: ${value}`;\n}\n\n// Function that handles errors from riskyOperation\nfunction handleRiskyOperation(value: string): string {\n\ttry {\n\t\treturn riskyOperation(value);\n\t} catch (error) {\n\t\tconst transformedError = transformError(error);\n\t\tthrow transformedError;\n\t} finally {\n\t\tconsole.log('Cleanup resources if any');\n\t}\n}\n\n// Test cases\ntry {\n\tassert.strictEqual(handleRiskyOperation('valid'), 'Processed value: valid');\n} catch (error) {\n\tassert.fail(`Unexpected error: ${error.message}`);\n}\n", "suffix": "\n\ntry {\n\tassert.strictEqual(handleRiskyOperation('invalid'), '');\n} catch (error) {\n\tassert.strictEqual(error instanceof CustomError, true);\n\tassert.strictEqual(error.message, 'Validation failed: The provided value is invalid');\n}\n\nconsole.log('All tests passed');\n", "golden_completion": "try {\n\tassert.strictEqual(handleRiskyOperation('notfound'), '');\n} catch (error) {\n\tassert.strictEqual(error instanceof CustomError, true);\n\tassert.strictEqual(error.message, 'Resource not found: The requested item was not found');\n}\n\n", "LLM_justification": "This scenario tests the LLM's ability to complete complex syntactical structures related to custom error hierarchies and error transformation patterns with type guards. It ensures proper handling of different error types, transforming them accordingly, and includes assertions to validate the correctness of the transformation and error handling logic. The completion requires understanding of custom error classes, try/catch/finally blocks, and type guards, making it a robust test for TypeScript syntax and type system comprehension.", "assertions": "assert.strictEqual(handleRiskyOperation('valid'), 'Processed value: valid');\ntry {\n\thandleRiskyOperation('notfound');\n} catch (error) {\n\tassert.strictEqual(error instanceof CustomError, true);\n\tassert.strictEqual(error.message, 'Resource not found: The requested item was not found');\n}\ntry {\n\thandleRiskyOperation('invalid');\n} catch (error) {\n\tassert.strictEqual(error instanceof CustomError, true);\n\tassert.strictEqual(error.message, 'Validation failed: The provided value is invalid');\n}\nconsole.log('All assertions passed');\n", "gpt-4o-copilot": "try {\n\tassert.strictEqual(handleRiskyOperation('notfound'), '');\n} catch (error) {\n\tassert.strictEqual(error instanceof CustomError, true);\n\tassert.strictEqual(error.message, 'Resource not found: The requested item was not found');\n}"}
{"id": "16", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import * as fs from 'fs';\n\ninterface Config {\n\tpath: string;\n\tencoding: BufferEncoding;\n}\n\nclass FileManager {\n\tprivate config: Config;\n\n\tconstructor(config: Config) {\n\t\tthis.config = config;\n\t}\n\n\tpublic read(): Promise<string> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.readFile(this.config.path, this.config.encoding, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic write(data: string): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.writeFile(this.config.path, data, this.config.encoding, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nconst config: Config = {\n\tpath: './test.txt',\n\tencoding: 'utf-8'\n};\n\nconst fileManager = new FileManager(config);\n\n// Usage example\nasync function example() {\n\ttry {\n\t\tawait fileManager.write('Hello, World!');\n\t\tconst content = await fileManager.read();\n\t\tconsole.log(content);\n\t} catch (error) {\n\t\tconsole.error('Error:', error);\n\t}\n}\n\nexample();\n\n// Cleanup\nfunction cleanup() {\n\tfs.unlinkSync(config.path);\n}\n\nprocess.on('exit', cleanup);\nprocess.on('SIGINT', cleanup);", "suffix": "async function testErrorHandling() {\n\ttry {\n\t\tawait fileManager.write('This should trigger an error');\n\t\tawait fileManager.read();\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tconsole.log('Caught error:', error.message);\n\t\t} else {\n\t\t\tconsole.log('Caught unknown error');\n\t\t}\n\t} finally {\n\t\tconsole.log('Cleaning up resources...');\n\t\tcleanup();\n\t}\n}\n\ntestErrorHandling();", "golden_completion": "async function testFileManager() {\n\ttry {\n\t\tawait fileManager.write('Testing FileManager');\n\t\tconst content = await fileManager.read();\n\t\tconsole.log('Content:', content);\n\t} catch (error) {\n\t\tconsole.error('Error:', error);\n\t} finally {\n\t\tcleanup();\n\t}\n}\n\ntestFileManager();", "LLM_justification": "This test case is designed to assess an LLM's capability to complete a complex TypeScript pattern involving async/await, proper error handling, and resource cleanup using try/catch/finally blocks. The completion should demonstrate understanding of error handling and resource management patterns, including the use of proper type annotations and the correct sequencing of operations. The prefix provides extensive context with a FileManager class, config setup, and an example usage. The suffix tests error handling with a different scenario, ensuring no duplication of the golden completion.", "assertions": "import { strict as assert } from 'assert';\n\nasync function runTests() {\n\tconst config: Config = {\n\t\tpath: './test.txt',\n\t\tencoding: 'utf-8'\n\t};\n\tconst fileManager = new FileManager(config);\n\n\tawait fileManager.write('Test Content');\n\tconst content = await fileManager.read();\n\tassert.equal(content, 'Test Content');\n\n\ttry {\n\t\tawait fileManager.write('Error Test');\n\t\tawait fileManager.read();\n\t} catch (error) {\n\t\tassert.ok(error instanceof Error);\n\t}\n}\n\nrunTests().then(() => console.log('All tests passed')).catch(err => console.error('Tests failed', err));", "gpt-4o-copilot": "}#TODO: You Code Here"}
{"id": "17", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from \"assert\";\n\nclass ApiError extends Error {\n    public code: number;\n    constructor(message: string, code: number) {\n        super(message);\n        this.code = code;\n        this.name = \"ApiError\";\n    }\n}\n\nclass NotFoundError extends ApiError {\n    constructor(message: string) {\n        super(message, 404);\n    }\n}\n\nclass ValidationError extends ApiError {\n    constructor(message: string) {\n        super(message, 400);\n    }\n}\n\nclass User {\n    constructor(public id: number, public name: string) {}\n}\n\nclass UserService {\n    private users: User[] = [];\n\n    addUser(user: User): this {\n        this.users.push(user);\n        return this;\n    }\n\n    getUser(id: number): User {\n        const user = this.users.find(u => u.id === id);\n        if (!user) {\n            throw new NotFoundError(`User with id ${id} not found`);\n        }\n        return user;\n    }\n\n    validateUser(user: User): void {\n        if (!user.name) {\n            throw new ValidationError(\"User name is required\");\n        }\n    }\n\n    saveUser(user: User): this {\n        this.validateUser(user);\n        return this.addUser(user);\n    }\n}\n\nconst userService = new UserService();\n\ntry {\n    userService", "suffix": ".getUser(1);\n} catch (error) {\n    if (error instanceof NotFoundError) {\n        console.error(`NotFoundError: ${error.message}`);\n    } else if (error instanceof ValidationError) {\n        console.error(`ValidationError: ${error.message}`);\n    } else {\n        console.error(`Unexpected error: ${error.message}`);\n    }\n} finally {\n    console.log(\"Operation complete\");\n}\n\nassert(userService instanceof UserService);\nassert(userService.getUser(1) === undefined);", "golden_completion": ".saveUser(new User(1, \"John Doe\"))", "LLM_justification": "This test case demonstrates a multi-line syntax pattern with method chaining and type inference in TypeScript. The prefix includes class definitions and a service class that uses method chaining to add, validate, and save users, with error handling for not found and validation errors. The completion focuses on adding a user using method chaining, and the suffix tests retrieving the user with proper error handling. This scenario ensures the LLM can handle method chaining with type inference and proper indentation.", "assertions": "assert(userService.getUser(1).name === \"John Doe\");", "gpt-4o-copilot": "    .saveUser(new User(1, \"John Doe\"));"}
{"id": "18", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\nclass QueryBuilder {\n\tprivate query: string = '';\n\n\tpublic select(fields: string[]): this {\n\t\tthis.query += `SELECT ${fields.join(', ')} `;\n\t\treturn this;\n\t}\n\n\tpublic from(table: string): this {\n\t\tthis.query += `FROM ${table} `;\n\t\treturn this;\n\t}\n\n\tpublic where(condition: string): this {\n\t\tthis.query += `WHERE ${condition} `;\n\t\treturn this;\n\t}\n\n\tpublic orderBy(field: string, direction: 'ASC' | 'DESC' = 'ASC'): this {\n\t\tthis.query += `ORDER BY ${field} ${direction} `;\n\t\treturn this;\n\t}\n\n\tpublic build(): string {\n\t\treturn this.query.trim() + ';';\n\t}\n}\n\n// Usage example\nconst query = new QueryBuilder()\n\t.select(['name', 'age'])\n\t.from('users')\n\t.where('age > 18')\n\t.orderBy('name')", "suffix": "const anotherQuery = new QueryBuilder()\n\t.select(['id', 'email'])\n\t.from('subscribers')\n\t.where('subscribed = true')\n\t.orderBy('email', 'DESC')\n\t.build();\n\nassert.strictEqual(anotherQuery, 'SELECT id, email FROM subscribers WHERE subscribed = true ORDER BY email DESC;');\n\nconsole.log('All assertions passed!');", "golden_completion": ".build();\n\nassert.strictEqual(query, 'SELECT name, age FROM users WHERE age > 18 ORDER BY name ASC;');", "LLM_justification": "This test case demonstrates a multi-line syntax pattern using the fluent interface structure with proper return types. The QueryBuilder class methods return 'this' to allow method chaining. The completion involves properly chaining and building a SQL query string, which tests the LLM's ability to handle multi-line method chaining and type inference. Assertions verify the correctness of the built query strings.", "assertions": "assert.strictEqual(query, 'SELECT name, age FROM users WHERE age > 18 ORDER BY name ASC;');\nassert.strictEqual(anotherQuery, 'SELECT id, email FROM subscribers WHERE subscribed = true ORDER BY email DESC;');", "gpt-4o-copilot": "\t.build();\n\nassert.strictEqual(query, 'SELECT name, age FROM users WHERE age > 18 ORDER BY name ASC;');"}
{"id": "19", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import assert from 'assert';\n\n// Define a custom error class hierarchy\nclass CustomError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nclass NotFoundError extends CustomError {\n    constructor(resource: string) {\n        super(`Resource not found: ${resource}`);\n        this.name = 'NotFoundError';\n    }\n}\n\nclass ValidationError extends CustomError {\n    constructor(field: string, message: string) {\n        super(`Validation error on ${field}: ${message}`);\n        this.name = 'ValidationError';\n    }\n}\n\n// Function that throws different types of errors\nfunction riskyOperation(action: string): void {\n    if (action === 'notfound') {\n        throw new NotFoundError('Item');\n    } else if (action === 'invalid') {\n        throw new ValidationError('Field', 'Invalid value');\n    } else {\n        throw new CustomError('Unknown error occurred');\n    }\n}\n\n// Error transformation function\nfunction transformError(error: Error): CustomError {\n    if (error instanceof NotFoundError) {\n        return new CustomError(`Transformed: ${error.message}`);\n    } else if (error instanceof ValidationError) {\n        return new CustomError(`Transformed: ${error.message}`);\n    }\n    return new CustomError('Transformed: General error');\n}\n\n// Function to handle errors\nfunction handleError(action: string): string {\n    try {\n        riskyOperation(action);\n        return 'Operation successful';\n    } catch (error) {\n        const transformedError = transformError(error);\n        return transformedError.message;\n    }\n}\n\n// Test cases\nconst testCases = [\n    { action: 'notfound', expected: 'Transformed: Resource not found: Item' },\n    { action: 'invalid', expected: 'Transformed: Validation error on Field: Invalid value' },\n    { action: 'unknown', expected: 'Transformed: Unknown error occurred' }\n];\n\n// Run test cases\n", "suffix": "// Cleanup code (if any) would go here\nconsole.log('All assertions passed.');", "golden_completion": "for (const testCase of testCases) {\n    const result = handleError(testCase.action);\n    assert.strictEqual(result, testCase.expected);\n}\n", "LLM_justification": "This example tests the LLM's ability to complete a multi-line syntax pattern involving custom error hierarchies, error transformation, and error handling in TypeScript. The code includes detailed setup with multiple error classes, a function to simulate risky operations, an error transformation function, and the main error handling function. The test cases verify that the error handling and transformation logic work correctly. This scenario is complex due to the nested structures, custom error types, and comprehensive error handling logic, making it a good test for syntax completion capabilities.", "assertions": "assert.strictEqual(handleError('notfound'), 'Transformed: Resource not found: Item');\nassert.strictEqual(handleError('invalid'), 'Transformed: Validation error on Field: Invalid value');\nassert.strictEqual(handleError('unknown'), 'Transformed: Unknown error occurred');", "gpt-4o-copilot": "testCases.forEach(({ action, expected }) => {\n    const result = handleError(action);\n    assert.strictEqual(result, expected);\n});"}
{"id": "20", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface Widget {\n\ttype: string;\n\tcolor: string;\n\tsize: number;\n}\n\nclass WidgetBuilder {\n\tprivate widget: Widget;\n\n\tconstructor() {\n\t\tthis.widget = { type: '', color: '', size: 0 };\n\t}\n\n\tsetType(type: string): this {\n\t\tthis.widget.type = type;\n\t\treturn this;\n\t}\n\n\tsetColor(color: string): this {\n\t\tthis.widget.color = color;\n\t\treturn this;\n\t}\n\n\tsetSize(size: number): this {\n\t\tthis.widget.size = size;\n\t\treturn this;\n\t}\n\n\tbuild(): Widget {\n\t\treturn this.widget;\n\t}\n}\n\n// Helper function to create a default Widget\nfunction createDefaultWidget(): Widget {\n\treturn new WidgetBuilder()\n\t\t.setType('default')\n\t\t.setColor('blue')\n\t\t.setSize(10)\n\t\t.build();\n}\n\nconst defaultWidget = createDefaultWidget();\n\n// Assertions to ensure the default widget is created properly\nassert.strictEqual(defaultWidget.type, 'default');\nassert.strictEqual(defaultWidget.color, 'blue');\nassert.strictEqual(defaultWidget.size, 10);\n\n// Now let's create a customized widget\nconst customWidgetBuilder = new WidgetBuilder();", "suffix": "\nconst customWidget = customWidgetBuilder.build();\n\n// Assertions to ensure the custom widget is created properly\nassert.strictEqual(customWidget.type, 'custom');\nassert.strictEqual(customWidget.color, 'red');\nassert.strictEqual(customWidget.size, 20);\n\n// Cleanup code if any\n// (In this example, there's no resource cleanup needed)", "golden_completion": "\nconst customWidget = customWidgetBuilder\n\t.setType('custom')\n\t.setColor('red')\n\t.setSize(20)\n\t.build();", "LLM_justification": "This example tests the LLM's ability to complete a method chaining pattern with type inference in TypeScript. It requires understanding of builder patterns and ensuring correct type and method chaining. The prefix provides a comprehensive setup, including class definitions and helper functions, and the suffix tests the created instance. The completion must correctly infer types and maintain the chaining structure.", "assertions": "assert.strictEqual(customWidget.type, 'custom');\nassert.strictEqual(customWidget.color, 'red');\nassert.strictEqual(customWidget.size, 20);", "gpt-4o-copilot": "customWidgetBuilder.setType('custom').setColor('red').setSize(20);"}
{"id": "21", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\ninterface Builder<T> {\n    setPropertyA(value: string): this;\n    setPropertyB(value: number): this;\n    setPropertyC(value: boolean): this;\n    build(): T;\n}\n\nclass ComplexObject {\n    propertyA: string;\n    propertyB: number;\n    propertyC: boolean;\n\n    constructor(propertyA: string, propertyB: number, propertyC: boolean) {\n        this.propertyA = propertyA;\n        this.propertyB = propertyB;\n        this.propertyC = propertyC;\n    }\n}\n\nclass ComplexObjectBuilder implements Builder<ComplexObject> {\n    private propertyA: string = '';\n    private propertyB: number = 0;\n    private propertyC: boolean = false;\n\n    setPropertyA(value: string): this {\n        this.propertyA = value;\n        return this;\n    }\n\n    setPropertyB(value: number): this {\n        this.propertyB = value;\n        return this;\n    }\n\n    setPropertyC(value: boolean): this {\n        this.propertyC = value;\n        return this;\n    }\n\n    build(): ComplexObject {\n        return new ComplexObject(this.propertyA, this.propertyB, this.propertyC);\n    }\n}\n\n// Example usage of the builder pattern\nconst builder = new ComplexObjectBuilder();", "suffix": "const incompleteObject = builder.setPropertyA('Test');\n\ntry {\n    assert.strictEqual(incompleteObject.build().propertyA, 'Test');\n    assert.strictEqual(incompleteObject.build().propertyB, 0);\n    assert.strictEqual(incompleteObject.build().propertyC, false);\n} finally {\n    // Cleanup if necessary\n}", "golden_completion": "const completeObject = builder.setPropertyA('Test')\n    .setPropertyB(42)\n    .setPropertyC(true)\n    .build();\n\nassert.strictEqual(completeObject.propertyA, 'Test');\nassert.strictEqual(completeObject.propertyB, 42);\nassert.strictEqual(completeObject.propertyC, true);\n", "LLM_justification": "This test case focuses on the builder pattern implementation with typed interfaces, a common multi-line syntax pattern in TypeScript. It ensures that the model can correctly complete method chaining with proper type inference and return types. The provided prefix sets up the context with a builder pattern, while the golden_completion demonstrates the correct use of chaining methods to construct a complex object. The suffix contains different assertions to verify the initial state of the object. This test case is effective in evaluating the model's ability to handle multi-line method chaining with correct typing and syntax.", "assertions": "assert.strictEqual(completeObject.propertyA, 'Test');\nassert.strictEqual(completeObject.propertyB, 42);\nassert.strictEqual(completeObject.propertyC, true);\nassert.strictEqual(incompleteObject.build().propertyA, 'Test');\nassert.strictEqual(incompleteObject.build().propertyB, 0);\nassert.strictEqual(incompleteObject.build().propertyC, false);", "gpt-4o-copilot": "builder.setPropertyB(42).setPropertyC(true);"}
{"id": "22", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "interface User {\n\tid: number;\n\tname: string;\n\temail: string;\n}\n\nclass UserBuilder {\n\tprivate user: Partial<User> = {};\n\n\tsetId(id: number): this {\n\t\tthis.user.id = id;\n\t\treturn this;\n\t}\n\n\tsetName(name: string): this {\n\t\tthis.user.name = name;\n\t\treturn this;\n\t}\n\n\tsetEmail(email: string): this {\n\t\tthis.user.email = email;\n\t\treturn this;\n\t}\n\n\tbuild(): User {\n\t\tif (!this.user.id || !this.user.name || !this.user.email) {\n\t\t\tthrow new Error('Missing required fields');\n\t\t}\n\t\treturn this.user as User;\n\t}\n}\n\n// Helper function to create and validate a user\nfunction createUser(userBuilder: UserBuilder): User {\n\tconst user = userBuilder.build();\n\tif (user.id <= 0) {\n\t\tthrow new Error('Invalid user ID');\n\t}\n\treturn user;\n}\n\n// Example usage of UserBuilder\nconst userBuilder = new UserBuilder();\nuserBuilder.setId(1).setName('John Doe')\n", "suffix": ".build();\n\n// Assertions\nimport { strict as assert } from 'assert';\n\ntry {\n\tconst user = createUser(userBuilder);\n\tassert.equal(user.id, 1);\n\tassert.equal(user.name, 'John Doe');\n} catch (error) {\n\tconsole.error('Error creating user:', error);\n}\n\n// Cleanup (not required in this example but illustrating the point)\nconsole.log('Test completed');", "golden_completion": ".setEmail('john.doe@example.com')", "LLM_justification": "This test case demonstrates the use of the Builder pattern in TypeScript with method chaining and type inference. The prefix sets up the context by defining a User interface and a UserBuilder class with various setter methods. The golden completion involves completing the method chaining by adding the setEmail method. The suffix includes assertions to verify the created user object. This scenario tests the LLM's ability to correctly infer types, follow method chaining patterns, and maintain proper syntax and formatting.", "assertions": "import { strict as assert } from 'assert';\n\ntry {\n\tconst user = createUser(userBuilder);\n\tassert.equal(user.id, 1);\n\tassert.equal(user.name, 'John Doe');\n\tassert.equal(user.email, 'john.doe@example.com');\n} catch (error) {\n\tconsole.error('Error creating user:', error);\n}\n\nconsole.log('Test completed');", "gpt-4o-copilot": "\t.setEmail('john.doe@example.com')"}
{"id": "23", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\nimport { promisify } from 'util';\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\n\ninterface User {\n\tid: number;\n\tname: string;\n\temail: string;\n}\n\ninterface UserBuilder {\n\tsetId(id: number): this;\n\tsetName(name: string): this;\n\tsetEmail(email: string): this;\n\tbuild(): User;\n}\n\nclass ConcreteUserBuilder implements UserBuilder {\n\tprivate user: Partial<User> = {};\n\n\tsetId(id: number): this {\n\t\tthis.user.id = id;\n\t\treturn this;\n\t}\n\n\tsetName(name: string): this {\n\t\tthis.user.name = name;\n\t\treturn this;\n\t}\n\n\tsetEmail(email: string): this {\n\t\tthis.user.email = email;\n\t\treturn this;\n\t}\n\n\tbuild(): User {\n\t\tif (!this.user.id || !this.user.name || !this.user.email) {\n\t\t\tthrow new Error('Missing properties to build User');\n\t\t}\n\t\treturn this.user as User;\n\t}\n}\n\nasync function getUserData(filePath: string): Promise<User> {\n\ttry {\n\t\tconst data = await readFile(filePath, 'utf8');\n\t\tconst json = JSON.parse(data);\n\t\tconst builder = new ConcreteUserBuilder();\n\t\t// This is where the builder pattern comes into play\n", "suffix": "\t\treturn user;\n\t} catch (error) {\n\t\tthrow new Error('Failed to read user data');\n\t}\n}\n\n(async () => {\n\tconst user = await getUserData('./user.json');\n\tconsole.log(user);\n})();", "golden_completion": "\t\tconst user = builder.setId(json.id).setName(json.name).setEmail(json.email).build();\n", "LLM_justification": "This test case effectively evaluates the LLM's capability to understand and complete a builder pattern implementation in TypeScript. The prefix provides extensive context with class definitions, method chaining, and type assertions. The completion requires correctly continuing the builder pattern with proper method chaining and returning the final built object. The suffix verifies the completion by using the built user object. Assertions are included to ensure the correctness of the builder pattern usage and the final object structure.", "assertions": "import assert from 'assert';\n\n(async () => {\n\tconst user = await getUserData('./user.json');\n\tassert.strictEqual(typeof user.id, 'number');\n\tassert.strictEqual(typeof user.name, 'string');\n\tassert.strictEqual(typeof user.email, 'string');\n})();", "gpt-4o-copilot": "\t\tconst user = builder.setId(json.id).setName(json.name).setEmail(json.email).build();"}
{"id": "24", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n// Type definitions for a builder pattern\ninterface Car {\n\tmake: string;\n\tmodel: string;\n\tyear: number;\n\tcolor: string;\n}\n\nclass CarBuilder {\n\tprivate car: Partial<Car> = {};\n\n\tsetMake(make: string): this {\n\t\tthis.car.make = make;\n\t\treturn this;\n\t}\n\n\tsetModel(model: string): this {\n\t\tthis.car.model = model;\n\t\treturn this;\n\t}\n\n\tsetYear(year: number): this {\n\t\tthis.car.year = year;\n\t\treturn this;\n\t}\n\n\tsetColor(color: string): this {\n\t\tthis.car.color = color;\n\t\treturn this;\n\t}\n\n\tbuild(): Car {\n\t\tif (!this.car.make || !this.car.model || !this.car.year || !this.car.color) {\n\t\t\tthrow new Error('Missing properties to build the car');\n\t\t}\n\t\treturn this.car as Car;\n\t}\n}\n\n// Function to create a Car using the builder\nfunction createCar(): Car {\n\tconst carBuilder = new CarBuilder();\n\tconst car = carBuilder\n\t\t.setMake('Tesla')\n\t\t.setModel('Model S')\n", "suffix": "\t\t.setColor('Red')\n\t\t.build();\n\treturn car;\n}\n\nconst myCar = createCar();\n\nassert.strictEqual(myCar.make, 'Tesla');\nassert.strictEqual(myCar.model, 'Model S');\nassert.strictEqual(myCar.year, 2023); // Note: this will fail without the completion part\nassert.strictEqual(myCar.color, 'Red');\n\nconsole.log('All assertions passed!');", "golden_completion": "\t\t.setYear(2023)\n", "LLM_justification": "This test case demonstrates a complex multi-line syntax pattern involving the builder pattern implementation in TypeScript. The prefix sets up an extensive context with type definitions, class implementation, and partial method chaining. The completion involves adding a missing method call in the chain, maintaining the correct types and fluent interface structure. The suffix completes the chain and includes assertions to validate the correctness of the built object, ensuring the entire pattern is correctly understood and implemented.", "assertions": "assert.strictEqual(myCar.make, 'Tesla');\nassert.strictEqual(myCar.model, 'Model S');\nassert.strictEqual(myCar.year, 2023);\nassert.strictEqual(myCar.color, 'Red');", "gpt-4o-copilot": "\t\t.setYear(2023)"}
{"id": "25", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from \"assert\";\n\n// Define a class with a fluent interface structure\nclass QueryBuilder {\n\tprivate query: string = \"\";\n\n\tselect(fields: string[]): this {\n\t\tthis.query += `SELECT ${fields.join(\", \")} `;\n\t\treturn this;\n\t}\n\n\tfrom(table: string): this {\n\t\tthis.query += `FROM ${table} `;\n\t\treturn this;\n\t}\n\n\twhere(condition: string): this {\n\t\tthis.query += `WHERE ${condition} `;\n\t\treturn this;\n\t}\n\n\torderBy(field: string, direction: \"ASC\" | \"DESC\" = \"ASC\"): this {\n\t\tthis.query += `ORDER BY ${field} ${direction} `;\n\t\treturn this;\n\t}\n\n\tbuild(): string {\n\t\treturn this.query.trim() + \";\";\n\t}\n}\n\n// Instantiate the QueryBuilder\nconst queryBuilder = new QueryBuilder();\n\n// Building a query using the fluent interface\nconst query = queryBuilder", "suffix": ".build();\n\n// Assertions to verify the query structure\nassert.equal(query, \"SELECT id, name FROM users WHERE age > 18 ORDER BY name ASC;\");\n\nconsole.log(\"Query built successfully:\", query);\n", "golden_completion": ".select([\"id\", \"name\"]).from(\"users\").where(\"age > 18\").orderBy(\"name\", \"ASC\")", "LLM_justification": "This test case is designed to evaluate the LLM's ability to complete a complex multi-line fluent interface structure with proper return types. The fluent interface pattern requires method chaining, which needs to return the correct type (the instance itself) to allow for subsequent calls. The completion must maintain the correct order and syntax for chaining methods and ensure proper type inference throughout the chain. This verifies the model's understanding of method chaining, type inference, and the overall structure of a fluent interface in TypeScript.", "assertions": "assert.equal(queryBuilder.select([\"id\", \"name\"]).from(\"users\").where(\"age > 18\").orderBy(\"name\", \"ASC\").build(), \"SELECT id, name FROM users WHERE age > 18 ORDER BY name ASC;\");", "gpt-4o-copilot": "\t.select([\"id\", \"name\"])\n\t.from(\"users\")\n\t.where(\"age > 18\")\n\t.orderBy(\"name\", \"ASC\");"}
{"id": "26", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n// Define a custom error class hierarchy\nclass AppError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'AppError';\n    }\n}\n\nclass NotFoundError extends AppError {\n    constructor(resource: string) {\n        super(`Resource not found: ${resource}`);\n        this.name = 'NotFoundError';\n    }\n}\n\nclass ValidationError extends AppError {\n    constructor(details: string) {\n        super(`Validation error: ${details}`);\n        this.name = 'ValidationError';\n    }\n}\n\n// Function that simulates an operation that could throw different types of errors\nfunction riskyOperation(resource: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (resource === 'valid') {\n                resolve('Operation successful');\n            } else if (resource === 'missing') {\n                reject(new NotFoundError(resource));\n            } else {\n                reject(new ValidationError('Invalid resource provided'));\n            }\n        }, 100);\n    });\n}\n\n// Utility function for logging errors\nfunction logError(error: AppError): void {\n    console.error(`Error: ${error.name} - ${error.message}`);\n}\n\n// Main function to perform an operation with error handling\nasync function main() {\n    const resource = 'missing';\n    try {\n        const result = await riskyOperation(resource);\n        console.log(result);\n", "suffix": "    } finally {\n        console.log('Operation completed');\n    }\n}\n\nmain();", "golden_completion": "    } catch (error) {\n        if (error instanceof NotFoundError) {\n            console.warn('Handling not found error');\n        } else if (error instanceof ValidationError) {\n            console.warn('Handling validation error');\n        } else {\n            throw error;\n        }\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to handle complex multi-line syntax patterns, specifically try/catch/finally combinations with typed errors and custom error hierarchies. The example includes various error types and demonstrates proper error handling and transformation. The completion involves catching different error types, handling them accordingly, and maintaining proper indentation and code structure. This tests the LLM's understanding of TypeScript's type system, error handling, and syntax formatting.", "assertions": "assert.doesNotThrow(() => main(), Error, 'Main function should not throw unhandled errors');\nassert.rejects(riskyOperation('missing'), NotFoundError, 'Should reject with NotFoundError for missing resource');\nassert.rejects(riskyOperation('invalid'), ValidationError, 'Should reject with ValidationError for invalid resource');\nassert.doesNotReject(riskyOperation('valid'), 'Should resolve successfully for valid resource');\n", "gpt-4o-copilot": "    } catch (error) {\n        if (error instanceof AppError) {\n            logError(error);\n        } else {\n            console.error('Unexpected error:', error);\n        }"}
{"id": "27", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import assert from 'assert';\n\n// Utility function to simulate an asynchronous operation\nasync function fetchData(url: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (url === 'https://valid.url') {\n                resolve('Data from ' + url);\n            } else {\n                reject(new Error('Invalid URL'));\n            }\n        }, 1000);\n    });\n}\n\n// Custom error classes\nclass AppError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'AppError';\n    }\n}\n\nclass NetworkError extends AppError {\n    constructor(message: string) {\n        super(message);\n        this.name = 'NetworkError';\n    }\n}\n\n// Function that processes data and handles errors\nasync function processData(url: string): Promise<string> {\n    try {\n        const data = await fetchData(url);\n        return `Processed: ${data}`;\n    } catch (error) {\n        if (error instanceof Error && error.message === 'Invalid URL') {\n            throw new NetworkError('Failed to fetch data due to invalid URL');\n        }\n        throw new AppError('An unexpected error occurred');\n    }\n}\n\n// Test cases to validate the behavior of processData function\nasync function runTests() {\n    try {\n        // Valid URL case\n        const result1 = await processData('https://valid.url');\n        assert.strictEqual(result1, 'Processed: Data from https://valid.url');\n\n        // Invalid URL case\n        await processData('https://invalid.url');\n    } catch (error) {\n        if (error instanceof NetworkError) {\n            assert.strictEqual(error.message, 'Failed to fetch data due to invalid URL');\n        } else {\n            throw error;\n        }\n    }\n}\n\n// Run the tests\n", "suffix": "\n// Additional test case for an unexpected error\nasync function runAdditionalTests() {\n    try {\n        // Simulate an unexpected error\n        const result2 = await processData('https://unexpected.error');\n    } catch (error) {\n        if (error instanceof AppError) {\n            assert.strictEqual(error.message, 'An unexpected error occurred');\n        } else {\n            throw error;\n        }\n    }\n}\n\n// Run additional tests\nrunAdditionalTests().then(() => {\n    console.log('Additional tests passed');\n}).catch((error) => {\n    console.error('Additional test failed', error);\n});\n", "golden_completion": "runTests().then(() => {\n    console.log('All tests passed');\n}).catch((error) => {\n    console.error('Test failed', error);\n});", "LLM_justification": "This test case is a good example of Promise error handling with proper typing and custom error hierarchies in TypeScript. The code includes asynchronous operations, error handling using try/catch blocks, and custom error classes with specific error messages. The assertions verify correct error handling behavior and message integrity, ensuring that the TypeScript compiler and runtime correctly interpret the nested error handling structures.", "assertions": "assert.strictEqual(result1, 'Processed: Data from https://valid.url');\nassert.strictEqual(error.message, 'Failed to fetch data due to invalid URL');\nassert.strictEqual(error.message, 'An unexpected error occurred');", "gpt-4o-copilot": "runTests().then(() => {\n    console.log('All tests passed');\n}).catch((error) => {\n    console.error('Test failed', error);\n});"}
{"id": "28", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "interface User {\n\tname: string;\n\temail: string;\n\tage: number;\n}\n\nclass UserBuilder {\n\tprivate user: User;\n\n\tconstructor() {\n\t\tthis.user = { name: '', email: '', age: 0 };\n\t}\n\n\tsetName(name: string): this {\n\t\tthis.user.name = name;\n\t\treturn this;\n\t}\n\n\tsetEmail(email: string): this {\n\t\tthis.user.email = email;\n\t\treturn this;\n\t}\n\n\tsetAge(age: number): this {\n\t\tthis.user.age = age;\n\t\treturn this;\n\t}\n\n\tbuild(): User {\n\t\treturn this.user;\n\t}\n}\n\n// Helper function to validate email format\nfunction isValidEmail(email: string): boolean {\n\tconst re = /^(([^<>()\\[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\\\.,;:\\s@\\\"]{2,})$/i;\n\treturn re.test(String(email).toLowerCase());\n}\n\n// Creating a user with the builder pattern\nconst userBuilder = new UserBuilder();\nconst user = userBuilder.setName('John Doe')", "suffix": ".build();\n\n// Assertion to check the user object\nconsole.assert(user.name === 'John Doe', 'User name should be John Doe');\nconsole.assert(user.email === '', 'User email should be empty');\nconsole.assert(user.age === 0, 'User age should be 0');\n\n// Cleanup (if any resources to be cleaned up, this is where it would happen)\n\nconsole.log('All assertions passed.');", "golden_completion": ".setEmail('john.doe@example.com').setAge(30)", "LLM_justification": "This example tests the LLM's ability to complete a method chaining pattern using the builder pattern in TypeScript. The builder pattern is a complex multi-line syntax pattern with type inference. The completion should correctly chain methods and maintain proper return types. The suffix contains different code to ensure distinction, and the assertions verify the correctness of the completion. This tests the LLM's understanding of complex TypeScript patterns, proper chaining, and type correctness.", "assertions": "console.assert(user.email === 'john.doe@example.com', 'User email should be john.doe@example.com');\nconsole.assert(user.age === 30, 'User age should be 30');", "gpt-4o-copilot": ".setEmail('john.doe@example.com').setAge(30).build();"}
{"id": "29", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface HttpResponse {\n    statusCode: number;\n    body: string;\n}\n\nclass HttpError extends Error {\n    constructor(public statusCode: number, message: string) {\n        super(message);\n        this.name = 'HttpError';\n    }\n}\n\nfunction fetchData(url: string): Promise<HttpResponse> {\n    return new Promise((resolve, reject) => {\n        // Simulating an HTTP request\n        setTimeout(() => {\n            if (url === 'https://api.example.com/data') {\n                resolve({ statusCode: 200, body: 'Success' });\n            } else {\n                reject(new HttpError(404, 'Not Found'));\n            }\n        }, 1000);\n    });\n}\n\nasync function getData(url: string): Promise<string> {\n    try {\n        const response = await fetchData(url);\n        if (response.statusCode !== 200) {\n            throw new HttpError(response.statusCode, 'Failed to fetch data');\n        }\n        return response.body;\n    } catch (error) {\n        if (error instanceof HttpError) {\n            // Transforming the error with a custom message\n            throw new HttpError(error.statusCode, `Custom Message: ${error.message}`);\n        }\n        throw error;\n    }\n}\n\nasync function main() {\n    const validUrl = 'https://api.example.com/data';\n    const invalidUrl = 'https://api.example.com/invalid';\n\n    // Valid URL test\n    let result;\n    try {\n        result = await getData(validUrl);\n", "suffix": "        assert.strictEqual(result, 'Error: Custom Message: Not Found');\n    } catch (error) {\n        assert.strictEqual(error.message, 'Error: Custom Message: Not Found');\n    }\n    console.log('All tests passed');\n}\n\nmain().catch(console.error);\n", "golden_completion": "        assert.strictEqual(result, 'Success');\n    } catch (error) {\n        assert.fail(`Unexpected error: ${error.message}`);\n    }\n\n    // Invalid URL test\n    try {\n        result = await getData(invalidUrl);\n", "LLM_justification": "This test case evaluates the LLM's ability to complete a complex error handling pattern involving asynchronous functions, promises, and custom error types in TypeScript. The scenario includes nested try/catch blocks, custom error transformation, and type guards, which are critical for ensuring robust error handling and type safety. The completion must correctly handle different outcomes (valid and invalid URLs) and maintain proper nesting and indentation. Assertions verify the correctness of the function's behavior and error handling logic.", "assertions": "assert.strictEqual(result, 'Success');\nassert.strictEqual(result, 'Error: Custom Message: Not Found');", "gpt-4o-copilot": "        assert.strictEqual(result, 'Success');"}
{"id": "30", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { assert } from 'chai';\n\n// Sample data structure to hold user information\ninterface User {\n\tid: number;\n\tname: string;\n\temail: string;\n\tage?: number;\n}\n\n// A utility class to build user objects\nclass UserBuilder {\n\tprivate user: Partial<User> = {};\n\n\tsetId(id: number): this {\n\t\tthis.user.id = id;\n\t\treturn this;\n\t}\n\n\tsetName(name: string): this {\n\t\tthis.user.name = name;\n\t\treturn this;\n\t}\n\n\tsetEmail(email: string): this {\n\t\tthis.user.email = email;\n\t\treturn this;\n\t}\n\n\tsetAge(age: number): this {\n\t\tthis.user.age = age;\n\t\treturn this;\n\t}\n\n\tbuild(): User {\n\t\tif (!this.user.id || !this.user.name || !this.user.email) {\n\t\t\tthrow new Error('Missing required user properties');\n\t\t}\n\t\treturn this.user as User;\n\t}\n}\n\n// Function to create a new user using the builder pattern\nfunction createUser(id: number, name: string, email: string, age?: number): User {\n\tconst builder = new UserBuilder();\n\treturn builder.setId(id).setName(name).setEmail(email)", "suffix": ".build();\n}\n\n// Testing the createUser function\nconst user1 = createUser(1, 'Alice', 'alice@example.com', 25);\nconst user2 = createUser(2, 'Bob', 'bob@example.com');\n\nassert.equal(user1.id, 1);\nassert.equal(user1.name, 'Alice');\nassert.equal(user1.email, 'alice@example.com');\nassert.equal(user1.age, 25);\n\nassert.equal(user2.id, 2);\nassert.equal(user2.name, 'Bob');\nassert.equal(user2.email, 'bob@example.com');\nassert.isUndefined(user2.age);\n\nconsole.log('All assertions passed');", "golden_completion": ".setAge(age)\t", "LLM_justification": "This scenario tests the LLM's ability to complete a complex builder pattern implementation with method chaining and type inference. The prefix sets up an incomplete user creation function using the builder pattern, and the golden completion requires the correct invocation of the setAge method to complete the user object. This tests the model's understanding of method chaining and correct usage of the builder pattern.", "assertions": "assert.equal(user1.id, 1);\nassert.equal(user1.name, 'Alice');\nassert.equal(user1.email, 'alice@example.com');\nassert.equal(user1.age, 25);\n\nassert.equal(user2.id, 2);\nassert.equal(user2.name, 'Bob');\nassert.equal(user2.email, 'bob@example.com');\nassert.isUndefined(user2.age);\n\nconsole.log('All assertions passed');", "gpt-4o-copilot": "\t.setAge(age).build();"}
{"id": "31", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import assert from 'assert';\n\n// A simple interface and class to demonstrate the builder pattern\ninterface ICar {\n\tcolor: string;\n\tengine: string;\n\twheels: number;\n\tbuild(): Car;\n}\n\nclass Car implements ICar {\n\tcolor: string = '';\n\tengine: string = '';\n\twheels: number = 0;\n\n\tsetColor(color: string): Car {\n\t\tthis.color = color;\n\t\treturn this;\n\t}\n\n\tsetEngine(engine: string): Car {\n\t\tthis.engine = engine;\n\t\treturn this;\n\t}\n\n\tsetWheels(wheels: number): Car {\n\t\tthis.wheels = wheels;\n\t\treturn this;\n\t}\n\n\tbuild(): Car {\n\t\t// Validation logic to ensure car is properly built\n\t\tif (!this.color || !this.engine || this.wheels <= 0) {\n\t\t\tthrow new Error('Invalid car configuration');\n\t\t}\n\t\treturn this;\n\t}\n}\n\n// Helper function to demonstrate the builder pattern\nfunction createSportsCar(): Car {\n\treturn new Car()\n\t\t.setColor('red')\n\t\t.setEngine('V8')\n\t\t.setWheels(4)\n\t\t.build();\n}\n\n// Another function to create a different type of car\nfunction createFamilyCar(): Car {\n\treturn new Car()\n\t\t.setColor('blue')\n\t\t.setEngine('V6')\n\t\t.setWheels(4)\n\t\t.build();\n}\n\n// Test the builder pattern implementation\nconst sportsCar = createSportsCar();\nconst familyCar = createFamilyCar();\n\n", "suffix": "\n\n// Assertions to verify the builder pattern implementation\nassert.strictEqual(sportsCar.color, 'red');\nassert.strictEqual(sportsCar.engine, 'V8');\nassert.strictEqual(sportsCar.wheels, 4);\n\nassert.strictEqual(familyCar.color, 'blue');\nassert.strictEqual(familyCar.engine, 'V6');\nassert.strictEqual(familyCar.wheels, 4);\n\nconsole.log('All assertions passed.');\n", "golden_completion": "\n// Another car creation example with different properties\nfunction createElectricCar(): Car {\n\treturn new Car()\n\t\t.setColor('green')\n\t\t.setEngine('Electric')\n\t\t.setWheels(4)\n\t\t.build();\n}\n\nconst electricCar = createElectricCar();\n", "LLM_justification": "This test case demonstrates the builder pattern implementation in TypeScript, which involves method chaining with type inference. The prefix sets up the context with helper functions and class methods. The golden completion adds a new method chain to create a different type of car, adhering to the builder pattern. The suffix includes assertions to verify the correctness of the implementation, ensuring that the language model can handle multi-line syntax patterns and proper type inference.", "assertions": "assert.strictEqual(electricCar.color, 'green');\nassert.strictEqual(electricCar.engine, 'Electric');\nassert.strictEqual(electricCar.wheels, 4);\n", "gpt-4o-copilot": "// Log the created cars to verify their properties\nconsole.log('Sports Car:', sportsCar);\nconsole.log('Family Car:', familyCar);"}
{"id": "32", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\ninterface User {\n\tid: number;\n\tname: string;\n\temail: string;\n}\n\nclass UserBuilder {\n\tprivate user: User;\n\n\tconstructor() {\n\t\tthis.user = { id: 0, name: '', email: '' };\n\t}\n\n\tsetId(id: number): this {\n\t\tthis.user.id = id;\n\t\treturn this;\n\t}\n\n\tsetName(name: string): this {\n\t\tthis.user.name = name;\n\t\treturn this;\n\t}\n\n\tsetEmail(email: string): this {\n\t\tthis.user.email = email;\n\t\treturn this;\n\t}\n\n\tbuild(): User {\n\t\treturn this.user;\n\t}\n}\n\n// Helper function to simulate user creation\nfunction createUser(id: number, name: string, email: string): User {\n\treturn new UserBuilder()\n\t\t.setId(id)\n\t\t.setName(name)\n\t\t.setEmail(email)\n\t\t.build();\n}\n\n// Example usage of the builder pattern\nconst newUser = createUser(1, 'John Doe', 'john.doe@example.com');\nconsole.log(newUser);\n\n// Function to write user data to a file\nfunction writeUserToFile(user: User, filePath: string): Promise<void> {\n\treturn new Promise((resolve, reject) => {\n\t\tfs.writeFile(filePath, JSON.stringify(user, null, 2), (err) => {\n\t\t\tif (err) {\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n", "suffix": "\n\nconst filePath = 'user.json';\n\nwriteUserToFile(newUser, filePath)\n\t.then(() => console.log('User data written to file successfully.'))\n\t.catch((err) => console.error('Failed to write user data to file:', err));\n\n// Cleanup: Remove the file after assertions\nfs.unlink(filePath, (err) => {\n\tif (err) console.error('Failed to delete file:', err);\n\telse console.log('File deleted successfully.');\n});\n", "golden_completion": "writeUserToFile(newUser, filePath)\n\t.then(() => console.log('User data written to file successfully.'))\n\t.catch((err) => console.error('Failed to write user data to file:', err));\n", "LLM_justification": "This test case is a good example of the builder pattern implementation with typed interfaces in TypeScript. It demonstrates the ability to chain methods with proper type inference and return types. The completion involves method chaining and proper error handling using Promises. The assertions ensure that the file writing operation completes successfully and the user data is correctly serialized and written to the file.", "assertions": "import assert from 'assert';\nimport fs from 'fs';\n\nconst filePath = 'user.json';\nconst userJson = fs.readFileSync(filePath, 'utf-8');\nconst user: User = JSON.parse(userJson);\n\nassert.strictEqual(user.id, 1, 'User ID should be 1');\nassert.strictEqual(user.name, 'John Doe', 'User name should be John Doe');\nassert.strictEqual(user.email, 'john.doe@example.com', 'User email should be john.doe@example.com');\n", "gpt-4o-copilot": "// Function to read user data from a file\nfunction readUserFromFile(filePath: string): Promise<User> {\n\treturn new Promise((resolve, reject) => {\n\t\tfs.readFile(filePath, 'utf8', (err, data) => {\n\t\t\tif (err) {\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\tresolve(JSON.parse(data));\n\t\t\t}\n\t\t});\n\t});\n}"}
{"id": "33", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n// Define a custom error class for typed errors\nclass CustomError extends Error {\n    constructor(public code: number, message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\n// Function that may throw a CustomError\nfunction riskyOperation(success: boolean): string {\n    if (!success) {\n        throw new CustomError(404, 'Resource not found');\n    }\n    return 'Operation successful';\n}\n\n// Utility function to handle errors\nfunction handleErrors(err: unknown): string {\n    if (err instanceof CustomError) {\n        return `Error: ${err.message} (Code: ${err.code})`;\n    }\n    return 'Unknown error occurred';\n}\n\n// Main function demonstrating try/catch/finally\nfunction main(success: boolean): string {\n    let result: string;\n    try {\n        result = riskyOperation(success);\n    } catch (err) {\n        result = handleErrors(err);\n    } finally {\n        console.log('Cleanup resources');\n    }\n    return result;\n}\n\n// Test the main function with both success and failure scenarios\nconst successResult = main(true);\nconst failureResult = main(false);\n", "suffix": "console.log('Logging success and failure results');\nconsole.log('Success result:', successResult);\nconsole.log('Failure result:', failureResult);\n\n// Cleanup resources can be handled here if needed\n", "golden_completion": "assert.strictEqual(successResult, 'Operation successful');\nassert.strictEqual(failureResult, 'Error: Resource not found (Code: 404)');\n", "LLM_justification": "This example is a good test case because it demonstrates the use of try/catch/finally blocks with typed errors in TypeScript. The scenario includes custom error classes, error handling functions, and a main function that integrates these components. The assertions verify the expected outcomes of both successful and failed operations, ensuring the LLM can complete complex syntactical structures and maintain proper formatting.", "assertions": "assert.strictEqual(successResult, 'Operation successful');\nassert.strictEqual(failureResult, 'Error: Resource not found (Code: 404)');\nconsole.log('All assertions passed');\n", "gpt-4o-copilot": "console.log('Logging success and failure results');"}
{"id": "34", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\ninterface User {\n\tid: number;\n\tname: string;\n\temail: string;\n}\n\nclass UserBuilder {\n\tprivate user: User;\n\n\tconstructor() {\n\t\tthis.user = { id: 0, name: '', email: '' };\n\t}\n\n\tsetId(id: number): this {\n\t\tthis.user.id = id;\n\t\treturn this;\n\t}\n\n\tsetName(name: string): this {\n\t\tthis.user.name = name;\n\t\treturn this;\n\t}\n\n\tsetEmail(email: string): this {\n\t\tthis.user.email = email;\n\t\treturn this;\n\t}\n\n\tbuild(): User {\n\t\treturn this.user;\n\t}\n}\n\n// Example usage\nconst userBuilder = new UserBuilder();\nconst user = userBuilder\n\t.setId(1)\n\t.setName('John Doe')\n\t.setEmail('john.doe@example.com')\n\t.build();\n\nassert.equal(user.id, 1);\nassert.equal(user.name, 'John Doe');\nassert.equal(user.email, 'john.doe@example.com');\n\n// Additional builder pattern for more complex object\ninterface Address {\n\tstreet: string;\n\tcity: string;\n\tzip: string;\n}\n\nclass AddressBuilder {\n\tprivate address: Address;\n\n\tconstructor() {\n\t\tthis.address = { street: '', city: '', zip: '' };\n\t}\n\n\tsetStreet(street: string): this {\n\t\tthis.address.street = street;\n\t\treturn this;\n\t}\n\n\tsetCity(city: string): this {\n\t\tthis.address.city = city;\n\t\treturn this;\n\t}\n\n\tsetZip(zip: string): this {\n\t\tthis.address.zip = zip;\n\t\treturn this;\n\t}\n\n\tbuild(): Address {\n\t\treturn this.address;\n\t}\n}\n\n// Example usage\nconst addressBuilder = new AddressBuilder();\n", "suffix": "const address2 = addressBuilder\n\t.setStreet('456 Elm St')\n\t.setCity('Othertown')\n\t.setZip('67890')\n\t.build();\n\nassert.equal(address2.street, '456 Elm St');\nassert.equal(address2.city, 'Othertown');\nassert.equal(address2.zip, '67890');\n\nconsole.log('All assertions passed.');\n", "golden_completion": "const address = addressBuilder\n\t.setStreet('123 Main St')\n\t.setCity('Anytown')\n\t.setZip('12345')\n\t.build();\n\nassert.equal(address.street, '123 Main St');\nassert.equal(address.city, 'Anytown');\nassert.equal(address.zip, '12345');\n", "LLM_justification": "This test case is a good benchmark for syntax completion capabilities because it involves a multi-line method chaining pattern within the builder pattern implementation. The code tests the LLM's ability to complete a complex syntactical structure while maintaining proper formatting and type correctness. The example includes extensive setup and context in the prefix, demonstrating the builder pattern for both User and Address objects. Assertions verify that the constructed objects have the expected properties, ensuring the completion is correct.", "assertions": "assert.equal(address.street, '123 Main St');\nassert.equal(address.city, 'Anytown');\nassert.equal(address.zip, '12345');\nassert.equal(address2.street, '456 Elm St');\nassert.equal(address2.city, 'Othertown');\nassert.equal(address2.zip, '67890');\n", "gpt-4o-copilot": "const address2 = addressBuilder"}
{"id": "35", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\nclass CustomError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'CustomError';\n  }\n}\n\nclass FileReadError extends CustomError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FileReadError';\n  }\n}\n\nclass FileWriteError extends CustomError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FileWriteError';\n  }\n}\n\nfunction readFileAsync(filePath: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, 'utf8', (err, data) => {\n      if (err) {\n        reject(new FileReadError(`Failed to read file: ${filePath}`));\n        return;\n      }\n      resolve(data);\n    });\n  });\n}\n\nfunction writeFileAsync(filePath: string, data: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(filePath, data, 'utf8', (err) => {\n      if (err) {\n        reject(new FileWriteError(`Failed to write to file: ${filePath}`));\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\nasync function processFile(filePath: string): Promise<void> {\n  try {\n    const data = await readFileAsync(filePath);\n    // Process data here\n    const processedData = data.toUpperCase();\n", "suffix": "    console.log('File processed successfully.');\n  } catch (error) {\n    if (error instanceof FileReadError) {\n      console.error('Error reading file:', error.message);\n    } else if (error instanceof FileWriteError) {\n      console.error('Error writing file:', error.message);\n    } else {\n      console.error('Unknown error:', error);\n    }\n  } finally {\n    console.log('Cleanup resources if any.');\n  }\n}\n\n// Test the processFile function\n(async () => {\n  const testFilePath = './test.txt';\n  try {\n    await writeFileAsync(testFilePath, 'Sample data');\n    await processFile(testFilePath);\n  } catch (error) {\n    console.error('Test failed:', error);\n  }\n})();\n", "golden_completion": "    await writeFileAsync(filePath, processedData);", "LLM_justification": "This test case is a good example because it demonstrates the use of custom error hierarchies, promise-based asynchronous file operations, and proper error handling with type guards. The golden completion requires the model to correctly handle nested async/await syntax, error propagation, and resource cleanup. It also tests the model's ability to maintain the context and indentation established in the prefix.", "assertions": "import { strict as assert } from 'assert';\n(async () => {\n  const testFilePath = './test.txt';\n  await writeFileAsync(testFilePath, 'Sample data');\n  try {\n    await processFile(testFilePath);\n    const result = await readFileAsync(testFilePath);\n    assert.equal(result, 'SAMPLE DATA');\n  } catch (error) {\n    assert.fail(`Unexpected error: ${error.message}`);\n  }\n})();", "gpt-4o-copilot": "    await writeFileAsync(filePath, processedData);"}
{"id": "36", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { readFileSync, writeFileSync } from 'fs';\nimport { join } from 'path';\n\nclass CustomError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nclass ResourceError extends CustomError {\n    constructor(message: string) {\n        super(message);\n        this.name = 'ResourceError';\n    }\n}\n\ninterface Resource {\n    name: string;\n    open(): void;\n    close(): void;\n}\n\nclass FileResource implements Resource {\n    name: string;\n    private filePath: string;\n    private fileContent: string | null = null;\n\n    constructor(name: string, filePath: string) {\n        this.name = name;\n        this.filePath = filePath;\n    }\n\n    open(): void {\n        try {\n            this.fileContent = readFileSync(this.filePath, 'utf-8');\n        } catch (error) {\n            throw new ResourceError(`Failed to open resource: ${this.name}`);\n        }\n    }\n\n    close(): void {\n        // Placeholder for resource cleanup logic\n    }\n}\n\nfunction processResource(resource: Resource): void {\n    try {\n        resource.open();\n        // Placeholder for processing logic\n    } catch (error) {\n        if (error instanceof ResourceError) {\n            console.error(error.message);\n        } else {\n            console.error('An unexpected error occurred:', error);\n        }\n    } finally {\n        resource.close();\n    }\n}\n\nconst resource = new FileResource('TestResource', join(__dirname, 'test.txt'));\n", "suffix": "\n// Additional processing code\n\nconsole.log('Resource processing complete.');\n", "golden_completion": "processResource(resource);", "LLM_justification": "This test case is a good example of error handling patterns in TypeScript. It demonstrates the use of custom error classes with inheritance, try/catch/finally blocks for error handling and resource management, and proper typing. The prefix sets up the necessary context with class definitions, interfaces, and error handling logic. The completion focuses on invoking the processResource function, which encapsulates the error handling pattern. The suffix adds additional processing code, ensuring a clear distinction from the completion.", "assertions": "import { strict as assert } from 'assert';\n\ntry {\n    processResource(resource);\n    console.log('Resource processed successfully.');\n} catch (error) {\n    assert.fail('Error should be handled within processResource function');\n}\n\nassert.strictEqual(resource.name, 'TestResource', 'Resource name should be TestResource');\n", "gpt-4o-copilot": "processResource(resource);"}
{"id": "37", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { readFileSync, writeFileSync } from 'fs';\n\nclass CustomError extends Error {\n    constructor(public message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nclass FileReadError extends CustomError {\n    constructor(public filePath: string, message: string) {\n        super(message);\n        this.name = 'FileReadError';\n    }\n}\n\nclass FileWriteError extends CustomError {\n    constructor(public filePath: string, message: string) {\n        super(message);\n        this.name = 'FileWriteError';\n    }\n}\n\nfunction readFile(filePath: string): string {\n    try {\n        const data = readFileSync(filePath, 'utf-8');\n        return data;\n    } catch (error) {\n        if (error instanceof Error) {\n            throw new FileReadError(filePath, error.message);\n        }\n        throw error;\n    }\n}\n\nfunction writeFile(filePath: string, data: string): void {\n    try {\n        writeFileSync(filePath, data, 'utf-8');\n    } catch (error) {\n        if (error instanceof Error) {\n            throw new FileWriteError(filePath, error.message);\n        }\n        throw error;\n    }\n}\n\nasync function processFile(inputPath: string, outputPath: string): Promise<void> {\n    let data: string = '';\n    try {\n        data = readFile(inputPath);\n", "suffix": "        writeFile(outputPath, data);\n    } catch (error) {\n        console.error('An error occurred:', error);\n    } finally {\n        console.log('Process completed');\n    }\n}\n\n// Example usage:\n(async () => {\n    const inputPath = 'input.txt';\n    const outputPath = 'output.txt';\n    await processFile(inputPath, outputPath);\n})();\n", "golden_completion": "        if (!data) {\n            throw new Error('No data to write');\n        }\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to complete a try/catch/finally block with proper error handling, nested within an async function. The scenario involves custom error classes with inheritance, and the completion requires the LLM to correctly handle a specific error condition and maintain proper indentation and syntax.", "assertions": "import { strict as assert } from 'assert';\n\n(async () => {\n    const inputPath = 'input.txt';\n    const outputPath = 'output.txt';\n    try {\n        await processFile(inputPath, outputPath);\n    } catch (error) {\n        assert.fail('The process should not throw an error');\n    }\n    const outputData = readFileSync(outputPath, 'utf-8');\n    assert.equal(outputData, readFileSync(inputPath, 'utf-8'), 'Output data should match input data');\n})();\n", "gpt-4o-copilot": "        data = data.toUpperCase();"}
{"id": "38", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\n// Custom Error Hierarchy\nclass AppError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'AppError';\n    }\n}\n\nclass FileNotFoundError extends AppError {\n    constructor(filePath: string) {\n        super(`File not found: ${filePath}`);\n        this.name = 'FileNotFoundError';\n    }\n}\n\nclass PermissionDeniedError extends AppError {\n    constructor(filePath: string) {\n        super(`Permission denied: ${filePath}`);\n        this.name = 'PermissionDeniedError';\n    }\n}\n\n// Utility function to read a file\nasync function readFile(filePath: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                if (err.code === 'ENOENT') {\n                    reject(new FileNotFoundError(filePath));\n                } else if (err.code === 'EACCES') {\n                    reject(new PermissionDeniedError(filePath));\n                } else {\n                    reject(new AppError('An unknown error occurred'));\n                }\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Function to process a file\nasync function processFile(filePath: string): Promise<void> {\n    try {\n        const content = await readFile(filePath);\n        console.log('File content:', content);\n    } catch (error) {\n        if (error instanceof FileNotFoundError) {\n            console.error('Handling file not found error:', error.message);\n        } else if (error instanceof PermissionDeniedError) {\n            console.error('Handling permission denied error:', error.message);\n        } else if (error instanceof AppError) {\n            console.error('Handling general app error:', error.message);\n        } else {\n            console.error('Handling unknown error:', error);\n        }\n    } finally {\n        console.log('Cleanup and resource management');\n    }\n}\n\n// Test case\nasync function testProcessFile() {\n    const testFilePath = './test.txt';\n    let fileExists = false;\n    try {\n        await fs.promises.access(testFilePath);\n        fileExists = true;\n    } catch {}\n    if (fileExists) {\n        await fs.promises.unlink(testFilePath);\n    }\n    fs.writeFileSync(testFilePath, 'Sample content');\n    await processFile(testFilePath);\n    // Assertions will be added here\n", "suffix": "\n    await fs.promises.unlink(testFilePath);\n}\n\ntestProcessFile().catch(console.error);", "golden_completion": "    const content = await readFile(testFilePath);\n    console.assert(content === 'Sample content', 'File content should match the written content');", "LLM_justification": "This test case is a good example of complex error handling patterns with custom error hierarchies, proper typing, and cleanup logic. It includes a try/catch/finally block, demonstrates type checking with instanceof, and handles resource management. The completion focuses on reading a file and asserting its content, which tests the LLM's ability to understand error handling, proper typing, and assertion placement.", "assertions": "    const content = await readFile(testFilePath);\n    console.assert(content === 'Sample content', 'File content should match the written content');", "gpt-4o-copilot": "    console.assert(fs.existsSync(testFilePath) === false, 'File should be deleted after processing');"}
{"id": "39", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { assert } from 'assert';\n\nclass BaseError extends Error {\n    constructor(public message: string) {\n        super(message);\n        this.name = 'BaseError';\n    }\n}\n\nclass ValidationError extends BaseError {\n    constructor(public message: string) {\n        super(message);\n        this.name = 'ValidationError';\n    }\n}\n\nclass NotFoundError extends BaseError {\n    constructor(public message: string) {\n        super(message);\n        this.name = 'NotFoundError';\n    }\n}\n\nfunction validateInput(input: string): void {\n    if (input === '') {\n        throw new ValidationError('Input cannot be empty');\n    }\n}\n\nfunction findResource(id: number): string {\n    if (id !== 1) {\n        throw new NotFoundError('Resource not found');\n    }\n    return 'Resource data';\n}\n\nasync function processResource(input: string, id: number): Promise<string> {\n    try {\n        validateInput(input);\n        const resource = findResource(id);\n        return `Processed ${resource}`;\n    } catch (error) {", "suffix": "    }\n}\n\nasync function main() {\n    try {\n        const result = await processResource('valid input', 1);\n        console.log(result);\n    } catch (error) {\n        if (error instanceof ValidationError) {\n            console.error('Validation failed:', error.message);\n        } else if (error instanceof NotFoundError) {\n            console.error('Resource lookup failed:', error.message);\n        } else {\n            console.error('An unexpected error occurred:', error.message);\n        }\n    } finally {\n        console.log('Cleanup resources if any');\n    }\n}\n\nmain();", "golden_completion": "        if (error instanceof ValidationError) {\n            console.error('Validation Error:', error.message);\n        } else if (error instanceof NotFoundError) {\n            console.error('Not Found Error:', error.message);\n        } else {\n            console.error('Unknown Error:', error.message);\n        }", "LLM_justification": "This example tests the LLM's ability to complete a try/catch/finally block with typed errors, including proper type guards and nested error handling. The completion requires understanding of custom error classes, type guards, and handling multiple error types. It also demonstrates correct usage of TypeScript's type system and ensures that the LLM can maintain proper indentation and syntax within complex nested structures.", "assertions": "import { strict as assert } from 'assert';\n(async () => {\n    try {\n        const result = await processResource('', 1);\n        assert.fail('Expected ValidationError was not thrown');\n    } catch (error) {\n        assert(error instanceof ValidationError, 'Error should be instance of ValidationError');\n        assert.strictEqual(error.message, 'Input cannot be empty');\n    }\n\n    try {\n        const result = await processResource('valid input', 2);\n        assert.fail('Expected NotFoundError was not thrown');\n    } catch (error) {\n        assert(error instanceof NotFoundError, 'Error should be instance of NotFoundError');\n        assert.strictEqual(error.message, 'Resource not found');\n    }\n\n    try {\n        const result = await processResource('valid input', 1);\n        assert.strictEqual(result, 'Processed Resource data');\n    } catch (error) {\n        assert.fail('Unexpected error was thrown');\n    }\n})();", "gpt-4o-copilot": "        console.error('An error occurred:', error.message);\n        throw error; // rethrow the error after logging"}
{"id": "40", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\nclass BaseError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'BaseError';\n    }\n}\n\nclass FileNotFoundError extends BaseError {\n    constructor(message: string) {\n        super(message);\n        this.name = 'FileNotFoundError';\n    }\n}\n\nclass PermissionError extends BaseError {\n    constructor(message: string) {\n        super(message);\n        this.name = 'PermissionError';\n    }\n}\n\nfunction readFileAsync(filePath: string): Promise<string> {\n    return new Promise<string>((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                if (err.code === 'ENOENT') {\n                    reject(new FileNotFoundError('File not found'));\n                } else if (err.code === 'EACCES') {\n                    reject(new PermissionError('Permission denied'));\n                } else {\n                    reject(new BaseError('Unknown error'));\n                }\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\nasync function readFileContents(filePath: string): Promise<string | null> {\n    try {\n        const data = await readFileAsync(filePath);\n        return data;\n    } catch (error) {", "suffix": "        return null;\n    }\n}\n\n(async () => {\n    const filePath = 'example.txt';\n    const content = await readFileContents(filePath);\n    if (content) {\n        console.log('File Content:', content);\n    } else {\n        console.log('Failed to read file.');\n    }\n})();\n", "golden_completion": "        if (error instanceof FileNotFoundError) {\n            console.error('File not found:', error.message);\n        } else if (error instanceof PermissionError) {\n            console.error('Permission denied:', error.message);\n        } else {\n            console.error('Error reading file:', error.message);\n        }", "LLM_justification": "This example tests the model's ability to handle complex error handling patterns with custom error hierarchies and type guards. It includes a nested try/catch block with specific error types and proper typing. The completion requires understanding of inheritance, proper error typing, and the ability to handle different error cases correctly. The assertions ensure that the correct error messages are logged based on the type of error encountered.", "assertions": "import assert from 'assert';\nimport { execSync } from 'child_process';\n\nconst result = execSync('ts-node <path_to_this_file>').toString();\nassert(result.includes('File not found:') || result.includes('Permission denied:') || result.includes('Error reading file:'));\n", "gpt-4o-copilot": "        console.error(error);"}
{"id": "41", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\nclass CustomError extends Error {\n    constructor(public message: string, public code: number) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nclass FileReadError extends CustomError {\n    constructor(message: string) {\n        super(message, 1001);\n        this.name = 'FileReadError';\n    }\n}\n\nclass FileParseError extends CustomError {\n    constructor(message: string) {\n        super(message, 1002);\n        this.name = 'FileParseError';\n    }\n}\n\nfunction parseJson(data: string): any {\n    try {\n        return JSON.parse(data);\n    } catch (e) {\n        throw new FileParseError('Failed to parse JSON');\n    }\n}\n\nasync function readFile(filePath: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(new FileReadError('Failed to read file'));\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\nasync function processFile(filePath: string): Promise<any> {\n    let fileContent: string | null = null;\n    try {\n        fileContent = await readFile(filePath);\n        const jsonData = parseJson(fileContent);\n        return jsonData;\n    } catch (error) {\n        if (error instanceof FileReadError) {\n            console.error('Error reading file:', error.message);\n        } else if (error instanceof FileParseError) {\n            console.error('Error parsing file:', error.message);\n        } else {\n            console.error('Unknown error:', error.message);\n        }\n        throw error;\n    } finally {", "suffix": "        console.log('Finished processing file:', filePath);\n    }\n}\n\n// Usage example\n(async () => {\n    try {\n        const data = await processFile('path/to/file.json');\n        console.log('Parsed data:', data);\n    } catch (e) {\n        console.error('Failed to process file:', e.message);\n    }\n})();\n", "golden_completion": "        if (fileContent !== null) {\n            console.log('Cleaning up resources...');\n        }\n", "LLM_justification": "This example effectively tests the LLM's ability to handle try/catch/finally blocks with typed errors, including custom error hierarchies and proper resource management. It demonstrates how to handle different error types and ensures proper cleanup within the finally block, which is a critical aspect of robust TypeScript programming. The scenario includes complex nesting and type annotations, providing a realistic and challenging test case.", "assertions": "import assert from 'assert';\n\n(async () => {\n    try {\n        let data = await processFile('path/to/file.json');\n        assert(data !== null, 'Data should not be null');\n    } catch (e) {\n        assert(e instanceof CustomError, 'Error should be an instance of CustomError');\n        assert(e.message !== '', 'Error message should not be empty');\n    }\n})();\n", "gpt-4o-copilot": "        if (fileContent) {\n            console.log('File content:', fileContent);\n        }"}
{"id": "42", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\n// Custom error classes\nclass FileNotFoundError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'FileNotFoundError';\n    }\n}\n\nclass PermissionError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'PermissionError';\n    }\n}\n\n// Utility function to read a file\nasync function readFile(filePath: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                if (err.code === 'ENOENT') {\n                    reject(new FileNotFoundError(`File not found: ${filePath}`));\n                } else if (err.code === 'EACCES') {\n                    reject(new PermissionError(`Permission denied: ${filePath}`));\n                } else {\n                    reject(new Error(`Unknown error: ${err.message}`));\n                }\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Function to process a file and handle errors\nasync function processFile(filePath: string): Promise<void> {\n    try {\n        const data = await readFile(filePath);\n        console.log('File data:', data);\n    } catch (error) {\n        if (error instanceof FileNotFoundError) {\n            console.error('Handling file not found error:', error.message);\n        } else if (error instanceof PermissionError) {\n            console.error('Handling permission error:', error.message);\n        } else {\n            console.error('Handling unknown error:', error.message);\n        }\n    }\n}\n\n// Test function to demonstrate error handling and resource cleanup\nasync function testErrorHandling() {\n    const testFilePath = './nonexistentfile.txt';\n", "suffix": "    await processFile(testFilePath);\n    console.log('Test completed.');\n}\n\ntestErrorHandling().then(() => console.log('All done.')).catch(console.error);\n", "golden_completion": "    try {\n        await processFile(testFilePath);\n    } catch (error) {\n        console.error('Error during file processing:', error);\n    } finally {\n        console.log('Cleanup resources if any.');\n    }\n", "LLM_justification": "This test case is a good example because it demonstrates complex error handling patterns in TypeScript, including custom error classes, try/catch/finally blocks, and nested promise handling. The extensive prefix provides a realistic and complete context for the completion, which involves properly handling errors and ensuring resource cleanup. The assertions ensure that errors are caught and handled appropriately, and the resources are cleaned up after the operation.", "assertions": "import assert from 'assert';\n\n(async function test() {\n    let caughtError = false;\n    try {\n        await processFile('./nonexistentfile.txt');\n    } catch (error) {\n        caughtError = true;\n        assert(error instanceof FileNotFoundError, 'Expected FileNotFoundError');\n    }\n    assert(caughtError, 'Expected an error to be caught');\n    console.log('Assertions passed.');\n})();\n", "gpt-4o-copilot": "    try {\n        await processFile(testFilePath);\n    } catch (error) {\n        console.error('Error during file processing:', error.message);\n    }"}
{"id": "43", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\n// Custom error classes\nclass FileNotFoundError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'FileNotFoundError';\n    }\n}\n\nclass PermissionError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'PermissionError';\n    }\n}\n\n// Function to read a file and process its content\nasync function readFileAndProcess(filePath: string): Promise<void> {\n    let fileHandle: fs.promises.FileHandle | null = null;\n    try {\n        fileHandle = await fs.promises.open(filePath, 'r');\n        const content = await fileHandle.readFile({ encoding: 'utf-8' });\n        console.log('File content:', content);\n        // Process the file content here\n    } catch (error) {\n        if (error.code === 'ENOENT') {\n            throw new FileNotFoundError(`File not found: ${filePath}`);\n        } else if (error.code === 'EACCES') {\n            throw new PermissionError(`Permission denied: ${filePath}`);\n        } else {\n            throw error;\n        }\n    } finally {\n        if (fileHandle) {\n            await fileHandle.close();\n        }\n    }\n}\n\n// Mock test function\nasync function testReadFileAndProcess() {\n    try {\n        await readFileAndProcess('/path/to/test/file.txt');\n        console.log('File processed successfully');\n    } catch (error) {", "suffix": "    }\n}\n\ntestReadFileAndProcess();\n\n// Assertions\nimport { strict as assert } from 'assert';\n\n(async () => {\n    let testError: Error | null = null;\n    try {\n        await readFileAndProcess('/invalid/path/to/file.txt');\n    } catch (error) {\n        testError = error;\n    }\n    assert(testError instanceof FileNotFoundError, 'Expected a FileNotFoundError');\n\n    testError = null;\n    try {\n        await readFileAndProcess('/path/without/permission.txt');\n    } catch (error) {\n        testError = error;\n    }\n    assert(testError instanceof PermissionError, 'Expected a PermissionError');\n})();", "golden_completion": "if (error instanceof FileNotFoundError) {\n            console.error('File not found:', error.message);\n        } else if (error instanceof PermissionError) {\n            console.error('Permission denied:', error.message);\n        } else {\n            console.error('An unknown error occurred:', error.message);\n        }", "LLM_justification": "This scenario demonstrates complex error handling patterns, including try/catch/finally with typed custom errors, proper resource management, and comprehensive error handling logic. It tests the LLM's ability to complete nested error handling blocks and ensure syntactic correctness. The assertions verify that specific errors are thrown under different conditions, ensuring type correctness and proper error transformation.", "assertions": "import { strict as assert } from 'assert';\n\n(async () => {\n    let testError: Error | null = null;\n    try {\n        await readFileAndProcess('/invalid/path/to/file.txt');\n    } catch (error) {\n        testError = error;\n    }\n    assert(testError instanceof FileNotFoundError, 'Expected a FileNotFoundError');\n\n    testError = null;\n    try {\n        await readFileAndProcess('/path/without/permission.txt');\n    } catch (error) {\n        testError = error;\n    }\n    assert(testError instanceof PermissionError, 'Expected a PermissionError');\n})();", "gpt-4o-copilot": "        console.error('Error processing file:', error);\n    }"}
{"id": "44", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\nclass CustomError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'CustomError';\n\t}\n}\n\nclass Resource {\n\tprivate resource: fs.FileHandle | null = null;\n\n\tasync open(filePath: string): Promise<void> {\n\t\ttry {\n\t\t\tthis.resource = await fs.promises.open(filePath, 'r');\n\t\t} catch (error) {\n\t\t\tthrow new CustomError('Failed to open file');\n\t\t}\n\t}\n\n\tasync read(): Promise<string> {\n\t\tif (!this.resource) {\n\t\t\tthrow new CustomError('Resource not opened');\n\t\t}\n\t\ttry {\n\t\t\tconst buffer = Buffer.alloc(1024);\n\t\t\tconst { bytesRead } = await this.resource.read(buffer, 0, 1024, 0);\n\t\t\treturn buffer.toString('utf-8', 0, bytesRead);\n\t\t} catch (error) {\n\t\t\tthrow new CustomError('Failed to read file');\n\t\t}\n\t}\n\n\tasync close(): Promise<void> {\n\t\tif (this.resource) {\n\t\t\tawait this.resource.close();\n\t\t\tthis.resource = null;\n\t\t}\n\t}\n}\n\nasync function processFile(filePath: string): Promise<string> {\n\tconst resource = new Resource();\n\ttry {\n\t\tawait resource.open(filePath);\n\t\tconst content = await resource.read();\n\t\treturn content;\n", "suffix": "\t} finally {\n\t\tawait resource.close();\n\t}\n}\n\n(async () => {\n\tconst filePath = 'testfile.txt';\n\ttry {\n\t\tconst content = await processFile(filePath);\n\t\tconsole.log(content);\n\t} catch (error) {\n\t\tif (error instanceof CustomError) {\n\t\t\tconsole.error('Custom error occurred:', error.message);\n\t\t} else {\n\t\t\tconsole.error('An unexpected error occurred:', error);\n\t\t}\n\t}\n})();", "golden_completion": "\t} catch (error) {\n\t\tif (error instanceof CustomError) {\n\t\t\tthrow error;\n\t\t} else {\n\t\t\tthrow new CustomError('Unexpected error occurred');\n\t\t}\n", "LLM_justification": "This example tests the LLM's ability to correctly handle nested try/catch/finally blocks with typed errors and custom error hierarchies. It demonstrates proper resource management and error transformation patterns with type guards, making it a robust test for understanding complex TypeScript syntax and type safety.", "assertions": "import assert from 'assert';\n\nasync function testProcessFile() {\n\tconst filePath = 'nonexistentfile.txt';\n\ttry {\n\t\tawait processFile(filePath);\n\t\tassert.fail('Expected error was not thrown');\n\t} catch (error) {\n\t\tassert(error instanceof CustomError, 'Error is not an instance of CustomError');\n\t\tassert.strictEqual(error.message, 'Failed to open file', 'Error message mismatch');\n\t}\n}\n\ntestProcessFile().then(() => console.log('All assertions passed')).catch(err => console.error('Assertions failed', err));", "gpt-4o-copilot": "\t} catch (error) {\n\t\tthrow new CustomError('Failed to process file');"}
{"id": "45", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\nclass CustomError extends Error {\n    constructor(public message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nclass FileReadError extends CustomError {\n    constructor(public filePath: string, message: string) {\n        super(message);\n        this.name = 'FileReadError';\n    }\n}\n\nclass FileProcessingError extends CustomError {\n    constructor(public fileName: string, message: string) {\n        super(message);\n        this.name = 'FileProcessingError';\n    }\n}\n\nasync function readFile(filePath: string): Promise<string> {\n    return new Promise<string>((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(new FileReadError(filePath, `Error reading file: ${err.message}`));\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\nasync function processFile(filePath: string): Promise<string> {\n    try {\n        const fileContent = await readFile(filePath);\n        if (fileContent.includes('error')) {\n            throw new FileProcessingError(filePath, 'File contains error text');\n        }\n        return `Processed: ${fileContent}`;\n    } catch (error) {\n        if (error instanceof FileReadError) {\n            console.error(`File read error: ${error.message}`);\n        } else if (error instanceof FileProcessingError) {\n            console.error(`File processing error: ${error.message}`);\n        } else {\n            console.error(`Unexpected error: ${error.message}`);\n        }\n        throw error;\n    }\n}\n\n// Helper function for testing\nfunction simulateFileRead(filePath: string, content: string, shouldError: boolean): void {\n    jest.spyOn(fs, 'readFile').mockImplementation((path, encoding, callback) => {\n        if (shouldError) {\n            callback(new Error('Simulated read error'), null);\n        } else {\n            callback(null, content);\n        }\n    });\n}\n\n// Test cases\nconst testFilePath = 'test.txt';\nsimulateFileRead(testFilePath, 'This is a test file.', false);", "suffix": "jest.restoreAllMocks();\n\nsimulateFileRead(testFilePath, 'This file contains an error.', false);\nprocessFile(testFilePath).catch(err => {\n    expect(err).toBeInstanceOf(FileProcessingError);\n    expect(err.message).toBe('File contains error text');\n});\n\njest.restoreAllMocks();\n\nsimulateFileRead(testFilePath, '', true);\nprocessFile(testFilePath).catch(err => {\n    expect(err).toBeInstanceOf(FileReadError);\n    expect(err.message).toBe('Error reading file: Simulated read error');\n});", "golden_completion": "await processFile(testFilePath).then(result => {\n    expect(result).toBe('Processed: This is a test file.');\n}).catch(err => {\n    throw err;\n});\n\njest.restoreAllMocks();\n\n", "LLM_justification": "This example tests the LLM's ability to understand complex error handling patterns with custom error hierarchies, proper typing, and error transformation. The completion involves nested try/catch blocks, type guards, and resource cleanup, ensuring the LLM can handle TypeScript's type system and asynchronous error handling correctly. The test case includes assertions for different error scenarios and verifies that the correct custom error types are thrown and handled, making it an excellent benchmark for syntax completion capabilities.", "assertions": "simulateFileRead(testFilePath, 'This is a test file.', false);\nawait processFile(testFilePath).then(result => {\n    expect(result).toBe('Processed: This is a test file.');\n}).catch(err => {\n    throw err;\n});\n\njest.restoreAllMocks();\n\nsimulateFileRead(testFilePath, 'This file contains an error.', false);\nprocessFile(testFilePath).catch(err => {\n    expect(err).toBeInstanceOf(FileProcessingError);\n    expect(err.message).toBe('File contains error text');\n});\n\njest.restoreAllMocks();\n\nsimulateFileRead(testFilePath, '', true);\nprocessFile(testFilePath).catch(err => {\n    expect(err).toBeInstanceOf(FileReadError);\n    expect(err.message).toBe('Error reading file: Simulated read error');\n});", "gpt-4o-copilot": "jest.restoreAllMocks();"}
{"id": "46", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\nclass CustomError extends Error {\n    constructor(public message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nclass FileReadError extends CustomError {\n    constructor(public filePath: string) {\n        super(`Failed to read file: ${filePath}`);\n        this.name = 'FileReadError';\n    }\n}\n\nclass FileParseError extends CustomError {\n    constructor(public filePath: string, public innerError: Error) {\n        super(`Failed to parse file: ${filePath} due to ${innerError.message}`);\n        this.name = 'FileParseError';\n    }\n}\n\nfunction readFile(filePath: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(new FileReadError(filePath));\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\nfunction parseFileContent(content: string): object {\n    try {\n        return JSON.parse(content);\n    } catch (error) {\n        throw new Error(`Invalid JSON format: ${error.message}`);\n    }\n}\n\nasync function processFile(filePath: string): Promise<void> {\n    try {\n        const content = await readFile(filePath);\n        const data = parseFileContent(content);\n        console.log('File data:', data);\n    } catch (error) {\n        if (error instanceof FileReadError) {\n            console.error('Error reading file:', error.message);\n        } else if (error instanceof Error) {\n            console.error('Unexpected error:', error.message);\n        } else {\n            console.error('Unknown error');\n        }\n    }\n}\n\n// Test the processFile function with a valid file\n(async () => {\n    await processFile('./validFile.json');\n    ", "suffix": "})();\n\n// Test the processFile function with an invalid file\n(async () => {\n    await processFile('./invalidFile.json');\n})();\n\n// Assertions\nimport assert from 'assert';\n\n(async () => {\n    try {\n        await processFile('./testFile.json');\n        assert(true, 'processFile should not throw an error with valid file');\n    } catch (e) {\n        assert.fail('processFile threw an error with valid file');\n    }\n\n    try {\n        await processFile('./nonExistentFile.json');\n        assert.fail('processFile did not throw an error with non-existent file');\n    } catch (e) {\n        assert(e instanceof FileReadError, 'processFile should throw FileReadError with non-existent file');\n    }\n})();", "golden_completion": "try {\n    const content = await readFile(filePath);\n    const data = parseFileContent(content);\n    console.log('File data:', data);\n} catch (error) {\n    if (error instanceof FileReadError) {\n        console.error('Error reading file:', error.message);\n    } else if (error instanceof Error) {\n        console.error('Unexpected error:', error.message);\n    } else {\n        console.error('Unknown error');\n    }\n}", "LLM_justification": "This test case assesses the LLM's ability to complete a complex try/catch/finally error handling pattern, including the proper usage of custom error classes with inheritance. The example demonstrates nested structures, type annotations, and proper resource management. The assertions test the function's behavior with both valid and invalid inputs, ensuring that the error handling works as expected and that the types are correctly checked. This makes it a robust test for syntax completion capabilities in TypeScript.", "assertions": "import assert from 'assert';\n\n(async () => {\n    try {\n        await processFile('./testFile.json');\n        assert(true, 'processFile should not throw an error with valid file');\n    } catch (e) {\n        assert.fail('processFile threw an error with valid file');\n    }\n\n    try {\n        await processFile('./nonExistentFile.json');\n        assert.fail('processFile did not throw an error with non-existent file');\n    } catch (e) {\n        assert(e instanceof FileReadError, 'processFile should throw FileReadError with non-existent file');\n    }\n})();", "gpt-4o-copilot": "})().catch(error => {\n    console.error('Error in test:', error.message);\n});"}
{"id": "47", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import { assert } from 'chai';\n\ninterface Product {\n\tname: string;\n\tprice: number;\n\tcategory: string;\n}\n\nclass ProductBuilder {\n\tprivate product: Product;\n\n\tconstructor() {\n\t\tthis.product = { name: '', price: 0, category: '' };\n\t}\n\n\tsetName(name: string): this {\n\t\tthis.product.name = name;\n\t\treturn this;\n\t}\n\n\tsetPrice(price: number): this {\n\t\tthis.product.price = price;\n\t\treturn this;\n\t}\n\n\tsetCategory(category: string): this {\n\t\tthis.product.category = category;\n\t\treturn this;\n\t}\n\n\tbuild(): Product {\n\t\treturn this.product;\n\t}\n}\n\nconst builder = new ProductBuilder();\nconst product = builder\n\t.setName('Laptop')\n\t.setPrice(1500)\n\t.setCategory('Electronics')\n\t.build();\n\nassert.strictEqual(product.name, 'Laptop');\nassert.strictEqual(product.price, 1500);\nassert.strictEqual(product.category, 'Electronics');\n\n// Now let's add a discount feature to the ProductBuilder\nProductBuilder.prototype.setDiscount = function (discount: number): this {\n\tif (discount < 0 || discount > 100) {\n\t\tthrow new Error('Discount must be between 0 and 100');\n\t}\n\tthis.product.price = this.product.price * (1 - discount / 100);\n\treturn this;\n};\n\n// Rebuild the product with the discount applied\nconst discountedProduct = builder", "suffix": ".setDiscount(10).build();\n\nassert.strictEqual(discountedProduct.price, 1350);\n\n// Clean up any resources if needed (not applicable in this scenario)\n", "golden_completion": "\n\t.setName('Laptop')\n\t.setPrice(1500)\n\t.setCategory('Electronics')", "LLM_justification": "This test case demonstrates the use of a builder pattern implementation with typed interfaces. The prefix sets up the context of creating a ProductBuilder class with method chaining for setting product properties. The golden completion continues this pattern by adding methods to set the product's name, price, and category, maintaining proper type inference and method chaining. The suffix applies a discount to the product and verifies the final price using assertions. This scenario tests the LLM's ability to handle complex multi-line method chaining patterns with proper type inference and maintain syntactic correctness and proper nesting.", "assertions": "assert.strictEqual(discountedProduct.name, 'Laptop');\nassert.strictEqual(discountedProduct.price, 1350);\nassert.strictEqual(discountedProduct.category, 'Electronics');", "gpt-4o-copilot": "\t.setName('Laptop')"}
{"id": "48", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import assert from 'assert';\n\n// Utility function to simulate async operation\nasync function asyncOperation(value: number): Promise<number> {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (value < 0) {\n                reject(new Error('Negative value not allowed'));\n            } else {\n                resolve(value * 2);\n            }\n        }, 1000);\n    });\n}\n\n// Custom error class for specific error handling\nclass CustomError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\n// Function that performs an async operation and handles errors\nasync function processValue(value: number): Promise<number> {\n    try {\n        const result = await asyncOperation(value);\n        return result;\n    } catch (error) {\n        if (error instanceof Error) {\n            throw new CustomError(`Processing error: ${error.message}`);\n        } else {\n            throw new CustomError('Unknown error');\n        }\n    }\n}\n\n// Function to test the error handling pattern\nasync function testErrorHandling(): Promise<void> {\n    try {\n        const positiveResult = await processValue(5);\n        assert.strictEqual(positiveResult, 10);\n", "suffix": "    } catch (error) {\n        if (error instanceof CustomError) {\n            assert.strictEqual(error.message, 'Processing error: Negative value not allowed');\n        } else {\n            throw error;\n        }\n    } finally {\n        console.log('Cleanup resources if any');\n    }\n}\n\ntestErrorHandling().then(() => console.log('Test completed')).catch(console.error);\n", "golden_completion": "        const negativeResult = await processValue(-5);\n        assert.fail('Expected error was not thrown');\n", "LLM_justification": "This example tests the LLM's ability to complete complex error handling patterns, including try/catch/finally blocks with typed errors, and nested error handling with custom error classes. It also verifies the model's capability to maintain proper indentation and syntactical correctness in a multi-line context.", "assertions": "assert.doesNotReject(testErrorHandling);\nassert.rejects(async () => processValue(-5), CustomError, 'Processing error: Negative value not allowed');", "gpt-4o-copilot": "        const negativeResult = await processValue(-5);\n        assert.fail('Expected error was not thrown');"}
{"id": "49", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\n// Interface for the FileHandlerBuilder\ninterface FileHandlerBuilder {\n\tsource(path: string): this;\n\tencoding(enc: BufferEncoding): this;\n\tread(): string;\n\twrite(content: string): void;\n}\n\n// Concrete implementation of the FileHandlerBuilder\nclass ConcreteFileHandlerBuilder implements FileHandlerBuilder {\n\tprivate filePath: string = '';\n\tprivate fileEncoding: BufferEncoding = 'utf-8';\n\n\tsource(path: string): this {\n\t\tthis.filePath = path;\n\t\treturn this;\n\t}\n\n\tencoding(enc: BufferEncoding): this {\n\t\tthis.fileEncoding = enc;\n\t\treturn this;\n\t}\n\n\tread(): string {\n\t\tif (!this.filePath) {\n\t\t\tthrow new Error('File path must be set');\n\t\t}\n\t\treturn fs.readFileSync(this.filePath, { encoding: this.fileEncoding });\n\t}\n\n\twrite(content: string): void {\n\t\tif (!this.filePath) {\n\t\t\tthrow new Error('File path must be set');\n\t\t}\n\t\tfs.writeFileSync(this.filePath, content, { encoding: this.fileEncoding });\n\t}\n}\n\n// Test Case Setup\nconst testFilePath = 'testfile.txt';\nconst testContent = 'This is a test.';\nconst testEncoding: BufferEncoding = 'utf-8';\n\n// Initialize FileHandlerBuilder\nconst fileHandler = new ConcreteFileHandlerBuilder();\n\n// Write initial content to file\nfileHandler.source(testFilePath).encoding(testEncoding).write(testContent);\n\n// Read and verify the content\nconst readContent = fileHandler.source(testFilePath).encoding(testEncoding).read();\n", "suffix": "\n// Clean up the test file\nfs.unlinkSync(testFilePath);\n\n// Additional check to ensure the file is deleted\ntry {\n\tfs.accessSync(testFilePath);\n\tthrow new Error('File should have been deleted');\n} catch (err) {\n\tif (err.code !== 'ENOENT') {\n\t\tthrow err;\n\t}\n}", "golden_completion": "console.assert(readContent === testContent, 'File content should match the written content');", "LLM_justification": "This test case is a good example because it demonstrates a complex multi-line syntax pattern with method chaining and type inference within a builder pattern. It ensures that the LLM can handle nested method calls and type constraints correctly. The assertions verify that the file content read matches the content written, which is a meaningful test of the FileHandlerBuilder's functionality. The cleanup code ensures that resources are managed appropriately after the assertions.", "assertions": "console.assert(readContent === testContent, 'File content should match the written content');", "gpt-4o-copilot": "if (readContent !== testContent) {\n\tthrow new Error('Content read from file does not match the expected content');\n}"}
{"id": "50", "testsource": "devbench-syntax-completion", "language": "typescript", "prefix": "import fs from 'fs';\n\n// Custom error class for file operations\nclass FileError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'FileError';\n\t}\n}\n\n// Function to read a file and return its content as a string\nasync function readFile(filePath: string): Promise<string> {\n\treturn new Promise((resolve, reject) => {\n\t\tfs.readFile(filePath, 'utf8', (err, data) => {\n\t\t\tif (err) {\n\t\t\t\treject(new FileError(`Failed to read file: ${filePath}`));\n\t\t\t} else {\n\t\t\t\tresolve(data);\n\t\t\t}\n\t\t});\n\t});\n}\n\n// Function to write data to a file\nasync function writeFile(filePath: string, data: string): Promise<void> {\n\treturn new Promise((resolve, reject) => {\n\t\tfs.writeFile(filePath, data, 'utf8', (err) => {\n\t\t\tif (err) {\n\t\t\t\treject(new FileError(`Failed to write to file: ${filePath}`));\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t});\n}\n\n// Function to process file content\nasync function processFileContent(filePath: string, transform: (content: string) => string): Promise<string> {\n\ttry {\n\t\tconst content = await readFile(filePath);\n\t\tconst transformedContent = transform(content);\n\t\tawait writeFile(filePath, transformedContent);\n\t\treturn transformedContent;\n\t} catch (error) {\n\t\tif (error instanceof FileError) {\n\t\t\tthrow error;\n\t\t} else {\n\t\t\tthrow new FileError('An unknown error occurred during file processing');\n\t\t}\n\t}\n}\n\n// Example usage\nconst filePath = 'example.txt';\nconst toUpperCase = (content: string) => content.toUpperCase();\n\n(async () => {\n\ttry {\n\t\tconst result = await processFileContent(filePath, toUpperCase);\n\t\tconsole.log('File processed successfully:', result);\n\t\t", "suffix": "console.error('An error occurred:', error);\n\t} finally {\n\t\t// Cleanup code here if needed\n\t}\n})();\n", "golden_completion": "console.log('Transformed content:', result);\n\t} catch (error) {\n\t\t", "LLM_justification": "This test case is designed to assess the model's capability to handle complex multi-line error handling patterns, specifically try/catch/finally blocks with custom error classes and proper type inference. The prefix sets up the context with file operations, custom error handling, and an async function that processes file content. The completion requires the model to insert a specific pattern of logging the result and handling errors correctly, maintaining the context and indentation. The suffix ensures that the error handling and cleanup code are distinct and follow the proper sequence.", "assertions": "import assert from 'assert';\n\n(async () => {\n\tlet caughtError = null;\n\ttry {\n\t\tawait processFileContent('nonexistent.txt', toUpperCase);\n\t} catch (error) {\n\t\tcaughtError = error;\n\t}\n\tassert(caughtError instanceof FileError, 'Expected a FileError to be thrown');\n\tassert.strictEqual(caughtError.message, 'Failed to read file: nonexistent.txt', 'Error message should match');\n})();\n\n(async () => {\n\tconst testFilePath = 'test.txt';\n\tfs.writeFileSync(testFilePath, 'hello world');\n\tconst result = await processFileContent(testFilePath, toUpperCase);\n\tassert.strictEqual(result, 'HELLO WORLD', 'Content should be transformed to upper case');\n\tconst fileContent = fs.readFileSync(testFilePath, 'utf8');\n\tassert.strictEqual(fileContent, 'HELLO WORLD', 'File content should be updated to upper case');\n\tfs.unlinkSync(testFilePath); // Cleanup\n})();", "gpt-4o-copilot": "\t} catch (error) {\n\t\tconsole.error('An error occurred:', error);"}
