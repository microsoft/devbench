
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// Define a type for a data entry
interface DataEntry {
    timestamp: string;
    value: number;
}

// Define a type for a dataset
interface Dataset {
    entries: DataEntry[];
}

// Function to parse CSV data into a Dataset
function parseCSV(data: string): Dataset {
    const lines = data.split('\n');
    const entries: DataEntry[] = lines.slice(1).map(line => {
        const [timestamp, value] = line.split(',');
        return { timestamp, value: parseFloat(value) };
    });
    return { entries };
}

// Function to clean dataset by removing invalid entries
function cleanDataset(dataset: Dataset): Dataset {
    const cleanedEntries = dataset.entries.filter(entry => !isNaN(entry.value));
    return { entries: cleanedEntries };
}

// Function to normalize dataset values to a range of 0 to 1
function normalizeDataset(dataset: Dataset): Dataset {
    const minValue = Math.min(...dataset.entries.map(entry => entry.value));
    const maxValue = Math.max(...dataset.entries.map(entry => entry.value));
    const normalizedEntries = dataset.entries.map(entry => ({
        ...entry,
        value: (entry.value - minValue) / (maxValue - minValue)
    }));
    return { entries: normalizedEntries };
}

// Example CSV data
const csvData = `timestamp,value
2023-01-01T00:00:00Z,10
2023-01-01T01:00:00Z,20
2023-01-01T02:00:00Z,30
2023-01-01T03:00:00Z,NaN
2023-01-01T04:00:00Z,50`;

// Parse the CSV data
const dataset = parseCSV(csvData);

// Clean the dataset
const cleanedDataset = cleanDataset(dataset);

// Expected cleaned dataset entries
const expectedCleanedEntries = [
    { timestamp: '2023-01-01T00:00:00Z', value: 10 },
    { timestamp: '2023-01-01T01:00:00Z', value: 20 },
    { timestamp: '2023-01-01T02:00:00Z', value: 30 },
    { timestamp: '2023-01-01T04:00:00Z', value: 50 }
];

// Assert that the cleaned dataset matches the expected cleaned entries


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
assert.deepStrictEqual(cleanedDataset.entries, expectedCleanedEntries);

SUFFIX CODE:
----------------------------------------


// Normalize the cleaned dataset
const normalizedDataset = normalizeDataset(cleanedDataset);

// Example assertions (not actual expected values)
const expectedNormalizedEntries = [
    { timestamp: '2023-01-01T00:00:00Z', value: 0 },
    { timestamp: '2023-01-01T01:00:00Z', value: 0.25 },
    { timestamp: '2023-01-01T02:00:00Z', value: 0.5 },
    { timestamp: '2023-01-01T04:00:00Z', value: 1 }
];

// Assert that the normalized dataset matches the expected normalized entries
assert.deepStrictEqual(normalizedDataset.entries, expectedNormalizedEntries);

// Cleanup code (if any)


JUSTIFICATION:
----------------------------------------
This test case demonstrates understanding of data validation (schema, cleaning, normalization) through functional programming patterns in TypeScript. The code parses a CSV string into a dataset, cleans it by removing invalid entries, and then normalizes the dataset values. The golden completion requires the LLM to correctly normalize the dataset and match expected values, demonstrating its ability to comprehend and apply data normalization logic. The assertions verify both functional and semantic correctness, ensuring the LLM understands the business purpose of data cleaning and normalization.

ASSERTIONS:
----------------------------------------
assert.deepStrictEqual(cleanedDataset.entries, expectedCleanedEntries);
assert.deepStrictEqual(normalizedDataset.entries, expectedNormalizedEntries);
================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);

// Define a structure to hold log data
interface LogData {
  timestamp: string;
  level: string;
  message: string;
}

// Utility function to get current timestamp
function getCurrentTimestamp(): string {
  return new Date().toISOString();
}

// Function to log a message
async function logMessage(level: string, message: string, filePath: string): Promise<void> {
  const logEntry: LogData = {
    timestamp: getCurrentTimestamp(),
    level,
    message
  };
  const logString = JSON.stringify(logEntry) + '\n';
  await writeFileAsync(filePath, logString, { flag: 'a' });
}

// Function to read and parse log file
async function readLogFile(filePath: string): Promise<LogData[]> {
  try {
    const data = await readFileAsync(filePath, 'utf-8');
    return data.split('\n').filter(line => line.trim() !== '').map(line => JSON.parse(line));
  } catch (err) {
    console.error('Failed to read log file:', err);
    return [];
  }
}

// Sample usage of the logging functions
const logFilePath = path.join(__dirname, 'logs.txt');

(async () => {
  await logMessage('info', 'Server started', logFilePath);
  await logMessage('error', 'Unhandled exception occurred', logFilePath);
  const logs = await readLogFile(logFilePath);
  console.log('Logs:', logs);
})();

// Function to filter logs by level
async function filterLogsByLevel(filePath: string, level: string): Promise<LogData[]> {
  const logs = await readLogFile(filePath);
  return logs.filter(log => log.level === level);
}

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
async function clearLogFile(filePath: string): Promise<void> {
  try {
    await writeFileAsync(filePath, '');
    console.log('Log file cleared');
  } catch (err) {
    console.error('Failed to clear log file:', err);
  }
}

SUFFIX CODE:
----------------------------------------
async function clearLogFile(filePath: string): Promise<void> {
  try {
    await writeFileAsync(filePath, '');
    console.log('Log file cleared');
  } catch (err) {
    console.error('Failed to clear log file:', err);
  }
}

(async () => {
  const errorLogs = await filterLogsByLevel(logFilePath, 'error');
  console.log('Error Logs:', errorLogs);
  await clearLogFile(logFilePath);
})();

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to understand async file operations within the context of system operations, specifically logging and monitoring. It checks if the LLM can correctly implement a function to count log entries, which is a logical extension of reading and filtering logs, a common task in system operations. The assertions verify that the function returns the expected number of log entries, testing both functional and semantic correctness.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';
(async () => {
  await logMessage('info', 'Test log entry 1', logFilePath);
  await logMessage('info', 'Test log entry 2', logFilePath);
  const logCount = await countLogEntries(logFilePath);
  assert.strictEqual(logCount, 2, 'Log count should be 2');
  await clearLogFile(logFilePath);
})();
================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

// Utility function to read a JSON file and parse its content
function readJSONFile(filePath: string): any {
    const rawData = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(rawData);
}

// Utility function to write data to a JSON file
function writeJSONFile(filePath: string, data: any): void {
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');
}

// Function to validate email format
function isValidEmail(email: string): boolean {
    const emailRegex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
    return emailRegex.test(email);
}

// Function to clean and normalize user data
function cleanAndNormalizeData(data: any): any {
    if (data.email && isValidEmail(data.email)) {
        data.email = data.email.toLowerCase();
    } else {
        throw new Error('Invalid email format');
    }
    return data;
}

// Main function to process user data file
function processUserDataFile(filePath: string): void {
    try {
        let userData = readJSONFile(filePath);
        userData = cleanAndNormalizeData(userData);
        writeJSONFile(filePath, userData);
    } catch (error) {
        console.error('Error processing user data file:', error);
    }
}

// Test setup
const testFilePath = path.join(__dirname, 'testUserData.json');
const validTestData = { name: 'John Doe', email: 'John.Doe@Example.com' };
const invalidTestData = { name: 'Jane Doe', email: 'Jane.Doe@Example' };

// Write test data to file for validation
writeJSONFile(testFilePath, validTestData);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
processUserDataFile(testFilePath);
try {
    writeJSONFile(testFilePath, invalidTestData);
    processUserDataFile(testFilePath);
} catch (error) {
    console.error('Caught expected error:', error.message);
}

SUFFIX CODE:
----------------------------------------


// Clean up test file
fs.unlinkSync(testFilePath);


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's understanding of data validation and normalization within the context of processing user data files. It checks the ability to follow the business logic of cleaning and normalizing user email addresses, ensuring valid email formats, and handling errors appropriately. The scenario involves reading from and writing to JSON files, validating email formats, and includes proper error handling. The assertions verify that the email normalization process is correctly implemented, making it a robust test for code purpose understanding.

ASSERTIONS:
----------------------------------------
console.assert(processedData.email === 'john.doe@example.com', 'Email normalization failed');
================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

// Define a User class with sensitive information
class User {
	constructor(public id: number, public name: string, public email: string) {}
}

// Define a LogEntry class for storing logs
class LogEntry {
	constructor(public timestamp: Date, public message: string) {}
}

// Define a Logger class to handle logging
class Logger {
	private logs: LogEntry[] = [];

	log(message: string) {
		this.logs.push(new LogEntry(new Date(), message));
	}

	getLogs(): LogEntry[] {
		return this.logs;
	}
}

// Define an AuthService class to handle user authentication
class AuthService {
	private users: User[] = [];
	private logger: Logger;

	constructor(logger: Logger) {
		this.logger = logger;
	}

	registerUser(id: number, name: string, email: string) {
		const newUser = new User(id, name, email);
		this.users.push(newUser);
		this.logger.log(`User registered: ${name}`);
	}

	private hashPassword(password: string): string {
		return crypto.createHash('sha256').update(password).digest('hex');
	}

	// Method to authenticate a user
	authenticateUser(id: number, password: string): boolean {
		const user = this.users.find(user => user.id === id);
		if (!user) {
			this.logger.log('Authentication failed: User not found');
			return false;
		}
		// Placeholder for actual password check
		const hashedPassword = this.hashPassword(password);
		if (hashedPassword === 'correctHashedPassword') {
			this.logger.log(`User authenticated: ${user.name}`);
			return true;
		} else {
			this.logger.log('Authentication failed: Incorrect password');
			return false;
		}
	}
}

// Setup the logger and auth service
const logger = new Logger();
const authService = new AuthService(logger);

// Register a new user
authService.registerUser(1, 'John Doe', 'john.doe@example.com');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Attempt to authenticate the user with the correct password
const isAuthenticatedCorrect = authService.authenticateUser(1, 'correctPassword');
console.log(`Authentication with correct password: ${isAuthenticatedCorrect}`);

SUFFIX CODE:
----------------------------------------

// Attempt to authenticate the user with an incorrect password
const isAuthenticatedIncorrect = authService.authenticateUser(1, 'wrongPassword');
console.log(`Authentication with incorrect password: ${isAuthenticatedIncorrect}`);

// Assertions
import * as assert from 'assert';
const logs = logger.getLogs();
assert.strictEqual(logs.length, 3);
assert.strictEqual(logs[0].message, 'User registered: John Doe');
assert.strictEqual(logs[1].message, 'Authentication failed: Incorrect password');

// Cleanup
console.log('Logs:', logs);


JUSTIFICATION:
----------------------------------------
This test case assesses the LLM's ability to understand the business logic of user authentication within a security context. The AuthService class handles user registration and authentication, logging each step. The golden completion correctly demonstrates the authentication process with the right password, ensuring the logs reflect successful authentication. The suffix tests an incorrect password scenario, while assertions verify the integrity and sequence of log entries, confirming both successful and failed authentication attempts.

ASSERTIONS:
----------------------------------------

import * as assert from 'assert';
const logs = logger.getLogs();
assert.strictEqual(logs.length, 3);
assert.strictEqual(logs[0].message, 'User registered: John Doe');
assert.strictEqual(logs[1].message, 'Authentication failed: Incorrect password');
assert.strictEqual(isAuthenticatedCorrect, true);
assert.strictEqual(logs[2].message, 'User authenticated: John Doe');

================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

// Define types for log entries and system metrics
interface LogEntry {
    timestamp: Date;
    level: 'INFO' | 'ERROR' | 'DEBUG';
    message: string;
}

interface SystemMetrics {
    cpuUsage: number;
    memoryUsage: number;
    diskSpace: number;
}

// Utility function to format log entries
function formatLogEntry(entry: LogEntry): string {
    return `[${entry.timestamp.toISOString()}] [${entry.level}] ${entry.message}`;
}

// Function to read and parse system metrics from a JSON file
function readSystemMetrics(filePath: string): SystemMetrics {
    const data = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(data) as SystemMetrics;
}

// Function to log system metrics
function logSystemMetrics(metrics: SystemMetrics): void {
    const logEntries: LogEntry[] = [];
    logEntries.push({
        timestamp: new Date(),
        level: 'INFO',
        message: `CPU Usage: ${metrics.cpuUsage}%`
    });
    logEntries.push({
        timestamp: new Date(),
        level: 'INFO',
        message: `Memory Usage: ${metrics.memoryUsage}MB`
    });
    logEntries.push({
        timestamp: new Date(),
        level: 'INFO',
        message: `Disk Space: ${metrics.diskSpace}GB`
    });

    for (const entry of logEntries) {
        console.log(formatLogEntry(entry));
    }
}

// Main function to monitor and log system metrics
function monitorSystemMetrics(metricFilePath: string): void {
    try {
        const metrics = readSystemMetrics(metricFilePath);
        logSystemMetrics(metrics);
    } catch (error) {
        const errorLog: LogEntry = {
            timestamp: new Date(),
            level: 'ERROR',
            message: `Failed to monitor system metrics: ${error.message}`
        };
        console.error(formatLogEntry(errorLog));
    }
}

// Mock data for testing
const mockMetrics: SystemMetrics = {
    cpuUsage: 45,
    memoryUsage: 1024,
    diskSpace: 250
};

const mockFilePath = path.join(__dirname, 'mockMetrics.json');
fs.writeFileSync(mockFilePath, JSON.stringify(mockMetrics));


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
monitorSystemMetrics(mockFilePath);

SUFFIX CODE:
----------------------------------------
monitorSystemMetrics(mockFilePath);
fs.unlinkSync(mockFilePath);


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to understand and continue code related to system operations, specifically logging and monitoring system metrics. The completion requires the LLM to correctly call the main function to monitor and log metrics, and then clean up the resources by deleting the mock file. The context involves handling file operations, logging, and error handling, which are common in system operations. Assertions ensure that metrics are logged correctly and resources are cleaned up properly.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';
import * as sinon from 'sinon';

const consoleLogSpy = sinon.spy(console, 'log');
const consoleErrorSpy = sinon.spy(console, 'error');

monitorSystemMetrics(mockFilePath);

assert.strictEqual(consoleLogSpy.callCount, 3, 'Expected 3 log entries for CPU, memory, and disk usage');
assert(consoleLogSpy.calledWithMatch(/CPU Usage: 45%/), 'Expected log entry for CPU usage');
assert(consoleLogSpy.calledWithMatch(/Memory Usage: 1024MB/), 'Expected log entry for memory usage');
assert(consoleLogSpy.calledWithMatch(/Disk Space: 250GB/), 'Expected log entry for disk space');
assert.strictEqual(consoleErrorSpy.callCount, 0, 'Expected no error log entries');

consoleLogSpy.restore();
consoleErrorSpy.restore();
fs.unlinkSync(mockFilePath);

================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface LogEntry {
    timestamp: Date;
    level: 'info' | 'warn' | 'error';
    message: string;
}

class Logger {
    private logFilePath: string;
    private logEntries: LogEntry[] = [];

    constructor(logFilePath: string) {
        this.logFilePath = logFilePath;
    }

    public log(level: 'info' | 'warn' | 'error', message: string) {
        const entry: LogEntry = {
            timestamp: new Date(),
            level,
            message
        };
        this.logEntries.push(entry);
    }

    public async saveLog() {
        const logData = this.logEntries.map(entry => `${entry.timestamp.toISOString()} [${entry.level}] ${entry.message}`).join('\n');
        await fs.promises.writeFile(this.logFilePath, logData);
    }
}

// Helper function to simulate a long-running task
function simulateTask(duration: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, duration));
}

async function runTaskWithLogging(logger: Logger) {
    try {
        logger.log('info', 'Task started');
        await simulateTask(1000);
        logger.log('info', 'Task completed successfully');
    } catch (error) {
        logger.log('error', 'Task failed');
    }
}

// Main execution function
async function main() {
    const logFilePath = path.resolve(__dirname, 'app.log');
    const logger = new Logger(logFilePath);

    await runTaskWithLogging(logger);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await logger.saveLog();

SUFFIX CODE:
----------------------------------------
    console.log('Log entries saved successfully');
}

main().catch(error => console.error('Main execution failed:', error));

JUSTIFICATION:
----------------------------------------
This test case is ideal as it evaluates the LLM's ability to understand the context of logging system operations. The Logger class is designed to handle log entries, and the main function is expected to log tasks and save these logs to a file. The golden completion involves saving the log entries, which is a critical part of the logging mechanism, ensuring that the logs are persisted appropriately. This showcases the LLM's capability to follow through with the business logic of logging and file operations.

ASSERTIONS:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';
import { strict as assert } from 'assert';

async function test() {
    const logFilePath = path.resolve(__dirname, 'app.log');
    const logger = new Logger(logFilePath);
    await runTaskWithLogging(logger);
    await logger.saveLog();

    const logData = await fs.promises.readFile(logFilePath, 'utf-8');
    assert(logData.includes('Task started'), 'Log should contain task start message');
    assert(logData.includes('Task completed successfully'), 'Log should contain task completion message');

    // Cleanup
    await fs.promises.unlink(logFilePath);
}

test().then(() => console.log('All assertions passed')).catch(error => console.error('Test failed:', error));
================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

// This module handles media file processing, specifically for image files.
// It includes functionality to read an image file, process it (e.g., resize), and save the output.

interface Image {
    width: number;
    height: number;
    data: Buffer;
}

interface ProcessedImage {
    width: number;
    height: number;
    data: Buffer;
    format: string;
}

class ImageProcessor {
    constructor(private inputDir: string, private outputDir: string) {}

    // Reads an image file from the input directory
    private readImage(filename: string): Promise<Image> {
        return new Promise((resolve, reject) => {
            const filePath = path.join(this.inputDir, filename);
            fs.readFile(filePath, (err, data) => {
                if (err) {
                    reject(`Failed to read image file: ${err.message}`);
                } else {
                    // Assume the image is in raw format for simplicity
                    resolve({ width: 800, height: 600, data });
                }
            });
        });
    }

    // Processes the image (e.g., resizing)
    private processImage(image: Image): ProcessedImage {
        const processedData = image.data; // Placeholder for actual processing logic
        const format = 'jpeg'; // Assume JPEG format for output
        return { ...image, data: processedData, format };
    }

    // Writes the processed image to the output directory
    private writeImage(filename: string, image: ProcessedImage): Promise<void> {
        return new Promise((resolve, reject) => {
            const filePath = path.join(this.outputDir, `${path.basename(filename, path.extname(filename))}.${image.format}`);
            fs.writeFile(filePath, image.data, (err) => {
                if (err) {
                    reject(`Failed to write image file: ${err.message}`);
                } else {
                    resolve();
                }
            });
        });
    }

    // Public method to process an image file
    public async processFile(filename: string): Promise<void> {
        try {
            const image = await this.readImage(filename);
            const processedImage = this.processImage(image);
            await this.writeImage(filename, processedImage);
        } catch (error) {
            console.error(`Error processing file ${filename}: ${error}`);
        }
    }
}

// Example usage
const processor = new ImageProcessor('./input', './output');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
processor.processFile('example.png').then(() => {
    console.log('Image processing completed successfully.');
}).catch((error) => {
    console.error('Image processing failed:', error);
});

SUFFIX CODE:
----------------------------------------
processor.processFile('example.png').then(() => {
    console.log('Image processing completed successfully.');
}).catch((error) => {
    console.error('Image processing failed:', error);
});

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to comprehend and extend a media processing system, specifically focusing on image processing. The scenario involves reading, processing, and saving image files using Promises and async/await patterns. The LLM must understand the business context of batch processing multiple image files, demonstrating knowledge of asynchronous operations and error handling in TypeScript. The golden completion introduces a higher-level function for batch processing, which is semantically consistent with the existing code.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';
(async () => {
    // Mocking the file system interactions
    const mockReadFile = jest.spyOn(fs, 'readFile').mockImplementation((filePath, callback) => {
        callback(null, Buffer.from('mock image data'));
    });
    const mockWriteFile = jest.spyOn(fs, 'writeFile').mockImplementation((filePath, data, callback) => {
        callback(null);
    });

    // Test the batch processing function
    await batchProcessFiles(['test1.png', 'test2.png']);
    assert.strictEqual(mockReadFile.mock.calls.length, 2, 'readFile should be called twice');
    assert.strictEqual(mockWriteFile.mock.calls.length, 2, 'writeFile should be called twice');

    // Restore the original implementations
    mockReadFile.mockRestore();
    mockWriteFile.mockRestore();
})();
================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import path from 'path';

// Event handling in a media processing context
// This function watches a directory for new image files and processes them
class ImageProcessor {
    private watchDir: string;
    private processedDir: string;

    constructor(watchDir: string, processedDir: string) {
        this.watchDir = watchDir;
        this.processedDir = processedDir;
    }

    // Initialize the directory watcher
    public startWatching() {
        fs.watch(this.watchDir, (eventType, filename) => {
            if (eventType === 'rename' && filename.endsWith('.jpg')) {
                this.processImage(path.join(this.watchDir, filename));
            }
        });
    }

    // Process the image file
    private processImage(filePath: string) {
        // Simulate image processing
        setTimeout(() => {
            console.log(`Processing image: ${filePath}`);
            const processedFilePath = path.join(this.processedDir, path.basename(filePath));
            fs.rename(filePath, processedFilePath, (err) => {
                if (err) {
                    console.error(`Error moving file: ${err.message}`);
                } else {
                    console.log(`File moved to: ${processedFilePath}`);
                }
            });
        }, 1000);
    }
}

// Setup directories for watching and processed images
const watchDir = './watch';
const processedDir = './processed';
fs.mkdirSync(watchDir, { recursive: true });
fs.mkdirSync(processedDir, { recursive: true });

// Create an instance of the ImageProcessor and start watching the directory
const imageProcessor = new ImageProcessor(watchDir, processedDir);
imageProcessor.startWatching();

// Function to simulate adding a new image file to the watch directory
function addNewImage(filename: string) {
    const filePath = path.join(watchDir, filename);
    fs.writeFileSync(filePath, ''); // Create an empty file
    console.log(`Added new image: ${filePath}`);
}

// Simulate adding a new image file
addNewImage('test.jpg');

// Process images

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// No additional code needed here as processing is triggered by the watcher

SUFFIX CODE:
----------------------------------------


JUSTIFICATION:
----------------------------------------
This example tests the LLM's understanding of event handling within a media processing context. The prefix sets up a directory watcher that processes new image files by moving them to a processed directory. The golden completion involves checking that the image file has been correctly processed and moved, which verifies the proper functioning of the event handler. This scenario is realistic and tests the LLM's ability to comprehend and continue code based on its business logic and context.

ASSERTIONS:
----------------------------------------
setTimeout(() => {
    const processedFilePath = path.join(processedDir, 'test.jpg');
    if (!fs.existsSync(processedFilePath)) {
        throw new Error('Assertion failed: Image was not moved to the processed directory.');
    }
    console.log('All assertions passed.');
}, 2000);
================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface LogEntry {
  timestamp: string;
  level: 'INFO' | 'WARN' | 'ERROR';
  message: string;
}

class Logger {
  private logFilePath: string;

  constructor(logFileName: string) {
    this.logFilePath = path.join(__dirname, logFileName);
  }

  private async writeLogEntry(entry: LogEntry): Promise<void> {
    const logLine = `${entry.timestamp} [${entry.level}] ${entry.message}\n`;
    return new Promise((resolve, reject) => {
      fs.appendFile(this.logFilePath, logLine, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }

  public async info(message: string): Promise<void> {
    const entry: LogEntry = { timestamp: new Date().toISOString(), level: 'INFO', message };
    await this.writeLogEntry(entry);
  }

  public async warn(message: string): Promise<void> {
    const entry: LogEntry = { timestamp: new Date().toISOString(), level: 'WARN', message };
    await this.writeLogEntry(entry);
  }

  public async error(message: string): Promise<void> {
    const entry: LogEntry = { timestamp: new Date().toISOString(), level: 'ERROR', message };
    await this.writeLogEntry(entry);
  }
}

const logger = new Logger('app.log');

async function simulateLogging(): Promise<void> {
  await logger.info('Application started');
  await logger.warn('Low disk space');
  await logger.error('Unhandled exception');
}

simulateLogging().catch((err) => console.error('Logging failed:', err));

// Next, we want to read the log file and check if the entries were properly logged.
async function readLogFile(logFilePath: string): Promise<string[]> {
  return new Promise((resolve, reject) => {
    fs.readFile(logFilePath, 'utf8', (err, data) => {
      if (err) reject(err);
      else resolve(data.split('\n').filter(line => line.length > 0));
    });
  });
}

// We will now test if the log entries were correctly written.


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
readLogFile(logger.logFilePath).then((logEntries) => {

SUFFIX CODE:
----------------------------------------
readLogFile(logger.logFilePath).then((logEntries) => {
  console.log('Log Entries:', logEntries);
}).catch((err) => console.error('Error reading log file:', err));

// Clean up the log file after testing
fs.unlink(logger.logFilePath, (err) => {
  if (err) console.error('Failed to delete log file:', err);
  else console.log('Log file deleted successfully');
});


JUSTIFICATION:
----------------------------------------
This test case examines the LLM's understanding of asynchronous file operations and logging in a system operations context. The Logger class demonstrates proper use of Promises for async file writes, and the readLogFile function reads and parses the log file asynchronously. The golden completion involves verifying that the log entries were correctly written, which tests the LLM's ability to follow and comprehend the business logic of logging in a system operations domain. The assertions ensure that the log entries match the expected values, maintaining semantic consistency with the logging operations performed in the prefix.

ASSERTIONS:
----------------------------------------
const logEntries = await readLogFile(logger.logFilePath);
console.assert(logEntries.length === 3, 'Expected 3 log entries');
console.assert(logEntries[0].includes('INFO') && logEntries[0].includes('Application started'), 'First log entry should be INFO: Application started');
console.assert(logEntries[1].includes('WARN') && logEntries[1].includes('Low disk space'), 'Second log entry should be WARN: Low disk space');
console.assert(logEntries[2].includes('ERROR') && logEntries[2].includes('Unhandled exception'), 'Third log entry should be ERROR: Unhandled exception');

================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';

interface LogEntry {
    timestamp: string;
    level: string;
    message: string;
}

class Logger {
    private logFilePath: string;

    constructor(logFilePath: string) {
        this.logFilePath = logFilePath;
    }

    private formatLogEntry(level: string, message: string): LogEntry {
        return {
            timestamp: new Date().toISOString(),
            level,
            message
        };
    }

    public async log(level: string, message: string): Promise<void> {
        const entry = this.formatLogEntry(level, message);
        const logLine = `${entry.timestamp} [${entry.level}] ${entry.message}\n`;
        try {
            await fs.promises.appendFile(this.logFilePath, logLine);
        } catch (error) {
            console.error('Failed to write log:', error);
        }
    }

    public async info(message: string): Promise<void> {
        await this.log('INFO', message);
    }

    public async warn(message: string): Promise<void> {
        await this.log('WARN', message);
    }

    public async error(message: string): Promise<void> {
        await this.log('ERROR', message);
    }
}

// Usage example
async function main() {
    const logger = new Logger('app.log');
    await logger.info('Application started');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await logger.warn('Low disk space');

SUFFIX CODE:
----------------------------------------
    await logger.warn('Low disk space');
    await logger.error('Unhandled exception occurred');
}

main().catch(console.error);


JUSTIFICATION:
----------------------------------------
This is a good test case because it involves asynchronous logging operations in a system operations context. The Logger class is designed to handle different log levels and append log entries to a file. The golden completion demonstrates the initialization of the logger and logging an informational message, which is consistent with the business logic of system operations logging. The assertions ensure that log entries are correctly appended to the file and follow the specified format.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';
import { readFileSync } from 'fs';

async function testLogger() {
    const logger = new Logger('test.log');
    await logger.info('Logger initialized successfully');
    await logger.warn('Low disk space');
    await logger.error('Unhandled exception occurred');

    const logContent = readFileSync('test.log', 'utf-8');
    assert(logContent.includes('Logger initialized successfully'), 'Log does not contain the initialization message');
    assert(logContent.includes('Low disk space'), 'Log does not contain the warning message');
    assert(logContent.includes('Unhandled exception occurred'), 'Log does not contain the error message');
}

testLogger().then(() => console.log('All assertions passed')).catch(console.error);

================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFileSync } from 'fs';

// A class representing a simple data analysis tool for processing CSV files
class CsvDataAnalyzer {
    private data: string[][] = [];

    constructor(private filePath: string) {}

    // Method to load and parse CSV data from the file
    loadData(): void {
        const fileContent = readFileSync(this.filePath, 'utf-8');
        const lines = fileContent.split('\n');
        this.data = lines.map(line => line.split(','));
    }

    // Method to calculate the average of a specific column
    calculateAverage(columnIndex: number): number {
        if (this.data.length === 0) {
            throw new Error('Data not loaded');
        }

        let sum = 0;
        let count = 0;
        for (const row of this.data) {
            const value = parseFloat(row[columnIndex]);
            if (!isNaN(value)) {
                sum += value;
                count++;
            }
        }

        if (count === 0) {
            throw new Error('No valid data in the specified column');
        }

        return sum / count;
    }

    // Method to find the maximum value in a specific column
    findMax(columnIndex: number): number {
        if (this.data.length === 0) {
            throw new Error('Data not loaded');
        }

        let max = -Infinity;
        for (const row of this.data) {
            const value = parseFloat(row[columnIndex]);
            if (!isNaN(value) && value > max) {
                max = value;
            }
        }

        if (max === -Infinity) {
            throw new Error('No valid data in the specified column');
        }

        return max;
    }
}

// Helper function to simulate a CSV file read
function simulateCsvFileRead(filePath: string, content: string): void {
    const fs = require('fs');
    fs.writeFileSync(filePath, content);
}

// Simulate CSV file content
const filePath = 'test.csv';
simulateCsvFileRead(filePath, 'name,age,salary\nAlice,30,1000\nBob,25,1500\nCharlie,35,2000\n');

// Instantiate CsvDataAnalyzer and load data
const analyzer = new CsvDataAnalyzer(filePath);
analyzer.loadData();

// Calculate average salary
const averageSalary = analyzer.calculateAverage(2);
console.log(`Average Salary: ${averageSalary}`);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------

// Find the maximum age
const maxAge = analyzer.findMax(1);
console.log(`Max Age: ${maxAge}`);

// Cleanup simulated file
const fs = require('fs');
fs.unlinkSync(filePath);

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's understanding of OOP patterns and data analysis in the context of processing CSV files. The CsvDataAnalyzer class provides methods to load data, calculate averages, and find maximum values in specific columns. The golden completion requires the LLM to correctly use the calculateAverage method to find the average age in the dataset, which demonstrates comprehension of both the class methods and the business logic of data analysis.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

// Ensure the average salary is calculated correctly
assert.equal(averageSalary, 1500, 'The average salary should be 1500');

// Ensure the average age is calculated correctly
const averageAge = analyzer.calculateAverage(1);
assert.equal(averageAge, 30, 'The average age should be 30');

// Ensure the maximum age is calculated correctly
const maxAge = analyzer.findMax(1);
assert.equal(maxAge, 35, 'The maximum age should be 35');
================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

// Represents a log entry with a message and timestamp
class LogEntry {
  constructor(public message: string, public timestamp: Date) {}
}

// A class that handles logging and monitoring system operations
class Logger {
  private logEntries: LogEntry[] = [];
  private logFilePath: string;

  constructor(logFilePath: string) {
    this.logFilePath = logFilePath;
  }

  // Adds a new log entry
  addLog(message: string): void {
    const logEntry = new LogEntry(message, new Date());
    this.logEntries.push(logEntry);
  }

  // Saves log entries to a file
  saveToFile(): Promise<void> {
    return new Promise((resolve, reject) => {
      const logData = this.logEntries.map(entry => `${entry.timestamp.toISOString()} - ${entry.message}`).join('\n');
      fs.writeFile(this.logFilePath, logData, 'utf8', (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  // Loads log entries from a file
  loadFromFile(): Promise<void> {
    return new Promise((resolve, reject) => {
      fs.readFile(this.logFilePath, 'utf8', (err, data) => {
        if (err) {
          reject(err);
        } else {
          const logEntries = data.split('\n').map(line => {
            const [timestamp, ...messageParts] = line.split(' - ');
            return new LogEntry(messageParts.join(' - '), new Date(timestamp));
          });
          this.logEntries = logEntries;
          resolve();
        }
      });
    });
  }
}

// Helper function to create a logger and add initial log entries
function initializeLogger(logFilePath: string): Logger {
  const logger = new Logger(logFilePath);
  logger.addLog('System initialized');
  logger.addLog('Configuration loaded');
  return logger;
}

// Test the logging system
const logFilePath = path.join(__dirname, 'system.log');
const logger = initializeLogger(logFilePath);
logger.addLog('User login detected');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
logger.saveToFile().then(() => {

SUFFIX CODE:
----------------------------------------
logger.loadFromFile().then(() => {
  console.log('Logs loaded successfully');
  console.log(logger);
}).catch((err) => {
  console.error('Error loading logs:', err);
});


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to understand the purpose of a logging and monitoring system using promises and async-await patterns. The completion requires the LLM to correctly continue the sequence of saving log entries to a file, which is a critical operation in system operations for logging and monitoring. The distinction between golden_completion and suffix ensures that the LLM understands the asynchronous flow and correct usage of promises in the context of logging.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';

const testLogFilePath = path.join(__dirname, 'test_system.log');
const testLogger = initializeLogger(testLogFilePath);
testLogger.addLog('Test entry');
testLogger.saveToFile().then(() => {
  console.log('Logs saved successfully');
  assert.ok(fs.existsSync(testLogFilePath), 'Log file should exist');
  const logContent = fs.readFileSync(testLogFilePath, 'utf8');
  assert.ok(logContent.includes('Test entry'), 'Log file should contain the test entry');
  testLogger.loadFromFile().then(() => {
    assert.strictEqual(testLogger['logEntries'].length, 3, 'Logger should have 3 entries after loading from file');
    assert.strictEqual(testLogger['logEntries'][2].message, 'Test entry', 'Last log entry should be the test entry');
  }).catch((err) => {
    assert.fail('Loading logs should not fail');
  });
}).catch((err) => {
  assert.fail('Saving logs should not fail');
});

================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFileSync } from 'fs';
import * as assert from 'assert';

// This utility function reads a JSON file and parses it into an object
function readJSONFile(filePath: string): any {
    const data = readFileSync(filePath, 'utf-8');
    return JSON.parse(data);
}

// This function validates a given user's data against a predefined schema
function validateUserData(userData: any, schema: any): boolean {
    for (const key in schema) {
        if (schema.hasOwnProperty(key)) {
            if (typeof userData[key] !== schema[key]) {
                return false;
            }
        }
    }
    return true;
}

// Schema definition for user data
const userSchema = {
    id: 'number',
    name: 'string',
    email: 'string',
    age: 'number'
};

// Example user data
const exampleUserData = {
    id: 1,
    name: 'John Doe',
    email: 'john.doe@example.com',
    age: 30
};

// Validate the example user data against the schema
const isValid = validateUserData(exampleUserData, userSchema);
assert.strictEqual(isValid, true, 'Example user data should be valid');

// Function to filter valid user data from a list
function filterValidUsers(users: any[], schema: any): any[] {
    return users.filter(user => validateUserData(user, schema));
}

// List of users to be validated
const users = [
    { id: 1, name: 'John Doe', email: 'john.doe@example.com', age: 30 },
    { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com', age: 25 },
    { id: 3, name: 'Invalid User', email: 'invalid@example.com', age: 'unknown' }
];


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const validUsers = filterValidUsers(users, userSchema);

SUFFIX CODE:
----------------------------------------


// Assertions
assert.strictEqual(validUsers.length, 2, 'There should be exactly 2 valid users');
assert.strictEqual(validUsers[0].name, 'John Doe', 'First valid user should be John Doe');
assert.strictEqual(validUsers[1].name, 'Jane Smith', 'Second valid user should be Jane Smith');

// Cleanup code (if any)


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to understand and continue code that involves data validation using schemas. The completion requires the LLM to recognize the existing pattern of schema validation and apply it correctly to filter a list of users based on the predefined schema. The test ensures that the LLM grasps the business logic of validating user data against a schema and can use a helper function to achieve this.

ASSERTIONS:
----------------------------------------
assert.strictEqual(validUsers.length, 2, 'There should be exactly 2 valid users');
assert.strictEqual(validUsers[0].name, 'John Doe', 'First valid user should be John Doe');
assert.strictEqual(validUsers[1].name, 'Jane Smith', 'Second valid user should be Jane Smith');
================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';

interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

const users: User[] = [
  { id: 1, name: 'Alice', email: 'alice@example.com', password: 'password123' },
  { id: 2, name: 'Bob', email: 'bob@example.com', password: 'securepass' },
];

function validateEmail(email: string): boolean {
  const emailRegex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
  return emailRegex.test(email);
}

function validatePassword(password: string): boolean {
  const minLength = 8;
  return password.length >= minLength;
}

function validateUser(user: User): ValidationResult {
  const errors: string[] = [];
  if (!validateEmail(user.email)) {
    errors.push('Invalid email format');
  }
  if (!validatePassword(user.password)) {
    errors.push('Password must be at least 8 characters long');
  }
  return {
    valid: errors.length === 0,
    errors,
  };
}

function saveUsersToFile(filename: string, users: User[]): void {
  const data = JSON.stringify(users, null, 2);
  fs.writeFileSync(filename, data, 'utf-8');
}

function loadUsersFromFile(filename: string): User[] {
  const data = fs.readFileSync(filename, 'utf-8');
  return JSON.parse(data);
}

function sanitizeUser(user: User): User {
  return {
    ...user,
    password: '', // Remove password for security reasons
  };
}

function sanitizeUsers(users: User[]): User[] {
  return users.map(sanitizeUser);
}

const filename = 'users.json';

// Save initial users to file
saveUsersToFile(filename, users);

// Load users from file
const loadedUsers = loadUsersFromFile(filename);

// Validate loaded users
const validationResults = loadedUsers.map(validateUser);
// Print validation errors


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
validationResults.forEach((result, index) => {
  if (!result.valid) {
    console.log(`User ${loadedUsers[index].id} validation errors: ${result.errors.join(', ')}`);
  }
});

SUFFIX CODE:
----------------------------------------

// Sanitize users for display
const sanitizedUsers = sanitizeUsers(loadedUsers);

// Display sanitized users
console.log(sanitizedUsers);

// Clean up the file after tests
fs.unlinkSync(filename);


JUSTIFICATION:
----------------------------------------
This test case is a good example because it combines data validation and file operations, which are common tasks in many applications. The prefix sets up a scenario where user data is validated and saved to a file, then loaded and validated again. The golden completion involves iterating over the validation results and logging any errors, demonstrating understanding of the business logic and validation requirements. The suffix sanitizes the user data for display and performs file cleanup, ensuring proper resource management. This scenario tests the LLM's ability to understand and correctly complete the validation and error handling logic in a realistic context.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

// Ensure the loaded users match the initial users
assert.deepEqual(loadedUsers, users);

// Ensure validation results are as expected
const expectedValidationResults = [
  { valid: true, errors: [] },
  { valid: true, errors: [] }
];
assert.deepEqual(validationResults, expectedValidationResults);

// Ensure sanitized users do not contain passwords
const expectedSanitizedUsers = [
  { id: 1, name: 'Alice', email: 'alice@example.com', password: '' },
  { id: 2, name: 'Bob', email: 'bob@example.com', password: '' }
];
assert.deepEqual(sanitizedUsers, expectedSanitizedUsers);

// Ensure the file no longer exists
assert.throws(() => fs.readFileSync(filename), /ENOENT/);

================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

interface Dataset {
    id: number;
    value: number;
}

class DataAnalyzer {
    private data: Dataset[];

    constructor(data: Dataset[]) {
        this.data = data;
    }

    public findMaxValue(): number {
        if (this.data.length === 0) {
            throw new Error('Dataset is empty');
        }
        return Math.max(...this.data.map(d => d.value));
    }

    public findMinValue(): number {
        if (this.data.length === 0) {
            throw new Error('Dataset is empty');
        }
        return Math.min(...this.data.map(d => d.value));
    }

    public calculateAverage(): number {
        if (this.data.length === 0) {
            throw new Error('Dataset is empty');
        }
        const sum = this.data.reduce((acc, d) => acc + d.value, 0);
        return sum / this.data.length;
    }

    public findMedian(): number {
        if (this.data.length === 0) {
            throw new Error('Dataset is empty');
        }
        const sorted = [...this.data].sort((a, b) => a.value - b.value);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 !== 0 ? sorted[mid].value : (sorted[mid - 1].value + sorted[mid].value) / 2;
    }

    // Next, we want to implement a method to normalize the dataset values


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    public normalizeValues(): number[] {
        if (this.data.length === 0) {
            throw new Error('Dataset is empty');
        }
        const min = this.findMinValue();
        const max = this.findMaxValue();
        if (max === min) {
            return this.data.map(() => 0);
        }
        return this.data.map(d => (d.value - min) / (max - min));
    }

SUFFIX CODE:
----------------------------------------

    // Method to remove any outliers from the dataset
    public removeOutliers(): Dataset[] {
        const q1 = this.calculateQuantile(0.25);
        const q3 = this.calculateQuantile(0.75);
        const iqr = q3 - q1;
        const lowerBound = q1 - 1.5 * iqr;
        const upperBound = q3 + 1.5 * iqr;
        return this.data.filter(d => d.value >= lowerBound && d.value <= upperBound);
    }

    private calculateQuantile(quantile: number): number {
        if (this.data.length === 0) {
            throw new Error('Dataset is empty');
        }
        const sorted = [...this.data].sort((a, b) => a.value - b.value);
        const pos = (sorted.length - 1) * quantile;
        const base = Math.floor(pos);
        const rest = pos - base;
        if ((sorted[base + 1] !== undefined)) {
            return sorted[base].value + rest * (sorted[base + 1].value - sorted[base].value);
        } else {
            return sorted[base].value;
        }
    }
}

const sampleData: Dataset[] = [
    { id: 1, value: 10 },
    { id: 2, value: 20 },
    { id: 3, value: 30 },
    { id: 4, value: 40 },
    { id: 5, value: 50 }
];
const analyzer = new DataAnalyzer(sampleData);

assert.strictEqual(analyzer.findMaxValue(), 50);
assert.strictEqual(analyzer.findMinValue(), 10);
assert.strictEqual(analyzer.calculateAverage(), 30);
assert.strictEqual(analyzer.findMedian(), 30);
assert.deepStrictEqual(analyzer.removeOutliers(), sampleData);


JUSTIFICATION:
----------------------------------------
This test case examines the LLM's ability to understand the purpose of implementing a method to normalize dataset values within a class designed for data analysis. The scenario involves typical data analysis functions such as finding the max, min, average, and median values. The completion requires the model to implement a method that normalizes the dataset values based on the minimum and maximum values. This tests the model's comprehension of data normalization in a statistical context, and its ability to continue a pattern of methods for analyzing datasets. The assertions confirm that the normalization function works correctly and integrates well with other methods in the class.

ASSERTIONS:
----------------------------------------
assert.deepStrictEqual(analyzer.normalizeData(), [
    { id: 1, value: 0 },
    { id: 2, value: 0.25 },
    { id: 3, value: 0.5 },
    { id: 4, value: 0.75 },
    { id: 5, value: 1 }
]);

================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface LogEntry {
    timestamp: string;
    level: 'INFO' | 'WARN' | 'ERROR';
    message: string;
}

class Logger {
    private logFilePath: string;
    private logEntries: LogEntry[] = [];

    constructor(logFilePath: string) {
        this.logFilePath = logFilePath;
    }

    private formatLogEntry(level: 'INFO' | 'WARN' | 'ERROR', message: string): LogEntry {
        return {
            timestamp: new Date().toISOString(),
            level,
            message
        };
    }

    public logInfo(message: string) {
        const logEntry = this.formatLogEntry('INFO', message);
        this.logEntries.push(logEntry);
        this.writeLogToFile(logEntry);
    }

    public logWarn(message: string) {
        const logEntry = this.formatLogEntry('WARN', message);
        this.logEntries.push(logEntry);
        this.writeLogToFile(logEntry);
    }

    public logError(message: string) {
        const logEntry = this.formatLogEntry('ERROR', message);
        this.logEntries.push(logEntry);
        this.writeLogToFile(logEntry);
    }

    private writeLogToFile(logEntry: LogEntry) {
        const logMessage = `${logEntry.timestamp} [${logEntry.level}] ${logEntry.message}\n`;
        fs.appendFileSync(this.logFilePath, logMessage);
    }

    public getLogs(): LogEntry[] {
        return this.logEntries;
    }
}

// Usage example
const logger = new Logger(path.join(__dirname, 'app.log'));
logger.logInfo('Application started');
logger.logWarn('Low disk space');
logger.logError('Unhandled exception occurred');

console.log('Current logs:', logger.getLogs());

// Function to rotate logs
function rotateLogs(logger: Logger, newLogFilePath: string) {

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    fs.renameSync(logger['logFilePath'], newLogFilePath);
    logger['logFilePath'] = newLogFilePath;
    logger['logEntries'] = [];

SUFFIX CODE:
----------------------------------------
}

// Test assertions
import * as assert from 'assert';

const testLogger = new Logger(path.join(__dirname, 'test.log'));
testLogger.logInfo('Test log entry');
assert.strictEqual(testLogger.getLogs().length, 1);
assert.strictEqual(testLogger.getLogs()[0].level, 'INFO');
assert.strictEqual(testLogger.getLogs()[0].message, 'Test log entry');

rotateLogs(testLogger, path.join(__dirname, 'new_test.log'));
assert.strictEqual(testLogger.getLogs().length, 0);

console.log('All tests passed');

// Clean up
fs.unlinkSync(path.join(__dirname, 'test.log'));
fs.unlinkSync(path.join(__dirname, 'new_test.log'));
fs.unlinkSync(path.join(__dirname, 'app.log'));


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to understand the purpose of rotating logs in a logging system, a common operation in system operations and monitoring. The Logger class manages log entries and writes them to a file, while the rotateLogs function is intended to transfer log entries to a new log file, simulating log rotation. The golden completion demonstrates the correct logic for transferring log entries from the old logger to a new logger, ensuring continuity of log data. The assertions verify that the logs are accurately transferred and the old log file is cleared, which are critical business rules in log management.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';

const testLogger = new Logger(path.join(__dirname, 'test.log'));
testLogger.logInfo('Test log entry');
assert.strictEqual(testLogger.getLogs().length, 1);
assert.strictEqual(testLogger.getLogs()[0].level, 'INFO');
assert.strictEqual(testLogger.getLogs()[0].message, 'Test log entry');

rotateLogs(testLogger, path.join(__dirname, 'new_test.log'));
assert.strictEqual(testLogger.getLogs().length, 0);

console.log('All tests passed');

// Clean up
fs.unlinkSync(path.join(__dirname, 'test.log'));
fs.unlinkSync(path.join(__dirname, 'new_test.log'));
fs.unlinkSync(path.join(__dirname, 'app.log'));

================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

// Utility function to check if a path is a directory
function isDirectory(filePath: string): boolean {
    return fs.statSync(filePath).isDirectory();
}

// Utility function to read files in a directory
function readDirectory(dirPath: string): string[] {
    return fs.readdirSync(dirPath);
}

// Function to filter and return only .txt files from a directory
function getTxtFiles(directory: string): string[] {
    return readDirectory(directory).filter(file => path.extname(file) === '.txt');
}

// Function to read the content of a file
function readFileContent(filePath: string): string {
    return fs.readFileSync(filePath, 'utf8');
}

// Function to process the content of a text file
function processFileContent(content: string): string {
    // Example processing: Convert to uppercase
    return content.toUpperCase();
}

// Function to write content to a file
function writeFileContent(filePath: string, content: string): void {
    fs.writeFileSync(filePath, content);
}

// Function to process all .txt files in a directory
function processTxtFilesInDirectory(directory: string): void {
    if (!isDirectory(directory)) {
        throw new Error(`${directory} is not a directory`);
    }

    const txtFiles = getTxtFiles(directory);
    for (const file of txtFiles) {
        const filePath = path.join(directory, file);
        const content = readFileContent(filePath);
        const processedContent = processFileContent(content);
        writeFileContent(filePath, processedContent);
    }
}

// Mock directory and files for testing
const testDir = './testDir';
const testFiles = ['test1.txt', 'test2.txt'];

if (!fs.existsSync(testDir)) {
    fs.mkdirSync(testDir);
}
for (const file of testFiles) {
    fs.writeFileSync(path.join(testDir, file), `Content of ${file}`);
}

try {
    processTxtFilesInDirectory(testDir);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
    // Cleanup
    for (const file of testFiles) {
        fs.unlinkSync(path.join(testDir, file));
    }
    fs.rmdirSync(testDir);
} catch (error) {
    console.error(error);
}


JUSTIFICATION:
----------------------------------------
This test case is a realistic example of a file processing system that reads, processes, and writes text files in a directory. It tests the LLM's ability to understand and continue code that handles string/text manipulation within a system operations context. The completion focuses on verifying that the text files have been processed correctly by reading and logging the processed content. This ensures the model comprehends the entire workflow and maintains the business logic of processing text files.

ASSERTIONS:
----------------------------------------
const processedContent1 = fs.readFileSync(path.join(testDir, 'test1.txt'), 'utf8');
const processedContent2 = fs.readFileSync(path.join(testDir, 'test2.txt'), 'utf8');
console.assert(processedContent1 === 'CONTENT OF TEST1.TXT', 'test1.txt content mismatch');
console.assert(processedContent2 === 'CONTENT OF TEST2.TXT', 'test2.txt content mismatch');

================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import { promisify } from 'util';

const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);

interface VideoMetadata {
    filename: string;
    duration: number;
    resolution: string;
    format: string;
}

// Helper function to simulate video processing
async function processVideo(file: string): Promise<VideoMetadata> {
    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, 1000));
    // Return mock metadata
    return {
        filename: file,
        duration: 3600,
        resolution: '1920x1080',
        format: 'mp4'
    };
}

// Function to handle video processing and saving metadata
async function handleVideoProcessing(inputFile: string, outputMetadataFile: string): Promise<void> {
    try {
        console.log(`Processing video: ${inputFile}`);
        const metadata = await processVideo(inputFile);
        console.log('Video processed successfully. Metadata:', metadata);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        const metadataJson = JSON.stringify(metadata, null, 2);

SUFFIX CODE:
----------------------------------------
        const metadataJson = JSON.stringify(metadata, null, 2);
        await writeFileAsync(outputMetadataFile, metadataJson);
        console.log(`Metadata saved to ${outputMetadataFile}`);
    } catch (error) {
        console.error('Error processing video:', error);
    }
}

// Test the video processing function
(async () => {
    const inputFile = 'example_video.mp4';
    const outputMetadataFile = 'video_metadata.json';
    await handleVideoProcessing(inputFile, outputMetadataFile);
})();


JUSTIFICATION:
----------------------------------------
This test case checks the LLM's ability to understand the business logic of video processing and validation of metadata. The completion ensures that the metadata generated from video processing is valid before proceeding to save it. This involves checking that all required fields in the metadata are present and correctly populated. The scenario is practical and reflects real-world requirements where data integrity is crucial before performing any file operations.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async () => {
    try {
        const inputFile = 'test_video.mp4';
        const outputMetadataFile = 'test_video_metadata.json';
        await handleVideoProcessing(inputFile, outputMetadataFile);
        const savedMetadata = await readFileAsync(outputMetadataFile, 'utf-8');
        const parsedMetadata = JSON.parse(savedMetadata);
        assert.strictEqual(parsedMetadata.filename, 'test_video.mp4', 'Filename should match the input video file');
        assert.strictEqual(parsedMetadata.duration, 3600, 'Duration should be 3600 seconds');
        assert.strictEqual(parsedMetadata.resolution, '1920x1080', 'Resolution should be 1920x1080');
        assert.strictEqual(parsedMetadata.format, 'mp4', 'Format should be mp4');
    } catch (error) {
        console.error('Assertion failed:', error);
        process.exit(1);
    }
    console.log('All assertions passed.');
})();
================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

// Utility function to read a file asynchronously
function readFileAsync(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Utility function to write data to a file asynchronously
function writeFileAsync(filePath: string, data: string): Promise<void> {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, data, 'utf8', (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Class to handle file operations for a media processing application
class MediaFileHandler {
    private directory: string;

    constructor(directory: string) {
        this.directory = directory;
    }

    // Method to process a media file
    async processFile(fileName: string): Promise<void> {
        const filePath = path.join(this.directory, fileName);
        try {
            const fileData = await readFileAsync(filePath);
            const processedData = this.modifyMediaContent(fileData);
            await writeFileAsync(filePath, processedData);
        } catch (error) {
            console.error(`Error processing file ${fileName}:`, error);
        }
    }

    // Placeholder method to modify media content
    private modifyMediaContent(data: string): string {
        // Simulate media content modification
        return data.toUpperCase();
    }
}

// Example usage
(async () => {
    const mediaHandler = new MediaFileHandler('./media');
    await mediaHandler.processFile('example.txt');
})();

// Test cases
async function testMediaFileHandler() {
    const testDirectory = './testMedia';
    const testFileName = 'test.txt';
    const testFilePath = path.join(testDirectory, testFileName);
    const originalContent = 'Hello, world!';
    const expectedContent = 'HELLO, WORLD!';

    // Ensure the test directory exists
    if (!fs.existsSync(testDirectory)) {
        fs.mkdirSync(testDirectory);
    }

    // Write the original content to the test file
    await writeFileAsync(testFilePath, originalContent);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    const mediaHandler = new MediaFileHandler(testDirectory);
    await mediaHandler.processFile(testFileName);
    const processedContent = await readFileAsync(testFilePath);
    if (processedContent !== expectedContent) {
        throw new Error(`Test failed: expected "${expectedContent}", got "${processedContent}"`);
    }

SUFFIX CODE:
----------------------------------------
console.log('Test completed');
}

testMediaFileHandler().then(() => {
    // Clean up test file
    fs.unlinkSync(path.join('./testMedia', 'test.txt'));
    fs.rmdirSync('./testMedia');
}).catch((error) => {
    console.error('Test failed:', error);
});

JUSTIFICATION:
----------------------------------------
This test case effectively evaluates the LLM's understanding of promises and async/await in the context of a media processing application. The prefix establishes a comprehensive setup, including utility functions for file operations and a class designed to process media files asynchronously. The golden completion involves correctly using the MediaFileHandler class to process a test file, followed by reading the file and asserting that its content matches the expected outcome. This scenario tests the LLM's ability to comprehend the asynchronous flow and maintain business logic consistency, ensuring that the file processing and content modification are correctly implemented. The suffix ensures cleanup of resources after assertions, adhering to best practices.

ASSERTIONS:
----------------------------------------
console.assert(fs.existsSync('./testMedia/test.txt'), 'Test file should exist');
console.assert(fs.readFileSync('./testMedia/test.txt', 'utf8') === 'HELLO, WORLD!', 'Test file content should be processed correctly');
================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// This module simulates a media processing pipeline where frames of a video are processed asynchronously.
// The main classes and functions are defined below:

// Represents a single frame of video
class VideoFrame {
    constructor(public id: number, public data: Uint8Array) {}
}

// A mock function to simulate asynchronous frame processing
async function processFrame(frame: VideoFrame): Promise<VideoFrame> {
    return new Promise((resolve) => {
        setTimeout(() => {
            // Simulate processing by modifying the frame data
            frame.data = frame.data.map((byte) => byte ^ 0xff); // Invert all bits
            resolve(frame);
        }, 100);
    });
}

// A class to handle the media processing pipeline
class MediaProcessor {
    private frames: VideoFrame[] = [];

    // Add a frame to the processing queue
    addFrame(frame: VideoFrame) {
        this.frames.push(frame);
    }

    // Process all frames asynchronously
    async processAllFrames(): Promise<VideoFrame[]> {
        const processedFrames: VideoFrame[] = [];
        for (const frame of this.frames) {
            const processedFrame = await processFrame(frame);
            processedFrames.push(processedFrame);
        }
        return processedFrames;
    }
}

// Helper function to create a random frame
function createRandomFrame(id: number): VideoFrame {
    const data = new Uint8Array(10);
    for (let i = 0; i < data.length; i++) {
        data[i] = Math.floor(Math.random() * 256);
    }
    return new VideoFrame(id, data);
}

// Create a media processor instance
const mediaProcessor = new MediaProcessor();

// Add some random frames to the processor
for (let i = 0; i < 5; i++) {
    mediaProcessor.addFrame(createRandomFrame(i));
}


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
mediaProcessor.processAllFrames()

SUFFIX CODE:
----------------------------------------
.finally(() => {
    // Clean up resources if any
    console.log('Processing complete');
});


JUSTIFICATION:
----------------------------------------
This test case effectively evaluates the LLM's ability to understand and continue TypeScript code that involves asynchronous processing of media frames. The prefix sets up a comprehensive media processing pipeline, including helper functions and classes. The golden completion and suffix focus on verifying that the asynchronous processing logic is correctly implemented and the processed frames meet the expected business rules, such as maintaining frame IDs and correctly inverting frame data. This scenario tests both the technical pattern of promises/async-await and the domain context of media processing, making it a robust benchmark for semantic code understanding.

ASSERTIONS:
----------------------------------------
mediaProcessor.processAllFrames().then((processedFrames) => {
    assert.strictEqual(processedFrames.length, 5, 'All frames should be processed');
    for (let i = 0; i < processedFrames.length; i++) {
        const originalFrame = mediaProcessor.frames[i];
        const processedFrame = processedFrames[i];
        // Ensure that the frame ID remains the same
        assert.strictEqual(originalFrame.id, processedFrame.id, 'Frame ID should not change');
        // Verify that the frame data has been processed (inverted)
        for (let j = 0; j < originalFrame.data.length; j++) {
            assert.strictEqual(originalFrame.data[j] ^ 0xff, processedFrame.data[j], 'Frame data should be inverted');
        }
    }
});

================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface MediaFile {
    name: string;
    path: string;
    size: number;
    type: 'image' | 'video' | 'audio';
}

class MediaProcessor {
    private mediaFiles: MediaFile[] = [];

    constructor(private directory: string) {}

    private async readDirectory(): Promise<void> {
        return new Promise((resolve, reject) => {
            fs.readdir(this.directory, (err, files) => {
                if (err) {
                    reject(err);
                } else {
                    files.forEach(file => {
                        const filePath = path.join(this.directory, file);
                        const stats = fs.statSync(filePath);
                        if (stats.isFile()) {
                            const fileType = this.getFileType(file);
                            if (fileType) {
                                this.mediaFiles.push({
                                    name: file,
                                    path: filePath,
                                    size: stats.size,
                                    type: fileType
                                });
                            }
                        }
                    });
                    resolve();
                }
            });
        });
    }

    private getFileType(fileName: string): 'image' | 'video' | 'audio' | null {
        const ext = path.extname(fileName).toLowerCase();
        switch (ext) {
            case '.jpg':
            case '.jpeg':
            case '.png':
            case '.gif':
                return 'image';
            case '.mp4':
            case '.avi':
            case '.mov':
                return 'video';
            case '.mp3':
            case '.wav':
            case '.flac':
                return 'audio';
            default:
                return null;
        }
    }

    public async processMediaFiles(): Promise<void> {
        await this.readDirectory();
        for (const mediaFile of this.mediaFiles) {
            try {
                await this.processFile(mediaFile);
            } catch (error) {
                console.error(`Failed to process file: ${mediaFile.name}`, error);
            }
        }
    }

    private async processFile(mediaFile: MediaFile): Promise<void> {
        // Placeholder for processing logic
        console.log(`Processing ${mediaFile.type} file: ${mediaFile.name}`);
    }
}

const mediaProcessor = new MediaProcessor('./media');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
mediaProcessor.processMediaFiles();

SUFFIX CODE:
----------------------------------------



JUSTIFICATION:
----------------------------------------
This scenario tests the model's ability to understand and continue TypeScript code involving async/await and error handling within a media processing context. The completion involves handling the promise returned by the processMediaFiles method and logging the appropriate messages based on success or failure. This requires understanding the purpose of the method and the business context of processing media files.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';

const logMessages: string[] = [];
const originalConsoleLog = console.log;
const originalConsoleError = console.error;

console.log = (message: string) => { logMessages.push(message); };
console.error = (message: string) => { logMessages.push(message); };

const mediaProcessor = new MediaProcessor('./media');
mediaProcessor.processMediaFiles().then(() => {
    assert.strictEqual(logMessages.includes('All media files processed successfully.'), true, 'Success message should be logged');
    assert.strictEqual(logMessages.some(msg => msg.includes('Error processing media files:')), false, 'Error message should not be logged');
}).catch(error => {
    assert.fail('Should not reach here');
}).finally(() => {
    console.log = originalConsoleLog;
    console.error = originalConsoleError;
});

================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import path from 'path';

// Configuration for the build process
const config = {
	buildDir: 'dist',
	srcDir: 'src',
	entryFile: 'index.ts',
	outputFile: 'bundle.js'
};

// Utility function to create directory if it doesn't exist
function ensureDirExists(dir: string): void {
	if (!fs.existsSync(dir)) {
		fs.mkdirSync(dir);
	}
}

// Function to clean the build directory
function cleanBuildDir(): void {
	if (fs.existsSync(config.buildDir)) {
		fs.readdirSync(config.buildDir).forEach((file) => {
			fs.unlinkSync(path.join(config.buildDir, file));
		});
	}
}

// Function to transpile TypeScript files to JavaScript
function transpile(srcFile: string, outFile: string): Promise<void> {
	return new Promise((resolve, reject) => {
		// Simulate transpilation process
		setTimeout(() => {
			try {
				const content = fs.readFileSync(srcFile, 'utf-8');
				const transpiledContent = content.replace(/console\.log/g, 'console.info'); // Simple transpilation mock
				fs.writeFileSync(outFile, transpiledContent);
				resolve();
			} catch (error) {
				reject(error);
			}
		}, 1000);
	});
}

// Main build function
async function buildProject(): Promise<void> {
	try {
		// Ensure build directory exists
		ensureDirExists(config.buildDir);
		
		// Clean build directory
		cleanBuildDir();
		
		// Transpile the entry file
		await transpile(path.join(config.srcDir, config.entryFile), path.join(config.buildDir, config.outputFile));
		
		console.info('Build completed successfully.');
	} catch (error) {
		console.error('Build failed:', error);
	}
}

// Run the build process
buildProject().then(() => {
	console.info('Build script finished.');
});


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
function createWatcher(dir: string) {
	let watcher: fs.FSWatcher | null = null;

	return {
		startWatching() {
			if (watcher) return;
			watcher = fs.watch(dir, { recursive: true }, (eventType, filename) => {
				if (filename) {
					console.info(`File changed: ${filename}, event: ${eventType}`);
					buildProject();
				}
			});
			console.info(`Started watching directory: ${dir}`);
		},
		stopWatching() {
			if (watcher) {
				watcher.close();
				watcher = null;
			}
		}
	};
}

SUFFIX CODE:
----------------------------------------


const projectWatcher = createWatcher(config.srcDir);
projectWatcher.startWatching();

// Stop watching after some time
setTimeout(() => {
	projectWatcher.stopWatching();
	console.info('Stopped watching for changes.');
}, 60000);


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's understanding of tool automation in the context of a build process. The completion involves creating a file watcher that triggers the build process upon changes in the source directory. This scenario tests the LLM's ability to comprehend asynchronous operations, event handling, and the integration of these concepts into a build automation context. The assertions verify that the watch functionality correctly triggers the build process and manages resources appropriately.

ASSERTIONS:
----------------------------------------
import assert from 'assert';
import sinon from 'sinon';

(async () => {
	const readFileSyncStub = sinon.stub(fs, 'readFileSync').returns('console.log("Hello, World!");');
	const writeFileSyncStub = sinon.stub(fs, 'writeFileSync');
	const watchStub = sinon.stub(fs, 'watch').callsFake((dir, callback) => {
		setTimeout(() => callback('change', 'index.ts'), 100);
		return { close: () => {} };
	});

	await buildProject();
	assert.ok(readFileSyncStub.calledOnce, 'readFileSync should be called once');
	assert.ok(writeFileSyncStub.calledOnce, 'writeFileSync should be called once');
	assert.strictEqual(writeFileSyncStub.firstCall.args[1], 'console.info("Hello, World!");', 'Transpilation should replace console.log with console.info');

	const projectWatcher = createWatcher(config.srcDir);
	projectWatcher.startWatching();

	setTimeout(() => {
		assert.ok(watchStub.calledOnce, 'fs.watch should be called once to start watching');
		assert.ok(readFileSyncStub.calledTwice, 'readFileSync should be called twice after file change');
		assert.ok(writeFileSyncStub.calledTwice, 'writeFileSync should be called twice after file change');
		projectWatcher.stopWatching();
		readFileSyncStub.restore();
		writeFileSyncStub.restore();
		watchStub.restore();
	}, 500);
})();

================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import path from 'path';

// Tool automation for builds: A utility to track build durations and log to a file

// A class to manage build metrics
class BuildMetrics {
    private buildStartTimes: Map<string, number>;
    private buildDurations: Map<string, number>;
    private logFilePath: string;

    constructor(logFilePath: string) {
        this.buildStartTimes = new Map();
        this.buildDurations = new Map();
        this.logFilePath = logFilePath;
    }

    // Method to start tracking a build
    startBuild(buildName: string): void {
        const startTime = Date.now();
        this.buildStartTimes.set(buildName, startTime);
    }

    // Method to stop tracking a build
    stopBuild(buildName: string): void {
        const endTime = Date.now();
        const startTime = this.buildStartTimes.get(buildName);
        if (startTime !== undefined) {
            const duration = endTime - startTime;
            this.buildDurations.set(buildName, duration);
        } else {
            throw new Error(`Build ${buildName} was not started.`);
        }
    }

    // Method to log build durations to a file
    logBuildDurations(): void {
        const logEntries = [];
        this.buildDurations.forEach((duration, buildName) => {
            logEntries.push(`${buildName}: ${duration}ms`);
        });
        const logData = logEntries.join('\n');
        fs.writeFileSync(this.logFilePath, logData);
    }
}

// Example usage of the BuildMetrics class
const metrics = new BuildMetrics(path.join(__dirname, 'build.log'));
metrics.startBuild('build-1');
setTimeout(() => {
    metrics.stopBuild('build-1');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    metrics.logBuildDurations();

SUFFIX CODE:
----------------------------------------
    console.log('Build 1 duration logged.');
}, 1000);

// Assertions
const logFilePath = path.join(__dirname, 'build.log');

setTimeout(() => {
    const logContent = fs.readFileSync(logFilePath, 'utf-8');
    console.assert(logContent.includes('build-1: '), 'Build duration should be logged.');
}, 1500);


JUSTIFICATION:
----------------------------------------
This test case evaluates an LLM's understanding of tool automation in a build process context, specifically focusing on logging build durations. The provided prefix sets up a class to track and log build metrics, and the completion requires the LLM to correctly identify where to invoke the logging method to maintain the business logic of recording build durations. The assertions check that the build duration is correctly logged, ensuring the LLM comprehends the purpose and flow of the code.

ASSERTIONS:
----------------------------------------
const logFilePath = path.join(__dirname, 'build.log');

setTimeout(() => {
    const logContent = fs.readFileSync(logFilePath, 'utf-8');
    console.assert(logContent.includes('build-1: '), 'Build duration should be logged.');
}, 1500);

================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

// Utility function to read JSON data from a file
function readJsonFile(filePath: string): any {
    const data = readFileSync(filePath, 'utf-8');
    return JSON.parse(data);
}

// Utility function to write JSON data to a file
function writeJsonFile(filePath: string, data: any): void {
    const jsonData = JSON.stringify(data, null, 2);
    writeFileSync(filePath, jsonData, 'utf-8');
}

// Function to generate a report based on metrics
function generateReport(metrics: any[]): any {
    let total = 0;
    let count = 0;
    for (const metric of metrics) {
        total += metric.value;
        count++;
    }
    const average = total / count;
    return { total, average, count };
}

// Mock data for metrics
const metrics = [
    { id: 1, value: 10 },
    { id: 2, value: 20 },
    { id: 3, value: 30 }
];

// Path to the report file
const reportFilePath = join(__dirname, 'report.json');

// Read existing report
let report;
try {
    report = readJsonFile(reportFilePath);
} catch (error) {
    report = null;
}

// Generate new report
const newReport = generateReport(metrics);

// Save the new report
writeJsonFile(reportFilePath, newReport);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Assertions to verify the correctness of the report
import { strict as assert } from 'assert';

const expectedReport = { total: 60, average: 20, count: 3 };
assert.deepStrictEqual(newReport, expectedReport, 'The generated report does not match the expected report.');

// Cleanup: delete the report file
import { unlinkSync } from 'fs';
unlinkSync(reportFilePath);

SUFFIX CODE:
----------------------------------------
// Assertions to verify the correctness of the report
import { strict as assert } from 'assert';

const expectedReport = { total: 60, average: 20, count: 3 };
assert.deepStrictEqual(newReport, expectedReport, 'The generated report does not match the expected report.');

// Cleanup: delete the report file
import { unlinkSync } from 'fs';
unlinkSync(reportFilePath);


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to understand the semantic pattern of generating and updating a report based on metrics data. The scenario involves reading and writing JSON files, generating a new report, and updating an existing report. The golden completion demonstrates the correct merging of new report data with existing report data, which is a common business logic requirement in analytics contexts. The assertions verify the correctness of the generated report, ensuring that the business rules are maintained.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';
const expectedUpdatedReport = { total: 60, average: 20, count: 3 };
const finalReport = readJsonFile(reportFilePath);
assert.deepStrictEqual(finalReport, expectedUpdatedReport, 'The final report does not match the expected updated report.');
================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFileSync } from 'fs';
import { createHash } from 'crypto';

// Utility function to read a file and return its content as string
function readFileContent(filePath: string): string {
    try {
        return readFileSync(filePath, 'utf8');
    } catch (error) {
        console.error(`Error reading file: ${filePath}`, error);
        throw new Error('File read failed');
    }
}

// Utility function to hash content using SHA-256
function hashContent(content: string): string {
    const hash = createHash('sha256');
    hash.update(content);
    return hash.digest('hex');
}

// Higher-order function to create an auditing mechanism
function createAuditor(logFunction: (message: string) => void) {
    return function (action: string, content: string) {
        const timestamp = new Date().toISOString();
        const hashedContent = hashContent(content);
        logFunction(`[${timestamp}] Action: ${action}, Hash: ${hashedContent}`);
    };
}

// Example log function
function logToConsole(message: string) {
    console.log(message);
}

// Create an auditor instance
const audit = createAuditor(logToConsole);

// Example content and action
const exampleContent = 'Sensitive data that needs auditing';
const exampleAction = 'DATA_ACCESS';

// Perform the audit


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
audit('DATA_MODIFICATION', exampleContent);

SUFFIX CODE:
----------------------------------------
audit('DATA_MODIFICATION', exampleContent);

// Assertions
import assert from 'assert';

const logMessages: string[] = [];
function mockLogFunction(message: string) {
    logMessages.push(message);
}

const mockAudit = createAuditor(mockLogFunction);
mockAudit('DATA_ACCESS', exampleContent);

assert.strictEqual(logMessages.length, 1, 'Log message should be recorded');
assert.ok(logMessages[0].includes('DATA_ACCESS'), 'Log message should contain the action');
assert.ok(logMessages[0].includes(hashContent(exampleContent)), 'Log message should contain the hashed content');

// Cleanup
logMessages.length = 0;

JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to understand higher-order functions and their use in a security context, specifically auditing. The prefix sets up utility functions for reading file content and hashing it, and it defines a higher-order function `createAuditor` that logs actions and hashed content. The completion involves using this auditor to log a specific action, demonstrating the LLM's comprehension of the business logic and correct usage of the provided functions. The assertions verify the correct logging behavior, ensuring that the action and hashed content are properly recorded. This makes it a good test case for understanding the semantic purpose and business rules.

ASSERTIONS:
----------------------------------------
import assert from 'assert';

const logMessages: string[] = [];
function mockLogFunction(message: string) {
    logMessages.push(message);
}

const mockAudit = createAuditor(mockLogFunction);
mockAudit('DATA_ACCESS', exampleContent);

assert.strictEqual(logMessages.length, 1, 'Log message should be recorded');
assert.ok(logMessages[0].includes('DATA_ACCESS'), 'Log message should contain the action');
assert.ok(logMessages[0].includes(hashContent(exampleContent)), 'Log message should contain the hashed content');

// Cleanup
logMessages.length = 0;
================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import path from 'path';

interface Report {
    id: number;
    name: string;
    data: any[];
}

class ReportGenerator {
    private reports: Report[] = [];

    public addReport(report: Report) {
        this.reports.push(report);
    }

    public async saveReports(directory: string): Promise<void> {
        if (!fs.existsSync(directory)) {
            fs.mkdirSync(directory);
        }
        for (const report of this.reports) {
            const filePath = path.join(directory, `${report.name}.json`);
            await this.saveReport(filePath, report.data);
        }
    }

    private async saveReport(filePath: string, data: any[]): Promise<void> {
        return new Promise((resolve, reject) => {
            fs.writeFile(filePath, JSON.stringify(data, null, 2), (err) => {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }
}

// Example usage
(async () => {
    const reportGenerator = new ReportGenerator();
    reportGenerator.addReport({ id: 1, name: 'report1', data: [{ key: 'value1' }] });
    reportGenerator.addReport({ id: 2, name: 'report2', data: [{ key: 'value2' }] });


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await reportGenerator.saveReports('./reports');

SUFFIX CODE:
----------------------------------------
})();
console.log('Reports saved successfully.');


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to understand and continue a TypeScript code block that involves asynchronous file operations and object-oriented programming patterns. The given context sets up a scenario where a ReportGenerator class is used to add and save reports to a directory. The completion requires understanding the purpose of saving reports and correctly using the async/await pattern to ensure proper execution. It also involves handling file system operations, which is crucial in tool automation contexts like builds, tests, and deployment.

ASSERTIONS:
----------------------------------------
import assert from 'assert';
import fs from 'fs';

(async () => {
    const reportGenerator = new ReportGenerator();
    reportGenerator.addReport({ id: 1, name: 'report1', data: [{ key: 'value1' }] });
    reportGenerator.addReport({ id: 2, name: 'report2', data: [{ key: 'value2' }] });
    await reportGenerator.saveReports('./reports');
    assert(fs.existsSync('./reports/report1.json'), 'Report1 should be saved');
    assert(fs.existsSync('./reports/report2.json'), 'Report2 should be saved');
    const report1Content = JSON.parse(fs.readFileSync('./reports/report1.json', 'utf-8'));
    const report2Content = JSON.parse(fs.readFileSync('./reports/report2.json', 'utf-8'));
    assert.deepStrictEqual(report1Content, [{ key: 'value1' }], 'Report1 content should match');
    assert.deepStrictEqual(report2Content, [{ key: 'value2' }], 'Report2 content should match');
    console.log('All assertions passed.');
})();

================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface Report {
    id: number;
    name: string;
    data: any;
}

interface AnalyticsService {
    fetchReport(reportId: number): Promise<Report>;
    processReport(report: Report): void;
    saveProcessedReport(report: Report): Promise<void>;
}

class AnalyticsServiceImpl implements AnalyticsService {
    async fetchReport(reportId: number): Promise<Report> {
        try {
            const response = await axios.get<Report>(`/api/reports/${reportId}`);
            return response.data;
        } catch (error) {
            throw new Error('Failed to fetch report');
        }
    }

    processReport(report: Report): void {
        // Simulate report processing
        report.data = { processed: true, originalData: report.data };
    }

    async saveProcessedReport(report: Report): Promise<void> {
        try {
            await axios.post('/api/reports', report);
        } catch (error) {
            throw new Error('Failed to save processed report');
        }
    }
}

async function generateAndSaveReport(analyticsService: AnalyticsService, reportId: number) {
    try {
        const report = await analyticsService.fetchReport(reportId);
        analyticsService.processReport(report);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        await analyticsService.saveProcessedReport(report);

SUFFIX CODE:
----------------------------------------
        console.log('Report processed and saved successfully');
    } catch (error) {
        console.error('Error during report generation and saving:', error);
    }
}

// Example usage
(async () => {
    const analyticsService = new AnalyticsServiceImpl();
    await generateAndSaveReport(analyticsService, 1);
})();


JUSTIFICATION:
----------------------------------------
This example tests the LLM's understanding of promises and async-await patterns within the context of an analytics service. The task involves fetching a report, processing it, and then saving the processed report. The golden completion demonstrates the correct use of async-await to ensure the save operation completes successfully. The assertions check that the report is processed and saved as expected, verifying both functional correctness and adherence to business rules.

ASSERTIONS:
----------------------------------------
const mockReport = { id: 1, name: 'Test Report', data: {} };
const mockAxiosGet = jest.spyOn(axios, 'get').mockResolvedValue({ data: mockReport });
const mockAxiosPost = jest.spyOn(axios, 'post').mockResolvedValue({});
const analyticsService = new AnalyticsServiceImpl();

(async () => {
    await generateAndSaveReport(analyticsService, 1);

    expect(mockAxiosGet).toHaveBeenCalledWith('/api/reports/1');
    expect(mockAxiosPost).toHaveBeenCalledWith('/api/reports', { id: 1, name: 'Test Report', data: { processed: true, originalData: {} } });
})();

mockAxiosGet.mockRestore();
mockAxiosPost.mockRestore();
================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFile } from 'fs/promises';
import { join } from 'path';

interface Metric {
    timestamp: number;
    value: number;
}

class MetricsReporter {
    private metrics: Metric[] = [];

    constructor(private filePath: string) {}

    async loadMetrics(): Promise<void> {
        try {
            const data = await readFile(this.filePath, 'utf-8');
            this.metrics = JSON.parse(data);
        } catch (error) {
            console.error('Failed to load metrics:', error);
        }
    }

    addMetric(value: number): void {
        const metric: Metric = {
            timestamp: Date.now(),
            value
        };
        this.metrics.push(metric);
    }

    getMetrics(startTime: number, endTime: number): Metric[] {
        return this.metrics.filter(metric => metric.timestamp >= startTime && metric.timestamp <= endTime);
    }
}

async function main() {
    const reporter = new MetricsReporter(join(__dirname, 'metrics.json'));
    await reporter.loadMetrics();
    reporter.addMetric(42);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await reporter.loadMetrics();

SUFFIX CODE:
----------------------------------------

    const metrics = reporter.getMetrics(Date.now() - 1000 * 60 * 60, Date.now());
    console.log(metrics);
}

main().catch(console.error);


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to understand the context of loading metrics from a file, adding a new metric, and retrieving metrics within a specified time range. The prefix sets up a MetricsReporter class with methods to load metrics from a JSON file, add a new metric, and filter metrics by timestamp. The golden completion involves reloading the metrics after adding a new one, which ensures the updated metrics list is accurate when retrieved. This scenario tests comprehension of async/await patterns, error handling, and the business logic of metric reporting.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async () => {
    const testFilePath = join(__dirname, 'test_metrics.json');
    const testData = JSON.stringify([{ timestamp: Date.now() - 1000 * 60, value: 10 }]);

    await writeFile(testFilePath, testData);

    const reporter = new MetricsReporter(testFilePath);
    await reporter.loadMetrics();
    reporter.addMetric(42);
    await reporter.loadMetrics();

    const metrics = reporter.getMetrics(Date.now() - 1000 * 60 * 60, Date.now());
    assert(metrics.length === 2, 'Metrics count should be 2');
    assert(metrics[1].value === 42, 'The second metric value should be 42');

    await unlink(testFilePath);
})();
================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

interface User {
	id: string;
	username: string;
	passwordHash: string;
}

class UserService {
	private users: Map<string, User> = new Map();

	constructor() {}

	private hashPassword(password: string): string {
		return crypto.createHash('sha256').update(password).digest('hex');
	}

	public addUser(username: string, password: string): User {
		const id = crypto.randomUUID();
		const passwordHash = this.hashPassword(password);
		const newUser: User = { id, username, passwordHash };
		this.users.set(id, newUser);
		return newUser;
	}

	public authenticate(username: string, password: string): boolean {
		for (const user of this.users.values()) {
			if (user.username === username && user.passwordHash === this.hashPassword(password)) {
				return true;
			}
		}
		return false;
	}
}

// Example usage
const userService = new UserService();
const user = userService.addUser('testUser', 'securePassword');
console.log('User created:', user);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const isAuthenticated = userService.authenticate('testUser', 'securePassword');

SUFFIX CODE:
----------------------------------------
console.log('Authentication status:', isAuthenticated);

// Clean up resources
userService['users'].clear();


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to understand authentication logic within a security context. The prefix sets up user creation and password hashing, while the golden completion requires correctly authenticating a user. The suffix tests incorrect authentication, ensuring the LLM comprehends the business logic of user authentication.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';

const isAuthenticated = userService.authenticate('testUser', 'securePassword');
assert.strictEqual(isAuthenticated, true, 'User should be authenticated with correct password');
const isAuthenticatedWrongPassword = userService.authenticate('testUser', 'wrongPassword');
assert.strictEqual(isAuthenticatedWrongPassword, false, 'User should not be authenticated with wrong password');

// Clean up resources
userService['users'].clear();

================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

// A class to handle encryption and decryption of sensitive data
class SecurityManager {
    private algorithm: string;
    private key: string;
    private iv: Buffer;

    constructor() {
        this.algorithm = 'aes-256-cbc';
        this.key = crypto.randomBytes(32).toString('hex');
        this.iv = crypto.randomBytes(16);
    }

    // Encrypts a given plaintext using the AES-256-CBC algorithm
    encrypt(text: string): string {
        const cipher = crypto.createCipheriv(this.algorithm, Buffer.from(this.key, 'hex'), this.iv);
        let encrypted = cipher.update(text);
        encrypted = Buffer.concat([encrypted, cipher.final()]);
        return `${this.iv.toString('hex')}:${encrypted.toString('hex')}`;
    }

    // Decrypts a given ciphertext using the AES-256-CBC algorithm
    decrypt(text: string): string {
        const [iv, encryptedText] = text.split(':');
        const decipher = crypto.createDecipheriv(this.algorithm, Buffer.from(this.key, 'hex'), Buffer.from(iv, 'hex'));
        let decrypted = decipher.update(Buffer.from(encryptedText, 'hex'));
        decrypted = Buffer.concat([decrypted, decipher.final()]);
        return decrypted.toString();
    }
}

// A function to simulate sensitive data processing
function processSensitiveData(data: string, securityManager: SecurityManager): string {
    // Encrypt the data
    const encryptedData = securityManager.encrypt(data);
    // Simulate some processing (e.g., storing or transmitting the data)
    // ...
    return encryptedData;
}

const securityManager = new SecurityManager();
const sensitiveData = 'Secret Information';
const encryptedData = processSensitiveData(sensitiveData, securityManager);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const decryptedData = securityManager.decrypt(encryptedData);
console.log('Decrypted Data:', decryptedData);

SUFFIX CODE:
----------------------------------------



JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's understanding of encryption and decryption processes within a security context. It requires the model to correctly use the provided SecurityManager class to decrypt data that was previously encrypted, and then compare the result with the original data to ensure the decryption process is accurate. The assertions verify that the decrypted data matches the original sensitive data, ensuring the integrity of the encryption-decryption cycle.

ASSERTIONS:
----------------------------------------
const decryptedData = securityManager.decrypt(encryptedData);
console.assert(decryptedData === sensitiveData, 'Decryption did not return the original data');

================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { EventEmitter } from 'events';

interface BuildEvent {
    timestamp: Date;
    message: string;
}

class BuildAutomation extends EventEmitter {
    private buildSteps: string[];
    private buildLogs: BuildEvent[];

    constructor() {
        super();
        this.buildSteps = [];
        this.buildLogs = [];
    }

    addStep(step: string) {
        this.buildSteps.push(step);
    }

    startBuild() {
        this.emit('buildStarted', { timestamp: new Date(), message: 'Build started.' });
        for (const step of this.buildSteps) {
            try {
                this.emit('stepStarted', { timestamp: new Date(), message: `Step started: ${step}` });
                // Simulate step execution
                console.log(`Executing step: ${step}`);
                this.emit('stepCompleted', { timestamp: new Date(), message: `Step completed: ${step}` });
            } catch (error) {
                this.emit('stepFailed', { timestamp: new Date(), message: `Step failed: ${step}` });
            }
        }
        this.emit('buildCompleted', { timestamp: new Date(), message: 'Build completed.' });
    }

    onBuildStarted(listener: (event: BuildEvent) => void) {
        this.on('buildStarted', listener);
    }

    onStepStarted(listener: (event: BuildEvent) => void) {
        this.on('stepStarted', listener);
    }

    onStepCompleted(listener: (event: BuildEvent) => void) {
        this.on('stepCompleted', listener);
    }

    onStepFailed(listener: (event: BuildEvent) => void) {
        this.on('stepFailed', listener);
    }

    onBuildCompleted(listener: (event: BuildEvent) => void) {
        this.on('buildCompleted', listener);
    }

    getBuildLogs(): BuildEvent[] {
        return this.buildLogs;
    }
}

const buildAutomation = new BuildAutomation();

buildAutomation.onBuildStarted((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.onStepStarted((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.onStepCompleted((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.onStepFailed((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.onBuildCompleted((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.addStep('Compile');
buildAutomation.addStep('Test');
buildAutomation.addStep('Package');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
buildAutomation.startBuild();
const logs = buildAutomation.getBuildLogs();

SUFFIX CODE:
----------------------------------------

console.log(`Total log entries: ${logs.length}`);
console.log(logs);

// Cleanup resources
buildAutomation.removeAllListeners();


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to understand and continue an event-driven build automation system. The context involves adding and executing build steps while emitting and handling events to log the process. The golden completion focuses on starting the build process and verifying the logs, demonstrating understanding of event handling and maintaining business logic consistency. The suffix includes cleanup code to ensure proper resource management, which is critical in real-world applications.

ASSERTIONS:
----------------------------------------
import assert from 'assert';

const buildAutomation = new BuildAutomation();

buildAutomation.onBuildStarted((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.onStepStarted((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.onStepCompleted((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.onStepFailed((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.onBuildCompleted((event) => {
    buildAutomation.getBuildLogs().push(event);
    console.log(event.message);
});

buildAutomation.addStep('Compile');
buildAutomation.addStep('Test');
buildAutomation.addStep('Package');

buildAutomation.startBuild();

const logs = buildAutomation.getBuildLogs();
assert.strictEqual(logs.length, 5, 'There should be 5 log entries in total.');
assert.strictEqual(logs[0].message, 'Build started.', 'First log entry should indicate build started.');
assert.strictEqual(logs[1].message, 'Step started: Compile', 'Second log entry should indicate first step started.');
assert.strictEqual(logs[2].message, 'Step completed: Compile', 'Third log entry should indicate first step completed.');
assert.strictEqual(logs[3].message, 'Step started: Test', 'Fourth log entry should indicate second step started.');
assert.strictEqual(logs[4].message, 'Step completed: Test', 'Fifth log entry should indicate second step completed.');

// Cleanup resources
buildAutomation.removeAllListeners();

================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

interface User {
	username: string;
	passwordHash: string;
}

class UserAuth {
	private users: User[];

	constructor() {
		this.users = [];
	}

	private hashPassword(password: string): string {
		return crypto.createHash('sha256').update(password).digest('hex');
	}

	public register(username: string, password: string): void {
		const passwordHash = this.hashPassword(password);
		this.users.push({ username, passwordHash });
	}

	public authenticate(username: string, password: string): boolean {
		const passwordHash = this.hashPassword(password);
		const user = this.users.find(user => user.username === username);
		if (user && user.passwordHash === passwordHash) {
			return true;
		}
		return false;
	}

	public changePassword(username: string, oldPassword: string, newPassword: string): boolean {
		if (this.authenticate(username, oldPassword)) {
			const user = this.users.find(user => user.username === username);
			if (user) {
				user.passwordHash = this.hashPassword(newPassword);
				return true;
			}
		}
		return false;
	}
}

const auth = new UserAuth();

auth.register('testUser', 'initialPassword');

// Successfully authenticate with the initial password
const isAuthenticatedInitially = auth.authenticate('testUser', 'initialPassword');
console.assert(isAuthenticatedInitially, 'User should be authenticated with the initial password');

// Change the password
const isPasswordChanged = auth.changePassword('testUser', 'initialPassword', 'newPassword');
console.assert(isPasswordChanged, 'Password should be changed successfully');

// Ensure old password no longer works
const isAuthenticatedWithOldPassword = auth.authenticate('testUser', 'initialPassword');
console.assert(!isAuthenticatedWithOldPassword, 'User should not be authenticated with the old password');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const authResult = auth.authenticate('testUser', 'newPassword');
console.assert(authResult, 'User should be authenticated with the new password');

SUFFIX CODE:
----------------------------------------
// Some other logic that follows after password change
const authResult = auth.authenticate('testUser', 'newPassword');
console.assert(authResult, 'User should be authenticated with the new password');

// Clean up resources if any
// In this case, there are no resources to clean up, but in a real-world scenario, this is where you would do it.


JUSTIFICATION:
----------------------------------------
This example is a good test case because it demonstrates a clear business logic scenario involving user authentication and password management, which is critical in security contexts. The provided prefix sets up a comprehensive context with user registration, authentication, and password change functionality. The golden completion is focused on verifying that the authentication works with the new password after a password change, ensuring business rule compliance. The suffix contains different logic to verify the new password functionality, ensuring clear distinction between the completion and suffix. Assertions are used to validate the correctness of the implementation, testing both positive and negative scenarios for authentication.

ASSERTIONS:
----------------------------------------
console.assert(isAuthenticatedWithNewPassword, 'User should be authenticated with the new password');
================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFileSync, writeFileSync } from 'fs';
import { promisify } from 'util';

// A utility function to read a file asynchronously
const readFileAsync = promisify(readFileSync);

// Define a type for the configuration settings
interface Config {
    key: string;
    value: string;
}

// A class representing a configuration manager for a tool automation scenario
class ConfigManager {
    private configFilePath: string;
    private config: Config[] = [];

    constructor(configFilePath: string) {
        this.configFilePath = configFilePath;
    }

    // Method to load configuration from the file
    async loadConfig(): Promise<void> {
        try {
            const data = await readFileAsync(this.configFilePath, 'utf-8');
            this.config = JSON.parse(data);
        } catch (error) {
            console.error('Failed to load config:', error);
            throw new Error('Failed to load config');
        }
    }

    // Method to get a config value by key
    getConfigValue(key: string): string | undefined {
        const configItem = this.config.find(item => item.key === key);
        return configItem ? configItem.value : undefined;
    }

    // Method to set a config value by key
    setConfigValue(key: string, value: string): void {
        const configItem = this.config.find(item => item.key === key);
        if (configItem) {
            configItem.value = value;
        } else {
            this.config.push({ key, value });
        }
    }

    // Method to save the current configuration to the file
    async saveConfig(): Promise<void> {
        try {
            const data = JSON.stringify(this.config, null, 2);
            await writeFileSync(this.configFilePath, data, 'utf-8');
        } catch (error) {
            console.error('Failed to save config:', error);
            throw new Error('Failed to save config');
        }
    }
}

// The main function to demonstrate the ConfigManager usage
async function main() {
    const configManager = new ConfigManager('config.json');

    // Load the configuration
    await configManager.loadConfig();

    // Retrieve a specific config value
    const apiKey = configManager.getConfigValue('apiKey');
    console.log('API Key:', apiKey);

    // Set a new config value
    configManager.setConfigValue('newKey', 'newValue');

    // Save the updated configuration
    await configManager.saveConfig();
}

main().catch(error => console.error(error));


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
(async () => {})();

SUFFIX CODE:
----------------------------------------


// Test that config value is properly set
const testConfigManager = new ConfigManager('test_config.json');
testConfigManager.setConfigValue('testKey', 'testValue');
const testValue = testConfigManager.getConfigValue('testKey');
console.assert(testValue === 'testValue', 'Expected testValue to be set correctly');

// Test error handling for loading config
try {
    await testConfigManager.loadConfig();
} catch (error) {
    console.assert(error.message === 'Failed to load config', 'Expected error message to be "Failed to load config"');
}

// Clean up
writeFileSync('test_config.json', '{}');


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to understand the purpose of a configuration manager in a tool automation context, where it involves reading, modifying, and saving configuration settings. The LLM needs to comprehend asynchronous file operations, error handling, and ensuring the consistency of the configuration state. The assertions check the correct setting and retrieval of configuration values and proper error handling during the load operation. This scenario combines async/await patterns with a practical tool automation context, providing a robust test for code purpose comprehension.

ASSERTIONS:
----------------------------------------
const configManager = new ConfigManager('test_config.json');
configManager.setConfigValue('testKey', 'testValue');
const value = configManager.getConfigValue('testKey');
console.assert(value === 'testValue', 'Expected testValue to be set correctly');

try {
    await configManager.loadConfig();
} catch (error) {
    console.assert(error.message === 'Failed to load config', 'Expected error message to be "Failed to load config"');
}

// Clean up
writeFileSync('test_config.json', '{}');
================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import path from 'path';

interface DeploymentConfig {
    environment: string;
    version: string;
    services: string[];
}

function readConfig(filePath: string): DeploymentConfig {
    const configContent = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(configContent) as DeploymentConfig;
}

class DeploymentManager {
    private config: DeploymentConfig;

    constructor(configFilePath: string) {
        this.config = readConfig(configFilePath);
    }

    public async deploy(): Promise<void> {
        console.log(`Deploying version ${this.config.version} to ${this.config.environment} environment.`);
        for (const service of this.config.services) {
            await this.deployService(service);
        }
    }

    private async deployService(service: string): Promise<void> {
        console.log(`Deploying service: ${service}`);
        // Simulate an asynchronous deployment task
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

// Helper function to create a temporary deployment config file
function createTempConfig(): string {
    const tempFilePath = path.join(__dirname, 'temp_config.json');
    const config: DeploymentConfig = {
        environment: 'staging',
        version: '1.0.0',
        services: ['auth', 'api', 'frontend']
    };
    fs.writeFileSync(tempFilePath, JSON.stringify(config, null, 2));
    return tempFilePath;
}

const tempConfigPath = createTempConfig();
const deploymentManager = new DeploymentManager(tempConfigPath);

(async () => {


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await deploymentManager.deploy();

SUFFIX CODE:
----------------------------------------
    console.log('Deployment process finished.');
})();

// Clean up temporary config file
fs.unlinkSync(tempConfigPath);



JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to understand the purpose of a deployment process in a tool automation context. The code involves reading a configuration file, initializing a deployment manager, and performing asynchronous deployment tasks using Promises and async-await. The golden completion requires inserting a call to the deploy method, which is critical for the deployment process to function correctly. The assertions will verify that the deployment steps are executed as expected and that the configuration file is cleaned up afterward.

ASSERTIONS:
----------------------------------------
import assert from 'assert';

(async () => {
    const consoleOutput: string[] = [];
    const originalConsoleLog = console.log;
    console.log = (message: string) => consoleOutput.push(message);

    await deploymentManager.deploy();

    console.log = originalConsoleLog;

    assert(consoleOutput.includes('Deploying version 1.0.0 to staging environment.'), 'Deployment version and environment log missing.');
    assert(consoleOutput.includes('Deploying service: auth'), 'Auth service deployment log missing.');
    assert(consoleOutput.includes('Deploying service: api'), 'API service deployment log missing.');
    assert(consoleOutput.includes('Deploying service: frontend'), 'Frontend service deployment log missing.');

    // Clean up temporary config file
    fs.unlinkSync(tempConfigPath);
})();

================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface BuildStep {
    execute(): Promise<void>;
}

class CleanStep implements BuildStep {
    private targetDir: string;
    constructor(targetDir: string) {
        this.targetDir = targetDir;
    }
    async execute(): Promise<void> {
        return new Promise((resolve, reject) => {
            fs.rmdir(this.targetDir, { recursive: true }, (err) => {
                if (err) reject(err);
                else resolve();
            });
        });
    }
}

class CompileStep implements BuildStep {
    private sourceDir: string;
    private outDir: string;
    constructor(sourceDir: string, outDir: string) {
        this.sourceDir = sourceDir;
        this.outDir = outDir;
    }
    async execute(): Promise<void> {
        // Simulate a compilation step
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log(`Compiled sources from ${this.sourceDir} to ${this.outDir}`);
                resolve();
            }, 1000);
        });
    }
}

class BuildProcess {
    private steps: BuildStep[] = [];

    addStep(step: BuildStep): void {
        this.steps.push(step);
    }

    async run(): Promise<void> {
        for (const step of this.steps) {
            try {
                await step.execute();
            } catch (error) {
                console.error('Build step failed:', error);
            }
        }
    }
}

// Example usage
const build = new BuildProcess();
build.addStep(new CleanStep(path.join(__dirname, 'dist')));
build.addStep(new CompileStep(path.join(__dirname, 'src'), path.join(__dirname, 'dist')));

// This part is missing the deployment step


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
class DeployStep implements BuildStep {
    private deployDir: string;
    constructor(deployDir: string) {
        this.deployDir = deployDir;
    }
    async execute(): Promise<void> {
        return new Promise((resolve) => {
            setTimeout(() => {
                console.log(`Deployed build to ${this.deployDir}`);
                resolve();
            }, 500);
        });
    }
}

build.addStep(new DeployStep(path.join(__dirname, 'dist')));

SUFFIX CODE:
----------------------------------------
build.run().then(() => {
    console.log('Build process completed successfully');
}).catch((error) => {
    console.error('Build process encountered an error:', error);
});


JUSTIFICATION:
----------------------------------------
This example is a good test case because it involves a realistic scenario in tool automation (builds, tests, deployment) using OOP patterns. The prefix sets up a build process with different steps (cleaning, compiling) and demonstrates how these steps are added and executed sequentially. The golden completion involves adding a deployment step, which is crucial for understanding the business logic of the build process. The suffix then runs the build process and logs the outcome. This tests the LLM's understanding of the build process and the importance of each step.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';

(async () => {
    const logs: string[] = [];
    const originalLog = console.log;
    console.log = (message: string) => { logs.push(message); };
    try {
        await build.run();
        assert.strictEqual(logs[0], 'Compiled sources from src to dist');
        assert.strictEqual(logs[1], 'Deployed to dist');
        assert.strictEqual(logs[2], 'Build process completed successfully');
    } catch (error) {
        assert.fail('Build process should not fail');
    } finally {
        console.log = originalLog;
    }
})();

================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

// Type Definitions
interface AuditLog {
	id: string;
	user: string;
	action: string;
	timestamp: Date;
}

// Utility Function to Generate Unique IDs
function generateUniqueId(): string {
	return crypto.randomBytes(16).toString('hex');
}

// Class to Handle Audit Logging
class AuditService {
	private logs: AuditLog[] = [];

	// Method to Log an Action
	logAction(user: string, action: string): void {
		const log: AuditLog = {
			id: generateUniqueId(),
			user,
			action,
			timestamp: new Date()
		};
		this.logs.push(log);
	}

	// Method to Retrieve Logs
	getLogs(): AuditLog[] {
		return this.logs;
	}
}

// AuditService Instance
const auditService = new AuditService();

// Sample Actions to Log
const actions = [
	{ user: 'alice', action: 'login' },
	{ user: 'bob', action: 'logout' },
	{ user: 'charlie', action: 'view' }
];

// Logging Actions
for (const action of actions) {
	auditService.logAction(action.user, action.action);
}

// Function to Retrieve and Display Logs
function displayLogs(service: AuditService): void {
	const logs = service.getLogs();
	for (const log of logs) {
		console.log(`User: ${log.user}, Action: ${log.action}, Timestamp: ${log.timestamp}`);
	}
}

// Displaying the Logs


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
displayLogs(auditService);

SUFFIX CODE:
----------------------------------------


// Assertions to Verify Correctness
const logs = auditService.getLogs();
console.assert(logs.length === 3, 'There should be exactly 3 logs');
console.assert(logs[0].user === 'alice', 'First log should be for user alice');
console.assert(logs[1].user === 'bob', 'Second log should be for user bob');
console.assert(logs[2].user === 'charlie', 'Third log should be for user charlie');

// Cleanup (if needed)
// No external resources to clean up in this example


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to understand TypeScript code within the context of security auditing. The example involves logging user actions and retrieving these logs, which is a common practice in security-related applications. The golden completion requires the LLM to correctly integrate the displayLogs function call and validate the audit logs through assertions. This tests the model's understanding of both the business logic (audit logging) and the technical pattern (error handling and assertions).

ASSERTIONS:
----------------------------------------
const logs = auditService.getLogs();
console.assert(logs.length === 3, 'There should be exactly 3 logs');
console.assert(logs[0].user === 'alice', 'First log should be for user alice');
console.assert(logs[1].user === 'bob', 'Second log should be for user bob');
console.assert(logs[2].user === 'charlie', 'Third log should be for user charlie');

================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { assert } from 'chai';

interface Metric {
    timestamp: Date;
    value: number;
}

class MetricsReporter {
    private metrics: Metric[] = [];

    addMetric(value: number): void {
        this.metrics.push({ timestamp: new Date(), value });
    }

    generateReport(): string {
        return this.metrics.map(metric => `Time: ${metric.timestamp}, Value: ${metric.value}`).join('\n');
    }

    async logMetricsToServer(): Promise<void> {
        try {
            const response = await fetch('https://example.com/metrics', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(this.metrics)
            });
            if (!response.ok) {
                throw new Error('Failed to log metrics');
            }
        } catch (error) {
            console.error('Error logging metrics:', error);
        }
    }
}

const reporter = new MetricsReporter();
reporter.addMetric(100);
reporter.addMetric(200);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
await reporter.logMetricsToServer();

SUFFIX CODE:
----------------------------------------
reporter.addMetric(300);
const report = reporter.generateReport();
console.log(report);

assert.include(report, 'Value: 100');
assert.include(report, 'Value: 200');
assert.include(report, 'Value: 300');

// Clean up resources if needed


JUSTIFICATION:
----------------------------------------
This test case is a good example of using async-await for handling asynchronous operations in the context of an analytics domain. The prefix sets up a MetricsReporter class that collects metrics and provides methods for reporting and logging them to a server. The golden completion involves the logMetricsToServer method, which is crucial for ensuring that the metrics are sent to the server correctly. This tests the LLM's understanding of how to properly handle asynchronous operations and the importance of logging metrics in an analytics context. The assertions verify that the metrics are correctly reported, ensuring the business logic is maintained.

ASSERTIONS:
----------------------------------------
assert.isDefined(reporter);
assert.isFunction(reporter.addMetric);
assert.isFunction(reporter.generateReport);
assert.isFunction(reporter.logMetricsToServer);
assert.include(reporter.generateReport(), 'Value: 100');
assert.include(reporter.generateReport(), 'Value: 200');
await reporter.logMetricsToServer();
assert.include(reporter.generateReport(), 'Value: 100');
assert.include(reporter.generateReport(), 'Value: 200');
assert.include(reporter.generateReport(), 'Value: 300');

================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

interface User {
  id: number;
  username: string;
  passwordHash: string;
}

interface AuditLog {
  timestamp: Date;
  userId: number;
  action: string;
  status: string;
}

const users: User[] = [
  { id: 1, username: 'alice', passwordHash: '5f4dcc3b5aa765d61d8327deb882cf99' },
  { id: 2, username: 'bob', passwordHash: 'b2e98ad6f6eb8508dd6a14cfa704bad7' }
];

const auditLogs: AuditLog[] = [];

function hashPassword(password: string): string {
  return crypto.createHash('md5').update(password).digest('hex');
}

function authenticate(username: string, password: string): boolean {
  const user = users.find(u => u.username === username);
  if (!user) return false;
  return user.passwordHash === hashPassword(password);
}

function logAudit(userId: number, action: string, status: string): void {
  auditLogs.push({ timestamp: new Date(), userId, action, status });
}

function login(username: string, password: string): boolean {
  const user = users.find(u => u.username === username);
  if (!user) {
    console.log('User not found');
    return false;
  }
  const isAuthenticated = authenticate(username, password);
  if (isAuthenticated) {
    console.log('User authenticated');
    logAudit(user.id, 'login', 'success');
    return true;
  } else {
    console.log('Authentication failed');
    logAudit(user.id, 'login', 'failure');
    return false;
  }
}

// Example usage
const username = 'alice';
const password = 'password';
const loginSuccess = login(username, password);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log('Login success:', loginSuccess);

SUFFIX CODE:
----------------------------------------


// Verify audit log
const aliceLog = auditLogs.find(log => log.userId === 1 && log.action === 'login');
console.assert(aliceLog !== undefined, 'Audit log for Alice should exist');
console.assert(aliceLog?.status === 'success', 'Alice login status should be success');

// Clean up
users.length = 0;
auditLogs.length = 0;


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves both error handling and security domain context, specifically user authentication and audit logging. The code tests the LLM's ability to understand the logic behind authenticating a user and logging the result of the authentication attempt. The assertions verify that the audit log is correctly updated based on the authentication outcome. This scenario is realistic and common in applications requiring secure user access and auditing capabilities.

ASSERTIONS:
----------------------------------------
console.assert(loginSuccess === true, 'Login should be successful for correct credentials');
console.assert(auditLogs.length === 1, 'There should be one audit log entry');
console.assert(auditLogs[0].status === 'success', 'Audit log status should be success');

================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as crypto from 'crypto';

// Helper function to generate a random string
function generateRandomString(length: number): string {
    return crypto.randomBytes(length).toString('hex');
}

// Helper function to simulate writing to a log file
function writeLog(message: string): void {
    fs.appendFileSync('audit.log', message + '\n');
}

// Class representing a user session
class UserSession {
    private sessionId: string;
    private userId: string;
    private startTime: Date;
    private endTime: Date | null;
    private actions: string[];

    constructor(userId: string) {
        this.sessionId = generateRandomString(16);
        this.userId = userId;
        this.startTime = new Date();
        this.endTime = null;
        this.actions = [];
    }

    public addAction(action: string): void {
        this.actions.push(action);
    }

    public endSession(): void {
        this.endTime = new Date();
        this.logSession();
    }

    private logSession(): void {
        const sessionDuration = this.endTime ? (this.endTime.getTime() - this.startTime.getTime()) : 0;
        const logMessage = `SessionID: ${this.sessionId}, UserID: ${this.userId}, Duration: ${sessionDuration}ms, Actions: ${this.actions.join(', ')}`;
        writeLog(logMessage);
    }
}

// Function to simulate user actions
function simulateUserActions(userId: string, actions: string[]): void {
    const session = new UserSession(userId);
    actions.forEach(action => session.addAction(action));
    // Missing code to end the session


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    session.endSession();

SUFFIX CODE:
----------------------------------------

}

// Test the simulateUserActions function
simulateUserActions('user123', ['login', 'view_dashboard', 'logout']);

// Read the log file to assert the correct entries
const logData = fs.readFileSync('audit.log', 'utf8');
console.assert(logData.includes('SessionID: '), 'Log must contain a SessionID');
console.assert(logData.includes('UserID: user123'), 'Log must contain the correct UserID');
console.assert(logData.includes('Actions: login, view_dashboard, logout'), 'Log must contain the correct actions');

// Cleanup log file
fs.unlinkSync('audit.log');

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to comprehend the business logic of an auditing system where user sessions are logged, including the actions taken by the user. The completion involves correctly ending the user session and logging it. This scenario uses OOP patterns and fits into the domain of security (auditing). The assertions verify that the log contains the expected session details, ensuring the completion maintains business logic consistency.

ASSERTIONS:
----------------------------------------
console.assert(logData.includes('SessionID: '), 'Log must contain a SessionID');
console.assert(logData.includes('UserID: user123'), 'Log must contain the correct UserID');
console.assert(logData.includes('Actions: login, view_dashboard, logout'), 'Log must contain the correct actions');
================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { randomBytes, createCipheriv, createDecipheriv } from 'crypto';

class EncryptionService {
    private algorithm: string;
    private key: Buffer;
    private ivLength: number;

    constructor(algorithm: string, key: Buffer, ivLength: number = 16) {
        this.algorithm = algorithm;
        this.key = key;
        this.ivLength = ivLength;
    }

    encrypt(text: string): string {
        const iv = randomBytes(this.ivLength);
        const cipher = createCipheriv(this.algorithm, this.key, iv);
        let encrypted = cipher.update(text, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        return iv.toString('hex') + ':' + encrypted;
    }

    decrypt(encryptedText: string): string {
        const [ivHex, encrypted] = encryptedText.split(':');
        const iv = Buffer.from(ivHex, 'hex');
        const decipher = createDecipheriv(this.algorithm, this.key, iv);
        let decrypted = decipher.update(encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }
}

const key = randomBytes(32);
const service = new EncryptionService('aes-256-cbc', key);

// Encrypt a text
const originalText = 'Hello, World!';
const encryptedText = service.encrypt(originalText);
console.log('Encrypted:', encryptedText);

// Decrypt the text back
const decryptedText = service.decrypt(encryptedText);
console.log('Decrypted:', decryptedText);

// Assertions
import * as assert from 'assert';


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
try {
    assert.strictEqual(service.decrypt('invalid:encrypted'), '');
} catch {
    console.log('Invalid decryption handled correctly.');
}

SUFFIX CODE:
----------------------------------------
assert.strictEqual(service.decrypt('invalid:encrypted'), ''); // Should throw an error or return an empty string
console.log('Invalid decryption handled correctly.');


JUSTIFICATION:
----------------------------------------
This scenario demonstrates an encryption service using Node.js crypto module, a common pattern in security-related contexts. The focus is on the ability to understand encryption and decryption processes, and the assertions test the consistency of these operations. This tests the LLM's ability to comprehend and complete a sequence where the integrity of encrypted and decrypted data must be maintained, a crucial aspect in many real-world applications involving secure data handling.

ASSERTIONS:
----------------------------------------
assert.strictEqual(decryptedText, originalText);

================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

// User data type definition
interface User {
  id: number;
  username: string;
  password: string;
  salt: string;
}

// Function to generate a salt
function generateSalt(length: number): string {
  return crypto.randomBytes(length).toString('hex');
}

// Function to hash a password with a given salt
function hashPassword(password: string, salt: string): string {
  const hash = crypto.createHmac('sha256', salt);
  hash.update(password);
  return hash.digest('hex');
}

// Class responsible for user authentication
class AuthService {
  private users: User[] = [];

  // Register a new user
  register(username: string, password: string): User {
    const salt = generateSalt(16);
    const hashedPassword = hashPassword(password, salt);
    const newUser: User = { id: this.users.length + 1, username, password: hashedPassword, salt };
    this.users.push(newUser);
    return newUser;
  }

  // Authenticate a user with username and password
  authenticate(username: string, password: string): boolean {
    const user = this.users.find(u => u.username === username);
    if (!user) return false;
    const hashedPassword = hashPassword(password, user.salt);
    return user.password === hashedPassword;
  }

  // Fetch user by ID
  getUserById(id: number): User | undefined {
    return this.users.find(u => u.id === id);
  }
}

// Utility function to log user login attempts
function logLoginAttempt(username: string, success: boolean): void {
  console.log(`Login attempt for user: ${username} was ${success ? 'successful' : 'unsuccessful'}`);
}

// Initialize AuthService
const authService = new AuthService();

// Register a test user
const testUser = authService.register('testUser', 'securePassword123');
console.log('Test user registered:', testUser);

// Attempt to authenticate with the correct password
const authSuccess = authService.authenticate('testUser', 'securePassword123');
logLoginAttempt('testUser', authSuccess);



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Attempt to authenticate with an incorrect password

SUFFIX CODE:
----------------------------------------
// Attempt to authenticate with an incorrect password
const authFailure = authService.authenticate('testUser', 'wrongPassword');
logLoginAttempt('testUser', authFailure);

// Assertions to verify business logic
import { strict as assert } from 'assert';

assert.strictEqual(authFailure, false, 'Authentication should fail with wrong password');

// Clean up resources (not needed in this example, but placeholder for real scenarios)
// e.g., close database connections


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's understanding of user authentication logic within a security context, using TypeScript. The prefix provides comprehensive setup including user registration, password hashing, and authentication functions. The golden_completion involves assertions that check the correctness of the authentication process, verifying the business rule that the correct password should authenticate successfully. This scenario is a good test case because it requires the LLM to understand the security domain, proper use of cryptographic functions, and the business logic of user authentication.

ASSERTIONS:
----------------------------------------
assert.strictEqual(authSuccess, true, 'Authentication should succeed with correct password');
assert.strictEqual(authFailure, false, 'Authentication should fail with wrong password');
================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

// Encryption Utility
class EncryptionUtility {
	private algorithm: string;
	private key: Buffer;
	private iv: Buffer;

	constructor() {
		this.algorithm = 'aes-256-cbc';
		this.key = crypto.randomBytes(32);
		this.iv = crypto.randomBytes(16);
	}

	// Encrypt a text
	encrypt(text: string): string {
		const cipher = crypto.createCipheriv(this.algorithm, this.key, this.iv);
		let encrypted = cipher.update(text, 'utf8', 'hex');
		encrypted += cipher.final('hex');
		return encrypted;
	}

	// Decrypt a text
	decrypt(encryptedText: string): string {
		const decipher = crypto.createDecipheriv(this.algorithm, this.key, this.iv);
		let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
		decrypted += decipher.final('utf8');
		return decrypted;
	}
}

// Mock data for testing
const sampleText = "Sensitive data to encrypt";
const encryptionUtility = new EncryptionUtility();

// Encrypting the sample text
const encryptedText = encryptionUtility.encrypt(sampleText);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const decryptedText = encryptionUtility.decrypt(encryptedText);
assert.notStrictEqual(encryptedText, "");

SUFFIX CODE:
----------------------------------------
const decryptedText = "";

// Assertions
import { strict as assert } from 'assert';
assert.strictEqual(encryptedText, "");
assert.strictEqual(decryptedText, sampleText);

// Cleanup
// No resources to cleanup in this scenario


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to understand encryption and decryption logic in the context of security. The pattern includes encrypting a sample text and then decrypting it back to verify the correctness. The completion requires the model to correctly implement the decryption step and verify that the decrypted text matches the original. The assertions ensure the encrypted text is non-empty and the decrypted text matches the original, demonstrating understanding of the security domain and the correct use of crypto library functions.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';
assert.strictEqual(encryptedText.length > 0, true);
assert.strictEqual(decryptedText, sampleText);

================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

interface Metrics {
    pageViews: number;
    clicks: number;
    purchases: number;
}

class AnalyticsTracker {
    private metrics: Metrics;
    constructor() {
        this.metrics = { pageViews: 0, clicks: 0, purchases: 0 };
    }

    public incrementPageViews() {
        this.metrics.pageViews += 1;
    }

    public incrementClicks() {
        this.metrics.clicks += 1;
    }

    public incrementPurchases() {
        this.metrics.purchases += 1;
    }

    public getMetrics(): Metrics {
        return this.metrics;
    }
}

// Helper function to simulate user actions
function simulateUserActions(tracker: AnalyticsTracker) {
    tracker.incrementPageViews();
    tracker.incrementClicks();
    tracker.incrementPurchases();
}

// Initialize tracker
const tracker = new AnalyticsTracker();

// Simulate some user actions
simulateUserActions(tracker);

// Assertions to verify the correctness of the metrics
assert.strictEqual(tracker.getMetrics().pageViews, 1);
assert.strictEqual(tracker.getMetrics().clicks, 1);
assert.strictEqual(tracker.getMetrics().purchases, 1);

// Simulate more user actions
simulateUserActions(tracker);

// More assertions
assert.strictEqual(tracker.getMetrics().pageViews, 2);
assert.strictEqual(tracker.getMetrics().clicks, 2);
assert.strictEqual(tracker.getMetrics().purchases, 2);

// Simulate a custom number of actions
function simulateCustomUserActions(tracker: AnalyticsTracker, actions: { pageViews: number, clicks: number, purchases: number }) {


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    for (let i = 0; i < actions.pageViews; i++) {
        tracker.incrementPageViews();
    }
    for (let i = 0; i < actions.clicks; i++) {
        tracker.incrementClicks();
    }
    for (let i = 0; i < actions.purchases; i++) {
        tracker.incrementPurchases();
    }

SUFFIX CODE:
----------------------------------------
}

// Simulate custom actions
simulateCustomUserActions(tracker, { pageViews: 3, clicks: 2, purchases: 1 });

// Assertions for custom actions
assert.strictEqual(tracker.getMetrics().pageViews, 5);
assert.strictEqual(tracker.getMetrics().clicks, 4);
assert.strictEqual(tracker.getMetrics().purchases, 3);

console.log('All assertions passed.');


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to understand and continue a code pattern that involves tracking and updating metrics. The scenario is relevant to the domain of analytics, which requires understanding of increment operations and maintaining state consistency. The golden completion demonstrates how to properly iterate over specified actions to update metrics, ensuring business logic is followed. Assertions are placed to verify that the metrics are correctly updated after each simulation, testing the functional correctness and business rule compliance of the provided code.

ASSERTIONS:
----------------------------------------
assert.strictEqual(tracker.getMetrics().pageViews, 5);
assert.strictEqual(tracker.getMetrics().clicks, 4);
assert.strictEqual(tracker.getMetrics().purchases, 3);

console.log('All assertions passed.');
================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

// Define a type for our metrics
interface Metric {
    timestamp: number;
    value: number;
}

// Utility function to read metrics from a JSON file
function readMetrics(filePath: string): Metric[] {
    const data = readFileSync(filePath, 'utf-8');
    return JSON.parse(data);
}

// Utility function to write metrics to a JSON file
function writeMetrics(filePath: string, metrics: Metric[]): void {
    const data = JSON.stringify(metrics, null, 2);
    writeFileSync(filePath, data);
}

// Function to calculate the average value of metrics
function calculateAverage(metrics: Metric[]): number {
    const total = metrics.reduce((sum, metric) => sum + metric.value, 0);
    return total / metrics.length;
}

// Function to calculate the maximum value of metrics
function calculateMax(metrics: Metric[]): number {
    return Math.max(...metrics.map(metric => metric.value));
}

// Function to calculate the minimum value of metrics
function calculateMin(metrics: Metric[]): number {
    return Math.min(...metrics.map(metric => metric.value));
}

// Example file paths
const inputFilePath = join(__dirname, 'metrics.json');
const outputFilePath = join(__dirname, 'output_metrics.json');

// Read the metrics from the input file
const metrics = readMetrics(inputFilePath);

// Calculate the average, max, and min values
const average = calculateAverage(metrics);
const max = calculateMax(metrics);
const min = calculateMin(metrics);

// Create a summary object
const summary = {
    average,
    max,
    min,
    count: metrics.length,
    timestamp: Date.now()
};

// Write the summary to the output file
writeMetrics(outputFilePath, metrics);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
writeMetrics(outputFilePath, [summary]);

SUFFIX CODE:
----------------------------------------

// Print the summary to the console
console.log('Metrics summary:', summary);

// Clean up: Remove the output file (if needed)
import { unlinkSync } from 'fs';
unlinkSync(outputFilePath);

JUSTIFICATION:
----------------------------------------
This test case is an excellent example because it involves the use of data structures and analytics within a real-world scenario of processing and summarizing metrics from a file. It tests the LLM's ability to understand the context of calculating and summarizing metrics, as well as updating the dataset with new information. The assertions will verify that the new summary is correctly added to the metrics and the file is properly updated.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

// Read the updated metrics from the output file
const updatedMetrics = readMetrics(outputFilePath);

// Check that the updated metrics contain the new summary
const lastMetric = updatedMetrics[updatedMetrics.length - 1];
assert.equal(lastMetric.value, summary.average, 'The last metric value should be the average');
assert.equal(lastMetric.timestamp, summary.timestamp, 'The last metric timestamp should match the summary timestamp');

// Ensure the count of metrics is correct
assert.equal(updatedMetrics.length, metrics.length, 'The length of updated metrics should be incremented by one');
================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { EventEmitter } from 'events';

// Define a simple interface for an event payload
type EventPayload = {
  eventType: string;
  eventData: any;
};

// Custom EventEmitter class for handling game events
class GameEventEmitter extends EventEmitter {
  // Emit an event with the specified payload
  emitEvent(payload: EventPayload): void {
    this.emit(payload.eventType, payload.eventData);
  }

  // Add a listener for a specific event type
  addEventListener(eventType: string, listener: (data: any) => void): void {
    this.on(eventType, listener);
  }

  // Remove a listener for a specific event type
  removeEventListener(eventType: string, listener: (data: any) => void): void {
    this.off(eventType, listener);
  }
}

// Create an instance of the GameEventEmitter
const gameEvents = new GameEventEmitter();

// Define a function to log event data
type EventLog = { timestamp: Date; eventType: string; eventData: any };
const eventLog: EventLog[] = [];
function logEvent(eventType: string, eventData: any) {
  eventLog.push({ timestamp: new Date(), eventType, eventData });
}

// Define some game-specific event handlers
function onPlayerScored(data: any) {
  console.log('Player scored:', data);
  logEvent('playerScored', data);
}
function onEnemyDefeated(data: any) {
  console.log('Enemy defeated:', data);
  logEvent('enemyDefeated', data);
}

// Add event listeners to gameEvents


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
gameEvents.addEventListener('playerScored', onPlayerScored);

SUFFIX CODE:
----------------------------------------
gameEvents.addEventListener('enemyDefeated', onEnemyDefeated);

// Emit some test events
gameEvents.emitEvent({ eventType: 'playerScored', eventData: { playerId: 1, score: 10 } });
gameEvents.emitEvent({ eventType: 'enemyDefeated', eventData: { enemyId: 42 } });

// Assertions
import { strict as assert } from 'assert';
assert.equal(eventLog.length, 2, 'Event log should contain 2 entries');
assert.equal(eventLog[0].eventType, 'playerScored', 'First event should be playerScored');
assert.equal(eventLog[0].eventData.playerId, 1, 'First event data should match');
assert.equal(eventLog[0].eventData.score, 10, 'First event score should match');
assert.equal(eventLog[1].eventType, 'enemyDefeated', 'Second event should be enemyDefeated');
assert.equal(eventLog[1].eventData.enemyId, 42, 'Second event data should match');

// Clean up event listeners
gameEvents.removeEventListener('playerScored', onPlayerScored);
gameEvents.removeEventListener('enemyDefeated', onEnemyDefeated);

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to understand and correctly continue code based on its semantic meaning and business context. The scenario involves event handling in a game mechanics context, where events such as 'playerScored' and 'enemyDefeated' are logged and handled using an EventEmitter pattern. The golden completion requires adding an event listener for the 'playerScored' event, which is crucial for the subsequent assertions to pass. This completion demonstrates understanding of the event handling mechanism and its importance in the game's business logic.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';
assert.equal(eventLog.length, 2, 'Event log should contain 2 entries');
assert.equal(eventLog[0].eventType, 'playerScored', 'First event should be playerScored');
assert.equal(eventLog[0].eventData.playerId, 1, 'First event data should match');
assert.equal(eventLog[0].eventData.score, 10, 'First event score should match');
assert.equal(eventLog[1].eventType, 'enemyDefeated', 'Second event should be enemyDefeated');
assert.equal(eventLog[1].eventData.enemyId, 42, 'Second event data should match');
================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import path from 'path';

interface TestResult {
    testName: string;
    passed: boolean;
    duration: number;
}

class TestRunner {
    private results: TestResult[] = [];

    public async runTests(testFiles: string[]): Promise<void> {
        for (const file of testFiles) {
            try {
                const testModule = await import(path.resolve(file));
                const testNames = Object.keys(testModule).filter(key => key.startsWith('test'));
                for (const testName of testNames) {
                    const start = Date.now();
                    await testModule[testName]();
                    const duration = Date.now() - start;
                    this.results.push({ testName, passed: true, duration });
                }
            } catch (error) {
                this.results.push({ testName: file, passed: false, duration: 0 });
            }
        }
    }

    public getResults(): TestResult[] {
        return this.results;
    }
}

// Utility function to write results to a file
function writeResultsToFile(results: TestResult[], filePath: string): void {
    const fileContent = JSON.stringify(results, null, 2);
    fs.writeFileSync(filePath, fileContent);
}

// Helper function to read test files from a directory
function getTestFilesFromDirectory(directory: string): string[] {
    const files = fs.readdirSync(directory);
    return files.filter(file => file.endsWith('.test.js')).map(file => path.join(directory, file));
}

// Main function to orchestrate test running and reporting
async function main() {
    const testDirectory = './tests';
    const testFiles = getTestFilesFromDirectory(testDirectory);
    const testRunner = new TestRunner();
    await testRunner.runTests(testFiles);
    const results = testRunner.getResults();
    writeResultsToFile(results, './test-results.json');
}

// Run the main function and handle errors


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
main().catch(error => {
    console.error('Error running tests:', error);
    process.exit(1);
});

SUFFIX CODE:
----------------------------------------

// Cleanup: remove the test results file after verification
fs.unlinkSync('./test-results.json');


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to understand and correctly implement the async-await pattern within the context of a tool automation scenario. The code involves running automated tests, capturing results, and handling errors appropriately. The prefix sets up the context with a test runner class, utility functions, and a main orchestrating function. The LLM must comprehend the business logic and ensure proper error handling and async-await usage in the golden completion. Assertions verify that the tests are run, results are captured, and errors are logged if they occur.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';
import fs from 'fs';
import path from 'path';

// Check if the test results file exists
assert(fs.existsSync('./test-results.json'));

// Read the results file
const resultsContent = fs.readFileSync('./test-results.json', 'utf8');
const results = JSON.parse(resultsContent) as TestResult[];

// Verify the results structure
assert(Array.isArray(results), 'Results should be an array');
results.forEach(result => {
    assert(typeof result.testName === 'string', 'Test name should be a string');
    assert(typeof result.passed === 'boolean', 'Passed flag should be a boolean');
    assert(typeof result.duration === 'number', 'Duration should be a number');
});

// Ensure at least one test result is present
assert(results.length > 0, 'There should be at least one test result');
================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import path from 'path';

// Utility function to read a JSON file
const readJsonFile = (filePath: string): any => {
  const rawData = fs.readFileSync(filePath);
  return JSON.parse(rawData.toString());
};

// Utility function to write to a JSON file
const writeJsonFile = (filePath: string, data: any): void => {
  const jsonData = JSON.stringify(data, null, 2);
  fs.writeFileSync(filePath, jsonData);
};

// Report generation utility
class ReportGenerator {
  private data: any;

  constructor(dataFilePath: string) {
    this.data = readJsonFile(dataFilePath);
  }

  public generateSummaryReport(outputFilePath: string): void {
    const summary = this.createSummary();
    writeJsonFile(outputFilePath, summary);
  }

  private createSummary(): any {
    const summary = {
      totalUsers: this.data.users.length,
      totalSales: this.data.sales.reduce((acc: number, sale: any) => acc + sale.amount, 0),
      averageSaleValue: this.calculateAverageSaleValue()
    };
    return summary;
  }

  private calculateAverageSaleValue(): number {
    return this.data.sales.reduce((acc: number, sale: any) => acc + sale.amount, 0) / this.data.sales.length;
  }
}

// Error handling example
function generateReport(dataFilePath: string, outputFilePath: string): void {
  try {
    const reportGenerator = new ReportGenerator(dataFilePath);
    reportGenerator.generateSummaryReport(outputFilePath);
  } catch (error) {
    console.error('Failed to generate report:', error);
  }
}

// Mock data for testing
const mockData = {
  users: [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' }
  ],
  sales: [
    { id: 1, userId: 1, amount: 100 },
    { id: 2, userId: 2, amount: 150 }
  ]
};

const mockDataFilePath = path.join(__dirname, 'mockData.json');
const mockOutputFilePath = path.join(__dirname, 'reportSummary.json');

// Write mock data to file for testing
writeJsonFile(mockDataFilePath, mockData);

// Test function to generate report
function testGenerateReport() {
  generateReport(mockDataFilePath, mockOutputFilePath);
  const result = readJsonFile(mockOutputFilePath);
  return result;
}


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log(testGenerateReport());

SUFFIX CODE:
----------------------------------------

// Clean up mock files
fs.unlinkSync(mockDataFilePath);
fs.unlinkSync(mockOutputFilePath);


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate an LLM's understanding of error handling and analytics within a TypeScript application. The scenario involves reading and writing JSON files, generating a summary report, and handling potential errors. The assertions verify that the generated report is accurate based on the provided mock data, ensuring that the business logic is correctly implemented. This example is a good test case because it demonstrates real-world tasks such as file I/O, data processing, and error management, all of which are common in many business applications.

ASSERTIONS:
----------------------------------------
const result = testGenerateReport();
console.assert(result.totalUsers === 2, 'Total users should be 2');
console.assert(result.totalSales === 250, 'Total sales should be 250');
console.assert(result.averageSaleValue === 125, 'Average sale value should be 125');
================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fs from 'fs';
import { promisify } from 'util';

const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);

interface Metric {
  name: string;
  value: number;
  timestamp: Date;
}

class MetricsCollector {
  private metrics: Metric[] = [];

  collect(metric: Metric) {
    this.metrics.push(metric);
  }

  async saveToFile(filename: string): Promise<void> {
    try {
      const data = JSON.stringify(this.metrics, null, 2);
      await writeFileAsync(filename, data);
    } catch (error) {
      console.error('Error saving metrics to file:', error);
    }
  }

  async loadFromFile(filename: string): Promise<void> {
    try {
      const data = await readFileAsync(filename, 'utf-8');
      this.metrics = JSON.parse(data);
    } catch (error) {
      console.error('Error loading metrics from file:', error);
    }
  }

  getMetrics(): Metric[] {
    return this.metrics;
  }
}

const collector = new MetricsCollector();
collector.collect({ name: 'CPU Usage', value: 75, timestamp: new Date() });
collector.collect({ name: 'Memory Usage', value: 60, timestamp: new Date() });
const FILENAME = 'metrics.json';

async function main() {
  await collector.saveToFile(FILENAME);
  // Clear current metrics
  collector['metrics'] = [];
  await collector.loadFromFile(FILENAME);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
  const loadedMetrics = collector.getMetrics();

SUFFIX CODE:
----------------------------------------

  console.log('Loaded Metrics:', loadedMetrics);
  await writeFileAsync(FILENAME, ''); // Clean up the file
}

main().catch(console.error);

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to understand and continue a TypeScript code scenario involving Promises/async-await in the context of analytics (metrics collection and reporting). The prefix establishes a comprehensive setup for collecting and saving metrics to a file, while the golden completion requires the LLM to correctly implement assertions verifying the loaded metrics. This demonstrates the LLM's understanding of async operations, file handling, and business logic validation.

ASSERTIONS:
----------------------------------------
const loadedMetrics = collector.getMetrics();
console.assert(loadedMetrics.length === 2, 'Metrics count should be 2');
console.assert(loadedMetrics[0].name === 'CPU Usage', 'First metric should be CPU Usage');
console.assert(loadedMetrics[1].name === 'Memory Usage', 'Second metric should be Memory Usage');
================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFile } from 'fs/promises';
import { join } from 'path';

interface Report {
  date: string;
  metric: string;
  value: number;
}

async function loadReport(filePath: string): Promise<Report[]> {
  const data = await readFile(filePath, 'utf8');
  const lines = data.split('\n');
  return lines.map(line => {
    const [date, metric, value] = line.split(',');
    return { date, metric, value: parseFloat(value) };
  });
}

function filterReportsByMetric(reports: Report[], metric: string): Report[] {
  return reports.filter(report => report.metric === metric);
}

function calculateAverageValue(reports: Report[]): number {
  const total = reports.reduce((sum, report) => sum + report.value, 0);
  return total / reports.length;
}

async function generateMetricReport(filePath: string, metric: string): Promise<string> {
  try {
    const reports = await loadReport(filePath);
    const filteredReports = filterReportsByMetric(reports, metric);
    if (filteredReports.length === 0) {
      throw new Error(`No reports found for metric: ${metric}`);
    }
    const averageValue = calculateAverageValue(filteredReports);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    return `Average value for metric "${metric}" is ${averageValue.toFixed(2)}`;

SUFFIX CODE:
----------------------------------------

  } catch (error) {
    return `Error generating report: ${error.message}`;
  }
}

(async () => {
  const filePath = join(__dirname, 'sample_report.csv');
  const metric = 'temperature';
  const report = await generateMetricReport(filePath, metric);
  console.log(report);
})();


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to understand and continue a function that processes and generates a metric report. The prefix provides a comprehensive setup, including loading data from a file, filtering reports by a metric, and calculating the average value. The completion must correctly format the report string, maintaining consistency with the context and domain-specific logic of analytics reporting. The suffix provides an alternative return statement, ensuring clear distinction.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async () => {
  const filePath = join(__dirname, 'sample_report.csv');
  const metric = 'temperature';
  const report = await generateMetricReport(filePath, metric);
  assert(report.startsWith('The average value for the metric temperature is:'));
  console.log('All assertions passed.');
})();

================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: synthbench-code-purpose-understanding
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fetch from 'node-fetch';
import { assert } from 'chai';

// Type definitions for the analytics data structure
interface Metric {
	name: string;
	value: number;
	timestamp: Date;
}

// Utility function to simulate fetching metrics
async function fetchMetrics(): Promise<Metric[]> {
	return [
		{name: 'metric1', value: 10, timestamp: new Date()},
		{name: 'metric2', value: 20, timestamp: new Date()},
		{name: 'metric3', value: 30, timestamp: new Date()}
	];
}

// Class to handle metrics processing
class MetricsProcessor {
	private metrics: Metric[] = [];

	async loadMetrics() {
		this.metrics = await fetchMetrics();
	}

	processMetrics() {
		// Placeholder for metrics processing logic
	}

	generateReport() {
		// Placeholder for report generation logic
	}
}

// Helper function to format metrics for reporting
function formatMetric(metric: Metric): string {
	return `${metric.name}: ${metric.value} at ${metric.timestamp.toISOString()}`;
}

// Example usage
async function runAnalytics() {
	const processor = new MetricsProcessor();
	await processor.loadMetrics();
	processor.processMetrics();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
	console.log(processor.metrics.map(formatMetric).join('\n'));

SUFFIX CODE:
----------------------------------------
	console.log('Metrics processed.');
	processor.generateReport();
}

runAnalytics();

JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of Promises and async-await in the context of an analytics system. The code involves fetching metrics asynchronously, processing them, and formatting them for reporting. This scenario tests the LLM's understanding of asynchronous operations, data transformation, and the business logic of generating reports. It ensures that the LLM can correctly continue the code by adding the logic to format and log the metrics after processing, maintaining consistency with the prefix and suffix.

ASSERTIONS:
----------------------------------------
const processor = new MetricsProcessor();
(async () => {
	await processor.loadMetrics();
	processor.processMetrics();
	const formattedMetrics = processor.metrics.map(formatMetric);
	assert.isArray(formattedMetrics);
	assert.lengthOf(formattedMetrics, 3);
	assert.match(formattedMetrics[0], /metric1: 10/);
	assert.match(formattedMetrics[1], /metric2: 20/);
	assert.match(formattedMetrics[2], /metric3: 30/);
	console.log('All assertions passed.');
})();
================================================================================
