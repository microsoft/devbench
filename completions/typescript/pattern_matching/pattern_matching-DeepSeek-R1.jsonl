{"id": "1", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\ninterface DataPoint {\n    x: number;\n    y: number;\n}\n\nclass Statistics {\n    private data: DataPoint[] = [];\n\n    public addDataPoint(x: number, y: number): void {\n        this.data.push({ x, y });\n    }\n\n    public calculateMean(): { meanX: number, meanY: number } {\n        const total = this.data.reduce((acc, point) => {\n            acc.x += point.x;\n            acc.y += point.y;\n            return acc;\n        }, { x: 0, y: 0 });\n        return {\n            meanX: total.x / this.data.length,\n            meanY: total.y / this.data.length\n        };\n    }\n\n    public calculateVariance(): { varianceX: number, varianceY: number } {\n        const mean = this.calculateMean();\n        const varianceTotal = this.data.reduce((acc, point) => {\n            acc.x += Math.pow(point.x - mean.meanX, 2);\n            acc.y += Math.pow(point.y - mean.meanY, 2);\n            return acc;\n        }, { x: 0, y: 0 });\n        return {\n            varianceX: varianceTotal.x / this.data.length,\n            varianceY: varianceTotal.y / this.data.length\n        };\n    }\n\n    public calculateStandardDeviation(): { stdDevX: number, stdDevY: number } {\n        const variance = this.calculateVariance();\n        return {\n            stdDevX: Math.sqrt(variance.varianceX),\n            stdDevY: Math.sqrt(variance.varianceY)\n        };\n    }\n}\n\nconst stats = new Statistics();\nstats.addDataPoint(1, 2);\nstats.addDataPoint(3, 4);\nstats.addDataPoint(5, 6);\n\n// Calculate and assert the mean values\nconst mean = stats.calculateMean();\nassert.strictEqual(mean.meanX, 3);\nassert.strictEqual(mean.meanY, 4);\n\n// Calculate and assert the variance values\nconst variance = stats.calculateVariance();\nassert.strictEqual(variance.varianceX, 4);\nassert.strictEqual(variance.varianceY, 4);\n\n", "suffix": "\n// Clean up resources or perform any final operations if necessary\n", "golden_completion": "// Calculate and assert the standard deviation values\nconst stdDev = stats.calculateStandardDeviation();\nassert.strictEqual(stdDev.stdDevX, 2);\nassert.strictEqual(stdDev.stdDevY, 2);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a pattern involving statistical calculations within a class. The pattern of calculating mean, variance, and standard deviation is clear and requires proper understanding of mathematical operations on data points. The assertions ensure that the calculations are performed correctly. The scenario is realistic for scientific computing, making it a practical test case for pattern recognition.", "assertions": "const stdDev = stats.calculateStandardDeviation();\nassert.strictEqual(stdDev.stdDevX, 2);\nassert.strictEqual(stdDev.stdDevY, 2);\n", "DeepSeek-R1": "const stdDev = stats.calculateStandardDeviation();\nassert.strictEqual(stdDev.stdDevX, 2);\nassert.strictEqual(stdDev.stdDevY, 2);"}
{"id": "2", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "interface DataPoint {\n    x: number;\n    y: number;\n}\n\nclass LinearRegression {\n    private data: DataPoint[] = [];\n\n    addDataPoint(point: DataPoint): void {\n        this.data.push(point);\n    }\n\n    private calculateMean(values: number[]): number {\n        const sum = values.reduce((acc, val) => acc + val, 0);\n        return sum / values.length;\n    }\n\n    private calculateVariance(values: number[], mean: number): number {\n        return values.reduce((acc, val) => acc + (val - mean) ** 2, 0) / values.length;\n    }\n\n    private calculateCovariance(xValues: number[], yValues: number[], xMean: number, yMean: number): number {\n        let covariance = 0;\n        for (let i = 0; i < xValues.length; i++) {\n            covariance += (xValues[i] - xMean) * (yValues[i] - yMean);\n        }\n        return covariance / xValues.length;\n    }\n\n    private extractXValues(): number[] {\n        return this.data.map(point => point.x);\n    }\n\n    private extractYValues(): number[] {\n        return this.data.map(point => point.y);\n    }\n\n    public calculateCoefficients(): { slope: number; intercept: number } {\n        const xValues = this.extractXValues();\n        const yValues = this.extractYValues();\n        const xMean = this.calculateMean(xValues);\n        const yMean = this.calculateMean(yValues);\n        const varianceX = this.calculateVariance(xValues, xMean);\n        const covarianceXY = this.calculateCovariance(xValues, yValues, xMean, yMean);\n        const slope = covarianceXY / varianceX;\n        const intercept = yMean - slope * xMean;\n        return { slope, intercept };\n    }\n}\n\nconst model = new LinearRegression();\nmodel.addDataPoint({ x: 1, y: 2 });\nmodel.addDataPoint({ x: 2, y: 3 });\nmodel.addDataPoint({ x: 3, y: 4 });\nconst coefficients = model.calculateCoefficients();\n", "suffix": "console.log(`Intercept: ${coefficients.intercept}`);\n\n// Validate the correctness of the model\nconst expectedSlope = 1;\nconst expectedIntercept = 1;\nconsole.assert(coefficients.slope === expectedSlope, `Expected slope to be ${expectedSlope}, but got ${coefficients.slope}`);\nconsole.assert(coefficients.intercept === expectedIntercept, `Expected intercept to be ${expectedIntercept}, but got ${coefficients.intercept}`);\n// Cleanup code if any (none needed in this case)\n", "golden_completion": "console.log(`Slope: ${coefficients.slope}`);\n", "LLM_justification": "This test case establishes a clear pattern of data extraction, mathematical computation, and result logging. The `golden_completion` logically fits by continuing the pattern of logging calculated results. The assertions ensure the slope and intercept calculations are correct, adhering to the established pattern. This scenario tests the LLM's ability to recognize and continue the pattern within a scientific computing context using TypeScript.", "assertions": "console.assert(coefficients.slope === 1, `Expected slope to be 1, but got ${coefficients.slope}`);\nconsole.assert(coefficients.intercept === 1, `Expected intercept to be 1, but got ${coefficients.intercept}`);", "DeepSeek-R1": "console.log(`Slope: ${coefficients.slope}`);"}
{"id": "3", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n// Helper function to calculate the mean of an array of numbers\nfunction calculateMean(numbers: number[]): number {\n    if (numbers.length === 0) throw new Error('Array cannot be empty');\n    const sum = numbers.reduce((acc, val) => acc + val, 0);\n    return sum / numbers.length;\n}\n\n// Helper function to calculate the median of an array of numbers\nfunction calculateMedian(numbers: number[]): number {\n    if (numbers.length === 0) throw new Error('Array cannot be empty');\n    const sorted = numbers.slice().sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    if (sorted.length % 2 === 0) {\n        return (sorted[mid - 1] + sorted[mid]) / 2;\n    } else {\n        return sorted[mid];\n    }\n}\n\n// Helper function to calculate the mode of an array of numbers\nfunction calculateMode(numbers: number[]): number[] {\n    if (numbers.length === 0) throw new Error('Array cannot be empty');\n    const frequency: { [key: number]: number } = {};\n    numbers.forEach(num => {\n        frequency[num] = (frequency[num] || 0) + 1;\n    });\n    const maxFreq = Math.max(...Object.values(frequency));\n    return Object.keys(frequency).filter(key => frequency[Number(key)] === maxFreq).map(Number);\n}\n\n// Helper function to calculate the variance of an array of numbers\nfunction calculateVariance(numbers: number[]): number {\n    if (numbers.length === 0) throw new Error('Array cannot be empty');\n    const mean = calculateMean(numbers);\n    const squaredDiffs = numbers.map(num => Math.pow(num - mean, 2));\n    return calculateMean(squaredDiffs);\n}\n\n// Helper function to calculate the standard deviation of an array of numbers\nfunction calculateStandardDeviation(numbers: number[]): number {\n    if (numbers.length === 0) throw new Error('Array cannot be empty');\n    const variance = calculateVariance(numbers);\n    return Math.sqrt(variance);\n}\n\n// Sample data for testing\nconst sampleData = [2, 4, 4, 4, 5, 5, 7, 9];\n\n// Calculate mean, median, mode, variance, and standard deviation\nconst mean = calculateMean(sampleData);\nconst median = calculateMedian(sampleData);\nconst mode = calculateMode(sampleData);\nconst variance = calculateVariance(sampleData);", "suffix": "\n\n// Assertions to verify the calculations\nassert.strictEqual(mean, 5);\nassert.strictEqual(median, 4.5);\nassert.deepStrictEqual(mode, [4]);\nassert.strictEqual(variance, 4);\nassert.strictEqual(stdDev, 2);\n\nconsole.log('All tests passed');", "golden_completion": "const stdDev = calculateStandardDeviation(sampleData);", "LLM_justification": "This test case is a good example because it establishes a clear pattern of calculating various statistical measures (mean, median, mode, variance) using helper functions. The golden completion requires the LLM to recognize and continue this pattern by calculating the standard deviation. The context of scientific computing and data analysis makes this pattern realistic and practical for developers. The assertions verify the correctness of the calculations and ensure that the pattern is adhered to.", "assertions": "assert.strictEqual(mean, 5);\nassert.strictEqual(median, 4.5);\nassert.deepStrictEqual(mode, [4]);\nassert.strictEqual(variance, 4);\nassert.strictEqual(stdDev, 2);\n\nconsole.log('All tests passed');", "DeepSeek-R1": "const stdDev = calculateStandardDeviation(sampleData);"}
{"id": "4", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\ntype DataEntry = {\n  timestamp: string;\n  value: number;\n};\n\ntype DataSet = DataEntry[];\n\nclass DataProcessor {\n  data: DataSet;\n\n  constructor(data: DataSet) {\n    this.data = data;\n  }\n\n  filterByDate(startDate: string, endDate: string): DataSet {\n    return this.data.filter(entry => entry.timestamp >= startDate && entry.timestamp <= endDate);\n  }\n\n  calculateAverage(data: DataSet): number {\n    const total = data.reduce((acc, entry) => acc + entry.value, 0);\n    return total / data.length;\n  }\n\n  findMaxValue(data: DataSet): number {\n    return data.reduce((max, entry) => entry.value > max ? entry.value : max, data[0].value);\n  }\n\n  // Add the new method pattern here\n", "suffix": "\n}\n\n// Test data\nconst testData: DataSet = [\n  { timestamp: '2023-01-01', value: 10 },\n  { timestamp: '2023-01-02', value: 20 },\n  { timestamp: '2023-01-03', value: 30 },\n  { timestamp: '2023-01-04', value: 40 },\n  { timestamp: '2023-01-05', value: 50 }\n];\n\nconst processor = new DataProcessor(testData);\nconst filteredData = processor.filterByDate('2023-01-02', '2023-01-04');\nconst average = processor.calculateAverage(filteredData);\nconst maxValue = processor.findMaxValue(filteredData);\nconst minValue = processor.findMinValue(filteredData);\n\nassert.strictEqual(filteredData.length, 3);\nassert.strictEqual(average, 30);\nassert.strictEqual(maxValue, 40);\nassert.strictEqual(minValue, 20);\n\nconsole.log('All tests passed.');", "golden_completion": "findMinValue(data: DataSet): number {\n    return data.reduce((min, entry) => entry.value < min ? entry.value : min, data[0].value);\n  }", "LLM_justification": "This test case is a good example of pattern matching in TypeScript because it requires the LLM to recognize and continue the pattern of methods within the DataProcessor class that perform calculations on a DataSet. The established methods (filterByDate, calculateAverage, findMaxValue) follow a clear pattern of taking a DataSet as input and returning a calculated value. The golden completion continues this pattern by implementing a method to find the minimum value in a DataSet, which is consistent with the other methods in the class. The assertions verify that the methods work correctly and adhere to the pattern.", "assertions": "assert.strictEqual(filteredData.length, 3);\nassert.strictEqual(average, 30);\nassert.strictEqual(maxValue, 40);\nassert.strictEqual(minValue, 20);", "DeepSeek-R1": "  findMinValue(data: DataSet): number {\n    return data.reduce((min, entry) => entry.value < min ? entry.value : min, data[0].value);\n  }"}
{"id": "5", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import { readFileSync } from 'fs';\n\n// Data validation helper functions\nfunction isValidString(value: any): boolean {\n    return typeof value === 'string' && value.trim().length > 0;\n}\n\nfunction isValidNumber(value: any): boolean {\n    return typeof value === 'number' && !isNaN(value);\n}\n\nfunction isValidDate(value: any): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n// Validation schema interface\ninterface User {\n    name: string;\n    age: number;\n    birthdate: Date;\n}\n\n// Validate user data according to the schema\nfunction validateUser(data: any): User | null {\n    if (isValidString(data.name) && isValidNumber(data.age) && isValidDate(new Date(data.birthdate))) {\n        return {\n            name: data.name,\n            age: data.age,\n            birthdate: new Date(data.birthdate)\n        };\n    }\n    return null;\n}\n\n// Sample data for validation\nconst rawData = '{\"name\": \"John Doe\", \"age\": 30, \"birthdate\": \"1992-06-15\"}';\nconst parsedData = JSON.parse(rawData);\n\n// Validating the parsed data\nconst validatedUser = validateUser(parsedData);\n\n// Assertions to verify validation\nif (validatedUser) {\n    console.log('User data is valid:', validatedUser);\n} else {\n    console.error('User data is invalid');\n}\n\n// Additional validation function for an array of users\nfunction validateUsers(data: any[]): (User | null)[] {\n    return data.map(validateUser);\n}\n\n// Sample array of user data\nconst rawUsers = '[{\"name\": \"John Doe\", \"age\": 30, \"birthdate\": \"1992-06-15\"}, {\"name\": \"Jane Smith\", \"age\": 25, \"birthdate\": \"1997-09-21\"}]';\nconst parsedUsers = JSON.parse(rawUsers);\n\n// Validating the array of users\nconst validatedUsers = validateUsers(parsedUsers);", "suffix": "if (validatedUsers.every(user => user !== null)) {\n    console.log('All user data is valid:', validatedUsers);\n} else {\n    console.error('Some user data is invalid');\n}\n\n// Cleaning up resources if any (not applicable in this example)\n", "golden_completion": "if (validatedUsers.some(user => user === null)) {\n    console.error('Some user data is invalid:', validatedUsers);\n} else {\n    console.log('All user data is valid:', validatedUsers);\n}\n", "LLM_justification": "This test case focuses on data validation patterns within the context of validating user data. The prefix establishes multiple helper functions for validating different data types, a schema interface for user data, and a function to validate individual user objects. The pattern is extended to validate an array of user objects. The golden completion must follow the established pattern to correctly validate the array of users and provide appropriate logging based on the validation result. This scenario is realistic and practical, testing the LLM's ability to recognize and continue the data validation pattern effectively.", "assertions": "import { strict as assert } from 'assert';\n\nconst testUsers = '[{\"name\": \"Alice\", \"age\": 28, \"birthdate\": \"1994-03-12\"}, {\"name\": \"Bob\", \"age\": 32, \"birthdate\": \"1990-07-08\"}]';\nconst parsedTestUsers = JSON.parse(testUsers);\nconst validatedTestUsers = validateUsers(parsedTestUsers);\n\nassert(validatedTestUsers.every(user => user !== null), 'All test user data should be valid');\n\nconst invalidUsers = '[{\"name\": \"\", \"age\": 28, \"birthdate\": \"1994-03-12\"}, {\"name\": \"Bob\", \"age\": null, \"birthdate\": \"1990-07-08\"}]';\nconst parsedInvalidUsers = JSON.parse(invalidUsers);\nconst validatedInvalidUsers = validateUsers(parsedInvalidUsers);\n\nassert(validatedInvalidUsers.some(user => user === null), 'Some invalid user data should be detected');\n", "DeepSeek-R1": "\nif (validatedUsers.every(user => user !== null)) {"}
{"id": "6", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\nimport * as path from 'path';\n\ninterface DataPoint {\n    timestamp: number;\n    value: number;\n}\n\nclass DataLoader {\n    private data: DataPoint[] = [];\n\n    constructor(private filePath: string) {}\n\n    public async loadData(): Promise<void> {\n        const fileContent = await fs.promises.readFile(this.filePath, 'utf-8');\n        const lines = fileContent.split('\\n');\n        for (const line of lines) {\n            const [timestampStr, valueStr] = line.split(',');\n            if (timestampStr && valueStr) {\n                const dataPoint: DataPoint = {\n                    timestamp: parseInt(timestampStr, 10),\n                    value: parseFloat(valueStr),\n                };\n                this.data.push(dataPoint);\n            }\n        }\n    }\n\n    public getData(): DataPoint[] {\n        return this.data;\n    }\n}\n\nclass DataAnalyzer {\n    constructor(private data: DataPoint[]) {}\n\n    public getAverageValue(): number {\n        const total = this.data.reduce((sum, dataPoint) => sum + dataPoint.value, 0);\n        return total / this.data.length;\n    }\n\n    public getMaxValue(): number {\n        return this.data.reduce((max, dataPoint) => dataPoint.value > max ? dataPoint.value : max, -Infinity);\n    }\n\n    public getMinValue(): number {\n        return this.data.reduce((min, dataPoint) => dataPoint.value < min ? dataPoint.value : min, Infinity);\n    }\n\n    public getMedianValue(): number {\n        const sortedValues = this.data.map(dataPoint => dataPoint.value).sort((a, b) => a - b);\n        const mid = Math.floor(sortedValues.length / 2);\n        if (sortedValues.length % 2 === 0) {\n            return (sortedValues[mid - 1] + sortedValues[mid]) / 2;\n        } else {\n            return sortedValues[mid];\n        }\n    }\n}\n\n// Usage example\nasync function main() {\n    const dataLoader = new DataLoader(path.join(__dirname, 'data.csv'));\n    await dataLoader.loadData();\n    const data = dataLoader.getData();\n    const analyzer = new DataAnalyzer(data);\n    console.log('Average Value:', analyzer.getAverageValue());\n    console.log('Max Value:', analyzer.getMaxValue());\n    console.log('Min Value:', analyzer.getMinValue());\n", "suffix": "\n}\n\nmain().catch(err => console.error(err));\n", "golden_completion": "    console.log('Median Value:', analyzer.getMedianValue());\n", "LLM_justification": "This test case is designed to assess the LLM's ability to recognize and complete a pattern in TypeScript code, specifically focusing on OOP patterns within a data analysis context. The prefix establishes a clear pattern of data loading and analysis, with multiple methods implemented in the DataAnalyzer class. The golden completion requires the LLM to continue this pattern by calling the getMedianValue method, which is consistent with the previous method calls for average, max, and min values. The suffix provides a realistic continuation of the code without duplicating the golden completion. This scenario tests the LLM's understanding of established patterns and its ability to follow TypeScript best practices.", "assertions": "import { strict as assert } from 'assert';\nimport * as path from 'path';\n\nasync function test() {\n    const dataLoader = new DataLoader(path.join(__dirname, 'test_data.csv'));\n    await dataLoader.loadData();\n    const data = dataLoader.getData();\n    const analyzer = new DataAnalyzer(data);\n\n    assert.strictEqual(analyzer.getAverageValue(), 3.5, 'Average value should be 3.5');\n    assert.strictEqual(analyzer.getMaxValue(), 5, 'Max value should be 5');\n    assert.strictEqual(analyzer.getMinValue(), 2, 'Min value should be 2');\n    assert.strictEqual(analyzer.getMedianValue(), 3.5, 'Median value should be 3.5');\n}\n\ntest().catch(err => console.error(err));\n", "DeepSeek-R1": "    console.log('Median Value:', analyzer.getMedianValue());"}
{"id": "7", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\n\ninterface DataPoint {\n    x: number;\n    y: number;\n}\n\nclass DataAnalyzer {\n    private data: DataPoint[];\n\n    constructor(data: DataPoint[]) {\n        this.data = data;\n    }\n\n    public calculateMean(): DataPoint {\n        const total = this.data.reduce((acc, point) => {\n            return { x: acc.x + point.x, y: acc.y + point.y };\n        }, { x: 0, y: 0 });\n        const count = this.data.length;\n        return { x: total.x / count, y: total.y / count };\n    }\n\n    public calculateVariance(mean: DataPoint): DataPoint {\n        const varianceTotal = this.data.reduce((acc, point) => {\n            return {\n                x: acc.x + Math.pow(point.x - mean.x, 2),\n                y: acc.y + Math.pow(point.y - mean.y, 2)\n            };\n        }, { x: 0, y: 0 });\n        const count = this.data.length;\n        return { x: varianceTotal.x / count, y: varianceTotal.y / count };\n    }\n\n    // Pattern: Methods that perform statistical calculations\n    // Next, we will add a method to calculate the standard deviation\n", "suffix": "\n    public saveResultsToFile(filename: string, results: {mean: DataPoint, variance: DataPoint, standardDeviation: DataPoint}): void {\n        const dataToSave = JSON.stringify(results, null, 2);\n        fs.writeFileSync(filename, dataToSave);\n    }\n}\n\n// Example usage\nconst data: DataPoint[] = [\n    { x: 1, y: 2 },\n    { x: 2, y: 3 },\n    { x: 3, y: 4 }\n];\nconst analyzer = new DataAnalyzer(data);\nconst mean = analyzer.calculateMean();\nconst variance = analyzer.calculateVariance(mean);\nconst standardDeviation = analyzer.calculateStandardDeviation(variance);\nconst results = { mean, variance, standardDeviation };\nanalyzer.saveResultsToFile('results.json', results);\n\n// Assertions\nimport assert from 'assert';\nconst savedData = JSON.parse(fs.readFileSync('results.json', 'utf-8'));\nassert.deepEqual(savedData.mean, mean);\nassert.deepEqual(savedData.variance, variance);\nassert.deepEqual(savedData.standardDeviation, standardDeviation);\nfs.unlinkSync('results.json'); // Cleanup\n", "golden_completion": "    public calculateStandardDeviation(variance: DataPoint): DataPoint {\n        return {\n            x: Math.sqrt(variance.x),\n            y: Math.sqrt(variance.y)\n        };\n    }", "LLM_justification": "This test case evaluates the LLM's ability to recognize and continue a pattern of statistical calculation methods within a TypeScript class that processes scientific data. The prefix establishes a pattern with methods for calculating the mean and variance, and the golden completion follows this pattern by adding a method to calculate the standard deviation. The suffix then uses this new method and saves the results to a file. This scenario tests the LLM's understanding of method consistency, parameter usage, and mathematical operations in the context of scientific computing.", "assertions": "import assert from 'assert';\nconst data: DataPoint[] = [\n    { x: 1, y: 2 },\n    { x: 2, y: 3 },\n    { x: 3, y: 4 }\n];\nconst analyzer = new DataAnalyzer(data);\nconst mean = analyzer.calculateMean();\nconst variance = analyzer.calculateVariance(mean);\nconst standardDeviation = analyzer.calculateStandardDeviation(variance);\nconst results = { mean, variance, standardDeviation };\nanalyzer.saveResultsToFile('results.json', results);\nconst savedData = JSON.parse(fs.readFileSync('results.json', 'utf-8'));\nassert.deepEqual(savedData.mean, mean);\nassert.deepEqual(savedData.variance, variance);\nassert.deepEqual(savedData.standardDeviation, standardDeviation);\nfs.unlinkSync('results.json');", "DeepSeek-R1": "    public calculateStandardDeviation(variance: DataPoint): DataPoint {\n        return {\n            x: Math.sqrt(variance.x),\n            y: Math.sqrt(variance.y)\n        };\n    }"}
{"id": "8", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n// Utility function to calculate the mean of an array of numbers\nfunction mean(numbers: number[]): number {\n    const total = numbers.reduce((acc, num) => acc + num, 0);\n    return total / numbers.length;\n}\n\n// Utility function to calculate the variance of an array of numbers\nfunction variance(numbers: number[]): number {\n    const meanValue = mean(numbers);\n    const squaredDiffs = numbers.map(num => Math.pow(num - meanValue, 2));\n    return mean(squaredDiffs);\n}\n\n// Utility function to calculate the standard deviation of an array of numbers\nfunction standardDeviation(numbers: number[]): number {\n    return Math.sqrt(variance(numbers));\n}\n\n// Utility function to calculate the median of an array of numbers\nfunction median(numbers: number[]): number {\n    const sortedNumbers = [...numbers].sort((a, b) => a - b);\n    const midIndex = Math.floor(sortedNumbers.length / 2);\n    if (sortedNumbers.length % 2 === 0) {\n        return (sortedNumbers[midIndex - 1] + sortedNumbers[midIndex]) / 2;\n    } else {\n        return sortedNumbers[midIndex];\n    }\n}\n\n// Utility function to calculate the mode of an array of numbers\nfunction mode(numbers: number[]): number[] {\n    const frequencyMap: { [key: number]: number } = {};\n    numbers.forEach(num => {\n        if (frequencyMap[num]) {\n            frequencyMap[num]++;\n        } else {\n            frequencyMap[num] = 1;\n        }\n    });\n    const maxFrequency = Math.max(...Object.values(frequencyMap));\n    return Object.keys(frequencyMap)\n        .filter(key => frequencyMap[Number(key)] === maxFrequency)\n        .map(Number);\n}\n\n// Utility function to calculate the range of an array of numbers\nfunction range(numbers: number[]): number {\n    const min = Math.min(...numbers);\n    const max = Math.max(...numbers);\n    return max - min;\n}\n\n// Test data\nconst data = [1, 2, 2, 3, 4, 4, 4, 5, 6];\n\n// Calculate statistics for the test data\nconst meanValue = mean(data);\nconst varianceValue = variance(data);\nconst standardDeviationValue = standardDeviation(data);\nconst medianValue = median(data);\nconst modeValue = mode(data);\nconst rangeValue = range(data);\n", "suffix": "\n// Assertions\nassert.strictEqual(meanValue, 3.4444444444444446, 'Mean value is incorrect');\nassert.strictEqual(varianceValue, 2.493827160493827, 'Variance value is incorrect');\nassert.strictEqual(standardDeviationValue, 1.5791859612183664, 'Standard deviation value is incorrect');\nassert.strictEqual(medianValue, 4, 'Median value is incorrect');\nassert.deepStrictEqual(modeValue, [4], 'Mode value is incorrect');\nassert.strictEqual(rangeValue, 5, 'Range value is incorrect');\n\nconsole.log('All assertions passed!');", "golden_completion": "// Utility function to calculate the skewness of an array of numbers\nfunction skewness(numbers: number[]): number {\n    const meanValue = mean(numbers);\n    const standardDev = standardDeviation(numbers);\n    const n = numbers.length;\n    const sumCubedDeviations = numbers.reduce((acc, num) => acc + Math.pow(num - meanValue, 3), 0);\n    return (n / ((n - 1) * (n - 2))) * (sumCubedDeviations / Math.pow(standardDev, 3));\n}\n\n// Utility function to calculate the kurtosis of an array of numbers\nfunction kurtosis(numbers: number[]): number {\n    const meanValue = mean(numbers);\n    const standardDev = standardDeviation(numbers);\n    const n = numbers.length;\n    const sumFourthDeviations = numbers.reduce((acc, num) => acc + Math.pow(num - meanValue, 4), 0);\n    return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * (sumFourthDeviations / Math.pow(standardDev, 4)) - (3 * Math.pow(n - 1, 2) / ((n - 2) * (n - 3)));\n}\n\nconst skewnessValue = skewness(data);\nconst kurtosisValue = kurtosis(data);\n\n", "LLM_justification": "This scenario tests the model's ability to recognize and continue a pattern of statistical utility functions for scientific computing. The prefix provides several examples of functions that calculate different statistical measures (mean, variance, standard deviation, median, mode, and range). The golden completion follows this established pattern by adding two new statistical measures (skewness and kurtosis) and includes the corresponding utility functions. This tests the model's ability to maintain consistency with the existing pattern and implement similar utility functions. The suffix includes assertions to verify the correctness of the computed values, ensuring the model's completion is both functionally and semantically correct.", "assertions": "assert.strictEqual(skewnessValue, 0.12260247977512876, 'Skewness value is incorrect');\nassert.strictEqual(kurtosisValue, -1.3733333333333334, 'Kurtosis value is incorrect');", "DeepSeek-R1": "assert.strictEqual(meanValue, 3.4444444444444446, 'Mean value is incorrect');\nassert.strictEqual(varianceValue, 2.493827160493827, 'Variance value is incorrect');\nassert.strictEqual(standardDeviationValue, 1.5791859612183664, 'Standard deviation value is incorrect');\nassert.strictEqual(medianValue, 4, 'Median value is incorrect');\nassert.deepStrictEqual(modeValue, [4], 'Mode value is incorrect');\nassert.strictEqual(rangeValue, 5, 'Range value is incorrect');\n\nconsole.log('All assertions passed!');"}
{"id": "9", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\ninterface DataPoint {\n    x: number;\n    y: number;\n}\n\nclass DataAnalyzer {\n    private data: DataPoint[];\n\n    constructor(data: DataPoint[]) {\n        this.data = data;\n    }\n\n    // A method to calculate the mean of x values\n    calculateMeanX(): number {\n        const sum = this.data.reduce((acc, point) => acc + point.x, 0);\n        return sum / this.data.length;\n    }\n\n    // A method to calculate the mean of y values\n    calculateMeanY(): number {\n        const sum = this.data.reduce((acc, point) => acc + point.y, 0);\n        return sum / this.data.length;\n    }\n\n    // A method to calculate the variance of x values\n    calculateVarianceX(): number {\n        const meanX = this.calculateMeanX();\n        const variance = this.data.reduce((acc, point) => acc + Math.pow(point.x - meanX, 2), 0) / this.data.length;\n        return variance;\n    }\n\n    // A method to calculate the variance of y values\n    calculateVarianceY(): number {\n        const meanY = this.calculateMeanY();\n        const variance = this.data.reduce((acc, point) => acc + Math.pow(point.y - meanY, 2), 0) / this.data.length;\n        return variance;\n    }\n}\n\nconst data: DataPoint[] = [\n    { x: 1, y: 2 },\n    { x: 2, y: 3 },\n    { x: 3, y: 4 },\n    { x: 4, y: 5 }\n];\n\nconst analyzer = new DataAnalyzer(data);\n", "suffix": "\nconst varianceY = analyzer.calculateVarianceY();\n\n// Assertions\nassert.strictEqual(meanX, 2.5);\nassert.strictEqual(meanY, 3.5);\nassert.strictEqual(varianceX, 1.25);\nassert.strictEqual(varianceY, 1.25);\n\nconsole.log('All assertions passed.');", "golden_completion": "const meanX = analyzer.calculateMeanX();\nconst meanY = analyzer.calculateMeanY();\nconst varianceX = analyzer.calculateVarianceX();", "LLM_justification": "This test case is a good example of pattern matching for several reasons. First, it establishes a clear pattern in the prefix with methods for calculating mean and variance for x and y values. This pattern is reinforced by the consistent method names and calculations. The golden completion continues this pattern by calling the methods defined in the prefix in a logical order, demonstrating understanding of the established pattern. The suffix then completes the example by using assertions to validate the correctness of the calculations, ensuring both functional and semantic correctness. The use of TypeScript interfaces and classes is appropriate for the domain context of scientific computing.", "assertions": "assert.strictEqual(meanX, 2.5);\nassert.strictEqual(meanY, 3.5);\nassert.strictEqual(varianceX, 1.25);\nassert.strictEqual(varianceY, 1.25);", "DeepSeek-R1": "const meanX = analyzer.calculateMeanX();\nconst meanY = analyzer.calculateMeanY();\nconst varianceX = analyzer.calculateVarianceX();"}
{"id": "10", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\n\n// Utility function to read and parse JSON files\nfunction readJSONFileSync<T>(filePath: string): T {\n    const data = fs.readFileSync(filePath, 'utf-8');\n    return JSON.parse(data) as T;\n}\n\n// Utility function to write JSON files\nfunction writeJSONFileSync<T>(filePath: string, data: T): void {\n    const json = JSON.stringify(data, null, 2);\n    fs.writeFileSync(filePath, json, 'utf-8');\n}\n\n// Type definition for a user\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\n// Type definition for a product\ninterface Product {\n    id: number;\n    name: string;\n    price: number;\n}\n\n// Function to validate user data\nfunction validateUser(user: User): boolean {\n    return user.id > 0 && user.name.length > 0 && /\\S+@\\S+\\.\\S+/.test(user.email);\n}\n\n// Function to validate product data\nfunction validateProduct(product: Product): boolean {\n    return product.id > 0 && product.name.length > 0 && product.price > 0;\n}\n\n// Sample user data\nconst sampleUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com'\n};\n\n// Sample product data\nconst sampleProduct: Product = {\n    id: 1,\n    name: 'Sample Product',\n    price: 99.99\n};\n\n// Validate the sample user data\nconst isUserValid = validateUser(sampleUser);\nconsole.log(`Is user valid? ${isUserValid}`);\n\n// Validate the sample product data\nconst isProductValid = validateProduct(sampleProduct);\nconsole.log(`Is product valid? ${isProductValid}`);\n\n// Reading from a JSON file\nconst users = readJSONFileSync<User[]>('users.json');\nconst products = readJSONFileSync<Product[]>('products.json');\n\n// Validate all users and products\nconst areUsersValid = users.every(validateUser);\nconsole.log(`Are all users valid? ${areUsersValid}`);\n", "suffix": "// Writing updated data back to JSON files\nwriteJSONFileSync('users.json', users);\nwriteJSONFileSync('products.json', products);\n", "golden_completion": "const areProductsValid = products.every(validateProduct);\nconsole.log(`Are all products valid? ${areProductsValid}`);\n\n", "LLM_justification": "This test case is designed to evaluate an LLM's ability to recognize and complete a pattern involving data validation and file operations in TypeScript. The prefix establishes a clear pattern of reading JSON files, validating data, and logging results. The golden completion continues this pattern by validating products, and the suffix completes the operation by writing the data back to JSON files. This scenario is realistic and demonstrates best practices in TypeScript for data validation and file handling.", "assertions": "import * as assert from 'assert';\nconst sampleUser: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\nconst sampleProduct: Product = { id: 1, name: 'Sample Product', price: 99.99 };\nconst users: User[] = [sampleUser];\nconst products: Product[] = [sampleProduct];\nassert.strictEqual(validateUser(sampleUser), true, 'Sample user should be valid');\nassert.strictEqual(validateProduct(sampleProduct), true, 'Sample product should be valid');\nassert.strictEqual(users.every(validateUser), true, 'All users should be valid');\nassert.strictEqual(products.every(validateProduct), true, 'All products should be valid');\n", "DeepSeek-R1": "const areProductsValid = products.every(validateProduct);\nconsole.log(`Are all products valid? ${areProductsValid}`);"}
{"id": "11", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n// Define a simple type for a 2D Point\ninterface Point {\n    x: number;\n    y: number;\n}\n\n// Define a class for a Shape\nabstract class Shape {\n    abstract area(): number;\n    abstract perimeter(): number;\n}\n\n// Define a class for a Circle that extends Shape\nclass Circle extends Shape {\n    constructor(public radius: number) {\n        super();\n    }\n\n    area(): number {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    perimeter(): number {\n        return 2 * Math.PI * this.radius;\n    }\n}\n\n// Define a class for a Rectangle that extends Shape\nclass Rectangle extends Shape {\n    constructor(public width: number, public height: number) {\n        super();\n    }\n\n    area(): number {\n        return this.width * this.height;\n    }\n\n    perimeter(): number {\n        return 2 * (this.width + this.height);\n    }\n}\n\n// Helper function to log shape details\nfunction logShapeDetails(shape: Shape): void {\n    console.log(`Shape details - Area: ${shape.area()}, Perimeter: ${shape.perimeter()}`);\n}\n\n// Create instances of shapes\nconst circle = new Circle(5);\nconst rectangle = new Rectangle(10, 20);\n\n// Log details of shapes\nlogShapeDetails(circle);\nlogShapeDetails(rectangle);\n", "suffix": "const square = new Square(15);\nlogShapeDetails(square);\n\n// Assertions\nassert.strictEqual(square.area(), 225);\nassert.strictEqual(square.perimeter(), 60);\n\nconsole.log('All tests passed');\n", "golden_completion": "class Square extends Shape {\n    constructor(public side: number) {\n        super();\n    }\n\n    area(): number {\n        return this.side * this.side;\n    }\n\n    perimeter(): number {\n        return 4 * this.side;\n    }\n}\n", "LLM_justification": "This example tests the LLM's ability to recognize and follow OOP patterns in TypeScript, particularly the implementation of abstract classes and their concrete subclasses. The pattern involves defining a Shape class with area and perimeter methods, which are then implemented by specific shapes (Circle, Rectangle). The golden completion requires the LLM to continue this pattern by correctly implementing a Square class that follows the same structure. This scenario is realistic as developers frequently work with abstract classes and their implementations in various domains, including scientific computing and simulations.", "assertions": "assert.strictEqual(square.area(), 225);\nassert.strictEqual(square.perimeter(), 60);\nconsole.log('All tests passed');\n", "DeepSeek-R1": "class Square extends Rectangle {\n    constructor(side: number) {\n        super(side, side);\n    }\n}"}
{"id": "12", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\n\n// Define a type for the data format\ninterface LogEntry {\n    timestamp: string;\n    level: 'INFO' | 'WARN' | 'ERROR';\n    message: string;\n}\n\n// Utility function to format log entries\nfunction formatLogEntry(entry: LogEntry): string {\n    return `${entry.timestamp} [${entry.level}] ${entry.message}`;\n}\n\n// Function to parse a log file\nfunction parseLogFile(filePath: string): LogEntry[] {\n    const content = fs.readFileSync(filePath, 'utf-8');\n    const lines = content.split('\\n');\n    const entries: LogEntry[] = [];\n    for (const line of lines) {\n        const parts = line.split(' ');\n        if (parts.length < 3) continue;\n        const timestamp = parts[0];\n        const level = parts[1] as 'INFO' | 'WARN' | 'ERROR';\n        const message = parts.slice(2).join(' ');\n        entries.push({ timestamp, level, message });\n    }\n    return entries;\n}\n\n// Function to filter log entries by level\nfunction filterLogEntries(entries: LogEntry[], level: 'INFO' | 'WARN' | 'ERROR'): LogEntry[] {\n    return entries.filter(entry => entry.level === level);\n}\n\n// Function to save log entries to a file\nfunction saveLogEntries(filePath: string, entries: LogEntry[]): void {\n    const content = entries.map(formatLogEntry).join('\\n');\n    fs.writeFileSync(filePath, content, 'utf-8');\n}\n\n// Example usage\nconst logEntries = parseLogFile('example.log');\nconst errorEntries = filterLogEntries(logEntries, 'ERROR');\nsaveLogEntries('errors.log', errorEntries);\n", "suffix": "console.log('Log processing complete.');\n", "golden_completion": "const warnEntries = filterLogEntries(logEntries, 'WARN');\nsaveLogEntries('warnings.log', warnEntries);\n", "LLM_justification": "This scenario demonstrates a clear pattern in the way log entries are processed. The pattern involves reading a log file, parsing it into structured log entries, filtering these entries based on a log level, and then saving the filtered entries to a new file. The completion requires recognizing this pattern and continuing it to handle warning log entries. This tests the LLM's ability to identify and extend a consistent functional pattern in the code.", "assertions": "import * as assert from 'assert';\nimport * as fs from 'fs';\n\nconst logEntries = parseLogFile('example.log');\nconst warnEntries = filterLogEntries(logEntries, 'WARN');\n\n// Assertions to verify the correct filtering of log entries\nassert.ok(warnEntries.length > 0, 'There should be warning log entries');\nassert.strictEqual(warnEntries.every(entry => entry.level === 'WARN'), true, 'All entries should be of level WARN');\n\n// Save the warning entries to a file\nsaveLogEntries('warnings.log', warnEntries);\n\n// Verify the file content\nconst savedContent = fs.readFileSync('warnings.log', 'utf-8');\nconst savedEntries = parseLogFile('warnings.log');\nassert.strictEqual(savedEntries.length, warnEntries.length, 'The number of saved entries should match the filtered entries');\nassert.strictEqual(savedContent, warnEntries.map(formatLogEntry).join('\\n'), 'The content of the saved file should match the formatted entries');\n\nconsole.log('All assertions passed.');\n", "DeepSeek-R1": "console.log('Log processing complete.');"}
{"id": "13", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\nimport * as path from 'path';\n\ninterface LogEntry {\n  timestamp: Date;\n  level: 'info' | 'warn' | 'error';\n  message: string;\n}\n\nclass Logger {\n  private logFilePath: string;\n\n  constructor(logFilePath: string) {\n    this.logFilePath = logFilePath;\n  }\n\n  private formatLogEntry(entry: LogEntry): string {\n    return `${entry.timestamp.toISOString()} - ${entry.level.toUpperCase()}: ${entry.message}`;\n  }\n\n  public async log(entry: LogEntry): Promise<void> {\n    const formattedEntry = this.formatLogEntry(entry);\n    await fs.promises.appendFile(this.logFilePath, formattedEntry + '\\n');\n  }\n\n  public async info(message: string): Promise<void> {\n    const entry: LogEntry = {\n      timestamp: new Date(),\n      level: 'info',\n      message: message\n    };\n    await this.log(entry);\n  }\n\n  public async warn(message: string): Promise<void> {\n    const entry: LogEntry = {\n      timestamp: new Date(),\n      level: 'warn',\n      message: message\n    };\n    await this.log(entry);\n  }\n\n  public async error(message: string): Promise<void> {\n    const entry: LogEntry = {\n      timestamp: new Date(),\n      level: 'error',\n      message: message\n    };\n    await this.log(entry);\n  }\n}\n\nconst logger = new Logger(path.join(__dirname, 'application.log'));\n\nasync function runLoggingDemo() {\n  await logger.info('This is an informational message.');\n  await logger.warn('This is a warning message.');\n", "suffix": "}\n\nrunLoggingDemo().then(() => console.log('Logging demo complete')).catch(err => console.error('Error during logging demo:', err));", "golden_completion": "  await logger.error('This is an error message.');", "LLM_justification": "This test case is a good example for testing pattern matching in large language models because it clearly establishes a pattern of logging methods in a Logger class. The Logger class has methods for logging info, warn, and error messages, each following a consistent pattern in terms of method structure and usage. The golden completion requires the model to recognize this pattern and correctly add the method call for logging an error message within the runLoggingDemo function. The scenario is realistic and practical, as logging is a common task in system operations, and the patterns used here are typical of logging implementations in TypeScript.", "assertions": "import * as assert from 'assert';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nasync function testLogger() {\n  const logFilePath = path.join(__dirname, 'test.log');\n  const logger = new Logger(logFilePath);\n\n  await logger.info('Test info message');\n  await logger.warn('Test warn message');\n  await logger.error('Test error message');\n\n  const logContent = await fs.promises.readFile(logFilePath, 'utf-8');\n\n  assert(logContent.includes('INFO: Test info message'), 'Info message should be logged');\n  assert(logContent.includes('WARN: Test warn message'), 'Warn message should be logged');\n  assert(logContent.includes('ERROR: Test error message'), 'Error message should be logged');\n\n  // Cleanup\n  await fs.promises.unlink(logFilePath);\n}\n\ntestLogger().then(() => console.log('All assertions passed')).catch(err => console.error('Assertion error:', err));", "DeepSeek-R1": "  await logger.error('This is an error message.');"}
{"id": "14", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\nimport * as path from 'path';\n\n// A utility function to read a JSON file\nfunction readJsonFile(filePath: string): any {\n    const data = fs.readFileSync(filePath, 'utf-8');\n    return JSON.parse(data);\n}\n\n// A utility function to write a JSON file\nfunction writeJsonFile(filePath: string, data: any): void {\n    const json = JSON.stringify(data, null, 2);\n    fs.writeFileSync(filePath, json, 'utf-8');\n}\n\n// A function to validate a JSON object against a schema\nfunction validateJson(schema: any, data: any): boolean {\n    // For simplicity, let's assume the schema is an object with required keys\n    for (const key of Object.keys(schema)) {\n        if (!data.hasOwnProperty(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Schema definition for data validation\nconst userSchema = {\n    \"id\": \"number\",\n    \"name\": \"string\",\n    \"email\": \"string\"\n};\n\n// Function to clean and normalize user data\nfunction cleanUserData(data: any): any {\n    const cleanedData = { ...data };\n    cleanedData.email = cleanedData.email.trim().toLowerCase();\n    return cleanedData;\n}\n\n// Example usage of the utility functions\nconst userData = readJsonFile(path.join(__dirname, 'user.json'));\n\nif (validateJson(userSchema, userData)) {\n    const cleanedData = cleanUserData(userData);\n    writeJsonFile(path.join(__dirname, 'cleaned_user.json'), cleanedData);\n} else {\n    console.error('Invalid user data');\n}\n\n// Another usage example for a different JSON file\nconst productSchema = {\n    \"id\": \"number\",\n    \"name\": \"string\",\n    \"price\": \"number\"\n};\n\nconst productData = readJsonFile(path.join(__dirname, 'product.json'));\n\nif (validateJson(productSchema, productData)) {\n    const cleanedData = cleanUserData(productData);\n    writeJsonFile(path.join(__dirname, 'cleaned_product.json'), cleanedData);\n} else {\n    console.error('Invalid product data');\n}\n\n// A function to clean and normalize product data\nfunction cleanProductData(data: any): any {\n    const cleanedData = { ...data };\n    cleanedData.name = cleanedData.name.trim();\n    cleanedData.price = parseFloat(cleanedData.price);\n    return cleanedData;\n}\n\nconst anotherProductData = readJsonFile(path.join(__dirname, 'another_product.json'));\n\nif (validateJson(productSchema, anotherProductData)) {\n    const cleanedData = cleanProductData(anotherProductData);\n    writeJsonFile(path.join(__dirname, 'cleaned_another_product.json'), cleanedData);\n} else {\n    console.error('Invalid another product data');\n}\n\n", "suffix": "const invalidData = { \"id\": 123, \"name\": \"Invalid Data\" };\n\nif (validateJson(productSchema, invalidData)) {\n    const cleanedData = cleanProductData(invalidData);\n    writeJsonFile(path.join(__dirname, 'cleaned_invalid_data.json'), cleanedData);\n} else {\n    console.error('Invalid data');\n}\n", "golden_completion": "const anotherUserData = readJsonFile(path.join(__dirname, 'another_user.json'));\n\nif (validateJson(userSchema, anotherUserData)) {\n    const cleanedData = cleanUserData(anotherUserData);\n    writeJsonFile(path.join(__dirname, 'cleaned_another_user.json'), cleanedData);\n} else {\n    console.error('Invalid another user data');\n}\n", "LLM_justification": "This test case establishes a clear pattern of reading, validating, cleaning, and writing JSON data using specific schemas. The pattern involves reading a JSON file, validating its structure against a schema, cleaning the data, and then writing the cleaned data to a new file. The completion requires the model to recognize and continue this established pattern with a new JSON file and schema. The provided assertions will verify both the adherence to the pattern and the functional correctness of the code.", "assertions": "const assert = require('assert');\nconst cleanedAnotherUserData = readJsonFile(path.join(__dirname, 'cleaned_another_user.json'));\nassert.strictEqual(cleanedAnotherUserData.email, 'another@example.com');\nassert.strictEqual(cleanedAnotherUserData.name, 'Another User');\nconst cleanedInvalidData = readJsonFile(path.join(__dirname, 'cleaned_invalid_data.json'));\nassert.strictEqual(cleanedInvalidData.id, undefined);", "DeepSeek-R1": "const invalidData = { \"id\": 123, \"name\": \"Invalid Data\" };"}
{"id": "15", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\ntype DataPoint = { x: number; y: number };\n\ntype Dataset = DataPoint[];\n\n/**\n * Computes the mean of the x values in the dataset.\n */\nfunction computeMeanX(dataset: Dataset): number {\n    const total = dataset.reduce((acc, point) => acc + point.x, 0);\n    return total / dataset.length;\n}\n\n/**\n * Computes the mean of the y values in the dataset.\n */\nfunction computeMeanY(dataset: Dataset): number {\n    const total = dataset.reduce((acc, point) => acc + point.y, 0);\n    return total / dataset.length;\n}\n\n/**\n * Computes the variance of the x values in the dataset.\n */\nfunction computeVarianceX(dataset: Dataset): number {\n    const meanX = computeMeanX(dataset);\n    const variance = dataset.reduce((acc, point) => acc + Math.pow(point.x - meanX, 2), 0);\n    return variance / dataset.length;\n}\n\n/**\n * Computes the variance of the y values in the dataset.\n */\nfunction computeVarianceY(dataset: Dataset): number {\n    const meanY = computeMeanY(dataset);\n    const variance = dataset.reduce((acc, point) => acc + Math.pow(point.y - meanY, 2), 0);\n    return variance / dataset.length;\n}\n\n/**\n * Computes the standard deviation of the x values in the dataset.\n */\nfunction computeStdDevX(dataset: Dataset): number {\n    const varianceX = computeVarianceX(dataset);\n    return Math.sqrt(varianceX);\n}\n\n/**\n * Computes the standard deviation of the y values in the dataset.\n */\nfunction computeStdDevY(dataset: Dataset): number {\n    const varianceY = computeVarianceY(dataset);\n    return Math.sqrt(varianceY);\n}\n\n// Example dataset\nconst dataset: Dataset = [\n    { x: 1, y: 2 },\n    { x: 2, y: 3 },\n    { x: 3, y: 4 },\n    { x: 4, y: 5 },\n    { x: 5, y: 6 }\n];", "suffix": "const computedStdDevX = computeStdDevX(dataset);\nconst computedStdDevY = computeStdDevY(dataset);\n\n// Assertions\nassert.strictEqual(computedStdDevX.toFixed(2), '1.41');\nassert.strictEqual(computedStdDevY.toFixed(2), '1.41');\n\nconsole.log('All assertions passed.');\n", "golden_completion": "\n\n/**\n * Computes the correlation coefficient between the x and y values in the dataset.\n */\nfunction computeCorrelationCoefficient(dataset: Dataset): number {\n    const meanX = computeMeanX(dataset);\n    const meanY = computeMeanY(dataset);\n    const stdDevX = computeStdDevX(dataset);\n    const stdDevY = computeStdDevY(dataset);\n\n    const covariance = dataset.reduce((acc, point) => acc + (point.x - meanX) * (point.y - meanY), 0) / dataset.length;\n    return covariance / (stdDevX * stdDevY);\n}\n\nconst computedCorrelationCoefficient = computeCorrelationCoefficient(dataset);\nassert.strictEqual(computedCorrelationCoefficient.toFixed(2), '1.00');\n", "LLM_justification": "This example tests the ability of the LLM to recognize and continue a pattern of statistical computations on a dataset. The prefix establishes a clear pattern of functions to compute mean, variance, and standard deviation for x and y values in a dataset. The golden completion requires the LLM to extend this pattern by implementing a function to compute the correlation coefficient, which logically follows from the previous computations. The suffix then continues to use the new function and asserts its correctness. This pattern is non-trivial but recognizable to anyone familiar with statistical analysis in TypeScript.", "assertions": "assert.strictEqual(computeMeanX(dataset).toFixed(2), '3.00');\nassert.strictEqual(computeMeanY(dataset).toFixed(2), '4.00');\nassert.strictEqual(computeVarianceX(dataset).toFixed(2), '2.50');\nassert.strictEqual(computeVarianceY(dataset).toFixed(2), '2.50');\nassert.strictEqual(computeStdDevX(dataset).toFixed(2), '1.58');\nassert.strictEqual(computeStdDevY(dataset).toFixed(2), '1.58');\nassert.strictEqual(computeCorrelationCoefficient(dataset).toFixed(2), '1.00');\n", "DeepSeek-R1": ";"}
{"id": "16", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\n\n// Define a higher-order function that processes files\nfunction processFile(filePath: string, processor: (data: string) => string): string {\n    const data = fs.readFileSync(filePath, 'utf-8');\n    return processor(data);\n}\n\n// Define a function that replaces all occurrences of a word\nfunction replaceWord(data: string, target: string, replacement: string): string {\n    const regex = new RegExp(target, 'g');\n    return data.replace(regex, replacement);\n}\n\n// Define a function that converts all text to uppercase\nfunction toUpperCase(data: string): string {\n    return data.toUpperCase();\n}\n\n// Mock file content for testing\nconst testFilePath = 'test.txt';\nfs.writeFileSync(testFilePath, 'hello world');\n\n// Test processing the file with the replaceWord function\nconst replacedContent = processFile(testFilePath, (data) => replaceWord(data, 'hello', 'hi'));\nconsole.log(replacedContent);  // Should log 'hi world'\n\n// Test processing the file with the toUpperCase function\nconst upperCaseContent = processFile(testFilePath, toUpperCase);\nconsole.log(upperCaseContent);  // Should log 'HELLO WORLD'\n\n", "suffix": "// Test processing the file with a custom function\nconst customContent = processFile(testFilePath, (data) => data.split(' ').reverse().join(' '));\nconsole.log(customContent);  // Should log 'world hello'\n\n// Clean up the test file\nfs.unlinkSync(testFilePath);\n", "golden_completion": "// Test processing the file with both functions combined\nconst combinedContent = processFile(testFilePath, (data) => toUpperCase(replaceWord(data, 'hello', 'hi')));\nconsole.log(combinedContent);  // Should log 'HI WORLD'\n\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving higher-order functions in the context of file processing. The prefix establishes the pattern by defining a higher-order function `processFile` and demonstrating its use with two different processing functions (`replaceWord` and `toUpperCase`). The golden completion continues this pattern by combining both processing functions in a single call, which is a common practice in functional programming. The assertions verify that the functions are applied correctly and that the pattern is followed.", "assertions": "import * as fs from 'fs';\nimport { strict as assert } from 'assert';\n\nconst testFilePath = 'test.txt';\nfs.writeFileSync(testFilePath, 'hello world');\n\nconst replacedContent = processFile(testFilePath, (data) => replaceWord(data, 'hello', 'hi'));\nassert.strictEqual(replacedContent, 'hi world');\n\nconst upperCaseContent = processFile(testFilePath, toUpperCase);\nassert.strictEqual(upperCaseContent, 'HELLO WORLD');\n\nconst combinedContent = processFile(testFilePath, (data) => toUpperCase(replaceWord(data, 'hello', 'hi')));\nassert.strictEqual(combinedContent, 'HI WORLD');\n\nconst customContent = processFile(testFilePath, (data) => data.split(' ').reverse().join(' '));\nassert.strictEqual(customContent, 'world hello');\n\nfs.unlinkSync(testFilePath);\n", "DeepSeek-R1": "const customContent = processFile(testFilePath, (data) => data.split(' ').reverse().join(' '));"}
{"id": "17", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse<T> {\n    success: boolean;\n    data: T;\n}\n\ninterface Metric {\n    id: number;\n    value: number;\n}\n\nasync function fetchMetrics(): Promise<ApiResponse<Metric[]>> {\n    try {\n        const response = await axios.get<ApiResponse<Metric[]>>('https://api.example.com/metrics');\n        return response.data;\n    } catch (error) {\n        throw new Error('Failed to fetch metrics');\n    }\n}\n\nasync function fetchMetricById(id: number): Promise<ApiResponse<Metric>> {\n    try {\n        const response = await axios.get<ApiResponse<Metric>>(`https://api.example.com/metrics/${id}`);\n        return response.data;\n    } catch (error) {\n        throw new Error(`Failed to fetch metric with id ${id}`);\n    }\n}\n\nasync function fetchAllData(): Promise<{ metrics: Metric[], metricDetails: Metric[] }> {\n    const metricsResponse = await fetchMetrics();\n    if (!metricsResponse.success) {\n        throw new Error('Failed to fetch metrics');\n    }\n    const metrics = metricsResponse.data;\n\n    const metricDetails: Metric[] = [];\n    for (const metric of metrics) {\n        const metricDetailResponse = await fetchMetricById(metric.id);\n        if (!metricDetailResponse.success) {\n            throw new Error(`Failed to fetch metric details for id ${metric.id}`);\n        }\n        metricDetails.push(metricDetailResponse.data);\n    }\n\n    return { metrics, metricDetails };\n}\n\n// Example usage\nasync function run() {\n    try {\n        const data = await fetchAllData();\n        console.log('Fetched data:', data);\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nrun();\n", "suffix": "\n\n// Cleanup code\naxios.defaults.baseURL = '';\naxios.defaults.headers.common = {};\n", "golden_completion": "async function fetchMetricByName(name: string): Promise<ApiResponse<Metric>> {\n    try {\n        const response = await axios.get<ApiResponse<Metric>>(`https://api.example.com/metrics/name/${name}`);\n        return response.data;\n    } catch (error) {\n        throw new Error(`Failed to fetch metric with name ${name}`);\n    }\n}\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of async functions fetching data from an API. The established pattern involves making HTTP GET requests using axios, handling errors, and returning the response data. The golden completion requires the LLM to create a new function that follows this pattern, but for fetching data by name instead of ID, which is a realistic extension of the provided prefix code. The assertions verify that the new function works correctly and adheres to the established pattern.", "assertions": "import { strict as assert } from 'assert';\n\n(async function() {\n    // Mock axios for testing\n    const axios = require('axios');\n    const MockAdapter = require('axios-mock-adapter');\n    const mock = new MockAdapter(axios);\n\n    mock.onGet('https://api.example.com/metrics/name/testName').reply(200, { success: true, data: { id: 1, value: 100 } });\n\n    const result = await fetchMetricByName('testName');\n    assert.equal(result.success, true, 'Expected success to be true');\n    assert.equal(result.data.id, 1, 'Expected id to be 1');\n    assert.equal(result.data.value, 100, 'Expected value to be 100');\n\n    mock.restore();\n})();", "DeepSeek-R1": "jest.mock('axios');\n\ndescribe('fetchAllData', () => {\n  it('should return metrics and details on successful fetch', async () => {\n    const mockMetrics = [{ id: 1, value: 100 }];\n    const mockDetails = { id: 1, value: 100 };\n    (axios.get as jest.Mock)\n      .mockResolvedValueOnce({ data: { success: true, data: mockMetrics } })\n      .mockResolvedValueOnce({ data: { success: true, data: mockDetails } });\n\n    const result = await fetchAllData();\n    expect(result.metrics).toEqual(mockMetrics);\n    expect(result.metricDetails).toEqual([mockDetails]);\n  });\n\n  it('should throw error when metrics fetch fails', async () => {\n    (axios.get as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n    await expect(fetchAllData()).rejects.toThrow('Failed to fetch metrics');\n  });\n});"}
{"id": "18", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as crypto from 'crypto';\n\ninterface User {\n  id: string;\n  username: string;\n  passwordHash: string;\n}\n\nclass Authentication {\n  private users: Map<string, User> = new Map();\n\n  constructor() {\n    // Initialize with a test user\n    const testUser: User = {\n      id: '1',\n      username: 'testuser',\n      passwordHash: this.hashPassword('testpassword')\n    };\n    this.users.set(testUser.username, testUser);\n  }\n\n  private hashPassword(password: string): string {\n    return crypto.createHash('sha256').update(password).digest('hex');\n  }\n\n  async register(username: string, password: string): Promise<void> {\n    if (this.users.has(username)) {\n      throw new Error('User already exists');\n    }\n    const user: User = {\n      id: crypto.randomUUID(),\n      username,\n      passwordHash: this.hashPassword(password)\n    };\n    this.users.set(username, user);\n  }\n\n  async authenticate(username: string, password: string): Promise<boolean> {\n    const user = this.users.get(username);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    const passwordHash = this.hashPassword(password);\n    return user.passwordHash === passwordHash;\n  }\n\n  async changePassword(username: string, oldPassword: string, newPassword: string): Promise<void> {\n    const user = this.users.get(username);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    const oldPasswordHash = this.hashPassword(oldPassword);\n    if (user.passwordHash !== oldPasswordHash) {\n      throw new Error('Incorrect old password');\n    }\n    user.passwordHash = this.hashPassword(newPassword);\n  }\n}\n\nconst auth = new Authentication();\n", "suffix": "auth.authenticate('testuser', 'testpassword').then(result => {\n  console.log('Authentication result:', result);\n}).catch(err => {\n  console.error('Error during authentication:', err);\n});\n\n// Clean-up code if necessary can be placed here\n", "golden_completion": "auth.register('newuser', 'newpassword').then(() => {\n  console.log('User registered successfully');\n}).catch(err => {\n  console.error('Error during registration:', err);\n});\n", "LLM_justification": "This is a good test case for pattern matching because it demonstrates a clear pattern of asynchronous method calls within an authentication class. The completion required involves registering a new user, which is a logical extension of the provided prefix methods. The pattern of using async/await and handling promises is well-established in the prefix, making it identifiable for an LLM to follow. The suffix continues the pattern by authenticating a user, ensuring the pattern is clear and consistent.", "assertions": "auth.authenticate('testuser', 'testpassword').then(result => {\n  console.assert(result === true, 'Test user should be authenticated');\n  return auth.register('newuser', 'newpassword');\n}).then(() => {\n  return auth.authenticate('newuser', 'newpassword');\n}).then(result => {\n  console.assert(result === true, 'New user should be authenticated');\n}).catch(err => {\n  console.error('Assertion failed:', err);\n});", "DeepSeek-R1": "auth.changePassword('testuser', 'testpassword', 'newpassword').then(() => {\n  return auth.authenticate('testuser', 'newpassword');\n}).then(result => {\n  console.log('Authentication after password change:', result);\n}).catch(err => {\n  console.error('Error during password change:', err);\n});"}
{"id": "19", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\nimport * as path from 'path';\n\ninterface LogEntry {\n    timestamp: Date;\n    level: 'info' | 'warn' | 'error';\n    message: string;\n}\n\nclass Logger {\n    private logFilePath: string;\n\n    constructor(logFilePath: string) {\n        this.logFilePath = logFilePath;\n    }\n\n    private formatLogEntry(entry: LogEntry): string {\n        return `[${entry.timestamp.toISOString()}] [${entry.level}] ${entry.message}`;\n    }\n\n    public logInfo(message: string): void {\n        const entry: LogEntry = {\n            timestamp: new Date(),\n            level: 'info',\n            message: message\n        };\n        this.appendLogEntry(entry);\n    }\n\n    public logWarn(message: string): void {\n        const entry: LogEntry = {\n            timestamp: new Date(),\n            level: 'warn',\n            message: message\n        };\n        this.appendLogEntry(entry);\n    }\n\n    public logError(message: string): void {\n        const entry: LogEntry = {\n            timestamp: new Date(),\n            level: 'error',\n            message: message\n        };\n        this.appendLogEntry(entry);\n    }\n\n    private appendLogEntry(entry: LogEntry): void {\n        const formattedEntry = this.formatLogEntry(entry) + '\\n';\n        fs.appendFileSync(this.logFilePath, formattedEntry);\n    }\n}\n\nconst logger = new Logger(path.join(__dirname, 'app.log'));\nlogger.logInfo('Application started');\nlogger.logWarn('Low disk space');\n", "suffix": "console.log('Log entries written to file.');\n\n// Cleanup\ntry {\n    fs.unlinkSync(path.join(__dirname, 'app.log'));\n} catch (err) {\n    console.error('Error cleaning up log file:', err);\n}\n", "golden_completion": "logger.logError('Unhandled exception occurred');", "LLM_justification": "This test case evaluates the LLM's ability to recognize and continue a clear logging pattern established in the Logger class. The Logger class has methods for logging messages at different levels (info, warn, error). The pattern is well-defined and includes method names, parameter types, and internal logic for formatting and writing log entries. The golden completion must follow this pattern by adding a logError call with an appropriate message. This tests the model's understanding of consistent method usage and pattern continuation within a class structure.", "assertions": "import * as fs from 'fs';\nimport * as path from 'path';\n\nconst logContent = fs.readFileSync(path.join(__dirname, 'app.log'), 'utf-8');\nconsole.assert(logContent.includes('[info] Application started'), 'Info log entry missing');\nconsole.assert(logContent.includes('[warn] Low disk space'), 'Warn log entry missing');\nconsole.assert(logContent.includes('[error] Unhandled exception occurred'), 'Error log entry missing');\n", "DeepSeek-R1": "logger.logError('Unexpected error occurred');"}
{"id": "20", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\nimport * as path from 'path';\n\n// Define a generic interface for data processing\ninterface DataProcessor<T> {\n    process(data: T): T;\n}\n\n// Implementation of a data processor for scientific computations\nclass ScientificDataProcessor implements DataProcessor<number[]> {\n    process(data: number[]): number[] {\n        return data.map(d => d * 2);\n    }\n}\n\n// Implementation of a data processor for media processing\nclass MediaDataProcessor implements DataProcessor<Buffer> {\n    process(data: Buffer): Buffer {\n        return Buffer.from(data.toString('base64'), 'base64');\n    }\n}\n\n// Function to process data with a given processor\nfunction processData<T>(processor: DataProcessor<T>, data: T): T {\n    return processor.process(data);\n}\n\n// Helper function to read a file asynchronously\nasync function readFileAsync(filePath: string): Promise<Buffer> {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Example usage of the data processors\nasync function main() {\n    // Process scientific data\n    const scientificProcessor = new ScientificDataProcessor();\n    const scientificData = [1, 2, 3, 4, 5];\n    const processedScientificData = processData(scientificProcessor, scientificData);\n    console.log('Processed Scientific Data:', processedScientificData);\n\n    // Process media data\n    const mediaProcessor = new MediaDataProcessor();\n    const mediaFilePath = path.join(__dirname, 'example.mp4');\n    try {\n        const mediaData = await readFileAsync(mediaFilePath);\n        const processedMediaData = processData(mediaProcessor, mediaData);\n        console.log('Processed Media Data:', processedMediaData.toString('base64'));\n    } catch (error) {\n        console.error('Error processing media data:', error);\n    }\n}\n\nmain().catch(console.error);", "suffix": "class StringDataProcessor implements DataProcessor<string> {\n    process(data: string): string {\n        return data.toUpperCase();\n    }\n}\n\n// Example usage of the string data processor\nconst stringProcessor = new StringDataProcessor();\nconst stringData = 'hello world';\nconst processedStringData = processData(stringProcessor, stringData);\nconsole.log('Processed String Data:', processedStringData);", "golden_completion": "class JsonDataProcessor implements DataProcessor<object> {\n    process(data: object): object {\n        return JSON.parse(JSON.stringify(data));\n    }\n}\n\n// Example usage of the JSON data processor\nconst jsonProcessor = new JsonDataProcessor();\nconst jsonData = { key: 'value' };\nconst processedJsonData = processData(jsonProcessor, jsonData);\nconsole.log('Processed JSON Data:', processedJsonData);", "LLM_justification": "This test case evaluates the LLM's ability to recognize and extend a pattern involving generic data processors in TypeScript. The prefix establishes a clear pattern with multiple data processors implementing a generic interface and a function to process data using these processors. The golden_completion continues this pattern by adding another data processor for JSON data, demonstrating an understanding of the pattern and TypeScript generics. The assertions verify that the new processor works correctly and adheres to the established pattern.", "assertions": "import { strict as assert } from 'assert';\n\n// Reuse the defined processors and functions from the prefix and golden_completion\nconst jsonProcessor = new JsonDataProcessor();\nconst jsonData = { key: 'value' };\nconst processedJsonData = processData(jsonProcessor, jsonData);\nassert.deepEqual(processedJsonData, jsonData, 'The JSON data should be processed correctly');\n\nconst stringProcessor = new StringDataProcessor();\nconst stringData = 'hello world';\nconst processedStringData = processData(stringProcessor, stringData);\nassert.equal(processedStringData, 'HELLO WORLD', 'The string data should be processed correctly');", "DeepSeek-R1": "class StringDataProcessor implements DataProcessor<string> {\n    process(data: string): string {\n        return data.toUpperCase();\n    }\n}\n\n// Example usage of the string data processor\nconst stringProcessor = new StringDataProcessor();\nconst stringData = 'hello world';\nconst processedStringData = processData(stringProcessor, stringData);\nconsole.log('Processed String Data:', processedStringData);"}
{"id": "21", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n// Data structure for representing a Matrix in scientific computing\nclass Matrix {\n    data: number[][];\n    rows: number;\n    cols: number;\n\n    constructor(rows: number, cols: number, initial: number = 0) {\n        this.rows = rows;\n        this.cols = cols;\n        this.data = Array.from({ length: rows }, () => Array(cols).fill(initial));\n    }\n\n    // Method for adding another matrix to this matrix\n    add(matrix: Matrix): Matrix {\n        assert.strictEqual(this.rows, matrix.rows, 'Matrix row counts must match');\n        assert.strictEqual(this.cols, matrix.cols, 'Matrix column counts must match');\n\n        let result = new Matrix(this.rows, this.cols);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.cols; j++) {\n                result.data[i][j] = this.data[i][j] + matrix.data[i][j];\n            }\n        }\n        return result;\n    }\n\n    // Method for subtracting another matrix from this matrix\n    subtract(matrix: Matrix): Matrix {\n        assert.strictEqual(this.rows, matrix.rows, 'Matrix row counts must match');\n        assert.strictEqual(this.cols, matrix.cols, 'Matrix column counts must match');\n\n        let result = new Matrix(this.rows, this.cols);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.cols; j++) {\n                result.data[i][j] = this.data[i][j] - matrix.data[i][j];\n            }\n        }\n        return result;\n    }\n\n    // Method for multiplying this matrix by another matrix\n    multiply(matrix: Matrix): Matrix {\n        assert.strictEqual(this.cols, matrix.rows, 'Matrix column count of first must match row count of second');\n\n        let result = new Matrix(this.rows, matrix.cols);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < matrix.cols; j++) {\n                for (let k = 0; k < this.cols; k++) {\n                    result.data[i][j] += this.data[i][k] * matrix.data[k][j];\n                }\n            }\n        }\n        return result;\n    }\n}\n\n// Sample matrices for testing\nconst matrixA = new Matrix(2, 2);\nmatrixA.data = [\n    [1, 2],\n    [3, 4]\n];\n\nconst matrixB = new Matrix(2, 2);\nmatrixB.data = [\n    [5, 6],\n    [7, 8]\n];\n\nconst matrixC = new Matrix(2, 2);\nmatrixC.data = [\n    [1, 0],\n    [0, 1]\n];\n\n// Testing matrix addition\nconst addedMatrix = matrixA.add(matrixB);\nassert.deepStrictEqual(addedMatrix.data, [\n    [6, 8],\n    [10, 12]\n]);\n\n// Testing matrix subtraction\nconst subtractedMatrix = matrixA.subtract(matrixC);\nassert.deepStrictEqual(subtractedMatrix.data, [\n    [0, 2],\n    [3, 3]\n]);\n\n", "suffix": "\n\nconst multipliedMatrix2 = matrixA.multiply(matrixB);\nassert.deepStrictEqual(multipliedMatrix2.data, [\n    [19, 22],\n    [43, 50]\n]);\n", "golden_completion": "// Testing matrix multiplication\nconst multipliedMatrix = matrixA.multiply(matrixC);\nassert.deepStrictEqual(multipliedMatrix.data, [\n    [1, 2],\n    [3, 4]\n]);\n", "LLM_justification": "This test case is a good example of a clear pattern in the context of scientific computing, specifically matrix operations. The pattern established involves basic matrix operations (addition, subtraction, multiplication) following a consistent structure. The golden completion is the matrix multiplication test that follows the same pattern as the addition and subtraction tests. The assertions check for correct matrix multiplication results, ensuring the pattern is adhered to and the functionality is correct.", "assertions": "assert.deepStrictEqual(multipliedMatrix.data, [\n    [1, 2],\n    [3, 4]\n]);", "DeepSeek-R1": "const multipliedMatrix1 = matrixA.multiply(matrixC);\nassert.deepStrictEqual(multipliedMatrix1.data, matrixA.data);"}
{"id": "22", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n// Define a generic type to handle data with different structures\ninterface DataType<T> {\n    id: number;\n    data: T;\n}\n\n// A function to process data of type string\nfunction processDataString(data: DataType<string>): string {\n    return `Processed string data: ${data.data}`;\n}\n\n// A function to process data of type number\nfunction processDataNumber(data: DataType<number>): string {\n    return `Processed number data: ${data.data}`;\n}\n\n// Function to handle array of strings\nfunction processDataArrayString(data: DataType<string[]>): string {\n    return `Processed array of strings: ${data.data.join(', ')}`;\n}\n\n// Example data\nconst stringData: DataType<string> = { id: 1, data: 'example' };\nconst numberData: DataType<number> = { id: 2, data: 42 };\nconst arrayStringData: DataType<string[]> = { id: 3, data: ['one', 'two', 'three'] };\n\n// Process the data using the functions\nconst processedString = processDataString(stringData);\nconst processedNumber = processDataNumber(numberData);\nconst processedArrayString = processDataArrayString(arrayStringData);\n\n// Assertions to verify the processing\nassert.strictEqual(processedString, 'Processed string data: example');\nassert.strictEqual(processedNumber, 'Processed number data: 42');\nassert.strictEqual(processedArrayString, 'Processed array of strings: one, two, three');\n\n// Add a new function to process data of type boolean\nfunction processDataBoolean(data: DataType<boolean>): string {\n    return `Processed boolean data: ${data.data}`;\n}\n\n// Example data for boolean type\nconst booleanData: DataType<boolean> = { id: 4, data: true };\n\n// Process the data using the new function\nconst processedBoolean = processDataBoolean(booleanData);\n\n// Assertions to verify the new processing\nassert.strictEqual(processedBoolean, 'Processed boolean data: true');\n\n// Cleanup\n", "suffix": "// Example data for object type\nconst objectData: DataType<{ key: string }> = { id: 5, data: { key: 'value' } };\n\n// Process the data using the new function\nconst processedObject = processDataObject(objectData);\n\n// Assertions to verify the new processing\nassert.strictEqual(processedObject, 'Processed object data: {\"key\":\"value\"}');\n\n// Cleanup\n", "golden_completion": "function processDataObject(data: DataType<{ key: string }>): string {\n    return `Processed object data: ${JSON.stringify(data.data)}`;\n}\n\n// Example data for object type\nconst objectData: DataType<{ key: string }> = { id: 5, data: { key: 'value' } };\n\n// Process the data using the new function\nconst processedObject = processDataObject(objectData);\n\n// Assertions to verify the new processing\nassert.strictEqual(processedObject, 'Processed object data: {\"key\":\"value\"}');\n\n// Cleanup", "LLM_justification": "This test case evaluates the LLM's ability to recognize and extend a pattern involving generic type definitions and specialized processing functions for different data types. The pattern is established with multiple examples of processing functions for various data types (string, number, array of strings, boolean) in the prefix. The task requires the LLM to add a new function to handle object data, following the same pattern. This scenario tests the LLM's understanding of TypeScript generics, function implementation, and consistency in handling different types, which are common tasks for TypeScript developers.", "assertions": "assert.strictEqual(processedString, 'Processed string data: example');\nassert.strictEqual(processedNumber, 'Processed number data: 42');\nassert.strictEqual(processedArrayString, 'Processed array of strings: one, two, three');\nassert.strictEqual(processedBoolean, 'Processed boolean data: true');\nassert.strictEqual(processedObject, 'Processed object data: {\"key\":\"value\"}');", "DeepSeek-R1": "function processDataObject(data: DataType<{ key: string }>): string {\n    return `Processed object data: ${JSON.stringify(data.data)}`;\n}"}
{"id": "23", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\nimport * as path from 'path';\n\ninterface LogEntry {\n    timestamp: Date;\n    level: string;\n    message: string;\n}\n\nclass Logger {\n    private logFilePath: string;\n\n    constructor(logFilePath: string) {\n        this.logFilePath = logFilePath;\n    }\n\n    private formatLogEntry(entry: LogEntry): string {\n        return `[${entry.timestamp.toISOString()}] [${entry.level}] ${entry.message}`;\n    }\n\n    public async logInfo(message: string): Promise<void> {\n        const entry: LogEntry = {\n            timestamp: new Date(),\n            level: 'INFO',\n            message,\n        };\n        await this.writeLog(entry);\n    }\n\n    public async logWarning(message: string): Promise<void> {\n        const entry: LogEntry = {\n            timestamp: new Date(),\n            level: 'WARNING',\n            message,\n        };\n        await this.writeLog(entry);\n    }\n\n    public async logError(message: string): Promise<void> {\n        const entry: LogEntry = {\n            timestamp: new Date(),\n            level: 'ERROR',\n            message,\n        };\n        await this.writeLog(entry);\n    }\n\n    private async writeLog(entry: LogEntry): Promise<void> {\n        const formattedEntry = this.formatLogEntry(entry);\n        await fs.promises.appendFile(this.logFilePath, formattedEntry + '\\n');\n    }\n}\n\nconst logger = new Logger(path.join(__dirname, 'system.log'));\n\n(async () => {\n    await logger.logInfo('System initialization complete.');\n    await logger.logWarning('System is running low on memory.');\n", "suffix": "    console.log('Logging complete.');\n})();\n", "golden_completion": "    await logger.logError('System encountered an unexpected error.');\n", "LLM_justification": "This test case is designed to evaluate the model's ability to recognize and complete a pattern in an OOP context within a system operations logging scenario. The Logger class demonstrates a clear pattern for logging messages at different levels (INFO, WARNING, ERROR). The model must identify this pattern and correctly generate the logError method call. The completion involves non-trivial understanding as it requires recognizing the established methods and their usage.", "assertions": "import * as fs from 'fs';\nimport * as path from 'path';\n\nconst logFilePath = path.join(__dirname, 'system.log');\n(async () => {\n    const logContent = await fs.promises.readFile(logFilePath, 'utf-8');\n    console.assert(logContent.includes('System initialization complete.'), 'Log should contain system initialization message.');\n    console.assert(logContent.includes('System is running low on memory.'), 'Log should contain memory warning message.');\n    console.assert(logContent.includes('System encountered an unexpected error.'), 'Log should contain error message.');\n    // Clean up\n    await fs.promises.unlink(logFilePath);\n})();\n", "DeepSeek-R1": "    await logger.logError('Critical system failure detected.');"}
{"id": "24", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\nimport * as path from 'path';\n\ninterface FileData {\n    name: string;\n    content: string;\n}\n\nclass FileManager {\n    private directory: string;\n\n    constructor(directory: string) {\n        this.directory = directory;\n    }\n\n    // A method to read a file and return its data\n    public readFile(fileName: string): Promise<FileData> {\n        return new Promise((resolve, reject) => {\n            const filePath = path.join(this.directory, fileName);\n            fs.readFile(filePath, 'utf8', (err, data) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve({ name: fileName, content: data });\n            });\n        });\n    }\n\n    // A method to write data to a file\n    public writeFile(fileData: FileData): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const filePath = path.join(this.directory, fileData.name);\n            fs.writeFile(filePath, fileData.content, 'utf8', (err) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    // A method to delete a file\n    public deleteFile(fileName: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const filePath = path.join(this.directory, fileName);\n            fs.unlink(filePath, (err) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    // A method to list all files in the directory\n    public listFiles(): Promise<string[]> {\n        return new Promise((resolve, reject) => {\n            fs.readdir(this.directory, (err, files) => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve(files);\n            });\n        });\n    }\n}\n\n// Example usage\nconst fileManager = new FileManager('/tmp');\n\n(async () => {\n    try {\n        await fileManager.writeFile({ name: 'test.txt', content: 'Hello, world!' });\n        const fileData = await fileManager.readFile('test.txt');\n        console.log(fileData);\n        const fileList = await fileManager.listFiles();\n        console.log(fileList);\n", "suffix": "        await fileManager.deleteFile('test.txt');\n    } catch (error) {\n        console.error('Error:', error);\n    }\n})();\n", "golden_completion": "        await fileManager.writeFile({ name: 'example.txt', content: 'Example content' });\n        const exampleData = await fileManager.readFile('example.txt');\n        console.log(exampleData);\n", "LLM_justification": "This example tests the ability of an LLM to recognize and complete a clear pattern in the context of asynchronous file operations using promises in TypeScript. The prefix establishes a pattern of asynchronous methods (readFile, writeFile, deleteFile, listFiles) and their usage. The completion should follow the established pattern by adding another file operation sequence (write and read) before the suffix continues with the delete operation. This tests the LLM's understanding of async patterns, promise handling, and file management in a realistic scenario.", "assertions": "import * as fs from 'fs';\nimport * as path from 'path';\nimport { strict as assert } from 'assert';\n\n(async () => {\n    const directory = '/tmp';\n    const fileManager = new FileManager(directory);\n    const exampleFilePath = path.join(directory, 'example.txt');\n\n    try {\n        // Write and read example file\n        await fileManager.writeFile({ name: 'example.txt', content: 'Example content' });\n        const exampleData = await fileManager.readFile('example.txt');\n        assert.deepEqual(exampleData, { name: 'example.txt', content: 'Example content' });\n\n        // Cleanup\n        await fileManager.deleteFile('example.txt');\n    } catch (error) {\n        console.error('Error in assertions:', error);\n    } finally {\n        // Ensure file is deleted\n        if (fs.existsSync(exampleFilePath)) {\n            fs.unlinkSync(exampleFilePath);\n        }\n    }\n})();\n", "DeepSeek-R1": "        const newFileList = await fileManager.listFiles();\n        console.log(newFileList);"}
{"id": "25", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n// Utility function to calculate the mean of an array of numbers\nfunction calculateMean(arr: number[]): number {\n    const sum = arr.reduce((acc, val) => acc + val, 0);\n    return sum / arr.length;\n}\n\n// Utility function to calculate the median of an array of numbers\nfunction calculateMedian(arr: number[]): number {\n    const sortedArr = [...arr].sort((a, b) => a - b);\n    const mid = Math.floor(sortedArr.length / 2);\n\n    if (sortedArr.length % 2 === 0) {\n        return (sortedArr[mid - 1] + sortedArr[mid]) / 2;\n    } else {\n        return sortedArr[mid];\n    }\n}\n\n// Utility function to calculate the mode of an array of numbers\nfunction calculateMode(arr: number[]): number[] {\n    const frequencyMap: { [key: number]: number } = {};\n    arr.forEach(num => {\n        frequencyMap[num] = (frequencyMap[num] || 0) + 1;\n    });\n\n    const maxFrequency = Math.max(...Object.values(frequencyMap));\n    return Object.keys(frequencyMap)\n        .filter(num => frequencyMap[+num] === maxFrequency)\n        .map(Number);\n}\n\n// Test data\nconst data = [1, 2, 2, 3, 4];\n\n// Assertions\nassert.strictEqual(calculateMean(data), 2.4);\nassert.strictEqual(calculateMedian(data), 2);\nassert.deepStrictEqual(calculateMode(data), [2]);\n\n// Utility function to calculate the range of an array of numbers\n", "suffix": "// Further assertions\nassert.strictEqual(calculateRange(data), 3);\n\n// Cleanup code (if any) would go here", "golden_completion": "function calculateRange(arr: number[]): number {\n    const min = Math.min(...arr);\n    const max = Math.max(...arr);\n    return max - min;\n}\n\n// Test data\nconst rangeData = [1, 2, 2, 3, 4];\n\n// Assertions\nassert.strictEqual(calculateRange(rangeData), 3);", "LLM_justification": "This is a good test case because it establishes a clear pattern of utility functions for common statistical calculations (mean, median, mode). The pattern is recognizable and involves array manipulations and mathematical operations. The golden completion follows this pattern by implementing the calculation of the range. The assertions verify the correctness of the implementation, ensuring it adheres to the established pattern. This scenario tests the LLM's ability to recognize and continue the pattern of statistical computation functions.", "assertions": "assert.strictEqual(calculateRange(data), 3);\nconst newTestData = [5, 10, 15, 20, 25];\nassert.strictEqual(calculateRange(newTestData), 20);\nconst edgeCaseData = [5];\nassert.strictEqual(calculateRange(edgeCaseData), 0);", "DeepSeek-R1": "function calculateRange(arr: number[]): number {\n    const max = Math.max(...arr);\n    const min = Math.min(...arr);\n    return max - min;\n}"}
{"id": "26", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import { assert } from 'chai';\n\n// A utility function to generate random IDs\nfunction generateId(): string {\n    return Math.random().toString(36).substr(2, 9);\n}\n\n// A generic interface representing an entity with an ID\ninterface Entity {\n    id: string;\n}\n\n// A class representing a user\nclass User implements Entity {\n    constructor(public id: string, public name: string, public email: string) {}\n}\n\n// A class representing a product\nclass Product implements Entity {\n    constructor(public id: string, public name: string, public price: number) {}\n}\n\n// A registry to store entities\nclass Registry<T extends Entity> {\n    private items: Map<string, T> = new Map();\n\n    // Add an item to the registry\n    add(item: T): void {\n        this.items.set(item.id, item);\n    }\n\n    // Remove an item from the registry by ID\n    remove(id: string): void {\n        this.items.delete(id);\n    }\n\n    // Get an item from the registry by ID\n    get(id: string): T | undefined {\n        return this.items.get(id);\n    }\n\n    // Get all items from the registry\n    getAll(): T[] {\n        return Array.from(this.items.values());\n    }\n}\n\n// Create a user registry\nconst userRegistry = new Registry<User>();\n// Add users to the registry\nuserRegistry.add(new User(generateId(), 'Alice', 'alice@example.com'));\nuserRegistry.add(new User(generateId(), 'Bob', 'bob@example.com'));\nuserRegistry.add(new User(generateId(), 'Charlie', 'charlie@example.com'));\n\n// Create a product registry\nconst productRegistry = new Registry<Product>();\n// Add products to the registry\nproductRegistry.add(new Product(generateId(), 'Laptop', 999.99));\nproductRegistry.add(new Product(generateId(), 'Smartphone', 499.99));\nproductRegistry.add(new Product(generateId(), 'Tablet', 299.99));\n\n// Function to find users by name\nfunction findUserByName(name: string): User | undefined {\n    return userRegistry.getAll().find(user => user.name === name);\n}\n\n// Function to find products by name\nfunction findProductByName(name: string): Product | undefined {\n    return productRegistry.getAll().find(product => product.name === name);\n}\n\n// Function to update a user's email\nfunction updateUserEmail(id: string, newEmail: string): void {\n    const user = userRegistry.get(id);\n    if (user) {\n        user.email = newEmail;\n    }\n}\n\n// Function to update a product's price\nfunction updateProductPrice(id: string, newPrice: number): void {\n    const product = productRegistry.get(id);\n    if (product) {\n        product.price = newPrice;\n    }\n}\n", "suffix": "\n// Remove a user from the registry\nfunction removeUserById(id: string): void {\n    userRegistry.remove(id);\n}\n\n// Remove a product from the registry\nfunction removeProductById(id: string): void {\n    productRegistry.remove(id);\n}\n\n// Test cases\nconst testUserId = generateId();\nconst testUser = new User(testUserId, 'Test User', 'test@example.com');\nuserRegistry.add(testUser);\nassert.equal(userRegistry.get(testUserId)?.name, 'Test User');\nassert.equal(userRegistry.get(testUserId)?.email, 'test@example.com');\n\nconst testProductId = generateId();\nconst testProduct = new Product(testProductId, 'Test Product', 123.45);\nproductRegistry.add(testProduct);\nassert.equal(productRegistry.get(testProductId)?.name, 'Test Product');\nassert.equal(productRegistry.get(testProductId)?.price, 123.45);\n\n// Cleanup\nuserRegistry.remove(testUserId);\nproductRegistry.remove(testProductId);\n", "golden_completion": "\n// Function to remove an entity by ID\nfunction removeEntityById<T extends Entity>(registry: Registry<T>, id: string): void {\n    registry.remove(id);\n}\n", "LLM_justification": "This test case demonstrates the use of TypeScript generics and higher-order functions within the context of managing a registry of entities. The prefix establishes a clear pattern of creating registries for different types of entities, adding and retrieving them. The golden completion introduces a higher-order function that generalizes the removal of an entity by ID from a registry, following the established pattern. The suffix continues to use this pattern for specific types of entities. This scenario tests the model's ability to recognize and complete a pattern involving generics and higher-order functions.", "assertions": "const testUserId = generateId();\nconst testUser = new User(testUserId, 'Test User', 'test@example.com');\nuserRegistry.add(testUser);\nremoveEntityById(userRegistry, testUserId);\nassert.isUndefined(userRegistry.get(testUserId));\n\nconst testProductId = generateId();\nconst testProduct = new Product(testProductId, 'Test Product', 123.45);\nproductRegistry.add(testProduct);\nremoveEntityById(productRegistry, testProductId);\nassert.isUndefined(productRegistry.get(testProductId));\n", "DeepSeek-R1": "function removeUserById(id: string): void {\n    userRegistry.remove(id);\n}\n\nfunction removeProductById(id: string): void {\n    productRegistry.remove(id);\n}"}
{"id": "27", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\ninterface DataPoint {\n  x: number;\n  y: number;\n}\n\ninterface Statistics {\n  mean: number;\n  variance: number;\n}\n\nclass DataAnalysis {\n  private data: DataPoint[];\n\n  constructor(data: DataPoint[]) {\n    this.data = data;\n  }\n\n  public calculateMean(): number {\n    const sum = this.data.reduce((acc, point) => acc + point.y, 0);\n    return sum / this.data.length;\n  }\n\n  public calculateVariance(mean: number): number {\n    const sum = this.data.reduce((acc, point) => acc + Math.pow(point.y - mean, 2), 0);\n    return sum / (this.data.length - 1);\n  }\n\n  public getStatistics(): Statistics {\n    const mean = this.calculateMean();\n    const variance = this.calculateVariance(mean);\n    return { mean, variance };\n  }\n}\n\nconst data: DataPoint[] = [\n  { x: 1, y: 2 },\n  { x: 2, y: 4 },\n  { x: 3, y: 4 },\n  { x: 4, y: 5 },\n  { x: 5, y: 7 }\n];\n\nconst analysis = new DataAnalysis(data);\nconst stats = analysis.getStatistics();\nassert.strictEqual(stats.mean, 4.4);\nassert.strictEqual(stats.variance, 3.3);\n\n// Calculate median function\nclass DataAnalysis {\n  private data: DataPoint[];\n\n  constructor(data: DataPoint[]) {\n    this.data = data;\n  }\n\n  public calculateMean(): number {\n    const sum = this.data.reduce((acc, point) => acc + point.y, 0);\n    return sum / this.data.length;\n  }\n\n  public calculateVariance(mean: number): number {\n    const sum = this.data.reduce((acc, point) => acc + Math.pow(point.y - mean, 2), 0);\n    return sum / (this.data.length - 1);\n  }\n\n  public getStatistics(): Statistics {\n    const mean = this.calculateMean();\n    const variance = this.calculateVariance(mean);\n    return { mean, variance };\n  }\n\n", "suffix": "\n}\n\nconst median = analysis.calculateMedian();\nassert.strictEqual(median, 4);\n", "golden_completion": "public calculateMedian(): number {\n  const sorted = this.data.map(point => point.y).sort((a, b) => a - b);\n  const mid = Math.floor(sorted.length / 2);\n  return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;\n}\n", "LLM_justification": "This test case establishes a clear pattern within the DataAnalysis class, specifically in the implementation of statistical methods (calculateMean, calculateVariance, getStatistics). The golden_completion requires the model to continue this pattern by implementing the calculateMedian method in a similar style. The assertions ensure that the calculateMedian method correctly computes the median of the dataset, verifying both the functional correctness and adherence to the established pattern.", "assertions": "assert.strictEqual(analysis.calculateMedian(), 4);", "DeepSeek-R1": "  public calculateMedian(): number {\n    const sortedY = this.data.map(point => point.y).sort((a, b) => a - b);\n    const mid = Math.floor(sortedY.length / 2);\n    return sortedY.length % 2 === 0 ? (sortedY[mid - 1] + sortedY[mid]) / 2 : sortedY[mid];\n  }"}
{"id": "28", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n// Helper function to generate a random integer between min and max\nfunction getRandomInt(min: number, max: number): number {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n// Class representing a two-dimensional point\nclass Point {\n  constructor(public x: number, public y: number) {}\n\n  // Method to calculate the distance to another point\n  distanceTo(other: Point): number {\n    return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n  }\n}\n\n// Class representing a rectangle\nclass Rectangle {\n  constructor(public topLeft: Point, public bottomRight: Point) {}\n\n  // Method to calculate the area of the rectangle\n  area(): number {\n    const width = Math.abs(this.bottomRight.x - this.topLeft.x);\n    const height = Math.abs(this.bottomRight.y - this.topLeft.y);\n    return width * height;\n  }\n\n  // Method to calculate the perimeter of the rectangle\n  perimeter(): number {\n    const width = Math.abs(this.bottomRight.x - this.topLeft.x);\n    const height = Math.abs(this.bottomRight.y - this.topLeft.y);\n    return 2 * (width + height);\n  }\n}\n\n// Function to generate a random point within given bounds\nfunction generateRandomPoint(xMin: number, xMax: number, yMin: number, yMax: number): Point {\n  const x = getRandomInt(xMin, xMax);\n  const y = getRandomInt(yMin, yMax);\n  return new Point(x, y);\n}\n\n// Function to generate a random rectangle within given bounds\nfunction generateRandomRectangle(xMin: number, xMax: number, yMin: number, yMax: number): Rectangle {\n  const point1 = generateRandomPoint(xMin, xMax, yMin, yMax);\n  const point2 = generateRandomPoint(xMin, xMax, yMin, yMax);\n  return new Rectangle(point1, point2);\n}\n\n// Array to hold generated rectangles\nconst rectangles: Rectangle[] = [];\n\n// Generate 5 random rectangles and add them to the array\nfor (let i = 0; i < 5; i++) {\n  rectangles.push(generateRandomRectangle(0, 100, 0, 100));\n}\n\n// Calculate the total area of all generated rectangles\nlet totalArea = 0;\nrectangles.forEach(rect => {\n  totalArea += rect.area();\n});\n\n// Calculate the total perimeter of all generated rectangles\nlet totalPerimeter = 0;\nrectangles.forEach(rect => {\n  totalPerimeter += rect.perimeter();\n});\n\n// Log the total area and perimeter\nconsole.log(`Total area: ${totalArea}`);\nconsole.log(`Total perimeter: ${totalPerimeter}`);\n\n// Assertions\nassert(totalArea > 0, 'Total area should be greater than 0');\nassert(totalPerimeter > 0, 'Total perimeter should be greater than 0');\n\n// Function to find the rectangle with the largest area\nfunction findLargestRectangleByArea(rects: Rectangle[]): Rectangle | null {\n  if (rects.length === 0) return null;\n  let largestRect = rects[0];\n  let maxArea = largestRect.area();\n  rects.forEach(rect => {\n    const area = rect.area();\n    if (area > maxArea) {\n      largestRect = rect;\n      maxArea = area;\n    }\n  });\n  return largestRect;\n}\n\n// Function to find the rectangle with the largest perimeter\nfunction findLargestRectangleByPerimeter(rects: Rectangle[]): Rectangle | null {\n  if (rects.length === 0) return null;\n  let largestRect = rects[0];\n  let maxPerimeter = largestRect.perimeter();\n  rects.forEach(rect => {\n    const perimeter = rect.perimeter();\n    if (perimeter > maxPerimeter) {\n      largestRect = rect;\n      maxPerimeter = perimeter;\n    }\n  });\n  return largestRect;\n}\n\n// Example usage\nconst largestByArea = findLargestRectangleByArea(rectangles);\n", "suffix": "console.log(`Largest rectangle by perimeter: ${largestByPerimeter?.perimeter()}`);\n\n// Clean up resources if necessary (not needed in this example)\n\n", "golden_completion": "const largestByPerimeter = findLargestRectangleByPerimeter(rectangles);\nconsole.log(`Largest rectangle by area: ${largestByArea?.area()}`);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete an established pattern involving class methods and array operations in TypeScript. The scenario involves a clear pattern of creating and manipulating geometric shapes (rectangles) and calculating properties such as area and perimeter. The golden completion requires the model to correctly identify the method to find the largest rectangle by perimeter and continue the pattern of logging results, matching the established code structure and conventions.", "assertions": "assert(largestByArea !== null, 'There should be a rectangle with the largest area');\nassert(largestByPerimeter !== null, 'There should be a rectangle with the largest perimeter');\nassert(largestByArea!.area() >= 0, 'Largest rectangle by area should have non-negative area');\nassert(largestByPerimeter!.perimeter() >= 0, 'Largest rectangle by perimeter should have non-negative perimeter');\n", "DeepSeek-R1": "const largestByPerimeter = findLargestRectangleByPerimeter(rectangles);\nconsole.log(`Largest rectangle by area: ${largestByArea?.area()}`);\nconsole.log(`Largest rectangle by perimeter: ${largestByPerimeter?.perimeter()}`);"}
{"id": "29", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import assert from 'assert';\n\n// Define a generic type Result which can contain a value or an error\ninterface Result<T> {\n    value?: T;\n    error?: string;\n}\n\n// A function to simulate a network request which returns a promise of Result\nfunction fetchData(url: string): Promise<Result<string>> {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            if (url === 'https://valid.url') {\n                resolve({ value: 'Data from ' + url });\n            } else {\n                resolve({ error: 'Network error' });\n            }\n        }, 1000);\n    });\n}\n\n// A function to process the result of the network request\nfunction processResult(result: Result<string>): string {\n    if (result.value) {\n        return 'Processed: ' + result.value;\n    } else {\n        return 'Error: ' + result.error;\n    }\n}\n\n// Main function to use fetchData and processResult\nasync function main() {\n    const url = 'https://valid.url';\n    const result = await fetchData(url);\n    const processedResult = processResult(result);\n    console.log(processedResult);\n\n    // Assertions to verify correctness\n    assert.strictEqual(result.value, 'Data from ' + url);\n    assert.strictEqual(processedResult, 'Processed: Data from ' + url);\n}\n\n// Execute main function\nmain().then(() => console.log('Done')).catch((err) => console.error(err));\n\n// Another example with an invalid URL\nasync function testErrorHandling() {\n    const url = 'https://invalid.url';\n    const result = await fetchData(url);\n    const processedResult = processResult(result);\n    console.log(processedResult);\n\n    // Assertions to verify correctness\n    assert.strictEqual(result.error, 'Network error');\n    assert.strictEqual(processedResult, 'Error: Network error');\n}\n\ntestErrorHandling().then(() => console.log('Error handling done')).catch((err) => console.error(err));", "suffix": "async function additionalTest() {\n    const url = 'https://another.valid.url';\n    const result = await fetchData(url);\n    const processedResult = processResult(result);\n    console.log(processedResult);\n\n    // Assertions to verify correctness\n    assert.strictEqual(result.value, 'Data from ' + url);\n    assert.strictEqual(processedResult, 'Processed: Data from ' + url);\n}\n\nadditionalTest().then(() => console.log('Additional test done')).catch((err) => console.error(err));", "golden_completion": "async function testAnotherErrorHandling() {\n    const url = 'https://another.invalid.url';\n    const result = await fetchData(url);\n    const processedResult = processResult(result);\n    console.log(processedResult);\n\n    // Assertions to verify correctness\n    assert.strictEqual(result.error, 'Network error');\n    assert.strictEqual(processedResult, 'Error: Network error');\n}\n\ntestAnotherErrorHandling().then(() => console.log('Another error handling done')).catch((err) => console.error(err));", "LLM_justification": "This test case is a good test of pattern matching in TypeScript because it establishes a clear, repetitive pattern of handling network requests using async functions, processing the results, and verifying the outcomes with assertions. The pattern is evident through multiple examples in both the prefix and suffix sections, and the golden_completion must follow the same pattern to be correct. This ensures that the LLM needs to recognize and complete the established pattern accurately.", "assertions": "assert.strictEqual((await fetchData('https://another.invalid.url')).error, 'Network error');\nassert.strictEqual(processResult(await fetchData('https://another.invalid.url')), 'Error: Network error');", "DeepSeek-R1": "async function additionalTest() {\n    const url = 'https://another.valid.url';\n    const result = await fetchData(url);\n    const processedResult = processResult(result);\n    console.log(processedResult);\n\n    // Assertions to verify correctness\n    assert.strictEqual(result.value, 'Data from ' + url);\n    assert.strictEqual(processedResult, 'Processed: Data from ' + url);\n}\n\nadditionalTest().then(() => console.log('Additional test done')).catch((err) => console.error(err));"}
{"id": "30", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as fs from 'fs';\n\n// Helper function to read a file\nfunction readFile(filePath: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Helper function to write to a file\nfunction writeFile(filePath: string, content: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(filePath, content, 'utf8', (err) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n        });\n    });\n}\n\n// Function to process file content\nasync function processFileContent(filePath: string, transformer: (content: string) => string): Promise<void> {\n    try {\n        const content = await readFile(filePath);\n        const transformedContent = transformer(content);\n        await writeFile(filePath, transformedContent);\n    } catch (error) {\n        console.error('Error processing file:', error);\n    }\n}\n\n// Transformer function to convert text to uppercase\nfunction toUpperCaseTransformer(content: string): string {\n    return content.toUpperCase();\n}\n\n// Transformer function to replace spaces with hyphens\nfunction replaceSpacesTransformer(content: string): string {\n    return content.replace(/\\s+/g, '-');\n}\n\n// Example usage\nasync function main() {\n    const filePath = './example.txt';\n    await processFileContent(filePath, toUpperCaseTransformer);\n    await processFileContent(filePath, replaceSpacesTransformer);\n", "suffix": "    await processFileContent(filePath, (content) => content.split('').reverse().join(''));\n}\n\nmain().catch(console.error);", "golden_completion": "    await processFileContent(filePath, (content) => content.toLowerCase());\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a pattern of using higher-order functions to transform file content. The prefix establishes a clear pattern with multiple examples of transformer functions applied to the content. The golden completion follows this pattern by adding another transformer function that converts the content to lowercase, maintaining consistency with the established pattern of content transformation.", "assertions": "import * as assert from 'assert';\nimport * as fs from 'fs';\n\n// Mocking fs.readFile and fs.writeFile\nconst originalReadFile = fs.readFile;\nconst originalWriteFile = fs.writeFile;\nlet fileContent = 'Hello World';\nfs.readFile = (filePath: string, encoding: string, callback: (err: NodeJS.ErrnoException | null, data: string) => void) => {\n    callback(null, fileContent);\n};\nfs.writeFile = (filePath: string, content: string, encoding: string, callback: (err: NodeJS.ErrnoException | null) => void) => {\n    fileContent = content;\n    callback(null);\n};\n\n// Run the main function\nmain().then(() => {\n    // Assertions\n    assert.strictEqual(fileContent, 'OLLEH-DLROW');\n\n    // Restore original functions\n    fs.readFile = originalReadFile;\n    fs.writeFile = originalWriteFile;\n}).catch(console.error);", "DeepSeek-R1": "await processFileContent(filePath, (content) => content.split('').reverse().join(''));"}
{"id": "31", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as crypto from 'crypto';\n\n// Utility function to generate a random string\nfunction generateRandomString(length: number): string {\n    return crypto.randomBytes(length).toString('hex');\n}\n\n// Interface for User\ninterface User {\n    id: string;\n    username: string;\n    password: string;\n    email: string;\n}\n\n// Function to create a user\nfunction createUser(username: string, password: string, email: string): User {\n    return {\n        id: generateRandomString(16),\n        username,\n        password: hashPassword(password),\n        email\n    };\n}\n\n// Function to hash passwords\nfunction hashPassword(password: string): string {\n    const salt = generateRandomString(8);\n    const hash = crypto.createHmac('sha256', salt).update(password).digest('hex');\n    return `${salt}$${hash}`;\n}\n\n// Function to verify passwords\nfunction verifyPassword(password: string, hashedPassword: string): boolean {\n    const [salt, originalHash] = hashedPassword.split('$');\n    const hash = crypto.createHmac('sha256', salt).update(password).digest('hex');\n    return hash === originalHash;\n}\n\n// Function to authenticate a user\nfunction authenticateUser(users: User[], username: string, password: string): boolean {\n    const user = users.find(u => u.username === username);\n    if (!user) return false;\n    return verifyPassword(password, user.password);\n}\n\n// Sample users array\nconst users: User[] = [\n    createUser('john_doe', 'password123', 'john@example.com'),\n    createUser('jane_doe', 'securePass456', 'jane@example.com')\n];\n\n// Helper function to log in a user\nfunction loginUser(username: string, password: string): string {\n    if (authenticateUser(users, username, password)) {\n        return 'Login successful';\n    }\n    return 'Login failed';\n}\n\n// Helper function to register a user\nfunction registerUser(username: string, password: string, email: string): string {\n    if (users.find(u => u.username === username || u.email === email)) {\n        return 'User already exists';\n    }\n    const newUser = createUser(username, password, email);\n    users.push(newUser);\n    return 'Registration successful';\n}\n\n// Example usage\nconst registrationStatus = registerUser('alice', 'alicePass789', 'alice@example.com');\nconsole.log(registrationStatus);", "suffix": "\nconst loginStatus = loginUser('alice', 'alicePass789');\nconsole.log(loginStatus);\n\n// Cleanup\nusers.pop();\n", "golden_completion": "\nconst loginStatus = loginUser('alice', 'alicePass789');\nconsole.log(loginStatus);\n\n// Assertions\nimport { strict as assert } from 'assert';\nassert.strictEqual(registrationStatus, 'Registration successful', 'User should be registered successfully');\nassert.strictEqual(loginStatus, 'Login successful', 'User should be able to log in successfully');\n\n// Cleanup\nusers.pop();\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving user registration and authentication in a security context. The prefix establishes functions for creating users, hashing and verifying passwords, and authenticating users. The completion must follow this established pattern by adding assertions to verify the correct functionality of the user registration and login processes. The example includes realistic scenarios and uses TypeScript-specific features like interfaces and type annotations.", "assertions": "import { strict as assert } from 'assert';\nassert.strictEqual(registrationStatus, 'Registration successful', 'User should be registered successfully');\nassert.strictEqual(loginStatus, 'Login successful', 'User should be able to log in successfully');", "DeepSeek-R1": ";"}
{"id": "32", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse<T> {\n\tdata: T;\n\terrors?: string[];\n}\n\ninterface User {\n\tid: number;\n\tname: string;\n\temail: string;\n}\n\ninterface Post {\n\tid: number;\n\ttitle: string;\n\tcontent: string;\n\tuserId: number;\n}\n\n// Helper function to handle API responses\nfunction handleApiResponse<T>(response: ApiResponse<T>): T {\n\tif (response.errors) {\n\t\tthrow new Error(response.errors.join(', '));\n\t}\n\treturn response.data;\n}\n\n// Fetch user by ID\nasync function fetchUserById(userId: number): Promise<User> {\n\ttry {\n\t\tconst response = await axios.get<ApiResponse<User>>(`/api/users/${userId}`);\n\t\treturn handleApiResponse(response.data);\n\t} catch (error) {\n\t\tconsole.error('Failed to fetch user:', error);\n\t\tthrow error;\n\t}\n}\n\n// Fetch posts by user ID\nasync function fetchPostsByUserId(userId: number): Promise<Post[]> {\n\ttry {\n\t\tconst response = await axios.get<ApiResponse<Post[]>>(`/api/users/${userId}/posts`);\n\t\treturn handleApiResponse(response.data);\n\t} catch (error) {\n\t\tconsole.error('Failed to fetch posts:', error);\n\t\tthrow error;\n\t}\n}\n\n// Example usage and assertions\n(async () => {\n\tconst userId = 1;\n\tconst user = await fetchUserById(userId);\n\tconsole.log('User:', user);\n", "suffix": "\n})();\n", "golden_completion": "\tconst posts = await fetchPostsByUserId(userId);\n\tconsole.log('Posts:', posts);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete an asynchronous pattern involving API calls and error handling. The prefix establishes a clear pattern with two similar functions for fetching user data and user posts, including error handling and response processing. The golden completion follows this established pattern by adding the function call to fetch posts and logging the results, ensuring consistency and proper error handling. The assertions verify that the functions work as intended, making this a realistic and practical scenario for pattern matching in TypeScript.", "assertions": "import { strict as assert } from 'assert';\n\n(async () => {\n\tconst userId = 1;\n\tconst user = await fetchUserById(userId);\n\tassert.equal(user.id, userId, 'User ID should match the requested ID');\n\tassert.equal(typeof user.name, 'string', 'User name should be a string');\n\tassert.equal(typeof user.email, 'string', 'User email should be a string');\n\n\tconst posts = await fetchPostsByUserId(userId);\n\tassert(Array.isArray(posts), 'Posts should be an array');\n\tif (posts.length > 0) {\n\t\tassert.equal(posts[0].userId, userId, 'Each post should belong to the user');\n\t}\n\tconsole.log('All assertions passed.');\n})();", "DeepSeek-R1": "\tconst posts = await fetchPostsByUserId(user.id);\n\tconsole.log('Posts:', posts);\n\tposts.forEach(post => {\n\t\tconsole.assert(post.userId === user.id, 'Post user ID mismatch');\n\t});"}
{"id": "33", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\n// Define a generic type for API response\ninterface ApiResponse<T> {\n    status: string;\n    data: T;\n}\n\n// A higher-order function to handle API calls\nfunction apiCall<T>(url: string, method: 'GET' | 'POST', data?: any): Promise<ApiResponse<T>> {\n    return axios({ url, method, data })\n        .then(response => ({ status: 'success', data: response.data }))\n        .catch(error => ({ status: 'error', data: error.message }));\n}\n\n// Function to get user data\nfunction getUserData(userId: string): Promise<ApiResponse<User>> {\n    return apiCall<User>(`/api/users/${userId}`, 'GET');\n}\n\n// Function to create a new user\nfunction createUser(data: Partial<User>): Promise<ApiResponse<User>> {\n    return apiCall<User>('/api/users', 'POST', data);\n}\n\n// User interface\ninterface User {\n    id: string;\n    name: string;\n    email: string;\n}\n\n// Function to update user data\nfunction updateUser(userId: string, data: Partial<User>): Promise<ApiResponse<User>> {\n    return apiCall<User>(`/api/users/${userId}`, 'POST', data);\n}\n\n// Function to delete a user\nfunction deleteUser(userId: string): Promise<ApiResponse<null>> {\n    return apiCall<null>(`/api/users/${userId}`, 'DELETE');\n}\n\n// Example usage of the functions\nconst userId = '123';\n\ngetUserData(userId).then(response => {\n    console.log('User Data:', response);\n});\n\ncreateUser({ name: 'John Doe', email: 'john@example.com' }).then(response => {\n    console.log('New User:', response);\n});\n\n// Additional function implementations following the same pattern\n", "suffix": "deleteUser(userId).then(response => {\n    console.log('Delete User:', response);\n});\n\n", "golden_completion": "updateUser(userId, { name: 'Jane Doe' }).then(response => {\n    console.log('Update User:', response);\n});\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a higher-order function pattern in the context of API calls. The pattern involves a higher-order function 'apiCall' that handles API requests and returns a promise with a structured response. The completion should follow this pattern to implement an update user function correctly. The assertions will verify the pattern adherence and functionality.", "assertions": "import assert from 'assert';\n\n(async () => {\n    const mockResponse = { status: 'success', data: { id: '123', name: 'Jane Doe', email: 'jane@example.com' } };\n    const mockError = { status: 'error', data: 'User not found' };\n\n    // Mock axios to control the responses\n    jest.mock('axios');\n    const axios = require('axios');\n    axios.mockImplementation(({ url, method, data }) => {\n        if (url.includes('/api/users') && method === 'POST') {\n            return Promise.resolve({ data: mockResponse.data });\n        } else if (url.includes('/api/users') && method === 'GET') {\n            return Promise.resolve({ data: mockResponse.data });\n        } else if (url.includes('/api/users') && method === 'DELETE') {\n            return Promise.resolve({ data: null });\n        } else {\n            return Promise.reject(new Error(mockError.data));\n        }\n    });\n\n    // Verify getUserData\n    const userData = await getUserData('123');\n    assert.strictEqual(userData.status, 'success');\n    assert.strictEqual(userData.data.name, 'Jane Doe');\n\n    // Verify createUser\n    const newUser = await createUser({ name: 'John Doe', email: 'john@example.com' });\n    assert.strictEqual(newUser.status, 'success');\n    assert.strictEqual(newUser.data.name, 'John Doe');\n\n    // Verify updateUser\n    const updatedUser = await updateUser('123', { name: 'Jane Doe' });\n    assert.strictEqual(updatedUser.status, 'success');\n    assert.strictEqual(updatedUser.data.name, 'Jane Doe');\n\n    // Verify deleteUser\n    const deletedUser = await deleteUser('123');\n    assert.strictEqual(deletedUser.status, 'success');\n})();\n", "DeepSeek-R1": "updateUser(userId, { name: 'Jane Doe' }).then(response => {\n    console.log('Updated User:', response);\n});"}
{"id": "34", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse<T> {\n    data: T;\n    status: number;\n}\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\nasync function fetchData<T>(url: string): Promise<ApiResponse<T>> {\n    try {\n        const response = await axios.get<T>(url);\n        return {\n            data: response.data,\n            status: response.status\n        };\n    } catch (error) {\n        throw new Error(`Failed to fetch data: ${error.message}`);\n    }\n}\n\nasync function fetchUser(userId: number): Promise<User> {\n    const url = `https://api.example.com/users/${userId}`;\n    const response = await fetchData<User>(url);\n    return response.data;\n}\n\nasync function fetchPost(postId: number): Promise<{ id: number; title: string; content: string }> {\n    const url = `https://api.example.com/posts/${postId}`;\n    const response = await fetchData<{ id: number; title: string; content: string }>(url);\n    return response.data;\n}\n\n// More functions could be here...\n\n", "suffix": "\n\nasync function main() {\n    try {\n        const user = await fetchUser(1);\n        console.log(user);\n\n        const post = await fetchPost(1);\n        console.log(post);\n    } catch (error) {\n        console.error(error);\n    }\n}\n\nmain();", "golden_completion": "async function fetchComments(postId: number): Promise<{ id: number; postId: number; content: string }[]> {\n    const url = `https://api.example.com/posts/${postId}/comments`;\n    const response = await fetchData<{ id: number; postId: number; content: string }[]>(url);\n    return response.data;\n}\n", "LLM_justification": "This test case is a good example for pattern matching in TypeScript as it involves async patterns and type definitions with generics in a network protocol context. The prefix establishes a clear pattern of using a generic async function to fetch data from an API and specific functions to fetch different types of data (User, Post). The golden completion continues this pattern by adding another function to fetch comments. The suffix uses the previously defined functions, making it clear that the pattern should be continued similarly. The scenario tests the LLM's ability to recognize and extend the established pattern correctly.", "assertions": "import { strict as assert } from 'assert';\n\nasync function testFetchComments() {\n    // Mocking axios.get\n    const axiosGet = axios.get as jest.Mock;\n    axiosGet.mockResolvedValue({\n        data: [\n            { id: 1, postId: 1, content: 'Great post!' },\n            { id: 2, postId: 1, content: 'Thanks for sharing!' }\n        ],\n        status: 200\n    });\n\n    const comments = await fetchComments(1);\n    assert.strictEqual(comments.length, 2);\n    assert.deepStrictEqual(comments[0], { id: 1, postId: 1, content: 'Great post!' });\n    assert.deepStrictEqual(comments[1], { id: 2, postId: 1, content: 'Thanks for sharing!' });\n}\n\n// Run the test\nawait testFetchComments();\nconsole.log('All assertions passed.');\n", "DeepSeek-R1": "async function fetchComments(postId: number): Promise<{ id: number; postId: number; text: string }[]> {\n    const url = `https://api.example.com/comments/${postId}`;\n    const response = await fetchData<{ id: number; postId: number; text: string }[]>(url);\n    return response.data;\n}"}
{"id": "35", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\n// Define a generic function to make API calls\nasync function fetchData<T>(url: string): Promise<T> {\n  try {\n    const response = await axios.get<T>(url);\n    return response.data;\n  } catch (error) {\n    throw new Error('Failed to fetch data');\n  }\n}\n\n// Define a generic function to post data to an API\nasync function postData<T>(url: string, data: T): Promise<void> {\n  try {\n    await axios.post(url, data);\n  } catch (error) {\n    throw new Error('Failed to post data');\n  }\n}\n\n// Define a type for user data\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Define a function to fetch user data\nasync function fetchUser(url: string): Promise<User> {\n  return fetchData<User>(url);\n}\n\n// Define a function to post user data\nasync function submitUser(url: string, user: User): Promise<void> {\n  return postData<User>(url, user);\n}\n\n// Test data\nconst testUser: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\nconst apiUrl = 'https://api.example.com/user';\n\n// Fetch user data\nfetchUser(apiUrl).then((user) => {\n  console.log('Fetched user:', user);\n}).catch((error) => {\n  console.error(error);\n});\n\n// Post user data\nsubmitUser(apiUrl, testUser).then(() => {\n  console.log('User data submitted successfully');\n}).catch((error) => {\n  console.error(error);\n});\n", "suffix": "submitUser(apiUrl, { id: 2, name: 'Jane Doe', email: 'jane.doe@example.com' }).then(() => {\n  console.log('Another user data submitted successfully');\n}).catch((error) => {\n  console.error(error);\n});\n", "golden_completion": "fetchUser(apiUrl).then((user) => {\n  console.log('Fetched another user:', user);\n}).catch((error) => {\n  console.error(error);\n});\n", "LLM_justification": "This test case involves async patterns and type definitions/generics, which are common in TypeScript when dealing with network protocols such as making API calls. The pattern of defining generic functions for fetching and posting data is established in the prefix. The golden completion continues this pattern by fetching user data, while the suffix demonstrates posting user data. This distinction tests the LLM's ability to recognize and complete the established pattern of using generic async functions for API interactions.", "assertions": "import { strict as assert } from 'assert';\n\n(async () => {\n  const mockUser: User = { id: 3, name: 'Test User', email: 'test.user@example.com' };\n  const mockApiUrl = 'https://mockapi.example.com/user';\n\n  // Mocking axios.get and axios.post\n  axios.get = async <T>(url: string): Promise<{ data: T }> => ({ data: mockUser as any });\n  axios.post = async (url: string, data: any): Promise<void> => { /* no-op */ };\n\n  // Verify fetchUser function\n  const user = await fetchUser(mockApiUrl);\n  assert.deepEqual(user, mockUser, 'fetchUser should return the correct user data');\n\n  // Verify submitUser function\n  await assert.doesNotReject(async () => await submitUser(mockApiUrl, mockUser), 'submitUser should not throw an error');\n\n  // Verify the fetchUser call in golden_completion\n  const anotherUser = await fetchUser(mockApiUrl);\n  assert.deepEqual(anotherUser, mockUser, 'fetchUser should return the correct user data');\n})();\n", "DeepSeek-R1": "submitUser(apiUrl, { id: 2, name: 'Jane Doe', email: 'jane.doe@example.com' }).then(() => {\n  console.log('Another user data submitted successfully');\n}).catch((error) => {\n  console.error(error);\n});"}
{"id": "36", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import fetch from 'node-fetch';\n\n// Function to handle API requests\nasync function fetchData(url: string): Promise<any> {\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Error fetching data:', error);\n        throw error;\n    }\n}\n\n// Function to get user data\nasync function getUserData(userId: string): Promise<any> {\n    const apiUrl = `https://api.example.com/users/${userId}`;\n    try {\n        const userData = await fetchData(apiUrl);\n        return userData;\n    } catch (error) {\n        console.error('Error getting user data:', error);\n        throw error;\n    }\n}\n\n// Function to get post data\nasync function getPostData(postId: string): Promise<any> {\n    const apiUrl = `https://api.example.com/posts/${postId}`;\n    try {\n        const postData = await fetchData(apiUrl);\n        return postData;\n    } catch (error) {\n        console.error('Error getting post data:', error);\n        throw error;\n    }\n}\n\n// Function to get comments for a post\nasync function getComments(postId: string): Promise<any[]> {\n    const apiUrl = `https://api.example.com/posts/${postId}/comments`;\n    try {\n        const comments = await fetchData(apiUrl);\n        return comments;\n    } catch (error) {\n        console.error('Error getting comments:', error);\n        throw error;\n    }\n}\n\n// Function to get user posts\nasync function getUserPosts(userId: string): Promise<any[]> {\n    const apiUrl = `https://api.example.com/users/${userId}/posts`;\n    try {\n        const posts = await fetchData(apiUrl);\n        return posts;\n    } catch (error) {\n        console.error('Error getting user posts:', error);\n        throw error;\n    }\n}\n\n// Function to get user comments\nasync function getUserComments(userId: string): Promise<any[]> {\n    const apiUrl = `https://api.example.com/users/${userId}/comments`;\n    try {\n        const comments = await fetchData(apiUrl);\n        return comments;\n    } catch (error) {\n        console.error('Error getting user comments:', error);\n        throw error;\n    }\n}\n\n", "suffix": "async function getPostAuthor(postId: string): Promise<any> {\n    const apiUrl = `https://api.example.com/posts/${postId}/author`;\n    try {\n        const author = await fetchData(apiUrl);\n        return author;\n    } catch (error) {\n        console.error('Error getting post author:', error);\n        throw error;\n    }\n}\n", "golden_completion": "async function getUserAlbums(userId: string): Promise<any[]> {\n    const apiUrl = `https://api.example.com/users/${userId}/albums`;\n    try {\n        const albums = await fetchData(apiUrl);\n        return albums;\n    } catch (error) {\n        console.error('Error getting user albums:', error);\n        throw error;\n    }\n}\n", "LLM_justification": "This test case is a good example for checking an LLM's ability to recognize and continue a pattern of async functions handling API requests and error handling. The prefix establishes a clear pattern of functions that fetch data from specific endpoints, handle errors, and return the results. The completion should follow this pattern, and the assertions will verify that the completion maintains consistency and correctness in both functionality and error handling.", "assertions": "import assert from 'assert';\n\n(async () => {\n    const mockUserId = '123';\n    const mockApiResponse = [{ id: '1', title: 'Mock Album' }];\n\n    // Mock fetch function\n    global.fetch = async (url: string) => {\n        return {\n            ok: true,\n            json: async () => mockApiResponse\n        };\n    };\n\n    const albums = await getUserAlbums(mockUserId);\n    assert.deepStrictEqual(albums, mockApiResponse, 'The returned albums should match the mock API response');\n\n    // Restore the original fetch function\n    delete global.fetch;\n})();\n", "DeepSeek-R1": "async function getPostAuthor(postId: string): Promise<any> {\n    const apiUrl = `https://api.example.com/posts/${postId}/author`;\n    try {\n        const author = await fetchData(apiUrl);\n        return author;\n    } catch (error) {\n        console.error('Error getting post author:', error);\n        throw error;\n    }\n}"}
{"id": "37", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import { EventEmitter } from 'events';\n\ninterface GameState {\n\tscore: number;\n\tlevel: number;\n\tisGameOver: boolean;\n}\n\nclass Game extends EventEmitter {\n\tprivate state: GameState;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.state = { score: 0, level: 1, isGameOver: false };\n\t}\n\n\tpublic start() {\n\t\tthis.emit('start');\n\t}\n\n\tpublic end() {\n\t\tthis.state.isGameOver = true;\n\t\tthis.emit('end');\n\t}\n\n\tpublic scorePoint() {\n\t\tthis.state.score += 1;\n\t\tthis.emit('score', this.state.score);\n\t}\n\n\tpublic levelUp() {\n\t\tthis.state.level += 1;\n\t\tthis.emit('levelUp', this.state.level);\n\t}\n}\n\nconst game = new Game();\n\ngame.on('start', () => {\n\tconsole.log('Game started!');\n});\n\ngame.on('end', () => {\n\tconsole.log('Game over!');\n});\n\ngame.on('score', (score) => {\n\tconsole.log(`Score: ${score}`);\n});\n\ngame.on('levelUp', (level) => {\n\tconsole.log(`Level: ${level}`);\n});\n\n// Start the game\nconsole.log('Initiating game...');\ngame.start();\n\n// Simulate scoring points\nfor (let i = 0; i < 10; i++) {\n\tgame.scorePoint();\n}\n\n// Simulate leveling up\nfor (let i = 0; i < 3; i++) {\n\tgame.levelUp();\n}\n\n// End the game\nconsole.log('Ending game...');\ngame.end();\n\n", "suffix": "console.log('Game session complete.');\n", "golden_completion": "game.on('end', () => {\n\tconsole.log('Game over!');\n\tconsole.log('Final Score:', game.state.score);\n\tconsole.log('Final Level:', game.state.level);\n});\n", "LLM_justification": "This test case checks the LLM's ability to recognize and complete a pattern of event handling in a game context. The prefix establishes a pattern of event registration and handling using the EventEmitter class. The completion must follow this pattern by adding appropriate event handling code for the 'end' event, which includes logging the final score and level. This pattern is common in game development for managing game states and events. The assertions verify that the completion adheres to the established pattern and performs the expected actions.", "assertions": "import { strict as assert } from 'assert';\n\nlet finalScore = 0;\nlet finalLevel = 0;\n\n// Mock console.log to capture output\nconst originalLog = console.log;\nconst logOutput: string[] = [];\nconsole.log = (message: string) => {\n\tlogOutput.push(message);\n\tif (message.startsWith('Final Score: ')) {\n\t\tfinalScore = parseInt(message.split(': ')[1], 10);\n\t}\n\tif (message.startsWith('Final Level: ')) {\n\t\tfinalLevel = parseInt(message.split(': ')[1], 10);\n\t}\n};\n\n// Assertions\nassert(logOutput.includes('Game started!'), 'Game should start');\nassert(logOutput.includes('Game over!'), 'Game should end');\nassert(logOutput.includes('Score: 10'), 'Final score should be 10');\nassert(logOutput.includes('Level: 4'), 'Final level should be 4');\nassert(finalScore === 10, `Expected final score to be 10, but got ${finalScore}`);\nassert(finalLevel === 4, `Expected final level to be 4, but got ${finalLevel}`);\n\n// Restore original console.log\nconsole.log = originalLog;\n", "DeepSeek-R1": "console.log('Game session complete.');"}
{"id": "38", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse<T> {\n\tdata: T;\n\tstatus: number;\n\tstatusText: string;\n\theaders: any;\n\tconfig: any;\n\trequest?: any;\n}\n\nclass ApiService {\n\tprivate baseUrl: string;\n\n\tconstructor(baseUrl: string) {\n\t\tthis.baseUrl = baseUrl;\n\t}\n\n\tasync get<T>(endpoint: string): Promise<ApiResponse<T>> {\n\t\ttry {\n\t\t\tconst response = await axios.get<T>(`${this.baseUrl}${endpoint}`);\n\t\t\treturn {\n\t\t\t\tdata: response.data,\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText,\n\t\t\t\theaders: response.headers,\n\t\t\t\tconfig: response.config,\n\t\t\t\trequest: response.request,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new Error(`GET request failed: ${error.message}`);\n\t\t}\n\t}\n\n\tasync post<T>(endpoint: string, body: any): Promise<ApiResponse<T>> {\n\t\ttry {\n\t\t\tconst response = await axios.post<T>(`${this.baseUrl}${endpoint}`, body);\n\t\t\treturn {\n\t\t\t\tdata: response.data,\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText,\n\t\t\t\theaders: response.headers,\n\t\t\t\tconfig: response.config,\n\t\t\t\trequest: response.request,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new Error(`POST request failed: ${error.message}`);\n\t\t}\n\t}\n\n\t// The PUT method needs to follow the same pattern\n", "suffix": "\n\n\tasync delete<T>(endpoint: string): Promise<ApiResponse<T>> {\n\t\ttry {\n\t\t\tconst response = await axios.delete<T>(`${this.baseUrl}${endpoint}`);\n\t\t\treturn {\n\t\t\t\tdata: response.data,\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText,\n\t\t\t\theaders: response.headers,\n\t\t\t\tconfig: response.config,\n\t\t\t\trequest: response.request,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new Error(`DELETE request failed: ${error.message}`);\n\t\t}\n\t}\n}\n\n// Example usage\n(async () => {\n\tconst api = new ApiService('https://api.example.com');\n\n\ttry {\n\t\tconst getResponse = await api.get<any>('/data');\n\t\tconsole.log('GET Response:', getResponse);\n\n\t\tconst postResponse = await api.post<any>('/data', { key: 'value' });\n\t\tconsole.log('POST Response:', postResponse);\n\n\t\tconst putResponse = await api.put<any>('/data', { key: 'newValue' });\n\t\tconsole.log('PUT Response:', putResponse);\n\n\t\tconst deleteResponse = await api.delete<any>('/data');\n\t\tconsole.log('DELETE Response:', deleteResponse);\n\t} catch (error) {\n\t\tconsole.error('API Error:', error.message);\n\t}\n})();", "golden_completion": "\n\n\tasync put<T>(endpoint: string, body: any): Promise<ApiResponse<T>> {\n\t\ttry {\n\t\t\tconst response = await axios.put<T>(`${this.baseUrl}${endpoint}`, body);\n\t\t\treturn {\n\t\t\t\tdata: response.data,\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText,\n\t\t\t\theaders: response.headers,\n\t\t\t\tconfig: response.config,\n\t\t\t\trequest: response.request,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new Error(`PUT request failed: ${error.message}`);\n\t\t}\n\t}", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and continue a pattern of implementing common HTTP methods (GET, POST, PUT, DELETE) within a TypeScript class that handles API requests. The pattern involves wrapping axios calls in methods that return a consistent ApiResponse structure and handle errors uniformly. The `put` method is missing and needs to follow the same pattern as the `get` and `post` methods already defined in the class. This scenario is realistic, as it mirrors typical patterns in services that interact with RESTful APIs, and it tests the model's ability to maintain consistency in method implementation.", "assertions": "import { strict as assert } from 'assert';\n\n(async () => {\n\tconst api = new ApiService('https://api.example.com');\n\n\ttry {\n\t\tconst putResponse = await api.put<any>('/data', { key: 'newValue' });\n\t\tassert.equal(putResponse.status, 200, 'PUT request should return status 200');\n\t\tassert.equal(putResponse.data.key, 'newValue', 'PUT request should update data correctly');\n\t} catch (error) {\n\t\tassert.fail(`PUT request failed: ${error.message}`);\n\t}\n})();", "DeepSeek-R1": "\tasync put<T>(endpoint: string, body: any): Promise<ApiResponse<T>> {\n\t\ttry {\n\t\t\tconst response = await axios.put<T>(`${this.baseUrl}${endpoint}`, body);\n\t\t\treturn {\n\t\t\t\tdata: response.data,\n\t\t\t\tstatus: response.status,\n\t\t\t\tstatusText: response.statusText,\n\t\t\t\theaders: response.headers,\n\t\t\t\tconfig: response.config,\n\t\t\t\trequest: response.request,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tthrow new Error(`PUT request failed: ${error.message}`);\n\t\t}\n\t}"}
{"id": "39", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse<T> {\n    status: number;\n    data: T;\n    error?: string;\n}\n\nasync function fetchUserData(userId: string): Promise<ApiResponse<{ name: string; email: string }>> {\n    try {\n        const response = await axios.get(`https://api.example.com/users/${userId}`);\n        return {\n            status: response.status,\n            data: response.data\n        };\n    } catch (error) {\n        return {\n            status: error.response ? error.response.status : 500,\n            error: error.message,\n            data: { name: '', email: '' }\n        };\n    }\n}\n\nasync function fetchProductData(productId: string): Promise<ApiResponse<{ title: string; price: number }>> {\n    try {\n        const response = await axios.get(`https://api.example.com/products/${productId}`);\n        return {\n            status: response.status,\n            data: response.data\n        };\n    } catch (error) {\n        return {\n            status: error.response ? error.response.status : 500,\n            error: error.message,\n            data: { title: '', price: 0 }\n        };\n    }\n}\n\nasync function fetchOrderData(orderId: string): Promise<ApiResponse<{ orderId: string; amount: number }>> {\n    try {\n        const response = await axios.get(`https://api.example.com/orders/${orderId}`);\n        return {\n            status: response.status,\n            data: response.data\n        };\n    } catch (error) {\n        return {\n            status: error.response ? error.response.status : 500,\n            error: error.message,\n            data: { orderId: '', amount: 0 }\n        };\n    }\n}\n\n// The pattern is to create an async function to fetch data, handle errors, and return a typed response\n", "suffix": "\n\n(async () => {\n    const invoiceData = await fetchInvoiceData('inv123');\n    console.log(invoiceData);\n})();\n", "golden_completion": "async function fetchInvoiceData(invoiceId: string): Promise<ApiResponse<{ invoiceId: string; total: number }>> {\n    try {\n        const response = await axios.get(`https://api.example.com/invoices/${invoiceId}`);\n        return {\n            status: response.status,\n            data: response.data\n        };\n    } catch (error) {\n        return {\n            status: error.response ? error.response.status : 500,\n            error: error.message,\n            data: { invoiceId: '', total: 0 }\n        };\n    }\n}\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and continue a clear pattern of async functions fetching data from an API, handling errors, and returning a typed response. The prefix establishes the pattern with three similar functions. The golden completion requires the LLM to follow this pattern for a new function, while the suffix demonstrates a deviation from the expected pattern. This scenario tests the LLM's understanding of async/await, error handling, and TypeScript generics.", "assertions": "import { strict as assert } from 'assert';\n\n(async () => {\n    const userData = await fetchUserData('user123');\n    assert.equal(userData.status, 200);\n    assert.equal(typeof userData.data.name, 'string');\n    assert.equal(typeof userData.data.email, 'string');\n\n    const productData = await fetchProductData('product123');\n    assert.equal(productData.status, 200);\n    assert.equal(typeof productData.data.title, 'string');\n    assert.equal(typeof productData.data.price, 'number');\n\n    const orderData = await fetchOrderData('order123');\n    assert.equal(orderData.status, 200);\n    assert.equal(typeof orderData.data.orderId, 'string');\n    assert.equal(typeof orderData.data.amount, 'number');\n\n    const invoiceData = await fetchInvoiceData('inv123');\n    assert.equal(invoiceData.status, 200);\n    assert.equal(typeof invoiceData.data.invoiceId, 'string');\n    assert.equal(typeof invoiceData.data.total, 'number');\n})();\n", "DeepSeek-R1": "async function fetchInvoiceData(invoiceId: string): Promise<ApiResponse<{ invoiceId: string; amount: number }>> {\n    try {\n        const response = await axios.get(`https://api.example.com/invoices/${invoiceId}`);\n        return {\n            status: response.status,\n            data: response.data\n        };\n    } catch (error) {\n        return {\n            status: error.response ? error.response.status : 500,\n            error: error.message,\n            data: { invoiceId: '', amount: 0 }\n        };\n    }\n}"}
{"id": "40", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as crypto from 'crypto';\n\ninterface User {\n  id: string;\n  username: string;\n  password: string;\n}\n\ninterface AuthResult {\n  success: boolean;\n  token?: string;\n  error?: string;\n}\n\nfunction hashPassword(password: string): string {\n  const hash = crypto.createHash('sha256');\n  hash.update(password);\n  return hash.digest('hex');\n}\n\nfunction generateToken(userId: string): string {\n  return crypto.randomBytes(16).toString('hex') + userId;\n}\n\nfunction authenticate(username: string, password: string, users: User[]): AuthResult {\n  const user = users.find(u => u.username === username);\n  if (!user) {\n    return { success: false, error: 'User not found' };\n  }\n  const hashedPassword = hashPassword(password);\n  if (user.password !== hashedPassword) {\n    return { success: false, error: 'Invalid password' };\n  }\n  const token = generateToken(user.id);\n  return { success: true, token };\n}\n\nconst users: User[] = [\n  { id: '1', username: 'user1', password: hashPassword('password1') },\n  { id: '2', username: 'user2', password: hashPassword('password2') },\n];\n\n// Sample usage and assertions\nconst result1 = authenticate('user1', 'password1', users);\nconsole.assert(result1.success === true, 'User1 should authenticate successfully');\nconsole.assert(typeof result1.token === 'string', 'User1 should receive a token');\n\nconst result2 = authenticate('user1', 'wrongpassword', users);\nconsole.assert(result2.success === false, 'User1 with wrong password should not authenticate');\nconsole.assert(result2.error === 'Invalid password', 'User1 with wrong password should receive an error message');\n\nconst result3 = authenticate('nonexistent', 'password', users);\nconsole.assert(result3.success === false, 'Non-existent user should not authenticate');\nconsole.assert(result3.error === 'User not found', 'Non-existent user should receive an error message');\n", "suffix": "\n\n// Cleanup code if necessary\n// No resources to clean up in this example\n", "golden_completion": "const result4 = authenticate('user2', 'password2', users);\nconsole.assert(result4.success === true, 'User2 should authenticate successfully');\nconsole.assert(typeof result4.token === 'string', 'User2 should receive a token');", "LLM_justification": "This test case demonstrates a clear pattern of user authentication with proper error handling. The prefix includes three examples of the pattern for authenticating users and verifying the result. The golden completion continues this pattern by adding another test case for a different user. This scenario is realistic for security contexts, involves TypeScript-specific features like interfaces, and includes robust assertions to verify both functionality and pattern adherence.", "assertions": "const result4 = authenticate('user2', 'password2', users);\nconsole.assert(result4.success === true, 'User2 should authenticate successfully');\nconsole.assert(typeof result4.token === 'string', 'User2 should receive a token');", "DeepSeek-R1": "const result4 = authenticate('user2', 'password2', users);\nconsole.assert(result4.success === true, 'User2 should authenticate successfully');\nconsole.assert(typeof result4.token === 'string', 'User2 should receive a token');"}
{"id": "41", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse<T> {\n    status: number;\n    data: T;\n}\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\n// Function to handle API responses with generics\nfunction handleApiResponse<T>(response: ApiResponse<T>): T | null {\n    if (response.status === 200) {\n        return response.data;\n    } else {\n        console.error(`API Error: ${response.status}`);\n        return null;\n    }\n}\n\n// Function to fetch user data from an API\nasync function fetchUserData(userId: number): Promise<User | null> {\n    try {\n        const response = await axios.get<ApiResponse<User>>(`/api/users/${userId}`);\n        return handleApiResponse(response.data);\n    } catch (error) {\n        console.error(`Failed to fetch user data: ${error}`);\n        return null;\n    }\n}\n\n// Fetch and handle user data for multiple users\nasync function fetchMultipleUsers(userIds: number[]): Promise<(User | null)[]> {\n    const userPromises = userIds.map(fetchUserData);\n    return Promise.all(userPromises);\n}\n\n// Function to fetch and log user data\nasync function logUserData(userId: number): Promise<void> {\n    const user = await fetchUserData(userId);\n    if (user) {\n        console.log(`User: ${user.name}, Email: ${user.email}`);\n    } else {\n        console.log('User not found');\n    }\n}\n\n// Testing the functions\n(async () => {\n    const userIds = [1, 2, 3];\n    const users = await fetchMultipleUsers(userIds);\n    users.forEach(user => {\n        if (user) {\n            console.log(`Fetched User: ${user.name}, Email: ${user.email}`);\n        } else {\n            console.log('User not found');\n        }\n    });\n})();\n\n", "suffix": "\n(async () => {\n    await logUserData(4);\n    await logUserData(5);\n})();\n", "golden_completion": "async function fetchAllUsers(): Promise<User[]> {\n    try {\n        const response = await axios.get<ApiResponse<User[]>>('/api/users');\n        return handleApiResponse(response.data) || [];\n    } catch (error) {\n        console.error(`Failed to fetch all users: ${error}`);\n        return [];\n    }\n}\n\n", "LLM_justification": "This test case is a good example because it establishes a clear pattern of handling API responses using generics and TypeScript types. The prefix includes multiple functions that follow this pattern, making it evident for an LLM to recognize. The completion requires the LLM to continue this pattern by adding a new function that fetches all users from an API, handling errors and using the `handleApiResponse` function to process the response. This scenario is realistic and tests the LLM's ability to maintain consistency with established patterns while implementing a new function.", "assertions": "import assert from 'assert';\n\n(async () => {\n    const mockUserResponse = { status: 200, data: [{ id: 1, name: 'John Doe', email: 'john@example.com' }] };\n    axios.get = async (url: string) => ({ data: mockUserResponse });\n\n    const users = await fetchAllUsers();\n    assert.strictEqual(users.length, 1, 'Should fetch one user');\n    assert.strictEqual(users[0].name, 'John Doe', 'User name should be John Doe');\n    assert.strictEqual(users[0].email, 'john@example.com', 'User email should be john@example.com');\n})();\n", "DeepSeek-R1": "(async () => {\n    await logUserData(4);\n    await logUserData(5);\n})();"}
{"id": "42", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as crypto from 'crypto';\n\n// Utility function to generate a random string\nfunction generateRandomString(length: number): string {\n\treturn crypto.randomBytes(length).toString('hex');\n}\n\n// Higher-order function to handle encryption\nfunction withEncryption<T>(data: T, key: string, encrypt: (data: T, key: string) => string): string {\n\ttry {\n\t\tconst encryptedData = encrypt(data, key);\n\t\tconsole.log('Encryption successful');\n\t\treturn encryptedData;\n\t} catch (error) {\n\t\tconsole.error('Encryption failed', error);\n\t\tthrow error;\n\t}\n}\n\n// Higher-order function to handle decryption\nfunction withDecryption<T>(data: string, key: string, decrypt: (data: string, key: string) => T): T {\n\ttry {\n\t\tconst decryptedData = decrypt(data, key);\n\t\tconsole.log('Decryption successful');\n\t\treturn decryptedData;\n\t} catch (error) {\n\t\tconsole.error('Decryption failed', error);\n\t\tthrow error;\n\t}\n}\n\n// Example encrypt function\nfunction encryptData(data: string, key: string): string {\n\tconst cipher = crypto.createCipher('aes-256-cbc', key);\n\tlet encrypted = cipher.update(data, 'utf8', 'hex');\n\tencrypted += cipher.final('hex');\n\treturn encrypted;\n}\n\n// Example decrypt function\nfunction decryptData(data: string, key: string): string {\n\tconst decipher = crypto.createDecipher('aes-256-cbc', key);\n\tlet decrypted = decipher.update(data, 'hex', 'utf8');\n\tdecrypted += decipher.final('utf8');\n\treturn decrypted;\n}\n\n// Test data and key\nconst testData = 'Sensitive Information';\nconst testKey = generateRandomString(32);\n\n// Encrypt the test data\nconst encryptedData = withEncryption(testData, testKey, encryptData);\n\n// Assertions to verify encryption\nimport assert from 'assert';\nassert.notStrictEqual(encryptedData, testData, 'Encrypted data should not match original data');\nassert.strictEqual(typeof encryptedData, 'string', 'Encrypted data should be a string');\n", "suffix": "// Decrypt the test data\nconst decryptedData = withDecryption(encryptedData, testKey, decryptData);\n\n// Assertions to verify decryption\nassert.strictEqual(decryptedData, testData, 'Decrypted data should match original data');\nassert.strictEqual(typeof decryptedData, 'string', 'Decrypted data should be a string');\n\nconsole.log('All assertions passed.');", "golden_completion": "const decryptedData = withDecryption(encryptedData, testKey, decryptData);\n\n// Assertions to verify decryption\nassert.strictEqual(decryptedData, testData, 'Decrypted data should match original data');\nassert.strictEqual(typeof decryptedData, 'string', 'Decrypted data should be a string');\n", "LLM_justification": "This test case is valuable for evaluating an LLM's ability to recognize and complete the pattern of higher-order functions handling encryption and decryption in a security context. The prefix establishes a clear pattern using higher-order functions for encryption and decryption, along with appropriate error handling. The completion should follow this pattern by implementing the decryption part and adding assertions to verify the correctness. The provided assertions ensure that the pattern is correctly followed and the functionality is accurate, making it a realistic and practical scenario for testing pattern recognition in TypeScript.", "assertions": "assert.strictEqual(decryptedData, testData, 'Decrypted data should match original data');\nassert.strictEqual(typeof decryptedData, 'string', 'Decrypted data should be a string');", "DeepSeek-R1": "const decryptedData = withDecryption(encryptedData, testKey, decryptData);"}
{"id": "43", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse {\n    data: any;\n    status: number;\n}\n\nfunction handleApiResponse(response: ApiResponse): void {\n    if (response.status === 200) {\n        console.log('Success:', response.data);\n    } else {\n        console.error('Error:', response.status);\n    }\n}\n\nfunction fetchUserData(userId: string): Promise<ApiResponse> {\n    return axios.get(`https://api.example.com/users/${userId}`)\n        .then(response => ({ data: response.data, status: response.status }))\n        .catch(error => ({ data: error.message, status: error.response?.status || 500 }));\n}\n\nfunction fetchPosts(userId: string): Promise<ApiResponse> {\n    return axios.get(`https://api.example.com/users/${userId}/posts`)\n        .then(response => ({ data: response.data, status: response.status }))\n        .catch(error => ({ data: error.message, status: error.response?.status || 500 }));\n}\n\nasync function fetchUserAndPosts(userId: string): Promise<void> {\n    try {\n        const userResponse = await fetchUserData(userId);\n        handleApiResponse(userResponse);\n\n        const postsResponse = await fetchPosts(userId);\n        handleApiResponse(postsResponse);\n    } catch (error) {\n        console.error('Unexpected error:', error);\n    }\n}\n\n// The following function fetches comments for a specific post\nasync function fetchComments(postId: string): Promise<void> {\n    try {\n        const response = await axios.get(`https://api.example.com/posts/${postId}/comments`);\n        const comments: ApiResponse = { data: response.data, status: response.status };\n        handleApiResponse(comments);\n    } catch (error) {\n        handleApiResponse({ data: error.message, status: error.response?.status || 500 });\n    }\n}\n\n// The following function fetches albums for a specific user\nasync function fetchAlbums(userId: string): Promise<void> {\n    try {\n        const response = await axios.get(`https://api.example.com/users/${userId}/albums`);\n        const albums: ApiResponse = { data: response.data, status: response.status };\n        handleApiResponse(albums);\n    } catch (error) {\n        handleApiResponse({ data: error.message, status: error.response?.status || 500 });\n    }\n}\n\n// The following function fetches photos for a specific album\n", "suffix": "\n\nfetchUserAndPosts('123');\nfetchComments('456');\nfetchAlbums('123');\nfetchPhotos('789');", "golden_completion": "async function fetchPhotos(albumId: string): Promise<void> {\n    try {\n        const response = await axios.get(`https://api.example.com/albums/${albumId}/photos`);\n        const photos: ApiResponse = { data: response.data, status: response.status };\n        handleApiResponse(photos);\n    } catch (error) {\n        handleApiResponse({ data: error.message, status: error.response?.status || 500 });\n    }\n}\n\n", "LLM_justification": "This test case is a good example of pattern matching in TypeScript as it requires the LLM to recognize the pattern of handling API responses using async/await and proper error handling. The prefix establishes a clear pattern of fetching data from different endpoints and processing the responses in a consistent manner. The golden completion must follow this established pattern to ensure consistency and correctness. This is representative of real-world scenarios where developers often need to handle multiple API calls with similar response handling logic.", "assertions": "import { strict as assert } from 'assert';\n\nasync function testFetchPhotos() {\n    let handledResponse: ApiResponse | null = null;\n    function mockHandleApiResponse(response: ApiResponse) {\n        handledResponse = response;\n    }\n\n    const originalHandleApiResponse = handleApiResponse;\n    handleApiResponse = mockHandleApiResponse;\n    try {\n        await fetchPhotos('789');\n        assert(handledResponse !== null, 'Response should have been handled');\n        assert(handledResponse.status === 200 || handledResponse.status === 500, 'Response status should be 200 or 500');\n    } finally {\n        handleApiResponse = originalHandleApiResponse;\n    }\n}\n\ntestFetchPhotos().then(() => console.log('All assertions passed.')).catch(console.error);", "DeepSeek-R1": "async function fetchPhotos(albumId: string): Promise<void> {\n    try {\n        const response = await axios.get(`https://api.example.com/albums/${albumId}/photos`);\n        const photos: ApiResponse = { data: response.data, status: response.status };\n        handleApiResponse(photos);\n    } catch (error) {\n        handleApiResponse({ data: error.message, status: error.response?.status || 500 });\n    }\n}"}
{"id": "44", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import { assert } from \"assert\";\n\ninterface ApiResponse<T> {\n    status: number;\n    data: T;\n    error?: string;\n}\n\nfunction fetchData<T>(url: string): Promise<ApiResponse<T>> {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (url === \"https://api.example.com/data\") {\n                resolve({ status: 200, data: { message: \"Success\" } as unknown as T });\n            } else {\n                reject({ status: 404, error: \"Not Found\" });\n            }\n        }, 1000);\n    });\n}\n\nasync function getApiData<T>(url: string): Promise<T> {\n    try {\n        const response = await fetchData<T>(url);\n        if (response.status === 200) {\n            return response.data;\n        } else {\n            throw new Error(response.error);\n        }\n    } catch (error) {\n        throw new Error(`Failed to fetch data: ${error.message}`);\n    }\n}\n\nasync function processApiData(url: string): Promise<void> {\n    try {\n        const data = await getApiData<{ message: string }>(url);\n        console.log(data.message);\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\n// Example usage\nprocessApiData(\"https://api.example.com/data\");\nprocessApiData(\"https://api.example.com/invalid\");\n\n// Tests\nasync function testApiData() {\n    // Successful fetch\n    const successData = await getApiData<{ message: string }>(\"https://api.example.com/data\");\n    assert.strictEqual(successData.message, \"Success\");\n\n    // Failed fetch\n    try {\n        await getApiData<{ message: string }>(\"https://api.example.com/invalid\");\n    } catch (error) {\n        assert.strictEqual(error.message, \"Failed to fetch data: Not Found\");\n    }\n}\n\ntestApiData().then(() => console.log(\"All tests passed.\"));\n", "suffix": "\n\n// Example usage\nlogApiData(\"https://api.example.com/data\");\nlogApiData(\"https://api.example.com/invalid\");\n", "golden_completion": "async function logApiData(url: string): Promise<void> {\n    try {\n        const data = await getApiData<{ message: string }>(url);\n        console.log(`Data fetched: ${data.message}`);\n    } catch (error) {\n        console.error(`Error: ${error.message}`);\n    }\n}\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and continue an async pattern involving API calls with error handling. The prefix establishes a pattern of fetching data from an API, handling errors, and processing the data. The golden completion continues this pattern by implementing a similar function that logs the fetched data or error message. The suffix provides a different continuation to ensure the distinction between the completion and the following code. This tests the LLM's ability to maintain consistency in async operations and error handling within a TypeScript context, which is critical for many real-world applications.", "assertions": "import { strict as assert } from \"assert\";\n\nasync function testLogApiData() {\n    // Successful fetch\n    const consoleLog = console.log;\n    const consoleError = console.error;\n    let logOutput = \"\";\n    let errorOutput = \"\";\n    console.log = (message: string) => { logOutput = message; };\n    console.error = (message: string) => { errorOutput = message; };\n\n    await logApiData(\"https://api.example.com/data\");\n    assert.strictEqual(logOutput, \"Data fetched: Success\");\n    assert.strictEqual(errorOutput, \"\");\n\n    // Failed fetch\n    await logApiData(\"https://api.example.com/invalid\");\n    assert.strictEqual(logOutput, \"\");\n    assert.strictEqual(errorOutput, \"Error: Not Found\");\n\n    // Restore console functions\n    console.log = consoleLog;\n    console.error = consoleError;\n}\n\ntestLogApiData().then(() => console.log(\"All logApiData tests passed.\"));\n", "DeepSeek-R1": "async function logApiData(url: string): Promise<void> {\n    try {\n        const data = await getApiData<{ message: string }>(url);\n        console.log(data.message);\n    } catch (error) {\n        console.error(error.message);\n    }\n}"}
{"id": "45", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse<T> {\n    data: T;\n    status: number;\n}\n\ninterface User {\n    id: number;\n    name: string;\n}\n\n// Higher-order function to handle API calls with retry logic\nfunction withRetry<T>(fn: () => Promise<ApiResponse<T>>, retries: number): Promise<ApiResponse<T>> {\n    return fn().catch((error) => {\n        if (retries > 0) {\n            console.log(`Retrying... ${retries} attempts left`);\n            return withRetry(fn, retries - 1);\n        } else {\n            throw error;\n        }\n    });\n}\n\n// Function to fetch user data\nasync function fetchUserData(userId: number): Promise<ApiResponse<User>> {\n    try {\n        const response = await axios.get<ApiResponse<User>>(`/api/users/${userId}`);\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching user data:', error);\n        throw error;\n    }\n}\n\n// Function to fetch multiple users data with retry logic\nasync function fetchMultipleUsers(userIds: number[]): Promise<ApiResponse<User>[]> {\n    const promises = userIds.map(id => withRetry(() => fetchUserData(id), 3));\n    return Promise.all(promises);\n}\n\n// Example usage\n(async () => {\n    const userIds = [1, 2, 3];\n    try {\n        const users = await fetchMultipleUsers(userIds);\n        console.log('Fetched users:', users);\n    } catch (error) {\n        console.error('Failed to fetch users:', error);\n    }\n})();\n", "suffix": "\n\nasync function fetchUserPosts(userId: number): Promise<ApiResponse<Post[]>> {\n    try {\n        const response = await axios.get<ApiResponse<Post[]>>(`/api/users/${userId}/posts`);\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching user posts:', error);\n        throw error;\n    }\n}\n\n(async () => {\n    const userId = 1;\n    try {\n        const posts = await fetchUserPosts(userId);\n        console.log('Fetched posts:', posts);\n    } catch (error) {\n        console.error('Failed to fetch posts:', error);\n    }\n})();\n", "golden_completion": "async function fetchUserDetails(userId: number): Promise<{user: ApiResponse<User>, posts: ApiResponse<Post[]>}> {\n    try {\n        const userPromise = fetchUserData(userId);\n        const postsPromise = fetchUserPosts(userId);\n        const [user, posts] = await Promise.all([userPromise, postsPromise]);\n        return { user, posts };\n    } catch (error) {\n        console.error('Error fetching user details:', error);\n        throw error;\n    }\n}\n\n(async () => {\n    const userId = 1;\n    try {\n        const userDetails = await fetchUserDetails(userId);\n        console.log('Fetched user details:', userDetails);\n    } catch (error) {\n        console.error('Failed to fetch user details:', error);\n    }\n})();", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete a pattern involving higher-order functions and async patterns in the context of network protocols (APIs). The prefix establishes a pattern of using higher-order functions to add retry logic to API calls and demonstrates how to fetch user data and multiple users data with retries. The golden completion continues this pattern by introducing a new function to fetch both user data and posts concurrently, maintaining the established async and error-handling patterns. The suffix then provides an additional function to fetch user posts, which follows the same pattern of async/await and error handling.", "assertions": "import { strict as assert } from 'assert';\n\n(async () => {\n    const userId = 1;\n    const userDetails = await fetchUserDetails(userId);\n    assert(userDetails.user.data.id === 1, 'User ID should be 1');\n    assert(Array.isArray(userDetails.posts.data), 'Posts should be an array');\n})();", "DeepSeek-R1": "interface Post {\n    id: number;\n    userId: number;\n    title: string;\n    body: string;\n}"}
{"id": "46", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import axios from 'axios';\n\ninterface ApiResponse<T> {\n\tdata: T;\n\terror?: string;\n}\n\n// A higher-order function that takes a URL and a transformation function\nfunction fetchData<T, U>(url: string, transform: (data: T) => U): Promise<ApiResponse<U>> {\n\treturn axios.get(url)\n\t\t.then(response => ({ data: transform(response.data) }))\n\t\t.catch(error => ({ data: null as any, error: error.message }));\n}\n\n// Transformation functions\nfunction transformUserData(data: any): { name: string; age: number } {\n\treturn { name: data.name, age: data.age };\n}\n\nfunction transformPostData(data: any): { title: string; content: string } {\n\treturn { title: data.title, content: data.body };\n}\n\n// Usage examples\nconst userUrl = 'https://jsonplaceholder.typicode.com/users/1';\nconst postUrl = 'https://jsonplaceholder.typicode.com/posts/1';\n\nconst userPromise = fetchData(userUrl, transformUserData);\nconst postPromise = fetchData(postUrl, transformPostData);\n\n// Assertions\nuserPromise.then(response => {\n\tif (response.error) {\n\t\tconsole.error('Error fetching user:', response.error);\n\t} else {\n\t\tconsole.log('User fetched successfully:', response.data);\n\t\t// Assertions for user data\n\t\tconsole.assert(typeof response.data.name === 'string', 'User name should be a string');\n\t\tconsole.assert(typeof response.data.age === 'number', 'User age should be a number');\n\t}\n});\n\npostPromise.then(response => {\n\tif (response.error) {\n\t\tconsole.error('Error fetching post:', response.error);\n\t} else {\n\t\tconsole.log('Post fetched successfully:', response.data);\n\t\t// Assertions for post data\n\t\tconsole.assert(typeof response.data.title === 'string', 'Post title should be a string');\n\t\tconsole.assert(typeof response.data.content === 'string', 'Post content should be a string');\n\t}\n});\n", "suffix": "\n\npostPromise.then(response => {\n\tif (response.error) {\n\t\tconsole.error('Error fetching post:', response.error);\n\t} else {\n\t\tconsole.log('Post fetched successfully:', response.data);\n\t\t// Assertions for post data\n\t\tconsole.assert(response.data.title.length > 0, 'Post title should not be empty');\n\t\tconsole.assert(response.data.content.length > 0, 'Post content should not be empty');\n\t}\n});\n", "golden_completion": "userPromise.then(response => {\n\tif (response.error) {\n\t\tconsole.error('Error fetching user:', response.error);\n\t} else {\n\t\tconsole.log('User fetched successfully:', response.data);\n\t\t// Assertions for user data\n\t\tconsole.assert(response.data.name.length > 0, 'User name should not be empty');\n\t\tconsole.assert(response.data.age > 0, 'User age should be positive');\n\t}\n});\n\n", "LLM_justification": "This test case is an excellent example for pattern matching as it establishes a clear pattern of using higher-order functions to fetch data from an API and transform it. The assertions are meaningful and test both the structure and content of the fetched data. This scenario is realistic, as it mimics common tasks such as fetching and transforming data in a TypeScript application. The prefix provides a comprehensive setup, including imports, type definitions, utility functions, and initial data fetching logic, making the pattern evident. The golden completion continues this pattern appropriately, ensuring consistency and correctness.", "assertions": "userPromise.then(response => {\n\tif (!response.error) {\n\t\tconsole.assert(response.data.name.length > 0, 'User name should not be empty');\n\t\tconsole.assert(response.data.age > 0, 'User age should be positive');\n\t}\n});\n\npostPromise.then(response => {\n\tif (!response.error) {\n\t\tconsole.assert(response.data.title.length > 0, 'Post title should not be empty');\n\t\tconsole.assert(response.data.content.length > 0, 'Post content should not be empty');\n\t}\n});", "DeepSeek-R1": "userPromise.then(response => {\n\tif (response.error) {\n\t\tconsole.error('Error fetching user:', response.error);\n\t} else {\n\t\tconsole.log('User fetched successfully:', response.data);\n\t\t// Assertions for user data\n\t\tconsole.assert(response.data.name.length > 0, 'User name should not be empty');\n\t\tconsole.assert(response.data.age > 0, 'User age should be positive');\n\t}\n});"}
{"id": "47", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import crypto from 'crypto';\n\n// Define a generic interface for encryption strategies\ninterface EncryptionStrategy {\n    encrypt(data: string): string;\n    decrypt(data: string): string;\n}\n\n// Implement an AES encryption strategy\nclass AESEncryption implements EncryptionStrategy {\n    private key: Buffer;\n    private iv: Buffer;\n\n    constructor(key: string, iv: string) {\n        this.key = Buffer.from(key, 'hex');\n        this.iv = Buffer.from(iv, 'hex');\n    }\n\n    encrypt(data: string): string {\n        const cipher = crypto.createCipheriv('aes-256-cbc', this.key, this.iv);\n        let encrypted = cipher.update(data, 'utf8', 'hex');\n        encrypted += cipher.final('hex');\n        return encrypted;\n    }\n\n    decrypt(data: string): string {\n        const decipher = crypto.createDecipheriv('aes-256-cbc', this.key, this.iv);\n        let decrypted = decipher.update(data, 'hex', 'utf8');\n        decrypted += decipher.final('utf8');\n        return decrypted;\n    }\n}\n\n// Implement a RSA encryption strategy\nclass RSAEncryption implements EncryptionStrategy {\n    private publicKey: string;\n    private privateKey: string;\n\n    constructor(publicKey: string, privateKey: string) {\n        this.publicKey = publicKey;\n        this.privateKey = privateKey;\n    }\n\n    encrypt(data: string): string {\n        const buffer = Buffer.from(data, 'utf8');\n        const encrypted = crypto.publicEncrypt(this.publicKey, buffer);\n        return encrypted.toString('hex');\n    }\n\n    decrypt(data: string): string {\n        const buffer = Buffer.from(data, 'hex');\n        const decrypted = crypto.privateDecrypt(this.privateKey, buffer);\n        return decrypted.toString('utf8');\n    }\n}\n\n// Factory function to create encryption strategies\nfunction createEncryptionStrategy(type: 'aes' | 'rsa', key: string, ivOrPrivateKey: string): EncryptionStrategy {\n    if (type === 'aes') {\n        return new AESEncryption(key, ivOrPrivateKey);\n    } else if (type === 'rsa') {\n        return new RSAEncryption(key, ivOrPrivateKey);\n    }\n    throw new Error('Unsupported encryption type');\n}\n\n// Example usage\nconst aesStrategy = createEncryptionStrategy('aes', '6368616e676520746869732070617373', '1234567890123456');\nconst rsaStrategy = createEncryptionStrategy('rsa', '-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7zB9VPJt5J1ZJvh2bcLg\\n-----END PUBLIC KEY-----', '-----BEGIN PRIVATE KEY-----\\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDvMH1U8m3knVkm\\n-----END PRIVATE KEY-----');\n\n// Encrypt and decrypt using AES strategy\nconst aesEncrypted = aesStrategy.encrypt('Hello, World!');\nconst aesDecrypted = aesStrategy.decrypt(aesEncrypted);\nconsole.log(`AES Encrypted: ${aesEncrypted}`);\nconsole.log(`AES Decrypted: ${aesDecrypted}`);\n\n// Encrypt and decrypt using RSA strategy\nconst rsaEncrypted = rsaStrategy.encrypt('Hello, World!');\nconst rsaDecrypted = rsaStrategy.decrypt(rsaEncrypted);\nconsole.log(`RSA Encrypted: ${rsaEncrypted}`);\nconsole.log(`RSA Decrypted: ${rsaDecrypted}`);", "suffix": "// Mocking a new encryption strategy for a different algorithm\nclass NewAlgoEncryption implements EncryptionStrategy {\n    private secret: string;\n\n    constructor(secret: string) {\n        this.secret = secret;\n    }\n\n    encrypt(data: string): string {\n        // Mock encryption logic\n        return `${data}-encrypted-with-${this.secret}`;\n    }\n\n    decrypt(data: string): string {\n        // Mock decryption logic\n        return data.replace(`-encrypted-with-${this.secret}`, '');\n    }\n}\n\n// Example usage for the new algorithm\nconst newAlgoStrategy = new NewAlgoEncryption('mysecretkey');\nconst newAlgoEncrypted = newAlgoStrategy.encrypt('Hello, World!');\nconst newAlgoDecrypted = newAlgoStrategy.decrypt(newAlgoEncrypted);\nconsole.log(`New Algo Encrypted: ${newAlgoEncrypted}`);\nconsole.log(`New Algo Decrypted: ${newAlgoDecrypted}`);", "golden_completion": "// Implement a DES encryption strategy\nclass DESEncryption implements EncryptionStrategy {\n    private key: Buffer;\n    private iv: Buffer;\n\n    constructor(key: string, iv: string) {\n        this.key = Buffer.from(key, 'hex');\n        this.iv = Buffer.from(iv, 'hex');\n    }\n\n    encrypt(data: string): string {\n        const cipher = crypto.createCipheriv('des-ede3-cbc', this.key, this.iv);\n        let encrypted = cipher.update(data, 'utf8', 'hex');\n        encrypted += cipher.final('hex');\n        return encrypted;\n    }\n\n    decrypt(data: string): string {\n        const decipher = crypto.createDecipheriv('des-ede3-cbc', this.key, this.iv);\n        let decrypted = decipher.update(data, 'hex', 'utf8');\n        decrypted += decipher.final('utf8');\n        return decrypted;\n    }\n}\n\n// Example usage for the DES strategy\nconst desStrategy = new DESEncryption('0123456789abcdef0123456789abcdef', '12345678');\nconst desEncrypted = desStrategy.encrypt('Hello, World!');\nconst desDecrypted = desStrategy.decrypt(desEncrypted);\nconsole.log(`DES Encrypted: ${desEncrypted}`);\nconsole.log(`DES Decrypted: ${desDecrypted}`);", "LLM_justification": "This test case demonstrates the implementation of various encryption strategies using a common interface. By establishing a clear pattern with AES and RSA encryption strategies, the LLM is expected to recognize and implement a new encryption strategy (DES) following the same pattern. This scenario involves type definitions and generics in the security domain, testing the model's ability to understand and extend patterns in cryptographic implementations. The provided assertions verify that the encryption and decryption processes are correctly implemented for the new strategy.", "assertions": "import { strict as assert } from 'assert';\n\n// Assertions for AES strategy\nassert.strictEqual(aesDecrypted, 'Hello, World!');\n\n// Assertions for RSA strategy\nassert.strictEqual(rsaDecrypted, 'Hello, World!');\n\n// Assertions for DES strategy\nassert.strictEqual(desDecrypted, 'Hello, World!');\n\n// Assertions for the new algorithm strategy\nassert.strictEqual(newAlgoDecrypted, 'Hello, World!');\n", "DeepSeek-R1": "// Mocking a new encryption strategy for a different algorithm\nclass NewAlgoEncryption implements EncryptionStrategy {\n    private secret: string;\n\n    constructor(secret: string) {\n        this.secret = secret;\n    }\n\n    encrypt(data: string): string {\n        // Mock encryption logic\n        return `${data}-encrypted-with-${this.secret}`;\n    }\n\n    decrypt(data: string): string {\n        // Mock decryption logic\n        return data.replace(`-encrypted-with-${this.secret}`, '');\n    }\n}\n\n// Example usage for the new algorithm\nconst newAlgoStrategy = new NewAlgoEncryption('mysecretkey');\nconst newAlgoEncrypted = newAlgoStrategy.encrypt('Hello, World!');\nconst newAlgoDecrypted = newAlgoStrategy.decrypt(newAlgoEncrypted);\nconsole.log(`New Algo Encrypted: ${newAlgoEncrypted}`);\nconsole.log(`New Algo Decrypted: ${newAlgoDecrypted}`);"}
{"id": "48", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import { createServer, IncomingMessage, ServerResponse } from 'http';\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\nconst users: User[] = [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com' }\n];\n\nfunction handleGetUsers(req: IncomingMessage, res: ServerResponse) {\n    res.writeHead(200, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify(users));\n}\n\nfunction handleGetUserById(req: IncomingMessage, res: ServerResponse) {\n    const userId = parseInt(req.url?.split('/')[2] || '', 10);\n    const user = users.find(u => u.id === userId);\n    if (user) {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify(user));\n    } else {\n        res.writeHead(404, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'User not found' }));\n    }\n}\n\nfunction handlePostUser(req: IncomingMessage, res: ServerResponse) {\n    let body = '';\n    req.on('data', chunk => {\n        body += chunk;\n    });\n    req.on('end', () => {\n        const newUser: User = JSON.parse(body);\n        newUser.id = users.length + 1;\n        users.push(newUser);\n        res.writeHead(201, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify(newUser));\n    });\n}\n\nfunction requestListener(req: IncomingMessage, res: ServerResponse) {\n    if (req.method === 'GET' && req.url === '/users') {\n        handleGetUsers(req, res);\n    } else if (req.method === 'GET' && req.url?.startsWith('/users/')) {\n        handleGetUserById(req, res);\n    } else if (req.method === 'POST' && req.url === '/users') {\n        handlePostUser(req, res);\n    } else {\n        res.writeHead(404, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'Not found' }));\n    }\n}\n\nconst server = createServer(requestListener);\nserver.listen(8080, () => {\n    console.log('Server is listening on port 8080');\n});\n", "suffix": "\nserver.close(() => {\n    console.log('Server closed');\n});\n", "golden_completion": "function handleDeleteUser(req: IncomingMessage, res: ServerResponse) {\n    const userId = parseInt(req.url?.split('/')[2] || '', 10);\n    const userIndex = users.findIndex(u => u.id === userId);\n    if (userIndex !== -1) {\n        users.splice(userIndex, 1);\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ success: 'User deleted' }));\n    } else {\n        res.writeHead(404, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({ error: 'User not found' }));\n    }\n}\n\nif (req.method === 'DELETE' && req.url?.startsWith('/users/')) {\n    handleDeleteUser(req, res);\n} else ", "LLM_justification": "This test case is a good example of pattern matching because it involves adding a new functionality to an existing HTTP server. The pattern of handling different HTTP methods and routes is established in the prefix with `handleGetUsers`, `handleGetUserById`, and `handlePostUser` functions. The `handleDeleteUser` function follows the same pattern for a DELETE request. This scenario tests the LLM's ability to recognize and extend the pattern of handling different HTTP requests and routes, which is a common task in building RESTful APIs.", "assertions": "import { strict as assert } from 'assert';\n\nconst testReq = (method: string, url: string, data?: any) => {\n    return new Promise<{ statusCode: number, data: any }>((resolve, reject) => {\n        const options = { hostname: 'localhost', port: 8080, path: url, method, headers: { 'Content-Type': 'application/json' } };\n        const req = require('http').request(options, (res: any) => {\n            let rawData = '';\n            res.on('data', (chunk: any) => { rawData += chunk; });\n            res.on('end', () => { resolve({ statusCode: res.statusCode, data: JSON.parse(rawData) }); });\n        });\n        req.on('error', (e: any) => { reject(e); });\n        if (data) req.write(JSON.stringify(data));\n        req.end();\n    });\n};\n\n(async () => {\n    // Test GET /users\n    let res = await testReq('GET', '/users');\n    assert.equal(res.statusCode, 200);\n    assert.equal(res.data.length, 3);\n\n    // Test GET /users/1\n    res = await testReq('GET', '/users/1');\n    assert.equal(res.statusCode, 200);\n    assert.equal(res.data.name, 'Alice');\n\n    // Test POST /users\n    res = await testReq('POST', '/users', { name: 'Dave', email: 'dave@example.com' });\n    assert.equal(res.statusCode, 201);\n    assert.equal(res.data.name, 'Dave');\n\n    // Test DELETE /users/4\n    res = await testReq('DELETE', '/users/4');\n    assert.equal(res.statusCode, 200);\n    assert.equal(res.data.success, 'User deleted');\n\n    // Verify user is deleted\n    res = await testReq('GET', '/users/4');\n    assert.equal(res.statusCode, 404);\n})();\n", "DeepSeek-R1": "process.on('SIGINT', () => {\n    server.close(() => {\n        console.log('Server closed');\n    });\n});"}
{"id": "49", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as crypto from 'crypto';\n\ninterface User {\n    id: number;\n    username: string;\n    passwordHash: string;\n}\n\nconst users: User[] = [\n    { id: 1, username: 'user1', passwordHash: 'hash1' },\n    { id: 2, username: 'user2', passwordHash: 'hash2' }\n];\n\nfunction hashPassword(password: string): string {\n    return crypto.createHash('sha256').update(password).digest('hex');\n}\n\nfunction authenticate(username: string, password: string): boolean {\n    const user = users.find(u => u.username === username);\n    if (!user) {\n        return false;\n    }\n    const passwordHash = hashPassword(password);\n    return user.passwordHash === passwordHash;\n}\n\n// Higher-order function for logging\nfunction logExecution<T extends (...args: any[]) => any>(fn: T): T {\n    return ((...args: Parameters<T>): ReturnType<T> => {\n        console.log(`Executing function ${fn.name} with arguments:`, args);\n        const result = fn(...args);\n        console.log(`Function ${fn.name} returned:`, result);\n        return result;\n    }) as T;\n}\n\nconst loggedAuthenticate = logExecution(authenticate);\n\n// Example usage of loggedAuthenticate\nconst isAuthenticated = loggedAuthenticate('user1', 'password1');\nconsole.log('Is authenticated:', isAuthenticated);\n\n// More higher-order functions for different actions\nfunction logAndTimeExecution<T extends (...args: any[]) => any>(fn: T): T {\n    return ((...args: Parameters<T>): ReturnType<T> => {\n        const startTime = Date.now();\n        console.log(`Executing function ${fn.name} with arguments:`, args);\n        const result = fn(...args);\n        const endTime = Date.now();\n        console.log(`Function ${fn.name} returned:`, result);\n        console.log(`Execution time: ${endTime - startTime}ms`);\n        return result;\n    }) as T;\n}\n\nconst loggedAndTimedAuthenticate = logAndTimeExecution(authenticate);\n\n// Example usage of loggedAndTimedAuthenticate\nconst isAuthenticatedTimed = loggedAndTimedAuthenticate('user2', 'password2');\nconsole.log('Is authenticated with timing:', isAuthenticatedTimed);\n", "suffix": "\n\n// Cleanup\nusers.length = 0;", "golden_completion": "\nconst loggedAndTimedHashPassword = logAndTimeExecution(hashPassword);\n\n// Example usage of loggedAndTimedHashPassword\nconst hashedPassword = loggedAndTimedHashPassword('mySecretPassword');\nconsole.log('Hashed password with timing:', hashedPassword);\n", "LLM_justification": "This example tests the LLM's ability to recognize and continue a higher-order function pattern in the context of security (password hashing and authentication). The pattern is established with higher-order functions that log and time the execution of other functions. The completion should demonstrate the ability to apply the same higher-order function pattern to a new function (`hashPassword`) and use it correctly. The prefix provides ample context and examples of the pattern, ensuring it is clear. Assertions verify that the pattern is followed and that the functionality is correct.", "assertions": "import * as assert from 'assert';\n\nconst testPassword = 'testPassword';\nconst expectedHash = hashPassword(testPassword);\nconst actualHash = loggedAndTimedHashPassword(testPassword);\nassert.strictEqual(actualHash, expectedHash, 'Hash should match the expected hash');\n\nconst testUser = 'user1';\nconst wrongPassword = 'wrongPassword';\nconst correctPassword = 'password1';\nassert.strictEqual(loggedAndTimedAuthenticate(testUser, wrongPassword), false, 'Authentication should fail with wrong password');\nassert.strictEqual(loggedAndTimedAuthenticate(testUser, correctPassword), true, 'Authentication should succeed with correct password');", "DeepSeek-R1": "users.push({ id: 3, username: 'testuser', passwordHash: hashPassword('testpass') });\nconst testAuth = loggedAuthenticate('testuser', 'testpass');\nconsole.log('Test authentication:', testAuth);"}
{"id": "50", "testsource": "devbench-pattern-matching", "language": "typescript", "prefix": "import * as crypto from 'crypto';\n\ninterface User {\n  id: string;\n  username: string;\n  passwordHash: string;\n  salt: string;\n}\n\nclass AuthenticationService {\n  private users: User[] = [];\n\n  public addUser(username: string, password: string): User {\n    const salt = crypto.randomBytes(16).toString('hex');\n    const passwordHash = this.hashPassword(password, salt);\n    const user: User = { id: crypto.randomUUID(), username, passwordHash, salt };\n    this.users.push(user);\n    return user;\n  }\n\n  private hashPassword(password: string, salt: string): string {\n    return crypto.pbkdf2Sync(password, salt, 1000, 64, 'sha512').toString('hex');\n  }\n\n  public authenticate(username: string, password: string): boolean {\n    const user = this.users.find(u => u.username === username);\n    if (!user) {\n      return false;\n    }\n    const passwordHash = this.hashPassword(password, user.salt);\n    return user.passwordHash === passwordHash;\n  }\n}\n\n// Adding and authenticating users\nconst authService = new AuthenticationService();\nconst user1 = authService.addUser('user1', 'password1');\nconst user2 = authService.addUser('user2', 'password2');\n\nconsole.log('User1:', user1);\nconsole.log('User2:', user2);\n\nconst isAuthenticatedUser1 = authService.authenticate('user1', 'password1');\nconst isAuthenticatedUser2 = authService.authenticate('user2', 'password2');\nconsole.log('Is User1 authenticated?', isAuthenticatedUser1);\nconsole.log('Is User2 authenticated?', isAuthenticatedUser2);\n", "suffix": "\nconst isAuthenticatedUser3 = authService.authenticate('user3', 'password3');\nconsole.log('Is User3 authenticated?', isAuthenticatedUser3);\n", "golden_completion": "const isAuthenticatedUser1WrongPassword = authService.authenticate('user1', 'wrongpassword');\nconsole.log('Is User1 authenticated with wrong password?', isAuthenticatedUser1WrongPassword);\n", "LLM_justification": "This is a good test case because it demonstrates a common pattern in authentication services: adding users, hashing passwords, and authenticating users. The prefix code establishes the pattern of using the `AuthenticationService` class to add users and authenticate them. The pattern involves hashing passwords with a salt and comparing the hashed passwords for authentication. The golden completion follows this pattern by attempting to authenticate a user with an incorrect password, which is a common scenario in real-world applications. The suffix continues the pattern by attempting to authenticate a non-existent user. This test case ensures that the LLM can recognize and complete the pattern of user authentication correctly.", "assertions": "import * as assert from 'assert';\n\nconst authService = new AuthenticationService();\nconst user1 = authService.addUser('user1', 'password1');\nconst user2 = authService.addUser('user2', 'password2');\n\nassert.strictEqual(authService.authenticate('user1', 'password1'), true, 'User1 should be authenticated with correct password');\nassert.strictEqual(authService.authenticate('user2', 'password2'), true, 'User2 should be authenticated with correct password');\nassert.strictEqual(authService.authenticate('user1', 'wrongpassword'), false, 'User1 should not be authenticated with wrong password');\nassert.strictEqual(authService.authenticate('user3', 'password3'), false, 'User3 should not be authenticated (non-existent user)');\n", "DeepSeek-R1": "const isAuthenticatedUser1Wrong = authService.authenticate('user1', 'wrong');\nconsole.log('Is User1 with wrong password authenticated?', isAuthenticatedUser1Wrong);"}
