
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

interface DataPoint {
    x: number;
    y: number;
}

class Statistics {
    private data: DataPoint[] = [];

    public addDataPoint(x: number, y: number): void {
        this.data.push({ x, y });
    }

    public calculateMean(): { meanX: number, meanY: number } {
        const total = this.data.reduce((acc, point) => {
            acc.x += point.x;
            acc.y += point.y;
            return acc;
        }, { x: 0, y: 0 });
        return {
            meanX: total.x / this.data.length,
            meanY: total.y / this.data.length
        };
    }

    public calculateVariance(): { varianceX: number, varianceY: number } {
        const mean = this.calculateMean();
        const varianceTotal = this.data.reduce((acc, point) => {
            acc.x += Math.pow(point.x - mean.meanX, 2);
            acc.y += Math.pow(point.y - mean.meanY, 2);
            return acc;
        }, { x: 0, y: 0 });
        return {
            varianceX: varianceTotal.x / this.data.length,
            varianceY: varianceTotal.y / this.data.length
        };
    }

    public calculateStandardDeviation(): { stdDevX: number, stdDevY: number } {
        const variance = this.calculateVariance();
        return {
            stdDevX: Math.sqrt(variance.varianceX),
            stdDevY: Math.sqrt(variance.varianceY)
        };
    }
}

const stats = new Statistics();
stats.addDataPoint(1, 2);
stats.addDataPoint(3, 4);
stats.addDataPoint(5, 6);

// Calculate and assert the mean values
const mean = stats.calculateMean();
assert.strictEqual(mean.meanX, 3);
assert.strictEqual(mean.meanY, 4);

// Calculate and assert the variance values
const variance = stats.calculateVariance();
assert.strictEqual(variance.varianceX, 4);
assert.strictEqual(variance.varianceY, 4);



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Calculate and assert the standard deviation values
const stdDev = stats.calculateStandardDeviation();
assert.strictEqual(stdDev.stdDevX, 2);
assert.strictEqual(stdDev.stdDevY, 2);

SUFFIX CODE:
----------------------------------------

// Clean up resources or perform any final operations if necessary


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and complete a pattern involving statistical calculations within a class. The pattern of calculating mean, variance, and standard deviation is clear and requires proper understanding of mathematical operations on data points. The assertions ensure that the calculations are performed correctly. The scenario is realistic for scientific computing, making it a practical test case for pattern recognition.

ASSERTIONS:
----------------------------------------
const stdDev = stats.calculateStandardDeviation();
assert.strictEqual(stdDev.stdDevX, 2);
assert.strictEqual(stdDev.stdDevY, 2);

================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
interface DataPoint {
    x: number;
    y: number;
}

class LinearRegression {
    private data: DataPoint[] = [];

    addDataPoint(point: DataPoint): void {
        this.data.push(point);
    }

    private calculateMean(values: number[]): number {
        const sum = values.reduce((acc, val) => acc + val, 0);
        return sum / values.length;
    }

    private calculateVariance(values: number[], mean: number): number {
        return values.reduce((acc, val) => acc + (val - mean) ** 2, 0) / values.length;
    }

    private calculateCovariance(xValues: number[], yValues: number[], xMean: number, yMean: number): number {
        let covariance = 0;
        for (let i = 0; i < xValues.length; i++) {
            covariance += (xValues[i] - xMean) * (yValues[i] - yMean);
        }
        return covariance / xValues.length;
    }

    private extractXValues(): number[] {
        return this.data.map(point => point.x);
    }

    private extractYValues(): number[] {
        return this.data.map(point => point.y);
    }

    public calculateCoefficients(): { slope: number; intercept: number } {
        const xValues = this.extractXValues();
        const yValues = this.extractYValues();
        const xMean = this.calculateMean(xValues);
        const yMean = this.calculateMean(yValues);
        const varianceX = this.calculateVariance(xValues, xMean);
        const covarianceXY = this.calculateCovariance(xValues, yValues, xMean, yMean);
        const slope = covarianceXY / varianceX;
        const intercept = yMean - slope * xMean;
        return { slope, intercept };
    }
}

const model = new LinearRegression();
model.addDataPoint({ x: 1, y: 2 });
model.addDataPoint({ x: 2, y: 3 });
model.addDataPoint({ x: 3, y: 4 });
const coefficients = model.calculateCoefficients();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log(`Slope: ${coefficients.slope}`);

SUFFIX CODE:
----------------------------------------
console.log(`Intercept: ${coefficients.intercept}`);

// Validate the correctness of the model
const expectedSlope = 1;
const expectedIntercept = 1;
console.assert(coefficients.slope === expectedSlope, `Expected slope to be ${expectedSlope}, but got ${coefficients.slope}`);
console.assert(coefficients.intercept === expectedIntercept, `Expected intercept to be ${expectedIntercept}, but got ${coefficients.intercept}`);
// Cleanup code if any (none needed in this case)


JUSTIFICATION:
----------------------------------------
This test case establishes a clear pattern of data extraction, mathematical computation, and result logging. The `golden_completion` logically fits by continuing the pattern of logging calculated results. The assertions ensure the slope and intercept calculations are correct, adhering to the established pattern. This scenario tests the LLM's ability to recognize and continue the pattern within a scientific computing context using TypeScript.

ASSERTIONS:
----------------------------------------
console.assert(coefficients.slope === 1, `Expected slope to be 1, but got ${coefficients.slope}`);
console.assert(coefficients.intercept === 1, `Expected intercept to be 1, but got ${coefficients.intercept}`);
================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// Helper function to calculate the mean of an array of numbers
function calculateMean(numbers: number[]): number {
    if (numbers.length === 0) throw new Error('Array cannot be empty');
    const sum = numbers.reduce((acc, val) => acc + val, 0);
    return sum / numbers.length;
}

// Helper function to calculate the median of an array of numbers
function calculateMedian(numbers: number[]): number {
    if (numbers.length === 0) throw new Error('Array cannot be empty');
    const sorted = numbers.slice().sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
    } else {
        return sorted[mid];
    }
}

// Helper function to calculate the mode of an array of numbers
function calculateMode(numbers: number[]): number[] {
    if (numbers.length === 0) throw new Error('Array cannot be empty');
    const frequency: { [key: number]: number } = {};
    numbers.forEach(num => {
        frequency[num] = (frequency[num] || 0) + 1;
    });
    const maxFreq = Math.max(...Object.values(frequency));
    return Object.keys(frequency).filter(key => frequency[Number(key)] === maxFreq).map(Number);
}

// Helper function to calculate the variance of an array of numbers
function calculateVariance(numbers: number[]): number {
    if (numbers.length === 0) throw new Error('Array cannot be empty');
    const mean = calculateMean(numbers);
    const squaredDiffs = numbers.map(num => Math.pow(num - mean, 2));
    return calculateMean(squaredDiffs);
}

// Helper function to calculate the standard deviation of an array of numbers
function calculateStandardDeviation(numbers: number[]): number {
    if (numbers.length === 0) throw new Error('Array cannot be empty');
    const variance = calculateVariance(numbers);
    return Math.sqrt(variance);
}

// Sample data for testing
const sampleData = [2, 4, 4, 4, 5, 5, 7, 9];

// Calculate mean, median, mode, variance, and standard deviation
const mean = calculateMean(sampleData);
const median = calculateMedian(sampleData);
const mode = calculateMode(sampleData);
const variance = calculateVariance(sampleData);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const stdDev = calculateStandardDeviation(sampleData);

SUFFIX CODE:
----------------------------------------


// Assertions to verify the calculations
assert.strictEqual(mean, 5);
assert.strictEqual(median, 4.5);
assert.deepStrictEqual(mode, [4]);
assert.strictEqual(variance, 4);
assert.strictEqual(stdDev, 2);

console.log('All tests passed');

JUSTIFICATION:
----------------------------------------
This test case is a good example because it establishes a clear pattern of calculating various statistical measures (mean, median, mode, variance) using helper functions. The golden completion requires the LLM to recognize and continue this pattern by calculating the standard deviation. The context of scientific computing and data analysis makes this pattern realistic and practical for developers. The assertions verify the correctness of the calculations and ensure that the pattern is adhered to.

ASSERTIONS:
----------------------------------------
assert.strictEqual(mean, 5);
assert.strictEqual(median, 4.5);
assert.deepStrictEqual(mode, [4]);
assert.strictEqual(variance, 4);
assert.strictEqual(stdDev, 2);

console.log('All tests passed');
================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

type DataEntry = {
  timestamp: string;
  value: number;
};

type DataSet = DataEntry[];

class DataProcessor {
  data: DataSet;

  constructor(data: DataSet) {
    this.data = data;
  }

  filterByDate(startDate: string, endDate: string): DataSet {
    return this.data.filter(entry => entry.timestamp >= startDate && entry.timestamp <= endDate);
  }

  calculateAverage(data: DataSet): number {
    const total = data.reduce((acc, entry) => acc + entry.value, 0);
    return total / data.length;
  }

  findMaxValue(data: DataSet): number {
    return data.reduce((max, entry) => entry.value > max ? entry.value : max, data[0].value);
  }

  // Add the new method pattern here


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
  findMinValue(data: DataSet): number {
    return data.reduce((min, entry) => entry.value < min ? entry.value : min, data[0].value);
  }

SUFFIX CODE:
----------------------------------------

}

// Test data
const testData: DataSet = [
  { timestamp: '2023-01-01', value: 10 },
  { timestamp: '2023-01-02', value: 20 },
  { timestamp: '2023-01-03', value: 30 },
  { timestamp: '2023-01-04', value: 40 },
  { timestamp: '2023-01-05', value: 50 }
];

const processor = new DataProcessor(testData);
const filteredData = processor.filterByDate('2023-01-02', '2023-01-04');
const average = processor.calculateAverage(filteredData);
const maxValue = processor.findMaxValue(filteredData);
const minValue = processor.findMinValue(filteredData);

assert.strictEqual(filteredData.length, 3);
assert.strictEqual(average, 30);
assert.strictEqual(maxValue, 40);
assert.strictEqual(minValue, 20);

console.log('All tests passed.');

JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in TypeScript because it requires the LLM to recognize and continue the pattern of methods within the DataProcessor class that perform calculations on a DataSet. The established methods (filterByDate, calculateAverage, findMaxValue) follow a clear pattern of taking a DataSet as input and returning a calculated value. The golden completion continues this pattern by implementing a method to find the minimum value in a DataSet, which is consistent with the other methods in the class. The assertions verify that the methods work correctly and adhere to the pattern.

ASSERTIONS:
----------------------------------------
assert.strictEqual(filteredData.length, 3);
assert.strictEqual(average, 30);
assert.strictEqual(maxValue, 40);
assert.strictEqual(minValue, 20);
================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { readFileSync } from 'fs';

// Data validation helper functions
function isValidString(value: any): boolean {
    return typeof value === 'string' && value.trim().length > 0;
}

function isValidNumber(value: any): boolean {
    return typeof value === 'number' && !isNaN(value);
}

function isValidDate(value: any): boolean {
    return value instanceof Date && !isNaN(value.getTime());
}

// Validation schema interface
interface User {
    name: string;
    age: number;
    birthdate: Date;
}

// Validate user data according to the schema
function validateUser(data: any): User | null {
    if (isValidString(data.name) && isValidNumber(data.age) && isValidDate(new Date(data.birthdate))) {
        return {
            name: data.name,
            age: data.age,
            birthdate: new Date(data.birthdate)
        };
    }
    return null;
}

// Sample data for validation
const rawData = '{"name": "John Doe", "age": 30, "birthdate": "1992-06-15"}';
const parsedData = JSON.parse(rawData);

// Validating the parsed data
const validatedUser = validateUser(parsedData);

// Assertions to verify validation
if (validatedUser) {
    console.log('User data is valid:', validatedUser);
} else {
    console.error('User data is invalid');
}

// Additional validation function for an array of users
function validateUsers(data: any[]): (User | null)[] {
    return data.map(validateUser);
}

// Sample array of user data
const rawUsers = '[{"name": "John Doe", "age": 30, "birthdate": "1992-06-15"}, {"name": "Jane Smith", "age": 25, "birthdate": "1997-09-21"}]';
const parsedUsers = JSON.parse(rawUsers);

// Validating the array of users
const validatedUsers = validateUsers(parsedUsers);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
if (validatedUsers.every(user => user !== null)) {
    console.log('All user data is valid:', validatedUsers);
} else {
    console.error('Some user data is invalid');
}

// Cleaning up resources if any (not applicable in this example)


JUSTIFICATION:
----------------------------------------
This test case focuses on data validation patterns within the context of validating user data. The prefix establishes multiple helper functions for validating different data types, a schema interface for user data, and a function to validate individual user objects. The pattern is extended to validate an array of user objects. The golden completion must follow the established pattern to correctly validate the array of users and provide appropriate logging based on the validation result. This scenario is realistic and practical, testing the LLM's ability to recognize and continue the data validation pattern effectively.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

const testUsers = '[{"name": "Alice", "age": 28, "birthdate": "1994-03-12"}, {"name": "Bob", "age": 32, "birthdate": "1990-07-08"}]';
const parsedTestUsers = JSON.parse(testUsers);
const validatedTestUsers = validateUsers(parsedTestUsers);

assert(validatedTestUsers.every(user => user !== null), 'All test user data should be valid');

const invalidUsers = '[{"name": "", "age": 28, "birthdate": "1994-03-12"}, {"name": "Bob", "age": null, "birthdate": "1990-07-08"}]';
const parsedInvalidUsers = JSON.parse(invalidUsers);
const validatedInvalidUsers = validateUsers(parsedInvalidUsers);

assert(validatedInvalidUsers.some(user => user === null), 'Some invalid user data should be detected');

================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface DataPoint {
    timestamp: number;
    value: number;
}

class DataLoader {
    private data: DataPoint[] = [];

    constructor(private filePath: string) {}

    public async loadData(): Promise<void> {
        const fileContent = await fs.promises.readFile(this.filePath, 'utf-8');
        const lines = fileContent.split('\n');
        for (const line of lines) {
            const [timestampStr, valueStr] = line.split(',');
            if (timestampStr && valueStr) {
                const dataPoint: DataPoint = {
                    timestamp: parseInt(timestampStr, 10),
                    value: parseFloat(valueStr),
                };
                this.data.push(dataPoint);
            }
        }
    }

    public getData(): DataPoint[] {
        return this.data;
    }
}

class DataAnalyzer {
    constructor(private data: DataPoint[]) {}

    public getAverageValue(): number {
        const total = this.data.reduce((sum, dataPoint) => sum + dataPoint.value, 0);
        return total / this.data.length;
    }

    public getMaxValue(): number {
        return this.data.reduce((max, dataPoint) => dataPoint.value > max ? dataPoint.value : max, -Infinity);
    }

    public getMinValue(): number {
        return this.data.reduce((min, dataPoint) => dataPoint.value < min ? dataPoint.value : min, Infinity);
    }

    public getMedianValue(): number {
        const sortedValues = this.data.map(dataPoint => dataPoint.value).sort((a, b) => a - b);
        const mid = Math.floor(sortedValues.length / 2);
        if (sortedValues.length % 2 === 0) {
            return (sortedValues[mid - 1] + sortedValues[mid]) / 2;
        } else {
            return sortedValues[mid];
        }
    }
}

// Usage example
async function main() {
    const dataLoader = new DataLoader(path.join(__dirname, 'data.csv'));
    await dataLoader.loadData();
    const data = dataLoader.getData();
    const analyzer = new DataAnalyzer(data);
    console.log('Average Value:', analyzer.getAverageValue());
    console.log('Max Value:', analyzer.getMaxValue());
    console.log('Min Value:', analyzer.getMinValue());


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    console.log('Median Value:', analyzer.getMedianValue());

SUFFIX CODE:
----------------------------------------

}

main().catch(err => console.error(err));


JUSTIFICATION:
----------------------------------------
This test case is designed to assess the LLM's ability to recognize and complete a pattern in TypeScript code, specifically focusing on OOP patterns within a data analysis context. The prefix establishes a clear pattern of data loading and analysis, with multiple methods implemented in the DataAnalyzer class. The golden completion requires the LLM to continue this pattern by calling the getMedianValue method, which is consistent with the previous method calls for average, max, and min values. The suffix provides a realistic continuation of the code without duplicating the golden completion. This scenario tests the LLM's understanding of established patterns and its ability to follow TypeScript best practices.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';
import * as path from 'path';

async function test() {
    const dataLoader = new DataLoader(path.join(__dirname, 'test_data.csv'));
    await dataLoader.loadData();
    const data = dataLoader.getData();
    const analyzer = new DataAnalyzer(data);

    assert.strictEqual(analyzer.getAverageValue(), 3.5, 'Average value should be 3.5');
    assert.strictEqual(analyzer.getMaxValue(), 5, 'Max value should be 5');
    assert.strictEqual(analyzer.getMinValue(), 2, 'Min value should be 2');
    assert.strictEqual(analyzer.getMedianValue(), 3.5, 'Median value should be 3.5');
}

test().catch(err => console.error(err));

================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';

interface DataPoint {
    x: number;
    y: number;
}

class DataAnalyzer {
    private data: DataPoint[];

    constructor(data: DataPoint[]) {
        this.data = data;
    }

    public calculateMean(): DataPoint {
        const total = this.data.reduce((acc, point) => {
            return { x: acc.x + point.x, y: acc.y + point.y };
        }, { x: 0, y: 0 });
        const count = this.data.length;
        return { x: total.x / count, y: total.y / count };
    }

    public calculateVariance(mean: DataPoint): DataPoint {
        const varianceTotal = this.data.reduce((acc, point) => {
            return {
                x: acc.x + Math.pow(point.x - mean.x, 2),
                y: acc.y + Math.pow(point.y - mean.y, 2)
            };
        }, { x: 0, y: 0 });
        const count = this.data.length;
        return { x: varianceTotal.x / count, y: varianceTotal.y / count };
    }

    // Pattern: Methods that perform statistical calculations
    // Next, we will add a method to calculate the standard deviation


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    public calculateStandardDeviation(variance: DataPoint): DataPoint {
        return { x: Math.sqrt(variance.x), y: Math.sqrt(variance.y) };
    }

SUFFIX CODE:
----------------------------------------

    public saveResultsToFile(filename: string, results: {mean: DataPoint, variance: DataPoint, standardDeviation: DataPoint}): void {
        const dataToSave = JSON.stringify(results, null, 2);
        fs.writeFileSync(filename, dataToSave);
    }
}

// Example usage
const data: DataPoint[] = [
    { x: 1, y: 2 },
    { x: 2, y: 3 },
    { x: 3, y: 4 }
];
const analyzer = new DataAnalyzer(data);
const mean = analyzer.calculateMean();
const variance = analyzer.calculateVariance(mean);
const standardDeviation = analyzer.calculateStandardDeviation(variance);
const results = { mean, variance, standardDeviation };
analyzer.saveResultsToFile('results.json', results);

// Assertions
import assert from 'assert';
const savedData = JSON.parse(fs.readFileSync('results.json', 'utf-8'));
assert.deepEqual(savedData.mean, mean);
assert.deepEqual(savedData.variance, variance);
assert.deepEqual(savedData.standardDeviation, standardDeviation);
fs.unlinkSync('results.json'); // Cleanup


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and continue a pattern of statistical calculation methods within a TypeScript class that processes scientific data. The prefix establishes a pattern with methods for calculating the mean and variance, and the golden completion follows this pattern by adding a method to calculate the standard deviation. The suffix then uses this new method and saves the results to a file. This scenario tests the LLM's understanding of method consistency, parameter usage, and mathematical operations in the context of scientific computing.

ASSERTIONS:
----------------------------------------
import assert from 'assert';
const data: DataPoint[] = [
    { x: 1, y: 2 },
    { x: 2, y: 3 },
    { x: 3, y: 4 }
];
const analyzer = new DataAnalyzer(data);
const mean = analyzer.calculateMean();
const variance = analyzer.calculateVariance(mean);
const standardDeviation = analyzer.calculateStandardDeviation(variance);
const results = { mean, variance, standardDeviation };
analyzer.saveResultsToFile('results.json', results);
const savedData = JSON.parse(fs.readFileSync('results.json', 'utf-8'));
assert.deepEqual(savedData.mean, mean);
assert.deepEqual(savedData.variance, variance);
assert.deepEqual(savedData.standardDeviation, standardDeviation);
fs.unlinkSync('results.json');
================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// Utility function to calculate the mean of an array of numbers
function mean(numbers: number[]): number {
    const total = numbers.reduce((acc, num) => acc + num, 0);
    return total / numbers.length;
}

// Utility function to calculate the variance of an array of numbers
function variance(numbers: number[]): number {
    const meanValue = mean(numbers);
    const squaredDiffs = numbers.map(num => Math.pow(num - meanValue, 2));
    return mean(squaredDiffs);
}

// Utility function to calculate the standard deviation of an array of numbers
function standardDeviation(numbers: number[]): number {
    return Math.sqrt(variance(numbers));
}

// Utility function to calculate the median of an array of numbers
function median(numbers: number[]): number {
    const sortedNumbers = [...numbers].sort((a, b) => a - b);
    const midIndex = Math.floor(sortedNumbers.length / 2);
    if (sortedNumbers.length % 2 === 0) {
        return (sortedNumbers[midIndex - 1] + sortedNumbers[midIndex]) / 2;
    } else {
        return sortedNumbers[midIndex];
    }
}

// Utility function to calculate the mode of an array of numbers
function mode(numbers: number[]): number[] {
    const frequencyMap: { [key: number]: number } = {};
    numbers.forEach(num => {
        if (frequencyMap[num]) {
            frequencyMap[num]++;
        } else {
            frequencyMap[num] = 1;
        }
    });
    const maxFrequency = Math.max(...Object.values(frequencyMap));
    return Object.keys(frequencyMap)
        .filter(key => frequencyMap[Number(key)] === maxFrequency)
        .map(Number);
}

// Utility function to calculate the range of an array of numbers
function range(numbers: number[]): number {
    const min = Math.min(...numbers);
    const max = Math.max(...numbers);
    return max - min;
}

// Test data
const data = [1, 2, 2, 3, 4, 4, 4, 5, 6];

// Calculate statistics for the test data
const meanValue = mean(data);
const varianceValue = variance(data);
const standardDeviationValue = standardDeviation(data);
const medianValue = median(data);
const modeValue = mode(data);
const rangeValue = range(data);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log({
    meanValue,
    varianceValue,
    standardDeviationValue,
    medianValue,
    modeValue,
    rangeValue
});

SUFFIX CODE:
----------------------------------------

// Assertions
assert.strictEqual(meanValue, 3.4444444444444446, 'Mean value is incorrect');
assert.strictEqual(varianceValue, 2.493827160493827, 'Variance value is incorrect');
assert.strictEqual(standardDeviationValue, 1.5791859612183664, 'Standard deviation value is incorrect');
assert.strictEqual(medianValue, 4, 'Median value is incorrect');
assert.deepStrictEqual(modeValue, [4], 'Mode value is incorrect');
assert.strictEqual(rangeValue, 5, 'Range value is incorrect');

console.log('All assertions passed!');

JUSTIFICATION:
----------------------------------------
This scenario tests the model's ability to recognize and continue a pattern of statistical utility functions for scientific computing. The prefix provides several examples of functions that calculate different statistical measures (mean, variance, standard deviation, median, mode, and range). The golden completion follows this established pattern by adding two new statistical measures (skewness and kurtosis) and includes the corresponding utility functions. This tests the model's ability to maintain consistency with the existing pattern and implement similar utility functions. The suffix includes assertions to verify the correctness of the computed values, ensuring the model's completion is both functionally and semantically correct.

ASSERTIONS:
----------------------------------------
assert.strictEqual(skewnessValue, 0.12260247977512876, 'Skewness value is incorrect');
assert.strictEqual(kurtosisValue, -1.3733333333333334, 'Kurtosis value is incorrect');
================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

interface DataPoint {
    x: number;
    y: number;
}

class DataAnalyzer {
    private data: DataPoint[];

    constructor(data: DataPoint[]) {
        this.data = data;
    }

    // A method to calculate the mean of x values
    calculateMeanX(): number {
        const sum = this.data.reduce((acc, point) => acc + point.x, 0);
        return sum / this.data.length;
    }

    // A method to calculate the mean of y values
    calculateMeanY(): number {
        const sum = this.data.reduce((acc, point) => acc + point.y, 0);
        return sum / this.data.length;
    }

    // A method to calculate the variance of x values
    calculateVarianceX(): number {
        const meanX = this.calculateMeanX();
        const variance = this.data.reduce((acc, point) => acc + Math.pow(point.x - meanX, 2), 0) / this.data.length;
        return variance;
    }

    // A method to calculate the variance of y values
    calculateVarianceY(): number {
        const meanY = this.calculateMeanY();
        const variance = this.data.reduce((acc, point) => acc + Math.pow(point.y - meanY, 2), 0) / this.data.length;
        return variance;
    }
}

const data: DataPoint[] = [
    { x: 1, y: 2 },
    { x: 2, y: 3 },
    { x: 3, y: 4 },
    { x: 4, y: 5 }
];

const analyzer = new DataAnalyzer(data);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const meanX = analyzer.calculateMeanX();
const meanY = analyzer.calculateMeanY();
const varianceX = analyzer.calculateVarianceX();

SUFFIX CODE:
----------------------------------------

const varianceY = analyzer.calculateVarianceY();

// Assertions
assert.strictEqual(meanX, 2.5);
assert.strictEqual(meanY, 3.5);
assert.strictEqual(varianceX, 1.25);
assert.strictEqual(varianceY, 1.25);

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching for several reasons. First, it establishes a clear pattern in the prefix with methods for calculating mean and variance for x and y values. This pattern is reinforced by the consistent method names and calculations. The golden completion continues this pattern by calling the methods defined in the prefix in a logical order, demonstrating understanding of the established pattern. The suffix then completes the example by using assertions to validate the correctness of the calculations, ensuring both functional and semantic correctness. The use of TypeScript interfaces and classes is appropriate for the domain context of scientific computing.

ASSERTIONS:
----------------------------------------
assert.strictEqual(meanX, 2.5);
assert.strictEqual(meanY, 3.5);
assert.strictEqual(varianceX, 1.25);
assert.strictEqual(varianceY, 1.25);
================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';

// Utility function to read and parse JSON files
function readJSONFileSync<T>(filePath: string): T {
    const data = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(data) as T;
}

// Utility function to write JSON files
function writeJSONFileSync<T>(filePath: string, data: T): void {
    const json = JSON.stringify(data, null, 2);
    fs.writeFileSync(filePath, json, 'utf-8');
}

// Type definition for a user
interface User {
    id: number;
    name: string;
    email: string;
}

// Type definition for a product
interface Product {
    id: number;
    name: string;
    price: number;
}

// Function to validate user data
function validateUser(user: User): boolean {
    return user.id > 0 && user.name.length > 0 && /\S+@\S+\.\S+/.test(user.email);
}

// Function to validate product data
function validateProduct(product: Product): boolean {
    return product.id > 0 && product.name.length > 0 && product.price > 0;
}

// Sample user data
const sampleUser: User = {
    id: 1,
    name: 'John Doe',
    email: 'john.doe@example.com'
};

// Sample product data
const sampleProduct: Product = {
    id: 1,
    name: 'Sample Product',
    price: 99.99
};

// Validate the sample user data
const isUserValid = validateUser(sampleUser);
console.log(`Is user valid? ${isUserValid}`);

// Validate the sample product data
const isProductValid = validateProduct(sampleProduct);
console.log(`Is product valid? ${isProductValid}`);

// Reading from a JSON file
const users = readJSONFileSync<User[]>('users.json');
const products = readJSONFileSync<Product[]>('products.json');

// Validate all users and products
const areUsersValid = users.every(validateUser);
console.log(`Are all users valid? ${areUsersValid}`);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const areProductsValid = products.every(validateProduct);
console.log(`Are all products valid? ${areProductsValid}`);

SUFFIX CODE:
----------------------------------------
// Writing updated data back to JSON files
writeJSONFileSync('users.json', users);
writeJSONFileSync('products.json', products);


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate an LLM's ability to recognize and complete a pattern involving data validation and file operations in TypeScript. The prefix establishes a clear pattern of reading JSON files, validating data, and logging results. The golden completion continues this pattern by validating products, and the suffix completes the operation by writing the data back to JSON files. This scenario is realistic and demonstrates best practices in TypeScript for data validation and file handling.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';
const sampleUser: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };
const sampleProduct: Product = { id: 1, name: 'Sample Product', price: 99.99 };
const users: User[] = [sampleUser];
const products: Product[] = [sampleProduct];
assert.strictEqual(validateUser(sampleUser), true, 'Sample user should be valid');
assert.strictEqual(validateProduct(sampleProduct), true, 'Sample product should be valid');
assert.strictEqual(users.every(validateUser), true, 'All users should be valid');
assert.strictEqual(products.every(validateProduct), true, 'All products should be valid');

================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// Define a simple type for a 2D Point
interface Point {
    x: number;
    y: number;
}

// Define a class for a Shape
abstract class Shape {
    abstract area(): number;
    abstract perimeter(): number;
}

// Define a class for a Circle that extends Shape
class Circle extends Shape {
    constructor(public radius: number) {
        super();
    }

    area(): number {
        return Math.PI * this.radius * this.radius;
    }

    perimeter(): number {
        return 2 * Math.PI * this.radius;
    }
}

// Define a class for a Rectangle that extends Shape
class Rectangle extends Shape {
    constructor(public width: number, public height: number) {
        super();
    }

    area(): number {
        return this.width * this.height;
    }

    perimeter(): number {
        return 2 * (this.width + this.height);
    }
}

// Helper function to log shape details
function logShapeDetails(shape: Shape): void {
    console.log(`Shape details - Area: ${shape.area()}, Perimeter: ${shape.perimeter()}`);
}

// Create instances of shapes
const circle = new Circle(5);
const rectangle = new Rectangle(10, 20);

// Log details of shapes
logShapeDetails(circle);
logShapeDetails(rectangle);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
class Square extends Shape {
    constructor(public side: number) {
        super();
    }

    area(): number {
        return this.side * this.side;
    }

    perimeter(): number {
        return 4 * this.side;
    }
}

SUFFIX CODE:
----------------------------------------
const square = new Square(15);
logShapeDetails(square);

// Assertions
assert.strictEqual(square.area(), 225);
assert.strictEqual(square.perimeter(), 60);

console.log('All tests passed');


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and follow OOP patterns in TypeScript, particularly the implementation of abstract classes and their concrete subclasses. The pattern involves defining a Shape class with area and perimeter methods, which are then implemented by specific shapes (Circle, Rectangle). The golden completion requires the LLM to continue this pattern by correctly implementing a Square class that follows the same structure. This scenario is realistic as developers frequently work with abstract classes and their implementations in various domains, including scientific computing and simulations.

ASSERTIONS:
----------------------------------------
assert.strictEqual(square.area(), 225);
assert.strictEqual(square.perimeter(), 60);
console.log('All tests passed');

================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';

// Define a type for the data format
interface LogEntry {
    timestamp: string;
    level: 'INFO' | 'WARN' | 'ERROR';
    message: string;
}

// Utility function to format log entries
function formatLogEntry(entry: LogEntry): string {
    return `${entry.timestamp} [${entry.level}] ${entry.message}`;
}

// Function to parse a log file
function parseLogFile(filePath: string): LogEntry[] {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    const entries: LogEntry[] = [];
    for (const line of lines) {
        const parts = line.split(' ');
        if (parts.length < 3) continue;
        const timestamp = parts[0];
        const level = parts[1] as 'INFO' | 'WARN' | 'ERROR';
        const message = parts.slice(2).join(' ');
        entries.push({ timestamp, level, message });
    }
    return entries;
}

// Function to filter log entries by level
function filterLogEntries(entries: LogEntry[], level: 'INFO' | 'WARN' | 'ERROR'): LogEntry[] {
    return entries.filter(entry => entry.level === level);
}

// Function to save log entries to a file
function saveLogEntries(filePath: string, entries: LogEntry[]): void {
    const content = entries.map(formatLogEntry).join('\n');
    fs.writeFileSync(filePath, content, 'utf-8');
}

// Example usage
const logEntries = parseLogFile('example.log');
const errorEntries = filterLogEntries(logEntries, 'ERROR');
saveLogEntries('errors.log', errorEntries);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log('Log processing complete.');

SUFFIX CODE:
----------------------------------------
console.log('Log processing complete.');


JUSTIFICATION:
----------------------------------------
This scenario demonstrates a clear pattern in the way log entries are processed. The pattern involves reading a log file, parsing it into structured log entries, filtering these entries based on a log level, and then saving the filtered entries to a new file. The completion requires recognizing this pattern and continuing it to handle warning log entries. This tests the LLM's ability to identify and extend a consistent functional pattern in the code.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';
import * as fs from 'fs';

const logEntries = parseLogFile('example.log');
const warnEntries = filterLogEntries(logEntries, 'WARN');

// Assertions to verify the correct filtering of log entries
assert.ok(warnEntries.length > 0, 'There should be warning log entries');
assert.strictEqual(warnEntries.every(entry => entry.level === 'WARN'), true, 'All entries should be of level WARN');

// Save the warning entries to a file
saveLogEntries('warnings.log', warnEntries);

// Verify the file content
const savedContent = fs.readFileSync('warnings.log', 'utf-8');
const savedEntries = parseLogFile('warnings.log');
assert.strictEqual(savedEntries.length, warnEntries.length, 'The number of saved entries should match the filtered entries');
assert.strictEqual(savedContent, warnEntries.map(formatLogEntry).join('\n'), 'The content of the saved file should match the formatted entries');

console.log('All assertions passed.');

================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface LogEntry {
  timestamp: Date;
  level: 'info' | 'warn' | 'error';
  message: string;
}

class Logger {
  private logFilePath: string;

  constructor(logFilePath: string) {
    this.logFilePath = logFilePath;
  }

  private formatLogEntry(entry: LogEntry): string {
    return `${entry.timestamp.toISOString()} - ${entry.level.toUpperCase()}: ${entry.message}`;
  }

  public async log(entry: LogEntry): Promise<void> {
    const formattedEntry = this.formatLogEntry(entry);
    await fs.promises.appendFile(this.logFilePath, formattedEntry + '\n');
  }

  public async info(message: string): Promise<void> {
    const entry: LogEntry = {
      timestamp: new Date(),
      level: 'info',
      message: message
    };
    await this.log(entry);
  }

  public async warn(message: string): Promise<void> {
    const entry: LogEntry = {
      timestamp: new Date(),
      level: 'warn',
      message: message
    };
    await this.log(entry);
  }

  public async error(message: string): Promise<void> {
    const entry: LogEntry = {
      timestamp: new Date(),
      level: 'error',
      message: message
    };
    await this.log(entry);
  }
}

const logger = new Logger(path.join(__dirname, 'application.log'));

async function runLoggingDemo() {
  await logger.info('This is an informational message.');
  await logger.warn('This is a warning message.');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
  await logger.error('This is an error message.');

SUFFIX CODE:
----------------------------------------
}

runLoggingDemo().then(() => console.log('Logging demo complete')).catch(err => console.error('Error during logging demo:', err));

JUSTIFICATION:
----------------------------------------
This test case is a good example for testing pattern matching in large language models because it clearly establishes a pattern of logging methods in a Logger class. The Logger class has methods for logging info, warn, and error messages, each following a consistent pattern in terms of method structure and usage. The golden completion requires the model to recognize this pattern and correctly add the method call for logging an error message within the runLoggingDemo function. The scenario is realistic and practical, as logging is a common task in system operations, and the patterns used here are typical of logging implementations in TypeScript.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';
import * as fs from 'fs';
import * as path from 'path';

async function testLogger() {
  const logFilePath = path.join(__dirname, 'test.log');
  const logger = new Logger(logFilePath);

  await logger.info('Test info message');
  await logger.warn('Test warn message');
  await logger.error('Test error message');

  const logContent = await fs.promises.readFile(logFilePath, 'utf-8');

  assert(logContent.includes('INFO: Test info message'), 'Info message should be logged');
  assert(logContent.includes('WARN: Test warn message'), 'Warn message should be logged');
  assert(logContent.includes('ERROR: Test error message'), 'Error message should be logged');

  // Cleanup
  await fs.promises.unlink(logFilePath);
}

testLogger().then(() => console.log('All assertions passed')).catch(err => console.error('Assertion error:', err));
================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

// A utility function to read a JSON file
function readJsonFile(filePath: string): any {
    const data = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(data);
}

// A utility function to write a JSON file
function writeJsonFile(filePath: string, data: any): void {
    const json = JSON.stringify(data, null, 2);
    fs.writeFileSync(filePath, json, 'utf-8');
}

// A function to validate a JSON object against a schema
function validateJson(schema: any, data: any): boolean {
    // For simplicity, let's assume the schema is an object with required keys
    for (const key of Object.keys(schema)) {
        if (!data.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}

// Schema definition for data validation
const userSchema = {
    "id": "number",
    "name": "string",
    "email": "string"
};

// Function to clean and normalize user data
function cleanUserData(data: any): any {
    const cleanedData = { ...data };
    cleanedData.email = cleanedData.email.trim().toLowerCase();
    return cleanedData;
}

// Example usage of the utility functions
const userData = readJsonFile(path.join(__dirname, 'user.json'));

if (validateJson(userSchema, userData)) {
    const cleanedData = cleanUserData(userData);
    writeJsonFile(path.join(__dirname, 'cleaned_user.json'), cleanedData);
} else {
    console.error('Invalid user data');
}

// Another usage example for a different JSON file
const productSchema = {
    "id": "number",
    "name": "string",
    "price": "number"
};

const productData = readJsonFile(path.join(__dirname, 'product.json'));

if (validateJson(productSchema, productData)) {
    const cleanedData = cleanUserData(productData);
    writeJsonFile(path.join(__dirname, 'cleaned_product.json'), cleanedData);
} else {
    console.error('Invalid product data');
}

// A function to clean and normalize product data
function cleanProductData(data: any): any {
    const cleanedData = { ...data };
    cleanedData.name = cleanedData.name.trim();
    cleanedData.price = parseFloat(cleanedData.price);
    return cleanedData;
}

const anotherProductData = readJsonFile(path.join(__dirname, 'another_product.json'));

if (validateJson(productSchema, anotherProductData)) {
    const cleanedData = cleanProductData(anotherProductData);
    writeJsonFile(path.join(__dirname, 'cleaned_another_product.json'), cleanedData);
} else {
    console.error('Invalid another product data');
}



LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
const invalidData = { "id": 123, "name": "Invalid Data" };

if (validateJson(productSchema, invalidData)) {
    const cleanedData = cleanProductData(invalidData);
    writeJsonFile(path.join(__dirname, 'cleaned_invalid_data.json'), cleanedData);
} else {
    console.error('Invalid data');
}


JUSTIFICATION:
----------------------------------------
This test case establishes a clear pattern of reading, validating, cleaning, and writing JSON data using specific schemas. The pattern involves reading a JSON file, validating its structure against a schema, cleaning the data, and then writing the cleaned data to a new file. The completion requires the model to recognize and continue this established pattern with a new JSON file and schema. The provided assertions will verify both the adherence to the pattern and the functional correctness of the code.

ASSERTIONS:
----------------------------------------
const assert = require('assert');
const cleanedAnotherUserData = readJsonFile(path.join(__dirname, 'cleaned_another_user.json'));
assert.strictEqual(cleanedAnotherUserData.email, 'another@example.com');
assert.strictEqual(cleanedAnotherUserData.name, 'Another User');
const cleanedInvalidData = readJsonFile(path.join(__dirname, 'cleaned_invalid_data.json'));
assert.strictEqual(cleanedInvalidData.id, undefined);
================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

type DataPoint = { x: number; y: number };

type Dataset = DataPoint[];

/**
 * Computes the mean of the x values in the dataset.
 */
function computeMeanX(dataset: Dataset): number {
    const total = dataset.reduce((acc, point) => acc + point.x, 0);
    return total / dataset.length;
}

/**
 * Computes the mean of the y values in the dataset.
 */
function computeMeanY(dataset: Dataset): number {
    const total = dataset.reduce((acc, point) => acc + point.y, 0);
    return total / dataset.length;
}

/**
 * Computes the variance of the x values in the dataset.
 */
function computeVarianceX(dataset: Dataset): number {
    const meanX = computeMeanX(dataset);
    const variance = dataset.reduce((acc, point) => acc + Math.pow(point.x - meanX, 2), 0);
    return variance / dataset.length;
}

/**
 * Computes the variance of the y values in the dataset.
 */
function computeVarianceY(dataset: Dataset): number {
    const meanY = computeMeanY(dataset);
    const variance = dataset.reduce((acc, point) => acc + Math.pow(point.y - meanY, 2), 0);
    return variance / dataset.length;
}

/**
 * Computes the standard deviation of the x values in the dataset.
 */
function computeStdDevX(dataset: Dataset): number {
    const varianceX = computeVarianceX(dataset);
    return Math.sqrt(varianceX);
}

/**
 * Computes the standard deviation of the y values in the dataset.
 */
function computeStdDevY(dataset: Dataset): number {
    const varianceY = computeVarianceY(dataset);
    return Math.sqrt(varianceY);
}

// Example dataset
const dataset: Dataset = [
    { x: 1, y: 2 },
    { x: 2, y: 3 },
    { x: 3, y: 4 },
    { x: 4, y: 5 },
    { x: 5, y: 6 }
];

LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
const computedStdDevX = computeStdDevX(dataset);
const computedStdDevY = computeStdDevY(dataset);

// Assertions
assert.strictEqual(computedStdDevX.toFixed(2), '1.41');
assert.strictEqual(computedStdDevY.toFixed(2), '1.41');

console.log('All assertions passed.');


JUSTIFICATION:
----------------------------------------
This example tests the ability of the LLM to recognize and continue a pattern of statistical computations on a dataset. The prefix establishes a clear pattern of functions to compute mean, variance, and standard deviation for x and y values in a dataset. The golden completion requires the LLM to extend this pattern by implementing a function to compute the correlation coefficient, which logically follows from the previous computations. The suffix then continues to use the new function and asserts its correctness. This pattern is non-trivial but recognizable to anyone familiar with statistical analysis in TypeScript.

ASSERTIONS:
----------------------------------------
assert.strictEqual(computeMeanX(dataset).toFixed(2), '3.00');
assert.strictEqual(computeMeanY(dataset).toFixed(2), '4.00');
assert.strictEqual(computeVarianceX(dataset).toFixed(2), '2.50');
assert.strictEqual(computeVarianceY(dataset).toFixed(2), '2.50');
assert.strictEqual(computeStdDevX(dataset).toFixed(2), '1.58');
assert.strictEqual(computeStdDevY(dataset).toFixed(2), '1.58');
assert.strictEqual(computeCorrelationCoefficient(dataset).toFixed(2), '1.00');

================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';

// Define a higher-order function that processes files
function processFile(filePath: string, processor: (data: string) => string): string {
    const data = fs.readFileSync(filePath, 'utf-8');
    return processor(data);
}

// Define a function that replaces all occurrences of a word
function replaceWord(data: string, target: string, replacement: string): string {
    const regex = new RegExp(target, 'g');
    return data.replace(regex, replacement);
}

// Define a function that converts all text to uppercase
function toUpperCase(data: string): string {
    return data.toUpperCase();
}

// Mock file content for testing
const testFilePath = 'test.txt';
fs.writeFileSync(testFilePath, 'hello world');

// Test processing the file with the replaceWord function
const replacedContent = processFile(testFilePath, (data) => replaceWord(data, 'hello', 'hi'));
console.log(replacedContent);  // Should log 'hi world'

// Test processing the file with the toUpperCase function
const upperCaseContent = processFile(testFilePath, toUpperCase);
console.log(upperCaseContent);  // Should log 'HELLO WORLD'



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Test processing the file with a custom function
const customContent = processFile(testFilePath, (data) => data.split(' ').reverse().join(' '));
console.log(customContent);  // Should log 'world hello'

SUFFIX CODE:
----------------------------------------
// Test processing the file with a custom function
const customContent = processFile(testFilePath, (data) => data.split(' ').reverse().join(' '));
console.log(customContent);  // Should log 'world hello'

// Clean up the test file
fs.unlinkSync(testFilePath);


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern involving higher-order functions in the context of file processing. The prefix establishes the pattern by defining a higher-order function `processFile` and demonstrating its use with two different processing functions (`replaceWord` and `toUpperCase`). The golden completion continues this pattern by combining both processing functions in a single call, which is a common practice in functional programming. The assertions verify that the functions are applied correctly and that the pattern is followed.

ASSERTIONS:
----------------------------------------
import * as fs from 'fs';
import { strict as assert } from 'assert';

const testFilePath = 'test.txt';
fs.writeFileSync(testFilePath, 'hello world');

const replacedContent = processFile(testFilePath, (data) => replaceWord(data, 'hello', 'hi'));
assert.strictEqual(replacedContent, 'hi world');

const upperCaseContent = processFile(testFilePath, toUpperCase);
assert.strictEqual(upperCaseContent, 'HELLO WORLD');

const combinedContent = processFile(testFilePath, (data) => toUpperCase(replaceWord(data, 'hello', 'hi')));
assert.strictEqual(combinedContent, 'HI WORLD');

const customContent = processFile(testFilePath, (data) => data.split(' ').reverse().join(' '));
assert.strictEqual(customContent, 'world hello');

fs.unlinkSync(testFilePath);

================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse<T> {
    success: boolean;
    data: T;
}

interface Metric {
    id: number;
    value: number;
}

async function fetchMetrics(): Promise<ApiResponse<Metric[]>> {
    try {
        const response = await axios.get<ApiResponse<Metric[]>>('https://api.example.com/metrics');
        return response.data;
    } catch (error) {
        throw new Error('Failed to fetch metrics');
    }
}

async function fetchMetricById(id: number): Promise<ApiResponse<Metric>> {
    try {
        const response = await axios.get<ApiResponse<Metric>>(`https://api.example.com/metrics/${id}`);
        return response.data;
    } catch (error) {
        throw new Error(`Failed to fetch metric with id ${id}`);
    }
}

async function fetchAllData(): Promise<{ metrics: Metric[], metricDetails: Metric[] }> {
    const metricsResponse = await fetchMetrics();
    if (!metricsResponse.success) {
        throw new Error('Failed to fetch metrics');
    }
    const metrics = metricsResponse.data;

    const metricDetails: Metric[] = [];
    for (const metric of metrics) {
        const metricDetailResponse = await fetchMetricById(metric.id);
        if (!metricDetailResponse.success) {
            throw new Error(`Failed to fetch metric details for id ${metric.id}`);
        }
        metricDetails.push(metricDetailResponse.data);
    }

    return { metrics, metricDetails };
}

// Example usage
async function run() {
    try {
        const data = await fetchAllData();
        console.log('Fetched data:', data);
    } catch (error) {
        console.error(error.message);
    }
}

run();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
axios.defaults.baseURL = 'https://api.example.com';

SUFFIX CODE:
----------------------------------------


// Cleanup code
axios.defaults.baseURL = '';
axios.defaults.headers.common = {};


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of async functions fetching data from an API. The established pattern involves making HTTP GET requests using axios, handling errors, and returning the response data. The golden completion requires the LLM to create a new function that follows this pattern, but for fetching data by name instead of ID, which is a realistic extension of the provided prefix code. The assertions verify that the new function works correctly and adheres to the established pattern.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async function() {
    // Mock axios for testing
    const axios = require('axios');
    const MockAdapter = require('axios-mock-adapter');
    const mock = new MockAdapter(axios);

    mock.onGet('https://api.example.com/metrics/name/testName').reply(200, { success: true, data: { id: 1, value: 100 } });

    const result = await fetchMetricByName('testName');
    assert.equal(result.success, true, 'Expected success to be true');
    assert.equal(result.data.id, 1, 'Expected id to be 1');
    assert.equal(result.data.value, 100, 'Expected value to be 100');

    mock.restore();
})();
================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

interface User {
  id: string;
  username: string;
  passwordHash: string;
}

class Authentication {
  private users: Map<string, User> = new Map();

  constructor() {
    // Initialize with a test user
    const testUser: User = {
      id: '1',
      username: 'testuser',
      passwordHash: this.hashPassword('testpassword')
    };
    this.users.set(testUser.username, testUser);
  }

  private hashPassword(password: string): string {
    return crypto.createHash('sha256').update(password).digest('hex');
  }

  async register(username: string, password: string): Promise<void> {
    if (this.users.has(username)) {
      throw new Error('User already exists');
    }
    const user: User = {
      id: crypto.randomUUID(),
      username,
      passwordHash: this.hashPassword(password)
    };
    this.users.set(username, user);
  }

  async authenticate(username: string, password: string): Promise<boolean> {
    const user = this.users.get(username);
    if (!user) {
      throw new Error('User not found');
    }
    const passwordHash = this.hashPassword(password);
    return user.passwordHash === passwordHash;
  }

  async changePassword(username: string, oldPassword: string, newPassword: string): Promise<void> {
    const user = this.users.get(username);
    if (!user) {
      throw new Error('User not found');
    }
    const oldPasswordHash = this.hashPassword(oldPassword);
    if (user.passwordHash !== oldPasswordHash) {
      throw new Error('Incorrect old password');
    }
    user.passwordHash = this.hashPassword(newPassword);
  }
}

const auth = new Authentication();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
auth.authenticate('testuser', 'testpassword').then(result => {
  console.log('Authentication result:', result);
}).catch(err => {
  console.error('Error during authentication:', err);
});

SUFFIX CODE:
----------------------------------------
auth.authenticate('testuser', 'testpassword').then(result => {
  console.log('Authentication result:', result);
}).catch(err => {
  console.error('Error during authentication:', err);
});

// Clean-up code if necessary can be placed here


JUSTIFICATION:
----------------------------------------
This is a good test case for pattern matching because it demonstrates a clear pattern of asynchronous method calls within an authentication class. The completion required involves registering a new user, which is a logical extension of the provided prefix methods. The pattern of using async/await and handling promises is well-established in the prefix, making it identifiable for an LLM to follow. The suffix continues the pattern by authenticating a user, ensuring the pattern is clear and consistent.

ASSERTIONS:
----------------------------------------
auth.authenticate('testuser', 'testpassword').then(result => {
  console.assert(result === true, 'Test user should be authenticated');
  return auth.register('newuser', 'newpassword');
}).then(() => {
  return auth.authenticate('newuser', 'newpassword');
}).then(result => {
  console.assert(result === true, 'New user should be authenticated');
}).catch(err => {
  console.error('Assertion failed:', err);
});
================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface LogEntry {
    timestamp: Date;
    level: 'info' | 'warn' | 'error';
    message: string;
}

class Logger {
    private logFilePath: string;

    constructor(logFilePath: string) {
        this.logFilePath = logFilePath;
    }

    private formatLogEntry(entry: LogEntry): string {
        return `[${entry.timestamp.toISOString()}] [${entry.level}] ${entry.message}`;
    }

    public logInfo(message: string): void {
        const entry: LogEntry = {
            timestamp: new Date(),
            level: 'info',
            message: message
        };
        this.appendLogEntry(entry);
    }

    public logWarn(message: string): void {
        const entry: LogEntry = {
            timestamp: new Date(),
            level: 'warn',
            message: message
        };
        this.appendLogEntry(entry);
    }

    public logError(message: string): void {
        const entry: LogEntry = {
            timestamp: new Date(),
            level: 'error',
            message: message
        };
        this.appendLogEntry(entry);
    }

    private appendLogEntry(entry: LogEntry): void {
        const formattedEntry = this.formatLogEntry(entry) + '\n';
        fs.appendFileSync(this.logFilePath, formattedEntry);
    }
}

const logger = new Logger(path.join(__dirname, 'app.log'));
logger.logInfo('Application started');
logger.logWarn('Low disk space');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
logger.logError('Unhandled exception occurred');

SUFFIX CODE:
----------------------------------------
console.log('Log entries written to file.');

// Cleanup
try {
    fs.unlinkSync(path.join(__dirname, 'app.log'));
} catch (err) {
    console.error('Error cleaning up log file:', err);
}


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and continue a clear logging pattern established in the Logger class. The Logger class has methods for logging messages at different levels (info, warn, error). The pattern is well-defined and includes method names, parameter types, and internal logic for formatting and writing log entries. The golden completion must follow this pattern by adding a logError call with an appropriate message. This tests the model's understanding of consistent method usage and pattern continuation within a class structure.

ASSERTIONS:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

const logContent = fs.readFileSync(path.join(__dirname, 'app.log'), 'utf-8');
console.assert(logContent.includes('[info] Application started'), 'Info log entry missing');
console.assert(logContent.includes('[warn] Low disk space'), 'Warn log entry missing');
console.assert(logContent.includes('[error] Unhandled exception occurred'), 'Error log entry missing');

================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

// Define a generic interface for data processing
interface DataProcessor<T> {
    process(data: T): T;
}

// Implementation of a data processor for scientific computations
class ScientificDataProcessor implements DataProcessor<number[]> {
    process(data: number[]): number[] {
        return data.map(d => d * 2);
    }
}

// Implementation of a data processor for media processing
class MediaDataProcessor implements DataProcessor<Buffer> {
    process(data: Buffer): Buffer {
        return Buffer.from(data.toString('base64'), 'base64');
    }
}

// Function to process data with a given processor
function processData<T>(processor: DataProcessor<T>, data: T): T {
    return processor.process(data);
}

// Helper function to read a file asynchronously
async function readFileAsync(filePath: string): Promise<Buffer> {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Example usage of the data processors
async function main() {
    // Process scientific data
    const scientificProcessor = new ScientificDataProcessor();
    const scientificData = [1, 2, 3, 4, 5];
    const processedScientificData = processData(scientificProcessor, scientificData);
    console.log('Processed Scientific Data:', processedScientificData);

    // Process media data
    const mediaProcessor = new MediaDataProcessor();
    const mediaFilePath = path.join(__dirname, 'example.mp4');
    try {
        const mediaData = await readFileAsync(mediaFilePath);
        const processedMediaData = processData(mediaProcessor, mediaData);
        console.log('Processed Media Data:', processedMediaData.toString('base64'));
    } catch (error) {
        console.error('Error processing media data:', error);
    }
}

main().catch(console.error);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
class StringDataProcessor implements DataProcessor<string> {
    process(data: string): string {
        return data.toUpperCase();
    }
}

// Example usage of the string data processor
const stringProcessor = new StringDataProcessor();
const stringData = 'hello world';
const processedStringData = processData(stringProcessor, stringData);
console.log('Processed String Data:', processedStringData);

JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and extend a pattern involving generic data processors in TypeScript. The prefix establishes a clear pattern with multiple data processors implementing a generic interface and a function to process data using these processors. The golden_completion continues this pattern by adding another data processor for JSON data, demonstrating an understanding of the pattern and TypeScript generics. The assertions verify that the new processor works correctly and adheres to the established pattern.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

// Reuse the defined processors and functions from the prefix and golden_completion
const jsonProcessor = new JsonDataProcessor();
const jsonData = { key: 'value' };
const processedJsonData = processData(jsonProcessor, jsonData);
assert.deepEqual(processedJsonData, jsonData, 'The JSON data should be processed correctly');

const stringProcessor = new StringDataProcessor();
const stringData = 'hello world';
const processedStringData = processData(stringProcessor, stringData);
assert.equal(processedStringData, 'HELLO WORLD', 'The string data should be processed correctly');
================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// Data structure for representing a Matrix in scientific computing
class Matrix {
    data: number[][];
    rows: number;
    cols: number;

    constructor(rows: number, cols: number, initial: number = 0) {
        this.rows = rows;
        this.cols = cols;
        this.data = Array.from({ length: rows }, () => Array(cols).fill(initial));
    }

    // Method for adding another matrix to this matrix
    add(matrix: Matrix): Matrix {
        assert.strictEqual(this.rows, matrix.rows, 'Matrix row counts must match');
        assert.strictEqual(this.cols, matrix.cols, 'Matrix column counts must match');

        let result = new Matrix(this.rows, this.cols);
        for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.cols; j++) {
                result.data[i][j] = this.data[i][j] + matrix.data[i][j];
            }
        }
        return result;
    }

    // Method for subtracting another matrix from this matrix
    subtract(matrix: Matrix): Matrix {
        assert.strictEqual(this.rows, matrix.rows, 'Matrix row counts must match');
        assert.strictEqual(this.cols, matrix.cols, 'Matrix column counts must match');

        let result = new Matrix(this.rows, this.cols);
        for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.cols; j++) {
                result.data[i][j] = this.data[i][j] - matrix.data[i][j];
            }
        }
        return result;
    }

    // Method for multiplying this matrix by another matrix
    multiply(matrix: Matrix): Matrix {
        assert.strictEqual(this.cols, matrix.rows, 'Matrix column count of first must match row count of second');

        let result = new Matrix(this.rows, matrix.cols);
        for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < matrix.cols; j++) {
                for (let k = 0; k < this.cols; k++) {
                    result.data[i][j] += this.data[i][k] * matrix.data[k][j];
                }
            }
        }
        return result;
    }
}

// Sample matrices for testing
const matrixA = new Matrix(2, 2);
matrixA.data = [
    [1, 2],
    [3, 4]
];

const matrixB = new Matrix(2, 2);
matrixB.data = [
    [5, 6],
    [7, 8]
];

const matrixC = new Matrix(2, 2);
matrixC.data = [
    [1, 0],
    [0, 1]
];

// Testing matrix addition
const addedMatrix = matrixA.add(matrixB);
assert.deepStrictEqual(addedMatrix.data, [
    [6, 8],
    [10, 12]
]);

// Testing matrix subtraction
const subtractedMatrix = matrixA.subtract(matrixC);
assert.deepStrictEqual(subtractedMatrix.data, [
    [0, 2],
    [3, 3]
]);



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const multipliedMatrix1 = matrixB.multiply(matrixC);
assert.deepStrictEqual(multipliedMatrix1.data, [
    [5, 6],
    [7, 8]
]);

SUFFIX CODE:
----------------------------------------


const multipliedMatrix2 = matrixA.multiply(matrixB);
assert.deepStrictEqual(multipliedMatrix2.data, [
    [19, 22],
    [43, 50]
]);


JUSTIFICATION:
----------------------------------------
This test case is a good example of a clear pattern in the context of scientific computing, specifically matrix operations. The pattern established involves basic matrix operations (addition, subtraction, multiplication) following a consistent structure. The golden completion is the matrix multiplication test that follows the same pattern as the addition and subtraction tests. The assertions check for correct matrix multiplication results, ensuring the pattern is adhered to and the functionality is correct.

ASSERTIONS:
----------------------------------------
assert.deepStrictEqual(multipliedMatrix.data, [
    [1, 2],
    [3, 4]
]);
================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// Define a generic type to handle data with different structures
interface DataType<T> {
    id: number;
    data: T;
}

// A function to process data of type string
function processDataString(data: DataType<string>): string {
    return `Processed string data: ${data.data}`;
}

// A function to process data of type number
function processDataNumber(data: DataType<number>): string {
    return `Processed number data: ${data.data}`;
}

// Function to handle array of strings
function processDataArrayString(data: DataType<string[]>): string {
    return `Processed array of strings: ${data.data.join(', ')}`;
}

// Example data
const stringData: DataType<string> = { id: 1, data: 'example' };
const numberData: DataType<number> = { id: 2, data: 42 };
const arrayStringData: DataType<string[]> = { id: 3, data: ['one', 'two', 'three'] };

// Process the data using the functions
const processedString = processDataString(stringData);
const processedNumber = processDataNumber(numberData);
const processedArrayString = processDataArrayString(arrayStringData);

// Assertions to verify the processing
assert.strictEqual(processedString, 'Processed string data: example');
assert.strictEqual(processedNumber, 'Processed number data: 42');
assert.strictEqual(processedArrayString, 'Processed array of strings: one, two, three');

// Add a new function to process data of type boolean
function processDataBoolean(data: DataType<boolean>): string {
    return `Processed boolean data: ${data.data}`;
}

// Example data for boolean type
const booleanData: DataType<boolean> = { id: 4, data: true };

// Process the data using the new function
const processedBoolean = processDataBoolean(booleanData);

// Assertions to verify the new processing
assert.strictEqual(processedBoolean, 'Processed boolean data: true');

// Cleanup


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// No cleanup needed

SUFFIX CODE:
----------------------------------------
// Example data for object type
const objectData: DataType<{ key: string }> = { id: 5, data: { key: 'value' } };

// Process the data using the new function
const processedObject = processDataObject(objectData);

// Assertions to verify the new processing
assert.strictEqual(processedObject, 'Processed object data: {"key":"value"}');

// Cleanup


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and extend a pattern involving generic type definitions and specialized processing functions for different data types. The pattern is established with multiple examples of processing functions for various data types (string, number, array of strings, boolean) in the prefix. The task requires the LLM to add a new function to handle object data, following the same pattern. This scenario tests the LLM's understanding of TypeScript generics, function implementation, and consistency in handling different types, which are common tasks for TypeScript developers.

ASSERTIONS:
----------------------------------------
assert.strictEqual(processedString, 'Processed string data: example');
assert.strictEqual(processedNumber, 'Processed number data: 42');
assert.strictEqual(processedArrayString, 'Processed array of strings: one, two, three');
assert.strictEqual(processedBoolean, 'Processed boolean data: true');
assert.strictEqual(processedObject, 'Processed object data: {"key":"value"}');
================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface LogEntry {
    timestamp: Date;
    level: string;
    message: string;
}

class Logger {
    private logFilePath: string;

    constructor(logFilePath: string) {
        this.logFilePath = logFilePath;
    }

    private formatLogEntry(entry: LogEntry): string {
        return `[${entry.timestamp.toISOString()}] [${entry.level}] ${entry.message}`;
    }

    public async logInfo(message: string): Promise<void> {
        const entry: LogEntry = {
            timestamp: new Date(),
            level: 'INFO',
            message,
        };
        await this.writeLog(entry);
    }

    public async logWarning(message: string): Promise<void> {
        const entry: LogEntry = {
            timestamp: new Date(),
            level: 'WARNING',
            message,
        };
        await this.writeLog(entry);
    }

    public async logError(message: string): Promise<void> {
        const entry: LogEntry = {
            timestamp: new Date(),
            level: 'ERROR',
            message,
        };
        await this.writeLog(entry);
    }

    private async writeLog(entry: LogEntry): Promise<void> {
        const formattedEntry = this.formatLogEntry(entry);
        await fs.promises.appendFile(this.logFilePath, formattedEntry + '\n');
    }
}

const logger = new Logger(path.join(__dirname, 'system.log'));

(async () => {
    await logger.logInfo('System initialization complete.');
    await logger.logWarning('System is running low on memory.');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
    await logger.logError('System encountered an unexpected error.');

SUFFIX CODE:
----------------------------------------
    console.log('Logging complete.');
})();


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the model's ability to recognize and complete a pattern in an OOP context within a system operations logging scenario. The Logger class demonstrates a clear pattern for logging messages at different levels (INFO, WARNING, ERROR). The model must identify this pattern and correctly generate the logError method call. The completion involves non-trivial understanding as it requires recognizing the established methods and their usage.

ASSERTIONS:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

const logFilePath = path.join(__dirname, 'system.log');
(async () => {
    const logContent = await fs.promises.readFile(logFilePath, 'utf-8');
    console.assert(logContent.includes('System initialization complete.'), 'Log should contain system initialization message.');
    console.assert(logContent.includes('System is running low on memory.'), 'Log should contain memory warning message.');
    console.assert(logContent.includes('System encountered an unexpected error.'), 'Log should contain error message.');
    // Clean up
    await fs.promises.unlink(logFilePath);
})();

================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';

interface FileData {
    name: string;
    content: string;
}

class FileManager {
    private directory: string;

    constructor(directory: string) {
        this.directory = directory;
    }

    // A method to read a file and return its data
    public readFile(fileName: string): Promise<FileData> {
        return new Promise((resolve, reject) => {
            const filePath = path.join(this.directory, fileName);
            fs.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    return reject(err);
                }
                resolve({ name: fileName, content: data });
            });
        });
    }

    // A method to write data to a file
    public writeFile(fileData: FileData): Promise<void> {
        return new Promise((resolve, reject) => {
            const filePath = path.join(this.directory, fileData.name);
            fs.writeFile(filePath, fileData.content, 'utf8', (err) => {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    }

    // A method to delete a file
    public deleteFile(fileName: string): Promise<void> {
        return new Promise((resolve, reject) => {
            const filePath = path.join(this.directory, fileName);
            fs.unlink(filePath, (err) => {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    }

    // A method to list all files in the directory
    public listFiles(): Promise<string[]> {
        return new Promise((resolve, reject) => {
            fs.readdir(this.directory, (err, files) => {
                if (err) {
                    return reject(err);
                }
                resolve(files);
            });
        });
    }
}

// Example usage
const fileManager = new FileManager('/tmp');

(async () => {
    try {
        await fileManager.writeFile({ name: 'test.txt', content: 'Hello, world!' });
        const fileData = await fileManager.readFile('test.txt');
        console.log(fileData);
        const fileList = await fileManager.listFiles();
        console.log(fileList);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
        await fileManager.deleteFile('test.txt');

SUFFIX CODE:
----------------------------------------
        await fileManager.deleteFile('test.txt');
    } catch (error) {
        console.error('Error:', error);
    }
})();


JUSTIFICATION:
----------------------------------------
This example tests the ability of an LLM to recognize and complete a clear pattern in the context of asynchronous file operations using promises in TypeScript. The prefix establishes a pattern of asynchronous methods (readFile, writeFile, deleteFile, listFiles) and their usage. The completion should follow the established pattern by adding another file operation sequence (write and read) before the suffix continues with the delete operation. This tests the LLM's understanding of async patterns, promise handling, and file management in a realistic scenario.

ASSERTIONS:
----------------------------------------
import * as fs from 'fs';
import * as path from 'path';
import { strict as assert } from 'assert';

(async () => {
    const directory = '/tmp';
    const fileManager = new FileManager(directory);
    const exampleFilePath = path.join(directory, 'example.txt');

    try {
        // Write and read example file
        await fileManager.writeFile({ name: 'example.txt', content: 'Example content' });
        const exampleData = await fileManager.readFile('example.txt');
        assert.deepEqual(exampleData, { name: 'example.txt', content: 'Example content' });

        // Cleanup
        await fileManager.deleteFile('example.txt');
    } catch (error) {
        console.error('Error in assertions:', error);
    } finally {
        // Ensure file is deleted
        if (fs.existsSync(exampleFilePath)) {
            fs.unlinkSync(exampleFilePath);
        }
    }
})();

================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// Utility function to calculate the mean of an array of numbers
function calculateMean(arr: number[]): number {
    const sum = arr.reduce((acc, val) => acc + val, 0);
    return sum / arr.length;
}

// Utility function to calculate the median of an array of numbers
function calculateMedian(arr: number[]): number {
    const sortedArr = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(sortedArr.length / 2);

    if (sortedArr.length % 2 === 0) {
        return (sortedArr[mid - 1] + sortedArr[mid]) / 2;
    } else {
        return sortedArr[mid];
    }
}

// Utility function to calculate the mode of an array of numbers
function calculateMode(arr: number[]): number[] {
    const frequencyMap: { [key: number]: number } = {};
    arr.forEach(num => {
        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
    });

    const maxFrequency = Math.max(...Object.values(frequencyMap));
    return Object.keys(frequencyMap)
        .filter(num => frequencyMap[+num] === maxFrequency)
        .map(Number);
}

// Test data
const data = [1, 2, 2, 3, 4];

// Assertions
assert.strictEqual(calculateMean(data), 2.4);
assert.strictEqual(calculateMedian(data), 2);
assert.deepStrictEqual(calculateMode(data), [2]);

// Utility function to calculate the range of an array of numbers


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
function calculateRange(arr: number[]): number {
    return Math.max(...arr) - Math.min(...arr);
}

SUFFIX CODE:
----------------------------------------
// Further assertions
assert.strictEqual(calculateRange(data), 3);

// Cleanup code (if any) would go here

JUSTIFICATION:
----------------------------------------
This is a good test case because it establishes a clear pattern of utility functions for common statistical calculations (mean, median, mode). The pattern is recognizable and involves array manipulations and mathematical operations. The golden completion follows this pattern by implementing the calculation of the range. The assertions verify the correctness of the implementation, ensuring it adheres to the established pattern. This scenario tests the LLM's ability to recognize and continue the pattern of statistical computation functions.

ASSERTIONS:
----------------------------------------
assert.strictEqual(calculateRange(data), 3);
const newTestData = [5, 10, 15, 20, 25];
assert.strictEqual(calculateRange(newTestData), 20);
const edgeCaseData = [5];
assert.strictEqual(calculateRange(edgeCaseData), 0);
================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { assert } from 'chai';

// A utility function to generate random IDs
function generateId(): string {
    return Math.random().toString(36).substr(2, 9);
}

// A generic interface representing an entity with an ID
interface Entity {
    id: string;
}

// A class representing a user
class User implements Entity {
    constructor(public id: string, public name: string, public email: string) {}
}

// A class representing a product
class Product implements Entity {
    constructor(public id: string, public name: string, public price: number) {}
}

// A registry to store entities
class Registry<T extends Entity> {
    private items: Map<string, T> = new Map();

    // Add an item to the registry
    add(item: T): void {
        this.items.set(item.id, item);
    }

    // Remove an item from the registry by ID
    remove(id: string): void {
        this.items.delete(id);
    }

    // Get an item from the registry by ID
    get(id: string): T | undefined {
        return this.items.get(id);
    }

    // Get all items from the registry
    getAll(): T[] {
        return Array.from(this.items.values());
    }
}

// Create a user registry
const userRegistry = new Registry<User>();
// Add users to the registry
userRegistry.add(new User(generateId(), 'Alice', 'alice@example.com'));
userRegistry.add(new User(generateId(), 'Bob', 'bob@example.com'));
userRegistry.add(new User(generateId(), 'Charlie', 'charlie@example.com'));

// Create a product registry
const productRegistry = new Registry<Product>();
// Add products to the registry
productRegistry.add(new Product(generateId(), 'Laptop', 999.99));
productRegistry.add(new Product(generateId(), 'Smartphone', 499.99));
productRegistry.add(new Product(generateId(), 'Tablet', 299.99));

// Function to find users by name
function findUserByName(name: string): User | undefined {
    return userRegistry.getAll().find(user => user.name === name);
}

// Function to find products by name
function findProductByName(name: string): Product | undefined {
    return productRegistry.getAll().find(product => product.name === name);
}

// Function to update a user's email
function updateUserEmail(id: string, newEmail: string): void {
    const user = userRegistry.get(id);
    if (user) {
        user.email = newEmail;
    }
}

// Function to update a product's price
function updateProductPrice(id: string, newPrice: number): void {
    const product = productRegistry.get(id);
    if (product) {
        product.price = newPrice;
    }
}


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Function to clear all users from the registry
function clearUsers(): void {
    userRegistry.getAll().forEach(user => userRegistry.remove(user.id));
}

// Function to clear all products from the registry
function clearProducts(): void {
    productRegistry.getAll().forEach(product => productRegistry.remove(product.id));
}

SUFFIX CODE:
----------------------------------------

// Remove a user from the registry
function removeUserById(id: string): void {
    userRegistry.remove(id);
}

// Remove a product from the registry
function removeProductById(id: string): void {
    productRegistry.remove(id);
}

// Test cases
const testUserId = generateId();
const testUser = new User(testUserId, 'Test User', 'test@example.com');
userRegistry.add(testUser);
assert.equal(userRegistry.get(testUserId)?.name, 'Test User');
assert.equal(userRegistry.get(testUserId)?.email, 'test@example.com');

const testProductId = generateId();
const testProduct = new Product(testProductId, 'Test Product', 123.45);
productRegistry.add(testProduct);
assert.equal(productRegistry.get(testProductId)?.name, 'Test Product');
assert.equal(productRegistry.get(testProductId)?.price, 123.45);

// Cleanup
userRegistry.remove(testUserId);
productRegistry.remove(testProductId);


JUSTIFICATION:
----------------------------------------
This test case demonstrates the use of TypeScript generics and higher-order functions within the context of managing a registry of entities. The prefix establishes a clear pattern of creating registries for different types of entities, adding and retrieving them. The golden completion introduces a higher-order function that generalizes the removal of an entity by ID from a registry, following the established pattern. The suffix continues to use this pattern for specific types of entities. This scenario tests the model's ability to recognize and complete a pattern involving generics and higher-order functions.

ASSERTIONS:
----------------------------------------
const testUserId = generateId();
const testUser = new User(testUserId, 'Test User', 'test@example.com');
userRegistry.add(testUser);
removeEntityById(userRegistry, testUserId);
assert.isUndefined(userRegistry.get(testUserId));

const testProductId = generateId();
const testProduct = new Product(testProductId, 'Test Product', 123.45);
productRegistry.add(testProduct);
removeEntityById(productRegistry, testProductId);
assert.isUndefined(productRegistry.get(testProductId));

================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

interface DataPoint {
  x: number;
  y: number;
}

interface Statistics {
  mean: number;
  variance: number;
}

class DataAnalysis {
  private data: DataPoint[];

  constructor(data: DataPoint[]) {
    this.data = data;
  }

  public calculateMean(): number {
    const sum = this.data.reduce((acc, point) => acc + point.y, 0);
    return sum / this.data.length;
  }

  public calculateVariance(mean: number): number {
    const sum = this.data.reduce((acc, point) => acc + Math.pow(point.y - mean, 2), 0);
    return sum / (this.data.length - 1);
  }

  public getStatistics(): Statistics {
    const mean = this.calculateMean();
    const variance = this.calculateVariance(mean);
    return { mean, variance };
  }
}

const data: DataPoint[] = [
  { x: 1, y: 2 },
  { x: 2, y: 4 },
  { x: 3, y: 4 },
  { x: 4, y: 5 },
  { x: 5, y: 7 }
];

const analysis = new DataAnalysis(data);
const stats = analysis.getStatistics();
assert.strictEqual(stats.mean, 4.4);
assert.strictEqual(stats.variance, 3.3);

// Calculate median function
class DataAnalysis {
  private data: DataPoint[];

  constructor(data: DataPoint[]) {
    this.data = data;
  }

  public calculateMean(): number {
    const sum = this.data.reduce((acc, point) => acc + point.y, 0);
    return sum / this.data.length;
  }

  public calculateVariance(mean: number): number {
    const sum = this.data.reduce((acc, point) => acc + Math.pow(point.y - mean, 2), 0);
    return sum / (this.data.length - 1);
  }

  public getStatistics(): Statistics {
    const mean = this.calculateMean();
    const variance = this.calculateVariance(mean);
    return { mean, variance };
  }



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
  public calculateMedian(): number {
    const sorted = this.data.map(point => point.y).sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    if (sorted.length % 2 === 0) {
      return (sorted[mid - 1] + sorted[mid]) / 2;
    } else {
      return sorted[mid];
    }
  }

SUFFIX CODE:
----------------------------------------

}

const median = analysis.calculateMedian();
assert.strictEqual(median, 4);


JUSTIFICATION:
----------------------------------------
This test case establishes a clear pattern within the DataAnalysis class, specifically in the implementation of statistical methods (calculateMean, calculateVariance, getStatistics). The golden_completion requires the model to continue this pattern by implementing the calculateMedian method in a similar style. The assertions ensure that the calculateMedian method correctly computes the median of the dataset, verifying both the functional correctness and adherence to the established pattern.

ASSERTIONS:
----------------------------------------
assert.strictEqual(analysis.calculateMedian(), 4);
================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

// Helper function to generate a random integer between min and max
function getRandomInt(min: number, max: number): number {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Class representing a two-dimensional point
class Point {
  constructor(public x: number, public y: number) {}

  // Method to calculate the distance to another point
  distanceTo(other: Point): number {
    return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));
  }
}

// Class representing a rectangle
class Rectangle {
  constructor(public topLeft: Point, public bottomRight: Point) {}

  // Method to calculate the area of the rectangle
  area(): number {
    const width = Math.abs(this.bottomRight.x - this.topLeft.x);
    const height = Math.abs(this.bottomRight.y - this.topLeft.y);
    return width * height;
  }

  // Method to calculate the perimeter of the rectangle
  perimeter(): number {
    const width = Math.abs(this.bottomRight.x - this.topLeft.x);
    const height = Math.abs(this.bottomRight.y - this.topLeft.y);
    return 2 * (width + height);
  }
}

// Function to generate a random point within given bounds
function generateRandomPoint(xMin: number, xMax: number, yMin: number, yMax: number): Point {
  const x = getRandomInt(xMin, xMax);
  const y = getRandomInt(yMin, yMax);
  return new Point(x, y);
}

// Function to generate a random rectangle within given bounds
function generateRandomRectangle(xMin: number, xMax: number, yMin: number, yMax: number): Rectangle {
  const point1 = generateRandomPoint(xMin, xMax, yMin, yMax);
  const point2 = generateRandomPoint(xMin, xMax, yMin, yMax);
  return new Rectangle(point1, point2);
}

// Array to hold generated rectangles
const rectangles: Rectangle[] = [];

// Generate 5 random rectangles and add them to the array
for (let i = 0; i < 5; i++) {
  rectangles.push(generateRandomRectangle(0, 100, 0, 100));
}

// Calculate the total area of all generated rectangles
let totalArea = 0;
rectangles.forEach(rect => {
  totalArea += rect.area();
});

// Calculate the total perimeter of all generated rectangles
let totalPerimeter = 0;
rectangles.forEach(rect => {
  totalPerimeter += rect.perimeter();
});

// Log the total area and perimeter
console.log(`Total area: ${totalArea}`);
console.log(`Total perimeter: ${totalPerimeter}`);

// Assertions
assert(totalArea > 0, 'Total area should be greater than 0');
assert(totalPerimeter > 0, 'Total perimeter should be greater than 0');

// Function to find the rectangle with the largest area
function findLargestRectangleByArea(rects: Rectangle[]): Rectangle | null {
  if (rects.length === 0) return null;
  let largestRect = rects[0];
  let maxArea = largestRect.area();
  rects.forEach(rect => {
    const area = rect.area();
    if (area > maxArea) {
      largestRect = rect;
      maxArea = area;
    }
  });
  return largestRect;
}

// Function to find the rectangle with the largest perimeter
function findLargestRectangleByPerimeter(rects: Rectangle[]): Rectangle | null {
  if (rects.length === 0) return null;
  let largestRect = rects[0];
  let maxPerimeter = largestRect.perimeter();
  rects.forEach(rect => {
    const perimeter = rect.perimeter();
    if (perimeter > maxPerimeter) {
      largestRect = rect;
      maxPerimeter = perimeter;
    }
  });
  return largestRect;
}

// Example usage
const largestByArea = findLargestRectangleByArea(rectangles);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const largestByPerimeter = findLargestRectangleByPerimeter(rectangles);
console.log(`Largest rectangle by perimeter: ${largestByPerimeter?.perimeter()}`);

SUFFIX CODE:
----------------------------------------
console.log(`Largest rectangle by perimeter: ${largestByPerimeter?.perimeter()}`);

// Clean up resources if necessary (not needed in this example)



JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete an established pattern involving class methods and array operations in TypeScript. The scenario involves a clear pattern of creating and manipulating geometric shapes (rectangles) and calculating properties such as area and perimeter. The golden completion requires the model to correctly identify the method to find the largest rectangle by perimeter and continue the pattern of logging results, matching the established code structure and conventions.

ASSERTIONS:
----------------------------------------
assert(largestByArea !== null, 'There should be a rectangle with the largest area');
assert(largestByPerimeter !== null, 'There should be a rectangle with the largest perimeter');
assert(largestByArea!.area() >= 0, 'Largest rectangle by area should have non-negative area');
assert(largestByPerimeter!.perimeter() >= 0, 'Largest rectangle by perimeter should have non-negative perimeter');

================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

// Define a generic type Result which can contain a value or an error
interface Result<T> {
    value?: T;
    error?: string;
}

// A function to simulate a network request which returns a promise of Result
function fetchData(url: string): Promise<Result<string>> {
    return new Promise((resolve) => {
        setTimeout(() => {
            if (url === 'https://valid.url') {
                resolve({ value: 'Data from ' + url });
            } else {
                resolve({ error: 'Network error' });
            }
        }, 1000);
    });
}

// A function to process the result of the network request
function processResult(result: Result<string>): string {
    if (result.value) {
        return 'Processed: ' + result.value;
    } else {
        return 'Error: ' + result.error;
    }
}

// Main function to use fetchData and processResult
async function main() {
    const url = 'https://valid.url';
    const result = await fetchData(url);
    const processedResult = processResult(result);
    console.log(processedResult);

    // Assertions to verify correctness
    assert.strictEqual(result.value, 'Data from ' + url);
    assert.strictEqual(processedResult, 'Processed: Data from ' + url);
}

// Execute main function
main().then(() => console.log('Done')).catch((err) => console.error(err));

// Another example with an invalid URL
async function testErrorHandling() {
    const url = 'https://invalid.url';
    const result = await fetchData(url);
    const processedResult = processResult(result);
    console.log(processedResult);

    // Assertions to verify correctness
    assert.strictEqual(result.error, 'Network error');
    assert.strictEqual(processedResult, 'Error: Network error');
}

testErrorHandling().then(() => console.log('Error handling done')).catch((err) => console.error(err));

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
function fetchData(url: string): Promise<Result<string>> {
    return new Promise((resolve) => {
        setTimeout(() => {
            if (url === 'https://valid.url' || url === 'https://another.valid.url') {
                resolve({ value: 'Data from ' + url });
            } else {
                resolve({ error: 'Network error' });
            }
        }, 1000);
    });
}

SUFFIX CODE:
----------------------------------------
async function additionalTest() {
    const url = 'https://another.valid.url';
    const result = await fetchData(url);
    const processedResult = processResult(result);
    console.log(processedResult);

    // Assertions to verify correctness
    assert.strictEqual(result.value, 'Data from ' + url);
    assert.strictEqual(processedResult, 'Processed: Data from ' + url);
}

additionalTest().then(() => console.log('Additional test done')).catch((err) => console.error(err));

JUSTIFICATION:
----------------------------------------
This test case is a good test of pattern matching in TypeScript because it establishes a clear, repetitive pattern of handling network requests using async functions, processing the results, and verifying the outcomes with assertions. The pattern is evident through multiple examples in both the prefix and suffix sections, and the golden_completion must follow the same pattern to be correct. This ensures that the LLM needs to recognize and complete the established pattern accurately.

ASSERTIONS:
----------------------------------------
assert.strictEqual((await fetchData('https://another.invalid.url')).error, 'Network error');
assert.strictEqual(processResult(await fetchData('https://another.invalid.url')), 'Error: Network error');
================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as fs from 'fs';

// Helper function to read a file
function readFile(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf8', (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Helper function to write to a file
function writeFile(filePath: string, content: string): Promise<void> {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, content, 'utf8', (err) => {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

// Function to process file content
async function processFileContent(filePath: string, transformer: (content: string) => string): Promise<void> {
    try {
        const content = await readFile(filePath);
        const transformedContent = transformer(content);
        await writeFile(filePath, transformedContent);
    } catch (error) {
        console.error('Error processing file:', error);
    }
}

// Transformer function to convert text to uppercase
function toUpperCaseTransformer(content: string): string {
    return content.toUpperCase();
}

// Transformer function to replace spaces with hyphens
function replaceSpacesTransformer(content: string): string {
    return content.replace(/\s+/g, '-');
}

// Example usage
async function main() {
    const filePath = './example.txt';
    await processFileContent(filePath, toUpperCaseTransformer);
    await processFileContent(filePath, replaceSpacesTransformer);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
    await processFileContent(filePath, (content) => content.split('').reverse().join(''));
}

main().catch(console.error);

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a pattern of using higher-order functions to transform file content. The prefix establishes a clear pattern with multiple examples of transformer functions applied to the content. The golden completion follows this pattern by adding another transformer function that converts the content to lowercase, maintaining consistency with the established pattern of content transformation.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';
import * as fs from 'fs';

// Mocking fs.readFile and fs.writeFile
const originalReadFile = fs.readFile;
const originalWriteFile = fs.writeFile;
let fileContent = 'Hello World';
fs.readFile = (filePath: string, encoding: string, callback: (err: NodeJS.ErrnoException | null, data: string) => void) => {
    callback(null, fileContent);
};
fs.writeFile = (filePath: string, content: string, encoding: string, callback: (err: NodeJS.ErrnoException | null) => void) => {
    fileContent = content;
    callback(null);
};

// Run the main function
main().then(() => {
    // Assertions
    assert.strictEqual(fileContent, 'OLLEH-DLROW');

    // Restore original functions
    fs.readFile = originalReadFile;
    fs.writeFile = originalWriteFile;
}).catch(console.error);
================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

// Utility function to generate a random string
function generateRandomString(length: number): string {
    return crypto.randomBytes(length).toString('hex');
}

// Interface for User
interface User {
    id: string;
    username: string;
    password: string;
    email: string;
}

// Function to create a user
function createUser(username: string, password: string, email: string): User {
    return {
        id: generateRandomString(16),
        username,
        password: hashPassword(password),
        email
    };
}

// Function to hash passwords
function hashPassword(password: string): string {
    const salt = generateRandomString(8);
    const hash = crypto.createHmac('sha256', salt).update(password).digest('hex');
    return `${salt}$${hash}`;
}

// Function to verify passwords
function verifyPassword(password: string, hashedPassword: string): boolean {
    const [salt, originalHash] = hashedPassword.split('$');
    const hash = crypto.createHmac('sha256', salt).update(password).digest('hex');
    return hash === originalHash;
}

// Function to authenticate a user
function authenticateUser(users: User[], username: string, password: string): boolean {
    const user = users.find(u => u.username === username);
    if (!user) return false;
    return verifyPassword(password, user.password);
}

// Sample users array
const users: User[] = [
    createUser('john_doe', 'password123', 'john@example.com'),
    createUser('jane_doe', 'securePass456', 'jane@example.com')
];

// Helper function to log in a user
function loginUser(username: string, password: string): string {
    if (authenticateUser(users, username, password)) {
        return 'Login successful';
    }
    return 'Login failed';
}

// Helper function to register a user
function registerUser(username: string, password: string, email: string): string {
    if (users.find(u => u.username === username || u.email === email)) {
        return 'User already exists';
    }
    const newUser = createUser(username, password, email);
    users.push(newUser);
    return 'Registration successful';
}

// Example usage
const registrationStatus = registerUser('alice', 'alicePass789', 'alice@example.com');
console.log(registrationStatus);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log(users);

SUFFIX CODE:
----------------------------------------

const loginStatus = loginUser('alice', 'alicePass789');
console.log(loginStatus);

// Cleanup
users.pop();


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a pattern involving user registration and authentication in a security context. The prefix establishes functions for creating users, hashing and verifying passwords, and authenticating users. The completion must follow this established pattern by adding assertions to verify the correct functionality of the user registration and login processes. The example includes realistic scenarios and uses TypeScript-specific features like interfaces and type annotations.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';
assert.strictEqual(registrationStatus, 'Registration successful', 'User should be registered successfully');
assert.strictEqual(loginStatus, 'Login successful', 'User should be able to log in successfully');
================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse<T> {
	data: T;
	errors?: string[];
}

interface User {
	id: number;
	name: string;
	email: string;
}

interface Post {
	id: number;
	title: string;
	content: string;
	userId: number;
}

// Helper function to handle API responses
function handleApiResponse<T>(response: ApiResponse<T>): T {
	if (response.errors) {
		throw new Error(response.errors.join(', '));
	}
	return response.data;
}

// Fetch user by ID
async function fetchUserById(userId: number): Promise<User> {
	try {
		const response = await axios.get<ApiResponse<User>>(`/api/users/${userId}`);
		return handleApiResponse(response.data);
	} catch (error) {
		console.error('Failed to fetch user:', error);
		throw error;
	}
}

// Fetch posts by user ID
async function fetchPostsByUserId(userId: number): Promise<Post[]> {
	try {
		const response = await axios.get<ApiResponse<Post[]>>(`/api/users/${userId}/posts`);
		return handleApiResponse(response.data);
	} catch (error) {
		console.error('Failed to fetch posts:', error);
		throw error;
	}
}

// Example usage and assertions
(async () => {
	const userId = 1;
	const user = await fetchUserById(userId);
	console.log('User:', user);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
	const posts = await fetchPostsByUserId(userId);
	console.log('Posts:', posts);

SUFFIX CODE:
----------------------------------------

})();


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete an asynchronous pattern involving API calls and error handling. The prefix establishes a clear pattern with two similar functions for fetching user data and user posts, including error handling and response processing. The golden completion follows this established pattern by adding the function call to fetch posts and logging the results, ensuring consistency and proper error handling. The assertions verify that the functions work as intended, making this a realistic and practical scenario for pattern matching in TypeScript.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async () => {
	const userId = 1;
	const user = await fetchUserById(userId);
	assert.equal(user.id, userId, 'User ID should match the requested ID');
	assert.equal(typeof user.name, 'string', 'User name should be a string');
	assert.equal(typeof user.email, 'string', 'User email should be a string');

	const posts = await fetchPostsByUserId(userId);
	assert(Array.isArray(posts), 'Posts should be an array');
	if (posts.length > 0) {
		assert.equal(posts[0].userId, userId, 'Each post should belong to the user');
	}
	console.log('All assertions passed.');
})();
================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

// Define a generic type for API response
interface ApiResponse<T> {
    status: string;
    data: T;
}

// A higher-order function to handle API calls
function apiCall<T>(url: string, method: 'GET' | 'POST', data?: any): Promise<ApiResponse<T>> {
    return axios({ url, method, data })
        .then(response => ({ status: 'success', data: response.data }))
        .catch(error => ({ status: 'error', data: error.message }));
}

// Function to get user data
function getUserData(userId: string): Promise<ApiResponse<User>> {
    return apiCall<User>(`/api/users/${userId}`, 'GET');
}

// Function to create a new user
function createUser(data: Partial<User>): Promise<ApiResponse<User>> {
    return apiCall<User>('/api/users', 'POST', data);
}

// User interface
interface User {
    id: string;
    name: string;
    email: string;
}

// Function to update user data
function updateUser(userId: string, data: Partial<User>): Promise<ApiResponse<User>> {
    return apiCall<User>(`/api/users/${userId}`, 'POST', data);
}

// Function to delete a user
function deleteUser(userId: string): Promise<ApiResponse<null>> {
    return apiCall<null>(`/api/users/${userId}`, 'DELETE');
}

// Example usage of the functions
const userId = '123';

getUserData(userId).then(response => {
    console.log('User Data:', response);
});

createUser({ name: 'John Doe', email: 'john@example.com' }).then(response => {
    console.log('New User:', response);
});

// Additional function implementations following the same pattern


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
deleteUser(userId).then(response => {
    console.log('Delete User:', response);
});

SUFFIX CODE:
----------------------------------------
deleteUser(userId).then(response => {
    console.log('Delete User:', response);
});



JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and complete a higher-order function pattern in the context of API calls. The pattern involves a higher-order function 'apiCall' that handles API requests and returns a promise with a structured response. The completion should follow this pattern to implement an update user function correctly. The assertions will verify the pattern adherence and functionality.

ASSERTIONS:
----------------------------------------
import assert from 'assert';

(async () => {
    const mockResponse = { status: 'success', data: { id: '123', name: 'Jane Doe', email: 'jane@example.com' } };
    const mockError = { status: 'error', data: 'User not found' };

    // Mock axios to control the responses
    jest.mock('axios');
    const axios = require('axios');
    axios.mockImplementation(({ url, method, data }) => {
        if (url.includes('/api/users') && method === 'POST') {
            return Promise.resolve({ data: mockResponse.data });
        } else if (url.includes('/api/users') && method === 'GET') {
            return Promise.resolve({ data: mockResponse.data });
        } else if (url.includes('/api/users') && method === 'DELETE') {
            return Promise.resolve({ data: null });
        } else {
            return Promise.reject(new Error(mockError.data));
        }
    });

    // Verify getUserData
    const userData = await getUserData('123');
    assert.strictEqual(userData.status, 'success');
    assert.strictEqual(userData.data.name, 'Jane Doe');

    // Verify createUser
    const newUser = await createUser({ name: 'John Doe', email: 'john@example.com' });
    assert.strictEqual(newUser.status, 'success');
    assert.strictEqual(newUser.data.name, 'John Doe');

    // Verify updateUser
    const updatedUser = await updateUser('123', { name: 'Jane Doe' });
    assert.strictEqual(updatedUser.status, 'success');
    assert.strictEqual(updatedUser.data.name, 'Jane Doe');

    // Verify deleteUser
    const deletedUser = await deleteUser('123');
    assert.strictEqual(deletedUser.status, 'success');
})();

================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse<T> {
    data: T;
    status: number;
}

interface User {
    id: number;
    name: string;
    email: string;
}

async function fetchData<T>(url: string): Promise<ApiResponse<T>> {
    try {
        const response = await axios.get<T>(url);
        return {
            data: response.data,
            status: response.status
        };
    } catch (error) {
        throw new Error(`Failed to fetch data: ${error.message}`);
    }
}

async function fetchUser(userId: number): Promise<User> {
    const url = `https://api.example.com/users/${userId}`;
    const response = await fetchData<User>(url);
    return response.data;
}

async function fetchPost(postId: number): Promise<{ id: number; title: string; content: string }> {
    const url = `https://api.example.com/posts/${postId}`;
    const response = await fetchData<{ id: number; title: string; content: string }>(url);
    return response.data;
}

// More functions could be here...



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
export { fetchData, fetchUser, fetchPost };

SUFFIX CODE:
----------------------------------------


async function main() {
    try {
        const user = await fetchUser(1);
        console.log(user);

        const post = await fetchPost(1);
        console.log(post);
    } catch (error) {
        console.error(error);
    }
}

main();

JUSTIFICATION:
----------------------------------------
This test case is a good example for pattern matching in TypeScript as it involves async patterns and type definitions with generics in a network protocol context. The prefix establishes a clear pattern of using a generic async function to fetch data from an API and specific functions to fetch different types of data (User, Post). The golden completion continues this pattern by adding another function to fetch comments. The suffix uses the previously defined functions, making it clear that the pattern should be continued similarly. The scenario tests the LLM's ability to recognize and extend the established pattern correctly.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

async function testFetchComments() {
    // Mocking axios.get
    const axiosGet = axios.get as jest.Mock;
    axiosGet.mockResolvedValue({
        data: [
            { id: 1, postId: 1, content: 'Great post!' },
            { id: 2, postId: 1, content: 'Thanks for sharing!' }
        ],
        status: 200
    });

    const comments = await fetchComments(1);
    assert.strictEqual(comments.length, 2);
    assert.deepStrictEqual(comments[0], { id: 1, postId: 1, content: 'Great post!' });
    assert.deepStrictEqual(comments[1], { id: 2, postId: 1, content: 'Thanks for sharing!' });
}

// Run the test
await testFetchComments();
console.log('All assertions passed.');

================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

// Define a generic function to make API calls
async function fetchData<T>(url: string): Promise<T> {
  try {
    const response = await axios.get<T>(url);
    return response.data;
  } catch (error) {
    throw new Error('Failed to fetch data');
  }
}

// Define a generic function to post data to an API
async function postData<T>(url: string, data: T): Promise<void> {
  try {
    await axios.post(url, data);
  } catch (error) {
    throw new Error('Failed to post data');
  }
}

// Define a type for user data
interface User {
  id: number;
  name: string;
  email: string;
}

// Define a function to fetch user data
async function fetchUser(url: string): Promise<User> {
  return fetchData<User>(url);
}

// Define a function to post user data
async function submitUser(url: string, user: User): Promise<void> {
  return postData<User>(url, user);
}

// Test data
const testUser: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };
const apiUrl = 'https://api.example.com/user';

// Fetch user data
fetchUser(apiUrl).then((user) => {
  console.log('Fetched user:', user);
}).catch((error) => {
  console.error(error);
});

// Post user data
submitUser(apiUrl, testUser).then(() => {
  console.log('User data submitted successfully');
}).catch((error) => {
  console.error(error);
});


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
submitUser(apiUrl, { id: 2, name: 'Jane Doe', email: 'jane.doe@example.com' }).then(() => {
  console.log('Another user data submitted successfully');
}).catch((error) => {
  console.error(error);
});

SUFFIX CODE:
----------------------------------------
submitUser(apiUrl, { id: 2, name: 'Jane Doe', email: 'jane.doe@example.com' }).then(() => {
  console.log('Another user data submitted successfully');
}).catch((error) => {
  console.error(error);
});


JUSTIFICATION:
----------------------------------------
This test case involves async patterns and type definitions/generics, which are common in TypeScript when dealing with network protocols such as making API calls. The pattern of defining generic functions for fetching and posting data is established in the prefix. The golden completion continues this pattern by fetching user data, while the suffix demonstrates posting user data. This distinction tests the LLM's ability to recognize and complete the established pattern of using generic async functions for API interactions.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async () => {
  const mockUser: User = { id: 3, name: 'Test User', email: 'test.user@example.com' };
  const mockApiUrl = 'https://mockapi.example.com/user';

  // Mocking axios.get and axios.post
  axios.get = async <T>(url: string): Promise<{ data: T }> => ({ data: mockUser as any });
  axios.post = async (url: string, data: any): Promise<void> => { /* no-op */ };

  // Verify fetchUser function
  const user = await fetchUser(mockApiUrl);
  assert.deepEqual(user, mockUser, 'fetchUser should return the correct user data');

  // Verify submitUser function
  await assert.doesNotReject(async () => await submitUser(mockApiUrl, mockUser), 'submitUser should not throw an error');

  // Verify the fetchUser call in golden_completion
  const anotherUser = await fetchUser(mockApiUrl);
  assert.deepEqual(anotherUser, mockUser, 'fetchUser should return the correct user data');
})();

================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import fetch from 'node-fetch';

// Function to handle API requests
async function fetchData(url: string): Promise<any> {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching data:', error);
        throw error;
    }
}

// Function to get user data
async function getUserData(userId: string): Promise<any> {
    const apiUrl = `https://api.example.com/users/${userId}`;
    try {
        const userData = await fetchData(apiUrl);
        return userData;
    } catch (error) {
        console.error('Error getting user data:', error);
        throw error;
    }
}

// Function to get post data
async function getPostData(postId: string): Promise<any> {
    const apiUrl = `https://api.example.com/posts/${postId}`;
    try {
        const postData = await fetchData(apiUrl);
        return postData;
    } catch (error) {
        console.error('Error getting post data:', error);
        throw error;
    }
}

// Function to get comments for a post
async function getComments(postId: string): Promise<any[]> {
    const apiUrl = `https://api.example.com/posts/${postId}/comments`;
    try {
        const comments = await fetchData(apiUrl);
        return comments;
    } catch (error) {
        console.error('Error getting comments:', error);
        throw error;
    }
}

// Function to get user posts
async function getUserPosts(userId: string): Promise<any[]> {
    const apiUrl = `https://api.example.com/users/${userId}/posts`;
    try {
        const posts = await fetchData(apiUrl);
        return posts;
    } catch (error) {
        console.error('Error getting user posts:', error);
        throw error;
    }
}

// Function to get user comments
async function getUserComments(userId: string): Promise<any[]> {
    const apiUrl = `https://api.example.com/users/${userId}/comments`;
    try {
        const comments = await fetchData(apiUrl);
        return comments;
    } catch (error) {
        console.error('Error getting user comments:', error);
        throw error;
    }
}



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
async function getPostAuthor(postId: string): Promise<any> {

SUFFIX CODE:
----------------------------------------
async function getPostAuthor(postId: string): Promise<any> {
    const apiUrl = `https://api.example.com/posts/${postId}/author`;
    try {
        const author = await fetchData(apiUrl);
        return author;
    } catch (error) {
        console.error('Error getting post author:', error);
        throw error;
    }
}


JUSTIFICATION:
----------------------------------------
This test case is a good example for checking an LLM's ability to recognize and continue a pattern of async functions handling API requests and error handling. The prefix establishes a clear pattern of functions that fetch data from specific endpoints, handle errors, and return the results. The completion should follow this pattern, and the assertions will verify that the completion maintains consistency and correctness in both functionality and error handling.

ASSERTIONS:
----------------------------------------
import assert from 'assert';

(async () => {
    const mockUserId = '123';
    const mockApiResponse = [{ id: '1', title: 'Mock Album' }];

    // Mock fetch function
    global.fetch = async (url: string) => {
        return {
            ok: true,
            json: async () => mockApiResponse
        };
    };

    const albums = await getUserAlbums(mockUserId);
    assert.deepStrictEqual(albums, mockApiResponse, 'The returned albums should match the mock API response');

    // Restore the original fetch function
    delete global.fetch;
})();

================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { EventEmitter } from 'events';

interface GameState {
	score: number;
	level: number;
	isGameOver: boolean;
}

class Game extends EventEmitter {
	private state: GameState;

	constructor() {
		super();
		this.state = { score: 0, level: 1, isGameOver: false };
	}

	public start() {
		this.emit('start');
	}

	public end() {
		this.state.isGameOver = true;
		this.emit('end');
	}

	public scorePoint() {
		this.state.score += 1;
		this.emit('score', this.state.score);
	}

	public levelUp() {
		this.state.level += 1;
		this.emit('levelUp', this.state.level);
	}
}

const game = new Game();

game.on('start', () => {
	console.log('Game started!');
});

game.on('end', () => {
	console.log('Game over!');
});

game.on('score', (score) => {
	console.log(`Score: ${score}`);
});

game.on('levelUp', (level) => {
	console.log(`Level: ${level}`);
});

// Start the game
console.log('Initiating game...');
game.start();

// Simulate scoring points
for (let i = 0; i < 10; i++) {
	game.scorePoint();
}

// Simulate leveling up
for (let i = 0; i < 3; i++) {
	game.levelUp();
}

// End the game
console.log('Ending game...');
game.end();



LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log('Game session complete.');

SUFFIX CODE:
----------------------------------------
console.log('Game session complete.');


JUSTIFICATION:
----------------------------------------
This test case checks the LLM's ability to recognize and complete a pattern of event handling in a game context. The prefix establishes a pattern of event registration and handling using the EventEmitter class. The completion must follow this pattern by adding appropriate event handling code for the 'end' event, which includes logging the final score and level. This pattern is common in game development for managing game states and events. The assertions verify that the completion adheres to the established pattern and performs the expected actions.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

let finalScore = 0;
let finalLevel = 0;

// Mock console.log to capture output
const originalLog = console.log;
const logOutput: string[] = [];
console.log = (message: string) => {
	logOutput.push(message);
	if (message.startsWith('Final Score: ')) {
		finalScore = parseInt(message.split(': ')[1], 10);
	}
	if (message.startsWith('Final Level: ')) {
		finalLevel = parseInt(message.split(': ')[1], 10);
	}
};

// Assertions
assert(logOutput.includes('Game started!'), 'Game should start');
assert(logOutput.includes('Game over!'), 'Game should end');
assert(logOutput.includes('Score: 10'), 'Final score should be 10');
assert(logOutput.includes('Level: 4'), 'Final level should be 4');
assert(finalScore === 10, `Expected final score to be 10, but got ${finalScore}`);
assert(finalLevel === 4, `Expected final level to be 4, but got ${finalLevel}`);

// Restore original console.log
console.log = originalLog;

================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse<T> {
	data: T;
	status: number;
	statusText: string;
	headers: any;
	config: any;
	request?: any;
}

class ApiService {
	private baseUrl: string;

	constructor(baseUrl: string) {
		this.baseUrl = baseUrl;
	}

	async get<T>(endpoint: string): Promise<ApiResponse<T>> {
		try {
			const response = await axios.get<T>(`${this.baseUrl}${endpoint}`);
			return {
				data: response.data,
				status: response.status,
				statusText: response.statusText,
				headers: response.headers,
				config: response.config,
				request: response.request,
			};
		} catch (error) {
			throw new Error(`GET request failed: ${error.message}`);
		}
	}

	async post<T>(endpoint: string, body: any): Promise<ApiResponse<T>> {
		try {
			const response = await axios.post<T>(`${this.baseUrl}${endpoint}`, body);
			return {
				data: response.data,
				status: response.status,
				statusText: response.statusText,
				headers: response.headers,
				config: response.config,
				request: response.request,
			};
		} catch (error) {
			throw new Error(`POST request failed: ${error.message}`);
		}
	}

	// The PUT method needs to follow the same pattern


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
	async put<T>(endpoint: string, body: any): Promise<ApiResponse<T>> {
		try {
			const response = await axios.put<T>(`${this.baseUrl}${endpoint}`, body);
			return {
				data: response.data,
				status: response.status,
				statusText: response.statusText,
				headers: response.headers,
				config: response.config,
				request: response.request,
			};
		} catch (error) {
			throw new Error(`PUT request failed: ${error.message}`);
		}
	}

SUFFIX CODE:
----------------------------------------


	async delete<T>(endpoint: string): Promise<ApiResponse<T>> {
		try {
			const response = await axios.delete<T>(`${this.baseUrl}${endpoint}`);
			return {
				data: response.data,
				status: response.status,
				statusText: response.statusText,
				headers: response.headers,
				config: response.config,
				request: response.request,
			};
		} catch (error) {
			throw new Error(`DELETE request failed: ${error.message}`);
		}
	}
}

// Example usage
(async () => {
	const api = new ApiService('https://api.example.com');

	try {
		const getResponse = await api.get<any>('/data');
		console.log('GET Response:', getResponse);

		const postResponse = await api.post<any>('/data', { key: 'value' });
		console.log('POST Response:', postResponse);

		const putResponse = await api.put<any>('/data', { key: 'newValue' });
		console.log('PUT Response:', putResponse);

		const deleteResponse = await api.delete<any>('/data');
		console.log('DELETE Response:', deleteResponse);
	} catch (error) {
		console.error('API Error:', error.message);
	}
})();

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to recognize and continue a pattern of implementing common HTTP methods (GET, POST, PUT, DELETE) within a TypeScript class that handles API requests. The pattern involves wrapping axios calls in methods that return a consistent ApiResponse structure and handle errors uniformly. The `put` method is missing and needs to follow the same pattern as the `get` and `post` methods already defined in the class. This scenario is realistic, as it mirrors typical patterns in services that interact with RESTful APIs, and it tests the model's ability to maintain consistency in method implementation.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async () => {
	const api = new ApiService('https://api.example.com');

	try {
		const putResponse = await api.put<any>('/data', { key: 'newValue' });
		assert.equal(putResponse.status, 200, 'PUT request should return status 200');
		assert.equal(putResponse.data.key, 'newValue', 'PUT request should update data correctly');
	} catch (error) {
		assert.fail(`PUT request failed: ${error.message}`);
	}
})();
================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse<T> {
    status: number;
    data: T;
    error?: string;
}

async function fetchUserData(userId: string): Promise<ApiResponse<{ name: string; email: string }>> {
    try {
        const response = await axios.get(`https://api.example.com/users/${userId}`);
        return {
            status: response.status,
            data: response.data
        };
    } catch (error) {
        return {
            status: error.response ? error.response.status : 500,
            error: error.message,
            data: { name: '', email: '' }
        };
    }
}

async function fetchProductData(productId: string): Promise<ApiResponse<{ title: string; price: number }>> {
    try {
        const response = await axios.get(`https://api.example.com/products/${productId}`);
        return {
            status: response.status,
            data: response.data
        };
    } catch (error) {
        return {
            status: error.response ? error.response.status : 500,
            error: error.message,
            data: { title: '', price: 0 }
        };
    }
}

async function fetchOrderData(orderId: string): Promise<ApiResponse<{ orderId: string; amount: number }>> {
    try {
        const response = await axios.get(`https://api.example.com/orders/${orderId}`);
        return {
            status: response.status,
            data: response.data
        };
    } catch (error) {
        return {
            status: error.response ? error.response.status : 500,
            error: error.message,
            data: { orderId: '', amount: 0 }
        };
    }
}

// The pattern is to create an async function to fetch data, handle errors, and return a typed response


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
async function fetchInvoiceData(invoiceId: string): Promise<ApiResponse<{ invoiceId: string; total: number }>> {
    try {
        const response = await axios.get(`https://api.example.com/invoices/${invoiceId}`);
        return {
            status: response.status,
            data: response.data
        };
    } catch (error) {
        return {
            status: error.response ? error.response.status : 500,
            error: error.message,
            data: { invoiceId: '', total: 0 }
        };
    }
}

SUFFIX CODE:
----------------------------------------


(async () => {
    const invoiceData = await fetchInvoiceData('inv123');
    console.log(invoiceData);
})();


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and continue a clear pattern of async functions fetching data from an API, handling errors, and returning a typed response. The prefix establishes the pattern with three similar functions. The golden completion requires the LLM to follow this pattern for a new function, while the suffix demonstrates a deviation from the expected pattern. This scenario tests the LLM's understanding of async/await, error handling, and TypeScript generics.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async () => {
    const userData = await fetchUserData('user123');
    assert.equal(userData.status, 200);
    assert.equal(typeof userData.data.name, 'string');
    assert.equal(typeof userData.data.email, 'string');

    const productData = await fetchProductData('product123');
    assert.equal(productData.status, 200);
    assert.equal(typeof productData.data.title, 'string');
    assert.equal(typeof productData.data.price, 'number');

    const orderData = await fetchOrderData('order123');
    assert.equal(orderData.status, 200);
    assert.equal(typeof orderData.data.orderId, 'string');
    assert.equal(typeof orderData.data.amount, 'number');

    const invoiceData = await fetchInvoiceData('inv123');
    assert.equal(invoiceData.status, 200);
    assert.equal(typeof invoiceData.data.invoiceId, 'string');
    assert.equal(typeof invoiceData.data.total, 'number');
})();

================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

interface User {
  id: string;
  username: string;
  password: string;
}

interface AuthResult {
  success: boolean;
  token?: string;
  error?: string;
}

function hashPassword(password: string): string {
  const hash = crypto.createHash('sha256');
  hash.update(password);
  return hash.digest('hex');
}

function generateToken(userId: string): string {
  return crypto.randomBytes(16).toString('hex') + userId;
}

function authenticate(username: string, password: string, users: User[]): AuthResult {
  const user = users.find(u => u.username === username);
  if (!user) {
    return { success: false, error: 'User not found' };
  }
  const hashedPassword = hashPassword(password);
  if (user.password !== hashedPassword) {
    return { success: false, error: 'Invalid password' };
  }
  const token = generateToken(user.id);
  return { success: true, token };
}

const users: User[] = [
  { id: '1', username: 'user1', password: hashPassword('password1') },
  { id: '2', username: 'user2', password: hashPassword('password2') },
];

// Sample usage and assertions
const result1 = authenticate('user1', 'password1', users);
console.assert(result1.success === true, 'User1 should authenticate successfully');
console.assert(typeof result1.token === 'string', 'User1 should receive a token');

const result2 = authenticate('user1', 'wrongpassword', users);
console.assert(result2.success === false, 'User1 with wrong password should not authenticate');
console.assert(result2.error === 'Invalid password', 'User1 with wrong password should receive an error message');

const result3 = authenticate('nonexistent', 'password', users);
console.assert(result3.success === false, 'Non-existent user should not authenticate');
console.assert(result3.error === 'User not found', 'Non-existent user should receive an error message');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
console.log('All tests passed successfully.');

SUFFIX CODE:
----------------------------------------


// Cleanup code if necessary
// No resources to clean up in this example


JUSTIFICATION:
----------------------------------------
This test case demonstrates a clear pattern of user authentication with proper error handling. The prefix includes three examples of the pattern for authenticating users and verifying the result. The golden completion continues this pattern by adding another test case for a different user. This scenario is realistic for security contexts, involves TypeScript-specific features like interfaces, and includes robust assertions to verify both functionality and pattern adherence.

ASSERTIONS:
----------------------------------------
const result4 = authenticate('user2', 'password2', users);
console.assert(result4.success === true, 'User2 should authenticate successfully');
console.assert(typeof result4.token === 'string', 'User2 should receive a token');
================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse<T> {
    status: number;
    data: T;
}

interface User {
    id: number;
    name: string;
    email: string;
}

// Function to handle API responses with generics
function handleApiResponse<T>(response: ApiResponse<T>): T | null {
    if (response.status === 200) {
        return response.data;
    } else {
        console.error(`API Error: ${response.status}`);
        return null;
    }
}

// Function to fetch user data from an API
async function fetchUserData(userId: number): Promise<User | null> {
    try {
        const response = await axios.get<ApiResponse<User>>(`/api/users/${userId}`);
        return handleApiResponse(response.data);
    } catch (error) {
        console.error(`Failed to fetch user data: ${error}`);
        return null;
    }
}

// Fetch and handle user data for multiple users
async function fetchMultipleUsers(userIds: number[]): Promise<(User | null)[]> {
    const userPromises = userIds.map(fetchUserData);
    return Promise.all(userPromises);
}

// Function to fetch and log user data
async function logUserData(userId: number): Promise<void> {
    const user = await fetchUserData(userId);
    if (user) {
        console.log(`User: ${user.name}, Email: ${user.email}`);
    } else {
        console.log('User not found');
    }
}

// Testing the functions
(async () => {
    const userIds = [1, 2, 3];
    const users = await fetchMultipleUsers(userIds);
    users.forEach(user => {
        if (user) {
            console.log(`Fetched User: ${user.name}, Email: ${user.email}`);
        } else {
            console.log('User not found');
        }
    });
})();



LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------

(async () => {
    await logUserData(4);
    await logUserData(5);
})();


JUSTIFICATION:
----------------------------------------
This test case is a good example because it establishes a clear pattern of handling API responses using generics and TypeScript types. The prefix includes multiple functions that follow this pattern, making it evident for an LLM to recognize. The completion requires the LLM to continue this pattern by adding a new function that fetches all users from an API, handling errors and using the `handleApiResponse` function to process the response. This scenario is realistic and tests the LLM's ability to maintain consistency with established patterns while implementing a new function.

ASSERTIONS:
----------------------------------------
import assert from 'assert';

(async () => {
    const mockUserResponse = { status: 200, data: [{ id: 1, name: 'John Doe', email: 'john@example.com' }] };
    axios.get = async (url: string) => ({ data: mockUserResponse });

    const users = await fetchAllUsers();
    assert.strictEqual(users.length, 1, 'Should fetch one user');
    assert.strictEqual(users[0].name, 'John Doe', 'User name should be John Doe');
    assert.strictEqual(users[0].email, 'john@example.com', 'User email should be john@example.com');
})();

================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

// Utility function to generate a random string
function generateRandomString(length: number): string {
	return crypto.randomBytes(length).toString('hex');
}

// Higher-order function to handle encryption
function withEncryption<T>(data: T, key: string, encrypt: (data: T, key: string) => string): string {
	try {
		const encryptedData = encrypt(data, key);
		console.log('Encryption successful');
		return encryptedData;
	} catch (error) {
		console.error('Encryption failed', error);
		throw error;
	}
}

// Higher-order function to handle decryption
function withDecryption<T>(data: string, key: string, decrypt: (data: string, key: string) => T): T {
	try {
		const decryptedData = decrypt(data, key);
		console.log('Decryption successful');
		return decryptedData;
	} catch (error) {
		console.error('Decryption failed', error);
		throw error;
	}
}

// Example encrypt function
function encryptData(data: string, key: string): string {
	const cipher = crypto.createCipher('aes-256-cbc', key);
	let encrypted = cipher.update(data, 'utf8', 'hex');
	encrypted += cipher.final('hex');
	return encrypted;
}

// Example decrypt function
function decryptData(data: string, key: string): string {
	const decipher = crypto.createDecipher('aes-256-cbc', key);
	let decrypted = decipher.update(data, 'hex', 'utf8');
	decrypted += decipher.final('utf8');
	return decrypted;
}

// Test data and key
const testData = 'Sensitive Information';
const testKey = generateRandomString(32);

// Encrypt the test data
const encryptedData = withEncryption(testData, testKey, encryptData);

// Assertions to verify encryption
import assert from 'assert';
assert.notStrictEqual(encryptedData, testData, 'Encrypted data should not match original data');
assert.strictEqual(typeof encryptedData, 'string', 'Encrypted data should be a string');


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------
// Decrypt the test data
const decryptedData = withDecryption(encryptedData, testKey, decryptData);

// Assertions to verify decryption
assert.strictEqual(decryptedData, testData, 'Decrypted data should match original data');
assert.strictEqual(typeof decryptedData, 'string', 'Decrypted data should be a string');

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case is valuable for evaluating an LLM's ability to recognize and complete the pattern of higher-order functions handling encryption and decryption in a security context. The prefix establishes a clear pattern using higher-order functions for encryption and decryption, along with appropriate error handling. The completion should follow this pattern by implementing the decryption part and adding assertions to verify the correctness. The provided assertions ensure that the pattern is correctly followed and the functionality is accurate, making it a realistic and practical scenario for testing pattern recognition in TypeScript.

ASSERTIONS:
----------------------------------------
assert.strictEqual(decryptedData, testData, 'Decrypted data should match original data');
assert.strictEqual(typeof decryptedData, 'string', 'Decrypted data should be a string');
================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse {
    data: any;
    status: number;
}

function handleApiResponse(response: ApiResponse): void {
    if (response.status === 200) {
        console.log('Success:', response.data);
    } else {
        console.error('Error:', response.status);
    }
}

function fetchUserData(userId: string): Promise<ApiResponse> {
    return axios.get(`https://api.example.com/users/${userId}`)
        .then(response => ({ data: response.data, status: response.status }))
        .catch(error => ({ data: error.message, status: error.response?.status || 500 }));
}

function fetchPosts(userId: string): Promise<ApiResponse> {
    return axios.get(`https://api.example.com/users/${userId}/posts`)
        .then(response => ({ data: response.data, status: response.status }))
        .catch(error => ({ data: error.message, status: error.response?.status || 500 }));
}

async function fetchUserAndPosts(userId: string): Promise<void> {
    try {
        const userResponse = await fetchUserData(userId);
        handleApiResponse(userResponse);

        const postsResponse = await fetchPosts(userId);
        handleApiResponse(postsResponse);
    } catch (error) {
        console.error('Unexpected error:', error);
    }
}

// The following function fetches comments for a specific post
async function fetchComments(postId: string): Promise<void> {
    try {
        const response = await axios.get(`https://api.example.com/posts/${postId}/comments`);
        const comments: ApiResponse = { data: response.data, status: response.status };
        handleApiResponse(comments);
    } catch (error) {
        handleApiResponse({ data: error.message, status: error.response?.status || 500 });
    }
}

// The following function fetches albums for a specific user
async function fetchAlbums(userId: string): Promise<void> {
    try {
        const response = await axios.get(`https://api.example.com/users/${userId}/albums`);
        const albums: ApiResponse = { data: response.data, status: response.status };
        handleApiResponse(albums);
    } catch (error) {
        handleApiResponse({ data: error.message, status: error.response?.status || 500 });
    }
}

// The following function fetches photos for a specific album


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
async function fetchPhotos(albumId: string): Promise<void> {
    try {
        const response = await axios.get(`https://api.example.com/albums/${albumId}/photos`);
        const photos: ApiResponse = { data: response.data, status: response.status };
        handleApiResponse(photos);
    } catch (error) {
        handleApiResponse({ data: error.message, status: error.response?.status || 500 });
    }
}

SUFFIX CODE:
----------------------------------------


fetchUserAndPosts('123');
fetchComments('456');
fetchAlbums('123');
fetchPhotos('789');

JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching in TypeScript as it requires the LLM to recognize the pattern of handling API responses using async/await and proper error handling. The prefix establishes a clear pattern of fetching data from different endpoints and processing the responses in a consistent manner. The golden completion must follow this established pattern to ensure consistency and correctness. This is representative of real-world scenarios where developers often need to handle multiple API calls with similar response handling logic.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

async function testFetchPhotos() {
    let handledResponse: ApiResponse | null = null;
    function mockHandleApiResponse(response: ApiResponse) {
        handledResponse = response;
    }

    const originalHandleApiResponse = handleApiResponse;
    handleApiResponse = mockHandleApiResponse;
    try {
        await fetchPhotos('789');
        assert(handledResponse !== null, 'Response should have been handled');
        assert(handledResponse.status === 200 || handledResponse.status === 500, 'Response status should be 200 or 500');
    } finally {
        handleApiResponse = originalHandleApiResponse;
    }
}

testFetchPhotos().then(() => console.log('All assertions passed.')).catch(console.error);
================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { assert } from "assert";

interface ApiResponse<T> {
    status: number;
    data: T;
    error?: string;
}

function fetchData<T>(url: string): Promise<ApiResponse<T>> {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (url === "https://api.example.com/data") {
                resolve({ status: 200, data: { message: "Success" } as unknown as T });
            } else {
                reject({ status: 404, error: "Not Found" });
            }
        }, 1000);
    });
}

async function getApiData<T>(url: string): Promise<T> {
    try {
        const response = await fetchData<T>(url);
        if (response.status === 200) {
            return response.data;
        } else {
            throw new Error(response.error);
        }
    } catch (error) {
        throw new Error(`Failed to fetch data: ${error.message}`);
    }
}

async function processApiData(url: string): Promise<void> {
    try {
        const data = await getApiData<{ message: string }>(url);
        console.log(data.message);
    } catch (error) {
        console.error(error.message);
    }
}

// Example usage
processApiData("https://api.example.com/data");
processApiData("https://api.example.com/invalid");

// Tests
async function testApiData() {
    // Successful fetch
    const successData = await getApiData<{ message: string }>("https://api.example.com/data");
    assert.strictEqual(successData.message, "Success");

    // Failed fetch
    try {
        await getApiData<{ message: string }>("https://api.example.com/invalid");
    } catch (error) {
        assert.strictEqual(error.message, "Failed to fetch data: Not Found");
    }
}

testApiData().then(() => console.log("All tests passed."));


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
async function logApiData(url: string): Promise<void> {
    try {
        const data = await getApiData<{ message: string }>(url);
        console.log(data.message);
    } catch (error) {
        console.error(error.message);
    }
}

SUFFIX CODE:
----------------------------------------


// Example usage
logApiData("https://api.example.com/data");
logApiData("https://api.example.com/invalid");


JUSTIFICATION:
----------------------------------------
This scenario tests the LLM's ability to recognize and continue an async pattern involving API calls with error handling. The prefix establishes a pattern of fetching data from an API, handling errors, and processing the data. The golden completion continues this pattern by implementing a similar function that logs the fetched data or error message. The suffix provides a different continuation to ensure the distinction between the completion and the following code. This tests the LLM's ability to maintain consistency in async operations and error handling within a TypeScript context, which is critical for many real-world applications.

ASSERTIONS:
----------------------------------------
import { strict as assert } from "assert";

async function testLogApiData() {
    // Successful fetch
    const consoleLog = console.log;
    const consoleError = console.error;
    let logOutput = "";
    let errorOutput = "";
    console.log = (message: string) => { logOutput = message; };
    console.error = (message: string) => { errorOutput = message; };

    await logApiData("https://api.example.com/data");
    assert.strictEqual(logOutput, "Data fetched: Success");
    assert.strictEqual(errorOutput, "");

    // Failed fetch
    await logApiData("https://api.example.com/invalid");
    assert.strictEqual(logOutput, "");
    assert.strictEqual(errorOutput, "Error: Not Found");

    // Restore console functions
    console.log = consoleLog;
    console.error = consoleError;
}

testLogApiData().then(() => console.log("All logApiData tests passed."));

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse<T> {
    data: T;
    status: number;
}

interface User {
    id: number;
    name: string;
}

// Higher-order function to handle API calls with retry logic
function withRetry<T>(fn: () => Promise<ApiResponse<T>>, retries: number): Promise<ApiResponse<T>> {
    return fn().catch((error) => {
        if (retries > 0) {
            console.log(`Retrying... ${retries} attempts left`);
            return withRetry(fn, retries - 1);
        } else {
            throw error;
        }
    });
}

// Function to fetch user data
async function fetchUserData(userId: number): Promise<ApiResponse<User>> {
    try {
        const response = await axios.get<ApiResponse<User>>(`/api/users/${userId}`);
        return response.data;
    } catch (error) {
        console.error('Error fetching user data:', error);
        throw error;
    }
}

// Function to fetch multiple users data with retry logic
async function fetchMultipleUsers(userIds: number[]): Promise<ApiResponse<User>[]> {
    const promises = userIds.map(id => withRetry(() => fetchUserData(id), 3));
    return Promise.all(promises);
}

// Example usage
(async () => {
    const userIds = [1, 2, 3];
    try {
        const users = await fetchMultipleUsers(userIds);
        console.log('Fetched users:', users);
    } catch (error) {
        console.error('Failed to fetch users:', error);
    }
})();


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
interface Post {
    id: number;
    title: string;
    content: string;
    userId: number;
}

SUFFIX CODE:
----------------------------------------


async function fetchUserPosts(userId: number): Promise<ApiResponse<Post[]>> {
    try {
        const response = await axios.get<ApiResponse<Post[]>>(`/api/users/${userId}/posts`);
        return response.data;
    } catch (error) {
        console.error('Error fetching user posts:', error);
        throw error;
    }
}

(async () => {
    const userId = 1;
    try {
        const posts = await fetchUserPosts(userId);
        console.log('Fetched posts:', posts);
    } catch (error) {
        console.error('Failed to fetch posts:', error);
    }
})();


JUSTIFICATION:
----------------------------------------
This test case evaluates the LLM's ability to recognize and complete a pattern involving higher-order functions and async patterns in the context of network protocols (APIs). The prefix establishes a pattern of using higher-order functions to add retry logic to API calls and demonstrates how to fetch user data and multiple users data with retries. The golden completion continues this pattern by introducing a new function to fetch both user data and posts concurrently, maintaining the established async and error-handling patterns. The suffix then provides an additional function to fetch user posts, which follows the same pattern of async/await and error handling.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

(async () => {
    const userId = 1;
    const userDetails = await fetchUserDetails(userId);
    assert(userDetails.user.data.id === 1, 'User ID should be 1');
    assert(Array.isArray(userDetails.posts.data), 'Posts should be an array');
})();
================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import axios from 'axios';

interface ApiResponse<T> {
	data: T;
	error?: string;
}

// A higher-order function that takes a URL and a transformation function
function fetchData<T, U>(url: string, transform: (data: T) => U): Promise<ApiResponse<U>> {
	return axios.get(url)
		.then(response => ({ data: transform(response.data) }))
		.catch(error => ({ data: null as any, error: error.message }));
}

// Transformation functions
function transformUserData(data: any): { name: string; age: number } {
	return { name: data.name, age: data.age };
}

function transformPostData(data: any): { title: string; content: string } {
	return { title: data.title, content: data.body };
}

// Usage examples
const userUrl = 'https://jsonplaceholder.typicode.com/users/1';
const postUrl = 'https://jsonplaceholder.typicode.com/posts/1';

const userPromise = fetchData(userUrl, transformUserData);
const postPromise = fetchData(postUrl, transformPostData);

// Assertions
userPromise.then(response => {
	if (response.error) {
		console.error('Error fetching user:', response.error);
	} else {
		console.log('User fetched successfully:', response.data);
		// Assertions for user data
		console.assert(typeof response.data.name === 'string', 'User name should be a string');
		console.assert(typeof response.data.age === 'number', 'User age should be a number');
	}
});

postPromise.then(response => {
	if (response.error) {
		console.error('Error fetching post:', response.error);
	} else {
		console.log('Post fetched successfully:', response.data);
		// Assertions for post data
		console.assert(typeof response.data.title === 'string', 'Post title should be a string');
		console.assert(typeof response.data.content === 'string', 'Post content should be a string');
	}
});


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
userPromise.then(response => {
	if (response.error) {
		console.error('Error fetching user:', response.error);
	} else {
		console.log('User fetched successfully:', response.data);
		// Additional assertions for user data
		console.assert(response.data.name.length > 0, 'User name should not be empty');
		console.assert(response.data.age > 0, 'User age should be greater than 0');
	}
});

SUFFIX CODE:
----------------------------------------


postPromise.then(response => {
	if (response.error) {
		console.error('Error fetching post:', response.error);
	} else {
		console.log('Post fetched successfully:', response.data);
		// Assertions for post data
		console.assert(response.data.title.length > 0, 'Post title should not be empty');
		console.assert(response.data.content.length > 0, 'Post content should not be empty');
	}
});


JUSTIFICATION:
----------------------------------------
This test case is an excellent example for pattern matching as it establishes a clear pattern of using higher-order functions to fetch data from an API and transform it. The assertions are meaningful and test both the structure and content of the fetched data. This scenario is realistic, as it mimics common tasks such as fetching and transforming data in a TypeScript application. The prefix provides a comprehensive setup, including imports, type definitions, utility functions, and initial data fetching logic, making the pattern evident. The golden completion continues this pattern appropriately, ensuring consistency and correctness.

ASSERTIONS:
----------------------------------------
userPromise.then(response => {
	if (!response.error) {
		console.assert(response.data.name.length > 0, 'User name should not be empty');
		console.assert(response.data.age > 0, 'User age should be positive');
	}
});

postPromise.then(response => {
	if (!response.error) {
		console.assert(response.data.title.length > 0, 'Post title should not be empty');
		console.assert(response.data.content.length > 0, 'Post content should not be empty');
	}
});
================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import crypto from 'crypto';

// Define a generic interface for encryption strategies
interface EncryptionStrategy {
    encrypt(data: string): string;
    decrypt(data: string): string;
}

// Implement an AES encryption strategy
class AESEncryption implements EncryptionStrategy {
    private key: Buffer;
    private iv: Buffer;

    constructor(key: string, iv: string) {
        this.key = Buffer.from(key, 'hex');
        this.iv = Buffer.from(iv, 'hex');
    }

    encrypt(data: string): string {
        const cipher = crypto.createCipheriv('aes-256-cbc', this.key, this.iv);
        let encrypted = cipher.update(data, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        return encrypted;
    }

    decrypt(data: string): string {
        const decipher = crypto.createDecipheriv('aes-256-cbc', this.key, this.iv);
        let decrypted = decipher.update(data, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }
}

// Implement a RSA encryption strategy
class RSAEncryption implements EncryptionStrategy {
    private publicKey: string;
    private privateKey: string;

    constructor(publicKey: string, privateKey: string) {
        this.publicKey = publicKey;
        this.privateKey = privateKey;
    }

    encrypt(data: string): string {
        const buffer = Buffer.from(data, 'utf8');
        const encrypted = crypto.publicEncrypt(this.publicKey, buffer);
        return encrypted.toString('hex');
    }

    decrypt(data: string): string {
        const buffer = Buffer.from(data, 'hex');
        const decrypted = crypto.privateDecrypt(this.privateKey, buffer);
        return decrypted.toString('utf8');
    }
}

// Factory function to create encryption strategies
function createEncryptionStrategy(type: 'aes' | 'rsa', key: string, ivOrPrivateKey: string): EncryptionStrategy {
    if (type === 'aes') {
        return new AESEncryption(key, ivOrPrivateKey);
    } else if (type === 'rsa') {
        return new RSAEncryption(key, ivOrPrivateKey);
    }
    throw new Error('Unsupported encryption type');
}

// Example usage
const aesStrategy = createEncryptionStrategy('aes', '6368616e676520746869732070617373', '1234567890123456');
const rsaStrategy = createEncryptionStrategy('rsa', '-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7zB9VPJt5J1ZJvh2bcLg\n-----END PUBLIC KEY-----', '-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDvMH1U8m3knVkm\n-----END PRIVATE KEY-----');

// Encrypt and decrypt using AES strategy
const aesEncrypted = aesStrategy.encrypt('Hello, World!');
const aesDecrypted = aesStrategy.decrypt(aesEncrypted);
console.log(`AES Encrypted: ${aesEncrypted}`);
console.log(`AES Decrypted: ${aesDecrypted}`);

// Encrypt and decrypt using RSA strategy
const rsaEncrypted = rsaStrategy.encrypt('Hello, World!');
const rsaDecrypted = rsaStrategy.decrypt(rsaEncrypted);
console.log(`RSA Encrypted: ${rsaEncrypted}`);
console.log(`RSA Decrypted: ${rsaDecrypted}`);

LLM COMPLETION gpt-4.1-mini:
----------------------------------------
// Extend the factory function to support the new algorithm
function createEncryptionStrategy(type: 'aes' | 'rsa' | 'newalgo', key: string, ivOrPrivateKey?: string): EncryptionStrategy {
    if (type === 'aes') {
        return new AESEncryption(key, ivOrPrivateKey!);
    } else if (type === 'rsa') {
        return new RSAEncryption(key, ivOrPrivateKey!);
    } else if (type === 'newalgo') {
        return new NewAlgoEncryption(key);
    }
    throw new Error('Unsupported encryption type');
}

SUFFIX CODE:
----------------------------------------
// Mocking a new encryption strategy for a different algorithm
class NewAlgoEncryption implements EncryptionStrategy {
    private secret: string;

    constructor(secret: string) {
        this.secret = secret;
    }

    encrypt(data: string): string {
        // Mock encryption logic
        return `${data}-encrypted-with-${this.secret}`;
    }

    decrypt(data: string): string {
        // Mock decryption logic
        return data.replace(`-encrypted-with-${this.secret}`, '');
    }
}

// Example usage for the new algorithm
const newAlgoStrategy = new NewAlgoEncryption('mysecretkey');
const newAlgoEncrypted = newAlgoStrategy.encrypt('Hello, World!');
const newAlgoDecrypted = newAlgoStrategy.decrypt(newAlgoEncrypted);
console.log(`New Algo Encrypted: ${newAlgoEncrypted}`);
console.log(`New Algo Decrypted: ${newAlgoDecrypted}`);

JUSTIFICATION:
----------------------------------------
This test case demonstrates the implementation of various encryption strategies using a common interface. By establishing a clear pattern with AES and RSA encryption strategies, the LLM is expected to recognize and implement a new encryption strategy (DES) following the same pattern. This scenario involves type definitions and generics in the security domain, testing the model's ability to understand and extend patterns in cryptographic implementations. The provided assertions verify that the encryption and decryption processes are correctly implemented for the new strategy.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

// Assertions for AES strategy
assert.strictEqual(aesDecrypted, 'Hello, World!');

// Assertions for RSA strategy
assert.strictEqual(rsaDecrypted, 'Hello, World!');

// Assertions for DES strategy
assert.strictEqual(desDecrypted, 'Hello, World!');

// Assertions for the new algorithm strategy
assert.strictEqual(newAlgoDecrypted, 'Hello, World!');

================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { createServer, IncomingMessage, ServerResponse } from 'http';

interface User {
    id: number;
    name: string;
    email: string;
}

const users: User[] = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' },
    { id: 3, name: 'Charlie', email: 'charlie@example.com' }
];

function handleGetUsers(req: IncomingMessage, res: ServerResponse) {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(users));
}

function handleGetUserById(req: IncomingMessage, res: ServerResponse) {
    const userId = parseInt(req.url?.split('/')[2] || '', 10);
    const user = users.find(u => u.id === userId);
    if (user) {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(user));
    } else {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'User not found' }));
    }
}

function handlePostUser(req: IncomingMessage, res: ServerResponse) {
    let body = '';
    req.on('data', chunk => {
        body += chunk;
    });
    req.on('end', () => {
        const newUser: User = JSON.parse(body);
        newUser.id = users.length + 1;
        users.push(newUser);
        res.writeHead(201, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(newUser));
    });
}

function requestListener(req: IncomingMessage, res: ServerResponse) {
    if (req.method === 'GET' && req.url === '/users') {
        handleGetUsers(req, res);
    } else if (req.method === 'GET' && req.url?.startsWith('/users/')) {
        handleGetUserById(req, res);
    } else if (req.method === 'POST' && req.url === '/users') {
        handlePostUser(req, res);
    } else {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Not found' }));
    }
}

const server = createServer(requestListener);
server.listen(8080, () => {
    console.log('Server is listening on port 8080');
});


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
setTimeout(() => {
    server.close(() => {
        console.log('Server closed');
    });
}, 10000);

SUFFIX CODE:
----------------------------------------

server.close(() => {
    console.log('Server closed');
});


JUSTIFICATION:
----------------------------------------
This test case is a good example of pattern matching because it involves adding a new functionality to an existing HTTP server. The pattern of handling different HTTP methods and routes is established in the prefix with `handleGetUsers`, `handleGetUserById`, and `handlePostUser` functions. The `handleDeleteUser` function follows the same pattern for a DELETE request. This scenario tests the LLM's ability to recognize and extend the pattern of handling different HTTP requests and routes, which is a common task in building RESTful APIs.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

const testReq = (method: string, url: string, data?: any) => {
    return new Promise<{ statusCode: number, data: any }>((resolve, reject) => {
        const options = { hostname: 'localhost', port: 8080, path: url, method, headers: { 'Content-Type': 'application/json' } };
        const req = require('http').request(options, (res: any) => {
            let rawData = '';
            res.on('data', (chunk: any) => { rawData += chunk; });
            res.on('end', () => { resolve({ statusCode: res.statusCode, data: JSON.parse(rawData) }); });
        });
        req.on('error', (e: any) => { reject(e); });
        if (data) req.write(JSON.stringify(data));
        req.end();
    });
};

(async () => {
    // Test GET /users
    let res = await testReq('GET', '/users');
    assert.equal(res.statusCode, 200);
    assert.equal(res.data.length, 3);

    // Test GET /users/1
    res = await testReq('GET', '/users/1');
    assert.equal(res.statusCode, 200);
    assert.equal(res.data.name, 'Alice');

    // Test POST /users
    res = await testReq('POST', '/users', { name: 'Dave', email: 'dave@example.com' });
    assert.equal(res.statusCode, 201);
    assert.equal(res.data.name, 'Dave');

    // Test DELETE /users/4
    res = await testReq('DELETE', '/users/4');
    assert.equal(res.statusCode, 200);
    assert.equal(res.data.success, 'User deleted');

    // Verify user is deleted
    res = await testReq('GET', '/users/4');
    assert.equal(res.statusCode, 404);
})();

================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

interface User {
    id: number;
    username: string;
    passwordHash: string;
}

const users: User[] = [
    { id: 1, username: 'user1', passwordHash: 'hash1' },
    { id: 2, username: 'user2', passwordHash: 'hash2' }
];

function hashPassword(password: string): string {
    return crypto.createHash('sha256').update(password).digest('hex');
}

function authenticate(username: string, password: string): boolean {
    const user = users.find(u => u.username === username);
    if (!user) {
        return false;
    }
    const passwordHash = hashPassword(password);
    return user.passwordHash === passwordHash;
}

// Higher-order function for logging
function logExecution<T extends (...args: any[]) => any>(fn: T): T {
    return ((...args: Parameters<T>): ReturnType<T> => {
        console.log(`Executing function ${fn.name} with arguments:`, args);
        const result = fn(...args);
        console.log(`Function ${fn.name} returned:`, result);
        return result;
    }) as T;
}

const loggedAuthenticate = logExecution(authenticate);

// Example usage of loggedAuthenticate
const isAuthenticated = loggedAuthenticate('user1', 'password1');
console.log('Is authenticated:', isAuthenticated);

// More higher-order functions for different actions
function logAndTimeExecution<T extends (...args: any[]) => any>(fn: T): T {
    return ((...args: Parameters<T>): ReturnType<T> => {
        const startTime = Date.now();
        console.log(`Executing function ${fn.name} with arguments:`, args);
        const result = fn(...args);
        const endTime = Date.now();
        console.log(`Function ${fn.name} returned:`, result);
        console.log(`Execution time: ${endTime - startTime}ms`);
        return result;
    }) as T;
}

const loggedAndTimedAuthenticate = logAndTimeExecution(authenticate);

// Example usage of loggedAndTimedAuthenticate
const isAuthenticatedTimed = loggedAndTimedAuthenticate('user2', 'password2');
console.log('Is authenticated with timing:', isAuthenticatedTimed);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------
const loggedAndTimedAuthenticateAsync = async (...args: Parameters<typeof authenticate>): Promise<ReturnType<typeof authenticate>> => {
    const startTime = Date.now();
    console.log(`Executing async function authenticate with arguments:`, args);
    const result = await Promise.resolve(authenticate(...args));
    const endTime = Date.now();
    console.log(`Async function authenticate returned:`, result);
    console.log(`Execution time: ${endTime - startTime}ms`);
    return result;
};

SUFFIX CODE:
----------------------------------------


// Cleanup
users.length = 0;

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to recognize and continue a higher-order function pattern in the context of security (password hashing and authentication). The pattern is established with higher-order functions that log and time the execution of other functions. The completion should demonstrate the ability to apply the same higher-order function pattern to a new function (`hashPassword`) and use it correctly. The prefix provides ample context and examples of the pattern, ensuring it is clear. Assertions verify that the pattern is followed and that the functionality is correct.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';

const testPassword = 'testPassword';
const expectedHash = hashPassword(testPassword);
const actualHash = loggedAndTimedHashPassword(testPassword);
assert.strictEqual(actualHash, expectedHash, 'Hash should match the expected hash');

const testUser = 'user1';
const wrongPassword = 'wrongPassword';
const correctPassword = 'password1';
assert.strictEqual(loggedAndTimedAuthenticate(testUser, wrongPassword), false, 'Authentication should fail with wrong password');
assert.strictEqual(loggedAndTimedAuthenticate(testUser, correctPassword), true, 'Authentication should succeed with correct password');
================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: devbench-pattern-matching
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as crypto from 'crypto';

interface User {
  id: string;
  username: string;
  passwordHash: string;
  salt: string;
}

class AuthenticationService {
  private users: User[] = [];

  public addUser(username: string, password: string): User {
    const salt = crypto.randomBytes(16).toString('hex');
    const passwordHash = this.hashPassword(password, salt);
    const user: User = { id: crypto.randomUUID(), username, passwordHash, salt };
    this.users.push(user);
    return user;
  }

  private hashPassword(password: string, salt: string): string {
    return crypto.pbkdf2Sync(password, salt, 1000, 64, 'sha512').toString('hex');
  }

  public authenticate(username: string, password: string): boolean {
    const user = this.users.find(u => u.username === username);
    if (!user) {
      return false;
    }
    const passwordHash = this.hashPassword(password, user.salt);
    return user.passwordHash === passwordHash;
  }
}

// Adding and authenticating users
const authService = new AuthenticationService();
const user1 = authService.addUser('user1', 'password1');
const user2 = authService.addUser('user2', 'password2');

console.log('User1:', user1);
console.log('User2:', user2);

const isAuthenticatedUser1 = authService.authenticate('user1', 'password1');
const isAuthenticatedUser2 = authService.authenticate('user2', 'password2');
console.log('Is User1 authenticated?', isAuthenticatedUser1);
console.log('Is User2 authenticated?', isAuthenticatedUser2);


LLM COMPLETION gpt-4.1-mini:
----------------------------------------


SUFFIX CODE:
----------------------------------------

const isAuthenticatedUser3 = authService.authenticate('user3', 'password3');
console.log('Is User3 authenticated?', isAuthenticatedUser3);


JUSTIFICATION:
----------------------------------------
This is a good test case because it demonstrates a common pattern in authentication services: adding users, hashing passwords, and authenticating users. The prefix code establishes the pattern of using the `AuthenticationService` class to add users and authenticate them. The pattern involves hashing passwords with a salt and comparing the hashed passwords for authentication. The golden completion follows this pattern by attempting to authenticate a user with an incorrect password, which is a common scenario in real-world applications. The suffix continues the pattern by attempting to authenticate a non-existent user. This test case ensures that the LLM can recognize and complete the pattern of user authentication correctly.

ASSERTIONS:
----------------------------------------
import * as assert from 'assert';

const authService = new AuthenticationService();
const user1 = authService.addUser('user1', 'password1');
const user2 = authService.addUser('user2', 'password2');

assert.strictEqual(authService.authenticate('user1', 'password1'), true, 'User1 should be authenticated with correct password');
assert.strictEqual(authService.authenticate('user2', 'password2'), true, 'User2 should be authenticated with correct password');
assert.strictEqual(authService.authenticate('user1', 'wrongpassword'), false, 'User1 should not be authenticated with wrong password');
assert.strictEqual(authService.authenticate('user3', 'password3'), false, 'User3 should not be authenticated (non-existent user)');

================================================================================
