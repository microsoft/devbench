
================================================================================
Test Case #1
================================================================================

================================================================================
Test Case ID: 1
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Represents a financial portfolio containing multiple assets.
 */
interface Portfolio {
    assets: Asset[];
}

/**
 * Represents a financial asset with a name and value.
 */
interface Asset {
    name: string;
    value: number;
}

/**
 * Calculates the total value of a portfolio.
 * @param portfolio The portfolio for which to calculate the total value.
 * @returns The total value of all assets in the portfolio.
 */
function calculateTotalValue(portfolio: Portfolio): number {
    let totalValue = 0;
    for (const asset of portfolio.assets) {
        totalValue += asset.value;
    }
    return totalValue;
}

/**
 * Analyzes the risk of a portfolio based on asset values.
 * @param portfolio The portfolio to analyze.
 * @returns A string indicating the risk level.
 */
function analyzeRisk(portfolio: Portfolio): string {
    const totalValue = calculateTotalValue(portfolio);
    if (totalValue > 1000000) {
        return 'High Risk';
    } else if (totalValue > 500000) {
        return 'Medium Risk';
    } else {
        return 'Low Risk';
    }
}

// Example usage:
const myPortfolio: Portfolio = {
    assets: [
        { name: 'Stock A', value: 300000 },
        { name: 'Stock B', value: 700000 },
        { name: 'Bond C', value: 100000 }
    ]
};

const riskLevel = analyzeRisk(myPortfolio);
console.log(`Risk Level: ${riskLevel}`);

// Assertions to verify the correctness of the functions
assert.strictEqual(calculateTotalValue(myPortfolio), 1100000);
assert.strictEqual(analyzeRisk(myPortfolio), 'High Risk');

/**
 * Generates a summary report of the portfolio.
 * @param portfolio The portfolio to summarize.
 * @returns A string containing the summary report.
 */
function generateSummaryReport(portfolio: Portfolio): string {
    const totalValue = calculateTotalValue(portfolio);
    const riskLevel = analyzeRisk(portfolio);
    let report = `Portfolio Summary:\n`;
    report += `Total Value: $${totalValue.toLocaleString()}\n`;
    report += `Risk Level: ${riskLevel}\n`;
    report += `Assets:\n`;
    for (const asset of portfolio.assets) {
        report += ` - ${asset.name}: $${asset.value.toLocaleString()}\n`;
    }
    return report;
}

const summaryReport = generateSummaryReport(myPortfolio);
console.log(summaryReport);

/**
 * Validates that the portfolio is not empty and that asset values are positive.
 * @param portfolio The portfolio to validate.
 * @throws Will throw an error if the portfolio is empty or contains assets with non-positive values.
 */


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function validatePortfolio(portfolio: Portfolio): void {
    if (!portfolio.assets || portfolio.assets.length === 0) {
        throw new Error('Portfolio cannot be empty');
    }
    
    for (const asset of portfolio.assets) {
        if (asset.value <= 0) {
            throw new Error(`Asset ${asset.name} has a non-positive value: ${asset.value}`);
        }
    }
}

SUFFIX CODE:
----------------------------------------
assert.strictEqual(summaryReport.includes('Total Value: $1,100,000'), true);
assert.strictEqual(summaryReport.includes('Risk Level: High Risk'), true);
assert.strictEqual(summaryReport.includes('Stock A: $300,000'), true);
assert.strictEqual(summaryReport.includes('Stock B: $700,000'), true);
assert.strictEqual(summaryReport.includes('Bond C: $100,000'), true);

// Cleanup code (none required for this example)


JUSTIFICATION:
----------------------------------------
This test case is a good example for evaluating an LLM's ability to translate between TypeScript code and natural language documentation. The scenario involves financial portfolio analysis, which is a realistic and complex business domain. The code-to-comment part requires generating comprehensive documentation for the validatePortfolio function, including parameter descriptions, error scenarios, and usage examples. The comment-to-code part involves implementing the function based on the provided documentation. Assertions verify the correctness of the implementation and the generated documentation, ensuring that key domain terms and concepts are covered. The example demonstrates clear alignment between documentation and implementation, leveraging TypeScript's type system and best practices for TSDoc comments.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Validates that the portfolio is not empty and that asset values are positive.
 * @param portfolio The portfolio to validate.
 * @throws Will throw an error if the portfolio is empty or contains assets with non-positive values.
 */`;
assert(docString.toLowerCase().includes('portfolio'));
assert(docString.includes('Parameters:'));
assert(docString.includes('@throws'));
assert(docString.includes('non-positive'));
assert(docString.includes('positive'));

const testPortfolio: Portfolio = { assets: [] };
try {
    validatePortfolio(testPortfolio);
} catch (error) {
    assert.strictEqual(error.message, 'Portfolio is empty');
}

const invalidPortfolio: Portfolio = { assets: [{ name: 'Stock D', value: -1000 }] };
try {
    validatePortfolio(invalidPortfolio);
} catch (error) {
    assert.strictEqual(error.message, 'Asset value for Stock D must be positive');
}

const validPortfolio: Portfolio = { assets: [{ name: 'Stock E', value: 1000 }] };
try {
    validatePortfolio(validPortfolio);
    assert(true);
} catch {
    assert(false);
}

================================================================================

================================================================================
Test Case #2
================================================================================

================================================================================
Test Case ID: 2
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
import { strict as 

SUFFIX CODE:
----------------------------------------
class TaskScheduler {
    private tasks: Map<string, () => void>;

    constructor() {
        this.tasks = new Map();
    }

    /**
     * Adds a new task to the scheduler.
     * @param name - The name of the task.
     * @param task - The task function to be executed.
     */
    addTask(name: string, task: () => void): void {
        if (this.tasks.has(name)) {
            throw new Error(`Task with name ${name} already exists.`);
        }
        this.tasks.set(name, task);
    }

    /**
     * Executes the task with the given name.
     * @param name - The name of the task to execute.
     */
    executeTask(name: string): void {
        const task = this.tasks.get(name);
        if (!task) {
            throw new Error(`Task with name ${name} does not exist.`);
        }
        task();
    }

    /**
     * Removes a task from the scheduler.
     * @param name - The name of the task to remove.
     */
    removeTask(name: string): void {
        if (!this.tasks.delete(name)) {
            throw new Error(`Task with name ${name} does not exist.`);
        }
    }
}

// Example usage:
const scheduler = new TaskScheduler();
scheduler.addTask('task1', () => console.log('Executing Task 1'));
scheduler.addTask('task2', () => console.log('Executing Task 2'));
scheduler.executeTask('task1');
scheduler.removeTask('task1');

// Assertions
assert.throws(() => scheduler.executeTask('task1'), /does not exist/);
scheduler.executeTask('task2');
scheduler.removeTask('task2');

// Clean up resources
assert.throws(() => scheduler.executeTask('task2'), /does not exist/);


JUSTIFICATION:
----------------------------------------
This is a good test case because it covers a realistic scenario of managing tasks in a task scheduler. The code includes detailed TSDoc comments explaining the purpose of the class, its methods, and usage examples. The provided assertions verify that the class handles task addition, execution, removal, and error scenarios correctly. This scenario effectively tests the LLM's ability to generate both code and comprehensive documentation, maintaining consistency between the two.

ASSERTIONS:
----------------------------------------
assert(TaskScheduler.toString().includes('class TaskScheduler'));
const docString = TaskScheduler.toString();
assert(docString.includes('Parameters:'));
assert(docString.includes('Example'));
assert(docString.includes('A class representing a simple task scheduler'));
assert(docString.includes('This class allows for adding, executing, and removing tasks'));
assert(docString.includes('It ensures that tasks with duplicate names cannot be added'));
assert(docString.includes('appropriate error handling for operations on non-existent tasks'));
assert(docString.includes('@class TaskScheduler'));

================================================================================

================================================================================
Test Case #3
================================================================================

================================================================================
Test Case ID: 3
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a financial asset in a portfolio
 */
interface Asset {
	name: string;
	quantity: number;
	pricePerUnit: number;
}

/**
 * Interface representing a portfolio
 */
interface Portfolio {
	assets: Asset[];
}

/**
 * Function to calculate the total value of a portfolio
 * @param portfolio - The portfolio containing various assets
 * @returns The total value of the portfolio
 */
function calculatePortfolioValue(portfolio: Portfolio): number {
	let totalValue = 0;
	for (const asset of portfolio.assets) {
		totalValue += asset.quantity * asset.pricePerUnit;
	}
	return totalValue;
}

/**
 * Function to assess the risk level of a portfolio based on asset allocation
 * @param portfolio - The portfolio to assess
 * @returns The risk level as a string
 */
function assessPortfolioRisk(portfolio: Portfolio): string {
	let totalValue = calculatePortfolioValue(portfolio);
	let stockValue = 0;
	let bondValue = 0;
	for (const asset of portfolio.assets) {
		if (asset.name === 'Stock') {
			stockValue += asset.quantity * asset.pricePerUnit;
		} else if (asset.name === 'Bond') {
			bondValue += asset.quantity * asset.pricePerUnit;
		}
	}
	const stockPercentage = stockValue / totalValue;
	if (stockPercentage > 0.7) {
		return 'High Risk';
	} else if (stockPercentage > 0.4) {
		return 'Moderate Risk';
	} else {
		return 'Low Risk';
	}
}

/**
 * Example portfolio
 */
const portfolio: Portfolio = {
	assets: [
		{name: 'Stock', quantity: 50, pricePerUnit: 200},
		{name: 'Bond', quantity: 100, pricePerUnit: 100},
	]
};

// Calculate and assert the total portfolio value
const totalValue = calculatePortfolioValue(portfolio);
assert.strictEqual(totalValue, 15000);

// Assess and assert the portfolio risk level
const riskLevel = assessPortfolioRisk(portfolio);
assert.strictEqual(riskLevel, 'Moderate Risk');

/**
 * Function to evaluate the portfolio based on various criteria
 * @param portfolio - The portfolio to evaluate
 * @returns An object with the total value and risk level
 */


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function evaluatePortfolio(portfolio: Portfolio): { totalValue: number; riskLevel: string } {
  const totalValue = calculatePortfolioValue(portfolio);
  const riskLevel = assessPortfolioRisk(portfolio);
  return { totalValue, riskLevel };
}

SUFFIX CODE:
----------------------------------------
const evaluation = evaluatePortfolio(portfolio);
assert.strictEqual(evaluation.totalValue, 15000);
assert.strictEqual(evaluation.riskLevel, 'Moderate Risk');

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to translate between code and documentation effectively by requiring it to generate a function implementation from detailed comments. The scenario includes realistic business logic for financial portfolio analysis, ensuring practical relevance. The assertions verify that the generated code meets functional requirements and handles edge cases correctly, while the detailed comments provide clear guidance for the expected implementation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Function to evaluate the portfolio based on various criteria
 * @param portfolio - The portfolio to evaluate
 * @returns An object with the total value and risk level
 */`;
assert(docString.includes('portfolio'));
assert(docString.includes('total value'));
assert(docString.includes('risk level'));
assert(docString.includes('@param portfolio'));
assert(docString.includes('@returns An object'));
================================================================================

================================================================================
Test Case #4
================================================================================

================================================================================
Test Case ID: 4
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Represents a financial transaction with an amount and a timestamp.
 */
interface Transaction {
	amount: number;
	timestamp: Date;
}

/**
 * Calculates the total value of transactions within a specific time range.
 * @param transactions - Array of transactions to be analyzed.
 * @param start - Start date of the time range.
 * @param end - End date of the time range.
 * @returns The total value of transactions within the specified time range.
 */
function calculateTotalValue(transactions: Transaction[], start: Date, end: Date): number {
	let total = 0;
	for (const transaction of transactions) {
		if (transaction.timestamp >= start && transaction.timestamp <= end) {
			total += transaction.amount;
		}
	}
	return total;
}

/**
 * Filters transactions that fall within a specific time range.
 * @param transactions - Array of transactions to be filtered.
 * @param start - Start date of the time range.
 * @param end - End date of the time range.
 * @returns A filtered array of transactions within the specified time range.
 */
function filterTransactions(transactions: Transaction[], start: Date, end: Date): Transaction[] {
	return transactions.filter(transaction => transaction.timestamp >= start && transaction.timestamp <= end);
}

const transactions: Transaction[] = [
	{ amount: 100, timestamp: new Date('2023-01-01') },
	{ amount: 200, timestamp: new Date('2023-02-01') },
	{ amount: -50, timestamp: new Date('2023-03-01') },
	{ amount: 300, timestamp: new Date('2023-04-01') }
];

const start = new Date('2023-01-01');
const end = new Date('2023-03-01');

const totalValue = calculateTotalValue(transactions, start, end);
const filteredTransactions = filterTransactions(transactions, start, end);


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
console.log(`Total value of transactions between ${start.toDateString()} and ${end.toDateString()}: $${totalValue}`);
console.log(`Number of transactions in the period: ${filteredTransactions.length}`);

// Calculate average transaction value
const averageValue = filteredTransactions.length > 0 
  ? filteredTransactions.reduce((sum, transaction) => sum + transaction.amount, 0) / filteredTransactions.length 
  : 0;
console.log(`Average transaction value: $${averageValue.toFixed(2)}`);

// Find largest transaction in the period
const largestTransaction = filteredTransactions.reduce(
  (max, transaction) => transaction.amount > max.amount ? transaction : max, 
  { amount: Number.NEGATIVE_INFINITY, timestamp: new Date() }
);
if (filteredTransactions.length > 0) {
  console.log(`Largest transaction: $${largestTransaction.amount} on ${largestTransaction.timestamp.toDateString()}`);
}

SUFFIX CODE:
----------------------------------------

// Example usage of the functions
document.getElementById('total-value').textContent = `Total Value: $${totalValue}`;
document.getElementById('filtered-transactions').textContent = `Filtered Transactions: ${JSON.stringify(filteredTransactions)}`;

// Assertions
assert(totalValue === 250, 'Total value should be 250');
assert(filteredTransactions.length === 3, 'There should be 3 transactions within the date range');
assert(filteredTransactions[0].amount === 100, 'First transaction amount should be 100');
assert(filteredTransactions[2].amount === -50, 'Third transaction amount should be -50');

JUSTIFICATION:
----------------------------------------
This test case provides a comprehensive scenario involving financial transaction processing. It tests the ability of an LLM to translate between TypeScript code and documentation effectively. The prefix includes detailed TypeScript interfaces, functions, and comments, establishing a clear context. The golden completion requires generating a function with proper async handling and documentation. The suffix ensures the completion does not duplicate content and includes assertions to verify correctness. This case tests complex business logic, error handling, and realistic API interactions.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

// Ensure the fetchLatestTransactions function is properly documented and implemented
const docString = fetchLatestTransactions.toString();
assert(docString.includes('async function fetchLatestTransactions'), 'Function name and async keyword should be present');
assert(docString.includes('Mocking an API call with a delay'), 'Internal function comment should mention mocking');
assert(docString.includes('transactions.push'), 'Function should push new transaction');
assert(docString.includes('new Date()'), 'Function should use new Date()');
assert(docString.includes('resolve();'), 'Function should resolve the promise');
================================================================================

================================================================================
Test Case #5
================================================================================

================================================================================
Test Case ID: 5
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

interface Portfolio {
    stocks: Stock[];
    bonds: Bond[];
}

interface Stock {
    symbol: string;
    shares: number;
    purchasePrice: number;
}

interface Bond {
    identifier: string;
    faceValue: number;
    interestRate: number;
    maturityDate: Date;
}

/**
 * Analyzes a portfolio to calculate the total value of stocks and bonds.
 * @param portfolio The portfolio to analyze.
 * @returns The total value of the portfolio.
 */
function analyzePortfolio(portfolio: Portfolio): number {
    let totalValue = 0;

    // Calculate total value of stocks
    for (const stock of portfolio.stocks) {
        totalValue += stock.shares * stock.purchasePrice;
    }

    // Calculate total value of bonds
    for (const bond of portfolio.bonds) {
        totalValue += bond.faceValue * (1 + bond.interestRate);
    }

    return totalValue;
}

const samplePortfolio: Portfolio = {
    stocks: [
        { symbol: 'AAPL', shares: 10, purchasePrice: 150 },
        { symbol: 'GOOGL', shares: 5, purchasePrice: 1000 }
    ],
    bonds: [
        { identifier: 'US12345', faceValue: 1000, interestRate: 0.05, maturityDate: new Date('2030-01-01') }
    ]
};

const totalValue = analyzePortfolio(samplePortfolio);
console.log(`Total Portfolio Value: $${totalValue}`);

LLM COMPLETION claude-3-7-sonnet:
----------------------------------------


SUFFIX CODE:
----------------------------------------
assert(totalValue === 8500);

/**
 * Generates a summary of the portfolio's investments.
 * @param portfolio The portfolio to summarize.
 * @returns A summary string of the portfolio.
 */
function generatePortfolioSummary(portfolio: Portfolio): string {
    const stockSummary = portfolio.stocks.map(stock => `${stock.shares} shares of ${stock.symbol} at $${stock.purchasePrice} each`).join(', ');
    const bondSummary = portfolio.bonds.map(bond => `${bond.faceValue} bond with ${bond.interestRate * 100}% interest maturing on ${bond.maturityDate.toDateString()}`).join(', ');
    return `Stocks: ${stockSummary}. Bonds: ${bondSummary}.`;
}

const summary = generatePortfolioSummary(samplePortfolio);
console.log(summary);
assert(summary.includes('10 shares of AAPL at $150 each'));
assert(summary.includes('5 shares of GOOGL at $1000 each'));
assert(summary.includes('1000 bond with 5% interest maturing on Tue Jan 01 2030'));

// Clean up resources if any (not applicable here)

JUSTIFICATION:
----------------------------------------
This test case is a good example because it combines financial calculations with business rule validation and risk assessment logic. It requires the LLM to understand and translate complex business logic, including portfolio analysis and risk assessment. Additionally, it tests both code-to-comment and comment-to-code translation capabilities by providing detailed documentation requirements and a working implementation. The scenario includes realistic financial data and calculations, making it a practical and relevant example for testing LLM capabilities.

ASSERTIONS:
----------------------------------------
assert(totalValue === 8500);
assert(summary.includes('10 shares of AAPL at $150 each'));
assert(summary.includes('5 shares of GOOGL at $1000 each'));
assert(summary.includes('1000 bond with 5% interest maturing on Tue Jan 01 2030'));
assert(riskLevel === 'Low');
================================================================================

================================================================================
Test Case #6
================================================================================

================================================================================
Test Case ID: 6
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a financial asset.
 */
interface Asset {
    symbol: string;
    quantity: number;
    purchasePrice: number;
}

/**
 * Interface representing a portfolio containing multiple assets.
 */
interface Portfolio {
    assets: Asset[];
}

/**
 * Function to calculate the total value of a portfolio based on current market prices.
 * @param portfolio The portfolio containing assets.
 * @param marketPrices A dictionary of current market prices keyed by asset symbol.
 * @returns The total value of the portfolio.
 * @throws Error if any asset in the portfolio is missing a market price.
 */
function calculatePortfolioValue(portfolio: Portfolio, marketPrices: Record<string, number>): number {
    let totalValue = 0;
    for (const asset of portfolio.assets) {
        const currentPrice = marketPrices[asset.symbol];
        if (currentPrice === undefined) {
            throw new Error(`Market price for ${asset.symbol} not found.`);
        }
        totalValue += asset.quantity * currentPrice;
    }
    return totalValue;
}

const samplePortfolio: Portfolio = {
    assets: [
        { symbol: 'AAPL', quantity: 10, purchasePrice: 150 },
        { symbol: 'GOOGL', quantity: 5, purchasePrice: 1000 },
        { symbol: 'MSFT', quantity: 8, purchasePrice: 200 }
    ]
};

const currentMarketPrices: Record<string, number> = {
    'AAPL': 170,
    'GOOGL': 1100,
    'MSFT': 210
};


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
/**
 * Function to calculate the total profit or loss of a portfolio based on current market prices.
 * @param portfolio The portfolio containing assets.
 * @param marketPrices A dictionary of current market prices keyed by asset symbol.
 * @returns The total profit or loss of the portfolio.
 * @throws Error if any asset in the portfolio is missing a market price.
 */
function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {
    let totalProfitLoss = 0;
    for (const asset of portfolio.assets) {
        const currentPrice = marketPrices[asset.symbol];
        if (currentPrice === undefined) {
            throw new Error(`Market price for ${asset.symbol} not found.`);
        }
        const currentValue = asset.quantity * currentPrice;
        const purchaseValue = asset.quantity * asset.purchasePrice;
        totalProfitLoss += currentValue - purchaseValue;
    }
    return totalProfitLoss;
}


SUFFIX CODE:
----------------------------------------
const profitLoss = calculatePortfolioProfitLoss(samplePortfolio, currentMarketPrices);
console.log(`Total Profit/Loss: $${profitLoss}`);

// Assertions
assert.strictEqual(profitLoss, 1600);

// Resource cleanup
// No resources to clean up in this example.


JUSTIFICATION:
----------------------------------------
This test case effectively evaluates the LLM's ability to generate detailed and accurate documentation for a function that calculates the profit or loss of a financial portfolio. The function involves complex business logic such as price lookup, profit/loss calculation, and error handling for missing market prices. The golden completion provides comprehensive documentation that includes parameter descriptions, return value details, and error conditions, ensuring alignment between the code and the comments. Assertions verify the correctness of the function's implementation and the accuracy of the generated documentation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Calculates the total profit or loss of the given portfolio by comparing the purchase prices of the assets with their current market prices.
 * @param portfolio - The portfolio to calculate the profit or loss for.
 * @param marketPrices - A dictionary containing the current market prices for each asset.
 * @returns The total profit or loss of the portfolio.
 * @throws Will throw an error if a market price for any asset is not found.
 */`;
assert(docString.toLowerCase().includes('total profit or loss'));
assert(docString.includes('@param portfolio'));
assert(docString.includes('@param marketPrices'));
assert(docString.includes('@returns'));
assert(docString.includes('@throws'));
const profitLoss = calculatePortfolioProfitLoss(samplePortfolio, currentMarketPrices);
assert.strictEqual(profitLoss, 1600);

================================================================================

================================================================================
Test Case #7
================================================================================

================================================================================
Test Case ID: 7
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface Portfolio {
	id: string;
	name: string;
	assets: Asset[];
}

interface Asset {
	id: string;
	name: string;
	value: number;
}

/**
 * Function to calculate the total value of a portfolio.
 * @param portfolio - The portfolio object containing assets.
 * @returns The total value of all assets in the portfolio.
 */
function calculateTotalValue(portfolio: Portfolio): number {
	let totalValue = 0;
	for (const asset of portfolio.assets) {
		totalValue += asset.value;
	}
	return totalValue;
}

/**
 * Function to find the asset with the highest value in a portfolio.
 * @param portfolio - The portfolio object containing assets.
 * @returns The asset with the highest value.
 */
function findHighestValueAsset(portfolio: Portfolio): Asset | null {
	if (portfolio.assets.length === 0) {
		return null;
	}
	let highestValueAsset = portfolio.assets[0];
	for (const asset of portfolio.assets) {
		if (asset.value > highestValueAsset.value) {
			highestValueAsset = asset;
		}
	}
	return highestValueAsset;
}

const examplePortfolio: Portfolio = {
	id: 'portfolio1',
	name: 'Example Portfolio',
	assets: [
		{id: 'asset1', name: 'Asset One', value: 1000},
		{id: 'asset2', name: 'Asset Two', value: 2000},
		{id: 'asset3', name: 'Asset Three', value: 1500}
	]
};

// Calculate the total value of the example portfolio
const totalValue = calculateTotalValue(examplePortfolio);
assert(totalValue === 4500);



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
// Find the asset with the highest value in the example portfolio
const highestValueAsset = findHighestValueAsset(examplePortfolio);
assert(highestValueAsset !== null);
assert(highestValueAsset!.id === 'asset2');

SUFFIX CODE:
----------------------------------------

// Find the asset with the highest value in the example portfolio
const highestValueAsset = findHighestValueAsset(examplePortfolio);
assert(highestValueAsset !== null);
assert(highestValueAsset!.name === 'Asset Two');

// Cleanup code (if any resources needed cleanup, it would go here)


JUSTIFICATION:
----------------------------------------
This test case effectively evaluates an LLM's ability to translate between TypeScript code and natural language documentation. The prefix provides a comprehensive context with interfaces, utility functions, and data structures, while the golden completion demonstrates the creation of a function to validate business rules for a portfolio. The suffix ensures that the added function is utilized correctly and assertions verify the implementation. This scenario covers complex business logic, proper TypeScript typing, and clear documentation patterns, making it a robust test for code-to-comment and comment-to-code translation capabilities.

ASSERTIONS:
----------------------------------------
assert(calculateTotalValue(examplePortfolio) === 4500);
assert(findHighestValueAsset(examplePortfolio)!.name === 'Asset Two');
assert(validatePortfolio(examplePortfolio) === true);
const docString = `Function to validate a portfolio based on business rules.
@param portfolio - The portfolio object to validate.
@returns A boolean indicating whether the portfolio is valid or not.`;
assert(docString.toLowerCase().includes("validate a portfolio"));
assert(docString.includes("@param portfolio"));
assert(docString.includes("@returns A boolean"));
================================================================================

================================================================================
Test Case #8
================================================================================

================================================================================
Test Case ID: 8
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

// Business logic for financial calculations
interface Portfolio {
    assets: { [symbol: string]: number };
    cash: number;
}

/**
 * Calculates the total value of the portfolio.
 * @param portfolio The portfolio object containing assets and cash.
 * @param prices The current prices of the assets.
 * @returns The total value of the portfolio.
 */
function calculatePortfolioValue(portfolio: Portfolio, prices: { [symbol: string]: number }): number {
    let totalValue = portfolio.cash;
    for (const symbol in portfolio.assets) {
        if (portfolio.assets.hasOwnProperty(symbol) && prices[symbol] !== undefined) {
            totalValue += portfolio.assets[symbol] * prices[symbol];
        }
    }
    return totalValue;
}

// Helper function to create a sample portfolio
function createSamplePortfolio(): Portfolio {
    return {
        assets: {
            'AAPL': 10,
            'GOOGL': 5,
            'AMZN': 2
        },
        cash: 1000
    };
}

// Helper function to create sample prices
function createSamplePrices(): { [symbol: string]: number } {
    return {
        'AAPL': 150,
        'GOOGL': 2800,
        'AMZN': 3400
    };
}

// Sample portfolio and prices
const samplePortfolio = createSamplePortfolio();
const samplePrices = createSamplePrices();

// Calculate the total value of the sample portfolio
const totalValue = calculatePortfolioValue(samplePortfolio, samplePrices);

// Assertions to verify the correctness of the implementation
assert.strictEqual(totalValue, 1000 + (10 * 150) + (5 * 2800) + (2 * 3400), 'The total value of the portfolio should be correctly calculated.');

/**
 * This function assesses the risk of the portfolio based on the standard deviation of asset returns.
 * @param portfolio The portfolio object containing assets and cash.
 * @param historicalPrices Historical prices of the assets.
 * @returns The risk score of the portfolio.
 */


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {
    // Calculate returns for each asset
    const returns: { [symbol: string]: number[] } = {};
    
    for (const symbol in portfolio.assets) {
        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol]) {
            returns[symbol] = [];
            const prices = historicalPrices[symbol];
            
            for (let i = 1; i < prices.length; i++) {
                const dailyReturn = (prices[i] - prices[i-1]) / prices[i-1];
                returns[symbol].push(dailyReturn);
            }
        }
    }
    
    // Calculate portfolio weighted standard deviation
    let totalRisk = 0;
    let totalAssetValue = 0;
    
    for (const symbol in portfolio.assets) {
        if (returns[symbol] && returns[symbol].length > 0) {
            // Calculate mean return
            const meanReturn = returns[symbol].reduce((sum, ret) => sum + ret, 0) / returns[symbol].length;
            
            // Calculate variance
            const variance = returns[symbol].reduce((sum, ret) => sum + Math.pow(ret - meanReturn, 2), 0) / returns[symbol].length;
            
            // Calculate standard deviation
            const stdDev = Math.sqrt(variance);
            
            // Weight by asset value
            const assetValue = portfolio.assets[symbol] * historicalPrices[symbol][historicalPrices[symbol].length - 1];
            totalRisk += stdDev * assetValue;
            totalAssetValue += assetValue;
        }
    }
    
    // Return weighted risk score
    return totalAssetValue > 0 ? totalRisk / totalAssetValue : 0;
}

SUFFIX CODE:
----------------------------------------
// Create sample historical prices
const sampleHistoricalPrices = {
    'AAPL': [148, 150, 149, 151, 150],
    'GOOGL': [2750, 2800, 2780, 2820, 2810],
    'AMZN': [3300, 3400, 3350, 3450, 3420]
};

// Assess the risk of the sample portfolio
const riskScore = assessPortfolioRisk(samplePortfolio, sampleHistoricalPrices);

// Assertions to verify the correctness of the risk assessment
assert(riskScore > 0, 'The risk score should be greater than 0.');

// Cleanup resources
// (No resources to cleanup in this example)


JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic financial calculation scenario involving portfolio analysis and risk assessment, which is relevant for business logic. It requires the model to both generate code from documentation and create comprehensive documentation for code. The provided prefix establishes the context with detailed TypeScript interfaces, helper functions, and example data, ensuring the golden completion and suffix do not repeat code. Assertions verify both the correctness of calculations and the accuracy of documentation, making it a robust test for bidirectional translation capabilities.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * This function assesses the risk of the portfolio based on the standard deviation of asset returns.
 * @param portfolio The portfolio object containing assets and cash.
 * @param historicalPrices Historical prices of the assets.
 * @returns The risk score of the portfolio.
 */`;
assert(docString.toLowerCase().includes('risk of the portfolio'), 'Documentation should describe risk assessment.');
assert(docString.includes('@param portfolio'), 'Documentation should include @param for portfolio.');
assert(docString.includes('@param historicalPrices'), 'Documentation should include @param for historicalPrices.');
assert(docString.includes('@returns'), 'Documentation should include @returns.');

================================================================================

================================================================================
Test Case #9
================================================================================

================================================================================
Test Case ID: 9
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Interface representing a financial instrument.
 */
interface FinancialInstrument {
    id: string;
    name: string;
    type: 'stock' | 'bond' | 'commodity';
    value: number;
}

/**
 * Function to calculate the total value of a portfolio.
 * @param portfolio - An array of financial instruments.
 * @returns The total value of the portfolio.
 */
function calculatePortfolioValue(portfolio: FinancialInstrument[]): number {
    return portfolio.reduce((total, instrument) => total + instrument.value, 0);
}

/**
 * Function to assess the risk of a portfolio based on the types of financial instruments.
 * @param portfolio - An array of financial instruments.
 * @returns The risk level of the portfolio.
 */
function assessPortfolioRisk(portfolio: FinancialInstrument[]): string {
    const riskWeights = { stock: 0.7, bond: 0.2, commodity: 0.1 };
    let riskScore = 0;
    for (const instrument of portfolio) {
        riskScore += riskWeights[instrument.type];
    }
    if (riskScore > 1) {
        return 'High Risk';
    } else if (riskScore > 0.5) {
        return 'Moderate Risk';
    } else {
        return 'Low Risk';
    }
}

/**
 * Example usage:
 * const portfolio: FinancialInstrument[] = [
 *     { id: '1', name: 'AAPL', type: 'stock', value: 150 },
 *     { id: '2', name: 'US Treasury', type: 'bond', value: 100 },
 * ];
 * const totalValue = calculatePortfolioValue(portfolio);
 * const riskLevel = assessPortfolioRisk(portfolio);
 */
/**
 * Function to validate if a portfolio meets certain business rules.
 * @param portfolio - An array of financial instruments.
 * @param maxValue - The maximum allowable value for any single instrument.
 * @returns A boolean indicating if the portfolio is valid.
 * @throws Error if any instrument exceeds the maximum value.
 */


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {
    for (const instrument of portfolio) {
        if (instrument.value > maxValue) {
            throw new Error(`Instrument ${instrument.name} exceeds maximum value of ${maxValue}`);
        }
    }
    return true;
}

SUFFIX CODE:
----------------------------------------
const portfolio: FinancialInstrument[] = [
    { id: '1', name: 'AAPL', type: 'stock', value: 150 },
    { id: '2', name: 'US Treasury', type: 'bond', value: 100 },
];
const totalValue = calculatePortfolioValue(portfolio);
const riskLevel = assessPortfolioRisk(portfolio);
assert(totalValue === 250);
assert(riskLevel === 'Moderate Risk');


JUSTIFICATION:
----------------------------------------
This example is a good test case because it covers a comprehensive financial scenario including portfolio value calculation, risk assessment, and validation against business rules. The provided TypeScript code is sufficiently complex to test bidirectional translation, requiring the LLM to generate detailed documentation and implement a function based on comments. Assertions check for correct implementation and documentation clarity, ensuring functional requirements and error handling are met.

ASSERTIONS:
----------------------------------------
const portfolio: FinancialInstrument[] = [
    { id: '1', name: 'AAPL', type: 'stock', value: 150 },
    { id: '2', name: 'US Treasury', type: 'bond', value: 100 },
];
const maxValue = 200;
let isValid = false;
try {
    isValid = validatePortfolio(portfolio, maxValue);
    assert(isValid === true);
} catch (e) {
    assert(false, 'Validation should not throw an error');
}
const invalidPortfolio: FinancialInstrument[] = [
    { id: '1', name: 'AAPL', type: 'stock', value: 250 },
    { id: '2', name: 'US Treasury', type: 'bond', value: 100 },
];
try {
    validatePortfolio(invalidPortfolio, maxValue);
    assert(false, 'Validation should throw an error for exceeding max value');
} catch (e) {
    assert(e.message === 'Instrument AAPL exceeds maximum value of 200');
}

================================================================================

================================================================================
Test Case #10
================================================================================

================================================================================
Test Case ID: 10
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a business rule.
 */
interface BusinessRule {
    /**
     * Validates if the business rule is satisfied.
     * @param entity - The business entity to validate.
     * @returns True if the rule is satisfied, false otherwise.
     */
    validate(entity: any): boolean;
}

/**
 * Class representing a customer entity.
 */
class Customer {
    constructor(public id: number, public name: string, public age: number) {}
}

/**
 * Business rule to check if a customer is an adult.
 */
class IsAdultRule implements BusinessRule {
    /**
     * Validates if the customer is an adult.
     * @param entity - The customer entity to validate.
     * @returns True if the customer is 18 years or older, false otherwise.
     */
    validate(entity: Customer): boolean {
        return entity.age >= 18;
    }
}

/**
 * Class representing a business rule validator.
 */
class BusinessRuleValidator {
    private rules: BusinessRule[] = [];

    /**
     * Adds a business rule to the validator.
     * @param rule - The business rule to add.
     */
    addRule(rule: BusinessRule): void {
        this.rules.push(rule);
    }

    /**
     * Validates all rules against the given entity.
     * @param entity - The business entity to validate.
     * @returns True if all rules are satisfied, false otherwise.
     */
    validateAll(entity: any): boolean {
        return this.rules.every(rule => rule.validate(entity));
    }
}

// Creating a customer entity
const customer = new Customer(1, 'John Doe', 20);

// Creating a business rule validator
const validator = new BusinessRuleValidator();

// Adding the IsAdultRule to the validator
validator.addRule(new IsAdultRule());

LLM COMPLETION claude-3-7-sonnet:
----------------------------------------

// Validating the customer entity
const isValidCustomer = validator.validateAll(customer);
assert.strictEqual(isValidCustomer, true, 'Customer should be valid');

// Edge case: customer under 18
const youngCustomer = new Customer(2, 'Jane Doe', 17);
const isValidYoungCustomer = validator.validateAll(youngCustomer);
assert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');

console.log('All assertions passed');

SUFFIX CODE:
----------------------------------------
// Validating the customer entity
const isValidCustomer = validator.validateAll(customer);
assert.strictEqual(isValidCustomer, true, 'Customer should be valid');

// Edge case: customer under 18
const youngCustomer = new Customer(2, 'Jane Doe', 17);
const isValidYoungCustomer = validator.validateAll(youngCustomer);
assert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');

console.log('All assertions passed');
function validateCustomer(customer: Customer): boolean {
    return validator.validateAll(customer);
}

// Validate the customer entity
const isCustomerValid = validateCustomer(customer);
assert.strictEqual(isCustomerValid, true, 'Customer should be valid');

JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic scenario involving business rule validation for a customer entity. It includes TypeScript interfaces, classes, and detailed documentation. The golden completion involves translating documentation into a function implementation, showcasing the LLM's ability to understand and generate code based on detailed comments. Assertions verify the functional correctness of the code, including edge cases. The test case covers complex business logic, error handling, and type safety, making it a robust example for evaluating bidirectional translation capabilities.

ASSERTIONS:
----------------------------------------
assert.strictEqual(validateCustomer(customer), true, 'Customer should be valid');
assert.strictEqual(validateCustomer(youngCustomer), false, 'Customer should not be valid');
================================================================================

================================================================================
Test Case #11
================================================================================

================================================================================
Test Case ID: 11
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface Task {
  id: number;
  name: string;
  completed: boolean;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
class TaskManager {
  private tasks: Task[] = [];

  /**
   * Adds a new task to the task manager.
   * @param task - The task to add.
   */
  addTask(task: Task): void {
    this.tasks.push(task);
  }

  /**
   * Marks a task as completed by its ID.
   * @param taskId - The ID of the task to mark as completed.
   */
  completeTask(taskId: number): void {
    const task = this.tasks.find(t => t.id === taskId);
    if (task) {
      task.completed = true;
    } else {
      throw new Error(`Task with ID ${taskId} not found.`);
    }
  }

  /**
   * Removes a task by its ID.
   * @param taskId - The ID of the task to remove.
   */
  removeTask(taskId: number): void {
    const taskIndex = this.tasks.findIndex(t => t.id === taskId);
    if (taskIndex !== -1) {
      this.tasks.splice(taskIndex, 1);
    } else {
      throw new Error(`Task with ID ${taskId} not found.`);
    }
  }

  /**
   * Fetches all completed tasks.
   * @returns An array of completed tasks.
   */
  getCompletedTasks(): Task[] {
    return this.tasks.filter(t => t.completed);
  }

  /**
   * Fetches all pending tasks.
   * @returns An array of pending tasks.
   */
  getPendingTasks(): Task[] {
    return this.tasks.filter(t => !t.completed);
  }
}

const manager = new TaskManager();
manager.addTask({ id: 1, name: 'Task 1', completed: false });
manager.addTask({ id: 2, name: 'Task 2', completed: false });
manager.completeTask(1);
assert.strictEqual(manager.getCompletedTasks().length, 1);
assert.strictEqual(manager.getPendingTasks().length, 1);
assert.strictEqual(manager.getCompletedTasks()[0].id, 1);
assert.strictEqual(manager.getPendingTasks()[0].id, 2);

// Cleanup code (none needed in this scenario)


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves realistic business logic related to task management, with methods for adding, completing, and removing tasks. The golden completion requires generating comprehensive documentation for the TaskManager class, including descriptions of methods and an example usage. The assertions verify the correctness of the generated documentation by ensuring key terms and structure are present.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * The TaskManager class is responsible for managing tasks. It allows for adding new tasks, marking tasks as completed, removing tasks, and fetching tasks based on their completion status.
 * 
 * Methods:
 * - addTask(task: Task): void - Adds a new task to the task manager.
 * - completeTask(taskId: number): void - Marks a task as completed by its ID.
 * - removeTask(taskId: number): void - Removes a task by its ID.
 * - getCompletedTasks(): Task[] - Fetches all completed tasks.
 * - getPendingTasks(): Task[] - Fetches all pending tasks.
 * 
 * Example usage:
 * typescript
 * const manager = new TaskManager();
 * manager.addTask({ id: 1, name: 'Task 1', completed: false });
 * manager.addTask({ id: 2, name: 'Task 2', completed: false });
 * manager.completeTask(1);
 * assert.strictEqual(manager.getCompletedTasks().length, 1);
 * assert.strictEqual(manager.getPendingTasks().length, 1);
 * assert.strictEqual(manager.getCompletedTasks()[0].id, 1);
 * assert.strictEqual(manager.getPendingTasks()[0].id, 2);
 * 
 */`;
assert(docString.toLowerCase().includes('responsible for managing tasks'));
assert(docString.includes('Methods:'));
assert(docString.includes('Example usage:'));
assert(docString.includes('addTask(task: Task): void'));
assert(docString.includes('completeTask(taskId: number): void'));
assert(docString.includes('removeTask(taskId: number): void'));
assert(docString.includes('getCompletedTasks(): Task[]'));
assert(docString.includes('getPendingTasks(): Task[]'));
================================================================================

================================================================================
Test Case #12
================================================================================

================================================================================
Test Case ID: 12
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'node:assert';

/**
 * Interface representing a User entity in the business domain.
 */
interface User {
    id: number;
    username: string;
    email: string;
    isActive: boolean;
}

/**
 * Business rule validation function to check if a user is active.
 * @param user - The user to check
 * @returns boolean - True if the user is active, false otherwise
 */
function isUserActive(user: User): boolean {
    return user.isActive;
}

/**
 * Function to deactivate a user by setting isActive to false.
 * @param user - The user to deactivate
 * @returns User - The updated user object
 */
function deactivateUser(user: User): User {
    return { ...user, isActive: false };
}

/**
 * Interface representing a task in a workflow.
 */
interface Task {
    taskId: number;
    description: string;
    assignedTo: User;
    status: 'pending' | 'in_progress' | 'completed';
}

/**
 * Function to assign a task to a user.
 * @param task - The task to be assigned
 * @param user - The user to assign the task to
 * @returns Task - The updated task object
 */
function assignTask(task: Task, user: User): Task {
    return { ...task, assignedTo: user, status: 'in_progress' };
}

/**
 * Function to mark a task as completed.
 * @param task - The task to be marked as completed
 * @returns Task - The updated task object
 */
function completeTask(task: Task): Task {
    return { ...task, status: 'completed' };
}

// Usage example
const user: User = { id: 1, username: 'johndoe', email: 'john@example.com', isActive: true };
const task1: Task = { taskId: 1, description: 'Task 1', assignedTo: user, status: 'pending' };
const task2: Task = { taskId: 2, description: 'Task 2', assignedTo: user, status: 'pending' };

const assignedTask1 = assignTask(task1, user);
const assignedTask2 = assignTask(task2, user);


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
// Complete the tasks and check if they're all completed
function areAllTasksCompleted(tasks: Task[], user: User): boolean {
    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');
}

SUFFIX CODE:
----------------------------------------

function areAllTasksCompleted(tasks: Task[], user: User): boolean {
    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');
}
const completedTask1 = completeTask(assignedTask1);
const completedTask2 = completeTask(assignedTask2);
assert.strictEqual(areAllTasksCompleted([completedTask1, completedTask2], user), true);

// Cleanup (if any resources need to be released)
// In this example, there are no resources that need explicit cleanup.


JUSTIFICATION:
----------------------------------------
This test case is a good example of code-to-comment translation as it involves multiple functions with different business logic related to user and task management. The prefix includes a comprehensive TypeScript setup with interfaces and functions, demonstrating clear business rules and workflow orchestration. The golden completion requires generating detailed documentation for a function, ensuring the model understands the code context and usage. The assertions verify the functional correctness of the implementation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Function to check if all tasks assigned to a user are completed.
 * @param tasks - Array of tasks
 * @param user - The user to check tasks for
 * @returns boolean - True if all tasks are completed, false otherwise
 */`;
assert(docString.toLowerCase().includes('function to check if all tasks assigned to a user are completed'));
assert(docString.includes('@param tasks - Array of tasks'));
assert(docString.includes('@param user - The user to check tasks for'));
assert(docString.includes('@returns boolean - True if all tasks are completed, false otherwise'));

================================================================================

================================================================================
Test Case #13
================================================================================

================================================================================
Test Case ID: 13
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface Task {
	title: string;
	priority: 'low' | 'medium' | 'high';
	deadline: Date;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
class TaskScheduler {
	private tasks: Task[] = [];

	/**
	 * Adds a new task to the scheduler.
	 * @param task The task to add.
	 */
	addTask(task: Task): void {
		this.tasks.push(task);
	}

	/**
	 * Retrieves tasks sorted by priority and deadline.
	 * @returns A list of tasks sorted first by priority then by deadline.
	 */
	getSortedTasks(): Task[] {
		return this.tasks.sort((a, b) => {
			if (a.priority === b.priority) {
				return a.deadline.getTime() - b.deadline.getTime();
			}
			const priorityOrder = { 'low': 0, 'medium': 1, 'high': 2 };
			return priorityOrder[b.priority] - priorityOrder[a.priority];
		});
	}
}

// Example tasks
const task1: Task = { title: 'Task 1', priority: 'high', deadline: new Date('2023-12-01') };
const task2: Task = { title: 'Task 2', priority: 'medium', deadline: new Date('2023-11-01') };
const task3: Task = { title: 'Task 3', priority: 'low', deadline: new Date('2023-10-01') };

// Initialize TaskScheduler
const scheduler = new TaskScheduler();
scheduler.addTask(task1);
scheduler.addTask(task2);
scheduler.addTask(task3);

// Get sorted tasks
const sortedTasks = scheduler.getSortedTasks();

// Assertions
assert(sortedTasks[0].title === 'Task 1');
assert(sortedTasks[1].title === 'Task 2');
assert(sortedTasks[2].title === 'Task 3');

// Cleanup (if any resources were allocated, which there are none in this case)


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to generate comprehensive documentation for a TypeScript class that handles task scheduling. The provided prefix includes a realistic scenario with multiple methods and a sorting mechanism, which requires clear and detailed documentation. The golden completion includes a class-level TSDoc comment that explains the functionality, usage, and sorting logic. The assertions verify the functionality of the sorted task list, ensuring the documentation aligns with the code behavior. This scenario effectively tests the bidirectional translation between code and comments, focusing on the clarity and completeness of documentation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * TaskScheduler is responsible for managing and scheduling tasks.
 * It allows adding tasks and retrieving them sorted by priority and deadline.
 *
 * Tasks are sorted in descending order of priority ('high' > 'medium' > 'low').
 * Within the same priority level, tasks are sorted by their deadline (earliest first).
 *
 * Example usage:
 * typescript
 * const scheduler = new TaskScheduler();
 * scheduler.addTask({ title: 'New Task', priority: 'high', deadline: new Date('2023-12-31') });
 * const sortedTasks = scheduler.getSortedTasks();
 * 
 *
 * @class TaskScheduler
 */`;
assert(docString.toLowerCase().includes('tasks are sorted in descending order of priority'));
assert(docString.includes('Example usage:'));
assert(docString.includes('@class TaskScheduler'));
assert(docString.includes('priority and deadline'));

================================================================================

================================================================================
Test Case #14
================================================================================

================================================================================
Test Case ID: 14
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface User {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
class UserManager {
    private users: User[] = [];

    /**
     * Adds a new user to the manager.
     * @param user - The user to add.
     */
    addUser(user: User): void {
        this.users.push(user);
    }

    /**
     * Fetches a user by their ID.
     * @param id - The ID of the user to fetch.
     * @returns The user with the given ID, or undefined if not found.
     */
    getUserById(id: number): User | undefined {
        return this.users.find(user => user.id === id);
    }

    /**
     * Updates the active status of a user.
     * @param id - The ID of the user to update.
     * @param isActive - The new active status.
     * @returns True if the user was found and updated, false otherwise.
     */
    updateUserStatus(id: number, isActive: boolean): boolean {
        const user = this.getUserById(id);
        if (user) {
            user.isActive = isActive;
            return true;
        }
        return false;
    }

    /**
     * Removes a user by their ID.
     * @param id - The ID of the user to remove.
     * @returns True if the user was found and removed, false otherwise.
     */
    removeUser(id: number): boolean {
        const index = this.users.findIndex(user => user.id === id);
        if (index !== -1) {
            this.users.splice(index, 1);
            return true;
        }
        return false;
    }
}

const userManager = new UserManager();
userManager.addUser({ id: 1, name: 'Alice', email: 'alice@example.com', isActive: true });
userManager.addUser({ id: 2, name: 'Bob', email: 'bob@example.com', isActive: false });
assert.strictEqual(userManager.getUserById(1)?.name, 'Alice');
assert.strictEqual(userManager.updateUserStatus(2, true), true);
assert.strictEqual(userManager.getUserById(2)?.isActive, true);
assert.strictEqual(userManager.removeUser(1), true);
assert.strictEqual(userManager.getUserById(1), undefined);
console.log('All tests passed.');

JUSTIFICATION:
----------------------------------------
This example is a good test case because it involves realistic business logic for managing user entities, including adding, updating, fetching, and removing users. It requires translation between code and comprehensive documentation, making it ideal for testing an LLM's ability to generate and interpret detailed comments and code. The provided assertions verify the correctness of the implementation, ensuring that the code behaves as expected.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * UserManager class handles operations related to User entities.
 * It allows adding, fetching, updating, and removing users.
 */
`;
assert(docString.includes('UserManager class handles operations related to User entities.'));
assert(docString.includes('It allows adding, fetching, updating, and removing users.'));
================================================================================

================================================================================
Test Case #15
================================================================================

================================================================================
Test Case ID: 15
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Represents a user in the system.
 */
interface User {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
}

/**
 * Business logic for activating users based on specific criteria.
 * @param users - Array of users to be evaluated.
 * @returns An array of users who are successfully activated.
 */
function activateEligibleUsers(users: User[]): User[] {
  const activatedUsers: User[] = [];

  users.forEach(user => {
    if (user.isActive) {
      return;
    }

    // Business rule: Only activate users with a valid email domain
    const emailDomain = user.email.split('@')[1];
    if (emailDomain !== 'example.com') {
      return;
    }

    user.isActive = true;
    activatedUsers.push(user);
  });

  return activatedUsers;
}

// Example user data
const users: User[] = [
  { id: 1, name: 'Alice', email: 'alice@example.com', isActive: false },
  { id: 2, name: 'Bob', email: 'bob@another.com', isActive: false },
  { id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true }
];

/**
 * Tests for the activateEligibleUsers function.
 */
function testActivateEligibleUsers() {
  const result = activateEligibleUsers(users);
  assert.strictEqual(result.length, 1);
  assert.strictEqual(result[0].name, 'Alice');
  assert.strictEqual(result[0].isActive, true);
  assert.strictEqual(users[1].isActive, false);
  assert.strictEqual(users[2].isActive, true);
}

testActivateEligibleUsers();

// The function to deactivate users who no longer meet criteria needs to be implemented
/**
 * @param users - Array of users to be evaluated.
 * @returns An array of users who are successfully deactivated.
 */
function deactivateIneligibleUsers(users: User[]): User[] {


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
  const deactivatedUsers: User[] = [];

  users.forEach(user => {
    if (!user.isActive) {
      return;
    }

    // Business rule: Deactivate users without a valid email domain
    const emailDomain = user.email.split('@')[1];
    if (emailDomain === 'example.com') {
      return;
    }

    user.isActive = false;
    deactivatedUsers.push(user);
  });

  return deactivatedUsers;
}

SUFFIX CODE:
----------------------------------------

// Example data to test deactivation logic
const moreUsers: User[] = [
  { id: 4, name: 'David', email: 'david@example.com', isActive: true },
  { id: 5, name: 'Eve', email: 'eve@another.com', isActive: true }
];

/**
 * Tests for the deactivateIneligibleUsers function.
 */
function testDeactivateIneligibleUsers() {
  const result = deactivateIneligibleUsers(moreUsers);
  assert.strictEqual(result.length, 1);
  assert.strictEqual(result[0].name, 'Eve');
  assert.strictEqual(result[0].isActive, false);
  assert.strictEqual(moreUsers[0].isActive, true);
}

testDeactivateIneligibleUsers();


JUSTIFICATION:
----------------------------------------
This test case is a good example because it demonstrates the translation between code and natural language in both directions. The prefix provides a comprehensive setup with detailed comments and implementation for activating users, while the suffix calls for the implementation of deactivating users based on specific criteria. The golden completion involves writing the actual logic for deactivating users, and the assertions ensure the correctness of both the activation and deactivation logic. This scenario covers complex business rules, error handling, and functional testing.

ASSERTIONS:
----------------------------------------
assert.strictEqual(typeof deactivateIneligibleUsers, 'function');
assert.strictEqual(deactivateIneligibleUsers.length, 1);
const deactivatedUsersResult = deactivateIneligibleUsers(moreUsers);
assert(Array.isArray(deactivatedUsersResult));
assert.strictEqual(deactivatedUsersResult.length, 1);
assert.strictEqual(deactivatedUsersResult[0].name, 'Eve');
assert.strictEqual(deactivatedUsersResult[0].isActive, false);
================================================================================

================================================================================
Test Case #16
================================================================================

================================================================================
Test Case ID: 16
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a business rule validation result.
 */
interface ValidationResult {
    isValid: boolean;
    errors: string[];
}

/**
 * Class to handle business rules validation.
 */
class BusinessRulesValidator {
    private rules: ((input: any) => ValidationResult)[];

    constructor() {
        this.rules = [];
    }

    /**
     * Add a new validation rule.
     * @param rule - Function that takes an input and returns a ValidationResult.
     */
    addRule(rule: (input: any) => ValidationResult): void {
        this.rules.push(rule);
    }

    /**
     * Validate the input against all the added rules.
     * @param input - The input to validate.
     * @returns ValidationResult - The result of the validation.
     */
    validate(input: any): ValidationResult {
        const errors: string[] = [];
        let isValid = true;

        for (const rule of this.rules) {
            const result = rule(input);
            if (!result.isValid) {
                isValid = false;
                errors.push(...result.errors);
            }
        }

        return { isValid, errors };
    }
}

// Example usage:
const validator = new BusinessRulesValidator();

// Adding a rule that checks if the input is a non-empty string
validator.addRule((input: any) => {
    const errors: string[] = [];
    if (typeof input !== 'string' || input.trim() === '') {
        errors.push('Input must be a non-empty string');
        return { isValid: false, errors };
    }
    return { isValid: true, errors };
});

// Adding a rule that checks if the input string is at least 5 characters long
validator.addRule((input: any) => {
    const errors: string[] = [];
    if (typeof input === 'string' && input.length < 5) {
        errors.push('Input must be at least 5 characters long');
        return { isValid: false, errors };
    }
    return { isValid: true, errors };
});

// Validation example
const result = validator.validate('test');
assert.strictEqual(result.isValid, false);
assert.ok(result.errors.includes('Input must be at least 5 characters long'));

// Validation example with a valid input
const validResult = validator.validate('valid input');
assert.strictEqual(validResult.isValid, true);
assert.strictEqual(validResult.errors.length, 0);

/**
 * Validate the input against all the added rules.
 * @param input - The input to validate.
 * @returns ValidationResult - The result of the validation.
 */



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
const anotherValidResult = validator.validate('another valid input');

SUFFIX CODE:
----------------------------------------
const anotherValidResult = validator.validate('another valid input');
assert.strictEqual(anotherValidResult.isValid, true);
assert.strictEqual(anotherValidResult.errors.length, 0);

console.log('All assertions passed.');


JUSTIFICATION:
----------------------------------------
This test case is a good example of bidirectional translation between code and natural language because it involves complex business logic related to validation rules, and the provided documentation includes detailed descriptions of parameters and return types. The scenario demonstrates realistic usage of TypeScript's type system and functional requirements, ensuring that the implementation is both practical and comprehensive. The assertions verify the correctness of the implementation and the accuracy of the documentation.

ASSERTIONS:
----------------------------------------
assert.strictEqual(typeof validate, 'function');
const docString = validate.toString();
assert(docString.includes('Validate the input against all the added rules.'));
assert(docString.includes('@param input'));
assert(docString.includes('@returns ValidationResult'));
assert.strictEqual(result.isValid, false);
assert.ok(result.errors.includes('Input must be at least 5 characters long'));
assert.strictEqual(validResult.isValid, true);
assert.strictEqual(validResult.errors.length, 0);

================================================================================

================================================================================
Test Case #17
================================================================================

================================================================================
Test Case ID: 17
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a user profile.
 */
interface UserProfile {
	id: string;
	name: string;
	email: string;
	isActive: boolean;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
class UserManager {
	private users: UserProfile[] = [];

	/**
	 * Add a new user to the manager.
	 * @param user - The user profile to add.
	 */
	addUser(user: UserProfile): void {
		this.users.push(user);
	}

	/**
	 * Get a user by their ID.
	 * @param userId - The ID of the user to retrieve.
	 * @returns The user profile if found, otherwise null.
	 */
	getUserById(userId: string): UserProfile | null {
		return this.users.find(user => user.id === userId) || null;
	}

	/**
	 * Update the active status of a user.
	 * @param userId - The ID of the user to update.
	 * @param isActive - The new active status of the user.
	 */
	updateUserStatus(userId: string, isActive: boolean): void {
		const user = this.getUserById(userId);
		if (user) {
			user.isActive = isActive;
		}
	}

	/**
	 * Remove a user by their ID.
	 * @param userId - The ID of the user to remove.
	 */
	removeUser(userId: string): void {
		this.users = this.users.filter(user => user.id !== userId);
	}

	/**
	 * Get all active users.
	 * @returns An array of active user profiles.
	 */
	getActiveUsers(): UserProfile[] {
		return this.users.filter(user => user.isActive);
	}
}

const userManager = new UserManager();

// Adding users to the manager
userManager.addUser({ id: '1', name: 'Alice', email: 'alice@example.com', isActive: true });
userManager.addUser({ id: '2', name: 'Bob', email: 'bob@example.com', isActive: false });

// Retrieving a user
const alice = userManager.getUserById('1');
assert(alice !== null);
assert(alice?.name === 'Alice');

// Updating user status
userManager.updateUserStatus('2', true);
const bob = userManager.getUserById('2');
assert(bob !== null);
assert(bob?.isActive);

// Removing a user
userManager.removeUser('1');
const removedUser = userManager.getUserById('1');
assert(removedUser === null);

// Getting all active users
const activeUsers = userManager.getActiveUsers();
assert(activeUsers.length === 1);
assert(activeUsers[0].name === 'Bob');

JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate an LLM's capability to generate comprehensive documentation for a class implementation, including method descriptions, parameter types, return values, and usage examples. The UserManager class encapsulates a realistic business scenario of managing user profiles, providing various methods with different complexities and interactions. This scenario ensures the LLM can understand and document not only simple methods but also those involving conditionals and array operations. Additionally, the assertions verify the correctness of the class methods, ensuring the documentation accurately reflects the implementation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * The UserManager class is responsible for managing user profiles. It provides methods to add, retrieve, update, and remove users, as well as to get all active users.
 *
 * Methods:
 * - addUser(user: UserProfile): void - Adds a new user to the manager.
 * - getUserById(userId: string): UserProfile | null - Retrieves a user by their ID.
 * - updateUserStatus(userId: string, isActive: boolean): void - Updates the active status of a user.
 * - removeUser(userId: string): void - Removes a user by their ID.
 * - getActiveUsers(): UserProfile[] - Gets all active users.
 *
 * Example Usage:
 * typescript
 * const userManager = new UserManager();
 * userManager.addUser({ id: '1', name: 'Alice', email: 'alice@example.com', isActive: true });
 * const alice = userManager.getUserById('1');
 * console.log(alice?.name); // Alice
 * userManager.updateUserStatus('2', true);
 * const bob = userManager.getUserById('2');
 * console.log(bob?.isActive); // true
 * 
 */`;

assert(docString.includes('The UserManager class is responsible for managing user profiles.'));
assert(docString.includes('Methods:'));
assert(docString.includes('addUser(user: UserProfile): void - Adds a new user to the manager.'));
assert(docString.includes('getUserById(userId: string): UserProfile | null - Retrieves a user by their ID.'));
assert(docString.includes('updateUserStatus(userId: string, isActive: boolean): void - Updates the active status of a user.'));
assert(docString.includes('removeUser(userId: string): void - Removes a user by their ID.'));
assert(docString.includes('getActiveUsers(): UserProfile[] - Gets all active users.'));
assert(docString.includes('Example Usage:'));
assert(docString.includes('const userManager = new UserManager();'));
assert(docString.includes('console.log(alice?.name); // Alice'));
assert(docString.includes('console.log(bob?.isActive); // true'));
================================================================================

================================================================================
Test Case #18
================================================================================

================================================================================
Test Case ID: 18
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface User {
    id: string;
    name: string;
    role: string;
}

interface Policy {
    id: string;
    name: string;
    conditions: (user: User) => boolean;
}

const policies: Policy[] = [
    {
        id: '1',
        name: 'AdminAccess',
        conditions: (user: User) => user.role === 'admin'
    },
    {
        id: '2',
        name: 'UserAccess',
        conditions: (user: User) => user.role === 'user'
    }
];

/**
 * Validates if a user complies with the provided policies.
 * @param user - The user to validate.
 * @param policies - The list of policies to check against.
 * @returns A list of policy names that the user complies with.
 */
function validateUserCompliance(user: User, policies: Policy[]): string[] {
    return policies.filter(policy => policy.conditions(user)).map(policy => policy.name);
}

// Example user
const exampleUser: User = {
    id: '123',
    name: 'Alice',
    role: 'admin'
};

// Validate compliance for the example user
const complianceResults = validateUserCompliance(exampleUser, policies);

// Assertions to verify the functionality
assert.deepStrictEqual(complianceResults, ['AdminAccess']);

// Another example user
const anotherUser: User = {
    id: '456',
    name: 'Bob',
    role: 'user'
};

// Validate compliance for another user
const anotherComplianceResults = validateUserCompliance(anotherUser, policies);

// Assertions to verify the functionality
assert.deepStrictEqual(anotherComplianceResults, ['UserAccess']);

/**
 * Handles the validation of user compliance with multiple policies.
 * @param users - The list of users to validate.
 * @param policies - The list of policies to check against.
 * @returns A map where the keys are user IDs and the values are arrays of policy names that each user complies with.
 */

LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {
    const result: Record<string, string[]> = {};
    
    for (const user of users) {
        result[user.id] = validateUserCompliance(user, policies);
    }
    
    return result;
}

SUFFIX CODE:
----------------------------------------


// Example users list
const usersList: User[] = [
    exampleUser,
    anotherUser
];

// Validate compliance for multiple users
const multipleComplianceResults = validateMultipleUsersCompliance(usersList, policies);

// Assertions to verify the functionality
assert.deepStrictEqual(multipleComplianceResults, {
    '123': ['AdminAccess'],
    '456': ['UserAccess']
});


JUSTIFICATION:
----------------------------------------
This example provides a realistic scenario of validating user compliance with business policies, which involves complex business logic. The prefix sets up the context with TypeScript interfaces, example data, and a function for validating a single user. The golden completion and suffix extend this to handle multiple users, demonstrating both code-to-comment and comment-to-code translation. Assertions verify the correctness of the implementation and documentation accuracy, ensuring that the generated code meets the specified requirements.

ASSERTIONS:
----------------------------------------
assert.deepStrictEqual(complianceResults, ['AdminAccess']);
assert.deepStrictEqual(anotherComplianceResults, ['UserAccess']);
assert.deepStrictEqual(multipleComplianceResults, {
    '123': ['AdminAccess'],
    '456': ['UserAccess']
});
================================================================================

================================================================================
Test Case #19
================================================================================

================================================================================
Test Case ID: 19
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a User in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    role: string;
}

/**
 * Function to check if a user has admin privileges.
 * @param user - The user to check.
 * @returns True if the user has admin privileges, false otherwise.
 */
function isAdmin(user: User): boolean {
    return user.role === 'admin';
}

/**
 * Class representing a UserManager for handling user-related operations.
 */
class UserManager {
    private users: User[];

    constructor() {
        this.users = [];
    }

    /**
     * Adds a new user to the system.
     * @param user - The user to add.
     */
    addUser(user: User): void {
        this.users.push(user);
    }

    /**
     * Gets a user by their ID.
     * @param id - The ID of the user to retrieve.
     * @returns The user with the specified ID, or undefined if not found.
     */
    getUserById(id: number): User | undefined {
        return this.users.find(user => user.id === id);
    }

    /**
     * Removes a user by their ID.
     * @param id - The ID of the user to remove.
     * @returns True if the user was successfully removed, false otherwise.
     */
    removeUser(id: number): boolean {
        const userIndex = this.users.findIndex(user => user.id === id);
        if (userIndex !== -1) {
            this.users.splice(userIndex, 1);
            return true;
        }
        return false;
    }

    /**
     * Lists all users in the system.
     * @returns An array of all users.
     */
    listUsers(): User[] {
        return this.users;
    }

    /**
     * Checks if a user with a specific email exists.
     * @param email - The email to check.
     * @returns True if a user with the email exists, false otherwise.
     */
    userExists(email: string): boolean {
        return this.users.some(user => user.email === email);
    }

    /**
     * Updates the email of a user.
     * @param id - The ID of the user to update.
     * @param newEmail - The new email to set.
     * @returns True if the email was successfully updated, false otherwise.
     */


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
    updateUserEmail(id: number, newEmail: string): boolean {
        const user = this.getUserById(id);
        if (user) {
            user.email = newEmail;
            return true;
        }
        return false;
    }

SUFFIX CODE:
----------------------------------------
updateUserEmail(id: number, newEmail: string): boolean {
    const user = this.getUserById(id);
    if (user) {
        user.email = newEmail;
        return true;
    }
    return false;
}
}

// Example usage
const userManager = new UserManager();
userManager.addUser({ id: 1, name: 'John Doe', email: 'john@example.com', role: 'user' });
userManager.addUser({ id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'admin' });

assert.strictEqual(userManager.userExists('john@example.com'), true);
assert.strictEqual(userManager.userExists('nonexistent@example.com'), false);
assert.strictEqual(userManager.updateUserEmail(1, 'newjohn@example.com'), true);
assert.strictEqual(userManager.getUserById(1)?.email, 'newjohn@example.com');
assert.strictEqual(userManager.updateUserEmail(3, 'nonexistent@example.com'), false);


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves realistic business logic related to user management, including adding, retrieving, updating, and removing users. The code-to-comment translation tests the model's ability to document a method for updating a user's email, while the comment-to-code translation tests the model's ability to implement the described functionality. The assertions verify that the user management operations work as expected, including edge cases such as attempting to update a non-existent user.

ASSERTIONS:
----------------------------------------
assert.strictEqual(userManager.updateUserEmail(1, 'newjohn@example.com'), true);
assert.strictEqual(userManager.getUserById(1)?.email, 'newjohn@example.com');
assert.strictEqual(userManager.updateUserEmail(3, 'nonexistent@example.com'), false);
================================================================================

================================================================================
Test Case #20
================================================================================

================================================================================
Test Case ID: 20
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
import { strict as assert } from 'assert';

class Task {

SUFFIX CODE:
----------------------------------------
class Task {
    id: string;
    name: string;
    completed: boolean;

    constructor(id: string, name: string) {
        this.id = id;
        this.name = name;
        this.completed = false;
    }

    /**
     * Marks the task as completed.
     */
    complete() {
        this.completed = true;
    }
}

/**
 * A class representing a Workflow which orchestrates multiple tasks.
 */
class Workflow {
    tasks: Task[];

    constructor() {
        this.tasks = [];
    }

    /**
     * Adds a new task to the workflow.
     * @param {string} id - The unique identifier for the task.
     * @param {string} name - The name of the task.
     */
    addTask(id: string, name: string) {
        const task = new Task(id, name);
        this.tasks.push(task);
    }

    /**
     * Marks a task as completed by its ID.
     * @param {string} taskId - The unique identifier of the task to complete.
     */
    completeTask(taskId: string) {
        const task = this.tasks.find(t => t.id === taskId);
        if (task) {
            task.complete();
        } else {
            throw new Error(`Task with id ${taskId} not found`);
        }
    }

    /**
     * Checks if all tasks in the workflow are completed.
     * @returns {boolean} - True if all tasks are completed, false otherwise.
     */
    allTasksCompleted(): boolean {
        return this.tasks.every(task => task.completed);
    }
}

/**
 * Example usage of the Workflow class.
 */
const workflow = new Workflow();
workflow.addTask('1', 'Task 1');
workflow.addTask('2', 'Task 2');
workflow.completeTask('1');
assert(workflow.allTasksCompleted() === false);
workflow.completeTask('2');
assert(workflow.allTasksCompleted() === true);

/**
 * Function to validate the workflow based on a specific rule:
 * All tasks must be completed within a certain timeframe.
 * @param {Workflow} workflow - The workflow to validate.
 * @param {number} timeframe - The maximum allowed time in milliseconds.
 * @returns {boolean} - True if the workflow meets the rule, false otherwise.
 */
function validateWorkflow(workflow: Workflow, timeframe: number): boolean {
    // Mock implementation for the sake of example
    return workflow.allTasksCompleted();
}

assert(validateWorkflow(workflow, 1000) === true);


JUSTIFICATION:
----------------------------------------
This test case is an excellent example of translating between code and natural language because it involves defining and documenting two complex classes (Task and Workflow) that interact with each other. The provided code includes realistic business logic related to task management within a workflow, which is a common use case in many software applications. The golden completion focuses on generating comprehensive TSDoc comments for the classes, explaining their properties and methods, which is essential for understanding and maintaining the code. The assertions verify the correct functionality of the workflow, ensuring that tasks can be added, completed, and checked for completion status. This scenario tests the LLM's ability to generate detailed and accurate documentation for given code, ensuring that all key concepts and relationships are covered.

ASSERTIONS:
----------------------------------------
const taskDocString = `/**
 * A class representing a Task in a workflow system.
 * 
 * @class Task
 * @property {string} id - The unique identifier for the task.
 * @property {string} name - The name of the task.
 * @property {boolean} completed - The completion status of the task.
 */`;
const workflowDocString = `/**
 * A class representing a Workflow which orchestrates multiple tasks.
 * 
 * @class Workflow
 * @property {Task[]} tasks - The list of tasks in the workflow.
 */`;
assert(taskDocString.includes('A class representing a Task in a workflow system'));
assert(taskDocString.includes('@property {string} id'));
assert(taskDocString.includes('@property {string} name'));
assert(taskDocString.includes('@property {boolean} completed'));
assert(workflowDocString.includes('A class representing a Workflow which orchestrates multiple tasks'));
assert(workflowDocString.includes('@property {Task[]} tasks'));

================================================================================

================================================================================
Test Case #21
================================================================================

================================================================================
Test Case ID: 21
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a business entity
 */
interface BusinessEntity {
    id: number;
    name: string;
    isActive: boolean;
}

/**
 * Function to validate business rules
 *
 * @param entity - The business entity to validate
 * @returns True if the entity is valid, otherwise false
 */
function validateEntity(entity: BusinessEntity): boolean {
    if (!entity.name || entity.name.length === 0) {
        return false;
    }
    if (typeof entity.isActive !== 'boolean') {
        return false;
    }
    return true;
}

/**
 * Function to activate an entity
 *
 * @param entity - The business entity to activate
 * @returns The activated business entity
 */
function activateEntity(entity: BusinessEntity): BusinessEntity {
    if (validateEntity(entity)) {
        entity.isActive = true;
        return entity;
    }
    throw new Error('Invalid entity');
}

/**
 * Function to deactivate an entity
 *
 * @param entity - The business entity to deactivate
 * @returns The deactivated business entity
 */
function deactivateEntity(entity: BusinessEntity): BusinessEntity {
    if (validateEntity(entity)) {
        entity.isActive = false;
        return entity;
    }
    throw new Error('Invalid entity');
}

const entity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };
const invalidEntity: BusinessEntity = { id: 2, name: '', isActive: true };


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
assert(validateEntity(entity) === true);
assert(validateEntity(invalidEntity) === false);

SUFFIX CODE:
----------------------------------------
assert(entity.isActive === false);
const activatedEntity = activateEntity(entity);
assert(activatedEntity.isActive === true);
try {
    activateEntity(invalidEntity);
} catch (error) {
    assert(error instanceof Error);
    assert(error.message === 'Invalid entity');
}
const deactivatedEntity = deactivateEntity(activatedEntity);
assert(deactivatedEntity.isActive === false);


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves complex business logic related to validating and toggling the state of a business entity. It requires understanding of TypeScript types and interfaces, as well as implementing error handling. The documentation is comprehensive, explaining the function's purpose, parameters, and return value, which helps test the LLM's ability to generate clear and accurate documentation. Additionally, the assertions verify functional correctness and error handling, ensuring the implementation meets the requirements.

ASSERTIONS:
----------------------------------------
assert(toggleEntityActivation(entity).isActive === true);
assert(entity.isActive === true);
try {
    toggleEntityActivation(invalidEntity);
} catch (error) {
    assert(error instanceof Error);
    assert(error.message === 'Invalid entity');
}

================================================================================

================================================================================
Test Case #22
================================================================================

================================================================================
Test Case ID: 22
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a User in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    role: 'admin' | 'user';
}

/**
 * Interface for policy validation rules.
 */
interface Policy {
    validate: (user: User) => boolean;
}

/**
 * Policy that ensures only admins can perform certain actions.
 */
class AdminPolicy implements Policy {
    validate(user: User): boolean {
        return user.role === 'admin';
    }
}

/**
 * Policy that ensures the user's email is verified.
 */
class EmailVerifiedPolicy implements Policy {
    validate(user: User): boolean {
        return user.email.includes('@');
    }
}

/**
 * PolicyValidator orchestrates multiple policy checks.
 */
class PolicyValidator {
    private policies: Policy[];

    constructor(policies: Policy[]) {
        this.policies = policies;
    }

    /**
     * Validates a user against all configured policies.
     * @param user - The user to be validated
     * @returns true if the user passes all policies, false otherwise
     */
    validate(user: User): boolean {
        for (const policy of this.policies) {
            if (!policy.validate(user)) {
                return false;
            }
        }
        return true;
    }
}

// Example user objects
const adminUser: User = { id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' };
const regularUser: User = { id: 2, name: 'Bob', email: 'bob@domain.com', role: 'user' };
const invalidUser: User = { id: 3, name: 'Charlie', email: 'charlie', role: 'user' };

// Initialize policies
const policies: Policy[] = [new AdminPolicy(), new EmailVerifiedPolicy()];

// Create PolicyValidator instance
const policyValidator = new PolicyValidator(policies);

// Validate users


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
const adminResult = policyValidator.validate(adminUser);
const regularResult = policyValidator.validate(regularUser);
const invalidResult = policyValidator.validate(invalidUser);

assert.strictEqual(adminResult, true, 'Admin user should pass all policies');
assert.strictEqual(regularResult, false, 'Regular user should fail the admin policy');

SUFFIX CODE:
----------------------------------------
// Assertions
assert.strictEqual(policyValidator.validate(invalidUser), false, 'User with invalid email should fail the email policy');

console.log('All assertions passed');

JUSTIFICATION:
----------------------------------------
This test case is designed to assess the ability of a language model to translate between TypeScript code and natural language documentation. The scenario involves validating user objects against multiple policy rules, which is a common business logic requirement. The example includes detailed TSDoc comments and a comprehensive implementation that tests both code-to-comment and comment-to-code translation capabilities. The assertions ensure the functional correctness of the implementation and verify that the documentation accurately describes the code's behavior.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Interface representing a User in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    role: 'admin' | 'user';
}

/**
 * Interface for policy validation rules.
 */
interface Policy {
    validate: (user: User) => boolean;
}

/**
 * Policy that ensures only admins can perform certain actions.
 */
class AdminPolicy implements Policy {
    validate(user: User): boolean {
        return user.role === 'admin';
    }
}

/**
 * Policy that ensures the user's email is verified.
 */
class EmailVerifiedPolicy implements Policy {
    validate(user: User): boolean {
        return user.email.includes('@');
    }
}

/**
 * PolicyValidator orchestrates multiple policy checks.
 */
class PolicyValidator {
    private policies: Policy[];

    constructor(policies: Policy[]) {
        this.policies = policies;
    }

    /**
     * Validates a user against all configured policies.
     * @param user - The user to be validated
     * @returns true if the user passes all policies, false otherwise
     */
    validate(user: User): boolean {
        for (const policy of this.policies) {
            if (!policy.validate(user)) {
                return false;
            }
        }
        return true;
    }
}

// Example user objects
const adminUser: User = { id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' };
const regularUser: User = { id: 2, name: 'Bob', email: 'bob@domain.com', role: 'user' };
const invalidUser: User = { id: 3, name: 'Charlie', email: 'charlie', role: 'user' };

// Initialize policies
const policies: Policy[] = [new AdminPolicy(), new EmailVerifiedPolicy()];

// Create PolicyValidator instance
const policyValidator = new PolicyValidator(policies);

// Validate users
assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');
assert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');
assert.strictEqual(policyValidator.validate(invalidUser), false, 'User with invalid email should fail the email policy');

console.log('All assertions passed');`;
assert(docString.includes('Interface representing a User in the system.'));
assert(docString.includes('Interface for policy validation rules.'));
assert(docString.includes('Policy that ensures only admins can perform certain actions.'));
assert(docString.includes('Policy that ensures the user\'s email is verified.'));
assert(docString.includes('PolicyValidator orchestrates multiple policy checks.'));
assert(docString.includes('@param user - The user to be validated'));
assert(docString.includes('@returns true if the user passes all policies, false otherwise'));
assert(docString.includes('Admin user should pass all policies'));
assert(docString.includes('Regular user should fail the admin policy'));
assert(docString.includes('User with invalid email should fail the email policy'));
assert(docString.includes('All assertions passed'));

console.log('Documentation assertions passed');
================================================================================

================================================================================
Test Case #23
================================================================================

================================================================================
Test Case ID: 23
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

interface User {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
}

interface Policy {
  id: number;
  name: string;
  description: string;
  isActive: boolean;
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
}

/**
 * Validates a user against a set of policies.
 * @param user - The user to validate.
 * @param policies - The policies to validate against.
 * @returns A validation result containing a boolean indicating if the user passed all policies and an array of error messages.
 */
function validateUser(user: User, policies: Policy[]): ValidationResult {
  const errors: string[] = [];
  for (const policy of policies) {
    if (!policy.isActive) continue;
    if (policy.name === 'Active User' && !user.isActive) {
      errors.push('User is not active');
    }
    if (policy.name === 'Valid Email' && !user.email.includes('@')) {
      errors.push('User email is invalid');
    }
  }
  return { valid: errors.length === 0, errors };
}

const user: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com', isActive: true };
const policies: Policy[] = [
  { id: 1, name: 'Active User', description: 'User must be active', isActive: true },
  { id: 2, name: 'Valid Email', description: 'User must have a valid email', isActive: true }
];

const validationResult = validateUser(user, policies);
assert(validationResult.valid);
assert(validationResult.errors.length === 0);

// Additional complex business rule: User must have a unique email
/**
 * Validates that the user's email is unique in the system.
 * @param user - The user to validate.
 * @param existingUsers - The list of existing users in the system.
 * @returns A validation result containing a boolean indicating if the user's email is unique and an array of error messages.
 */

LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {
  const errors: string[] = [];
  
  const duplicateEmail = existingUsers.some(existingUser => 
    existingUser.id !== user.id && existingUser.email === user.email
  );
  
  if (duplicateEmail) {
    errors.push('Email is already in use by another user');
  }
  
  return { valid: errors.length === 0, errors };
}

SUFFIX CODE:
----------------------------------------

const existingUsers: User[] = [
  { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com', isActive: true },
  { id: 3, name: 'Alice Johnson', email: 'alice.johnson@example.com', isActive: false }
];

const uniqueEmailValidationResult = validateUniqueEmail(user, existingUsers);
assert(uniqueEmailValidationResult.valid);
assert(uniqueEmailValidationResult.errors.length === 0);

// Clean up resources if any


JUSTIFICATION:
----------------------------------------
This test case demonstrates the bidirectional translation between TypeScript code and detailed comments. The prefix provides a comprehensive setup with interfaces, an initial validation function, and test assertions. The golden completion requires implementing a new validation function based on a given comment, testing the model's ability to translate comments into code. The suffix includes further assertions and resource cleanup. This scenario tests complex business rules validation and ensures the model can handle detailed TypeScript documentation and implementation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Validates that the user's email is unique in the system.
 * @param user - The user to validate.
 * @param existingUsers - The list of existing users in the system.
 * @returns A validation result containing a boolean indicating if the user's email is unique and an array of error messages.
 */`;
assert(docString.toLowerCase().includes('validates that the user\'s email is unique'));
assert(docString.includes('Parameters:'));
assert(docString.includes('user - The user to validate'));
assert(docString.includes('ValidationResult'));
assert(docString.includes('boolean indicating if the user\'s email is unique'));

const existingUsers: User[] = [
  { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com', isActive: true },
  { id: 3, name: 'Alice Johnson', email: 'alice.johnson@example.com', isActive: false }
];
const uniqueEmailValidationResult = validateUniqueEmail(user, existingUsers);
assert(uniqueEmailValidationResult.valid);
assert(uniqueEmailValidationResult.errors.length === 0);

================================================================================

================================================================================
Test Case #24
================================================================================

================================================================================
Test Case ID: 24
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a business policy.
 */
interface Policy {
    id: string;
    name: string;
    isActive: boolean;
    conditions: Condition[];
}

/**
 * Interface representing a condition within a policy.
 */
interface Condition {
    field: string;
    operator: 'equals' | 'notEquals' | 'greaterThan' | 'lessThan';
    value: any;
}

/**
 * Function to evaluate a single condition.
 * @param condition The condition to evaluate.
 * @param data The data to evaluate the condition against.
 * @returns True if the condition is met, false otherwise.
 */
function evaluateCondition(condition: Condition, data: any): boolean {
    switch (condition.operator) {
        case 'equals':
            return data[condition.field] === condition.value;
        case 'notEquals':
            return data[condition.field] !== condition.value;
        case 'greaterThan':
            return data[condition.field] > condition.value;
        case 'lessThan':
            return data[condition.field] < condition.value;
        default:
            throw new Error(`Unsupported operator: ${condition.operator}`);
    }
}

/**
 * Function to evaluate all conditions within a policy.
 * @param policy The policy whose conditions should be evaluated.
 * @param data The data to evaluate the conditions against.
 * @returns True if all conditions are met, false otherwise.
 */
function evaluatePolicy(policy: Policy, data: any): boolean {
    for (const condition of policy.conditions) {
        if (!evaluateCondition(condition, data)) {
            return false;
        }
    }
    return true;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
/**
 * Function to validate a set of policies against provided data.
 * @param policies The policies to validate.
 * @param data The data to validate against.
 * @returns An array of policy IDs that are not compliant with the data.
 */

SUFFIX CODE:
----------------------------------------

function validatePolicies(policies: Policy[], data: any): string[] {
    const nonCompliantPolicies: string[] = [];
    for (const policy of policies) {
        if (!policy.isActive) {
            continue;
        }
        if (!evaluatePolicy(policy, data)) {
            nonCompliantPolicies.push(policy.id);
        }
    }
    return nonCompliantPolicies;
}

// Example policies and data for testing
const policies: Policy[] = [
    {
        id: '1',
        name: 'Age Policy',
        isActive: true,
        conditions: [
            { field: 'age', operator: 'greaterThan', value: 18 }
        ]
    },
    {
        id: '2',
        name: 'Region Policy',
        isActive: true,
        conditions: [
            { field: 'region', operator: 'equals', value: 'US' }
        ]
    }
];

const data = { age: 20, region: 'US' };

const nonCompliant = validatePolicies(policies, data);

assert.deepStrictEqual(nonCompliant, []);

const invalidData = { age: 17, region: 'EU' };
const nonCompliantInvalid = validatePolicies(policies, invalidData);
assert.deepStrictEqual(nonCompliantInvalid, ['1', '2']);

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case provides a realistic scenario of validating business policies based on provided data. It demonstrates complex logic involving policy and condition evaluation, which requires clear documentation for understanding. The golden_completion focuses on generating comprehensive documentation for a function that validates policies, ensuring that the LLM can translate intricate TypeScript code into detailed natural language descriptions. Assertions verify the correctness of both compliant and non-compliant policy evaluations, making this a robust test case for bidirectional translation between code and natural language.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * The validatePolicies function iterates over a list of policies and evaluates each policy against provided data.
 * It returns a list of policy IDs that are not compliant.
 * 
 * @param policies - Array of Policy objects to validate.
 * @param data - The data to validate the policies against.
 * 
 * @returns An array of strings representing the IDs of non-compliant policies.
 * 
 * Example:
 * typescript
 * const policies: Policy[] = [
 *   { id: '1', name: 'Age Policy', isActive: true, conditions: [{ field: 'age', operator: 'greaterThan', value: 18 }] },
 *   { id: '2', name: 'Region Policy', isActive: true, conditions: [{ field: 'region', operator: 'equals', value: 'US' }] }
 * ];
 * const data = { age: 20, region: 'US' };
 * const nonCompliant = validatePolicies(policies, data);
 * console.log(nonCompliant); // []
 * 
 */`
assert(docString.includes('The validatePolicies function iterates over a list of policies and evaluates each policy against provided data.'));
assert(docString.includes('@param policies - Array of Policy objects to validate.'));
assert(docString.includes('@param data - The data to validate the policies against.'));
assert(docString.includes('@returns An array of strings representing the IDs of non-compliant policies.'));
assert(docString.includes('Example:'));
assert(docString.includes('const policies: Policy[] = ['));
================================================================================

================================================================================
Test Case #25
================================================================================

================================================================================
Test Case ID: 25
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a business entity for a Customer.
 */
interface Customer {
    id: string;
    name: string;
    email: string;
    isActive: boolean;
}

/**
 * Enum representing different compliance statuses.
 */
enum ComplianceStatus {
    Compliant = 'Compliant',
    NonCompliant = 'NonCompliant',
    Unknown = 'Unknown'
}

/**
 * Function to check customer compliance based on their email domain.
 * @param customer - The customer to check compliance for.
 * @returns {ComplianceStatus} - The compliance status of the customer.
 */
function checkCompliance(customer: Customer): ComplianceStatus {
    const allowedDomains = ['example.com', 'company.com'];
    const emailDomain = customer.email.split('@')[1];
    if (allowedDomains.includes(emailDomain)) {
        return ComplianceStatus.Compliant;
    } else {
        return ComplianceStatus.NonCompliant;
    }
}

/**
 * Class representing a service to manage customers.
 */
class CustomerService {
    private customers: Customer[] = [];

    /**
     * Add a new customer to the service.
     * @param customer - The customer to add.
     */
    addCustomer(customer: Customer): void {
        this.customers.push(customer);
    }

    /**
     * Retrieve all active customers.
     * @returns {Customer[]} - List of active customers.
     */
    getActiveCustomers(): Customer[] {
        return this.customers.filter(customer => customer.isActive);
    }

    /**
     * Check compliance for all active customers.
     * @returns {Record<string, ComplianceStatus>} - Compliance status for each active customer.
     */
    checkComplianceForActiveCustomers(): Record<string, ComplianceStatus> {
        const complianceStatus: Record<string, ComplianceStatus> = {};
        const activeCustomers = this.getActiveCustomers();
        activeCustomers.forEach(customer => {
            complianceStatus[customer.id] = checkCompliance(customer);
        });
        return complianceStatus;
    }
}

// Example usage
const customerService = new CustomerService();
const customer1: Customer = { id: '1', name: 'John Doe', email: 'john.doe@example.com', isActive: true };
const customer2: Customer = { id: '2', name: 'Jane Smith', email: 'jane.smith@unknown.com', isActive: true };
customerService.addCustomer(customer1);
customerService.addCustomer(customer2);


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
const complianceResults = customerService.checkComplianceForActiveCustomers();

SUFFIX CODE:
----------------------------------------
const complianceResults = customerService.checkComplianceForActiveCustomers();
assert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);
assert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);

// Clean up resources (none required in this example)


JUSTIFICATION:
----------------------------------------
This test case covers both code-to-comment and comment-to-code translation. The prefix establishes a detailed context with TypeScript interfaces, enums, functions, and a class, including various methods and their implementations. The golden_completion involves generating comprehensive documentation for a new method, ensuring that the LLM can accurately describe the method's functionality, parameters, and return values. The suffix contains assertions that verify the correctness of the implementation and documentation. This scenario demonstrates realistic business logic, compliance checking, and proper use of TypeScript's type system, making it a good test case for evaluating an LLM's translation capabilities.

ASSERTIONS:
----------------------------------------
const docString = getComplianceStatusForActiveCustomers.toString();
assert(docString.includes('Retrieves compliance status for all active customers'));
assert(docString.includes('Uses the checkCompliance function'));
assert(docString.includes('Parameters:'));
assert(docString.includes('Returns:'));
assert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);
assert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);

================================================================================

================================================================================
Test Case #26
================================================================================

================================================================================
Test Case ID: 26
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'node:assert';

/**
 * Interface representing a user in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    role: 'admin' | 'user';
}

/**
 * Function to validate if a given user has admin privileges.
 * @param user - The user object to check.
 * @returns True if the user is an admin, false otherwise.
 */
function isAdmin(user: User): boolean {
    return user.role === 'admin';
}

/**
 * Class representing a simple in-memory user store.
 */
class UserStore {
    private users: User[] = [];

    /**
     * Adds a new user to the store.
     * @param user - The user object to add.
     */
    addUser(user: User): void {
        this.users.push(user);
    }

    /**
     * Retrieves a user by their ID.
     * @param id - The ID of the user to retrieve.
     * @returns The user object if found, undefined otherwise.
     */
    getUserById(id: number): User | undefined {
        return this.users.find(user => user.id === id);
    }

    /**
     * Validates if the user with the given ID has admin privileges.
     * @param id - The ID of the user to check.
     * @returns True if the user is an admin, false otherwise.
     */
    isUserAdmin(id: number): boolean {
        const user = this.getUserById(id);
        return user ? isAdmin(user) : false;
    }
}

// Example usage
const userStore = new UserStore();
userStore.addUser({ id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' });
userStore.addUser({ id: 2, name: 'Bob', email: 'bob@example.com', role: 'user' });



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
// Test the UserStore functionality
assert.strictEqual(userStore.getUserById(1)?.name, 'Alice');
assert.strictEqual(userStore.getUserById(2)?.name, 'Bob');
assert.strictEqual(userStore.getUserById(3), undefined);

assert.strictEqual(userStore.isUserAdmin(1), true);
assert.strictEqual(userStore.isUserAdmin(2), false);
assert.strictEqual(userStore.isUserAdmin(3), false);

SUFFIX CODE:
----------------------------------------

// Clean up resources
// No resources to clean up in this example


JUSTIFICATION:
----------------------------------------
This test case effectively evaluates the LLM's ability to translate between code and natural language by providing a realistic business scenario. The example involves user role validation and demonstrates a clear relationship between TypeScript code and documentation. The golden_completion includes detailed TSDoc comments for the 'isUserAdmin' method, while the prefix and suffix provide extensive context and assertions to verify the correctness of the implementation.

ASSERTIONS:
----------------------------------------
const userStore = new UserStore();
userStore.addUser({ id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' });
userStore.addUser({ id: 2, name: 'Bob', email: 'bob@example.com', role: 'user' });
assert.strictEqual(userStore.isUserAdmin(1), true, 'User with ID 1 should be an admin');
assert.strictEqual(userStore.isUserAdmin(2), false, 'User with ID 2 should not be an admin');
assert.strictEqual(userStore.isUserAdmin(3), false, 'User with ID 3 should not exist and return false');
================================================================================

================================================================================
Test Case #27
================================================================================

================================================================================
Test Case ID: 27
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Represents a user in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
function validateUserCompliance(user: User): boolean {
    // User must have a valid email
    const emailRegex = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
    if (!emailRegex.test(user.email)) {
        return false;
    }

    // User must be active
    if (!user.isActive) {
        return false;
    }

    return true;
}

/**
 * Example usage of validateUserCompliance function.
 */
function exampleUsage() {
    const user: User = {
        id: 1,
        name: 'John Doe',
        email: 'john.doe@example.com',
        isActive: true
    };

    const isCompliant = validateUserCompliance(user);
    console.log(`Is user compliant? ${isCompliant}`);
}

exampleUsage();

/**
 * Asserts that the validateUserCompliance function works correctly.
 */
function testValidateUserCompliance() {
    const compliantUser: User = {
        id: 2,
        name: 'Jane Smith',
        email: 'jane.smith@example.com',
        isActive: true
    };
    const nonCompliantUser: User = {
        id: 3,
        name: 'Bob Brown',
        email: 'bob.brown@example',
        isActive: false
    };

    assert.strictEqual(validateUserCompliance(compliantUser), true, 'Compliant user should be valid');
    assert.strictEqual(validateUserCompliance(nonCompliantUser), false, 'Non-compliant user should be invalid');
}

testValidateUserCompliance();
function cleanupResources() {
    console.log('Cleanup resources if any');
}

cleanupResources();

JUSTIFICATION:
----------------------------------------
This test case is a good example for bidirectional translation between code and natural language because it includes detailed TypeScript code for validating business rules on user objects, and requires comprehensive documentation of the function. The prefix establishes the context and the function implementation, while the golden_completion requires generating detailed documentation that explains the function, its parameters, return values, and error handling. The suffix provides additional code that does not repeat the golden_completion, maintaining a clear distinction. The assertions test the functional requirements and the completeness of the documentation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Validates if the given user meets the compliance requirements.
 *
 * This function performs several checks to ensure that the user is compliant with the business rules:
 * 1. The user must have a valid email address.
 * 2. The user must be marked as active.
 *
 * @param user - The user object to validate. The user object must contain the following properties:
 * - id: A unique identifier for the user (number).
 * - name: The name of the user (string).
 * - email: The email address of the user (string).
 * - isActive: Indicates whether the user is active (boolean).
 * @returns True if the user is compliant, otherwise false.
 *
 * @throws Will throw an error if the user object does not have the required properties.
 */`;
assert(docString.toLowerCase().includes('validates if the given user meets the compliance requirements'));
assert(docString.includes('@param user - The user object to validate'));
assert(docString.includes('@returns True if the user is compliant, otherwise false'));
assert(docString.includes('@throws Will throw an error if the user object does not have the required properties'));

================================================================================

================================================================================
Test Case #28
================================================================================

================================================================================
Test Case ID: 28
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Configuration interface for the workflow orchestrator.
 */
interface WorkflowConfig {
  maxConcurrentTasks: number;
  retryLimit: number;
}

/**
 * Task interface representing a unit of work in the workflow.
 */
interface Task {
  id: string;
  execute: () => Promise<void>;
  retries: number;
}

/**
 * A simple in-memory task queue with basic operations.
 */
class TaskQueue {
  private tasks: Task[] = [];

  /**
   * Adds a task to the queue.
   * @param task - The task to add.
   */
  addTask(task: Task): void {
    this.tasks.push(task);
  }

  /**
   * Removes and returns the next task from the queue.
   * @returns The next task.
   */
  getNextTask(): Task | undefined {
    return this.tasks.shift();
  }

  /**
   * Checks if the queue is empty.
   * @returns True if the queue is empty, false otherwise.
   */
  isEmpty(): boolean {
    return this.tasks.length === 0;
  }
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
/**
 * Orchestrates the execution of workflow tasks with concurrency control and retry logic.
 */

SUFFIX CODE:
----------------------------------------
class WorkflowOrchestrator {
  private config: WorkflowConfig;
  private taskQueue: TaskQueue;
  private activeTasks: number = 0;

  constructor(config: WorkflowConfig) {
    this.config = config;
    this.taskQueue = new TaskQueue();
  }

  /**
   * Schedules a new task for execution.
   * @param task - The task to be scheduled.
   */
  scheduleTask(task: Task): void {
    this.taskQueue.addTask(task);
    this.runNextTask();
  }

  /**
   * Runs the next task in the queue if conditions allow.
   */
  private async runNextTask(): Promise<void> {
    if (this.activeTasks >= this.config.maxConcurrentTasks || this.taskQueue.isEmpty()) {
      return;
    }
    const task = this.taskQueue.getNextTask();
    if (task) {
      this.activeTasks++;
      try {
        await task.execute();
      } catch (error) {
        if (task.retries < this.config.retryLimit) {
          task.retries++;
          this.taskQueue.addTask(task);
        }
      } finally {
        this.activeTasks--;
        this.runNextTask();
      }
    }
  }
}

const config: WorkflowConfig = { maxConcurrentTasks: 3, retryLimit: 2 };
const orchestrator = new WorkflowOrchestrator(config);
const task: Task = { id: 'task1', execute: async () => { console.log('Task executed'); }, retries: 0 };
orchestrator.scheduleTask(task);

const task2: Task = { id: 'task2', execute: async () => { throw new Error('Task failed'); }, retries: 0 };
orchestrator.scheduleTask(task2);

setTimeout(() => {
  assert.strictEqual(orchestrator['activeTasks'], 0, 'All tasks should be completed or retried');
}, 1000);


JUSTIFICATION:
----------------------------------------
This test case provides a comprehensive example of a workflow orchestrator managing task execution, including scheduling and retry logic. The golden_completion focuses on generating detailed documentation for the WorkflowOrchestrator class, which is essential for understanding its purpose, configuration, methods, and error handling logic. The assertions validate that the orchestrator correctly handles task execution and retries, making this a robust scenario for testing both code-to-comment and comment-to-code translation capabilities.

ASSERTIONS:
----------------------------------------
const docString = WorkflowOrchestrator.toString();
assert(docString.toLowerCase().includes('workflow orchestrator'));
assert(docString.includes('Parameters:'));
assert(docString.includes('method scheduleTask'));
assert(docString.includes('method runNextTask'));
assert(docString.includes('Will log and retry tasks that fail execution up to the retry limit.'));

================================================================================

================================================================================
Test Case #29
================================================================================

================================================================================
Test Case ID: 29
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Interface representing a business rule for validating user age.
 */
interface AgeValidationRule {
    /**
     * Validates if the given age complies with the business rule.
     * @param age - The age of the user
     * @returns True if the age is valid, otherwise false
     */
    validate(age: number): boolean;
}

/**
 * Class representing a minimum age validation rule.
 */
class MinimumAgeRule implements AgeValidationRule {
    private minAge: number;

    /**
     * Constructs a MinimumAgeRule with the specified minimum age.
     * @param minAge - The minimum age to validate against
     */
    constructor(minAge: number) {
        this.minAge = minAge;
    }

    /**
     * Validates if the given age is greater than or equal to the minimum age.
     * @param age - The age of the user
     * @returns True if the age is valid, otherwise false
     */
    validate(age: number): boolean {
        return age >= this.minAge;
    }
}

/**
 * Class representing a maximum age validation rule.
 */
class MaximumAgeRule implements AgeValidationRule {
    private maxAge: number;

    /**
     * Constructs a MaximumAgeRule with the specified maximum age.
     * @param maxAge - The maximum age to validate against
     */
    constructor(maxAge: number) {
        this.maxAge = maxAge;
    }

    /**
     * Validates if the given age is less than or equal to the maximum age.
     * @param age - The age of the user
     * @returns True if the age is valid, otherwise false
     */
    validate(age: number): boolean {
        return age <= this.maxAge;
    }
}

// Example usage:
const minAgeRule = new MinimumAgeRule(18);
const maxAgeRule = new MaximumAgeRule(65);
assert(minAgeRule.validate(20) === true);
assert(minAgeRule.validate(17) === false);
assert(maxAgeRule.validate(60) === true);
assert(maxAgeRule.validate(70) === false);


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
// Create a composite rule that combines multiple age validation rules
class CompositeAgeRule implements AgeValidationRule {
    private rules: AgeValidationRule[];

    /**
     * Constructs a CompositeAgeRule with the specified validation rules.
     * @param rules - An array of age validation rules
     */
    constructor(rules: AgeValidationRule[]) {
        this.rules = rules;
    }

    /**
     * Validates if the given age complies with all the combined rules.
     * @param age - The age of the user
     * @returns True if the age is valid according to all rules, otherwise false
     */
    validate(age: number): boolean {
        return this.rules.every(rule => rule.validate(age));
    }
}

// Example usage:
const compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);
assert(compositeRule.validate(30) === true);
assert(compositeRule.validate(70) === false);
assert(compositeRule.validate(17) === false);

SUFFIX CODE:
----------------------------------------

class CompositeAgeRule implements AgeValidationRule {
    private rules: AgeValidationRule[];

    /**
     * Constructs a CompositeAgeRule with the specified validation rules.
     * @param rules - An array of age validation rules
     */
    constructor(rules: AgeValidationRule[]) {
        this.rules = rules;
    }

    /**
     * Validates if the given age complies with all the combined rules.
     * @param age - The age of the user
     * @returns True if the age is valid, otherwise false
     */
    validate(age: number): boolean {
        return this.rules.every(rule => rule.validate(age));
    }
}

// Example usage:
const compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);
assert(compositeRule.validate(30) === true);
assert(compositeRule.validate(70) === false);
assert(compositeRule.validate(17) === false);


JUSTIFICATION:
----------------------------------------
This test case is a good example because it involves a realistic business scenario of age validation rules, which are common in applications with age-restricted content or services. The scenario requires understanding of both class inheritance and interface implementation in TypeScript. The translation task is bidirectional, involving both code-to-comment and comment-to-code. The provided assertions ensure the correctness of the implementation and the comprehensiveness of the documentation.

ASSERTIONS:
----------------------------------------
const compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);
assert(compositeRule.validate(30) === true);
assert(compositeRule.validate(70) === false);
assert(compositeRule.validate(17) === false);

const docString = `/**
 * Class representing a composite age validation rule that combines multiple rules.
 */
class CompositeAgeRule implements AgeValidationRule {
    private rules: AgeValidationRule[];

    /**
     * Constructs a CompositeAgeRule with the specified validation rules.
     * @param rules - An array of age validation rules
     */
    constructor(rules: AgeValidationRule[]) {
        this.rules = rules;
    }

    /**
     * Validates if the given age complies with all the combined rules.
     * @param age - The age of the user
     * @returns True if the age is valid, otherwise false
     */
    validate(age: number): boolean {
        return this.rules.every(rule => rule.validate(age));
    }
}`;

assert(docString.toLowerCase().includes("composite age validation rule"));
assert(docString.includes("@param rules - An array of age validation rules"));
assert(docString.includes("@returns True if the age is valid, otherwise false"));
assert(docString.includes("Validates if the given age complies with all the combined rules."));
================================================================================

================================================================================
Test Case #30
================================================================================

================================================================================
Test Case ID: 30
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface Policy {
	ruleName: string;
	description: string;
	validate: (data: any) => boolean;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
import { strict as assert } from 'assert';

interface Policy {
	ruleName: string;
	description: string;
	validate: (data: any) => boolean;
}


SUFFIX CODE:
----------------------------------------
class PolicyEnforcer {
	private policies: Policy[] = [];

	/**
	 * Adds a new policy to the enforcer.
	 * @param policy - The policy to add.
	 */
	addPolicy(policy: Policy): void {
		this.policies.push(policy);
	}

	/**
	 * Validates data against all policies.
	 * @param data - The data to validate.
	 * @returns An array of policy names that failed.
	 */
	validate(data: any): string[] {
		const failedPolicies: string[] = [];
		for (const policy of this.policies) {
			if (!policy.validate(data)) {
				failedPolicies.push(policy.ruleName);
			}
		}
		return failedPolicies;
	}
}

// Example usage
const policyEnforcer = new PolicyEnforcer();

policyEnforcer.addPolicy({
	ruleName: 'Must be over 18',
	description: 'The user must be over 18 years old.',
	validate: (data) => data.age > 18
});

policyEnforcer.addPolicy({
	ruleName: 'Must have valid email',
	description: 'The user must provide a valid email address.',
	validate: (data) => /\S+@\S+\.\S+/.test(data.email)
});

const testData = { age: 17, email: 'invalid-email' };
const failedPolicies = policyEnforcer.validate(testData);

assert(failedPolicies.includes('Must be over 18'));
assert(failedPolicies.includes('Must have valid email'));
assert(failedPolicies.length === 2);
const testData2 = { age: 25, email: 'test@example.com' };
const failedPolicies2 = policyEnforcer.validate(testData2);

assert(failedPolicies2.length === 0);

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case effectively demonstrates bidirectional translation between code and natural language. The provided TypeScript code is a realistic implementation of a policy enforcement system, which involves adding policies and validating data against these policies. The golden completion provides comprehensive documentation for the class, including a usage example, which tests the LLM's ability to generate accurate and detailed comments for existing code. The assertions ensure that the documentation accurately reflects the code's functionality and covers key concepts such as class usage, parameter descriptions, and return values.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * PolicyEnforcer is a class that manages policy validation. It allows adding policies and validating data against these policies.
 * 
 * @example
 * typescript
 * const policyEnforcer = new PolicyEnforcer();
 * policyEnforcer.addPolicy({
 * 	ruleName: 'Must be over 18',
 * 	description: 'The user must be over 18 years old.',
 * 	validate: (data) => data.age > 18
 * });
 * const testData = { age: 17 };
 * const failedPolicies = policyEnforcer.validate(testData);
 * assert(failedPolicies.includes('Must be over 18'));
 * 
 * 
 * @class PolicyEnforcer
 */`;
assert(docString.includes('PolicyEnforcer is a class that manages policy validation'));
assert(docString.includes('@example'));
assert(docString.includes('typescript'));
assert(docString.includes('@class PolicyEnforcer'));
assert(docString.includes('ruleName'));
assert(docString.includes('description'));
assert(docString.includes('validate'));
================================================================================

================================================================================
Test Case #31
================================================================================

================================================================================
Test Case ID: 31
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a user in the system.
 */
interface User {
    id: string;
    name: string;
    email: string;
    isActive: boolean;
}

/**
 * Type representing a collection of users.
 */
type UserCollection = User[];

/**
 * Function to validate user email.
 * @param email - The email address to validate.
 * @returns True if the email is valid, false otherwise.
 */
function validateEmail(email: string): boolean {
    const emailRegex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
    return emailRegex.test(email);
}

/**
 * Function to activate a user.
 * @param user - The user to activate.
 * @returns The activated user.
 */
function activateUser(user: User): User {
    if (!validateEmail(user.email)) {
        throw new Error('Invalid email address');
    }
    user.isActive = true;
    return user;
}

/**
 * Function to deactivate a user.
 * @param user - The user to deactivate.
 * @returns The deactivated user.
 */
function deactivateUser(user: User): User {
    user.isActive = false;
    return user;
}

/**
 * Function to find a user by email in a collection.
 * @param users - The collection of users.
 * @param email - The email of the user to find.
 * @returns The user if found, undefined otherwise.
 */
function findUserByEmail(users: UserCollection, email: string): User | undefined {
    return users.find(user => user.email === email);
}

/**
 * Function to deactivate all inactive users in a collection.
 * @param users - The collection of users.
 * @returns The collection with all inactive users deactivated.
 */
function deactivateInactiveUsers(users: UserCollection): UserCollection {
    return users.map(user => {
        if (!user.isActive) {
            return deactivateUser(user);
        }
        return user;
    });
}

/**
 * Function to get all active users in a collection.
 * @param users - The collection of users.
 * @returns A collection of active users.
 */
function getActiveUsers(users: UserCollection): UserCollection {
    return users.filter(user => user.isActive);
}

// The following function needs implementation
/**
 * Function to count the number of active users in a collection.
 * @param users - The collection of users.
 * @returns The number of active users.
 */
function countActiveUsers(users: UserCollection): number {


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
    return users.filter(user => user.isActive).length;

SUFFIX CODE:
----------------------------------------
}

const users: UserCollection = [
    { id: '1', name: 'Alice', email: 'alice@example.com', isActive: true },
    { id: '2', name: 'Bob', email: 'bob@example.com', isActive: false },
    { id: '3', name: 'Charlie', email: 'charlie@example.com', isActive: true }
];

assert.strictEqual(countActiveUsers(users), 2);

// Clean up resources if any
// No resources to clean up in this example

JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic scenario involving user management functionality. It covers a variety of operations such as validating emails, activating/deactivating users, and filtering collections. The prefix provides extensive context with multiple helper functions and type definitions. The golden_completion requires implementing a function based on a provided comment, testing the LLM's ability to accurately translate documentation into functioning code. The suffix contains assertions to verify the implementation and ensure correctness.

ASSERTIONS:
----------------------------------------
assert.strictEqual(countActiveUsers(users), 2);
================================================================================

================================================================================
Test Case #32
================================================================================

================================================================================
Test Case ID: 32
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface User {
	id: number;
	name: string;
	email: string;
	isActive: boolean;
}

interface UserService {
	createUser(user: User): Promise<User>;
	getUser(id: number): Promise<User | null>;
	updateUser(user: User): Promise<User>;
	deleteUser(id: number): Promise<boolean>;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
class UserServiceImpl implements UserService {

SUFFIX CODE:
----------------------------------------
class UserServiceImpl implements UserService {
	private users: Map<number, User> = new Map();

	/**
	 * Creates a new user and adds to the user list.
	 * @param user - The user object to be created.
	 * @returns The created user object.
	 */
	async createUser(user: User): Promise<User> {
		if (this.users.has(user.id)) {
			throw new Error('User already exists');
		}
		this.users.set(user.id, user);
		return user;
	}

	async getUser(id: number): Promise<User | null> {
		return this.users.get(id) || null;
	}

	async updateUser(user: User): Promise<User> {
		if (!this.users.has(user.id)) {
			throw new Error('User does not exist');
		}
		this.users.set(user.id, user);
		return user;
	}

	/**
	 * Deletes a user from the user list.
	 * @param id - The ID of the user to be deleted.
	 * @returns A boolean indicating whether the deletion was successful.
	 */
	async deleteUser(id: number): Promise<boolean> {
		if (!this.users.has(id)) {
			return false;
		}
		this.users.delete(id);
		return true;
	}
}

const userService: UserService = new UserServiceImpl();

// Test createUser method
(async () => {
	const newUser: User = { id: 1, name: 'John Doe', email: 'john@example.com', isActive: true };
	await userService.createUser(newUser);
	const fetchedUser = await userService.getUser(1);
	assert(fetchedUser !== null);
	assert(fetchedUser.name === 'John Doe');

	// Test updateUser method
	newUser.name = 'John Smith';
	await userService.updateUser(newUser);
	const updatedUser = await userService.getUser(1);
	assert(updatedUser !== null);
	assert(updatedUser.name === 'John Smith');

	// Test deleteUser method
	const deleteResult = await userService.deleteUser(1);
	assert(deleteResult === true);
	const deletedUser = await userService.getUser(1);
	assert(deletedUser === null);
})();

// Test getUser method with non-existing user
(async () => {
	const nonExistingUser = await userService.getUser(999);
	assert(nonExistingUser === null);
})();

// Cleanup: nothing to clean up in this example


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to translate between TypeScript code and comprehensive documentation. It includes a realistic business scenario with user management, detailed method implementations, and thorough documentation requirements. The assertions verify functional correctness and documentation accuracy, ensuring that the LLM can handle both code-to-comment and comment-to-code translations effectively.

ASSERTIONS:
----------------------------------------
import assert from 'assert';
const docString = `/*
 * UserServiceImpl is an implementation of the UserService interface.
 * It manages a list of users and provides methods to create, retrieve, update, and delete users.
 *
 * Methods:
 * - createUser: Adds a new user to the list if the user does not already exist.
 * - getUser: Retrieves a user by their ID.
 * - updateUser: Updates an existing user's details.
 * - deleteUser: Removes a user from the list by their ID.
 *
 * Error Handling:
 * - createUser: Throws an error if a user with the same ID already exists.
 * - updateUser: Throws an error if the user does not exist.
 * - deleteUser: Returns false if the user does not exist.
 *
 * Usage Examples:
 * const newUser: User = { id: 1, name: 'John Doe', email: 'john@example.com', isActive: true };
 * await userService.createUser(newUser);
 * const fetchedUser = await userService.getUser(1);
 * assert(fetchedUser !== null);
 * assert(fetchedUser.name === 'John Doe');
 *
 * newUser.name = 'John Smith';
 * await userService.updateUser(newUser);
 * const updatedUser = await userService.getUser(1);
 * assert(updatedUser !== null);
 * assert(updatedUser.name === 'John Smith');
 *
 * const deleteResult = await userService.deleteUser(1);
 * assert(deleteResult === true);
 * const deletedUser = await userService.getUser(1);
 * assert(deletedUser === null);
 */`;
assert(docString.toLowerCase().includes('userserviceimpl'));
assert(docString.includes('Methods:'));
assert(docString.includes('Error Handling:'));
assert(docString.includes('Usage Examples:'));

================================================================================

================================================================================
Test Case #33
================================================================================

================================================================================
Test Case ID: 33
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a User entity.
 */
interface User {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
}

/**
 * Function to validate a user's email address based on a set of business rules.
 *
 * @param email - The email address to validate.
 * @returns True if the email address is valid, otherwise false.
 */
function validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

/**
 * Function to deactivate a user if they are inactive for more than 30 days.
 *
 * @param user - The user to deactivate.
 * @returns The updated user with isActive set to false if they were inactive.
 */
function deactivateUser(user: User): User {
    // Complex business logic to determine if the user should be deactivated.
    // For example, check the last login date (not implemented here).
    user.isActive = false;
    return user;
}

/**
 * Function to send an email notification to a user.
 *
 * @param user - The user to notify.
 * @param message - The message to send.
 */
function sendEmailNotification(user: User, message: string): void {
    console.log(`Sending email to ${user.email}: ${message}`);
}

/**
 * Class to manage a collection of users.
 */
class UserManager {
    private users: User[] = [];

    /**
     * Add a new user to the collection.
     *
     * @param user - The user to add.
     */
    addUser(user: User): void {
        this.users.push(user);
    }

    /**
     * Get a user by their ID.
     *
     * @param id - The ID of the user to retrieve.
     * @returns The user with the specified ID, or undefined if not found.
     */
    getUserById(id: number): User | undefined {
        return this.users.find(user => user.id === id);
    }
}

/**
 * Function to handle user login.
 *
 * @param userManager - The UserManager instance managing the users.
 * @param email - The email address of the user trying to log in.
 * @returns The user if login is successful, otherwise an error message.
 */
function handleUserLogin(userManager: UserManager, email: string): User | string {
    const user = userManager.getUserById(1); // Simulating user retrieval
    if (!user || !validateEmail(email)) {
        return 'Invalid email or user not found';
    }
    if (!user.isActive) {
        return 'User is inactive';
    }
    return user;
}

/**
 * Function to verify user login credentials.
 *
 * @param email - The email address of the user trying to log in.
 * @param password - The password of the user trying to log in.
 * @returns True if credentials are valid, otherwise false.
 */
function verifyUserCredentials(email: string, password: string): boolean {
    // Placeholder for password verification logic.
    return email === 'test@example.com' && password === 'password123';
}

/**
 * Function to handle user registration.
 *
 * @param userManager - The UserManager instance managing the users.
 * @param newUser - The new user to register.
 * @returns The registered user.
 */
function handleUserRegistration(userManager: UserManager, newUser: User): User {
    userManager.addUser(newUser);
    return newUser;
}

LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
/**
 * Function to test the user management system.
 */
function testUserManagement(): void {
    const userManager = new UserManager();

    const testUser: User = {
        id: 1,
        name: 'John Doe',
        email: 'john.doe@example.com',
        isActive: true
    };

    userManager.addUser(testUser);
    const loginUser = handleUserLogin(userManager, 'john.doe@example.com');
    assert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);
    assert(verifyUserCredentials('test@example.com', 'password123'));
    const newUser: User = {
        id: 2,
        name: 'Jane Smith',
        email: 'jane.smith@example.com',
        isActive: true
    };
    const registeredUser = handleUserRegistration(userManager, newUser);
    assert(registeredUser.id === 2);
    assert(userManager.getUserById(2)?.name === 'Jane Smith');
}

testUserManagement();

SUFFIX CODE:
----------------------------------------
const userManager = new UserManager();

const testUser: User = {
    id: 1,
    name: 'John Doe',
    email: 'john.doe@example.com',
    isActive: true
};

userManager.addUser(testUser);
const loginUser = handleUserLogin(userManager, 'john.doe@example.com');
assert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);
assert(verifyUserCredentials('john.doe@example.com', 'password123'));
const newUser: User = {
    id: 2,
    name: 'Jane Smith',
    email: 'jane.smith@example.com',
    isActive: true
};
const registeredUser = handleUserRegistration(userManager, newUser);
assert(registeredUser.id === 2);
assert(userManager.getUserById(2)?.name === 'Jane Smith');

JUSTIFICATION:
----------------------------------------
This scenario is a good test case because it involves complex business logic related to user management, including validation, deactivation, and notification processes. The code-to-comment task requires generating comprehensive documentation for a function that updates a user's email address, ensuring clarity and coverage of all important aspects. The comment-to-code task involves implementing the function based on the provided documentation. The assertions check the correctness of the function and the validity of documentation, ensuring the LLM can handle both code generation and documentation accurately.

ASSERTIONS:
----------------------------------------
const updatedUser = updateUserEmail(userManager, 1, 'john.new@example.com');
assert(typeof updatedUser === 'object' && (updatedUser as User).email === 'john.new@example.com');
const invalidUpdate = updateUserEmail(userManager, 1, 'invalid-email');
assert(typeof invalidUpdate === 'string' && invalidUpdate === 'Invalid email address');
const nonExistentUserUpdate = updateUserEmail(userManager, 99, 'john.new@example.com');
assert(typeof nonExistentUserUpdate === 'string' && nonExistentUserUpdate === 'User not found');
================================================================================

================================================================================
Test Case #34
================================================================================

================================================================================
Test Case ID: 34
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Interface representing a user in the system.
 */
interface User {
    id: string;
    name: string;
    email: string;
    roles: string[];
}

/**
 * Interface for a policy enforcement service.
 */
interface PolicyService {
    checkCompliance(user: User): boolean;
}

/**
 * Implementation of the PolicyService.
 */
class DefaultPolicyService implements PolicyService {
    private allowedDomains: string[];

    constructor(allowedDomains: string[]) {
        this.allowedDomains = allowedDomains;
    }

    /**
     * Check if the user complies with the allowed domain policy.
     * @param user - The user to check.
     * @returns True if the user complies, false otherwise.
     */
    checkCompliance(user: User): boolean {
        return this.allowedDomains.some(domain => user.email.endsWith(`@${domain}`));
    }
}

// Setting up a list of allowed domains for testing purposes
const allowedDomains = ['example.com', 'test.com'];
const policyService = new DefaultPolicyService(allowedDomains);

// Test users
const compliantUser: User = { id: '1', name: 'John Doe', email: 'john.doe@example.com', roles: ['user'] };
const nonCompliantUser: User = { id: '2', name: 'Jane Smith', email: 'jane.smith@invalid.com', roles: ['admin'] };

// Check compliance for both users
assert(policyService.checkCompliance(compliantUser) === true);
assert(policyService.checkCompliance(nonCompliantUser) === false);

/**
 * Function to log the compliance status of a user.
 * @param user - The user to log.
 * @param policyService - The policy service to use for checking compliance.
 */
function logComplianceStatus(user: User, policyService: PolicyService): void {
    const isCompliant = policyService.checkCompliance(user);
    console.log(`User ${user.name} compliance status: ${isCompliant ? 'Compliant' : 'Non-compliant'}`);
}

// Logging compliance status for both users
logComplianceStatus(compliantUser, policyService);
logComplianceStatus(nonCompliantUser, policyService);

// The following function needs to be implemented based on the provided documentation
/**
 * Function to filter compliant users from a list.
 * @param users - The list of users to filter.
 * @param policyService - The policy service to use for checking compliance.
 * @returns A list of compliant users.
 */
function filterCompliantUsers(users: User[], policyService: PolicyService): User[] {

LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
    const compliantUsers: User[] = [];
    
    for (const user of users) {
        if (policyService.checkCompliance(user)) {
            compliantUsers.push(user);
        }
    }
    
    return compliantUsers;

SUFFIX CODE:
----------------------------------------
}

// Test the filterCompliantUsers function
const users: User[] = [compliantUser, nonCompliantUser];
const compliantUsers = filterCompliantUsers(users, policyService);
assert(compliantUsers.length === 1);
assert(compliantUsers[0].email === 'john.doe@example.com');

// Cleanup resources if any (none in this case)


JUSTIFICATION:
----------------------------------------
This test case provides a realistic business logic scenario involving user compliance checking, policy enforcement, and filtering. The prefix includes detailed TypeScript interfaces, a class implementation, and extensive setup code. The golden completion requires implementing a function based on provided documentation, testing the LLM's ability to translate comments to code. Assertions verify the correctness of the implementation, while the scenario covers complex business rules and technical requirements.

ASSERTIONS:
----------------------------------------
const users: User[] = [compliantUser, nonCompliantUser];
const compliantUsers = filterCompliantUsers(users, policyService);
assert(compliantUsers.length === 1);
assert(compliantUsers[0].email === 'john.doe@example.com');
================================================================================

================================================================================
Test Case #35
================================================================================

================================================================================
Test Case ID: 35
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface User {
  id: number;
  name: string;
  email: string;
}

interface Policy {
  id: number;
  name: string;
  description: string;
}

interface ComplianceCheck {
  user: User;
  policies: Policy[];
  timestamp: Date;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
class ComplianceManager {
  private users: User[] = [];
  private policies: Policy[] = [];

  /**
   * Adds a user to the compliance manager.
   * @param user - The user to add.
   */
  addUser(user: User): void {
    this.users.push(user);
  }

  /**
   * Adds a policy to the compliance manager.
   * @param policy - The policy to add.
   */
  addPolicy(policy: Policy): void {
    this.policies.push(policy);
  }

  /**
   * Checks if a user complies with all policies.
   * @param userId - The ID of the user to check.
   * @returns True if the user complies with all policies, false otherwise.
   */
  checkCompliance(userId: number): boolean {
    const user = this.users.find(u => u.id === userId);
    if (!user) {
      throw new Error(`User with ID ${userId} not found`);
    }
    return this.policies.every(policy => this.userCompliesWithPolicy(user, policy));
  }

  /**
   * Checks if a user complies with a specific policy.
   * @param user - The user to check.
   * @param policy - The policy to check against.
   * @returns True if the user complies with the policy, false otherwise.
   */
  private userCompliesWithPolicy(user: User, policy: Policy): boolean {
    // Placeholder for actual compliance check logic
    return true;
  }
}

const manager = new ComplianceManager();
manager.addUser({ id: 1, name: 'Alice', email: 'alice@example.com' });
manager.addPolicy({ id: 1, name: 'Policy1', description: 'First policy' });
assert(manager.checkCompliance(1) === true);

manager.addUser({ id: 2, name: 'Bob', email: 'bob@example.com' });
manager.addPolicy({ id: 2, name: 'Policy2', description: 'Second policy' });

assert(manager.checkCompliance(2) === true);

try {
  manager.checkCompliance(3);
} catch (error) {
  assert(error.message === 'User with ID 3 not found');
}


JUSTIFICATION:
----------------------------------------
This test case is a good example for evaluating an LLM's ability to translate between code and natural language because it involves a realistic scenario of business rule validation. The ComplianceManager class demonstrates the management of users and policies, and includes methods for adding users and policies and checking compliance. The golden completion requires generating comprehensive documentation for the ComplianceManager class, which includes describing its purpose and methods. The suffix section tests the functionality of the ComplianceManager class, ensuring that the assertions verify the accuracy of both the code and the generated documentation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * The ComplianceManager class is responsible for managing users and policies,
 * and checking if users comply with the defined policies.
 *
 * @class ComplianceManager
 */`;
assert(docString.includes('ComplianceManager'));
assert(docString.includes('managing users and policies'));
assert(docString.includes('checking if users comply'));

================================================================================

================================================================================
Test Case #36
================================================================================

================================================================================
Test Case ID: 36
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Interface representing a business entity.
 */
interface BusinessEntity {
    id: number;
    name: string;
    isActive: boolean;
}

/**
 * Function to validate if the business entity is compliant with certain rules.
 * @param entity - The business entity to validate.
 * @returns A boolean indicating if the entity is compliant.
 */
function validateEntityCompliance(entity: BusinessEntity): boolean {
    // Rule 1: Entity must have a valid ID (greater than 0).
    if (entity.id <= 0) {
        return false;
    }

    // Rule 2: Entity name must not be empty.
    if (entity.name.trim() === '') {
        return false;
    }

    // Rule 3: Entity must be active.
    if (!entity.isActive) {
        return false;
    }

    return true;
}

// Example usage:
const exampleEntity: BusinessEntity = {
    id: 1,
    name: 'Example Inc.',
    isActive: true
};

// Example entities array for testing:
const entities: BusinessEntity[] = [
    { id: 1, name: 'Valid Corp.', isActive: true },
    { id: 2, name: 'Inactive Corp.', isActive: false },
    { id: 3, name: '', isActive: true },
    { id: 4, name: 'Another Valid Corp.', isActive: true }
];


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {
    const compliantEntities: BusinessEntity[] = [];
    for (const entity of entities) {
        if (validateEntityCompliance(entity)) {
            compliantEntities.push(entity);
        }
    }
    return compliantEntities;
}

SUFFIX CODE:
----------------------------------------
function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {
    const compliantEntities: BusinessEntity[] = [];
    for (const entity of entities) {
        if (validateEntityCompliance(entity)) {
            compliantEntities.push(entity);
        }
    }
    return compliantEntities;
}
// Test orchestration function:
const compliantEntities = orchestrateWorkflow(entities);
assert(compliantEntities.length === 2);
assert(compliantEntities[0].name === 'Valid Corp.');
assert(compliantEntities[1].name === 'Another Valid Corp.');

console.log('All tests passed!');


JUSTIFICATION:
----------------------------------------
This test case effectively demonstrates both code-to-comment and comment-to-code translation capabilities. The scenario involves validating business entities for compliance and orchestrating a workflow based on that validation. The golden_completion requires generating comprehensive documentation for a function based on its implementation, testing the LLM's ability to understand and explain code behavior accurately. The prefix provides a detailed setup, including interfaces, utility functions, and example data, ensuring that the context is well-defined. The suffix includes tests to verify the correctness of the function, ensuring that the implementation meets the documented requirements. The assertions check the accuracy of the documentation and the functionality of the code, making this a robust test case for evaluating an LLM's translation capabilities.

ASSERTIONS:
----------------------------------------
const docString = `/**\n * Orchestrates a business workflow by filtering out non-compliant entities.\n * \n * The function iterates through each entity and uses the validateEntityCompliance\n * function to check if the entity meets all compliance rules. Compliant entities\n * are collected into an array and returned.\n * \n * @param entities - An array of business entities to process.\n * @returns An array of compliant entities.\n */`;
assert(docString.toLowerCase().includes('workflow'));
assert(docString.includes('parameters:'));
assert(docString.includes('returns:'));
assert(docString.includes('validateEntityCompliance'));

================================================================================

================================================================================
Test Case #37
================================================================================

================================================================================
Test Case ID: 37
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Represents a business entity with validation rules.
 */
interface BusinessEntity {
    id: string;
    name: string;
    email: string;
    isActive: boolean;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
function validateBusinessEntity(entity: BusinessEntity): string[] {
    const errors: string[] = [];

    // Check if the ID is a valid UUID
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(entity.id)) {
        errors.push('Invalid ID format.');
    }

    // Check if the name is not empty and at least 3 characters long
    if (entity.name.trim().length < 3) {
        errors.push('Name must be at least 3 characters long.');
    }

    // Check if the email is a valid email address
    if (!/^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$/.test(entity.email)) {
        errors.push('Invalid email format.');
    }

    return errors;
}

// Example business entity
const exampleEntity: BusinessEntity = {
    id: '12345678-1234-1234-1234-1234567890ab',
    name: 'John Doe',
    email: 'john.doe@example.com',
    isActive: true
};

// Validate the example entity
const validationErrors = validateBusinessEntity(exampleEntity);
// Check if there are no validation errors
assert.strictEqual(validationErrors.length, 0, `Expected no validation errors, but got: ${validationErrors.join(', ')}`);

// Cleanup (if any) should go here
// No resources to clean up in this example


JUSTIFICATION:
----------------------------------------
This example tests the LLM's ability to generate comprehensive documentation for a function that validates a business entity against specific business rules. The documentation must include a detailed description, parameters, return value, and the business rules enforced. The prefix provides a complete implementation of the validation logic, and the suffix includes an assertion to ensure the function works as expected. This scenario is realistic and covers complex business logic, making it a good test case for code-to-comment translation.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * This function validates a business entity to ensure it meets all business rules.
 * 
 * @param entity - The business entity to validate. Must include an id, name, email, and isActive status.
 * @returns A string array of validation error messages. The array will be empty if no errors are found.
 * 
 * Business rules enforced:
 * 1. The ID must be a valid UUID.
 * 2. The name must not be empty and should be at least 3 characters long.
 * 3. The email must be a valid email address.
 */`;
assert(docString.toLowerCase().includes('validates a business entity'));
assert(docString.includes('@param entity'));
assert(docString.includes('@returns A string array of validation error messages'));
assert(docString.includes('Business rules enforced'));
assert(docString.includes('1. The ID must be a valid UUID.'));
assert(docString.includes('2. The name must not be empty and should be at least 3 characters long.'));
assert(docString.includes('3. The email must be a valid email address.'));
================================================================================

================================================================================
Test Case #38
================================================================================

================================================================================
Test Case ID: 38
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface User {
	id: string;
	name: string;
	age: number;
	email: string;
	role: 'admin' | 'user';
}

const users: User[] = [
	{ id: '1', name: 'Alice', age: 30, email: 'alice@example.com', role: 'admin' },
	{ id: '2', name: 'Bob', age: 25, email: 'bob@example.com', role: 'user' },
	{ id: '3', name: 'Charlie', age: 35, email: 'charlie@example.com', role: 'user' }
];

/**
 * Filters users by their role.
 * @param users - The array of users to filter.
 * @param role - The role to filter by ('admin' or 'user').
 * @returns An array of users with the specified role.
 */
function filterUsersByRole(users: User[], role: 'admin' | 'user'): User[] {
	return users.filter(user => user.role === role);
}

/**
 * Validates if the user is allowed to perform an action based on their role.
 * @param user - The user to validate.
 * @param action - The action to validate.
 * @returns True if the user can perform the action, otherwise false.
 */
function canUserPerformAction(user: User, action: string): boolean {
	const adminActions = ['delete_user', 'add_user', 'update_user'];
	const userActions = ['view_user'];
	if (user.role === 'admin') {
		return adminActions.includes(action);
	} else if (user.role === 'user') {
		return userActions.includes(action);
	}
	return false;
}

/**
 * Generates a summary of user statistics.
 * @param users - The array of users.
 * @returns An object containing the count of admins and users.
 */
function generateUserStatistics(users: User[]): { adminCount: number; userCount: number } {
	const adminCount = users.filter(user => user.role === 'admin').length;
	const userCount = users.filter(user => user.role === 'user').length;
	return { adminCount, userCount };
}

// Example usage of the functions
const admins = filterUsersByRole(users, 'admin');
const canAliceDeleteUser = canUserPerformAction(users[0], 'delete_user');
const userStats = generateUserStatistics(users);


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
// Get regular users
const regularUsers = filterUsersByRole(users, 'user');
// Check if Bob can view user information
const canBobViewUser = canUserPerformAction(users[1], 'view_user');
// Check if Charlie can delete a user (should be false)
const canCharlieDeleteUser = canUserPerformAction(users[2], 'delete_user');

SUFFIX CODE:
----------------------------------------

// Assertions to verify the correctness of the functions
assert.strictEqual(admins.length, 1);
assert.strictEqual(admins[0].name, 'Alice');
assert.strictEqual(canAliceDeleteUser, true);
assert.strictEqual(userStats.adminCount, 1);
assert.strictEqual(userStats.userCount, 2);

console.log('All assertions passed.');


JUSTIFICATION:
----------------------------------------
This scenario demonstrates complex business logic involving user management and role-based permissions. The code includes various functions to filter users, validate actions based on roles, and generate user statistics, which are common tasks in business applications. The golden completion adds functions to add and remove users, which are essential operations in user management systems. This tests the LLM's ability to generate accurate TypeScript code from detailed documentation and vice versa. The assertions verify the correctness of these functions, ensuring the LLM's understanding of both the code and the documentation.

ASSERTIONS:
----------------------------------------
assert.strictEqual(updatedUsers.length, 4);
assert.strictEqual(updatedUsers[3].name, 'Dave');
assert.strictEqual(usersAfterRemoval.length, 3);
assert.strictEqual(usersAfterRemoval.find(user => user.id === '2'), undefined);

================================================================================

================================================================================
Test Case #39
================================================================================

================================================================================
Test Case ID: 39
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Interface representing a user in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
}

/**
 * Mock database of users.
 */
const usersDb: User[] = [
    { id: 1, name: 'Alice', email: 'alice@example.com', isActive: true },
    { id: 2, name: 'Bob', email: 'bob@example.com', isActive: false },
    { id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true }
];

/**
 * Function to find active users.
 * @returns An array of active users.
 */
function findActiveUsers(): User[] {
    return usersDb.filter(user => user.isActive);
}

/**
 * Function to deactivate a user by their email.
 * @param email - The email of the user to deactivate.
 * @returns The updated user object, or null if no user was found.
 */
function deactivateUserByEmail(email: string): User | null {
    const user = usersDb.find(user => user.email === email);
    if (user) {
        user.isActive = false;
        return user;
    }
    return null;
}

/**
 * Function to validate user email format.
 * @param email - The email to validate.
 * @returns True if the email format is valid, otherwise false.
 */
function validateEmailFormat(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

/**
 * Function to add a new user to the database.
 * @param user - The user object to add.
 * @returns The added user object.
 * @throws Error if the user with the same email already exists.
 */


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function addUser(user: User): User {
    if (!validateEmailFormat(user.email)) {
        throw new Error('Invalid email format');
    }
    
    const existingUser = usersDb.find(u => u.email === user.email);
    if (existingUser) {
        throw new Error('User with this email already exists');
    }
    
    usersDb.push(user);
    return user;
}

SUFFIX CODE:
----------------------------------------

/**
 * Function to activate a user by their email.
 * @param email - The email of the user to activate.
 * @returns The updated user object, or null if no user was found.
 */
function activateUserByEmail(email: string): User | null {
    const user = usersDb.find(user => user.email === email);
    if (user) {
        user.isActive = true;
        return user;
    }
    return null;
}

// Test cases
assert.deepStrictEqual(findActiveUsers().map(user => user.email), ['alice@example.com', 'charlie@example.com']);
assert.strictEqual(deactivateUserByEmail('alice@example.com')?.isActive, false);
assert.strictEqual(activateUserByEmail('bob@example.com')?.isActive, true);
assert.strictEqual(validateEmailFormat('invalid-email'), false);
assert.strictEqual(validateEmailFormat('valid@example.com'), true);


JUSTIFICATION:
----------------------------------------
This test case is a good example because it covers both code-to-comment and comment-to-code translations. The prefix establishes a comprehensive context with multiple functions related to user management, including complex business logic for activating and deactivating users, and email validation. The golden completion requires generating a new function with proper error handling and adds a new user to the database, following the existing patterns. This scenario ensures that the LLM can understand and generate documentation and code consistently, while the assertions verify the functional correctness of the entire implementation.

ASSERTIONS:
----------------------------------------
assert.throws(() => addUser({ id: 4, name: 'Alice', email: 'alice@example.com', isActive: true }), /User with the same email already exists./);
assert.deepStrictEqual(addUser({ id: 4, name: 'Dave', email: 'dave@example.com', isActive: true }), { id: 4, name: 'Dave', email: 'dave@example.com', isActive: true });
================================================================================

================================================================================
Test Case #40
================================================================================

================================================================================
Test Case ID: 40
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface User {
    id: number;
    name: string;
    email: string;
}

interface Policy {
    id: number;
    name: string;
    rules: string[];
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function validateUserPolicy(user: User, policy: Policy): boolean {
    const userEmailDomain = user.email.split('@')[1];
    
    for (const rule of policy.rules) {
        if (rule.startsWith('domain:')) {
            const allowedDomain = rule.substring(7);
            if (userEmailDomain === allowedDomain) {
                return true;
            }
        }
    }
    
    return false;
}

SUFFIX CODE:
----------------------------------------


const user: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };
const policy: Policy = { id: 1, name: 'Email Domain Policy', rules: ['domain:example.com', 'domain:test.com'] };

assert(validateUserPolicy(user, policy) === true);

// Further logic to handle policy enforcement
const invalidUser: User = { id: 2, name: 'Jane Smith', email: 'jane.smith@invalid.com' };
assert(validateUserPolicy(invalidUser, policy) === false);

// Cleanup resources if any
// (In this example, there are no resources to cleanup)


JUSTIFICATION:
----------------------------------------
This test case provides a realistic business logic scenario where a user's email domain must comply with policy rules. The prefix includes a function with partial comments, and the golden completion extends the documentation to cover all necessary details, including error handling. The suffix introduces an additional test case, and the assertions verify the functionality, making this a comprehensive test for both code-to-comment and comment-to-code translation.

ASSERTIONS:
----------------------------------------
const user: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };
const policy: Policy = { id: 1, name: 'Email Domain Policy', rules: ['domain:example.com', 'domain:test.com'] };
const docString = `/**
 * Validates if a user complies with the given policy.
 * @param user - The user to be validated.
 * @param policy - The policy to check against.
 * @returns A boolean indicating if the user complies with the policy.
 * @throws Will throw an error if the policy rules are malformed.
 */`;
assert(docString.toLowerCase().includes('validates if a user complies with the given policy'));
assert(docString.includes('@param user - The user to be validated'));
assert(docString.includes('@param policy - The policy to check against'));
assert(docString.includes('@returns A boolean indicating if the user complies with the policy'));
assert(docString.includes('@throws Will throw an error if the policy rules are malformed'));
assert(validateUserPolicy(user, policy) === true);
const invalidUser: User = { id: 2, name: 'Jane Smith', email: 'jane.smith@invalid.com' };
assert(validateUserPolicy(invalidUser, policy) === false);
================================================================================

================================================================================
Test Case #41
================================================================================

================================================================================
Test Case ID: 41
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a User in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
}

/**
 * Function to validate if a user email follows a specific business rule.
 * The email must be a valid email format and must belong to a specific domain (example.com).
 * 
 * @param email - The email address to validate.
 * @returns True if the email is valid and belongs to the domain, false otherwise.
 */
function validateEmail(email: string): boolean {
    const emailPattern = /^[^@\s]+@example\.com$/;
    return emailPattern.test(email);
}

/**
 * Function to activate a user if their email is valid.
 * 
 * @param user - The user object to be activated.
 * @returns The updated user object.
 */
function activateUser(user: User): User {
    if (validateEmail(user.email)) {
        user.isActive = true;
    } else {
        throw new Error('Invalid email address');
    }
    return user;
}

// Setting up mock users for testing
const user1: User = { id: 1, name: 'Alice', email: 'alice@example.com', isActive: false };
const user2: User = { id: 2, name: 'Bob', email: 'bob@notexample.com', isActive: false };

// Test cases to validate the functionality
try {
    const updatedUser1 = activateUser(user1);
    assert.strictEqual(updatedUser1.isActive, true);

    // This should throw an error due to invalid email
    const updatedUser2 = activateUser(user2);
} catch (error) {
    assert.strictEqual(error.message, 'Invalid email address');
}

/**
 * Function to deactivate a user.
 * 
 * @param user - The user object to be deactivated.
 * @returns The updated user object.
 */

LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function deactivateUser(user: User): User {
    user.isActive = false;
    return user;
}

SUFFIX CODE:
----------------------------------------


// Test deactivating user
const deactivatedUser = deactivateUser(user1);
assert.strictEqual(deactivatedUser.isActive, false);

console.log('All tests passed successfully.');

JUSTIFICATION:
----------------------------------------
This example tests both code-to-comment and comment-to-code capabilities by providing a complex business logic for user activation based on email validation. The prefix includes detailed TypeScript types and interfaces, along with helper functions and comprehensive comments. The golden_completion requires translating a detailed function documentation into code, ensuring consistency in the documentation and implementation. The suffix completes the implementation with additional functionality and tests. Assertions verify both the activation and deactivation functionalities, ensuring correctness and error handling.

ASSERTIONS:
----------------------------------------
assert.strictEqual(typeof deactivateUser, 'function');
assert.strictEqual(deactivateUser.length, 1);
assert.strictEqual(deactivateUser(user1).isActive, false);
assert.strictEqual(deactivateUser({ id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true }).isActive, false);
assert.strictEqual(deactivateUser({ id: 4, name: 'Dana', email: 'dana@example.com', isActive: false }).isActive, false);
================================================================================

================================================================================
Test Case #42
================================================================================

================================================================================
Test Case ID: 42
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a business entity.
 */
interface BusinessEntity {
    id: string;
    name: string;
    isActive: boolean;
}

/**
 * Configuration object for validation rules.
 */
const validationConfig = {
    minNameLength: 3,
    idPattern: /^[a-zA-Z0-9-]+$/
};

/**
 * Validates a business entity based on predefined rules.
 * @param entity - The business entity to validate.
 * @returns A string array of validation errors, or an empty array if valid.
 */
function validateEntity(entity: BusinessEntity): string[] {
    const errors: string[] = [];

    // Validate ID pattern
    if (!validationConfig.idPattern.test(entity.id)) {
        errors.push('Invalid ID format');
    }

    // Validate name length
    if (entity.name.length < validationConfig.minNameLength) {
        errors.push('Name is too short');
    }

    // Validate isActive flag
    if (typeof entity.isActive !== 'boolean') {
        errors.push('isActive must be a boolean');
    }

    return errors;
}

// Example usage:
const exampleEntity: BusinessEntity = {
    id: '123-abc',
    name: 'Example',
    isActive: true
};

const validationErrors = validateEntity(exampleEntity);
assert(validationErrors.length === 0);

/**
 * Function to deactivate a business entity.
 * @param entity - The business entity to deactivate.
 * @returns A new business entity object with isActive set to false.
 */
function deactivateEntity(entity: BusinessEntity): BusinessEntity {


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
    // Create a new entity with isActive set to false

SUFFIX CODE:
----------------------------------------
    return {
        ...entity,
        isActive: false
    };
}

// Example usage:
const deactivatedEntity = deactivateEntity(exampleEntity);
assert(deactivatedEntity.isActive === false);
assert(deactivatedEntity.id === exampleEntity.id);
assert(deactivatedEntity.name === exampleEntity.name);

console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case provides a realistic scenario of validating and deactivating a business entity, which is a common task in business logic. The provided code includes proper TypeScript interfaces, configuration objects, and validation logic, making it comprehensive. The golden completion adds an error handling check to ensure the entity is not already inactive before deactivating it, demonstrating the model's ability to handle error scenarios. The suffix continues with the implementation, ensuring no duplication. Assertions verify the functional requirements and error handling, ensuring the code works correctly. This scenario effectively tests the LLM's ability to translate between code and documentation.

ASSERTIONS:
----------------------------------------
assert.throws(() => deactivateEntity({ id: '123-abc', name: 'Example', isActive: false }), /Entity is already inactive/);
const activeEntity = { id: '123-abc', name: 'Example', isActive: true };
const deactivated = deactivateEntity(activeEntity);
assert(deactivated.isActive === false);
assert(deactivated.id === activeEntity.id);
assert(deactivated.name === activeEntity.name);
assert(deactivateEntity.length === 1);

================================================================================

================================================================================
Test Case #43
================================================================================

================================================================================
Test Case ID: 43
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

interface User {
    id: number;
    name: string;
    email: string;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
class UserValidator {
    private allowedDomain: string;

    constructor(allowedDomain: string) {
        this.allowedDomain = allowedDomain;
    }

    /**
     * Validate the user's email.
     * @param user - The user object containing email to validate
     * @returns true if email is valid, false otherwise
     */
    validateEmail(user: User): boolean {
        const emailParts = user.email.split('@');
        if (emailParts.length !== 2) {
            return false;
        }
        const domain = emailParts[1];
        return domain === this.allowedDomain;
    }
}

const userValidator = new UserValidator('example.com');
const validUser: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };
const invalidUser: User = { id: 2, name: 'Jane Smith', email: 'jane.smith@invalid.com' };


assert.strictEqual(userValidator.validateEmail(validUser), true, 'The valid user email should be accepted.');
assert.strictEqual(userValidator.validateEmail(invalidUser), false, 'The invalid user email should be rejected.');

// Cleanup resources or perform additional logic if necessary
console.log('All assertions passed.');

JUSTIFICATION:
----------------------------------------
This test case demonstrates a realistic business rule validation for user email compliance. It includes TypeScript code that validates user emails against a specific allowed domain. The golden completion provides comprehensive documentation for the UserValidator class, including its constructor, methods, and usage example. This tests the LLM's ability to generate accurate and detailed documentation for existing code, ensuring clear communication and understanding of the code's functionality. The assertions verify the correctness of the email validation logic, testing both valid and invalid scenarios.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * UserValidator class enforces business rules for user email compliance.
 * It ensures that user emails adhere to a specific allowed domain.
 * 
 * @param allowedDomain - The domain that user emails must match
 * @returns An instance of UserValidator
 * 
 * Methods:
 * - validateEmail(user: User): boolean
 *   - Validates if the user's email matches the allowed domain.
 * 
 * Usage example:
 * const validator = new UserValidator('example.com');
 * const user = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };
 * console.log(validator.validateEmail(user)); // true
 */`;
assert(docString.toLowerCase().includes('business rules'));
assert(docString.includes('allowed domain'));
assert(docString.includes('@param allowedDomain'));
assert(docString.includes('@returns An instance of UserValidator'));
assert(docString.includes('validateEmail(user: User): boolean'));
assert(docString.includes('Usage example:'));
assert(docString.includes('const validator = new UserValidator('));
================================================================================

================================================================================
Test Case #44
================================================================================

================================================================================
Test Case ID: 44
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import * as assert from 'assert';

/**
 * Interface representing a user in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
}

/**
 * Enum representing different types of user roles.
 */
enum UserRole {
    ADMIN = 'admin',
    USER = 'user',
    GUEST = 'guest'
}

/**
 * Function to determine if a user has admin privileges.
 * @param user - The user object.
 * @param role - The role of the user.
 * @returns True if the user is an admin, otherwise false.
 */
function isAdmin(user: User, role: UserRole): boolean {
    return role === UserRole.ADMIN;
}

/**
 * Function to toggle the activation status of a user.
 * @param user - The user object.
 * @returns The updated user object with toggled activation status.
 */
function toggleUserActivation(user: User): User {
    return { ...user, isActive: !user.isActive };
}

/**
 * Function to filter active users from a list.
 * @param users - Array of user objects.
 * @returns Array of active user objects.
 */
function filterActiveUsers(users: User[]): User[] {
    return users.filter(user => user.isActive);
}

/**
 * Class representing the user management system.
 */
class UserManager {
    private users: User[] = [];

    /**
     * Add a new user to the system.
     * @param user - The user object to add.
     */
    addUser(user: User): void {
        this.users.push(user);
    }

    /**
     * Remove a user from the system by ID.
     * @param userId - The ID of the user to remove.
     * @returns True if the user was removed, otherwise false.
     */
    removeUser(userId: number): boolean {
        const index = this.users.findIndex(user => user.id === userId);
        if (index !== -1) {
            this.users.splice(index, 1);
            return true;
        }
        return false;
    }

    /**
     * Get a list of all users in the system.
     * @returns Array of user objects.
     */
    getUsers(): User[] {
        return this.users;
    }

    /**
     * Get a list of all active users in the system.
     * @returns Array of active user objects.
     */
    getActiveUsers(): User[] {
        return filterActiveUsers(this.users);
    }
}

const userManager = new UserManager();
userManager.addUser({ id: 1, name: 'Alice', email: 'alice@example.com', isActive: true });
userManager.addUser({ id: 2, name: 'Bob', email: 'bob@example.com', isActive: false });



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
// Test the UserManager functionality
const allUsers = userManager.getUsers();
const activeUsers = userManager.getActiveUsers();

SUFFIX CODE:
----------------------------------------

assert.strictEqual(userManager.getUsers().length, 2);
assert.strictEqual(userManager.getActiveUsers().length, 1);
assert.strictEqual(userManager.removeUser(1), true);
assert.strictEqual(userManager.getUsers().length, 1);
assert.strictEqual(userManager.getActiveUsers().length, 0);
userManager.addUser({ id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true });
assert.strictEqual(userManager.getUsers().length, 2);
assert.strictEqual(userManager.getActiveUsers().length, 1);


JUSTIFICATION:
----------------------------------------
This scenario is a good test case because it covers a comprehensive implementation of a user management system, including class definitions, interface usage, and various utility functions. The golden completion focuses on adding a new function with detailed documentation, which requires understanding of the context provided in the prefix. This tests the LLM's ability to generate code from comments, ensuring alignment between natural language descriptions and code implementation. The assertions verify functional correctness of the implementation, while the structure and comments ensure clarity and maintainability.

ASSERTIONS:
----------------------------------------
assert.strictEqual(userManager.getUsers().length, 2);
assert.strictEqual(userManager.getActiveUsers().length, 1);
assert.strictEqual(userManager.removeUser(1), true);
assert.strictEqual(userManager.getUsers().length, 1);
assert.strictEqual(userManager.getActiveUsers().length, 0);
userManager.addUser({ id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true });
assert.strictEqual(userManager.getUsers().length, 2);
assert.strictEqual(userManager.getActiveUsers().length, 1);
assert.strictEqual(userManager.updateUserEmail(2, 'bob.new@example.com'), true);
assert.strictEqual(userManager.getUsers().find(user => user.id === 2)?.email, 'bob.new@example.com');

================================================================================

================================================================================
Test Case #45
================================================================================

================================================================================
Test Case ID: 45
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Represents a user in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
}

/**
 * Represents a policy that must be enforced.
 */
interface Policy {
    id: number;
    name: string;
    isActive: boolean;
}

/**
 * Validates if the given user complies with the active policies.
 * @param user The user to validate.
 * @param policies The list of policies to check against.
 * @returns True if the user complies with all active policies, false otherwise.
 */
function validateUserCompliance(user: User, policies: Policy[]): boolean {
    for (const policy of policies) {
        if (policy.isActive) {
            // Complex validation logic for each policy
            if (policy.name === 'EmailVerified' && !user.email.includes('@')) {
                return false;
            }
            // More business rules can be added here
        }
    }
    return true;
}

/**
 * Example usage of validateUserCompliance function.
 */
const user: User = { id: 1, name: 'John Doe', email: 'johndoe@example.com' };
const policies: Policy[] = [
    { id: 1, name: 'EmailVerified', isActive: true },
    { id: 2, name: 'ProfileComplete', isActive: false }
];

const isCompliant = validateUserCompliance(user, policies);
assert.strictEqual(isCompliant, true);

const nonCompliantUser: User = { id: 2, name: 'Jane Doe', email: 'janedoeexample.com' };
const isNonCompliant = validateUserCompliance(nonCompliantUser, policies);
assert.strictEqual(isNonCompliant, false);

/**
 * Error handling logic for user compliance validation.
 * This function will log an error message if a user does not comply with active policies.
 * @param user The user to validate.
 * @param policies The list of policies to check against.
 * @returns True if the user complies with all active policies, false otherwise.
 */


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {
    try {
        return validateUserCompliance(user, policies);
    } catch (error) {
        console.error(`Error validating user compliance for user ${user.id}: ${error.message}`);
        return false;
    }
}


SUFFIX CODE:
----------------------------------------
const compliantUser: User = { id: 3, name: 'Alice Smith', email: 'alice@example.com' };
const isCompliantWithErrorHandling = validateUserComplianceWithErrorHandling(compliantUser, policies);
assert.strictEqual(isCompliantWithErrorHandling, true);

const nonCompliantUserWithErrorHandling: User = { id: 4, name: 'Bob Brown', email: 'bobexample.com' };
const isNonCompliantWithErrorHandling = validateUserComplianceWithErrorHandling(nonCompliantUserWithErrorHandling, policies);
assert.strictEqual(isNonCompliantWithErrorHandling, false);


JUSTIFICATION:
----------------------------------------
This test case provides a realistic business logic scenario where user compliance with certain policies is validated. It includes both code-to-comment and comment-to-code translation tasks. The detailed documentation in the golden_completion explains the error handling logic, which is critical for understanding the implementation. The assertions test both compliant and non-compliant scenarios, ensuring the function behaves correctly under different conditions. This scenario effectively tests the LLM's ability to translate between code and natural language, handle complex business rules, and document error handling logic.

ASSERTIONS:
----------------------------------------
const docString = validateUserComplianceWithErrorHandling.toString();
assert(docString.toLowerCase().includes('validates if the given user complies with the active policies and handles errors'));
assert(docString.includes('@param user'));
assert(docString.includes('@param policies'));
assert(docString.includes('@returns'));
assert(docString.includes('log an error message if a user does not comply with active policies'));

================================================================================

================================================================================
Test Case #46
================================================================================

================================================================================
Test Case ID: 46
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Interface representing a business entity.
 */
interface BusinessEntity {
    id: string;
    name: string;
    complianceStatus: ComplianceStatus;
}

/**
 * Enum representing compliance status.
 */
enum ComplianceStatus {
    COMPLIANT = 'compliant',
    NON_COMPLIANT = 'non_compliant'
}

/**
 * Function to check if a business entity is compliant.
 * @param entity - The business entity to check.
 * @returns True if the entity is compliant, otherwise false.
 */
function isCompliant(entity: BusinessEntity): boolean {
    return entity.complianceStatus === ComplianceStatus.COMPLIANT;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
/**
 * Function to filter compliant business entities.
 * @param entities - Array of business entities to filter.
 * @returns Array of compliant business entities.
 */
function filterCompliantEntities(entities: BusinessEntity[]): BusinessEntity[] {
    return entities.filter(entity => isCompliant(entity));
}

SUFFIX CODE:
----------------------------------------

class BusinessRulesValidator {
    private entities: BusinessEntity[];

    constructor(entities: BusinessEntity[]) {
        this.entities = entities;
    }

    /**
     * Validates all business entities for compliance.
     * @returns An array of non-compliant business entities.
     */
    validateCompliance(): BusinessEntity[] {
        const nonCompliantEntities: BusinessEntity[] = [];
        for (const entity of this.entities) {
            if (!isCompliant(entity)) {
                nonCompliantEntities.push(entity);
            }
        }
        return nonCompliantEntities;
    }
}

// Example usage
const entities: BusinessEntity[] = [
    { id: '1', name: 'Entity1', complianceStatus: ComplianceStatus.COMPLIANT },
    { id: '2', name: 'Entity2', complianceStatus: ComplianceStatus.NON_COMPLIANT }
];
const validator = new BusinessRulesValidator(entities);
const nonCompliantEntities = validator.validateCompliance();

assert(nonCompliantEntities.length === 1);
assert(nonCompliantEntities[0].id === '2');
assert(nonCompliantEntities[0].name === 'Entity2');
assert(nonCompliantEntities[0].complianceStatus === ComplianceStatus.NON_COMPLIANT);


JUSTIFICATION:
----------------------------------------
This test case is a good example of code-to-comment translation because it involves a realistic business scenario of validating compliance rules for business entities. The BusinessRulesValidator class contains a method to validate the compliance of a list of entities and collect non-compliant ones, demonstrating complex logic. The detailed TSDoc comments in the golden_completion provide comprehensive documentation, including parameter descriptions, return value, and usage examples. The assertions in the suffix verify the correctness of the functionality, ensuring that the class works as intended.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * The BusinessRulesValidator class is responsible for validating a list of business entities against compliance rules.
 * It checks each entity's compliance status and collects all non-compliant entities.
 *
 * @class BusinessRulesValidator
 * @constructor
 * @param {BusinessEntity[]} entities - The list of business entities to validate.
 *
 * @method validateCompliance
 * @returns {BusinessEntity[]} - An array of non-compliant business entities.
 *
 * Example usage:
 * typescript
 * const entities: BusinessEntity[] = [
 *     { id: '1', name: 'Entity1', complianceStatus: ComplianceStatus.COMPLIANT },
 *     { id: '2', name: 'Entity2', complianceStatus: ComplianceStatus.NON_COMPLIANT }
 * ];
 * const validator = new BusinessRulesValidator(entities);
 * const nonCompliantEntities = validator.validateCompliance();
 * console.log(nonCompliantEntities); // Outputs: [{ id: '2', name: 'Entity2', complianceStatus: ComplianceStatus.NON_COMPLIANT }]
 * 
 */`;

assert(docString.toLowerCase().includes('businessrulesvalidator'));
assert(docString.includes('Parameters:'));
assert(docString.includes('Example usage:'));
assert(docString.includes('@returns {BusinessEntity[]}'));
assert(docString.includes('non_compliant business entities.'));

================================================================================

================================================================================
Test Case #47
================================================================================

================================================================================
Test Case ID: 47
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

/**
 * Represents a user in the system.
 */
interface User {
    id: number;
    name: string;
    email: string;
    roles: string[];
}

/**
 * Validates if the given user complies with the business rules.
 *
 * Business Rules:
 * 1. A user must have at least one role.
 * 2. A user must have a valid email format.
 *
 * @param user The user object to validate.
 * @returns An array of error messages, empty if the user is valid.
 */
function validateUser(user: User): string[] {
    const errors: string[] = [];

    // Ensure the user has at least one role
    if (user.roles.length === 0) {
        errors.push('User must have at least one role.');
    }

    // Ensure the email format is valid
    const emailRegex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
    if (!emailRegex.test(user.email)) {
        errors.push('Invalid email format.');
    }

    return errors;
}

// Example usage
const user: User = {
    id: 1,
    name: 'John Doe',
    email: 'johndoe@example.com',
    roles: ['admin']
};

const validationErrors = validateUser(user);

/**
 * Schedules a task for the user based on their role.
 *
 * Rules:
 * 1. Admin users should have daily tasks.
 * 2. General users should have weekly tasks.
 * 3. If a user has both roles, prioritize daily tasks.
 *
 * @param user The user object
 */
function scheduleUserTasks(user: User): void {


LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
    if (user.roles.includes('admin')) {
        console.log(`Scheduling daily tasks for admin user: ${user.name}`);
    } else if (user.roles.includes('user')) {
        console.log(`Scheduling weekly tasks for general user: ${user.name}`);
    } else {
        console.log(`No specific tasks scheduled for user: ${user.name} with roles: ${user.roles.join(', ')}`);
    }

SUFFIX CODE:
----------------------------------------

}

// Additional usage example for scheduling tasks
const taskUser: User = {
    id: 2,
    name: 'Jane Smith',
    email: 'jane.smith@example.com',
    roles: ['user', 'admin']
};

scheduleUserTasks(taskUser);


JUSTIFICATION:
----------------------------------------
This test case is designed to evaluate the LLM's ability to translate between code and natural language effectively. The prefix provides detailed context with TypeScript interfaces, function definitions, and complex business logic. The golden_completion requires implementing a function based on the provided documentation, ensuring the LLM can interpret and generate accurate code. The suffix continues the scenario with additional usage, and the assertions test the functional requirements.

ASSERTIONS:
----------------------------------------
assert(validationErrors.length === 0);
assert.doesNotThrow(() => scheduleUserTasks(taskUser));
assert.strictEqual(console.log.calledWith('Jane Smith has been scheduled for daily tasks.'), true);
assert.strictEqual(console.log.calledWith('John Doe has been scheduled for daily tasks.'), true);
================================================================================

================================================================================
Test Case #48
================================================================================

================================================================================
Test Case ID: 48
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * This module defines a class and related functions for managing a simple in-memory cache.
 * The cache supports basic operations such as adding, retrieving, and invalidating entries.
 */

interface CacheEntry<T> {
    value: T;
    expiry: number;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
class SimpleCache<T> {
    private cache: Map<string, CacheEntry<T>>;
    private defaultTTL: number;

    constructor(defaultTTL: number = 60000) {
        this.cache = new Map();
        this.defaultTTL = defaultTTL;
    }

    /**
     * Adds an entry to the cache with an optional TTL (time-to-live).
     * @param key - The key under which the entry is stored.
     * @param value - The value to be cached.
     * @param ttl - Optional TTL for the entry. If not provided, default TTL is used.
     */
    add(key: string, value: T, ttl?: number): void {
        const expiry = Date.now() + (ttl ?? this.defaultTTL);
        this.cache.set(key, { value, expiry });
    }

    /**
     * Retrieves an entry from the cache if it exists and has not expired.
     * @param key - The key of the entry to retrieve.
     * @returns The cached value or undefined if the entry does not exist or has expired.
     */
    get(key: string): T | undefined {
        const entry = this.cache.get(key);
        if (entry && entry.expiry > Date.now()) {
            return entry.value;
        }
        this.cache.delete(key);
        return undefined;
    }

    /**
     * Invalidates an entry in the cache.
     * @param key - The key of the entry to invalidate.
     */
    invalidate(key: string): void {
        this.cache.delete(key);
    }

    /**
     * Clears all entries in the cache.
     */
    clear(): void {
        this.cache.clear();
    }
}

const cache = new SimpleCache<number>();
cache.add('key1', 42);
assert.strictEqual(cache.get('key1'), 42);


cache.invalidate('key1');
assert.strictEqual(cache.get('key1'), undefined);
cache.add('key2', 84, 100);
assert.strictEqual(cache.get('key2'), 84);

setTimeout(() => {
    assert.strictEqual(cache.get('key2'), undefined);
}, 150);

cache.clear();
assert.strictEqual(cache.get('key1'), undefined);
assert.strictEqual(cache.get('key2'), undefined);


JUSTIFICATION:
----------------------------------------
This example presents a realistic scenario of a simple in-memory cache management system, providing a comprehensive class definition and methods. The golden completion includes detailed TSDoc comments that describe the class, its properties, and methods, along with usage examples. This tests an LLM's ability to generate accurate and complete documentation for a given TypeScript implementation, ensuring alignment between code and comments. The assertions verify the correct behavior of the cache methods, including edge cases and error handling.

ASSERTIONS:
----------------------------------------
import { strict as assert } from 'assert';

const cache = new SimpleCache<number>();

// Test adding and retrieving a cache entry
cache.add('key1', 42);
assert.strictEqual(cache.get('key1'), 42);

// Test invalidating a cache entry
cache.invalidate('key1');
assert.strictEqual(cache.get('key1'), undefined);

// Test adding a cache entry with a custom TTL and automatic expiration
cache.add('key2', 84, 100);
assert.strictEqual(cache.get('key2'), 84);

setTimeout(() => {
    assert.strictEqual(cache.get('key2'), undefined);
}, 150);

// Test clearing the cache
cache.clear();
assert.strictEqual(cache.get('key1'), undefined);
assert.strictEqual(cache.get('key2'), undefined);

================================================================================

================================================================================
Test Case #49
================================================================================

================================================================================
Test Case ID: 49
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import assert from 'assert';

// Utility functions
function isValidEmail(email: string): boolean {
    const emailRegex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
    return emailRegex.test(email);
}

function isValidPhoneNumber(phone: string): boolean {
    const phoneRegex = /^\+?\d{10,15}$/;
    return phoneRegex.test(phone);
}

// Business entity definition
interface User {
    id: number;
    name: string;
    email: string;
    phone: string;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
export 

SUFFIX CODE:
----------------------------------------
function validateUser(user: User): string[] {
    const errors: string[] = [];
    if (!user.name) {
        errors.push('Name is required');
    }
    if (!isValidEmail(user.email)) {
        errors.push('Invalid email address');
    }
    if (!isValidPhoneNumber(user.phone)) {
        errors.push('Invalid phone number');
    }
    return errors;
}

// Example user data
const user1: User = {
    id: 1,
    name: 'John Doe',
    email: 'john.doe@example.com',
    phone: '+1234567890'
};

const user2: User = {
    id: 2,
    name: '',
    email: 'invalid-email',
    phone: '123'
};

// Validate users
const errors1 = validateUser(user1);
const errors2 = validateUser(user2);

// Assertions
assert(errors1.length === 0, 'User 1 should have no validation errors');
assert(errors2.length === 3, 'User 2 should have three validation errors');
assert(errors2.includes('Name is required'), 'User 2 should have a missing name error');
assert(errors2.includes('Invalid email address'), 'User 2 should have an invalid email error');
assert(errors2.includes('Invalid phone number'), 'User 2 should have an invalid phone number error');

// Clean up resources if any (in this case, none required)


JUSTIFICATION:
----------------------------------------
This test case is an excellent example for evaluating an LLM's ability to translate between TypeScript code and natural language documentation. The prefix contains a substantial amount of setup code, including utility functions, an interface definition, and a function implementing business logic validation. The golden completion requires the model to generate comprehensive TSDoc comments for the validateUser function, including parameter descriptions, return value documentation, and usage examples. The suffix includes assertions that verify the correctness of the function's behavior, ensuring that the model's generated documentation accurately describes the implemented logic. This scenario tests the LLM's ability to understand and document complex business logic, handle error conditions, and provide clear examples.

ASSERTIONS:
----------------------------------------
const docString = `/**
 * Validates the given user data and returns a list of validation errors.
 *
 * @param user - The user object containing user data to validate
 * @returns An array of strings representing validation error messages
 *
 * @example
 * typescript
 * const user: User = {
 *     id: 1,
 *     name: 'John Doe',
 *     email: 'john.doe@example.com',
 *     phone: '+1234567890'
 * };
 * const errors = validateUser(user);
 * console.log(errors); // []
 * 
 */`;

assert(docString.toLowerCase().includes('validates the given user data and returns a list of validation errors'), 'Documentation should describe the function purpose');
assert(docString.includes('@param user - The user object containing user data to validate'), 'Documentation should include @param for user');
assert(docString.includes('@returns An array of strings representing validation error messages'), 'Documentation should include @returns description');
assert(docString.includes('@example'), 'Documentation should include an example');
================================================================================

================================================================================
Test Case #50
================================================================================

================================================================================
Test Case ID: 50
Source: devbench-code2NL-NL2code
Language: typescript
================================================================================

PREFIX CODE:
----------------------------------------
import { strict as assert } from 'assert';

/**
 * Represents a user in the system.
 */
interface User {
    id: number;
    name: string;
    isActive: boolean;
}

/**
 * Error thrown when a user is not found.
 */
class UserNotFoundError extends Error {
    constructor(userId: number) {
        super(`User with ID ${userId} not found.`);
        this.name = 'UserNotFoundError';
    }
}

/**
 * A mock database of users.
 */
const users: User[] = [
    { id: 1, name: 'Alice', isActive: true },
    { id: 2, name: 'Bob', isActive: false },
    { id: 3, name: 'Charlie', isActive: true }
];

/**
 * Fetches a user by ID from the mock database.
 * @param userId - The ID of the user to fetch.
 * @returns The user object if found.
 * @throws UserNotFoundError if the user is not found.
 */
function getUserById(userId: number): User {
    const user = users.find(u => u.id === userId);
    if (!user) {
        throw new UserNotFoundError(userId);
    }
    return user;
}

/**
 * Activates a user by setting their isActive status to true.
 * @param userId - The ID of the user to activate.
 * @throws UserNotFoundError if the user is not found.
 */
function activateUser(userId: number): void {
    const user = getUserById(userId);
    user.isActive = true;
}



LLM COMPLETION claude-3-7-sonnet:
----------------------------------------
/**
 * Deactivates a user by setting their isActive status to false.
 * @param userId - The ID of the user to deactivate.
 * @throws UserNotFoundError if the user is not found.
 */
function deactivateUser(userId: number): void {
    const user = getUserById(userId);
    user.isActive = false;
}


SUFFIX CODE:
----------------------------------------
// Example usage and assertions
try {
    activateUser(2);
    assert.strictEqual(users[1].isActive, true, 'User 2 should be activated');
    deactivateUser(1);
    assert.strictEqual(users[0].isActive, false, 'User 1 should be deactivated');
    try {
        getUserById(99);
    } catch (error) {
        assert(error instanceof UserNotFoundError, 'Should throw UserNotFoundError for non-existent user');
    }
} finally {
    // Cleanup if necessary (not needed in this example as we are using an in-memory mock database)
}

JUSTIFICATION:
----------------------------------------
This test case is a good example of translating between code and natural language because it includes complex business logic for user activation and deactivation, along with error handling. The prefix includes detailed documentation and type annotations, while the golden_completion requires comprehensive documentation of the activateUser and deactivateUser functions. The suffix includes additional assertions to verify the correctness of the implementation and error handling. This scenario tests the LLM's ability to generate accurate documentation and code translations in a realistic business context.

ASSERTIONS:
----------------------------------------
const docString = activateUser.toString();
assert(docString.includes('Activates a user by setting their isActive status to true'));
assert(docString.includes('Parameters:'));
assert(docString.includes('userId - The ID of the user to activate'));
assert(docString.includes('throws UserNotFoundError if the user is not found'));
const docString2 = deactivateUser.toString();
assert(docString2.includes('Deactivates a user by setting their isActive status to false'));
assert(docString2.includes('Parameters:'));
assert(docString2.includes('userId - The ID of the user to deactivate'));
assert(docString2.includes('throws UserNotFoundError if the user is not found'));

================================================================================
