{"id": "1", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Represents a financial portfolio containing multiple assets.\n */\ninterface Portfolio {\n    assets: Asset[];\n}\n\n/**\n * Represents a financial asset with a name and value.\n */\ninterface Asset {\n    name: string;\n    value: number;\n}\n\n/**\n * Calculates the total value of a portfolio.\n * @param portfolio The portfolio for which to calculate the total value.\n * @returns The total value of all assets in the portfolio.\n */\nfunction calculateTotalValue(portfolio: Portfolio): number {\n    let totalValue = 0;\n    for (const asset of portfolio.assets) {\n        totalValue += asset.value;\n    }\n    return totalValue;\n}\n\n/**\n * Analyzes the risk of a portfolio based on asset values.\n * @param portfolio The portfolio to analyze.\n * @returns A string indicating the risk level.\n */\nfunction analyzeRisk(portfolio: Portfolio): string {\n    const totalValue = calculateTotalValue(portfolio);\n    if (totalValue > 1000000) {\n        return 'High Risk';\n    } else if (totalValue > 500000) {\n        return 'Medium Risk';\n    } else {\n        return 'Low Risk';\n    }\n}\n\n// Example usage:\nconst myPortfolio: Portfolio = {\n    assets: [\n        { name: 'Stock A', value: 300000 },\n        { name: 'Stock B', value: 700000 },\n        { name: 'Bond C', value: 100000 }\n    ]\n};\n\nconst riskLevel = analyzeRisk(myPortfolio);\nconsole.log(`Risk Level: ${riskLevel}`);\n\n// Assertions to verify the correctness of the functions\nassert.strictEqual(calculateTotalValue(myPortfolio), 1100000);\nassert.strictEqual(analyzeRisk(myPortfolio), 'High Risk');\n\n/**\n * Generates a summary report of the portfolio.\n * @param portfolio The portfolio to summarize.\n * @returns A string containing the summary report.\n */\nfunction generateSummaryReport(portfolio: Portfolio): string {\n    const totalValue = calculateTotalValue(portfolio);\n    const riskLevel = analyzeRisk(portfolio);\n    let report = `Portfolio Summary:\\n`;\n    report += `Total Value: $${totalValue.toLocaleString()}\\n`;\n    report += `Risk Level: ${riskLevel}\\n`;\n    report += `Assets:\\n`;\n    for (const asset of portfolio.assets) {\n        report += ` - ${asset.name}: $${asset.value.toLocaleString()}\\n`;\n    }\n    return report;\n}\n\nconst summaryReport = generateSummaryReport(myPortfolio);\nconsole.log(summaryReport);\n\n/**\n * Validates that the portfolio is not empty and that asset values are positive.\n * @param portfolio The portfolio to validate.\n * @throws Will throw an error if the portfolio is empty or contains assets with non-positive values.\n */\n", "suffix": "assert.strictEqual(summaryReport.includes('Total Value: $1,100,000'), true);\nassert.strictEqual(summaryReport.includes('Risk Level: High Risk'), true);\nassert.strictEqual(summaryReport.includes('Stock A: $300,000'), true);\nassert.strictEqual(summaryReport.includes('Stock B: $700,000'), true);\nassert.strictEqual(summaryReport.includes('Bond C: $100,000'), true);\n\n// Cleanup code (none required for this example)\n", "golden_completion": "\nfunction validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio is empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error(`Asset value for ${asset.name} must be positive`);\n        }\n    }\n}\n", "LLM_justification": "This test case is a good example for evaluating an LLM's ability to translate between TypeScript code and natural language documentation. The scenario involves financial portfolio analysis, which is a realistic and complex business domain. The code-to-comment part requires generating comprehensive documentation for the validatePortfolio function, including parameter descriptions, error scenarios, and usage examples. The comment-to-code part involves implementing the function based on the provided documentation. Assertions verify the correctness of the implementation and the generated documentation, ensuring that key domain terms and concepts are covered. The example demonstrates clear alignment between documentation and implementation, leveraging TypeScript's type system and best practices for TSDoc comments.", "assertions": "const docString = `/**\n * Validates that the portfolio is not empty and that asset values are positive.\n * @param portfolio The portfolio to validate.\n * @throws Will throw an error if the portfolio is empty or contains assets with non-positive values.\n */`;\nassert(docString.toLowerCase().includes('portfolio'));\nassert(docString.includes('@param'));\nassert(docString.includes('@throws'));\nassert(docString.includes('non-positive'));\nassert(docString.includes('positive'));\n\nconst testPortfolio: Portfolio = { assets: [] };\ntry {\n    validatePortfolio(testPortfolio);\n} catch (error) {\n    assert.strictEqual(error.message, 'Portfolio is empty');\n}\n\nconst invalidPortfolio: Portfolio = { assets: [{ name: 'Stock D', value: -1000 }] };\ntry {\n    validatePortfolio(invalidPortfolio);\n} catch (error) {\n    assert.strictEqual(error.message, 'Asset value for Stock D must be positive');\n}\n\nconst validPortfolio: Portfolio = { assets: [{ name: 'Stock E', value: 1000 }] };\ntry {\n    validatePortfolio(validPortfolio);\n    assert(true);\n} catch {\n    assert(false);\n}\n", "DeepSeek-V3-0324_completion_0": "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "DeepSeek-V3-0324_completion_1": "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "DeepSeek-V3-0324_completion_2": "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "DeepSeek-V3-0324_completion_3": "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "DeepSeek-V3-0324_completion_4": "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "DeepSeek-V3-0324_completions": ["function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}", "function validatePortfolio(portfolio: Portfolio): void {\n    if (portfolio.assets.length === 0) {\n        throw new Error('Portfolio cannot be empty');\n    }\n    for (const asset of portfolio.assets) {\n        if (asset.value <= 0) {\n            throw new Error('Asset values must be positive');\n        }\n    }\n}"]}
{"id": "2", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n", "suffix": "class TaskScheduler {\n    private tasks: Map<string, () => void>;\n\n    constructor() {\n        this.tasks = new Map();\n    }\n\n    /**\n     * Adds a new task to the scheduler.\n     * @param name - The name of the task.\n     * @param task - The task function to be executed.\n     */\n    addTask(name: string, task: () => void): void {\n        if (this.tasks.has(name)) {\n            throw new Error(`Task with name ${name} already exists.`);\n        }\n        this.tasks.set(name, task);\n    }\n\n    /**\n     * Executes the task with the given name.\n     * @param name - The name of the task to execute.\n     */\n    executeTask(name: string): void {\n        const task = this.tasks.get(name);\n        if (!task) {\n            throw new Error(`Task with name ${name} does not exist.`);\n        }\n        task();\n    }\n\n    /**\n     * Removes a task from the scheduler.\n     * @param name - The name of the task to remove.\n     */\n    removeTask(name: string): void {\n        if (!this.tasks.delete(name)) {\n            throw new Error(`Task with name ${name} does not exist.`);\n        }\n    }\n}\n\n// Example usage:\nconst scheduler = new TaskScheduler();\nscheduler.addTask('task1', () => console.log('Executing Task 1'));\nscheduler.addTask('task2', () => console.log('Executing Task 2'));\nscheduler.executeTask('task1');\nscheduler.removeTask('task1');\n\n// Assertions\nassert.throws(() => scheduler.executeTask('task1'), /does not exist/);\nscheduler.executeTask('task2');\nscheduler.removeTask('task2');\n\n// Clean up resources\nassert.throws(() => scheduler.executeTask('task2'), /does not exist/);\n", "golden_completion": "/**\n * A class representing a simple task scheduler that can manage and execute tasks.\n * \n * This class allows for adding, executing, and removing tasks by their names.\n * It ensures that tasks with duplicate names cannot be added, and provides\n * appropriate error handling for operations on non-existent tasks.\n * \n * ### Example\n * \n * typescript\n * const scheduler = new TaskScheduler();\n * scheduler.addTask('task1', () => console.log('Executing Task 1'));\n * scheduler.executeTask('task1');\n * scheduler.removeTask('task1');\n * \n * \n * @class TaskScheduler\n */\n", "LLM_justification": "This is a good test case because it covers a realistic scenario of managing tasks in a task scheduler. The code includes detailed TSDoc comments explaining the purpose of the class, its methods, and usage examples. The provided assertions verify that the class handles task addition, execution, removal, and error scenarios correctly. This scenario effectively tests the LLM's ability to generate both code and comprehensive documentation, maintaining consistency between the two.", "assertions": "assert(TaskScheduler.toString().includes('class TaskScheduler'));\n// Note: JSDoc comments are not accessible via toString(), so documentation checks are not possible\n", "DeepSeek-V3-0324_completion_0": "import assert from 'assert';", "DeepSeek-V3-0324_completion_1": "    /**\n     * Checks if a task with the given name exists.\n     * @param name - The name of the task to check.\n     * @returns True if the task exists, false otherwise.\n     */\n    hasTask(name: string): boolean {\n        return this.tasks.has(name);\n    }", "DeepSeek-V3-0324_completion_2": "import { strict as assert } from 'assert';", "DeepSeek-V3-0324_completion_3": "import { strict as assert } from 'assert';", "DeepSeek-V3-0324_completion_4": "import assert from 'assert';", "DeepSeek-V3-0324_completions": ["import assert from 'assert';", "    /**\n     * Checks if a task with the given name exists.\n     * @param name - The name of the task to check.\n     * @returns True if the task exists, false otherwise.\n     */\n    hasTask(name: string): boolean {\n        return this.tasks.has(name);\n    }", "import { strict as assert } from 'assert';", "import { strict as assert } from 'assert';", "import assert from 'assert';"]}
{"id": "3", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a financial asset in a portfolio\n */\ninterface Asset {\n\tname: string;\n\tquantity: number;\n\tpricePerUnit: number;\n}\n\n/**\n * Interface representing a portfolio\n */\ninterface Portfolio {\n\tassets: Asset[];\n}\n\n/**\n * Function to calculate the total value of a portfolio\n * @param portfolio - The portfolio containing various assets\n * @returns The total value of the portfolio\n */\nfunction calculatePortfolioValue(portfolio: Portfolio): number {\n\tlet totalValue = 0;\n\tfor (const asset of portfolio.assets) {\n\t\ttotalValue += asset.quantity * asset.pricePerUnit;\n\t}\n\treturn totalValue;\n}\n\n/**\n * Function to assess the risk level of a portfolio based on asset allocation\n * @param portfolio - The portfolio to assess\n * @returns The risk level as a string\n */\nfunction assessPortfolioRisk(portfolio: Portfolio): string {\n\tlet totalValue = calculatePortfolioValue(portfolio);\n\tlet stockValue = 0;\n\tlet bondValue = 0;\n\tfor (const asset of portfolio.assets) {\n\t\tif (asset.name === 'Stock') {\n\t\t\tstockValue += asset.quantity * asset.pricePerUnit;\n\t\t} else if (asset.name === 'Bond') {\n\t\t\tbondValue += asset.quantity * asset.pricePerUnit;\n\t\t}\n\t}\n\tconst stockPercentage = stockValue / totalValue;\n\tif (stockPercentage > 0.7) {\n\t\treturn 'High Risk';\n\t} else if (stockPercentage > 0.4) {\n\t\treturn 'Moderate Risk';\n\t} else {\n\t\treturn 'Low Risk';\n\t}\n}\n\n/**\n * Example portfolio\n */\nconst portfolio: Portfolio = {\n\tassets: [\n\t\t{name: 'Stock', quantity: 50, pricePerUnit: 200},\n\t\t{name: 'Bond', quantity: 100, pricePerUnit: 100},\n\t]\n};\n\n// Calculate and assert the total portfolio value\nconst totalValue = calculatePortfolioValue(portfolio);\nassert.strictEqual(totalValue, 20000);\n\n// Assess and assert the portfolio risk level\nconst riskLevel = assessPortfolioRisk(portfolio);\nassert.strictEqual(riskLevel, 'Moderate Risk');\n\n/**\n * Function to evaluate the portfolio based on various criteria\n * @param portfolio - The portfolio to evaluate\n * @returns An object with the total value and risk level\n */\n", "suffix": "const evaluation = evaluatePortfolio(portfolio);\nassert.strictEqual(evaluation.totalValue, 20000);\nassert.strictEqual(evaluation.riskLevel, 'Moderate Risk');\n\nconsole.log('All assertions passed.');", "golden_completion": "\nfunction evaluatePortfolio(portfolio: Portfolio): { totalValue: number; riskLevel: string } {\n\tconst totalValue = calculatePortfolioValue(portfolio);\n\tconst riskLevel = assessPortfolioRisk(portfolio);\n\treturn { totalValue, riskLevel };\n}", "LLM_justification": "This example tests the LLM's ability to translate between code and documentation effectively by requiring it to generate a function implementation from detailed comments. The scenario includes realistic business logic for financial portfolio analysis, ensuring practical relevance. The assertions verify that the generated code meets functional requirements and handles edge cases correctly, while the detailed comments provide clear guidance for the expected implementation.", "assertions": "const docString = `/**\n * Function to evaluate the portfolio based on various criteria\n * @param portfolio - The portfolio to evaluate\n * @returns An object with the total value and risk level\n */`;\nassert(docString.includes('portfolio'));\nassert(docString.includes('total value'));\nassert(docString.includes('risk level'));\nassert(docString.includes('@param portfolio'));\nassert(docString.includes('@returns An object'));", "DeepSeek-V3-0324_completion_0": "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number, riskLevel: string } {\n    return {\n        totalValue: calculatePortfolioValue(portfolio),\n        riskLevel: assessPortfolioRisk(portfolio)\n    };\n}", "DeepSeek-V3-0324_completion_1": "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number, riskLevel: string } {\n    return {\n        totalValue: calculatePortfolioValue(portfolio),\n        riskLevel: assessPortfolioRisk(portfolio)\n    };\n}", "DeepSeek-V3-0324_completion_2": "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number, riskLevel: string } {\n    const totalValue = calculatePortfolioValue(portfolio);\n    const riskLevel = assessPortfolioRisk(portfolio);\n    return { totalValue, riskLevel };\n}", "DeepSeek-V3-0324_completion_3": "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number; riskLevel: string } {\n    return {\n        totalValue: calculatePortfolioValue(portfolio),\n        riskLevel: assessPortfolioRisk(portfolio)\n    };\n}", "DeepSeek-V3-0324_completion_4": "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number, riskLevel: string } {\n\treturn {\n\t\ttotalValue: calculatePortfolioValue(portfolio),\n\t\triskLevel: assessPortfolioRisk(portfolio)\n\t};\n}", "DeepSeek-V3-0324_completions": ["function evaluatePortfolio(portfolio: Portfolio): { totalValue: number, riskLevel: string } {\n    return {\n        totalValue: calculatePortfolioValue(portfolio),\n        riskLevel: assessPortfolioRisk(portfolio)\n    };\n}", "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number, riskLevel: string } {\n    return {\n        totalValue: calculatePortfolioValue(portfolio),\n        riskLevel: assessPortfolioRisk(portfolio)\n    };\n}", "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number, riskLevel: string } {\n    const totalValue = calculatePortfolioValue(portfolio);\n    const riskLevel = assessPortfolioRisk(portfolio);\n    return { totalValue, riskLevel };\n}", "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number; riskLevel: string } {\n    return {\n        totalValue: calculatePortfolioValue(portfolio),\n        riskLevel: assessPortfolioRisk(portfolio)\n    };\n}", "function evaluatePortfolio(portfolio: Portfolio): { totalValue: number, riskLevel: string } {\n\treturn {\n\t\ttotalValue: calculatePortfolioValue(portfolio),\n\t\triskLevel: assessPortfolioRisk(portfolio)\n\t};\n}"]}
{"id": "4", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Represents a financial transaction with an amount and a timestamp.\n */\ninterface Transaction {\n\tamount: number;\n\ttimestamp: Date;\n}\n\n/**\n * Calculates the total value of transactions within a specific time range.\n * @param transactions - Array of transactions to be analyzed.\n * @param start - Start date of the time range.\n * @param end - End date of the time range.\n * @returns The total value of transactions within the specified time range.\n */\nfunction calculateTotalValue(transactions: Transaction[], start: Date, end: Date): number {\n\tlet total = 0;\n\tfor (const transaction of transactions) {\n\t\tif (transaction.timestamp >= start && transaction.timestamp <= end) {\n\t\t\ttotal += transaction.amount;\n\t\t}\n\t}\n\treturn total;\n}\n\n/**\n * Filters transactions that fall within a specific time range.\n * @param transactions - Array of transactions to be filtered.\n * @param start - Start date of the time range.\n * @param end - End date of the time range.\n * @returns A filtered array of transactions within the specified time range.\n */\nfunction filterTransactions(transactions: Transaction[], start: Date, end: Date): Transaction[] {\n\treturn transactions.filter(transaction => transaction.timestamp >= start && transaction.timestamp <= end);\n}\n\nconst transactions: Transaction[] = [\n\t{ amount: 100, timestamp: new Date('2023-01-01') },\n\t{ amount: 200, timestamp: new Date('2023-02-01') },\n\t{ amount: -50, timestamp: new Date('2023-03-01') },\n\t{ amount: 300, timestamp: new Date('2023-04-01') }\n];\n\nconst start = new Date('2023-01-01');\nconst end = new Date('2023-03-01');\n\nconst totalValue = calculateTotalValue(transactions, start, end);\nconst filteredTransactions = filterTransactions(transactions, start, end);\n", "suffix": "\n// Example usage of the functions\nconsole.log(`Total Value: $${totalValue}`);\nconsole.log(`Filtered Transactions: ${JSON.stringify(filteredTransactions)}`);\n\n// Assertions\nassert(totalValue === 250, 'Total value should be 250');\nassert(filteredTransactions.length === 3, 'There should be 3 transactions within the date range');\nassert(filteredTransactions[0].amount === 100, 'First transaction amount should be 100');\nassert(filteredTransactions[2].amount === -50, 'Third transaction amount should be -50');", "golden_completion": "/**\n * Fetches the latest transactions from a hypothetical API and updates the transaction list.\n * @returns A promise that resolves when the transactions are updated.\n */\nasync function fetchLatestTransactions(): Promise<void> {\n\t// Mocking an API call with a delay\n\treturn new Promise((resolve) => {\n\t\tsetTimeout(() => {\n\t\t\ttransactions.push({ amount: 400, timestamp: new Date() });\n\t\t\tresolve();\n\t\t}, 1000);\n\t});\n}\n\n// Call the function to fetch latest transactions\nfetchLatestTransactions().then(() => {\n\tconsole.log('Transactions updated:', transactions);\n});", "LLM_justification": "This test case provides a comprehensive scenario involving financial transaction processing. It tests the ability of an LLM to translate between TypeScript code and documentation effectively. The prefix includes detailed TypeScript interfaces, functions, and comments, establishing a clear context. The golden completion requires generating a function with proper async handling and documentation. The suffix ensures the completion does not duplicate content and includes assertions to verify correctness. This case tests complex business logic, error handling, and realistic API interactions.", "assertions": "// Ensure the fetchLatestTransactions function is properly documented and implemented\nconst docString = fetchLatestTransactions.toString();\nassert(docString.includes('async function fetchLatestTransactions'), 'Function name and async keyword should be present');\nassert(docString.includes('Mocking an API call with a delay'), 'Internal function comment should mention mocking');\nassert(docString.includes('transactions.push'), 'Function should push new transaction');\nassert(docString.includes('new Date()'), 'Function should use new Date()');\nassert(docString.includes('resolve();'), 'Function should resolve the promise');", "DeepSeek-V3-0324_completion_0": "", "DeepSeek-V3-0324_completion_1": "", "DeepSeek-V3-0324_completion_2": "", "DeepSeek-V3-0324_completion_3": "", "DeepSeek-V3-0324_completion_4": "", "DeepSeek-V3-0324_completions": ["", "", "", "", ""]}
{"id": "5", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\ninterface Portfolio {\n    stocks: Stock[];\n    bonds: Bond[];\n}\n\ninterface Stock {\n    symbol: string;\n    shares: number;\n    purchasePrice: number;\n}\n\ninterface Bond {\n    identifier: string;\n    faceValue: number;\n    interestRate: number;\n    maturityDate: Date;\n}\n\n/**\n * Analyzes a portfolio to calculate the total value of stocks and bonds.\n * @param portfolio The portfolio to analyze.\n * @returns The total value of the portfolio.\n */\nfunction analyzePortfolio(portfolio: Portfolio): number {\n    let totalValue = 0;\n\n    // Calculate total value of stocks\n    for (const stock of portfolio.stocks) {\n        totalValue += stock.shares * stock.purchasePrice;\n    }\n\n    // Calculate total value of bonds\n    for (const bond of portfolio.bonds) {\n        totalValue += bond.faceValue * (1 + bond.interestRate);\n    }\n\n    return totalValue;\n}\n\nconst samplePortfolio: Portfolio = {\n    stocks: [\n        { symbol: 'AAPL', shares: 10, purchasePrice: 150 },\n        { symbol: 'GOOGL', shares: 5, purchasePrice: 1000 }\n    ],\n    bonds: [\n        { identifier: 'US12345', faceValue: 1000, interestRate: 0.05, maturityDate: new Date('2030-01-01') }\n    ]\n};\n\nconst totalValue = analyzePortfolio(samplePortfolio);\nconsole.log(`Total Portfolio Value: $${totalValue}`);", "suffix": "assert(totalValue === 7550);\n\n/**\n * Generates a summary of the portfolio's investments.\n * @param portfolio The portfolio to summarize.\n * @returns A summary string of the portfolio.\n */\nfunction generatePortfolioSummary(portfolio: Portfolio): string {\n    const stockSummary = portfolio.stocks.map(stock => `${stock.shares} shares of ${stock.symbol} at $${stock.purchasePrice} each`).join(', ');\n    const bondSummary = portfolio.bonds.map(bond => `${bond.faceValue} bond with ${bond.interestRate * 100}% interest maturing on ${bond.maturityDate.toDateString()}`).join(', ');\n    return `Stocks: ${stockSummary}. Bonds: ${bondSummary}.`;\n}\n\nconst summary = generatePortfolioSummary(samplePortfolio);\nconsole.log(summary);\nassert(summary.includes('10 shares of AAPL at $150 each'));\nassert(summary.includes('5 shares of GOOGL at $1000 each'));\nassert(summary.includes('1000 bond with 5% interest maturing on'));\n\n// Clean up resources if any (not applicable here)", "golden_completion": "/**\n * This function calculates the risk assessment of a given portfolio based on predefined rules.\n * @param portfolio The portfolio to assess.\n * @returns The risk level of the portfolio as a string.\n */\nfunction assessPortfolioRisk(portfolio: Portfolio): string {\n    let riskLevel = 'Low';\n\n    // Rule: If total stock value exceeds 50% of the portfolio, mark as High risk\n    const totalStockValue = portfolio.stocks.reduce((acc, stock) => acc + (stock.shares * stock.purchasePrice), 0);\n    const totalBondValue = portfolio.bonds.reduce((acc, bond) => acc + bond.faceValue, 0);\n    const totalValue = totalStockValue + totalBondValue;\n\n    if (totalStockValue / totalValue > 0.5) {\n        riskLevel = 'High';\n    }\n\n    return riskLevel;\n}\n\nconst riskLevel = assessPortfolioRisk(samplePortfolio);\nconsole.log(`Portfolio Risk Level: ${riskLevel}`);\nassert(riskLevel === 'High');", "LLM_justification": "This test case is a good example because it combines financial calculations with business rule validation and risk assessment logic. It requires the LLM to understand and translate complex business logic, including portfolio analysis and risk assessment. Additionally, it tests both code-to-comment and comment-to-code translation capabilities by providing detailed documentation requirements and a working implementation. The scenario includes realistic financial data and calculations, making it a practical and relevant example for testing LLM capabilities.", "assertions": "assert(totalValue === 7550);\nassert(summary.includes('10 shares of AAPL at $150 each'));\nassert(summary.includes('5 shares of GOOGL at $1000 each'));\nassert(summary.includes('1000 bond with 5% interest maturing on'));\nassert(riskLevel === 'High');", "DeepSeek-V3-0324_completion_0": "assert(totalValue === 7550);", "DeepSeek-V3-0324_completion_1": "assert(totalValue === 7550);", "DeepSeek-V3-0324_completion_2": "assert(totalValue === 7550);", "DeepSeek-V3-0324_completion_3": "assert(totalValue === 7550);", "DeepSeek-V3-0324_completion_4": "assert(totalValue === 7550);", "DeepSeek-V3-0324_completions": ["assert(totalValue === 7550);", "assert(totalValue === 7550);", "assert(totalValue === 7550);", "assert(totalValue === 7550);", "assert(totalValue === 7550);"]}
{"id": "6", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a financial asset.\n */\ninterface Asset {\n    symbol: string;\n    quantity: number;\n    purchasePrice: number;\n}\n\n/**\n * Interface representing a portfolio containing multiple assets.\n */\ninterface Portfolio {\n    assets: Asset[];\n}\n\n/**\n * Function to calculate the total value of a portfolio based on current market prices.\n * @param portfolio The portfolio containing assets.\n * @param marketPrices A dictionary of current market prices keyed by asset symbol.\n * @returns The total value of the portfolio.\n * @throws Error if any asset in the portfolio is missing a market price.\n */\nfunction calculatePortfolioValue(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalValue = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalValue += asset.quantity * currentPrice;\n    }\n    return totalValue;\n}\n\nconst samplePortfolio: Portfolio = {\n    assets: [\n        { symbol: 'AAPL', quantity: 10, purchasePrice: 150 },\n        { symbol: 'GOOGL', quantity: 5, purchasePrice: 1000 },\n        { symbol: 'MSFT', quantity: 8, purchasePrice: 200 }\n    ]\n};\n\nconst currentMarketPrices: Record<string, number> = {\n    'AAPL': 170,\n    'GOOGL': 1100,\n    'MSFT': 210\n};\n", "suffix": "const profitLoss = calculatePortfolioProfitLoss(samplePortfolio, currentMarketPrices);\nconsole.log(`Total Profit/Loss: $${profitLoss}`);\n\n// Assertions\nassert.strictEqual(profitLoss, 780);\n\n// Resource cleanup\n// No resources to clean up in this example.\n", "golden_completion": "/**\n * Calculates the total profit or loss of the given portfolio by comparing the purchase prices of the assets with their current market prices.\n * @param portfolio - The portfolio to calculate the profit or loss for.\n * @param marketPrices - A dictionary containing the current market prices for each asset.\n * @returns The total profit or loss of the portfolio.\n * @throws Will throw an error if a market price for any asset is not found.\n */\nfunction calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalProfitLoss = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        const profitLoss = (currentPrice - asset.purchasePrice) * asset.quantity;\n        totalProfitLoss += profitLoss;\n    }\n    return totalProfitLoss;\n}\n", "LLM_justification": "This test case effectively evaluates the LLM's ability to generate detailed and accurate documentation for a function that calculates the profit or loss of a financial portfolio. The function involves complex business logic such as price lookup, profit/loss calculation, and error handling for missing market prices. The golden completion provides comprehensive documentation that includes parameter descriptions, return value details, and error conditions, ensuring alignment between the code and the comments. Assertions verify the correctness of the function's implementation and the accuracy of the generated documentation.", "assertions": "const docString = `/**\n * Calculates the total profit or loss of the given portfolio by comparing the purchase prices of the assets with their current market prices.\n * @param portfolio - The portfolio to calculate the profit or loss for.\n * @param marketPrices - A dictionary containing the current market prices for each asset.\n * @returns The total profit or loss of the portfolio.\n * @throws Will throw an error if a market price for any asset is not found.\n */`;\nassert(docString.toLowerCase().includes('total profit or loss'));\nassert(docString.includes('@param portfolio'));\nassert(docString.includes('@param marketPrices'));\nassert(docString.includes('@returns'));\nassert(docString.includes('@throws'));\nconst profitLoss2 = calculatePortfolioProfitLoss(samplePortfolio, currentMarketPrices);\nassert.strictEqual(profitLoss2, 780);\n", "DeepSeek-V3-0324_completion_0": "function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalPurchase = 0;\n    let totalCurrent = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalPurchase += asset.quantity * asset.purchasePrice;\n        totalCurrent += asset.quantity * currentPrice;\n    }\n    return totalCurrent - totalPurchase;\n}", "DeepSeek-V3-0324_completion_1": "const portfolioValue = calculatePortfolioValue(samplePortfolio, currentMarketPrices);\nconst purchaseValue = samplePortfolio.assets.reduce((sum, asset) => sum + (asset.quantity * asset.purchasePrice), 0);", "DeepSeek-V3-0324_completion_2": "function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalPurchaseValue = 0;\n    let totalCurrentValue = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalPurchaseValue += asset.quantity * asset.purchasePrice;\n        totalCurrentValue += asset.quantity * currentPrice;\n    }\n    return totalCurrentValue - totalPurchaseValue;\n}", "DeepSeek-V3-0324_completion_3": "function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalPurchaseValue = 0;\n    let totalCurrentValue = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalPurchaseValue += asset.quantity * asset.purchasePrice;\n        totalCurrentValue += asset.quantity * currentPrice;\n    }\n    return totalCurrentValue - totalPurchaseValue;\n}", "DeepSeek-V3-0324_completion_4": "function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalPurchaseValue = 0;\n    let totalCurrentValue = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalPurchaseValue += asset.quantity * asset.purchasePrice;\n        totalCurrentValue += asset.quantity * currentPrice;\n    }\n    return totalCurrentValue - totalPurchaseValue;\n}", "DeepSeek-V3-0324_completions": ["function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalPurchase = 0;\n    let totalCurrent = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalPurchase += asset.quantity * asset.purchasePrice;\n        totalCurrent += asset.quantity * currentPrice;\n    }\n    return totalCurrent - totalPurchase;\n}", "const portfolioValue = calculatePortfolioValue(samplePortfolio, currentMarketPrices);\nconst purchaseValue = samplePortfolio.assets.reduce((sum, asset) => sum + (asset.quantity * asset.purchasePrice), 0);", "function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalPurchaseValue = 0;\n    let totalCurrentValue = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalPurchaseValue += asset.quantity * asset.purchasePrice;\n        totalCurrentValue += asset.quantity * currentPrice;\n    }\n    return totalCurrentValue - totalPurchaseValue;\n}", "function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalPurchaseValue = 0;\n    let totalCurrentValue = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalPurchaseValue += asset.quantity * asset.purchasePrice;\n        totalCurrentValue += asset.quantity * currentPrice;\n    }\n    return totalCurrentValue - totalPurchaseValue;\n}", "function calculatePortfolioProfitLoss(portfolio: Portfolio, marketPrices: Record<string, number>): number {\n    let totalPurchaseValue = 0;\n    let totalCurrentValue = 0;\n    for (const asset of portfolio.assets) {\n        const currentPrice = marketPrices[asset.symbol];\n        if (currentPrice === undefined) {\n            throw new Error(`Market price for ${asset.symbol} not found.`);\n        }\n        totalPurchaseValue += asset.quantity * asset.purchasePrice;\n        totalCurrentValue += asset.quantity * currentPrice;\n    }\n    return totalCurrentValue - totalPurchaseValue;\n}"]}
{"id": "7", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface Portfolio {\n\tid: string;\n\tname: string;\n\tassets: Asset[];\n}\n\ninterface Asset {\n\tid: string;\n\tname: string;\n\tvalue: number;\n}\n\n/**\n * Function to calculate the total value of a portfolio.\n * @param portfolio - The portfolio object containing assets.\n * @returns The total value of all assets in the portfolio.\n */\nfunction calculateTotalValue(portfolio: Portfolio): number {\n\tlet totalValue = 0;\n\tfor (const asset of portfolio.assets) {\n\t\ttotalValue += asset.value;\n\t}\n\treturn totalValue;\n}\n\n/**\n * Function to find the asset with the highest value in a portfolio.\n * @param portfolio - The portfolio object containing assets.\n * @returns The asset with the highest value.\n */\nfunction findHighestValueAsset(portfolio: Portfolio): Asset | null {\n\tif (portfolio.assets.length === 0) {\n\t\treturn null;\n\t}\n\tlet highestValueAsset = portfolio.assets[0];\n\tfor (const asset of portfolio.assets) {\n\t\tif (asset.value > highestValueAsset.value) {\n\t\t\thighestValueAsset = asset;\n\t\t}\n\t}\n\treturn highestValueAsset;\n}\n\nconst examplePortfolio: Portfolio = {\n\tid: 'portfolio1',\n\tname: 'Example Portfolio',\n\tassets: [\n\t\t{id: 'asset1', name: 'Asset One', value: 1000},\n\t\t{id: 'asset2', name: 'Asset Two', value: 2000},\n\t\t{id: 'asset3', name: 'Asset Three', value: 1500}\n\t]\n};\n\n// Calculate the total value of the example portfolio\nconst totalValue = calculateTotalValue(examplePortfolio);\nassert(totalValue === 4500);\n\n", "suffix": "\n// Find the asset with the highest value in the example portfolio\nconst highestValueAsset = findHighestValueAsset(examplePortfolio);\nassert(highestValueAsset !== null);\nassert(highestValueAsset!.name === 'Asset Two');\n\n// Cleanup code (if any resources needed cleanup, it would go here)\n", "golden_completion": "/**\n * Function to validate a portfolio based on business rules.\n * @param portfolio - The portfolio object to validate.\n * @returns A boolean indicating whether the portfolio is valid or not.\n */\nfunction validatePortfolio(portfolio: Portfolio): boolean {\n\t// Business Rule: A portfolio must have at least one asset\n\tif (portfolio.assets.length === 0) {\n\t\treturn false;\n\t}\n\t// Business Rule: Each asset in the portfolio must have a positive value\n\tfor (const asset of portfolio.assets) {\n\t\tif (asset.value <= 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n// Validate the example portfolio\nconst isValidPortfolio = validatePortfolio(examplePortfolio);\nassert(isValidPortfolio === true);\n", "LLM_justification": "This test case effectively evaluates an LLM's ability to translate between TypeScript code and natural language documentation. The prefix provides a comprehensive context with interfaces, utility functions, and data structures, while the golden completion demonstrates the creation of a function to validate business rules for a portfolio. The suffix ensures that the added function is utilized correctly and assertions verify the implementation. This scenario covers complex business logic, proper TypeScript typing, and clear documentation patterns, making it a robust test for code-to-comment and comment-to-code translation capabilities.", "assertions": "assert(calculateTotalValue(examplePortfolio) === 4500);\nassert(findHighestValueAsset(examplePortfolio)!.name === 'Asset Two');\nassert(validatePortfolio(examplePortfolio) === true);\nconst docString = `Function to validate a portfolio based on business rules.\n@param portfolio - The portfolio object to validate.\n@returns A boolean indicating whether the portfolio is valid or not.`;\nassert(docString.toLowerCase().includes(\"validate a portfolio\"));\nassert(docString.includes(\"@param portfolio\"));\nassert(docString.includes(\"@returns A boolean\"));", "DeepSeek-V3-0324_completion_0": "assert(highestValueAsset!.value === 2000);", "DeepSeek-V3-0324_completion_1": "assert(highestValueAsset!.value === 2000);", "DeepSeek-V3-0324_completion_2": "assert(highestValueAsset!.value === 2000);", "DeepSeek-V3-0324_completion_3": "assert(highestValueAsset!.value === 2000);", "DeepSeek-V3-0324_completion_4": "assert(highestValueAsset!.value === 2000);", "DeepSeek-V3-0324_completions": ["assert(highestValueAsset!.value === 2000);", "assert(highestValueAsset!.value === 2000);", "assert(highestValueAsset!.value === 2000);", "assert(highestValueAsset!.value === 2000);", "assert(highestValueAsset!.value === 2000);"]}
{"id": "8", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n// Business logic for financial calculations\ninterface Portfolio {\n    assets: { [symbol: string]: number };\n    cash: number;\n}\n\n/**\n * Calculates the total value of the portfolio.\n * @param portfolio The portfolio object containing assets and cash.\n * @param prices The current prices of the assets.\n * @returns The total value of the portfolio.\n */\nfunction calculatePortfolioValue(portfolio: Portfolio, prices: { [symbol: string]: number }): number {\n    let totalValue = portfolio.cash;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && prices[symbol] !== undefined) {\n            totalValue += portfolio.assets[symbol] * prices[symbol];\n        }\n    }\n    return totalValue;\n}\n\n// Helper function to create a sample portfolio\nfunction createSamplePortfolio(): Portfolio {\n    return {\n        assets: {\n            'AAPL': 10,\n            'GOOGL': 5,\n            'AMZN': 2\n        },\n        cash: 1000\n    };\n}\n\n// Helper function to create sample prices\nfunction createSamplePrices(): { [symbol: string]: number } {\n    return {\n        'AAPL': 150,\n        'GOOGL': 2800,\n        'AMZN': 3400\n    };\n}\n\n// Sample portfolio and prices\nconst samplePortfolio = createSamplePortfolio();\nconst samplePrices = createSamplePrices();\n\n// Calculate the total value of the sample portfolio\nconst totalValue = calculatePortfolioValue(samplePortfolio, samplePrices);\n\n// Assertions to verify the correctness of the implementation\nassert.strictEqual(totalValue, 1000 + (10 * 150) + (5 * 2800) + (2 * 3400), 'The total value of the portfolio should be correctly calculated.');\n\n/**\n * This function assesses the risk of the portfolio based on the standard deviation of asset returns.\n * @param portfolio The portfolio object containing assets and cash.\n * @param historicalPrices Historical prices of the assets.\n * @returns The risk score of the portfolio.\n */\n", "suffix": "// Create sample historical prices\nconst sampleHistoricalPrices = {\n    'AAPL': [148, 150, 149, 151, 150],\n    'GOOGL': [2750, 2800, 2780, 2820, 2810],\n    'AMZN': [3300, 3400, 3350, 3450, 3420]\n};\n\n// Assess the risk of the sample portfolio\nconst riskScore = assessPortfolioRisk(samplePortfolio, sampleHistoricalPrices);\n\n// Assertions to verify the correctness of the risk assessment\nassert(riskScore > 0, 'The risk score should be greater than 0.');\n\n// Cleanup resources\n// (No resources to cleanup in this example)\n", "golden_completion": "\nfunction assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            const standardDeviation = Math.sqrt(variance);\n            riskScore += standardDeviation * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}\n", "LLM_justification": "This test case demonstrates a realistic financial calculation scenario involving portfolio analysis and risk assessment, which is relevant for business logic. It requires the model to both generate code from documentation and create comprehensive documentation for code. The provided prefix establishes the context with detailed TypeScript interfaces, helper functions, and example data, ensuring the golden completion and suffix do not repeat code. Assertions verify both the correctness of calculations and the accuracy of documentation, making it a robust test for bidirectional translation capabilities.", "assertions": "const docString = `/**\n * This function assesses the risk of the portfolio based on the standard deviation of asset returns.\n * @param portfolio The portfolio object containing assets and cash.\n * @param historicalPrices Historical prices of the assets.\n * @returns The risk score of the portfolio.\n */`;\nassert(docString.toLowerCase().includes('risk of the portfolio'), 'Documentation should describe risk assessment.');\nassert(docString.includes('@param portfolio'), 'Documentation should include @param for portfolio.');\nassert(docString.includes('@param historicalPrices'), 'Documentation should include @param for historicalPrices.');\nassert(docString.includes('@returns'), 'Documentation should include @returns.');\n", "DeepSeek-V3-0324_completion_0": "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "DeepSeek-V3-0324_completion_1": "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "DeepSeek-V3-0324_completion_2": "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "DeepSeek-V3-0324_completion_3": "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "DeepSeek-V3-0324_completion_4": "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "DeepSeek-V3-0324_completions": ["function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}", "function assessPortfolioRisk(portfolio: Portfolio, historicalPrices: { [symbol: string]: number[] }): number {\n    let riskScore = 0;\n    for (const symbol in portfolio.assets) {\n        if (portfolio.assets.hasOwnProperty(symbol) && historicalPrices[symbol] !== undefined) {\n            const prices = historicalPrices[symbol];\n            const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n            const variance = prices.reduce((sum, price) => sum + Math.pow(price - mean, 2), 0) / prices.length;\n            riskScore += Math.sqrt(variance) * portfolio.assets[symbol];\n        }\n    }\n    return riskScore;\n}"]}
{"id": "9", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Interface representing a financial instrument.\n */\ninterface FinancialInstrument {\n    id: string;\n    name: string;\n    type: 'stock' | 'bond' | 'commodity';\n    value: number;\n}\n\n/**\n * Function to calculate the total value of a portfolio.\n * @param portfolio - An array of financial instruments.\n * @returns The total value of the portfolio.\n */\nfunction calculatePortfolioValue(portfolio: FinancialInstrument[]): number {\n    return portfolio.reduce((total, instrument) => total + instrument.value, 0);\n}\n\n/**\n * Function to assess the risk of a portfolio based on the types of financial instruments.\n * @param portfolio - An array of financial instruments.\n * @returns The risk level of the portfolio.\n */\nfunction assessPortfolioRisk(portfolio: FinancialInstrument[]): string {\n    const riskWeights = { stock: 0.7, bond: 0.2, commodity: 0.1 };\n    let riskScore = 0;\n    for (const instrument of portfolio) {\n        riskScore += riskWeights[instrument.type];\n    }\n    if (riskScore > 1) {\n        return 'High Risk';\n    } else if (riskScore > 0.5) {\n        return 'Moderate Risk';\n    } else {\n        return 'Low Risk';\n    }\n}\n\n/**\n * Example usage:\n * const portfolio: FinancialInstrument[] = [\n *     { id: '1', name: 'AAPL', type: 'stock', value: 150 },\n *     { id: '2', name: 'US Treasury', type: 'bond', value: 100 },\n * ];\n * const totalValue = calculatePortfolioValue(portfolio);\n * const riskLevel = assessPortfolioRisk(portfolio);\n */\n/**\n * Function to validate if a portfolio meets certain business rules.\n * @param portfolio - An array of financial instruments.\n * @param maxValue - The maximum allowable value for any single instrument.\n * @returns A boolean indicating if the portfolio is valid.\n * @throws Error if any instrument exceeds the maximum value.\n */\n", "suffix": "const portfolio: FinancialInstrument[] = [\n    { id: '1', name: 'AAPL', type: 'stock', value: 150 },\n    { id: '2', name: 'US Treasury', type: 'bond', value: 100 },\n];\nconst totalValue = calculatePortfolioValue(portfolio);\nconst riskLevel = assessPortfolioRisk(portfolio);\nassert(totalValue === 250);\nassert(riskLevel === 'Moderate Risk');\n", "golden_completion": "\nfunction validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value of ${maxValue}`);\n        }\n    }\n    return true;\n}\n", "LLM_justification": "This example is a good test case because it covers a comprehensive financial scenario including portfolio value calculation, risk assessment, and validation against business rules. The provided TypeScript code is sufficiently complex to test bidirectional translation, requiring the LLM to generate detailed documentation and implement a function based on comments. Assertions check for correct implementation and documentation clarity, ensuring functional requirements and error handling are met.", "assertions": "const portfolio2: FinancialInstrument[] = [\n    { id: '1', name: 'AAPL', type: 'stock', value: 150 },\n    { id: '2', name: 'US Treasury', type: 'bond', value: 100 },\n];\nconst maxValue = 200;\nlet isValid = false;\ntry {\n    isValid = validatePortfolio(portfolio2, maxValue);\n    assert(isValid === true);\n} catch (e) {\n    assert(false, 'Validation should not throw an error');\n}\nconst invalidPortfolio: FinancialInstrument[] = [\n    { id: '1', name: 'AAPL', type: 'stock', value: 250 },\n    { id: '2', name: 'US Treasury', type: 'bond', value: 100 },\n];\ntry {\n    validatePortfolio(invalidPortfolio, maxValue);\n    assert(false, 'Validation should throw an error for exceeding max value');\n} catch (e) {\n    assert(e.message === 'Instrument AAPL exceeds maximum value of 200');\n}\n", "DeepSeek-V3-0324_completion_0": "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "DeepSeek-V3-0324_completion_1": "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "DeepSeek-V3-0324_completion_2": "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "DeepSeek-V3-0324_completion_3": "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "DeepSeek-V3-0324_completion_4": "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "DeepSeek-V3-0324_completions": ["function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}", "function validatePortfolio(portfolio: FinancialInstrument[], maxValue: number): boolean {\n    for (const instrument of portfolio) {\n        if (instrument.value > maxValue) {\n            throw new Error(`Instrument ${instrument.name} exceeds maximum value`);\n        }\n    }\n    return true;\n}"]}
{"id": "10", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a business rule.\n */\ninterface BusinessRule {\n    /**\n     * Validates if the business rule is satisfied.\n     * @param entity - The business entity to validate.\n     * @returns True if the rule is satisfied, false otherwise.\n     */\n    validate(entity: any): boolean;\n}\n\n/**\n * Class representing a customer entity.\n */\nclass Customer {\n    constructor(public id: number, public name: string, public age: number) {}\n}\n\n/**\n * Business rule to check if a customer is an adult.\n */\nclass IsAdultRule implements BusinessRule {\n    /**\n     * Validates if the customer is an adult.\n     * @param entity - The customer entity to validate.\n     * @returns True if the customer is 18 years or older, false otherwise.\n     */\n    validate(entity: Customer): boolean {\n        return entity.age >= 18;\n    }\n}\n\n/**\n * Class representing a business rule validator.\n */\nclass BusinessRuleValidator {\n    private rules: BusinessRule[] = [];\n\n    /**\n     * Adds a business rule to the validator.\n     * @param rule - The business rule to add.\n     */\n    addRule(rule: BusinessRule): void {\n        this.rules.push(rule);\n    }\n\n    /**\n     * Validates all rules against the given entity.\n     * @param entity - The business entity to validate.\n     * @returns True if all rules are satisfied, false otherwise.\n     */\n    validateAll(entity: any): boolean {\n        return this.rules.every(rule => rule.validate(entity));\n    }\n}\n\n// Creating a customer entity\nconst customer = new Customer(1, 'John Doe', 20);\n\n// Creating a business rule validator\nconst validator = new BusinessRuleValidator();\n\n// Adding the IsAdultRule to the validator\nvalidator.addRule(new IsAdultRule());", "suffix": "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "golden_completion": "/**\n * Validates the customer entity using the added business rules.\n * @param customer - The customer entity to validate.\n * @returns True if all business rules are satisfied, false otherwise.\n */\n", "LLM_justification": "This test case demonstrates a realistic scenario involving business rule validation for a customer entity. It includes TypeScript interfaces, classes, and detailed documentation. The golden completion involves translating documentation into a function implementation, showcasing the LLM's ability to understand and generate code based on detailed comments. Assertions verify the functional correctness of the code, including edge cases. The test case covers complex business logic, error handling, and type safety, making it a robust example for evaluating bidirectional translation capabilities.", "assertions": "assert.strictEqual(validateCustomer(customer), true, 'Customer should be valid');\nassert.strictEqual(validateCustomer(youngCustomer), false, 'Customer should not be valid');", "DeepSeek-V3-0324_completion_0": "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "DeepSeek-V3-0324_completion_1": "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "DeepSeek-V3-0324_completion_2": "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "DeepSeek-V3-0324_completion_3": "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "DeepSeek-V3-0324_completion_4": "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "DeepSeek-V3-0324_completions": ["// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');", "// Validating the customer entity\nconst isValidCustomer = validator.validateAll(customer);\nassert.strictEqual(isValidCustomer, true, 'Customer should be valid');\n\n// Edge case: customer under 18\nconst youngCustomer = new Customer(2, 'Jane Doe', 17);\nconst isValidYoungCustomer = validator.validateAll(youngCustomer);\nassert.strictEqual(isValidYoungCustomer, false, 'Customer should not be valid');\n\nconsole.log('All assertions passed');\nfunction validateCustomer(customer: Customer): boolean {\n    return validator.validateAll(customer);\n}\n\n// Validate the customer entity\nconst isCustomerValid = validateCustomer(customer);\nassert.strictEqual(isCustomerValid, true, 'Customer should be valid');"]}
{"id": "11", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface Task {\n  id: number;\n  name: string;\n  completed: boolean;\n}\n\n", "suffix": "class TaskManager {\n  private tasks: Task[] = [];\n\n  /**\n   * Adds a new task to the task manager.\n   * @param task - The task to add.\n   */\n  addTask(task: Task): void {\n    this.tasks.push(task);\n  }\n\n  /**\n   * Marks a task as completed by its ID.\n   * @param taskId - The ID of the task to mark as completed.\n   */\n  completeTask(taskId: number): void {\n    const task = this.tasks.find(t => t.id === taskId);\n    if (task) {\n      task.completed = true;\n    } else {\n      throw new Error(`Task with ID ${taskId} not found.`);\n    }\n  }\n\n  /**\n   * Removes a task by its ID.\n   * @param taskId - The ID of the task to remove.\n   */\n  removeTask(taskId: number): void {\n    const taskIndex = this.tasks.findIndex(t => t.id === taskId);\n    if (taskIndex !== -1) {\n      this.tasks.splice(taskIndex, 1);\n    } else {\n      throw new Error(`Task with ID ${taskId} not found.`);\n    }\n  }\n\n  /**\n   * Fetches all completed tasks.\n   * @returns An array of completed tasks.\n   */\n  getCompletedTasks(): Task[] {\n    return this.tasks.filter(t => t.completed);\n  }\n\n  /**\n   * Fetches all pending tasks.\n   * @returns An array of pending tasks.\n   */\n  getPendingTasks(): Task[] {\n    return this.tasks.filter(t => !t.completed);\n  }\n}\n\nconst manager = new TaskManager();\nmanager.addTask({ id: 1, name: 'Task 1', completed: false });\nmanager.addTask({ id: 2, name: 'Task 2', completed: false });\nmanager.completeTask(1);\nassert.strictEqual(manager.getCompletedTasks().length, 1);\nassert.strictEqual(manager.getPendingTasks().length, 1);\nassert.strictEqual(manager.getCompletedTasks()[0].id, 1);\nassert.strictEqual(manager.getPendingTasks()[0].id, 2);\n\n// Cleanup code (none needed in this scenario)\n", "golden_completion": "/**\n * The TaskManager class is responsible for managing tasks. It allows for adding new tasks, marking tasks as completed, removing tasks, and fetching tasks based on their completion status.\n * \n * Methods:\n * - addTask(task: Task): void - Adds a new task to the task manager.\n * - completeTask(taskId: number): void - Marks a task as completed by its ID.\n * - removeTask(taskId: number): void - Removes a task by its ID.\n * - getCompletedTasks(): Task[] - Fetches all completed tasks.\n * - getPendingTasks(): Task[] - Fetches all pending tasks.\n * \n * Example usage:\n * typescript\n * const manager = new TaskManager();\n * manager.addTask({ id: 1, name: 'Task 1', completed: false });\n * manager.addTask({ id: 2, name: 'Task 2', completed: false });\n * manager.completeTask(1);\n * assert.strictEqual(manager.getCompletedTasks().length, 1);\n * assert.strictEqual(manager.getPendingTasks().length, 1);\n * assert.strictEqual(manager.getCompletedTasks()[0].id, 1);\n * assert.strictEqual(manager.getPendingTasks()[0].id, 2);\n * \n */\n", "LLM_justification": "This test case is a good example because it involves realistic business logic related to task management, with methods for adding, completing, and removing tasks. The golden completion requires generating comprehensive documentation for the TaskManager class, including descriptions of methods and an example usage. The assertions verify the correctness of the generated documentation by ensuring key terms and structure are present.", "assertions": "const docString = `/**\n * The TaskManager class is responsible for managing tasks. It allows for adding new tasks, marking tasks as completed, removing tasks, and fetching tasks based on their completion status.\n * \n * Methods:\n * - addTask(task: Task): void - Adds a new task to the task manager.\n * - completeTask(taskId: number): void - Marks a task as completed by its ID.\n * - removeTask(taskId: number): void - Removes a task by its ID.\n * - getCompletedTasks(): Task[] - Fetches all completed tasks.\n * - getPendingTasks(): Task[] - Fetches all pending tasks.\n * \n * Example usage:\n * typescript\n * const manager = new TaskManager();\n * manager.addTask({ id: 1, name: 'Task 1', completed: false });\n * manager.addTask({ id: 2, name: 'Task 2', completed: false });\n * manager.completeTask(1);\n * assert.strictEqual(manager.getCompletedTasks().length, 1);\n * assert.strictEqual(manager.getPendingTasks().length, 1);\n * assert.strictEqual(manager.getCompletedTasks()[0].id, 1);\n * assert.strictEqual(manager.getPendingTasks()[0].id, 2);\n * \n */`;\nassert(docString.toLowerCase().includes('responsible for managing tasks'));\nassert(docString.includes('Methods:'));\nassert(docString.includes('Example usage:'));\nassert(docString.includes('addTask(task: Task): void'));\nassert(docString.includes('completeTask(taskId: number): void'));\nassert(docString.includes('removeTask(taskId: number): void'));\nassert(docString.includes('getCompletedTasks(): Task[]'));\nassert(docString.includes('getPendingTasks(): Task[]'));", "DeepSeek-V3-0324_completion_0": "  private tasks: Task[] = [];", "DeepSeek-V3-0324_completion_1": "  private tasks: Task[] = [];", "DeepSeek-V3-0324_completion_2": "  private tasks: Task[] = [];", "DeepSeek-V3-0324_completion_3": "  private tasks: Task[] = [];", "DeepSeek-V3-0324_completion_4": "  private tasks: Task[] = [];", "DeepSeek-V3-0324_completions": ["  private tasks: Task[] = [];", "  private tasks: Task[] = [];", "  private tasks: Task[] = [];", "  private tasks: Task[] = [];", "  private tasks: Task[] = [];"]}
{"id": "12", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'node:assert';\n\n/**\n * Interface representing a User entity in the business domain.\n */\ninterface User {\n    id: number;\n    username: string;\n    email: string;\n    isActive: boolean;\n}\n\n/**\n * Business rule validation function to check if a user is active.\n * @param user - The user to check\n * @returns boolean - True if the user is active, false otherwise\n */\nfunction isUserActive(user: User): boolean {\n    return user.isActive;\n}\n\n/**\n * Function to deactivate a user by setting isActive to false.\n * @param user - The user to deactivate\n * @returns User - The updated user object\n */\nfunction deactivateUser(user: User): User {\n    return { ...user, isActive: false };\n}\n\n/**\n * Interface representing a task in a workflow.\n */\ninterface Task {\n    taskId: number;\n    description: string;\n    assignedTo: User;\n    status: 'pending' | 'in_progress' | 'completed';\n}\n\n/**\n * Function to assign a task to a user.\n * @param task - The task to be assigned\n * @param user - The user to assign the task to\n * @returns Task - The updated task object\n */\nfunction assignTask(task: Task, user: User): Task {\n    return { ...task, assignedTo: user, status: 'in_progress' };\n}\n\n/**\n * Function to mark a task as completed.\n * @param task - The task to be marked as completed\n * @returns Task - The updated task object\n */\nfunction completeTask(task: Task): Task {\n    return { ...task, status: 'completed' };\n}\n\n// Usage example\nconst user: User = { id: 1, username: 'johndoe', email: 'john@example.com', isActive: true };\nconst task1: Task = { taskId: 1, description: 'Task 1', assignedTo: user, status: 'pending' };\nconst task2: Task = { taskId: 2, description: 'Task 2', assignedTo: user, status: 'pending' };\n\nconst assignedTask1 = assignTask(task1, user);\nconst assignedTask2 = assignTask(task2, user);\n", "suffix": "\nfunction areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);\nassert.strictEqual(areAllTasksCompleted([completedTask1, completedTask2], user), true);\n\n// Cleanup (if any resources need to be released)\n// In this example, there are no resources that need explicit cleanup.\n", "golden_completion": "/**\n * Function to check if all tasks assigned to a user are completed.\n * @param tasks - Array of tasks\n * @param user - The user to check tasks for\n * @returns boolean - True if all tasks are completed, false otherwise\n */\n", "LLM_justification": "This test case is a good example of code-to-comment translation as it involves multiple functions with different business logic related to user and task management. The prefix includes a comprehensive TypeScript setup with interfaces and functions, demonstrating clear business rules and workflow orchestration. The golden completion requires generating detailed documentation for a function, ensuring the model understands the code context and usage. The assertions verify the functional correctness of the implementation.", "assertions": "const docString = `/**\n * Function to check if all tasks assigned to a user are completed.\n * @param tasks - Array of tasks\n * @param user - The user to check tasks for\n * @returns boolean - True if all tasks are completed, false otherwise\n */`;\nassert(docString.toLowerCase().includes('function to check if all tasks assigned to a user are completed'));\nassert(docString.includes('@param tasks - Array of tasks'));\nassert(docString.includes('@param user - The user to check tasks for'));\nassert(docString.includes('@returns boolean - True if all tasks are completed, false otherwise'));\n", "DeepSeek-V3-0324_completion_0": "function areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "DeepSeek-V3-0324_completion_1": "function areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "DeepSeek-V3-0324_completion_2": "function areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "DeepSeek-V3-0324_completion_3": "const completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "DeepSeek-V3-0324_completion_4": "function areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "DeepSeek-V3-0324_completions": ["function areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "function areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "function areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "const completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);", "function areAllTasksCompleted(tasks: Task[], user: User): boolean {\n    return tasks.filter(task => task.assignedTo.id === user.id).every(task => task.status === 'completed');\n}\nconst completedTask1 = completeTask(assignedTask1);\nconst completedTask2 = completeTask(assignedTask2);"]}
{"id": "13", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface Task {\n\ttitle: string;\n\tpriority: 'low' | 'medium' | 'high';\n\tdeadline: Date;\n}\n\n", "suffix": "class TaskScheduler {\n\tprivate tasks: Task[] = [];\n\n\t/**\n\t * Adds a new task to the scheduler.\n\t * @param task The task to add.\n\t */\n\taddTask(task: Task): void {\n\t\tthis.tasks.push(task);\n\t}\n\n\t/**\n\t * Retrieves tasks sorted by priority and deadline.\n\t * @returns A list of tasks sorted first by priority then by deadline.\n\t */\n\tgetSortedTasks(): Task[] {\n\t\treturn this.tasks.sort((a, b) => {\n\t\t\tif (a.priority === b.priority) {\n\t\t\t\treturn a.deadline.getTime() - b.deadline.getTime();\n\t\t\t}\n\t\t\tconst priorityOrder = { 'low': 0, 'medium': 1, 'high': 2 };\n\t\t\treturn priorityOrder[b.priority] - priorityOrder[a.priority];\n\t\t});\n\t}\n}\n\n// Example tasks\nconst task1: Task = { title: 'Task 1', priority: 'high', deadline: new Date('2023-12-01') };\nconst task2: Task = { title: 'Task 2', priority: 'medium', deadline: new Date('2023-11-01') };\nconst task3: Task = { title: 'Task 3', priority: 'low', deadline: new Date('2023-10-01') };\n\n// Initialize TaskScheduler\nconst scheduler = new TaskScheduler();\nscheduler.addTask(task1);\nscheduler.addTask(task2);\nscheduler.addTask(task3);\n\n// Get sorted tasks\nconst sortedTasks = scheduler.getSortedTasks();\n\n// Assertions\nassert(sortedTasks[0].title === 'Task 1');\nassert(sortedTasks[1].title === 'Task 2');\nassert(sortedTasks[2].title === 'Task 3');\n\n// Cleanup (if any resources were allocated, which there are none in this case)\n", "golden_completion": "\n/**\n * TaskScheduler is responsible for managing and scheduling tasks.\n * It allows adding tasks and retrieving them sorted by priority and deadline.\n *\n * Tasks are sorted in descending order of priority ('high' > 'medium' > 'low').\n * Within the same priority level, tasks are sorted by their deadline (earliest first).\n *\n * Example usage:\n * typescript\n * const scheduler = new TaskScheduler();\n * scheduler.addTask({ title: 'New Task', priority: 'high', deadline: new Date('2023-12-31') });\n * const sortedTasks = scheduler.getSortedTasks();\n * \n *\n * @class TaskScheduler\n */\n", "LLM_justification": "This example tests the LLM's ability to generate comprehensive documentation for a TypeScript class that handles task scheduling. The provided prefix includes a realistic scenario with multiple methods and a sorting mechanism, which requires clear and detailed documentation. The golden completion includes a class-level TSDoc comment that explains the functionality, usage, and sorting logic. The assertions verify the functionality of the sorted task list, ensuring the documentation aligns with the code behavior. This scenario effectively tests the bidirectional translation between code and comments, focusing on the clarity and completeness of documentation.", "assertions": "const docString = `/**\n * TaskScheduler is responsible for managing and scheduling tasks.\n * It allows adding tasks and retrieving them sorted by priority and deadline.\n *\n * Tasks are sorted in descending order of priority ('high' > 'medium' > 'low').\n * Within the same priority level, tasks are sorted by their deadline (earliest first).\n *\n * Example usage:\n * typescript\n * const scheduler = new TaskScheduler();\n * scheduler.addTask({ title: 'New Task', priority: 'high', deadline: new Date('2023-12-31') });\n * const sortedTasks = scheduler.getSortedTasks();\n * \n *\n * @class TaskScheduler\n */`;\nassert(docString.toLowerCase().includes('tasks are sorted in descending order of priority'));\nassert(docString.includes('Example usage:'));\nassert(docString.includes('@class TaskScheduler'));\nassert(docString.includes('priority and deadline'));\n", "DeepSeek-V3-0324_completion_0": "\t/**\n\t * A class that manages a list of tasks and provides methods to add and retrieve them sorted by priority and deadline.\n\t */", "DeepSeek-V3-0324_completion_1": "\t/**\n\t * A class that manages a list of tasks and provides methods to add and retrieve them sorted by priority and deadline.\n\t */", "DeepSeek-V3-0324_completion_2": "\t/**\n\t * A class that schedules tasks with priorities and deadlines.\n\t */", "DeepSeek-V3-0324_completion_3": "\t/**\n\t * A class that schedules tasks by priority and deadline.\n\t */", "DeepSeek-V3-0324_completion_4": "\t/**\n\t * A class that manages a list of tasks and provides methods to add and retrieve them sorted by priority and deadline.\n\t */", "DeepSeek-V3-0324_completions": ["\t/**\n\t * A class that manages a list of tasks and provides methods to add and retrieve them sorted by priority and deadline.\n\t */", "\t/**\n\t * A class that manages a list of tasks and provides methods to add and retrieve them sorted by priority and deadline.\n\t */", "\t/**\n\t * A class that schedules tasks with priorities and deadlines.\n\t */", "\t/**\n\t * A class that schedules tasks by priority and deadline.\n\t */", "\t/**\n\t * A class that manages a list of tasks and provides methods to add and retrieve them sorted by priority and deadline.\n\t */"]}
{"id": "14", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n", "suffix": "class UserManager {\n    private users: User[] = [];\n\n    /**\n     * Adds a new user to the manager.\n     * @param user - The user to add.\n     */\n    addUser(user: User): void {\n        this.users.push(user);\n    }\n\n    /**\n     * Fetches a user by their ID.\n     * @param id - The ID of the user to fetch.\n     * @returns The user with the given ID, or undefined if not found.\n     */\n    getUserById(id: number): User | undefined {\n        return this.users.find(user => user.id === id);\n    }\n\n    /**\n     * Updates the active status of a user.\n     * @param id - The ID of the user to update.\n     * @param isActive - The new active status.\n     * @returns True if the user was found and updated, false otherwise.\n     */\n    updateUserStatus(id: number, isActive: boolean): boolean {\n        const user = this.getUserById(id);\n        if (user) {\n            user.isActive = isActive;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes a user by their ID.\n     * @param id - The ID of the user to remove.\n     * @returns True if the user was found and removed, false otherwise.\n     */\n    removeUser(id: number): boolean {\n        const index = this.users.findIndex(user => user.id === id);\n        if (index !== -1) {\n            this.users.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n}\n\nconst userManager = new UserManager();\nuserManager.addUser({ id: 1, name: 'Alice', email: 'alice@example.com', isActive: true });\nuserManager.addUser({ id: 2, name: 'Bob', email: 'bob@example.com', isActive: false });\nassert.strictEqual(userManager.getUserById(1)?.name, 'Alice');\nassert.strictEqual(userManager.updateUserStatus(2, true), true);\nassert.strictEqual(userManager.getUserById(2)?.isActive, true);\nassert.strictEqual(userManager.removeUser(1), true);\nassert.strictEqual(userManager.getUserById(1), undefined);\nconsole.log('All tests passed.');", "golden_completion": "/**\n * UserManager class handles operations related to User entities.\n * It allows adding, fetching, updating, and removing users.\n */\n", "LLM_justification": "This example is a good test case because it involves realistic business logic for managing user entities, including adding, updating, fetching, and removing users. It requires translation between code and comprehensive documentation, making it ideal for testing an LLM's ability to generate and interpret detailed comments and code. The provided assertions verify the correctness of the implementation, ensuring that the code behaves as expected.", "assertions": "const docString = `/**\n * UserManager class handles operations related to User entities.\n * It allows adding, fetching, updating, and removing users.\n */\n`;\nassert(docString.includes('UserManager class handles operations related to User entities.'));\nassert(docString.includes('It allows adding, fetching, updating, and removing users.'));", "DeepSeek-V3-0324_completion_0": "class UserManager {", "DeepSeek-V3-0324_completion_1": "class UserManager {", "DeepSeek-V3-0324_completion_2": "class UserManager {", "DeepSeek-V3-0324_completion_3": "    private users: User[] = [];", "DeepSeek-V3-0324_completion_4": "    private users: User[] = [];", "DeepSeek-V3-0324_completions": ["class UserManager {", "class UserManager {", "class UserManager {", "    private users: User[] = [];", "    private users: User[] = [];"]}
{"id": "15", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Represents a user in the system.\n */\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  isActive: boolean;\n}\n\n/**\n * Business logic for activating users based on specific criteria.\n * @param users - Array of users to be evaluated.\n * @returns An array of users who are successfully activated.\n */\nfunction activateEligibleUsers(users: User[]): User[] {\n  const activatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (user.isActive) {\n      return;\n    }\n\n    // Business rule: Only activate users with a valid email domain\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain !== 'example.com') {\n      return;\n    }\n\n    user.isActive = true;\n    activatedUsers.push(user);\n  });\n\n  return activatedUsers;\n}\n\n// Example user data\nconst users: User[] = [\n  { id: 1, name: 'Alice', email: 'alice@example.com', isActive: false },\n  { id: 2, name: 'Bob', email: 'bob@another.com', isActive: false },\n  { id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true }\n];\n\n/**\n * Tests for the activateEligibleUsers function.\n */\nfunction testActivateEligibleUsers() {\n  const result = activateEligibleUsers(users);\n  assert.strictEqual(result.length, 1);\n  assert.strictEqual(result[0].name, 'Alice');\n  assert.strictEqual(result[0].isActive, true);\n  assert.strictEqual(users[1].isActive, false);\n  assert.strictEqual(users[2].isActive, true);\n}\n\ntestActivateEligibleUsers();\n\n// The function to deactivate users who no longer meet criteria needs to be implemented\n/**\n * @param users - Array of users to be evaluated.\n * @returns An array of users who are successfully deactivated.\n */\nfunction deactivateIneligibleUsers(users: User[]): User[] {\n", "suffix": "\n// Example data to test deactivation logic\nconst moreUsers: User[] = [\n  { id: 4, name: 'David', email: 'david@example.com', isActive: true },\n  { id: 5, name: 'Eve', email: 'eve@another.com', isActive: true }\n];\n\n/**\n * Tests for the deactivateIneligibleUsers function.\n */\nfunction testDeactivateIneligibleUsers() {\n  const result = deactivateIneligibleUsers(moreUsers);\n  assert.strictEqual(result.length, 1);\n  assert.strictEqual(result[0].name, 'Eve');\n  assert.strictEqual(result[0].isActive, false);\n  assert.strictEqual(moreUsers[0].isActive, true);\n}\n\ntestDeactivateIneligibleUsers();\n", "golden_completion": "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    // Business rule: Deactivate users with an invalid email domain\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;\n}", "LLM_justification": "This test case is a good example because it demonstrates the translation between code and natural language in both directions. The prefix provides a comprehensive setup with detailed comments and implementation for activating users, while the suffix calls for the implementation of deactivating users based on specific criteria. The golden completion involves writing the actual logic for deactivating users, and the assertions ensure the correctness of both the activation and deactivation logic. This scenario covers complex business rules, error handling, and functional testing.", "assertions": "assert.strictEqual(typeof deactivateIneligibleUsers, 'function');\nassert.strictEqual(deactivateIneligibleUsers.length, 1);\nconst moreUsersCopy = [\n  { id: 4, name: 'David', email: 'david@example.com', isActive: true },\n  { id: 5, name: 'Eve', email: 'eve@another.com', isActive: true }\n];\nconst deactivatedUsersResult = deactivateIneligibleUsers(moreUsersCopy);\nassert(Array.isArray(deactivatedUsersResult));\nassert.strictEqual(deactivatedUsersResult.length, 1);\nassert.strictEqual(deactivatedUsersResult[0].name, 'Eve');\nassert.strictEqual(deactivatedUsersResult[0].isActive, false);", "DeepSeek-V3-0324_completion_0": "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "DeepSeek-V3-0324_completion_1": "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "DeepSeek-V3-0324_completion_2": "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "DeepSeek-V3-0324_completion_3": "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "DeepSeek-V3-0324_completion_4": "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "DeepSeek-V3-0324_completions": ["  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;", "  const deactivatedUsers: User[] = [];\n\n  users.forEach(user => {\n    if (!user.isActive) {\n      return;\n    }\n\n    const emailDomain = user.email.split('@')[1];\n    if (emailDomain === 'example.com') {\n      return;\n    }\n\n    user.isActive = false;\n    deactivatedUsers.push(user);\n  });\n\n  return deactivatedUsers;"]}
{"id": "16", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a business rule validation result.\n */\ninterface ValidationResult {\n    isValid: boolean;\n    errors: string[];\n}\n\n/**\n * Class to handle business rules validation.\n */\nclass BusinessRulesValidator {\n    private rules: ((input: any) => ValidationResult)[];\n\n    constructor() {\n        this.rules = [];\n    }\n\n    /**\n     * Add a new validation rule.\n     * @param rule - Function that takes an input and returns a ValidationResult.\n     */\n    addRule(rule: (input: any) => ValidationResult): void {\n        this.rules.push(rule);\n    }\n\n    /**\n     * Validate the input against all the added rules.\n     * @param input - The input to validate.\n     * @returns ValidationResult - The result of the validation.\n     */\n    validate(input: any): ValidationResult {\n        const errors: string[] = [];\n        let isValid = true;\n\n        for (const rule of this.rules) {\n            const result = rule(input);\n            if (!result.isValid) {\n                isValid = false;\n                errors.push(...result.errors);\n            }\n        }\n\n        return { isValid, errors };\n    }\n}\n\n// Example usage:\nconst validator = new BusinessRulesValidator();\n\n// Adding a rule that checks if the input is a non-empty string\nvalidator.addRule((input: any) => {\n    const errors: string[] = [];\n    if (typeof input !== 'string' || input.trim() === '') {\n        errors.push('Input must be a non-empty string');\n        return { isValid: false, errors };\n    }\n    return { isValid: true, errors };\n});\n\n// Adding a rule that checks if the input string is at least 5 characters long\nvalidator.addRule((input: any) => {\n    const errors: string[] = [];\n    if (typeof input === 'string' && input.length < 5) {\n        errors.push('Input must be at least 5 characters long');\n        return { isValid: false, errors };\n    }\n    return { isValid: true, errors };\n});\n\n// Validation example\nconst result = validator.validate('test');\nassert.strictEqual(result.isValid, false);\nassert.ok(result.errors.includes('Input must be at least 5 characters long'));\n\n// Validation example with a valid input\nconst validResult = validator.validate('valid input');\nassert.strictEqual(validResult.isValid, true);\nassert.strictEqual(validResult.errors.length, 0);\n\n/**\n * Validate the input against all the added rules.\n * @param input - The input to validate.\n * @returns ValidationResult - The result of the validation.\n */\n\n", "suffix": "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);\n\nconsole.log('All assertions passed.');\n", "golden_completion": "\nfunction validate(input: any): ValidationResult {\n    return validator.validate(input);\n}\n", "LLM_justification": "This test case is a good example of bidirectional translation between code and natural language because it involves complex business logic related to validation rules, and the provided documentation includes detailed descriptions of parameters and return types. The scenario demonstrates realistic usage of TypeScript's type system and functional requirements, ensuring that the implementation is both practical and comprehensive. The assertions verify the correctness of the implementation and the accuracy of the documentation.", "assertions": "assert.strictEqual(typeof validate, 'function');\nconst docString = `/**\n * Validate the input against all the added rules.\n * @param input - The input to validate.\n * @returns ValidationResult - The result of the validation.\n */`;\nassert(docString.includes('Validate the input against all the added rules.'));\nassert(docString.includes('@param input'));\nassert(docString.includes('@returns ValidationResult'));\nassert.strictEqual(result.isValid, false);\nassert.ok(result.errors.includes('Input must be at least 5 characters long'));\nassert.strictEqual(validResult.isValid, true);\nassert.strictEqual(validResult.errors.length, 0);\n", "DeepSeek-V3-0324_completion_0": "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "DeepSeek-V3-0324_completion_1": "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "DeepSeek-V3-0324_completion_2": "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "DeepSeek-V3-0324_completion_3": "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "DeepSeek-V3-0324_completion_4": "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "DeepSeek-V3-0324_completions": ["const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);", "const anotherValidResult = validator.validate('another valid input');\nassert.strictEqual(anotherValidResult.isValid, true);\nassert.strictEqual(anotherValidResult.errors.length, 0);"]}
{"id": "17", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a user profile.\n */\ninterface UserProfile {\n\tid: string;\n\tname: string;\n\temail: string;\n\tisActive: boolean;\n}\n\n", "suffix": "class UserManager {\n\tprivate users: UserProfile[] = [];\n\n\t/**\n\t * Add a new user to the manager.\n\t * @param user - The user profile to add.\n\t */\n\taddUser(user: UserProfile): void {\n\t\tthis.users.push(user);\n\t}\n\n\t/**\n\t * Get a user by their ID.\n\t * @param userId - The ID of the user to retrieve.\n\t * @returns The user profile if found, otherwise null.\n\t */\n\tgetUserById(userId: string): UserProfile | null {\n\t\treturn this.users.find(user => user.id === userId) || null;\n\t}\n\n\t/**\n\t * Update the active status of a user.\n\t * @param userId - The ID of the user to update.\n\t * @param isActive - The new active status of the user.\n\t */\n\tupdateUserStatus(userId: string, isActive: boolean): void {\n\t\tconst user = this.getUserById(userId);\n\t\tif (user) {\n\t\t\tuser.isActive = isActive;\n\t\t}\n\t}\n\n\t/**\n\t * Remove a user by their ID.\n\t * @param userId - The ID of the user to remove.\n\t */\n\tremoveUser(userId: string): void {\n\t\tthis.users = this.users.filter(user => user.id !== userId);\n\t}\n\n\t/**\n\t * Get all active users.\n\t * @returns An array of active user profiles.\n\t */\n\tgetActiveUsers(): UserProfile[] {\n\t\treturn this.users.filter(user => user.isActive);\n\t}\n}\n\nconst userManager = new UserManager();\n\n// Adding users to the manager\nuserManager.addUser({ id: '1', name: 'Alice', email: 'alice@example.com', isActive: true });\nuserManager.addUser({ id: '2', name: 'Bob', email: 'bob@example.com', isActive: false });\n\n// Retrieving a user\nconst alice = userManager.getUserById('1');\nassert(alice !== null);\nassert(alice?.name === 'Alice');\n\n// Updating user status\nuserManager.updateUserStatus('2', true);\nconst bob = userManager.getUserById('2');\nassert(bob !== null);\nassert(bob?.isActive);\n\n// Removing a user\nuserManager.removeUser('1');\nconst removedUser = userManager.getUserById('1');\nassert(removedUser === null);\n\n// Getting all active users\nconst activeUsers = userManager.getActiveUsers();\nassert(activeUsers.length === 1);\nassert(activeUsers[0].name === 'Bob');", "golden_completion": "/**\n * The UserManager class is responsible for managing user profiles. It provides methods to add, retrieve, update, and remove users, as well as to get all active users.\n *\n * Methods:\n * - addUser(user: UserProfile): void - Adds a new user to the manager.\n * - getUserById(userId: string): UserProfile | null - Retrieves a user by their ID.\n * - updateUserStatus(userId: string, isActive: boolean): void - Updates the active status of a user.\n * - removeUser(userId: string): void - Removes a user by their ID.\n * - getActiveUsers(): UserProfile[] - Gets all active users.\n *\n * Example Usage:\n * typescript\n * const userManager = new UserManager();\n * userManager.addUser({ id: '1', name: 'Alice', email: 'alice@example.com', isActive: true });\n * const alice = userManager.getUserById('1');\n * console.log(alice?.name); // Alice\n * userManager.updateUserStatus('2', true);\n * const bob = userManager.getUserById('2');\n * console.log(bob?.isActive); // true\n * \n */", "LLM_justification": "This test case is designed to evaluate an LLM's capability to generate comprehensive documentation for a class implementation, including method descriptions, parameter types, return values, and usage examples. The UserManager class encapsulates a realistic business scenario of managing user profiles, providing various methods with different complexities and interactions. This scenario ensures the LLM can understand and document not only simple methods but also those involving conditionals and array operations. Additionally, the assertions verify the correctness of the class methods, ensuring the documentation accurately reflects the implementation.", "assertions": "const docString = `/**\n * The UserManager class is responsible for managing user profiles. It provides methods to add, retrieve, update, and remove users, as well as to get all active users.\n *\n * Methods:\n * - addUser(user: UserProfile): void - Adds a new user to the manager.\n * - getUserById(userId: string): UserProfile | null - Retrieves a user by their ID.\n * - updateUserStatus(userId: string, isActive: boolean): void - Updates the active status of a user.\n * - removeUser(userId: string): void - Removes a user by their ID.\n * - getActiveUsers(): UserProfile[] - Gets all active users.\n *\n * Example Usage:\n * typescript\n * const userManager = new UserManager();\n * userManager.addUser({ id: '1', name: 'Alice', email: 'alice@example.com', isActive: true });\n * const alice = userManager.getUserById('1');\n * console.log(alice?.name); // Alice\n * userManager.updateUserStatus('2', true);\n * const bob = userManager.getUserById('2');\n * console.log(bob?.isActive); // true\n * \n */`;\n\nassert(docString.includes('The UserManager class is responsible for managing user profiles.'));\nassert(docString.includes('Methods:'));\nassert(docString.includes('addUser(user: UserProfile): void - Adds a new user to the manager.'));\nassert(docString.includes('getUserById(userId: string): UserProfile | null - Retrieves a user by their ID.'));\nassert(docString.includes('updateUserStatus(userId: string, isActive: boolean): void - Updates the active status of a user.'));\nassert(docString.includes('removeUser(userId: string): void - Removes a user by their ID.'));\nassert(docString.includes('getActiveUsers(): UserProfile[] - Gets all active users.'));\nassert(docString.includes('Example Usage:'));\nassert(docString.includes('const userManager = new UserManager();'));\nassert(docString.includes('console.log(alice?.name); // Alice'));\nassert(docString.includes('console.log(bob?.isActive); // true'));", "DeepSeek-V3-0324_completion_0": "class UserManager {", "DeepSeek-V3-0324_completion_1": "class UserManager {", "DeepSeek-V3-0324_completion_2": "class UserManager {", "DeepSeek-V3-0324_completion_3": "\t/**\n\t * A class to manage user profiles.\n\t */", "DeepSeek-V3-0324_completion_4": "class UserManager {", "DeepSeek-V3-0324_completions": ["class UserManager {", "class UserManager {", "class UserManager {", "\t/**\n\t * A class to manage user profiles.\n\t */", "class UserManager {"]}
{"id": "18", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface User {\n    id: string;\n    name: string;\n    role: string;\n}\n\ninterface Policy {\n    id: string;\n    name: string;\n    conditions: (user: User) => boolean;\n}\n\nconst policies: Policy[] = [\n    {\n        id: '1',\n        name: 'AdminAccess',\n        conditions: (user: User) => user.role === 'admin'\n    },\n    {\n        id: '2',\n        name: 'UserAccess',\n        conditions: (user: User) => user.role === 'user'\n    }\n];\n\n/**\n * Validates if a user complies with the provided policies.\n * @param user - The user to validate.\n * @param policies - The list of policies to check against.\n * @returns A list of policy names that the user complies with.\n */\nfunction validateUserCompliance(user: User, policies: Policy[]): string[] {\n    return policies.filter(policy => policy.conditions(user)).map(policy => policy.name);\n}\n\n// Example user\nconst exampleUser: User = {\n    id: '123',\n    name: 'Alice',\n    role: 'admin'\n};\n\n// Validate compliance for the example user\nconst complianceResults = validateUserCompliance(exampleUser, policies);\n\n// Assertions to verify the functionality\nassert.deepStrictEqual(complianceResults, ['AdminAccess']);\n\n// Another example user\nconst anotherUser: User = {\n    id: '456',\n    name: 'Bob',\n    role: 'user'\n};\n\n// Validate compliance for another user\nconst anotherComplianceResults = validateUserCompliance(anotherUser, policies);\n\n// Assertions to verify the functionality\nassert.deepStrictEqual(anotherComplianceResults, ['UserAccess']);\n\n/**\n * Handles the validation of user compliance with multiple policies.\n * @param users - The list of users to validate.\n * @param policies - The list of policies to check against.\n * @returns A map where the keys are user IDs and the values are arrays of policy names that each user complies with.\n */", "suffix": "\n\n// Example users list\nconst usersList: User[] = [\n    exampleUser,\n    anotherUser\n];\n\n// Validate compliance for multiple users\nconst multipleComplianceResults = validateMultipleUsersCompliance(usersList, policies);\n\n// Assertions to verify the functionality\nassert.deepStrictEqual(multipleComplianceResults, {\n    '123': ['AdminAccess'],\n    '456': ['UserAccess']\n});\n", "golden_completion": "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}\n\n", "LLM_justification": "This example provides a realistic scenario of validating user compliance with business policies, which involves complex business logic. The prefix sets up the context with TypeScript interfaces, example data, and a function for validating a single user. The golden completion and suffix extend this to handle multiple users, demonstrating both code-to-comment and comment-to-code translation. Assertions verify the correctness of the implementation and documentation accuracy, ensuring that the generated code meets the specified requirements.", "assertions": "assert.deepStrictEqual(complianceResults, ['AdminAccess']);\nassert.deepStrictEqual(anotherComplianceResults, ['UserAccess']);\nassert.deepStrictEqual(multipleComplianceResults, {\n    '123': ['AdminAccess'],\n    '456': ['UserAccess']\n});", "DeepSeek-V3-0324_completion_0": "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "DeepSeek-V3-0324_completion_1": "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "DeepSeek-V3-0324_completion_2": "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "DeepSeek-V3-0324_completion_3": "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "DeepSeek-V3-0324_completion_4": "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "DeepSeek-V3-0324_completions": ["function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}", "function validateMultipleUsersCompliance(users: User[], policies: Policy[]): Record<string, string[]> {\n    const result: Record<string, string[]> = {};\n    users.forEach(user => {\n        result[user.id] = validateUserCompliance(user, policies);\n    });\n    return result;\n}"]}
{"id": "19", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a User in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    role: string;\n}\n\n/**\n * Function to check if a user has admin privileges.\n * @param user - The user to check.\n * @returns True if the user has admin privileges, false otherwise.\n */\nfunction isAdmin(user: User): boolean {\n    return user.role === 'admin';\n}\n\n/**\n * Class representing a UserManager for handling user-related operations.\n */\nclass UserManager {\n    private users: User[];\n\n    constructor() {\n        this.users = [];\n    }\n\n    /**\n     * Adds a new user to the system.\n     * @param user - The user to add.\n     */\n    addUser(user: User): void {\n        this.users.push(user);\n    }\n\n    /**\n     * Gets a user by their ID.\n     * @param id - The ID of the user to retrieve.\n     * @returns The user with the specified ID, or undefined if not found.\n     */\n    getUserById(id: number): User | undefined {\n        return this.users.find(user => user.id === id);\n    }\n\n    /**\n     * Removes a user by their ID.\n     * @param id - The ID of the user to remove.\n     * @returns True if the user was successfully removed, false otherwise.\n     */\n    removeUser(id: number): boolean {\n        const userIndex = this.users.findIndex(user => user.id === id);\n        if (userIndex !== -1) {\n            this.users.splice(userIndex, 1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Lists all users in the system.\n     * @returns An array of all users.\n     */\n    listUsers(): User[] {\n        return this.users;\n    }\n\n    /**\n     * Checks if a user with a specific email exists.\n     * @param email - The email to check.\n     * @returns True if a user with the email exists, false otherwise.\n     */\n    userExists(email: string): boolean {\n        return this.users.some(user => user.email === email);\n    }\n\n    /**\n     * Updates the email of a user.\n     * @param id - The ID of the user to update.\n     * @param newEmail - The new email to set.\n     * @returns True if the email was successfully updated, false otherwise.\n     */\n", "suffix": "updateUserEmail(id: number, newEmail: string): boolean {\n    const user = this.getUserById(id);\n    if (user) {\n        user.email = newEmail;\n        return true;\n    }\n    return false;\n}\n}\n\n// Example usage\nconst userManager = new UserManager();\nuserManager.addUser({ id: 1, name: 'John Doe', email: 'john@example.com', role: 'user' });\nuserManager.addUser({ id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'admin' });\n\nassert.strictEqual(userManager.userExists('john@example.com'), true);\nassert.strictEqual(userManager.userExists('nonexistent@example.com'), false);\nassert.strictEqual(userManager.updateUserEmail(1, 'newjohn@example.com'), true);\nassert.strictEqual(userManager.getUserById(1)?.email, 'newjohn@example.com');\nassert.strictEqual(userManager.updateUserEmail(3, 'nonexistent@example.com'), false);\n", "golden_completion": "/**\n * Updates the email of a user.\n * @param id - The ID of the user to update.\n * @param newEmail - The new email to set.\n * @returns True if the email was successfully updated, false otherwise.\n */\n", "LLM_justification": "This test case is a good example because it involves realistic business logic related to user management, including adding, retrieving, updating, and removing users. The code-to-comment translation tests the model's ability to document a method for updating a user's email, while the comment-to-code translation tests the model's ability to implement the described functionality. The assertions verify that the user management operations work as expected, including edge cases such as attempting to update a non-existent user.", "assertions": "assert.strictEqual(userManager.updateUserEmail(1, 'newjohn@example.com'), true);\nassert.strictEqual(userManager.getUserById(1)?.email, 'newjohn@example.com');\nassert.strictEqual(userManager.updateUserEmail(3, 'nonexistent@example.com'), false);", "DeepSeek-V3-0324_completion_0": "    function updateUserEmail(id: number, newEmail: string): boolean {\n        const user = this.getUserById(id);\n        if (user) {\n            user.email = newEmail;\n            return true;\n        }\n        return false;\n    }", "DeepSeek-V3-0324_completion_1": "\n    function ", "DeepSeek-V3-0324_completion_2": "    function ", "DeepSeek-V3-0324_completion_3": "    function ", "DeepSeek-V3-0324_completion_4": "\n    function ", "DeepSeek-V3-0324_completions": ["    function updateUserEmail(id: number, newEmail: string): boolean {\n        const user = this.getUserById(id);\n        if (user) {\n            user.email = newEmail;\n            return true;\n        }\n        return false;\n    }", "\n    function ", "    function ", "    function ", "\n    function "]}
{"id": "20", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n", "suffix": "class Task {\n    id: string;\n    name: string;\n    completed: boolean;\n\n    constructor(id: string, name: string) {\n        this.id = id;\n        this.name = name;\n        this.completed = false;\n    }\n\n    /**\n     * Marks the task as completed.\n     */\n    complete() {\n        this.completed = true;\n    }\n}\n\n/**\n * A class representing a Workflow which orchestrates multiple tasks.\n */\nclass Workflow {\n    tasks: Task[];\n\n    constructor() {\n        this.tasks = [];\n    }\n\n    /**\n     * Adds a new task to the workflow.\n     * @param {string} id - The unique identifier for the task.\n     * @param {string} name - The name of the task.\n     */\n    addTask(id: string, name: string) {\n        const task = new Task(id, name);\n        this.tasks.push(task);\n    }\n\n    /**\n     * Marks a task as completed by its ID.\n     * @param {string} taskId - The unique identifier of the task to complete.\n     */\n    completeTask(taskId: string) {\n        const task = this.tasks.find(t => t.id === taskId);\n        if (task) {\n            task.complete();\n        } else {\n            throw new Error(`Task with id ${taskId} not found`);\n        }\n    }\n\n    /**\n     * Checks if all tasks in the workflow are completed.\n     * @returns {boolean} - True if all tasks are completed, false otherwise.\n     */\n    allTasksCompleted(): boolean {\n        return this.tasks.every(task => task.completed);\n    }\n}\n\n/**\n * Example usage of the Workflow class.\n */\nconst workflow = new Workflow();\nworkflow.addTask('1', 'Task 1');\nworkflow.addTask('2', 'Task 2');\nworkflow.completeTask('1');\nassert(workflow.allTasksCompleted() === false);\nworkflow.completeTask('2');\nassert(workflow.allTasksCompleted() === true);\n\n/**\n * Function to validate the workflow based on a specific rule:\n * All tasks must be completed within a certain timeframe.\n * @param {Workflow} workflow - The workflow to validate.\n * @param {number} timeframe - The maximum allowed time in milliseconds.\n * @returns {boolean} - True if the workflow meets the rule, false otherwise.\n */\nfunction validateWorkflow(workflow: Workflow, timeframe: number): boolean {\n    // Mock implementation for the sake of example\n    return workflow.allTasksCompleted();\n}\n\nassert(validateWorkflow(workflow, 1000) === true);\n", "golden_completion": "/**\n * A class representing a Task in a workflow system.\n * \n * @class Task\n * @property {string} id - The unique identifier for the task.\n * @property {string} name - The name of the task.\n * @property {boolean} completed - The completion status of the task.\n */\n\n", "LLM_justification": "This test case is an excellent example of translating between code and natural language because it involves defining and documenting two complex classes (Task and Workflow) that interact with each other. The provided code includes realistic business logic related to task management within a workflow, which is a common use case in many software applications. The golden completion focuses on generating comprehensive TSDoc comments for the classes, explaining their properties and methods, which is essential for understanding and maintaining the code. The assertions verify the correct functionality of the workflow, ensuring that tasks can be added, completed, and checked for completion status. This scenario tests the LLM's ability to generate detailed and accurate documentation for given code, ensuring that all key concepts and relationships are covered.", "assertions": "const taskDocString = `/**\n * A class representing a Task in a workflow system.\n * \n * @class Task\n * @property {string} id - The unique identifier for the task.\n * @property {string} name - The name of the task.\n * @property {boolean} completed - The completion status of the task.\n */`;\nconst workflowDocString = `/**\n * A class representing a Workflow which orchestrates multiple tasks.\n * \n * @class Workflow\n * @property {Task[]} tasks - The list of tasks in the workflow.\n */`;\nassert(taskDocString.includes('A class representing a Task in a workflow system'));\nassert(taskDocString.includes('@property {string} id'));\nassert(taskDocString.includes('@property {string} name'));\nassert(taskDocString.includes('@property {boolean} completed'));\nassert(workflowDocString.includes('A class representing a Workflow which orchestrates multiple tasks'));\nassert(workflowDocString.includes('@property {Task[]} tasks'));\n", "DeepSeek-V3-0324_completion_0": "import assert from 'assert';", "DeepSeek-V3-0324_completion_1": "import assert from 'assert';", "DeepSeek-V3-0324_completion_2": "import assert } from 'assert';", "DeepSeek-V3-0324_completion_3": "import assert from 'assert';", "DeepSeek-V3-0324_completion_4": "import assert from 'assert';", "DeepSeek-V3-0324_completions": ["import assert from 'assert';", "import assert from 'assert';", "import assert } from 'assert';", "import assert from 'assert';", "import assert from 'assert';"]}
{"id": "21", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a business entity\n */\ninterface BusinessEntity {\n    id: number;\n    name: string;\n    isActive: boolean;\n}\n\n/**\n * Function to validate business rules\n *\n * @param entity - The business entity to validate\n * @returns True if the entity is valid, otherwise false\n */\nfunction validateEntity(entity: BusinessEntity): boolean {\n    if (!entity.name || entity.name.length === 0) {\n        return false;\n    }\n    if (typeof entity.isActive !== 'boolean') {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Function to activate an entity\n *\n * @param entity - The business entity to activate\n * @returns The activated business entity\n */\nfunction activateEntity(entity: BusinessEntity): BusinessEntity {\n    if (validateEntity(entity)) {\n        entity.isActive = true;\n        return entity;\n    }\n    throw new Error('Invalid entity');\n}\n\n/**\n * Function to deactivate an entity\n *\n * @param entity - The business entity to deactivate\n * @returns The deactivated business entity\n */\nfunction deactivateEntity(entity: BusinessEntity): BusinessEntity {\n    if (validateEntity(entity)) {\n        entity.isActive = false;\n        return entity;\n    }\n    throw new Error('Invalid entity');\n}\n\nconst entity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nconst invalidEntity: BusinessEntity = { id: 2, name: '', isActive: true };\n", "suffix": "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);\n", "golden_completion": "/**\n * Function to toggle the activation state of an entity\n *\n * @param entity - The business entity to toggle\n * @returns The toggled business entity\n */\nfunction toggleEntityActivation(entity: BusinessEntity): BusinessEntity {\n    if (validateEntity(entity)) {\n        entity.isActive = !entity.isActive;\n        return entity;\n    }\n    throw new Error('Invalid entity');\n}\n\n// Example usage\nconst toggledEntity = toggleEntityActivation(entity);\nassert(toggledEntity.isActive === true);\n", "LLM_justification": "This test case is a good example because it involves complex business logic related to validating and toggling the state of a business entity. It requires understanding of TypeScript types and interfaces, as well as implementing error handling. The documentation is comprehensive, explaining the function's purpose, parameters, and return value, which helps test the LLM's ability to generate clear and accurate documentation. Additionally, the assertions verify functional correctness and error handling, ensuring the implementation meets the requirements.", "assertions": "const testEntityForAssertions: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nconst toggledEntityTest = toggleEntityActivation(testEntityForAssertions);\nassert(toggledEntityTest.isActive);\nassert(testEntityForAssertions.isActive);\ntry {\n    toggleEntityActivation(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\n", "DeepSeek-V3-0324_completion_0": "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "DeepSeek-V3-0324_completion_1": "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "DeepSeek-V3-0324_completion_2": "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "DeepSeek-V3-0324_completion_3": "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "DeepSeek-V3-0324_completion_4": "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "DeepSeek-V3-0324_completions": ["const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);", "const testEntity: BusinessEntity = { id: 1, name: 'Test Entity', isActive: false };\nassert(testEntity.isActive === false);\nconst activatedEntity = activateEntity(testEntity);\nassert(activatedEntity.isActive === true);\ntry {\n    activateEntity(invalidEntity);\n} catch (error) {\n    assert(error instanceof Error);\n    assert(error.message === 'Invalid entity');\n}\nconst deactivatedEntity = deactivateEntity(activatedEntity);\nassert(deactivatedEntity.isActive === false);"]}
{"id": "22", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a User in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    role: 'admin' | 'user';\n}\n\n/**\n * Interface for policy validation rules.\n */\ninterface Policy {\n    validate: (user: User) => boolean;\n}\n\n/**\n * Policy that ensures only admins can perform certain actions.\n */\nclass AdminPolicy implements Policy {\n    validate(user: User): boolean {\n        return user.role === 'admin';\n    }\n}\n\n/**\n * Policy that ensures the user's email is verified.\n */\nclass EmailVerifiedPolicy implements Policy {\n    validate(user: User): boolean {\n        return user.email.includes('@');\n    }\n}\n\n/**\n * PolicyValidator orchestrates multiple policy checks.\n */\nclass PolicyValidator {\n    private policies: Policy[];\n\n    constructor(policies: Policy[]) {\n        this.policies = policies;\n    }\n\n    /**\n     * Validates a user against all configured policies.\n     * @param user - The user to be validated\n     * @returns true if the user passes all policies, false otherwise\n     */\n    validate(user: User): boolean {\n        for (const policy of this.policies) {\n            if (!policy.validate(user)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// Example user objects\nconst adminUser: User = { id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' };\nconst regularUser: User = { id: 2, name: 'Bob', email: 'bob@domain.com', role: 'user' };\nconst invalidUser: User = { id: 3, name: 'Charlie', email: 'charlie', role: 'user' };\n\n// Initialize policies\nconst policies: Policy[] = [new AdminPolicy(), new EmailVerifiedPolicy()];\n\n// Create PolicyValidator instance\nconst policyValidator = new PolicyValidator(policies);\n\n// Validate users\n", "suffix": "// Assertions\nassert.strictEqual(policyValidator.validate(invalidUser), false, 'User with invalid email should fail the email policy');\n\nconsole.log('All assertions passed');", "golden_completion": "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');\n", "LLM_justification": "This test case is designed to assess the ability of a language model to translate between TypeScript code and natural language documentation. The scenario involves validating user objects against multiple policy rules, which is a common business logic requirement. The example includes detailed TSDoc comments and a comprehensive implementation that tests both code-to-comment and comment-to-code translation capabilities. The assertions ensure the functional correctness of the implementation and verify that the documentation accurately describes the code's behavior.", "assertions": "const docString = `/**\n * Interface representing a User in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    role: 'admin' | 'user';\n}\n\n/**\n * Interface for policy validation rules.\n */\ninterface Policy {\n    validate: (user: User) => boolean;\n}\n\n/**\n * Policy that ensures only admins can perform certain actions.\n */\nclass AdminPolicy implements Policy {\n    validate(user: User): boolean {\n        return user.role === 'admin';\n    }\n}\n\n/**\n * Policy that ensures the user's email is verified.\n */\nclass EmailVerifiedPolicy implements Policy {\n    validate(user: User): boolean {\n        return user.email.includes('@');\n    }\n}\n\n/**\n * PolicyValidator orchestrates multiple policy checks.\n */\nclass PolicyValidator {\n    private policies: Policy[];\n\n    constructor(policies: Policy[]) {\n        this.policies = policies;\n    }\n\n    /**\n     * Validates a user against all configured policies.\n     * @param user - The user to be validated\n     * @returns true if the user passes all policies, false otherwise\n     */\n    validate(user: User): boolean {\n        for (const policy of this.policies) {\n            if (!policy.validate(user)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// Example user objects\nconst adminUser: User = { id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' };\nconst regularUser: User = { id: 2, name: 'Bob', email: 'bob@domain.com', role: 'user' };\nconst invalidUser: User = { id: 3, name: 'Charlie', email: 'charlie', role: 'user' };\n\n// Initialize policies\nconst policies: Policy[] = [new AdminPolicy(), new EmailVerifiedPolicy()];\n\n// Create PolicyValidator instance\nconst policyValidator = new PolicyValidator(policies);\n\n// Validate users\nassert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');\nassert.strictEqual(policyValidator.validate(invalidUser), false, 'User with invalid email should fail the email policy');\n\nconsole.log('All assertions passed');`;\nassert(docString.includes('Interface representing a User in the system.'));\nassert(docString.includes('Interface for policy validation rules.'));\nassert(docString.includes('Policy that ensures only admins can perform certain actions.'));\nassert(docString.includes('Policy that ensures the user\\'s email is verified.'));\nassert(docString.includes('PolicyValidator orchestrates multiple policy checks.'));\nassert(docString.includes('@param user - The user to be validated'));\nassert(docString.includes('@returns true if the user passes all policies, false otherwise'));\nassert(docString.includes('Admin user should pass all policies'));\nassert(docString.includes('Regular user should fail the admin policy'));\nassert(docString.includes('User with invalid email should fail the email policy'));\nassert(docString.includes('All assertions passed'));\n\nconsole.log('Documentation assertions passed');", "DeepSeek-V3-0324_completion_0": "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "DeepSeek-V3-0324_completion_1": "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "DeepSeek-V3-0324_completion_2": "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "DeepSeek-V3-0324_completion_3": "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "DeepSeek-V3-0324_completion_4": "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "DeepSeek-V3-0324_completions": ["assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');", "assert.strictEqual(policyValidator.validate(adminUser), true, 'Admin user should pass all policies');\nassert.strictEqual(policyValidator.validate(regularUser), false, 'Regular user should fail the admin policy');"]}
{"id": "23", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  isActive: boolean;\n}\n\ninterface Policy {\n  id: number;\n  name: string;\n  description: string;\n  isActive: boolean;\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\n/**\n * Validates a user against a set of policies.\n * @param user - The user to validate.\n * @param policies - The policies to validate against.\n * @returns A validation result containing a boolean indicating if the user passed all policies and an array of error messages.\n */\nfunction validateUser(user: User, policies: Policy[]): ValidationResult {\n  const errors: string[] = [];\n  for (const policy of policies) {\n    if (!policy.isActive) continue;\n    if (policy.name === 'Active User' && !user.isActive) {\n      errors.push('User is not active');\n    }\n    if (policy.name === 'Valid Email' && !user.email.includes('@')) {\n      errors.push('User email is invalid');\n    }\n  }\n  return { valid: errors.length === 0, errors };\n}\n\nconst user: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com', isActive: true };\nconst policies: Policy[] = [\n  { id: 1, name: 'Active User', description: 'User must be active', isActive: true },\n  { id: 2, name: 'Valid Email', description: 'User must have a valid email', isActive: true }\n];\n\nconst validationResult = validateUser(user, policies);\nassert(validationResult.valid);\nassert(validationResult.errors.length === 0);\n\n// Additional complex business rule: User must have a unique email\n/**\n * Validates that the user's email is unique in the system.\n * @param user - The user to validate.\n * @param existingUsers - The list of existing users in the system.\n * @returns A validation result containing a boolean indicating if the user's email is unique and an array of error messages.\n */", "suffix": "\nconst existingUsers: User[] = [\n  { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com', isActive: true },\n  { id: 3, name: 'Alice Johnson', email: 'alice.johnson@example.com', isActive: false }\n];\n\nconst uniqueEmailValidationResult = validateUniqueEmail(user, existingUsers);\nassert(uniqueEmailValidationResult.valid);\nassert(uniqueEmailValidationResult.errors.length === 0);\n\n// Clean up resources if any\n", "golden_completion": "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  const emailExists = existingUsers.some(existingUser => existingUser.email === user.email);\n  if (emailExists) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}\n\n", "LLM_justification": "This test case demonstrates the bidirectional translation between TypeScript code and detailed comments. The prefix provides a comprehensive setup with interfaces, an initial validation function, and test assertions. The golden completion requires implementing a new validation function based on a given comment, testing the model's ability to translate comments into code. The suffix includes further assertions and resource cleanup. This scenario tests complex business rules validation and ensures the model can handle detailed TypeScript documentation and implementation.", "assertions": "const docString = `/**\n * Validates that the user's email is unique in the system.\n * @param user - The user to validate.\n * @param existingUsers - The list of existing users in the system.\n * @returns A validation result containing a boolean indicating if the user's email is unique and an array of error messages.\n */`;\nassert(docString.toLowerCase().includes('validates that the user\\'s email is unique'));\nassert(docString.includes('@param user'));\nassert(docString.includes('user - The user to validate'));\nassert(docString.includes('validation result'));\nassert(docString.includes('boolean indicating if the user\\'s email is unique'));\n\nconst existingUsersCopy: User[] = [\n  { id: 2, name: 'Jane Smith', email: 'jane.smith@example.com', isActive: true },\n  { id: 3, name: 'Alice Johnson', email: 'alice.johnson@example.com', isActive: false }\n];\nconst uniqueEmailValidationResult2 = validateUniqueEmail(user, existingUsersCopy);\nassert(uniqueEmailValidationResult2.valid);\nassert(uniqueEmailValidationResult2.errors.length === 0);\n", "DeepSeek-V3-0324_completion_0": "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "DeepSeek-V3-0324_completion_1": "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "DeepSeek-V3-0324_completion_2": "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "DeepSeek-V3-0324_completion_3": "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "DeepSeek-V3-0324_completion_4": "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "DeepSeek-V3-0324_completions": ["function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}", "function validateUniqueEmail(user: User, existingUsers: User[]): ValidationResult {\n  const errors: string[] = [];\n  if (existingUsers.some(existingUser => existingUser.email === user.email)) {\n    errors.push('User email must be unique');\n  }\n  return { valid: errors.length === 0, errors };\n}"]}
{"id": "24", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a business policy.\n */\ninterface Policy {\n    id: string;\n    name: string;\n    isActive: boolean;\n    conditions: Condition[];\n}\n\n/**\n * Interface representing a condition within a policy.\n */\ninterface Condition {\n    field: string;\n    operator: 'equals' | 'notEquals' | 'greaterThan' | 'lessThan';\n    value: any;\n}\n\n/**\n * Function to evaluate a single condition.\n * @param condition The condition to evaluate.\n * @param data The data to evaluate the condition against.\n * @returns True if the condition is met, false otherwise.\n */\nfunction evaluateCondition(condition: Condition, data: any): boolean {\n    switch (condition.operator) {\n        case 'equals':\n            return data[condition.field] === condition.value;\n        case 'notEquals':\n            return data[condition.field] !== condition.value;\n        case 'greaterThan':\n            return data[condition.field] > condition.value;\n        case 'lessThan':\n            return data[condition.field] < condition.value;\n        default:\n            throw new Error(`Unsupported operator: ${condition.operator}`);\n    }\n}\n\n/**\n * Function to evaluate all conditions within a policy.\n * @param policy The policy whose conditions should be evaluated.\n * @param data The data to evaluate the conditions against.\n * @returns True if all conditions are met, false otherwise.\n */\nfunction evaluatePolicy(policy: Policy, data: any): boolean {\n    for (const condition of policy.conditions) {\n        if (!evaluateCondition(condition, data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n", "suffix": "\nfunction validatePolicies(policies: Policy[], data: any): string[] {\n    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;\n}\n\n// Example policies and data for testing\nconst policies: Policy[] = [\n    {\n        id: '1',\n        name: 'Age Policy',\n        isActive: true,\n        conditions: [\n            { field: 'age', operator: 'greaterThan', value: 18 }\n        ]\n    },\n    {\n        id: '2',\n        name: 'Region Policy',\n        isActive: true,\n        conditions: [\n            { field: 'region', operator: 'equals', value: 'US' }\n        ]\n    }\n];\n\nconst data = { age: 20, region: 'US' };\n\nconst nonCompliant = validatePolicies(policies, data);\n\nassert.deepStrictEqual(nonCompliant, []);\n\nconst invalidData = { age: 17, region: 'EU' };\nconst nonCompliantInvalid = validatePolicies(policies, invalidData);\nassert.deepStrictEqual(nonCompliantInvalid, ['1', '2']);\n\nconsole.log('All assertions passed.');", "golden_completion": "/**\n * The validatePolicies function iterates over a list of policies and evaluates each policy against provided data.\n * It returns a list of policy IDs that are not compliant.\n * \n * @param policies - Array of Policy objects to validate.\n * @param data - The data to validate the policies against.\n * \n * @returns An array of strings representing the IDs of non-compliant policies.\n * \n * Example:\n * typescript\n * const policies: Policy[] = [\n *   { id: '1', name: 'Age Policy', isActive: true, conditions: [{ field: 'age', operator: 'greaterThan', value: 18 }] },\n *   { id: '2', name: 'Region Policy', isActive: true, conditions: [{ field: 'region', operator: 'equals', value: 'US' }] }\n * ];\n * const data = { age: 20, region: 'US' };\n * const nonCompliant = validatePolicies(policies, data);\n * console.log(nonCompliant); // []\n * \n */", "LLM_justification": "This test case provides a realistic scenario of validating business policies based on provided data. It demonstrates complex logic involving policy and condition evaluation, which requires clear documentation for understanding. The golden_completion focuses on generating comprehensive documentation for a function that validates policies, ensuring that the LLM can translate intricate TypeScript code into detailed natural language descriptions. Assertions verify the correctness of both compliant and non-compliant policy evaluations, making this a robust test case for bidirectional translation between code and natural language.", "assertions": "const docString = `/**\n * The validatePolicies function iterates over a list of policies and evaluates each policy against provided data.\n * It returns a list of policy IDs that are not compliant.\n * \n * @param policies - Array of Policy objects to validate.\n * @param data - The data to validate the policies against.\n * \n * @returns An array of strings representing the IDs of non-compliant policies.\n * \n * Example:\n * typescript\n * const policies: Policy[] = [\n *   { id: '1', name: 'Age Policy', isActive: true, conditions: [{ field: 'age', operator: 'greaterThan', value: 18 }] },\n *   { id: '2', name: 'Region Policy', isActive: true, conditions: [{ field: 'region', operator: 'equals', value: 'US' }] }\n * ];\n * const data = { age: 20, region: 'US' };\n * const nonCompliant = validatePolicies(policies, data);\n * console.log(nonCompliant); // []\n * \n */`\nassert(docString.includes('The validatePolicies function iterates over a list of policies and evaluates each policy against provided data.'));\nassert(docString.includes('@param policies - Array of Policy objects to validate.'));\nassert(docString.includes('@param data - The data to validate the policies against.'));\nassert(docString.includes('@returns An array of strings representing the IDs of non-compliant policies.'));\nassert(docString.includes('Example:'));\nassert(docString.includes('const policies: Policy[] = ['));", "DeepSeek-V3-0324_completion_0": "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "DeepSeek-V3-0324_completion_1": "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "DeepSeek-V3-0324_completion_2": "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "DeepSeek-V3-0324_completion_3": "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "DeepSeek-V3-0324_completion_4": "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "DeepSeek-V3-0324_completions": ["    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;", "    const nonCompliantPolicies: string[] = [];\n    for (const policy of policies) {\n        if (!policy.isActive) {\n            continue;\n        }\n        if (!evaluatePolicy(policy, data)) {\n            nonCompliantPolicies.push(policy.id);\n        }\n    }\n    return nonCompliantPolicies;"]}
{"id": "25", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a business entity for a Customer.\n */\ninterface Customer {\n    id: string;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n/**\n * Enum representing different compliance statuses.\n */\nenum ComplianceStatus {\n    Compliant = 'Compliant',\n    NonCompliant = 'NonCompliant',\n    Unknown = 'Unknown'\n}\n\n/**\n * Function to check customer compliance based on their email domain.\n * @param customer - The customer to check compliance for.\n * @returns {ComplianceStatus} - The compliance status of the customer.\n */\nfunction checkCompliance(customer: Customer): ComplianceStatus {\n    const allowedDomains = ['example.com', 'company.com'];\n    const emailDomain = customer.email.split('@')[1];\n    if (allowedDomains.includes(emailDomain)) {\n        return ComplianceStatus.Compliant;\n    } else {\n        return ComplianceStatus.NonCompliant;\n    }\n}\n\n/**\n * Class representing a service to manage customers.\n */\nclass CustomerService {\n    private customers: Customer[] = [];\n\n    /**\n     * Add a new customer to the service.\n     * @param customer - The customer to add.\n     */\n    addCustomer(customer: Customer): void {\n        this.customers.push(customer);\n    }\n\n    /**\n     * Retrieve all active customers.\n     * @returns {Customer[]} - List of active customers.\n     */\n    getActiveCustomers(): Customer[] {\n        return this.customers.filter(customer => customer.isActive);\n    }\n\n    /**\n     * Check compliance for all active customers.\n     * @returns {Record<string, ComplianceStatus>} - Compliance status for each active customer.\n     */\n    checkComplianceForActiveCustomers(): Record<string, ComplianceStatus> {\n        const complianceStatus: Record<string, ComplianceStatus> = {};\n        const activeCustomers = this.getActiveCustomers();\n        activeCustomers.forEach(customer => {\n            complianceStatus[customer.id] = checkCompliance(customer);\n        });\n        return complianceStatus;\n    }\n}\n\n// Example usage\nconst customerService = new CustomerService();\nconst customer1: Customer = { id: '1', name: 'John Doe', email: 'john.doe@example.com', isActive: true };\nconst customer2: Customer = { id: '2', name: 'Jane Smith', email: 'jane.smith@unknown.com', isActive: true };\ncustomerService.addCustomer(customer1);\ncustomerService.addCustomer(customer2);\n", "suffix": "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);\n\n// Clean up resources (none required in this example)\n", "golden_completion": "/**\n * Retrieves compliance status for all active customers in the service.\n * Uses the checkCompliance function to determine compliance based on the customer's email domain.\n * @returns {Record<string, ComplianceStatus>} - A record where the key is the customer ID and the value is the compliance status.\n */\nfunction getComplianceStatusForActiveCustomers(): Record<string, ComplianceStatus> {\n    const activeCustomers = this.getActiveCustomers();\n    const complianceStatus: Record<string, ComplianceStatus> = {};\n    activeCustomers.forEach(customer => {\n        complianceStatus[customer.id] = checkCompliance(customer);\n    });\n    return complianceStatus;\n}\n", "LLM_justification": "This test case covers both code-to-comment and comment-to-code translation. The prefix establishes a detailed context with TypeScript interfaces, enums, functions, and a class, including various methods and their implementations. The golden_completion involves generating comprehensive documentation for a new method, ensuring that the LLM can accurately describe the method's functionality, parameters, and return values. The suffix contains assertions that verify the correctness of the implementation and documentation. This scenario demonstrates realistic business logic, compliance checking, and proper use of TypeScript's type system, making it a good test case for evaluating an LLM's translation capabilities.", "assertions": "const docString = `/**\n * Retrieves compliance status for all active customers in the service.\n * Uses the checkCompliance function to determine compliance based on the customer's email domain.\n * @returns {Record<string, ComplianceStatus>} - A record where the key is the customer ID and the value is the compliance status.\n */`;\nassert(docString.includes('Retrieves compliance status for all active customers'));\nassert(docString.includes('Uses the checkCompliance function'));\nassert(docString.includes('@returns'));\nassert(docString.includes('Record<string, ComplianceStatus>'));\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);\n", "DeepSeek-V3-0324_completion_0": "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "DeepSeek-V3-0324_completion_1": "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "DeepSeek-V3-0324_completion_2": "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "DeepSeek-V3-0324_completion_3": "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "DeepSeek-V3-0324_completion_4": "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "DeepSeek-V3-0324_completions": ["const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);", "const complianceResults = customerService.checkComplianceForActiveCustomers();\nassert.strictEqual(complianceResults['1'], ComplianceStatus.Compliant);\nassert.strictEqual(complianceResults['2'], ComplianceStatus.NonCompliant);"]}
{"id": "26", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'node:assert';\n\n/**\n * Interface representing a user in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    role: 'admin' | 'user';\n}\n\n/**\n * Function to validate if a given user has admin privileges.\n * @param user - The user object to check.\n * @returns True if the user is an admin, false otherwise.\n */\nfunction isAdmin(user: User): boolean {\n    return user.role === 'admin';\n}\n\n/**\n * Class representing a simple in-memory user store.\n */\nclass UserStore {\n    private users: User[] = [];\n\n    /**\n     * Adds a new user to the store.\n     * @param user - The user object to add.\n     */\n    addUser(user: User): void {\n        this.users.push(user);\n    }\n\n    /**\n     * Retrieves a user by their ID.\n     * @param id - The ID of the user to retrieve.\n     * @returns The user object if found, undefined otherwise.\n     */\n    getUserById(id: number): User | undefined {\n        return this.users.find(user => user.id === id);\n    }\n\n    /**\n     * Validates if the user with the given ID has admin privileges.\n     * @param id - The ID of the user to check.\n     * @returns True if the user is an admin, false otherwise.\n     */\n    isUserAdmin(id: number): boolean {\n        const user = this.getUserById(id);\n        return user ? isAdmin(user) : false;\n    }\n}\n\n// Example usage\nconst userStore = new UserStore();\nuserStore.addUser({ id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' });\nuserStore.addUser({ id: 2, name: 'Bob', email: 'bob@example.com', role: 'user' });\n\n", "suffix": "\n// Clean up resources\n// No resources to clean up in this example\n", "golden_completion": "/**\n * Validates if the user with the given ID has admin privileges.\n * @param id - The ID of the user to check.\n * @returns True if the user is an admin, false otherwise.\n */\nUserStore.prototype.isUserAdmin = function(id: number): boolean {\n    const user = this.getUserById(id);\n    return user ? isAdmin(user) : false;\n};\n\n// Assertions\nassert.strictEqual(userStore.isUserAdmin(1), true, 'User with ID 1 should be an admin');\nassert.strictEqual(userStore.isUserAdmin(2), false, 'User with ID 2 should not be an admin');\nassert.strictEqual(userStore.isUserAdmin(3), false, 'User with ID 3 should not exist and return false');\n", "LLM_justification": "This test case effectively evaluates the LLM's ability to translate between code and natural language by providing a realistic business scenario. The example involves user role validation and demonstrates a clear relationship between TypeScript code and documentation. The golden_completion includes detailed TSDoc comments for the 'isUserAdmin' method, while the prefix and suffix provide extensive context and assertions to verify the correctness of the implementation.", "assertions": "assert.strictEqual(userStore.isUserAdmin(1), true, 'User with ID 1 should be an admin');\nassert.strictEqual(userStore.isUserAdmin(2), false, 'User with ID 2 should not be an admin');\nassert.strictEqual(userStore.isUserAdmin(3), false, 'User with ID 3 should not exist and return false');", "DeepSeek-V3-0324_completion_0": "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "DeepSeek-V3-0324_completion_1": "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "DeepSeek-V3-0324_completion_2": "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "DeepSeek-V3-0324_completion_3": "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "DeepSeek-V3-0324_completion_4": "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "DeepSeek-V3-0324_completions": ["assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);", "assert.strictEqual(userStore.isUserAdmin(1), true);\nassert.strictEqual(userStore.isUserAdmin(2), false);"]}
{"id": "27", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Represents a user in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n", "suffix": "function validateUserCompliance(user: User): boolean {\n    // User must have a valid email\n    const emailRegex = /^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/;\n    if (!emailRegex.test(user.email)) {\n        return false;\n    }\n\n    // User must be active\n    if (!user.isActive) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Example usage of validateUserCompliance function.\n */\nfunction exampleUsage() {\n    const user: User = {\n        id: 1,\n        name: 'John Doe',\n        email: 'john.doe@example.com',\n        isActive: true\n    };\n\n    const isCompliant = validateUserCompliance(user);\n    console.log(`Is user compliant? ${isCompliant}`);\n}\n\nexampleUsage();\n\n/**\n * Asserts that the validateUserCompliance function works correctly.\n */\nfunction testValidateUserCompliance() {\n    const compliantUser: User = {\n        id: 2,\n        name: 'Jane Smith',\n        email: 'jane.smith@example.com',\n        isActive: true\n    };\n    const nonCompliantUser: User = {\n        id: 3,\n        name: 'Bob Brown',\n        email: 'bob.brown@example',\n        isActive: false\n    };\n\n    assert.strictEqual(validateUserCompliance(compliantUser), true, 'Compliant user should be valid');\n    assert.strictEqual(validateUserCompliance(nonCompliantUser), false, 'Non-compliant user should be invalid');\n}\n\ntestValidateUserCompliance();\nfunction cleanupResources() {\n    console.log('Cleanup resources if any');\n}\n\ncleanupResources();", "golden_completion": "/**\n * Validates if the given user meets the compliance requirements.\n *\n * This function performs several checks to ensure that the user is compliant with the business rules:\n * 1. The user must have a valid email address.\n * 2. The user must be marked as active.\n *\n * @param user - The user object to validate. The user object must contain the following properties:\n * - id: A unique identifier for the user (number).\n * - name: The name of the user (string).\n * - email: The email address of the user (string).\n * - isActive: Indicates whether the user is active (boolean).\n * @returns True if the user is compliant, otherwise false.\n *\n * @throws Will throw an error if the user object does not have the required properties.\n */\n", "LLM_justification": "This test case is a good example for bidirectional translation between code and natural language because it includes detailed TypeScript code for validating business rules on user objects, and requires comprehensive documentation of the function. The prefix establishes the context and the function implementation, while the golden_completion requires generating detailed documentation that explains the function, its parameters, return values, and error handling. The suffix provides additional code that does not repeat the golden_completion, maintaining a clear distinction. The assertions test the functional requirements and the completeness of the documentation.", "assertions": "const docString = `/**\n * Validates if the given user meets the compliance requirements.\n *\n * This function performs several checks to ensure that the user is compliant with the business rules:\n * 1. The user must have a valid email address.\n * 2. The user must be marked as active.\n *\n * @param user - The user object to validate. The user object must contain the following properties:\n * - id: A unique identifier for the user (number).\n * - name: The name of the user (string).\n * - email: The email address of the user (string).\n * - isActive: Indicates whether the user is active (boolean).\n * @returns True if the user is compliant, otherwise false.\n *\n * @throws Will throw an error if the user object does not have the required properties.\n */`;\nassert(docString.toLowerCase().includes('validates if the given user meets the compliance requirements'));\nassert(docString.includes('@param user - The user object to validate'));\nassert(docString.includes('@returns True if the user is compliant, otherwise false'));\nassert(docString.includes('@throws Will throw an error if the user object does not have the required properties'));\n", "DeepSeek-V3-0324_completion_0": "/**\n * Validates if a user meets compliance requirements.\n * @param user The user to validate.\n * @returns True if the user is compliant, false otherwise.\n */", "DeepSeek-V3-0324_completion_1": "/**\n * Validates if a user meets compliance requirements.\n * @param user The user to validate.\n * @returns True if the user is compliant, false otherwise.\n */", "DeepSeek-V3-0324_completion_2": "function validateUserCompliance(user: User): boolean {\n    // User must have a valid email\n    const emailRegex = /^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/;\n    if (!emailRegex.test(user.email)) {\n        return false;\n    }\n\n    // User must be active\n    if (!user.isActive) {\n        return false;\n    }\n\n    return true;\n}", "DeepSeek-V3-0324_completion_3": "function validateUserCompliance(user: User): boolean {\n    // User must have a valid email\n    const emailRegex = /^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/;\n    if (!emailRegex.test(user.email)) {\n        return false;\n    }\n\n    // User must be active\n    if (!user.isActive) {\n        return false;\n    }\n\n    return true;\n}", "DeepSeek-V3-0324_completion_4": "/**\n * Validates if a user meets compliance requirements.\n * @param user The user to validate.\n * @returns True if the user is compliant, false otherwise.\n */", "DeepSeek-V3-0324_completions": ["/**\n * Validates if a user meets compliance requirements.\n * @param user The user to validate.\n * @returns True if the user is compliant, false otherwise.\n */", "/**\n * Validates if a user meets compliance requirements.\n * @param user The user to validate.\n * @returns True if the user is compliant, false otherwise.\n */", "function validateUserCompliance(user: User): boolean {\n    // User must have a valid email\n    const emailRegex = /^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/;\n    if (!emailRegex.test(user.email)) {\n        return false;\n    }\n\n    // User must be active\n    if (!user.isActive) {\n        return false;\n    }\n\n    return true;\n}", "function validateUserCompliance(user: User): boolean {\n    // User must have a valid email\n    const emailRegex = /^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/;\n    if (!emailRegex.test(user.email)) {\n        return false;\n    }\n\n    // User must be active\n    if (!user.isActive) {\n        return false;\n    }\n\n    return true;\n}", "/**\n * Validates if a user meets compliance requirements.\n * @param user The user to validate.\n * @returns True if the user is compliant, false otherwise.\n */"]}
{"id": "28", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Configuration interface for the workflow orchestrator.\n */\ninterface WorkflowConfig {\n  maxConcurrentTasks: number;\n  retryLimit: number;\n}\n\n/**\n * Task interface representing a unit of work in the workflow.\n */\ninterface Task {\n  id: string;\n  execute: () => Promise<void>;\n  retries: number;\n}\n\n/**\n * A simple in-memory task queue with basic operations.\n */\nclass TaskQueue {\n  private tasks: Task[] = [];\n\n  /**\n   * Adds a task to the queue.\n   * @param task - The task to add.\n   */\n  addTask(task: Task): void {\n    this.tasks.push(task);\n  }\n\n  /**\n   * Removes and returns the next task from the queue.\n   * @returns The next task.\n   */\n  getNextTask(): Task | undefined {\n    return this.tasks.shift();\n  }\n\n  /**\n   * Checks if the queue is empty.\n   * @returns True if the queue is empty, false otherwise.\n   */\n  isEmpty(): boolean {\n    return this.tasks.length === 0;\n  }\n}\n\n", "suffix": "class WorkflowOrchestrator {\n  private config: WorkflowConfig;\n  private taskQueue: TaskQueue;\n  private activeTasks: number = 0;\n\n  constructor(config: WorkflowConfig) {\n    this.config = config;\n    this.taskQueue = new TaskQueue();\n  }\n\n  /**\n   * Schedules a new task for execution.\n   * @param task - The task to be scheduled.\n   */\n  scheduleTask(task: Task): void {\n    this.taskQueue.addTask(task);\n    this.runNextTask();\n  }\n\n  /**\n   * Runs the next task in the queue if conditions allow.\n   */\n  private async runNextTask(): Promise<void> {\n    if (this.activeTasks >= this.config.maxConcurrentTasks || this.taskQueue.isEmpty()) {\n      return;\n    }\n    const task = this.taskQueue.getNextTask();\n    if (task) {\n      this.activeTasks++;\n      try {\n        await task.execute();\n      } catch (error) {\n        if (task.retries < this.config.retryLimit) {\n          task.retries++;\n          this.taskQueue.addTask(task);\n        }\n      } finally {\n        this.activeTasks--;\n        this.runNextTask();\n      }\n    }\n  }\n}\n\nconst config: WorkflowConfig = { maxConcurrentTasks: 3, retryLimit: 2 };\nconst orchestrator = new WorkflowOrchestrator(config);\nconst task: Task = { id: 'task1', execute: async () => { console.log('Task executed'); }, retries: 0 };\norchestrator.scheduleTask(task);\n\nconst task2: Task = { id: 'task2', execute: async () => { throw new Error('Task failed'); }, retries: 0 };\norchestrator.scheduleTask(task2);\n\nsetTimeout(() => {\n  assert.strictEqual(orchestrator['activeTasks'], 0, 'All tasks should be completed or retried');\n}, 1000);\n", "golden_completion": "/**\n * Workflow orchestrator class to manage task execution.\n *\n * This class is responsible for scheduling tasks and ensuring that they\n * are executed according to the configured concurrency and retry limits.\n *\n * @param config - The configuration settings for the workflow orchestrator.\n * @property config - The configuration settings.\n * @property taskQueue - The queue holding tasks to be executed.\n * @property activeTasks - The number of tasks currently being executed.\n *\n * @method scheduleTask - Schedules a new task for execution.\n * @param task - The task to be scheduled.\n *\n * @method runNextTask - Runs the next task in the queue if conditions allow.\n *\n * @throws Will log and retry tasks that fail execution up to the retry limit.\n */\n", "LLM_justification": "This test case provides a comprehensive example of a workflow orchestrator managing task execution, including scheduling and retry logic. The golden_completion focuses on generating detailed documentation for the WorkflowOrchestrator class, which is essential for understanding its purpose, configuration, methods, and error handling logic. The assertions validate that the orchestrator correctly handles task execution and retries, making this a robust scenario for testing both code-to-comment and comment-to-code translation capabilities.", "assertions": "const docString = `/**\n * Workflow orchestrator class to manage task execution.\n *\n * This class is responsible for scheduling tasks and ensuring that they\n * are executed according to the configured concurrency and retry limits.\n *\n * @param config - The configuration settings for the workflow orchestrator.\n * @property config - The configuration settings.\n * @property taskQueue - The queue holding tasks to be executed.\n * @property activeTasks - The number of tasks currently being executed.\n *\n * @method scheduleTask - Schedules a new task for execution.\n * @param task - The task to be scheduled.\n *\n * @method runNextTask - Runs the next task in the queue if conditions allow.\n *\n * @throws Will log and retry tasks that fail execution up to the retry limit.\n */`;\nassert(docString.toLowerCase().includes('workflow orchestrator'));\nassert(docString.includes('@param'));\nassert(docString.includes('method scheduleTask'));\nassert(docString.includes('method runNextTask'));\nassert(docString.includes('Will log and retry tasks that fail execution up to the retry limit.'));\n", "DeepSeek-V3-0324_completion_0": "  private completedTasks: Set<string> = new Set();\n  private failedTasks: Set<string> = new Set();", "DeepSeek-V3-0324_completion_1": "  private completedTasks: number = 0;\n\n  /**\n   * Gets the number of completed tasks.\n   * @returns The number of completed tasks.\n   */\n  getCompletedTasks(): number {\n    return this.completedTasks;\n  }", "DeepSeek-V3-0324_completion_2": "  private completedTasks: number = 0;", "DeepSeek-V3-0324_completion_3": "  private completedTasks: Set<string> = new Set();\n  private failedTasks: Set<string> = new Set();", "DeepSeek-V3-0324_completion_4": "  private completedTasks: Set<string> = new Set();\n  private failedTasks: Map<string, number> = new Map();", "DeepSeek-V3-0324_completions": ["  private completedTasks: Set<string> = new Set();\n  private failedTasks: Set<string> = new Set();", "  private completedTasks: number = 0;\n\n  /**\n   * Gets the number of completed tasks.\n   * @returns The number of completed tasks.\n   */\n  getCompletedTasks(): number {\n    return this.completedTasks;\n  }", "  private completedTasks: number = 0;", "  private completedTasks: Set<string> = new Set();\n  private failedTasks: Set<string> = new Set();", "  private completedTasks: Set<string> = new Set();\n  private failedTasks: Map<string, number> = new Map();"]}
{"id": "29", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Interface representing a business rule for validating user age.\n */\ninterface AgeValidationRule {\n    /**\n     * Validates if the given age complies with the business rule.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean;\n}\n\n/**\n * Class representing a minimum age validation rule.\n */\nclass MinimumAgeRule implements AgeValidationRule {\n    private minAge: number;\n\n    /**\n     * Constructs a MinimumAgeRule with the specified minimum age.\n     * @param minAge - The minimum age to validate against\n     */\n    constructor(minAge: number) {\n        this.minAge = minAge;\n    }\n\n    /**\n     * Validates if the given age is greater than or equal to the minimum age.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return age >= this.minAge;\n    }\n}\n\n/**\n * Class representing a maximum age validation rule.\n */\nclass MaximumAgeRule implements AgeValidationRule {\n    private maxAge: number;\n\n    /**\n     * Constructs a MaximumAgeRule with the specified maximum age.\n     * @param maxAge - The maximum age to validate against\n     */\n    constructor(maxAge: number) {\n        this.maxAge = maxAge;\n    }\n\n    /**\n     * Validates if the given age is less than or equal to the maximum age.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return age <= this.maxAge;\n    }\n}\n\n// Example usage:\nconst minAgeRule = new MinimumAgeRule(18);\nconst maxAgeRule = new MaximumAgeRule(65);\nassert(minAgeRule.validate(20) === true);\nassert(minAgeRule.validate(17) === false);\nassert(maxAgeRule.validate(60) === true);\nassert(maxAgeRule.validate(70) === false);\n", "suffix": "\nclass CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);\n", "golden_completion": "/**\n * Class representing a composite age validation rule that combines multiple rules.\n */\n", "LLM_justification": "This test case is a good example because it involves a realistic business scenario of age validation rules, which are common in applications with age-restricted content or services. The scenario requires understanding of both class inheritance and interface implementation in TypeScript. The translation task is bidirectional, involving both code-to-comment and comment-to-code. The provided assertions ensure the correctness of the implementation and the comprehensiveness of the documentation.", "assertions": "const compositeRuleTest = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRuleTest.validate(30) === true);\nassert(compositeRuleTest.validate(70) === false);\nassert(compositeRuleTest.validate(17) === false);\n\nconst docString = `/**\n * Class representing a composite age validation rule that combines multiple rules.\n */\nclass CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}`;\n\nassert(docString.toLowerCase().includes(\"composite age validation rule\"));\nassert(docString.includes(\"@param rules - An array of age validation rules\"));\nassert(docString.includes(\"@returns True if the age is valid, otherwise false\"));\nassert(docString.includes(\"Validates if the given age complies with all the combined rules.\"));", "DeepSeek-V3-0324_completion_0": "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "DeepSeek-V3-0324_completion_1": "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "DeepSeek-V3-0324_completion_2": "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "DeepSeek-V3-0324_completion_3": "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "DeepSeek-V3-0324_completion_4": "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "DeepSeek-V3-0324_completions": ["class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);", "class CompositeAgeRule implements AgeValidationRule {\n    private rules: AgeValidationRule[];\n\n    /**\n     * Constructs a CompositeAgeRule with the specified validation rules.\n     * @param rules - An array of age validation rules\n     */\n    constructor(rules: AgeValidationRule[]) {\n        this.rules = rules;\n    }\n\n    /**\n     * Validates if the given age complies with all the combined rules.\n     * @param age - The age of the user\n     * @returns True if the age is valid, otherwise false\n     */\n    validate(age: number): boolean {\n        return this.rules.every(rule => rule.validate(age));\n    }\n}\n\n// Example usage:\nconst compositeRule = new CompositeAgeRule([minAgeRule, maxAgeRule]);\nassert(compositeRule.validate(30) === true);\nassert(compositeRule.validate(70) === false);\nassert(compositeRule.validate(17) === false);"]}
{"id": "30", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface Policy {\n\truleName: string;\n\tdescription: string;\n\tvalidate: (data: any) => boolean;\n}\n\n", "suffix": "class PolicyEnforcer {\n\tprivate policies: Policy[] = [];\n\n\t/**\n\t * Adds a new policy to the enforcer.\n\t * @param policy - The policy to add.\n\t */\n\taddPolicy(policy: Policy): void {\n\t\tthis.policies.push(policy);\n\t}\n\n\t/**\n\t * Validates data against all policies.\n\t * @param data - The data to validate.\n\t * @returns An array of policy names that failed.\n\t */\n\tvalidate(data: any): string[] {\n\t\tconst failedPolicies: string[] = [];\n\t\tfor (const policy of this.policies) {\n\t\t\tif (!policy.validate(data)) {\n\t\t\t\tfailedPolicies.push(policy.ruleName);\n\t\t\t}\n\t\t}\n\t\treturn failedPolicies;\n\t}\n}\n\n// Example usage\nconst policyEnforcer = new PolicyEnforcer();\n\npolicyEnforcer.addPolicy({\n\truleName: 'Must be over 18',\n\tdescription: 'The user must be over 18 years old.',\n\tvalidate: (data) => data.age > 18\n});\n\npolicyEnforcer.addPolicy({\n\truleName: 'Must have valid email',\n\tdescription: 'The user must provide a valid email address.',\n\tvalidate: (data) => /\\S+@\\S+\\.\\S+/.test(data.email)\n});\n\nconst testData = { age: 17, email: 'invalid-email' };\nconst failedPolicies = policyEnforcer.validate(testData);\n\nassert(failedPolicies.includes('Must be over 18'));\nassert(failedPolicies.includes('Must have valid email'));\nassert(failedPolicies.length === 2);\nconst testData2 = { age: 25, email: 'test@example.com' };\nconst failedPolicies2 = policyEnforcer.validate(testData2);\n\nassert(failedPolicies2.length === 0);\n\nconsole.log('All assertions passed.');", "golden_completion": "/**\n * PolicyEnforcer is a class that manages policy validation. It allows adding policies and validating data against these policies.\n * \n * @example\n * typescript\n * const policyEnforcer = new PolicyEnforcer();\n * policyEnforcer.addPolicy({\n * \truleName: 'Must be over 18',\n * \tdescription: 'The user must be over 18 years old.',\n * \tvalidate: (data) => data.age > 18\n * });\n * const testData = { age: 17 };\n * const failedPolicies = policyEnforcer.validate(testData);\n * assert(failedPolicies.includes('Must be over 18'));\n * \n * \n * @class PolicyEnforcer\n */", "LLM_justification": "This test case effectively demonstrates bidirectional translation between code and natural language. The provided TypeScript code is a realistic implementation of a policy enforcement system, which involves adding policies and validating data against these policies. The golden completion provides comprehensive documentation for the class, including a usage example, which tests the LLM's ability to generate accurate and detailed comments for existing code. The assertions ensure that the documentation accurately reflects the code's functionality and covers key concepts such as class usage, parameter descriptions, and return values.", "assertions": "const docString = `/**\n * PolicyEnforcer is a class that manages policy validation. It allows adding policies and validating data against these policies.\n * \n * @example\n * typescript\n * const policyEnforcer = new PolicyEnforcer();\n * policyEnforcer.addPolicy({\n * \truleName: 'Must be over 18',\n * \tdescription: 'The user must be over 18 years old.',\n * \tvalidate: (data) => data.age > 18\n * });\n * const testData = { age: 17 };\n * const failedPolicies = policyEnforcer.validate(testData);\n * assert(failedPolicies.includes('Must be over 18'));\n * \n * \n * @class PolicyEnforcer\n */`;\nassert(docString.includes('PolicyEnforcer is a class that manages policy validation'));\nassert(docString.includes('@example'));\nassert(docString.includes('typescript'));\nassert(docString.includes('@class PolicyEnforcer'));\nassert(docString.includes('ruleName'));\nassert(docString.includes('description'));\nassert(docString.includes('validate'));", "DeepSeek-V3-0324_completion_0": "class PolicyEnforcer {", "DeepSeek-V3-0324_completion_1": "\t/**\n\t * Enforces policies on data.\n\t */", "DeepSeek-V3-0324_completion_2": "class PolicyEnforcer {", "DeepSeek-V3-0324_completion_3": "class PolicyEnforcer {", "DeepSeek-V3-0324_completion_4": "\t/**\n\t * A class that enforces a set of policies on data.\n\t */", "DeepSeek-V3-0324_completions": ["class PolicyEnforcer {", "\t/**\n\t * Enforces policies on data.\n\t */", "class PolicyEnforcer {", "class PolicyEnforcer {", "\t/**\n\t * A class that enforces a set of policies on data.\n\t */"]}
{"id": "31", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a user in the system.\n */\ninterface User {\n    id: string;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n/**\n * Type representing a collection of users.\n */\ntype UserCollection = User[];\n\n/**\n * Function to validate user email.\n * @param email - The email address to validate.\n * @returns True if the email is valid, false otherwise.\n */\nfunction validateEmail(email: string): boolean {\n    const emailRegex = /^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\n    return emailRegex.test(email);\n}\n\n/**\n * Function to activate a user.\n * @param user - The user to activate.\n * @returns The activated user.\n */\nfunction activateUser(user: User): User {\n    if (!validateEmail(user.email)) {\n        throw new Error('Invalid email address');\n    }\n    user.isActive = true;\n    return user;\n}\n\n/**\n * Function to deactivate a user.\n * @param user - The user to deactivate.\n * @returns The deactivated user.\n */\nfunction deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}\n\n/**\n * Function to find a user by email in a collection.\n * @param users - The collection of users.\n * @param email - The email of the user to find.\n * @returns The user if found, undefined otherwise.\n */\nfunction findUserByEmail(users: UserCollection, email: string): User | undefined {\n    return users.find(user => user.email === email);\n}\n\n/**\n * Function to deactivate all inactive users in a collection.\n * @param users - The collection of users.\n * @returns The collection with all inactive users deactivated.\n */\nfunction deactivateInactiveUsers(users: UserCollection): UserCollection {\n    return users.map(user => {\n        if (!user.isActive) {\n            return deactivateUser(user);\n        }\n        return user;\n    });\n}\n\n/**\n * Function to get all active users in a collection.\n * @param users - The collection of users.\n * @returns A collection of active users.\n */\nfunction getActiveUsers(users: UserCollection): UserCollection {\n    return users.filter(user => user.isActive);\n}\n\n// The following function needs implementation\n/**\n * Function to count the number of active users in a collection.\n * @param users - The collection of users.\n * @returns The number of active users.\n */\nfunction countActiveUsers(users: UserCollection): number {\n", "suffix": "}\n\nconst users: UserCollection = [\n    { id: '1', name: 'Alice', email: 'alice@example.com', isActive: true },\n    { id: '2', name: 'Bob', email: 'bob@example.com', isActive: false },\n    { id: '3', name: 'Charlie', email: 'charlie@example.com', isActive: true }\n];\n\nassert.strictEqual(countActiveUsers(users), 2);\n\n// Clean up resources if any\n// No resources to clean up in this example", "golden_completion": "    return users.filter(user => user.isActive).length;\n", "LLM_justification": "This test case demonstrates a realistic scenario involving user management functionality. It covers a variety of operations such as validating emails, activating/deactivating users, and filtering collections. The prefix provides extensive context with multiple helper functions and type definitions. The golden_completion requires implementing a function based on a provided comment, testing the LLM's ability to accurately translate documentation into functioning code. The suffix contains assertions to verify the implementation and ensure correctness.", "assertions": "assert.strictEqual(countActiveUsers(users), 2);", "DeepSeek-V3-0324_completion_0": "    return users.filter(user => user.isActive).length;", "DeepSeek-V3-0324_completion_1": "    return users.filter(user => user.isActive).length;", "DeepSeek-V3-0324_completion_2": "    return users.filter(user => user.isActive).length;", "DeepSeek-V3-0324_completion_3": "    return users.filter(user => user.isActive).length;", "DeepSeek-V3-0324_completion_4": "    return users.filter(user => user.isActive).length;", "DeepSeek-V3-0324_completions": ["    return users.filter(user => user.isActive).length;", "    return users.filter(user => user.isActive).length;", "    return users.filter(user => user.isActive).length;", "    return users.filter(user => user.isActive).length;", "    return users.filter(user => user.isActive).length;"]}
{"id": "32", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface User {\n\tid: number;\n\tname: string;\n\temail: string;\n\tisActive: boolean;\n}\n\ninterface UserService {\n\tcreateUser(user: User): Promise<User>;\n\tgetUser(id: number): Promise<User | null>;\n\tupdateUser(user: User): Promise<User>;\n\tdeleteUser(id: number): Promise<boolean>;\n}\n\n", "suffix": "class UserServiceImpl implements UserService {\n\tprivate users: Map<number, User> = new Map();\n\n\t/**\n\t * Creates a new user and adds to the user list.\n\t * @param user - The user object to be created.\n\t * @returns The created user object.\n\t */\n\tasync createUser(user: User): Promise<User> {\n\t\tif (this.users.has(user.id)) {\n\t\t\tthrow new Error('User already exists');\n\t\t}\n\t\tthis.users.set(user.id, user);\n\t\treturn user;\n\t}\n\n\tasync getUser(id: number): Promise<User | null> {\n\t\treturn this.users.get(id) || null;\n\t}\n\n\tasync updateUser(user: User): Promise<User> {\n\t\tif (!this.users.has(user.id)) {\n\t\t\tthrow new Error('User does not exist');\n\t\t}\n\t\tthis.users.set(user.id, user);\n\t\treturn user;\n\t}\n\n\t/**\n\t * Deletes a user from the user list.\n\t * @param id - The ID of the user to be deleted.\n\t * @returns A boolean indicating whether the deletion was successful.\n\t */\n\tasync deleteUser(id: number): Promise<boolean> {\n\t\tif (!this.users.has(id)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.users.delete(id);\n\t\treturn true;\n\t}\n}\n\nconst userService: UserService = new UserServiceImpl();\n\n// Test createUser method\n(async () => {\n\tconst newUser: User = { id: 1, name: 'John Doe', email: 'john@example.com', isActive: true };\n\tawait userService.createUser(newUser);\n\tconst fetchedUser = await userService.getUser(1);\n\tassert(fetchedUser !== null);\n\tassert(fetchedUser.name === 'John Doe');\n\n\t// Test updateUser method\n\tnewUser.name = 'John Smith';\n\tawait userService.updateUser(newUser);\n\tconst updatedUser = await userService.getUser(1);\n\tassert(updatedUser !== null);\n\tassert(updatedUser.name === 'John Smith');\n\n\t// Test deleteUser method\n\tconst deleteResult = await userService.deleteUser(1);\n\tassert(deleteResult === true);\n\tconst deletedUser = await userService.getUser(1);\n\tassert(deletedUser === null);\n})();\n\n// Test getUser method with non-existing user\n(async () => {\n\tconst nonExistingUser = await userService.getUser(999);\n\tassert(nonExistingUser === null);\n})();\n\n// Cleanup: nothing to clean up in this example\n", "golden_completion": "/*\n * UserServiceImpl is an implementation of the UserService interface.\n * It manages a list of users and provides methods to create, retrieve, update, and delete users.\n *\n * Methods:\n * - createUser: Adds a new user to the list if the user does not already exist.\n * - getUser: Retrieves a user by their ID.\n * - updateUser: Updates an existing user's details.\n * - deleteUser: Removes a user from the list by their ID.\n *\n * Error Handling:\n * - createUser: Throws an error if a user with the same ID already exists.\n * - updateUser: Throws an error if the user does not exist.\n * - deleteUser: Returns false if the user does not exist.\n *\n * Usage Examples:\n * const newUser: User = { id: 1, name: 'John Doe', email: 'john@example.com', isActive: true };\n * await userService.createUser(newUser);\n * const fetchedUser = await userService.getUser(1);\n * assert(fetchedUser !== null);\n * assert(fetchedUser.name === 'John Doe');\n *\n * newUser.name = 'John Smith';\n * await userService.updateUser(newUser);\n * const updatedUser = await userService.getUser(1);\n * assert(updatedUser !== null);\n * assert(updatedUser.name === 'John Smith');\n *\n * const deleteResult = await userService.deleteUser(1);\n * assert(deleteResult === true);\n * const deletedUser = await userService.getUser(1);\n * assert(deletedUser === null);\n */", "LLM_justification": "This example tests the LLM's ability to translate between TypeScript code and comprehensive documentation. It includes a realistic business scenario with user management, detailed method implementations, and thorough documentation requirements. The assertions verify functional correctness and documentation accuracy, ensuring that the LLM can handle both code-to-comment and comment-to-code translations effectively.", "assertions": "const docString = `/*\n * UserServiceImpl is an implementation of the UserService interface.\n * It manages a list of users and provides methods to create, retrieve, update, and delete users.\n *\n * Methods:\n * - createUser: Adds a new user to the list if the user does not already exist.\n * - getUser: Retrieves a user by their ID.\n * - updateUser: Updates an existing user's details.\n * - deleteUser: Removes a user from the list by their ID.\n *\n * Error Handling:\n * - createUser: Throws an error if a user with the same ID already exists.\n * - updateUser: Throws an error if the user does not exist.\n * - deleteUser: Returns false if the user does not exist.\n *\n * Usage Examples:\n * const newUser: User = { id: 1, name: 'John Doe', email: 'john@example.com', isActive: true };\n * await userService.createUser(newUser);\n * const fetchedUser = await userService.getUser(1);\n * assert(fetchedUser !== null);\n * assert(fetchedUser.name === 'John Doe');\n *\n * newUser.name = 'John Smith';\n * await userService.updateUser(newUser);\n * const updatedUser = await userService.getUser(1);\n * assert(updatedUser !== null);\n * assert(updatedUser.name === 'John Smith');\n *\n * const deleteResult = await userService.deleteUser(1);\n * assert(deleteResult === true);\n * const deletedUser = await userService.getUser(1);\n * assert(deletedUser === null);\n */`;\nassert(docString.toLowerCase().includes('userserviceimpl'));\nassert(docString.includes('Methods:'));\nassert(docString.includes('Error Handling:'));\nassert(docString.includes('Usage Examples:'));\n", "DeepSeek-V3-0324_completion_0": "\n}", "DeepSeek-V3-0324_completion_1": "export ", "DeepSeek-V3-0324_completion_2": "class UserServiceImpl implements UserService {", "DeepSeek-V3-0324_completion_3": "\n}", "DeepSeek-V3-0324_completion_4": "\n}", "DeepSeek-V3-0324_completions": ["\n}", "export ", "class UserServiceImpl implements UserService {", "\n}", "\n}"]}
{"id": "33", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a User entity.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n/**\n * Function to validate a user's email address based on a set of business rules.\n *\n * @param email - The email address to validate.\n * @returns True if the email address is valid, otherwise false.\n */\nfunction validateEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\n\n/**\n * Function to deactivate a user if they are inactive for more than 30 days.\n *\n * @param user - The user to deactivate.\n * @returns The updated user with isActive set to false if they were inactive.\n */\nfunction deactivateUser(user: User): User {\n    // Complex business logic to determine if the user should be deactivated.\n    // For example, check the last login date (not implemented here).\n    user.isActive = false;\n    return user;\n}\n\n/**\n * Function to send an email notification to a user.\n *\n * @param user - The user to notify.\n * @param message - The message to send.\n */\nfunction sendEmailNotification(user: User, message: string): void {\n    console.log(`Sending email to ${user.email}: ${message}`);\n}\n\n/**\n * Class to manage a collection of users.\n */\nclass UserManager {\n    private users: User[] = [];\n\n    /**\n     * Add a new user to the collection.\n     *\n     * @param user - The user to add.\n     */\n    addUser(user: User): void {\n        this.users.push(user);\n    }\n\n    /**\n     * Get a user by their ID.\n     *\n     * @param id - The ID of the user to retrieve.\n     * @returns The user with the specified ID, or undefined if not found.\n     */\n    getUserById(id: number): User | undefined {\n        return this.users.find(user => user.id === id);\n    }\n}\n\n/**\n * Function to handle user login.\n *\n * @param userManager - The UserManager instance managing the users.\n * @param email - The email address of the user trying to log in.\n * @returns The user if login is successful, otherwise an error message.\n */\nfunction handleUserLogin(userManager: UserManager, email: string): User | string {\n    const user = userManager.getUserById(1); // Simulating user retrieval\n    if (!user || !validateEmail(email)) {\n        return 'Invalid email or user not found';\n    }\n    if (!user.isActive) {\n        return 'User is inactive';\n    }\n    return user;\n}\n\n/**\n * Function to verify user login credentials.\n *\n * @param email - The email address of the user trying to log in.\n * @param password - The password of the user trying to log in.\n * @returns True if credentials are valid, otherwise false.\n */\nfunction verifyUserCredentials(email: string, password: string): boolean {\n    // Placeholder for password verification logic.\n    return email === 'john.doe@example.com' && password === 'password123';\n}\n\n/**\n * Function to handle user registration.\n *\n * @param userManager - The UserManager instance managing the users.\n * @param newUser - The new user to register.\n * @returns The registered user.\n */\nfunction handleUserRegistration(userManager: UserManager, newUser: User): User {\n    userManager.addUser(newUser);\n    return newUser;\n}", "suffix": "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "golden_completion": "/**\n * Function to update a user's email address.\n *\n * @param userManager - The UserManager instance managing the users.\n * @param userId - The ID of the user to update.\n * @param newEmail - The new email address to set.\n * @returns The updated user if successful, otherwise an error message.\n */\nfunction updateUserEmail(userManager: UserManager, userId: number, newEmail: string): User | string {\n    const user = userManager.getUserById(userId);\n    if (!user) {\n        return 'User not found';\n    }\n    if (!validateEmail(newEmail)) {\n        return 'Invalid email address';\n    }\n    user.email = newEmail;\n    return user;\n}\n", "LLM_justification": "This scenario is a good test case because it involves complex business logic related to user management, including validation, deactivation, and notification processes. The code-to-comment task requires generating comprehensive documentation for a function that updates a user's email address, ensuring clarity and coverage of all important aspects. The comment-to-code task involves implementing the function based on the provided documentation. The assertions check the correctness of the function and the validity of documentation, ensuring the LLM can handle both code generation and documentation accurately.", "assertions": "const updatedUser = updateUserEmail(userManager, 1, 'john.new@example.com');\nassert(typeof updatedUser === 'object' && (updatedUser as User).email === 'john.new@example.com');\nconst invalidUpdate = updateUserEmail(userManager, 1, 'invalid-email');\nassert(typeof invalidUpdate === 'string' && invalidUpdate === 'Invalid email address');\nconst nonExistentUserUpdate = updateUserEmail(userManager, 99, 'john.new@example.com');\nassert(typeof nonExistentUserUpdate === 'string' && nonExistentUserUpdate === 'User not found');", "DeepSeek-V3-0324_completion_0": "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "DeepSeek-V3-0324_completion_1": "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "DeepSeek-V3-0324_completion_2": "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "DeepSeek-V3-0324_completion_3": "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "DeepSeek-V3-0324_completion_4": "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "DeepSeek-V3-0324_completions": ["const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');", "const userManager = new UserManager();\n\nconst testUser: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\nuserManager.addUser(testUser);\nconst loginUser = handleUserLogin(userManager, 'john.doe@example.com');\nassert(typeof loginUser === 'object' && loginUser !== null && (loginUser as User).id === 1);\nassert(verifyUserCredentials('john.doe@example.com', 'password123'));\nconst newUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    isActive: true\n};\nconst registeredUser = handleUserRegistration(userManager, newUser);\nassert(registeredUser.id === 2);\nassert(userManager.getUserById(2)?.name === 'Jane Smith');"]}
{"id": "34", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Interface representing a user in the system.\n */\ninterface User {\n    id: string;\n    name: string;\n    email: string;\n    roles: string[];\n}\n\n/**\n * Interface for a policy enforcement service.\n */\ninterface PolicyService {\n    checkCompliance(user: User): boolean;\n}\n\n/**\n * Implementation of the PolicyService.\n */\nclass DefaultPolicyService implements PolicyService {\n    private allowedDomains: string[];\n\n    constructor(allowedDomains: string[]) {\n        this.allowedDomains = allowedDomains;\n    }\n\n    /**\n     * Check if the user complies with the allowed domain policy.\n     * @param user - The user to check.\n     * @returns True if the user complies, false otherwise.\n     */\n    checkCompliance(user: User): boolean {\n        return this.allowedDomains.some(domain => user.email.endsWith(`@${domain}`));\n    }\n}\n\n// Setting up a list of allowed domains for testing purposes\nconst allowedDomains = ['example.com', 'test.com'];\nconst policyService = new DefaultPolicyService(allowedDomains);\n\n// Test users\nconst compliantUser: User = { id: '1', name: 'John Doe', email: 'john.doe@example.com', roles: ['user'] };\nconst nonCompliantUser: User = { id: '2', name: 'Jane Smith', email: 'jane.smith@invalid.com', roles: ['admin'] };\n\n// Check compliance for both users\nassert(policyService.checkCompliance(compliantUser) === true);\nassert(policyService.checkCompliance(nonCompliantUser) === false);\n\n/**\n * Function to log the compliance status of a user.\n * @param user - The user to log.\n * @param policyService - The policy service to use for checking compliance.\n */\nfunction logComplianceStatus(user: User, policyService: PolicyService): void {\n    const isCompliant = policyService.checkCompliance(user);\n    console.log(`User ${user.name} compliance status: ${isCompliant ? 'Compliant' : 'Non-compliant'}`);\n}\n\n// Logging compliance status for both users\nlogComplianceStatus(compliantUser, policyService);\nlogComplianceStatus(nonCompliantUser, policyService);\n\n// The following function needs to be implemented based on the provided documentation\n/**\n * Function to filter compliant users from a list.\n * @param users - The list of users to filter.\n * @param policyService - The policy service to use for checking compliance.\n * @returns A list of compliant users.\n */\nfunction filterCompliantUsers(users: User[], policyService: PolicyService): User[] {", "suffix": "}\n\n// Test the filterCompliantUsers function\nconst users: User[] = [compliantUser, nonCompliantUser];\nconst compliantUsers = filterCompliantUsers(users, policyService);\nassert(compliantUsers.length === 1);\nassert(compliantUsers[0].email === 'john.doe@example.com');\n\n// Cleanup resources if any (none in this case)\n", "golden_completion": "    return users.filter(user => policyService.checkCompliance(user));", "LLM_justification": "This test case provides a realistic business logic scenario involving user compliance checking, policy enforcement, and filtering. The prefix includes detailed TypeScript interfaces, a class implementation, and extensive setup code. The golden completion requires implementing a function based on provided documentation, testing the LLM's ability to translate comments to code. Assertions verify the correctness of the implementation, while the scenario covers complex business rules and technical requirements.", "assertions": "const usersTest: User[] = [compliantUser, nonCompliantUser];\nconst compliantUsersTest = filterCompliantUsers(usersTest, policyService);\nassert(compliantUsersTest.length === 1);\nassert(compliantUsersTest[0].email === 'john.doe@example.com');", "DeepSeek-V3-0324_completion_0": "    return users.filter(user => policyService.checkCompliance(user));", "DeepSeek-V3-0324_completion_1": "    return users.filter(user => policyService.checkCompliance(user));", "DeepSeek-V3-0324_completion_2": "    return users.filter(user => policyService.checkCompliance(user));", "DeepSeek-V3-0324_completion_3": "    return users.filter(user => policyService.checkCompliance(user));", "DeepSeek-V3-0324_completion_4": "    return users.filter(user => policyService.checkCompliance(user));", "DeepSeek-V3-0324_completions": ["    return users.filter(user => policyService.checkCompliance(user));", "    return users.filter(user => policyService.checkCompliance(user));", "    return users.filter(user => policyService.checkCompliance(user));", "    return users.filter(user => policyService.checkCompliance(user));", "    return users.filter(user => policyService.checkCompliance(user));"]}
{"id": "35", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface Policy {\n  id: number;\n  name: string;\n  description: string;\n}\n\ninterface ComplianceCheck {\n  user: User;\n  policies: Policy[];\n  timestamp: Date;\n}\n\n", "suffix": "class ComplianceManager {\n  private users: User[] = [];\n  private policies: Policy[] = [];\n\n  /**\n   * Adds a user to the compliance manager.\n   * @param user - The user to add.\n   */\n  addUser(user: User): void {\n    this.users.push(user);\n  }\n\n  /**\n   * Adds a policy to the compliance manager.\n   * @param policy - The policy to add.\n   */\n  addPolicy(policy: Policy): void {\n    this.policies.push(policy);\n  }\n\n  /**\n   * Checks if a user complies with all policies.\n   * @param userId - The ID of the user to check.\n   * @returns True if the user complies with all policies, false otherwise.\n   */\n  checkCompliance(userId: number): boolean {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    return this.policies.every(policy => this.userCompliesWithPolicy(user, policy));\n  }\n\n  /**\n   * Checks if a user complies with a specific policy.\n   * @param user - The user to check.\n   * @param policy - The policy to check against.\n   * @returns True if the user complies with the policy, false otherwise.\n   */\n  private userCompliesWithPolicy(user: User, policy: Policy): boolean {\n    // Placeholder for actual compliance check logic\n    return true;\n  }\n}\n\nconst manager = new ComplianceManager();\nmanager.addUser({ id: 1, name: 'Alice', email: 'alice@example.com' });\nmanager.addPolicy({ id: 1, name: 'Policy1', description: 'First policy' });\nassert(manager.checkCompliance(1) === true);\n\nmanager.addUser({ id: 2, name: 'Bob', email: 'bob@example.com' });\nmanager.addPolicy({ id: 2, name: 'Policy2', description: 'Second policy' });\n\nassert(manager.checkCompliance(2) === true);\n\ntry {\n  manager.checkCompliance(3);\n} catch (error) {\n  assert(error.message === 'User with ID 3 not found');\n}\n", "golden_completion": "/**\n * The ComplianceManager class is responsible for managing users and policies,\n * and checking if users comply with the defined policies.\n *\n * @class ComplianceManager\n */\n", "LLM_justification": "This test case is a good example for evaluating an LLM's ability to translate between code and natural language because it involves a realistic scenario of business rule validation. The ComplianceManager class demonstrates the management of users and policies, and includes methods for adding users and policies and checking compliance. The golden completion requires generating comprehensive documentation for the ComplianceManager class, which includes describing its purpose and methods. The suffix section tests the functionality of the ComplianceManager class, ensuring that the assertions verify the accuracy of both the code and the generated documentation.", "assertions": "const docString = `/**\n * The ComplianceManager class is responsible for managing users and policies,\n * and checking if users comply with the defined policies.\n *\n * @class ComplianceManager\n */`;\nassert(docString.includes('ComplianceManager'));\nassert(docString.includes('managing users and policies'));\nassert(docString.includes('checking if users comply'));\n", "DeepSeek-V3-0324_completion_0": "  recordCompliance(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    return {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n  }", "DeepSeek-V3-0324_completion_1": "  private complianceChecks: ComplianceCheck[] = [];\n\n  /**\n   * Records a compliance check for a user.\n   * @param userId - The ID of the user to record the check for.\n   * @returns The recorded compliance check.\n   */\n  recordComplianceCheck(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    const check: ComplianceCheck = {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n    this.complianceChecks.push(check);\n    return check;\n  }", "DeepSeek-V3-0324_completion_2": "  private complianceChecks: ComplianceCheck[] = [];\n\n  /**\n   * Records a compliance check for a user.\n   * @param userId - The ID of the user to record the check for.\n   * @returns The recorded compliance check.\n   */\n  recordComplianceCheck(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    const check: ComplianceCheck = {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n    this.complianceChecks.push(check);\n    return check;\n  }", "DeepSeek-V3-0324_completion_3": "  private complianceChecks: ComplianceCheck[] = [];\n\n  /**\n   * Records a compliance check for a user.\n   * @param userId - The ID of the user to record the check for.\n   * @returns The recorded compliance check.\n   */\n  recordComplianceCheck(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    const check: ComplianceCheck = {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n    this.complianceChecks.push(check);\n    return check;\n  }", "DeepSeek-V3-0324_completion_4": "  private complianceChecks: ComplianceCheck[] = [];\n\n  /**\n   * Records a compliance check for a user.\n   * @param userId - The ID of the user to record the check for.\n   * @returns The recorded compliance check.\n   */\n  recordComplianceCheck(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    const check: ComplianceCheck = {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n    this.complianceChecks.push(check);\n    return check;\n  }", "DeepSeek-V3-0324_completions": ["  recordCompliance(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    return {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n  }", "  private complianceChecks: ComplianceCheck[] = [];\n\n  /**\n   * Records a compliance check for a user.\n   * @param userId - The ID of the user to record the check for.\n   * @returns The recorded compliance check.\n   */\n  recordComplianceCheck(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    const check: ComplianceCheck = {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n    this.complianceChecks.push(check);\n    return check;\n  }", "  private complianceChecks: ComplianceCheck[] = [];\n\n  /**\n   * Records a compliance check for a user.\n   * @param userId - The ID of the user to record the check for.\n   * @returns The recorded compliance check.\n   */\n  recordComplianceCheck(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    const check: ComplianceCheck = {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n    this.complianceChecks.push(check);\n    return check;\n  }", "  private complianceChecks: ComplianceCheck[] = [];\n\n  /**\n   * Records a compliance check for a user.\n   * @param userId - The ID of the user to record the check for.\n   * @returns The recorded compliance check.\n   */\n  recordComplianceCheck(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    const check: ComplianceCheck = {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n    this.complianceChecks.push(check);\n    return check;\n  }", "  private complianceChecks: ComplianceCheck[] = [];\n\n  /**\n   * Records a compliance check for a user.\n   * @param userId - The ID of the user to record the check for.\n   * @returns The recorded compliance check.\n   */\n  recordComplianceCheck(userId: number): ComplianceCheck {\n    const user = this.users.find(u => u.id === userId);\n    if (!user) {\n      throw new Error(`User with ID ${userId} not found`);\n    }\n    const check: ComplianceCheck = {\n      user,\n      policies: this.policies,\n      timestamp: new Date()\n    };\n    this.complianceChecks.push(check);\n    return check;\n  }"]}
{"id": "36", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Interface representing a business entity.\n */\ninterface BusinessEntity {\n    id: number;\n    name: string;\n    isActive: boolean;\n}\n\n/**\n * Function to validate if the business entity is compliant with certain rules.\n * @param entity - The business entity to validate.\n * @returns A boolean indicating if the entity is compliant.\n */\nfunction validateEntityCompliance(entity: BusinessEntity): boolean {\n    // Rule 1: Entity must have a valid ID (greater than 0).\n    if (entity.id <= 0) {\n        return false;\n    }\n\n    // Rule 2: Entity name must not be empty.\n    if (entity.name.trim() === '') {\n        return false;\n    }\n\n    // Rule 3: Entity must be active.\n    if (!entity.isActive) {\n        return false;\n    }\n\n    return true;\n}\n\n// Example usage:\nconst exampleEntity: BusinessEntity = {\n    id: 1,\n    name: 'Example Inc.',\n    isActive: true\n};\n\n// Example entities array for testing:\nconst entities: BusinessEntity[] = [\n    { id: 1, name: 'Valid Corp.', isActive: true },\n    { id: 2, name: 'Inactive Corp.', isActive: false },\n    { id: 3, name: '', isActive: true },\n    { id: 4, name: 'Another Valid Corp.', isActive: true }\n];\n", "suffix": "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}\n// Test orchestration function:\nconst compliantEntities = orchestrateWorkflow(entities);\nassert(compliantEntities.length === 2);\nassert(compliantEntities[0].name === 'Valid Corp.');\nassert(compliantEntities[1].name === 'Another Valid Corp.');\n\nconsole.log('All tests passed!');\n", "golden_completion": "/**\n * Orchestrates a business workflow by filtering out non-compliant entities.\n * \n * The function iterates through each entity and uses the validateEntityCompliance\n * function to check if the entity meets all compliance rules. Compliant entities\n * are collected into an array and returned.\n * \n * @param entities - An array of business entities to process.\n * @returns An array of compliant entities.\n */\n", "LLM_justification": "This test case effectively demonstrates both code-to-comment and comment-to-code translation capabilities. The scenario involves validating business entities for compliance and orchestrating a workflow based on that validation. The golden_completion requires generating comprehensive documentation for a function based on its implementation, testing the LLM's ability to understand and explain code behavior accurately. The prefix provides a detailed setup, including interfaces, utility functions, and example data, ensuring that the context is well-defined. The suffix includes tests to verify the correctness of the function, ensuring that the implementation meets the documented requirements. The assertions check the accuracy of the documentation and the functionality of the code, making this a robust test case for evaluating an LLM's translation capabilities.", "assertions": "const docString = `/**\\n * Orchestrates a business workflow by filtering out non-compliant entities.\\n * \\n * The function iterates through each entity and uses the validateEntityCompliance\\n * function to check if the entity meets all compliance rules. Compliant entities\\n * are collected into an array and returned.\\n * \\n * @param entities - An array of business entities to process.\\n * @returns An array of compliant entities.\\n */`;\nassert(docString.toLowerCase().includes('workflow'));\nassert(docString.includes('@param'));\nassert(docString.includes('@returns'));\nassert(docString.includes('validateEntityCompliance'));\n", "DeepSeek-V3-0324_completion_0": "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}\n// Test orchestration function:\nconst compliantEntities = orchestrateWorkflow(entities);\nassert(compliantEntities.length === 2);\nassert(compliantEntities[0].name === 'Valid Corp.');\nassert(compliantEntities[1].name === 'Another Valid Corp.');\n\nconsole.log('All tests passed!');", "DeepSeek-V3-0324_completion_1": "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}", "DeepSeek-V3-0324_completion_2": "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}", "DeepSeek-V3-0324_completion_3": "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}", "DeepSeek-V3-0324_completion_4": "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}", "DeepSeek-V3-0324_completions": ["function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}\n// Test orchestration function:\nconst compliantEntities = orchestrateWorkflow(entities);\nassert(compliantEntities.length === 2);\nassert(compliantEntities[0].name === 'Valid Corp.');\nassert(compliantEntities[1].name === 'Another Valid Corp.');\n\nconsole.log('All tests passed!');", "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}", "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}", "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}", "function orchestrateWorkflow(entities: BusinessEntity[]): BusinessEntity[] {\n    const compliantEntities: BusinessEntity[] = [];\n    for (const entity of entities) {\n        if (validateEntityCompliance(entity)) {\n            compliantEntities.push(entity);\n        }\n    }\n    return compliantEntities;\n}"]}
{"id": "37", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Represents a business entity with validation rules.\n */\ninterface BusinessEntity {\n    id: string;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n", "suffix": "function validateBusinessEntity(entity: BusinessEntity): string[] {\n    const errors: string[] = [];\n\n    // Check if the ID is a valid UUID\n    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(entity.id)) {\n        errors.push('Invalid ID format.');\n    }\n\n    // Check if the name is not empty and at least 3 characters long\n    if (entity.name.trim().length < 3) {\n        errors.push('Name must be at least 3 characters long.');\n    }\n\n    // Check if the email is a valid email address\n    if (!/^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$/.test(entity.email)) {\n        errors.push('Invalid email format.');\n    }\n\n    return errors;\n}\n\n// Example business entity\nconst exampleEntity: BusinessEntity = {\n    id: '12345678-1234-1234-1234-1234567890ab',\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    isActive: true\n};\n\n// Validate the example entity\nconst validationErrors = validateBusinessEntity(exampleEntity);\n// Check if there are no validation errors\nassert.strictEqual(validationErrors.length, 0, `Expected no validation errors, but got: ${validationErrors.join(', ')}`);\n\n// Cleanup (if any) should go here\n// No resources to clean up in this example\n", "golden_completion": "/**\n * This function validates a business entity to ensure it meets all business rules.\n * \n * @param entity - The business entity to validate. Must include an id, name, email, and isActive status.\n * @returns A string array of validation error messages. The array will be empty if no errors are found.\n * \n * Business rules enforced:\n * 1. The ID must be a valid UUID.\n * 2. The name must not be empty and should be at least 3 characters long.\n * 3. The email must be a valid email address.\n */\n", "LLM_justification": "This example tests the LLM's ability to generate comprehensive documentation for a function that validates a business entity against specific business rules. The documentation must include a detailed description, parameters, return value, and the business rules enforced. The prefix provides a complete implementation of the validation logic, and the suffix includes an assertion to ensure the function works as expected. This scenario is realistic and covers complex business logic, making it a good test case for code-to-comment translation.", "assertions": "const docString = `/**\n * This function validates a business entity to ensure it meets all business rules.\n * \n * @param entity - The business entity to validate. Must include an id, name, email, and isActive status.\n * @returns A string array of validation error messages. The array will be empty if no errors are found.\n * \n * Business rules enforced:\n * 1. The ID must be a valid UUID.\n * 2. The name must not be empty and should be at least 3 characters long.\n * 3. The email must be a valid email address.\n */`;\nassert(docString.toLowerCase().includes('validates a business entity'));\nassert(docString.includes('@param entity'));\nassert(docString.includes('@returns A string array of validation error messages'));\nassert(docString.includes('Business rules enforced'));\nassert(docString.includes('1. The ID must be a valid UUID.'));\nassert(docString.includes('2. The name must not be empty and should be at least 3 characters long.'));\nassert(docString.includes('3. The email must be a valid email address.'));", "DeepSeek-V3-0324_completion_0": "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages, empty if the entity is valid.\n */", "DeepSeek-V3-0324_completion_1": "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages if validation fails, otherwise an empty array.\n */", "DeepSeek-V3-0324_completion_2": "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages, empty if the entity is valid.\n */", "DeepSeek-V3-0324_completion_3": "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages, empty if the entity is valid.\n */", "DeepSeek-V3-0324_completion_4": "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages, empty if the entity is valid.\n */", "DeepSeek-V3-0324_completions": ["/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages, empty if the entity is valid.\n */", "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages if validation fails, otherwise an empty array.\n */", "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages, empty if the entity is valid.\n */", "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages, empty if the entity is valid.\n */", "/**\n * Validates a business entity according to predefined rules.\n * @param entity The business entity to validate.\n * @returns An array of error messages, empty if the entity is valid.\n */"]}
{"id": "38", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface User {\n\tid: string;\n\tname: string;\n\tage: number;\n\temail: string;\n\trole: 'admin' | 'user';\n}\n\nconst users: User[] = [\n\t{ id: '1', name: 'Alice', age: 30, email: 'alice@example.com', role: 'admin' },\n\t{ id: '2', name: 'Bob', age: 25, email: 'bob@example.com', role: 'user' },\n\t{ id: '3', name: 'Charlie', age: 35, email: 'charlie@example.com', role: 'user' }\n];\n\n/**\n * Filters users by their role.\n * @param users - The array of users to filter.\n * @param role - The role to filter by ('admin' or 'user').\n * @returns An array of users with the specified role.\n */\nfunction filterUsersByRole(users: User[], role: 'admin' | 'user'): User[] {\n\treturn users.filter(user => user.role === role);\n}\n\n/**\n * Validates if the user is allowed to perform an action based on their role.\n * @param user - The user to validate.\n * @param action - The action to validate.\n * @returns True if the user can perform the action, otherwise false.\n */\nfunction canUserPerformAction(user: User, action: string): boolean {\n\tconst adminActions = ['delete_user', 'add_user', 'update_user'];\n\tconst userActions = ['view_user'];\n\tif (user.role === 'admin') {\n\t\treturn adminActions.includes(action);\n\t} else if (user.role === 'user') {\n\t\treturn userActions.includes(action);\n\t}\n\treturn false;\n}\n\n/**\n * Generates a summary of user statistics.\n * @param users - The array of users.\n * @returns An object containing the count of admins and users.\n */\nfunction generateUserStatistics(users: User[]): { adminCount: number; userCount: number } {\n\tconst adminCount = users.filter(user => user.role === 'admin').length;\n\tconst userCount = users.filter(user => user.role === 'user').length;\n\treturn { adminCount, userCount };\n}\n\n// Example usage of the functions\nconst admins = filterUsersByRole(users, 'admin');\nconst canAliceDeleteUser = canUserPerformAction(users[0], 'delete_user');\nconst userStats = generateUserStatistics(users);\n", "suffix": "\n// Assertions to verify the correctness of the functions\nassert.strictEqual(admins.length, 1);\nassert.strictEqual(admins[0].name, 'Alice');\nassert.strictEqual(canAliceDeleteUser, true);\nassert.strictEqual(userStats.adminCount, 1);\nassert.strictEqual(userStats.userCount, 2);\n\nconsole.log('All assertions passed.');\n", "golden_completion": "/**\n * Adds a new user to the array of users.\n * @param users - The array of users.\n * @param newUser - The new user to add.\n * @returns The updated array of users with the new user added.\n */\nfunction addUser(users: User[], newUser: User): User[] {\n\treturn [...users, newUser];\n}\n\n/**\n * Removes a user from the array of users by their ID.\n * @param users - The array of users.\n * @param userId - The ID of the user to remove.\n * @returns The updated array of users with the specified user removed.\n */\nfunction removeUser(users: User[], userId: string): User[] {\n\treturn users.filter(user => user.id !== userId);\n}\n\n// Example usage of the new functions\nconst updatedUsers = addUser(users, { id: '4', name: 'Dave', age: 40, email: 'dave@example.com', role: 'user' });\nconst usersAfterRemoval = removeUser(updatedUsers, '2');\n", "LLM_justification": "This scenario demonstrates complex business logic involving user management and role-based permissions. The code includes various functions to filter users, validate actions based on roles, and generate user statistics, which are common tasks in business applications. The golden completion adds functions to add and remove users, which are essential operations in user management systems. This tests the LLM's ability to generate accurate TypeScript code from detailed documentation and vice versa. The assertions verify the correctness of these functions, ensuring the LLM's understanding of both the code and the documentation.", "assertions": "assert.strictEqual(updatedUsers.length, 4);\nassert.strictEqual(updatedUsers[3].name, 'Dave');\nassert.strictEqual(usersAfterRemoval.length, 3);\nassert.strictEqual(usersAfterRemoval.find(user => user.id === '2'), undefined);\n", "DeepSeek-V3-0324_completion_0": "assert.strictEqual(filterUsersByRole(users, 'user').length, 2);\nassert.strictEqual(canUserPerformAction(users[1], 'view_user'), true);\nassert.strictEqual(canUserPerformAction(users[1], 'delete_user'), false);", "DeepSeek-V3-0324_completion_1": "console.log('Admins:', admins);\nconsole.log('Can Alice delete user:', canAliceDeleteUser);\nconsole.log('User statistics:', userStats);", "DeepSeek-V3-0324_completion_2": "assert.strictEqual(filterUsersByRole(users, 'user').length, 2);\nassert.strictEqual(canUserPerformAction(users[1], 'view_user'), true);\nassert.strictEqual(canUserPerformAction(users[1], 'delete_user'), false);", "DeepSeek-V3-0324_completion_3": "assert.strictEqual(filterUsersByRole(users, 'user').length, 2);\nassert.strictEqual(canUserPerformAction(users[1], 'view_user'), true);\nassert.strictEqual(canUserPerformAction(users[1], 'delete_user'), false);", "DeepSeek-V3-0324_completion_4": "assert.strictEqual(filterUsersByRole(users, 'user').length, 2);\nassert.strictEqual(canUserPerformAction(users[1], 'view_user'), true);\nassert.strictEqual(canUserPerformAction(users[1], 'delete_user'), false);", "DeepSeek-V3-0324_completions": ["assert.strictEqual(filterUsersByRole(users, 'user').length, 2);\nassert.strictEqual(canUserPerformAction(users[1], 'view_user'), true);\nassert.strictEqual(canUserPerformAction(users[1], 'delete_user'), false);", "console.log('Admins:', admins);\nconsole.log('Can Alice delete user:', canAliceDeleteUser);\nconsole.log('User statistics:', userStats);", "assert.strictEqual(filterUsersByRole(users, 'user').length, 2);\nassert.strictEqual(canUserPerformAction(users[1], 'view_user'), true);\nassert.strictEqual(canUserPerformAction(users[1], 'delete_user'), false);", "assert.strictEqual(filterUsersByRole(users, 'user').length, 2);\nassert.strictEqual(canUserPerformAction(users[1], 'view_user'), true);\nassert.strictEqual(canUserPerformAction(users[1], 'delete_user'), false);", "assert.strictEqual(filterUsersByRole(users, 'user').length, 2);\nassert.strictEqual(canUserPerformAction(users[1], 'view_user'), true);\nassert.strictEqual(canUserPerformAction(users[1], 'delete_user'), false);"]}
{"id": "39", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Interface representing a user in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n/**\n * Mock database of users.\n */\nconst usersDb: User[] = [\n    { id: 1, name: 'Alice', email: 'alice@example.com', isActive: true },\n    { id: 2, name: 'Bob', email: 'bob@example.com', isActive: false },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true }\n];\n\n/**\n * Function to find active users.\n * @returns An array of active users.\n */\nfunction findActiveUsers(): User[] {\n    return usersDb.filter(user => user.isActive);\n}\n\n/**\n * Function to deactivate a user by their email.\n * @param email - The email of the user to deactivate.\n * @returns The updated user object, or null if no user was found.\n */\nfunction deactivateUserByEmail(email: string): User | null {\n    const user = usersDb.find(user => user.email === email);\n    if (user) {\n        user.isActive = false;\n        return user;\n    }\n    return null;\n}\n\n/**\n * Function to validate user email format.\n * @param email - The email to validate.\n * @returns True if the email format is valid, otherwise false.\n */\nfunction validateEmailFormat(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\n\n/**\n * Function to add a new user to the database.\n * @param user - The user object to add.\n * @returns The added user object.\n * @throws Error if the user with the same email already exists.\n */\n", "suffix": "\n/**\n * Function to activate a user by their email.\n * @param email - The email of the user to activate.\n * @returns The updated user object, or null if no user was found.\n */\nfunction activateUserByEmail(email: string): User | null {\n    const user = usersDb.find(user => user.email === email);\n    if (user) {\n        user.isActive = true;\n        return user;\n    }\n    return null;\n}\n\n// Test cases\nassert.deepStrictEqual(findActiveUsers().map(user => user.email), ['alice@example.com', 'charlie@example.com']);\nassert.strictEqual(deactivateUserByEmail('alice@example.com')?.isActive, false);\nassert.strictEqual(activateUserByEmail('bob@example.com')?.isActive, true);\nassert.strictEqual(validateEmailFormat('invalid-email'), false);\nassert.strictEqual(validateEmailFormat('valid@example.com'), true);\n", "golden_completion": "\nfunction addUser(user: User): User {\n    if (usersDb.some(existingUser => existingUser.email === user.email)) {\n        throw new Error('User with the same email already exists.');\n    }\n    usersDb.push(user);\n    return user;\n}\n", "LLM_justification": "This test case is a good example because it covers both code-to-comment and comment-to-code translations. The prefix establishes a comprehensive context with multiple functions related to user management, including complex business logic for activating and deactivating users, and email validation. The golden completion requires generating a new function with proper error handling and adds a new user to the database, following the existing patterns. This scenario ensures that the LLM can understand and generate documentation and code consistently, while the assertions verify the functional correctness of the entire implementation.", "assertions": "assert.throws(() => addUser({ id: 4, name: 'Alice', email: 'alice@example.com', isActive: true }), /User with the same email already exists./);\nassert.deepStrictEqual(addUser({ id: 4, name: 'Dave', email: 'dave@example.com', isActive: true }), { id: 4, name: 'Dave', email: 'dave@example.com', isActive: true });", "DeepSeek-V3-0324_completion_0": "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "DeepSeek-V3-0324_completion_1": "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "DeepSeek-V3-0324_completion_2": "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "DeepSeek-V3-0324_completion_3": "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "DeepSeek-V3-0324_completion_4": "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "DeepSeek-V3-0324_completions": ["function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}", "function addUser(user: User): User {\n    if (usersDb.some(u => u.email === user.email)) {\n        throw new Error('User with this email already exists');\n    }\n    usersDb.push(user);\n    return user;\n}"]}
{"id": "40", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\ninterface Policy {\n    id: number;\n    name: string;\n    rules: string[];\n}\n\n", "suffix": "\n\nconst user: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\nconst policy: Policy = { id: 1, name: 'Email Domain Policy', rules: ['domain:example.com', 'domain:test.com'] };\n\nassert(validateUserPolicy(user, policy) === true);\n\n// Further logic to handle policy enforcement\nconst invalidUser: User = { id: 2, name: 'Jane Smith', email: 'jane.smith@invalid.com' };\nassert(validateUserPolicy(invalidUser, policy) === false);\n\n// Cleanup resources if any\n// (In this example, there are no resources to cleanup)\n", "golden_completion": "/**\n * Validates if a user complies with the given policy.\n * @param user - The user to be validated.\n * @param policy - The policy to check against.\n * @returns A boolean indicating if the user complies with the policy.\n * @throws Will throw an error if the policy rules are malformed.\n */\nfunction validateUserPolicy(user: User, policy: Policy): boolean {\n    // Check if user email domain is allowed by policy\n    const allowedDomains = policy.rules.filter(rule => rule.startsWith('domain:')).map(rule => rule.split(':')[1]);\n    const userDomain = user.email.split('@')[1];\n    if (allowedDomains.includes(userDomain)) {\n        return true;\n    }\n    return false;\n}\n", "LLM_justification": "This test case provides a realistic business logic scenario where a user's email domain must comply with policy rules. The prefix includes a function with partial comments, and the golden completion extends the documentation to cover all necessary details, including error handling. The suffix introduces an additional test case, and the assertions verify the functionality, making this a comprehensive test for both code-to-comment and comment-to-code translation.", "assertions": "const userTest: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\nconst policyTest: Policy = { id: 1, name: 'Email Domain Policy', rules: ['domain:example.com', 'domain:test.com'] };\nconst docString = `/**\n * Validates if a user complies with the given policy.\n * @param user - The user to be validated.\n * @param policy - The policy to check against.\n * @returns A boolean indicating if the user complies with the policy.\n * @throws Will throw an error if the policy rules are malformed.\n */`;\nassert(docString.toLowerCase().includes('validates if a user complies with the given policy'));\nassert(docString.includes('@param user - The user to be validated'));\nassert(docString.includes('@param policy - The policy to check against'));\nassert(docString.includes('@returns A boolean indicating if the user complies with the policy'));\nassert(docString.includes('@throws Will throw an error if the policy rules are malformed'));\nassert(validateUserPolicy(userTest, policyTest) === true);\nconst invalidUserTest: User = { id: 2, name: 'Jane Smith', email: 'jane.smith@invalid.com' };\nassert(validateUserPolicy(invalidUserTest, policyTest) === false);", "DeepSeek-V3-0324_completion_0": "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const emailDomain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule === `domain:${emailDomain}`);\n}", "DeepSeek-V3-0324_completion_1": "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const domain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule.endsWith(domain));\n}", "DeepSeek-V3-0324_completion_2": "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const domain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule.endsWith(domain));\n}", "DeepSeek-V3-0324_completion_3": "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const domain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule === `domain:${domain}`);\n}", "DeepSeek-V3-0324_completion_4": "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const domain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule.endsWith(domain));\n}", "DeepSeek-V3-0324_completions": ["function validateUserPolicy(user: User, policy: Policy): boolean {\n    const emailDomain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule === `domain:${emailDomain}`);\n}", "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const domain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule.endsWith(domain));\n}", "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const domain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule.endsWith(domain));\n}", "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const domain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule === `domain:${domain}`);\n}", "function validateUserPolicy(user: User, policy: Policy): boolean {\n    const domain = user.email.split('@')[1];\n    return policy.rules.some(rule => rule.endsWith(domain));\n}"]}
{"id": "41", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a User in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n/**\n * Function to validate if a user email follows a specific business rule.\n * The email must be a valid email format and must belong to a specific domain (example.com).\n * \n * @param email - The email address to validate.\n * @returns True if the email is valid and belongs to the domain, false otherwise.\n */\nfunction validateEmail(email: string): boolean {\n    const emailPattern = /^[^@\\s]+@example\\.com$/;\n    return emailPattern.test(email);\n}\n\n/**\n * Function to activate a user if their email is valid.\n * \n * @param user - The user object to be activated.\n * @returns The updated user object.\n */\nfunction activateUser(user: User): User {\n    if (validateEmail(user.email)) {\n        user.isActive = true;\n    } else {\n        throw new Error('Invalid email address');\n    }\n    return user;\n}\n\n// Setting up mock users for testing\nconst user1: User = { id: 1, name: 'Alice', email: 'alice@example.com', isActive: false };\nconst user2: User = { id: 2, name: 'Bob', email: 'bob@notexample.com', isActive: false };\n\n// Test cases to validate the functionality\ntry {\n    const updatedUser1 = activateUser(user1);\n    assert.strictEqual(updatedUser1.isActive, true);\n\n    // This should throw an error due to invalid email\n    const updatedUser2 = activateUser(user2);\n} catch (error) {\n    assert.strictEqual(error.message, 'Invalid email address');\n}\n\n/**\n * Function to deactivate a user.\n * \n * @param user - The user object to be deactivated.\n * @returns The updated user object.\n */", "suffix": "\n\n// Test deactivating user\nconst deactivatedUser = deactivateUser(user1);\nassert.strictEqual(deactivatedUser.isActive, false);\n\nconsole.log('All tests passed successfully.');", "golden_completion": "\nfunction deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}\n", "LLM_justification": "This example tests both code-to-comment and comment-to-code capabilities by providing a complex business logic for user activation based on email validation. The prefix includes detailed TypeScript types and interfaces, along with helper functions and comprehensive comments. The golden_completion requires translating a detailed function documentation into code, ensuring consistency in the documentation and implementation. The suffix completes the implementation with additional functionality and tests. Assertions verify both the activation and deactivation functionalities, ensuring correctness and error handling.", "assertions": "assert.strictEqual(typeof deactivateUser, 'function');\nassert.strictEqual(deactivateUser.length, 1);\nassert.strictEqual(deactivateUser(user1).isActive, false);\nassert.strictEqual(deactivateUser({ id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true }).isActive, false);\nassert.strictEqual(deactivateUser({ id: 4, name: 'Dana', email: 'dana@example.com', isActive: false }).isActive, false);", "DeepSeek-V3-0324_completion_0": "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "DeepSeek-V3-0324_completion_1": "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "DeepSeek-V3-0324_completion_2": "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "DeepSeek-V3-0324_completion_3": "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "DeepSeek-V3-0324_completion_4": "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "DeepSeek-V3-0324_completions": ["function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}", "function deactivateUser(user: User): User {\n    user.isActive = false;\n    return user;\n}"]}
{"id": "42", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a business entity.\n */\ninterface BusinessEntity {\n    id: string;\n    name: string;\n    isActive: boolean;\n}\n\n/**\n * Configuration object for validation rules.\n */\nconst validationConfig = {\n    minNameLength: 3,\n    idPattern: /^[a-zA-Z0-9-]+$/\n};\n\n/**\n * Validates a business entity based on predefined rules.\n * @param entity - The business entity to validate.\n * @returns A string array of validation errors, or an empty array if valid.\n */\nfunction validateEntity(entity: BusinessEntity): string[] {\n    const errors: string[] = [];\n\n    // Validate ID pattern\n    if (!validationConfig.idPattern.test(entity.id)) {\n        errors.push('Invalid ID format');\n    }\n\n    // Validate name length\n    if (entity.name.length < validationConfig.minNameLength) {\n        errors.push('Name is too short');\n    }\n\n    // Validate isActive flag\n    if (typeof entity.isActive !== 'boolean') {\n        errors.push('isActive must be a boolean');\n    }\n\n    return errors;\n}\n\n// Example usage:\nconst exampleEntity: BusinessEntity = {\n    id: '123-abc',\n    name: 'Example',\n    isActive: true\n};\n\nconst validationErrors = validateEntity(exampleEntity);\nassert(validationErrors.length === 0);\n\n/**\n * Function to deactivate a business entity.\n * @param entity - The business entity to deactivate.\n * @returns A new business entity object with isActive set to false.\n */\nfunction deactivateEntity(entity: BusinessEntity): BusinessEntity {\n", "suffix": "    return {\n        ...entity,\n        isActive: false\n    };\n}\n\n// Example usage:\nconst deactivatedEntity = deactivateEntity(exampleEntity);\nassert(deactivatedEntity.isActive === false);\nassert(deactivatedEntity.id === exampleEntity.id);\nassert(deactivatedEntity.name === exampleEntity.name);\n\nconsole.log('All assertions passed.');", "golden_completion": "    if (!entity.isActive) {\n        throw new Error('Entity is already inactive');\n    }\n", "LLM_justification": "This test case provides a realistic scenario of validating and deactivating a business entity, which is a common task in business logic. The provided code includes proper TypeScript interfaces, configuration objects, and validation logic, making it comprehensive. The golden completion adds an error handling check to ensure the entity is not already inactive before deactivating it, demonstrating the model's ability to handle error scenarios. The suffix continues with the implementation, ensuring no duplication. Assertions verify the functional requirements and error handling, ensuring the code works correctly. This scenario effectively tests the LLM's ability to translate between code and documentation.", "assertions": "assert.throws(() => deactivateEntity({ id: '123-abc', name: 'Example', isActive: false }), /Entity is already inactive/);\nconst activeEntity = { id: '123-abc', name: 'Example', isActive: true };\nconst deactivated = deactivateEntity(activeEntity);\nassert(deactivated.isActive === false);\nassert(deactivated.id === activeEntity.id);\nassert(deactivated.name === activeEntity.name);\nassert(deactivateEntity.length === 1);\n", "DeepSeek-V3-0324_completion_0": "    return {\n        ...entity,\n        isActive: false\n    };", "DeepSeek-V3-0324_completion_1": "    return {\n        ...entity,\n        isActive: false\n    };", "DeepSeek-V3-0324_completion_2": "    return {\n        ...entity,\n        isActive: false\n    };", "DeepSeek-V3-0324_completion_3": "    return {\n        ...entity,\n        isActive: false\n    };", "DeepSeek-V3-0324_completion_4": "    return {\n        ...entity,\n        isActive: false\n    };", "DeepSeek-V3-0324_completions": ["    return {\n        ...entity,\n        isActive: false\n    };", "    return {\n        ...entity,\n        isActive: false\n    };", "    return {\n        ...entity,\n        isActive: false\n    };", "    return {\n        ...entity,\n        isActive: false\n    };", "    return {\n        ...entity,\n        isActive: false\n    };"]}
{"id": "43", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\n", "suffix": "class UserValidator {\n    private allowedDomain: string;\n\n    constructor(allowedDomain: string) {\n        this.allowedDomain = allowedDomain;\n    }\n\n    /**\n     * Validate the user's email.\n     * @param user - The user object containing email to validate\n     * @returns true if email is valid, false otherwise\n     */\n    validateEmail(user: User): boolean {\n        const emailParts = user.email.split('@');\n        if (emailParts.length !== 2) {\n            return false;\n        }\n        const domain = emailParts[1];\n        return domain === this.allowedDomain;\n    }\n}\n\nconst userValidator = new UserValidator('example.com');\nconst validUser: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\nconst invalidUser: User = { id: 2, name: 'Jane Smith', email: 'jane.smith@invalid.com' };\n\n\nassert.strictEqual(userValidator.validateEmail(validUser), true, 'The valid user email should be accepted.');\nassert.strictEqual(userValidator.validateEmail(invalidUser), false, 'The invalid user email should be rejected.');\n\n// Cleanup resources or perform additional logic if necessary\nconsole.log('All assertions passed.');", "golden_completion": "\n\n/**\n * UserValidator class enforces business rules for user email compliance.\n * It ensures that user emails adhere to a specific allowed domain.\n * \n * @param allowedDomain - The domain that user emails must match\n * @returns An instance of UserValidator\n * \n * Methods:\n * - validateEmail(user: User): boolean\n *   - Validates if the user's email matches the allowed domain.\n * \n * Usage example:\n * const validator = new UserValidator('example.com');\n * const user = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\n * console.log(validator.validateEmail(user)); // true\n */", "LLM_justification": "This test case demonstrates a realistic business rule validation for user email compliance. It includes TypeScript code that validates user emails against a specific allowed domain. The golden completion provides comprehensive documentation for the UserValidator class, including its constructor, methods, and usage example. This tests the LLM's ability to generate accurate and detailed documentation for existing code, ensuring clear communication and understanding of the code's functionality. The assertions verify the correctness of the email validation logic, testing both valid and invalid scenarios.", "assertions": "const docString = `/**\n * UserValidator class enforces business rules for user email compliance.\n * It ensures that user emails adhere to a specific allowed domain.\n * \n * @param allowedDomain - The domain that user emails must match\n * @returns An instance of UserValidator\n * \n * Methods:\n * - validateEmail(user: User): boolean\n *   - Validates if the user's email matches the allowed domain.\n * \n * Usage example:\n * const validator = new UserValidator('example.com');\n * const user = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\n * console.log(validator.validateEmail(user)); // true\n */`;\nassert(docString.toLowerCase().includes('business rules'));\nassert(docString.includes('allowed domain'));\nassert(docString.includes('@param allowedDomain'));\nassert(docString.includes('@returns An instance of UserValidator'));\nassert(docString.includes('validateEmail(user: User): boolean'));\nassert(docString.includes('Usage example:'));\nassert(docString.includes('const validator = new UserValidator('));", "DeepSeek-V3-0324_completion_0": "    private allowedDomain: string;\n\n    constructor(allowedDomain: string) {\n        this.allowedDomain = allowedDomain;\n    }\n\n    /**\n     * Validate the user's email.\n     * @param user - The user object containing email to validate\n     * @returns true if email is valid, false otherwise\n     */\n    validateEmail(user: User): boolean {\n        const emailParts = user.email.split('@');\n        if (emailParts.length !== 2) {\n            return false;\n        }\n        const domain = emailParts[1];\n        return domain === this.allowedDomain;\n    }\n}\n\nconst userValidator = new UserValidator('example.com');\nconst validUser: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\nconst invalidUser: User = { id: 2, name: 'Jane Smith', email: 'jane.smith@invalid.com' };\n\n\nassert.strictEqual(userValidator.validateEmail(validUser), true, 'The valid user email should be accepted.');\nassert.strictEqual(userValidator.validateEmail(invalidUser), false, 'The invalid user email should be rejected.');\n\n// Cleanup resources or perform additional logic if necessary\nconsole.log('All assertions passed.');", "DeepSeek-V3-0324_completion_1": "    validate(user: User): boolean {\n        return this.validateEmail(user);\n    }", "DeepSeek-V3-0324_completion_2": "    validate(user: User): boolean {\n        return this.validateEmail(user);\n    }", "DeepSeek-V3-0324_completion_3": "    validate(user: User): boolean {\n        return this.validateEmail(user);\n    }", "DeepSeek-V3-0324_completion_4": "    validate(user: User): boolean {\n        return this.validateEmail(user);\n    }", "DeepSeek-V3-0324_completions": ["    private allowedDomain: string;\n\n    constructor(allowedDomain: string) {\n        this.allowedDomain = allowedDomain;\n    }\n\n    /**\n     * Validate the user's email.\n     * @param user - The user object containing email to validate\n     * @returns true if email is valid, false otherwise\n     */\n    validateEmail(user: User): boolean {\n        const emailParts = user.email.split('@');\n        if (emailParts.length !== 2) {\n            return false;\n        }\n        const domain = emailParts[1];\n        return domain === this.allowedDomain;\n    }\n}\n\nconst userValidator = new UserValidator('example.com');\nconst validUser: User = { id: 1, name: 'John Doe', email: 'john.doe@example.com' };\nconst invalidUser: User = { id: 2, name: 'Jane Smith', email: 'jane.smith@invalid.com' };\n\n\nassert.strictEqual(userValidator.validateEmail(validUser), true, 'The valid user email should be accepted.');\nassert.strictEqual(userValidator.validateEmail(invalidUser), false, 'The invalid user email should be rejected.');\n\n// Cleanup resources or perform additional logic if necessary\nconsole.log('All assertions passed.');", "    validate(user: User): boolean {\n        return this.validateEmail(user);\n    }", "    validate(user: User): boolean {\n        return this.validateEmail(user);\n    }", "    validate(user: User): boolean {\n        return this.validateEmail(user);\n    }", "    validate(user: User): boolean {\n        return this.validateEmail(user);\n    }"]}
{"id": "44", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import * as assert from 'assert';\n\n/**\n * Interface representing a user in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    isActive: boolean;\n}\n\n/**\n * Enum representing different types of user roles.\n */\nenum UserRole {\n    ADMIN = 'admin',\n    USER = 'user',\n    GUEST = 'guest'\n}\n\n/**\n * Function to determine if a user has admin privileges.\n * @param user - The user object.\n * @param role - The role of the user.\n * @returns True if the user is an admin, otherwise false.\n */\nfunction isAdmin(user: User, role: UserRole): boolean {\n    return role === UserRole.ADMIN;\n}\n\n/**\n * Function to toggle the activation status of a user.\n * @param user - The user object.\n * @returns The updated user object with toggled activation status.\n */\nfunction toggleUserActivation(user: User): User {\n    return { ...user, isActive: !user.isActive };\n}\n\n/**\n * Function to filter active users from a list.\n * @param users - Array of user objects.\n * @returns Array of active user objects.\n */\nfunction filterActiveUsers(users: User[]): User[] {\n    return users.filter(user => user.isActive);\n}\n\n/**\n * Class representing the user management system.\n */\nclass UserManager {\n    private users: User[] = [];\n\n    /**\n     * Add a new user to the system.\n     * @param user - The user object to add.\n     */\n    addUser(user: User): void {\n        this.users.push(user);\n    }\n\n    /**\n     * Remove a user from the system by ID.\n     * @param userId - The ID of the user to remove.\n     * @returns True if the user was removed, otherwise false.\n     */\n    removeUser(userId: number): boolean {\n        const index = this.users.findIndex(user => user.id === userId);\n        if (index !== -1) {\n            this.users.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get a list of all users in the system.\n     * @returns Array of user objects.\n     */\n    getUsers(): User[] {\n        return this.users;\n    }\n\n    /**\n     * Get a list of all active users in the system.\n     * @returns Array of active user objects.\n     */\n    getActiveUsers(): User[] {\n        return filterActiveUsers(this.users);\n    }\n", "suffix": "}\n\nconst userManager = new UserManager();\nuserManager.addUser({ id: 1, name: 'Alice', email: 'alice@example.com', isActive: true });\nuserManager.addUser({ id: 2, name: 'Bob', email: 'bob@example.com', isActive: false });\n\nassert.strictEqual(userManager.getUsers().length, 2);\nassert.strictEqual(userManager.getActiveUsers().length, 1);\nassert.strictEqual(userManager.removeUser(1), true);\nassert.strictEqual(userManager.getUsers().length, 1);\nassert.strictEqual(userManager.getActiveUsers().length, 0);\nuserManager.addUser({ id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true });\nassert.strictEqual(userManager.getUsers().length, 2);\nassert.strictEqual(userManager.getActiveUsers().length, 1);\n", "golden_completion": "/**\n     * Update a user's email address.\n     * @param userId - The ID of the user to update.\n     * @param newEmail - The new email address to set.\n     * @returns True if the email was updated, otherwise false.\n     */\n    updateUserEmail(userId: number, newEmail: string): boolean {\n        const user = this.users.find(user => user.id === userId);\n        if (user) {\n            user.email = newEmail;\n            return true;\n        }\n        return false;\n    }\n", "LLM_justification": "This scenario is a good test case because it covers a comprehensive implementation of a user management system, including class definitions, interface usage, and various utility functions. The golden completion focuses on adding a new function with detailed documentation, which requires understanding of the context provided in the prefix. This tests the LLM's ability to generate code from comments, ensuring alignment between natural language descriptions and code implementation. The assertions verify functional correctness of the implementation, while the structure and comments ensure clarity and maintainability.", "assertions": "assert.strictEqual(userManager.updateUserEmail(3, 'charlie.new@example.com'), true);\nassert.strictEqual(userManager.getUsers().find(user => user.id === 3)?.email, 'charlie.new@example.com');\n", "DeepSeek-V3-0324_completion_0": "    }", "DeepSeek-V3-0324_completion_1": "    }", "DeepSeek-V3-0324_completion_2": "    }", "DeepSeek-V3-0324_completion_3": "    }", "DeepSeek-V3-0324_completion_4": "    }", "DeepSeek-V3-0324_completions": ["    }", "    }", "    }", "    }", "    }"]}
{"id": "45", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Represents a user in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\n/**\n * Represents a policy that must be enforced.\n */\ninterface Policy {\n    id: number;\n    name: string;\n    isActive: boolean;\n}\n\n/**\n * Validates if the given user complies with the active policies.\n * @param user The user to validate.\n * @param policies The list of policies to check against.\n * @returns True if the user complies with all active policies, false otherwise.\n */\nfunction validateUserCompliance(user: User, policies: Policy[]): boolean {\n    for (const policy of policies) {\n        if (policy.isActive) {\n            // Complex validation logic for each policy\n            if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                return false;\n            }\n            // More business rules can be added here\n        }\n    }\n    return true;\n}\n\n/**\n * Example usage of validateUserCompliance function.\n */\nconst user: User = { id: 1, name: 'John Doe', email: 'johndoe@example.com' };\nconst policies: Policy[] = [\n    { id: 1, name: 'EmailVerified', isActive: true },\n    { id: 2, name: 'ProfileComplete', isActive: false }\n];\n\nconst isCompliant = validateUserCompliance(user, policies);\nassert.strictEqual(isCompliant, true);\n\nconst nonCompliantUser: User = { id: 2, name: 'Jane Doe', email: 'janedoeexample.com' };\nconst isNonCompliant = validateUserCompliance(nonCompliantUser, policies);\nassert.strictEqual(isNonCompliant, false);\n\n/**\n * Error handling logic for user compliance validation.\n * This function will log an error message if a user does not comply with active policies.\n * @param user The user to validate.\n * @param policies The list of policies to check against.\n * @returns True if the user complies with all active policies, false otherwise.\n */\n", "suffix": "const compliantUser: User = { id: 3, name: 'Alice Smith', email: 'alice@example.com' };\nconst isCompliantWithErrorHandling = validateUserComplianceWithErrorHandling(compliantUser, policies);\nassert.strictEqual(isCompliantWithErrorHandling, true);\n\nconst nonCompliantUserWithErrorHandling: User = { id: 4, name: 'Bob Brown', email: 'bobexample.com' };\nconst isNonCompliantWithErrorHandling = validateUserComplianceWithErrorHandling(nonCompliantUserWithErrorHandling, policies);\nassert.strictEqual(isNonCompliantWithErrorHandling, false);\n", "golden_completion": "\nfunction validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        return validateUserCompliance(user, policies);\n    } catch (error) {\n        console.error(`Error validating user compliance: ${error.message}`);\n        return false;\n    }\n}\n", "LLM_justification": "This test case provides a realistic business logic scenario where user compliance with certain policies is validated. It includes both code-to-comment and comment-to-code translation tasks. The detailed documentation in the golden_completion explains the error handling logic, which is critical for understanding the implementation. The assertions test both compliant and non-compliant scenarios, ensuring the function behaves correctly under different conditions. This scenario effectively tests the LLM's ability to translate between code and natural language, handle complex business rules, and document error handling logic.", "assertions": "const docString = `/**\n * Error handling logic for user compliance validation.\n * This function will log an error message if a user does not comply with active policies.\n * @param user The user to validate.\n * @param policies The list of policies to check against.\n * @returns True if the user complies with all active policies, false otherwise.\n */`;\nassert(docString.toLowerCase().includes('error handling logic'));\nassert(docString.includes('@param user'));\nassert(docString.includes('@param policies'));\nassert(docString.includes('@returns'));\nassert(docString.includes('log an error message if a user does not comply with active policies'));\n", "DeepSeek-V3-0324_completion_0": "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        for (const policy of policies) {\n            if (policy.isActive) {\n                if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                    console.error(`User ${user.name} does not comply with policy ${policy.name}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error('An error occurred during compliance validation:', error);\n        return false;\n    }\n}", "DeepSeek-V3-0324_completion_1": "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        for (const policy of policies) {\n            if (policy.isActive) {\n                if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                    console.error(`User ${user.name} does not comply with policy ${policy.name}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error('Error during compliance validation:', error);\n        return false;\n    }\n}", "DeepSeek-V3-0324_completion_2": "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        for (const policy of policies) {\n            if (policy.isActive) {\n                if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                    console.error(`User ${user.name} does not comply with policy ${policy.name}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error('An error occurred during compliance validation:', error);\n        return false;\n    }\n}", "DeepSeek-V3-0324_completion_3": "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        return validateUserCompliance(user, policies);\n    } catch (error) {\n        console.error(`Error validating user compliance: ${error}`);\n        return false;\n    }\n}", "DeepSeek-V3-0324_completion_4": "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        for (const policy of policies) {\n            if (policy.isActive) {\n                if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                    console.error(`User ${user.name} does not comply with policy ${policy.name}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error('An error occurred during compliance validation:', error);\n        return false;\n    }\n}", "DeepSeek-V3-0324_completions": ["function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        for (const policy of policies) {\n            if (policy.isActive) {\n                if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                    console.error(`User ${user.name} does not comply with policy ${policy.name}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error('An error occurred during compliance validation:', error);\n        return false;\n    }\n}", "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        for (const policy of policies) {\n            if (policy.isActive) {\n                if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                    console.error(`User ${user.name} does not comply with policy ${policy.name}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error('Error during compliance validation:', error);\n        return false;\n    }\n}", "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        for (const policy of policies) {\n            if (policy.isActive) {\n                if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                    console.error(`User ${user.name} does not comply with policy ${policy.name}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error('An error occurred during compliance validation:', error);\n        return false;\n    }\n}", "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        return validateUserCompliance(user, policies);\n    } catch (error) {\n        console.error(`Error validating user compliance: ${error}`);\n        return false;\n    }\n}", "function validateUserComplianceWithErrorHandling(user: User, policies: Policy[]): boolean {\n    try {\n        for (const policy of policies) {\n            if (policy.isActive) {\n                if (policy.name === 'EmailVerified' && !user.email.includes('@')) {\n                    console.error(`User ${user.name} does not comply with policy ${policy.name}`);\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (error) {\n        console.error('An error occurred during compliance validation:', error);\n        return false;\n    }\n}"]}
{"id": "46", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Interface representing a business entity.\n */\ninterface BusinessEntity {\n    id: string;\n    name: string;\n    complianceStatus: ComplianceStatus;\n}\n\n/**\n * Enum representing compliance status.\n */\nenum ComplianceStatus {\n    COMPLIANT = 'compliant',\n    NON_COMPLIANT = 'non_compliant'\n}\n\n/**\n * Function to check if a business entity is compliant.\n * @param entity - The business entity to check.\n * @returns True if the entity is compliant, otherwise false.\n */\nfunction isCompliant(entity: BusinessEntity): boolean {\n    return entity.complianceStatus === ComplianceStatus.COMPLIANT;\n}\n\n", "suffix": "\nclass BusinessRulesValidator {\n    private entities: BusinessEntity[];\n\n    constructor(entities: BusinessEntity[]) {\n        this.entities = entities;\n    }\n\n    /**\n     * Validates all business entities for compliance.\n     * @returns An array of non-compliant business entities.\n     */\n    validateCompliance(): BusinessEntity[] {\n        const nonCompliantEntities: BusinessEntity[] = [];\n        for (const entity of this.entities) {\n            if (!isCompliant(entity)) {\n                nonCompliantEntities.push(entity);\n            }\n        }\n        return nonCompliantEntities;\n    }\n}\n\n// Example usage\nconst entities: BusinessEntity[] = [\n    { id: '1', name: 'Entity1', complianceStatus: ComplianceStatus.COMPLIANT },\n    { id: '2', name: 'Entity2', complianceStatus: ComplianceStatus.NON_COMPLIANT }\n];\nconst validator = new BusinessRulesValidator(entities);\nconst nonCompliantEntities = validator.validateCompliance();\n\nassert(nonCompliantEntities.length === 1);\nassert(nonCompliantEntities[0].id === '2');\nassert(nonCompliantEntities[0].name === 'Entity2');\nassert(nonCompliantEntities[0].complianceStatus === ComplianceStatus.NON_COMPLIANT);\n", "golden_completion": "/**\n * The BusinessRulesValidator class is responsible for validating a list of business entities against compliance rules.\n * It checks each entity's compliance status and collects all non-compliant entities.\n *\n * @class BusinessRulesValidator\n * @constructor\n * @param {BusinessEntity[]} entities - The list of business entities to validate.\n *\n * @method validateCompliance\n * @returns {BusinessEntity[]} - An array of non-compliant business entities.\n *\n * Example usage:\n * typescript\n * const entities: BusinessEntity[] = [\n *     { id: '1', name: 'Entity1', complianceStatus: ComplianceStatus.COMPLIANT },\n *     { id: '2', name: 'Entity2', complianceStatus: ComplianceStatus.NON_COMPLIANT }\n * ];\n * const validator = new BusinessRulesValidator(entities);\n * const nonCompliantEntities = validator.validateCompliance();\n * console.log(nonCompliantEntities); // Outputs: [{ id: '2', name: 'Entity2', complianceStatus: ComplianceStatus.NON_COMPLIANT }]\n * \n */\n", "LLM_justification": "This test case is a good example of code-to-comment translation because it involves a realistic business scenario of validating compliance rules for business entities. The BusinessRulesValidator class contains a method to validate the compliance of a list of entities and collect non-compliant ones, demonstrating complex logic. The detailed TSDoc comments in the golden_completion provide comprehensive documentation, including parameter descriptions, return value, and usage examples. The assertions in the suffix verify the correctness of the functionality, ensuring that the class works as intended.", "assertions": "const docString = `/**\n * The BusinessRulesValidator class is responsible for validating a list of business entities against compliance rules.\n * It checks each entity's compliance status and collects all non-compliant entities.\n *\n * @class BusinessRulesValidator\n * @constructor\n * @param {BusinessEntity[]} entities - The list of business entities to validate.\n *\n * @method validateCompliance\n * @returns {BusinessEntity[]} - An array of non-compliant business entities.\n *\n * Example usage:\n * typescript\n * const entities: BusinessEntity[] = [\n *     { id: '1', name: 'Entity1', complianceStatus: ComplianceStatus.COMPLIANT },\n *     { id: '2', name: 'Entity2', complianceStatus: ComplianceStatus.NON_COMPLIANT }\n * ];\n * const validator = new BusinessRulesValidator(entities);\n * const nonCompliantEntities = validator.validateCompliance();\n * console.log(nonCompliantEntities); // Outputs: [{ id: '2', name: 'Entity2', complianceStatus: ComplianceStatus.NON_COMPLIANT }]\n * \n */`;\n\nassert(docString.toLowerCase().includes('businessrulesvalidator'));\nassert(docString.includes('@constructor'));\nassert(docString.includes('Example usage:'));\nassert(docString.includes('@returns {BusinessEntity[]}'));\nassert(docString.includes('non-compliant business entities.'));\n", "DeepSeek-V3-0324_completion_0": "    /**\n     * Gets the count of compliant entities.\n     * @returns The number of compliant entities.\n     */\n    getCompliantCount(): number {\n        let count = 0;\n        for (const entity of this.entities) {\n            if (isCompliant(entity)) {\n                count++;\n            }\n        }\n        return count;\n    }", "DeepSeek-V3-0324_completion_1": "    /**\n     * Gets all business entities.\n     * @returns An array of all business entities.\n     */\n    getEntities(): BusinessEntity[] {\n        return this.entities;\n    }", "DeepSeek-V3-0324_completion_2": "    /**\n     * Checks if all business entities are compliant.\n     * @returns True if all entities are compliant, otherwise false.\n     */\n    allCompliant(): boolean {\n        return this.entities.every(isCompliant);\n    }", "DeepSeek-V3-0324_completion_3": "    /**\n     * Gets all business entities.\n     * @returns An array of all business entities.\n     */\n    getEntities(): BusinessEntity[] {\n        return this.entities;\n    }", "DeepSeek-V3-0324_completion_4": "    /**\n     * Gets all compliant business entities.\n     * @returns An array of compliant business entities.\n     */\n    getCompliantEntities(): BusinessEntity[] {\n        const compliantEntities: BusinessEntity[] = [];\n        for (const entity of this.entities) {\n            if (isCompliant(entity)) {\n                compliantEntities.push(entity);\n            }\n        }\n        return compliantEntities;\n    }", "DeepSeek-V3-0324_completions": ["    /**\n     * Gets the count of compliant entities.\n     * @returns The number of compliant entities.\n     */\n    getCompliantCount(): number {\n        let count = 0;\n        for (const entity of this.entities) {\n            if (isCompliant(entity)) {\n                count++;\n            }\n        }\n        return count;\n    }", "    /**\n     * Gets all business entities.\n     * @returns An array of all business entities.\n     */\n    getEntities(): BusinessEntity[] {\n        return this.entities;\n    }", "    /**\n     * Checks if all business entities are compliant.\n     * @returns True if all entities are compliant, otherwise false.\n     */\n    allCompliant(): boolean {\n        return this.entities.every(isCompliant);\n    }", "    /**\n     * Gets all business entities.\n     * @returns An array of all business entities.\n     */\n    getEntities(): BusinessEntity[] {\n        return this.entities;\n    }", "    /**\n     * Gets all compliant business entities.\n     * @returns An array of compliant business entities.\n     */\n    getCompliantEntities(): BusinessEntity[] {\n        const compliantEntities: BusinessEntity[] = [];\n        for (const entity of this.entities) {\n            if (isCompliant(entity)) {\n                compliantEntities.push(entity);\n            }\n        }\n        return compliantEntities;\n    }"]}
{"id": "47", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n/**\n * Represents a user in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    roles: string[];\n}\n\n/**\n * Validates if the given user complies with the business rules.\n *\n * Business Rules:\n * 1. A user must have at least one role.\n * 2. A user must have a valid email format.\n *\n * @param user The user object to validate.\n * @returns An array of error messages, empty if the user is valid.\n */\nfunction validateUser(user: User): string[] {\n    const errors: string[] = [];\n\n    // Ensure the user has at least one role\n    if (user.roles.length === 0) {\n        errors.push('User must have at least one role.');\n    }\n\n    // Ensure the email format is valid\n    const emailRegex = /^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\n    if (!emailRegex.test(user.email)) {\n        errors.push('Invalid email format.');\n    }\n\n    return errors;\n}\n\n// Example usage\nconst user: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'johndoe@example.com',\n    roles: ['admin']\n};\n\nconst validationErrors = validateUser(user);\n\n/**\n * Schedules a task for the user based on their role.\n *\n * Rules:\n * 1. Admin users should have daily tasks.\n * 2. General users should have weekly tasks.\n * 3. If a user has both roles, prioritize daily tasks.\n *\n * @param user The user object\n */\nfunction scheduleUserTasks(user: User): void {\n", "suffix": "\n}\n\n// Additional usage example for scheduling tasks\nconst taskUser: User = {\n    id: 2,\n    name: 'Jane Smith',\n    email: 'jane.smith@example.com',\n    roles: ['user', 'admin']\n};\n\nscheduleUserTasks(taskUser);\n", "golden_completion": "    // Determine the schedule based on the user roles\n    if (user.roles.includes('admin')) {\n        console.log(`${user.name} has been scheduled for daily tasks.`);\n    } else if (user.roles.includes('user')) {\n        console.log(`${user.name} has been scheduled for weekly tasks.`);\n    } else {\n        console.log(`${user.name} does not have a valid role for task scheduling.`);\n    }\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to translate between code and natural language effectively. The prefix provides detailed context with TypeScript interfaces, function definitions, and complex business logic. The golden_completion requires implementing a function based on the provided documentation, ensuring the LLM can interpret and generate accurate code. The suffix continues the scenario with additional usage, and the assertions test the functional requirements.", "assertions": "assert(validationErrors.length === 0);\nassert.doesNotThrow(() => scheduleUserTasks(taskUser));", "DeepSeek-V3-0324_completion_0": "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "DeepSeek-V3-0324_completion_1": "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "DeepSeek-V3-0324_completion_2": "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "DeepSeek-V3-0324_completion_3": "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "DeepSeek-V3-0324_completion_4": "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "DeepSeek-V3-0324_completions": ["    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }", "    if (user.roles.includes('admin')) {\n        console.log('Scheduling daily tasks for admin user.');\n    } else if (user.roles.includes('user')) {\n        console.log('Scheduling weekly tasks for general user.');\n    }"]}
{"id": "48", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * This module defines a class and related functions for managing a simple in-memory cache.\n * The cache supports basic operations such as adding, retrieving, and invalidating entries.\n */\n\ninterface CacheEntry<T> {\n    value: T;\n    expiry: number;\n}\n\n", "suffix": "class SimpleCache<T> {\n    private cache: Map<string, CacheEntry<T>>;\n    private defaultTTL: number;\n\n    constructor(defaultTTL: number = 60000) {\n        this.cache = new Map();\n        this.defaultTTL = defaultTTL;\n    }\n\n    /**\n     * Adds an entry to the cache with an optional TTL (time-to-live).\n     * @param key - The key under which the entry is stored.\n     * @param value - The value to be cached.\n     * @param ttl - Optional TTL for the entry. If not provided, default TTL is used.\n     */\n    add(key: string, value: T, ttl?: number): void {\n        const expiry = Date.now() + (ttl ?? this.defaultTTL);\n        this.cache.set(key, { value, expiry });\n    }\n\n    /**\n     * Retrieves an entry from the cache if it exists and has not expired.\n     * @param key - The key of the entry to retrieve.\n     * @returns The cached value or undefined if the entry does not exist or has expired.\n     */\n    get(key: string): T | undefined {\n        const entry = this.cache.get(key);\n        if (entry && entry.expiry > Date.now()) {\n            return entry.value;\n        }\n        this.cache.delete(key);\n        return undefined;\n    }\n\n    /**\n     * Invalidates an entry in the cache.\n     * @param key - The key of the entry to invalidate.\n     */\n    invalidate(key: string): void {\n        this.cache.delete(key);\n    }\n\n    /**\n     * Clears all entries in the cache.\n     */\n    clear(): void {\n        this.cache.clear();\n    }\n}\n\nconst cache = new SimpleCache<number>();\ncache.add('key1', 42);\nassert.strictEqual(cache.get('key1'), 42);\n\n\ncache.invalidate('key1');\nassert.strictEqual(cache.get('key1'), undefined);\ncache.add('key2', 84, 100);\nassert.strictEqual(cache.get('key2'), 84);\n\nsetTimeout(() => {\n    assert.strictEqual(cache.get('key2'), undefined);\n}, 150);\n\ncache.clear();\nassert.strictEqual(cache.get('key1'), undefined);\nassert.strictEqual(cache.get('key2'), undefined);\n", "golden_completion": "/**\n * Class representing a simple in-memory cache.\n * \n * @template T - The type of the values being cached.\n * \n * @property {Map<string, CacheEntry<T>>} cache - The internal map storing cache entries.\n * @property {number} defaultTTL - The default time-to-live for cache entries in milliseconds.\n * \n * @method add - Adds an entry to the cache.\n * @method get - Retrieves an entry from the cache.\n * @method invalidate - Invalidates an entry in the cache.\n * @method clear - Clears all entries in the cache.\n * \n * @example\n * const cache = new SimpleCache<number>();\n * cache.add('key1', 42);\n * console.log(cache.get('key1')); // 42\n * cache.invalidate('key1');\n * console.log(cache.get('key1')); // undefined\n */\n", "LLM_justification": "This example presents a realistic scenario of a simple in-memory cache management system, providing a comprehensive class definition and methods. The golden completion includes detailed TSDoc comments that describe the class, its properties, and methods, along with usage examples. This tests an LLM's ability to generate accurate and complete documentation for a given TypeScript implementation, ensuring alignment between code and comments. The assertions verify the correct behavior of the cache methods, including edge cases and error handling.", "assertions": "// Test adding and retrieving a cache entry\nconst testCache = new SimpleCache<number>();\ntestCache.add('key1', 42);\nassert.strictEqual(testCache.get('key1'), 42);\n\n// Test invalidating a cache entry\ntestCache.invalidate('key1');\nassert.strictEqual(testCache.get('key1'), undefined);\n\n// Test adding a cache entry with a custom TTL and automatic expiration\ntestCache.add('key2', 84, 100);\nassert.strictEqual(testCache.get('key2'), 84);\n\nsetTimeout(() => {\n    assert.strictEqual(testCache.get('key2'), undefined);\n}, 150);\n\n// Test clearing the cache\ntestCache.clear();\nassert.strictEqual(testCache.get('key1'), undefined);\nassert.strictEqual(testCache.get('key2'), undefined);", "DeepSeek-V3-0324_completion_0": "export ", "DeepSeek-V3-0324_completion_1": "export ", "DeepSeek-V3-0324_completion_2": "export ", "DeepSeek-V3-0324_completion_3": "export ", "DeepSeek-V3-0324_completion_4": "export ", "DeepSeek-V3-0324_completions": ["export ", "export ", "export ", "export ", "export "]}
{"id": "49", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import assert from 'assert';\n\n// Utility functions\nfunction isValidEmail(email: string): boolean {\n    const emailRegex = /^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\n    return emailRegex.test(email);\n}\n\nfunction isValidPhoneNumber(phone: string): boolean {\n    const phoneRegex = /^\\+?\\d{10,15}$/;\n    return phoneRegex.test(phone);\n}\n\n// Business entity definition\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    phone: string;\n}\n\n", "suffix": "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}\n\n// Example user data\nconst user1: User = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n    phone: '+1234567890'\n};\n\nconst user2: User = {\n    id: 2,\n    name: '',\n    email: 'invalid-email',\n    phone: '123'\n};\n\n// Validate users\nconst errors1 = validateUser(user1);\nconst errors2 = validateUser(user2);\n\n// Assertions\nassert(errors1.length === 0, 'User 1 should have no validation errors');\nassert(errors2.length === 3, 'User 2 should have three validation errors');\nassert(errors2.includes('Name is required'), 'User 2 should have a missing name error');\nassert(errors2.includes('Invalid email address'), 'User 2 should have an invalid email error');\nassert(errors2.includes('Invalid phone number'), 'User 2 should have an invalid phone number error');\n\n// Clean up resources if any (in this case, none required)\n", "golden_completion": "/**\n * Validates the given user data and returns a list of validation errors.\n *\n * @param user - The user object containing user data to validate\n * @returns An array of strings representing validation error messages\n *\n * @example\n * typescript\n * const user: User = {\n *     id: 1,\n *     name: 'John Doe',\n *     email: 'john.doe@example.com',\n *     phone: '+1234567890'\n * };\n * const errors = validateUser(user);\n * console.log(errors); // []\n * \n */", "LLM_justification": "This test case is an excellent example for evaluating an LLM's ability to translate between TypeScript code and natural language documentation. The prefix contains a substantial amount of setup code, including utility functions, an interface definition, and a function implementing business logic validation. The golden completion requires the model to generate comprehensive TSDoc comments for the validateUser function, including parameter descriptions, return value documentation, and usage examples. The suffix includes assertions that verify the correctness of the function's behavior, ensuring that the model's generated documentation accurately describes the implemented logic. This scenario tests the LLM's ability to understand and document complex business logic, handle error conditions, and provide clear examples.", "assertions": "const docString = `/**\n * Validates the given user data and returns a list of validation errors.\n *\n * @param user - The user object containing user data to validate\n * @returns An array of strings representing validation error messages\n *\n * @example\n * typescript\n * const user: User = {\n *     id: 1,\n *     name: 'John Doe',\n *     email: 'john.doe@example.com',\n *     phone: '+1234567890'\n * };\n * const errors = validateUser(user);\n * console.log(errors); // []\n * \n */`;\n\nassert(docString.toLowerCase().includes('validates the given user data and returns a list of validation errors'), 'Documentation should describe the function purpose');\nassert(docString.includes('@param user - The user object containing user data to validate'), 'Documentation should include @param for user');\nassert(docString.includes('@returns An array of strings representing validation error messages'), 'Documentation should include @returns description');\nassert(docString.includes('@example'), 'Documentation should include an example');", "DeepSeek-V3-0324_completion_0": "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "DeepSeek-V3-0324_completion_1": "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "DeepSeek-V3-0324_completion_2": "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "DeepSeek-V3-0324_completion_3": "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "DeepSeek-V3-0324_completion_4": "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "DeepSeek-V3-0324_completions": ["function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}", "function validateUser(user: User): string[] {\n    const errors: string[] = [];\n    if (!user.name) {\n        errors.push('Name is required');\n    }\n    if (!isValidEmail(user.email)) {\n        errors.push('Invalid email address');\n    }\n    if (!isValidPhoneNumber(user.phone)) {\n        errors.push('Invalid phone number');\n    }\n    return errors;\n}"]}
{"id": "50", "testsource": "devbench-code2NL-NL2code", "language": "typescript", "prefix": "import { strict as assert } from 'assert';\n\n/**\n * Represents a user in the system.\n */\ninterface User {\n    id: number;\n    name: string;\n    isActive: boolean;\n}\n\n/**\n * Error thrown when a user is not found.\n */\nclass UserNotFoundError extends Error {\n    constructor(userId: number) {\n        super(`User with ID ${userId} not found.`);\n        this.name = 'UserNotFoundError';\n    }\n}\n\n/**\n * A mock database of users.\n */\nconst users: User[] = [\n    { id: 1, name: 'Alice', isActive: true },\n    { id: 2, name: 'Bob', isActive: false },\n    { id: 3, name: 'Charlie', isActive: true }\n];\n\n/**\n * Fetches a user by ID from the mock database.\n * @param userId - The ID of the user to fetch.\n * @returns The user object if found.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction getUserById(userId: number): User {\n    const user = users.find(u => u.id === userId);\n    if (!user) {\n        throw new UserNotFoundError(userId);\n    }\n    return user;\n}\n\n/**\n * Activates a user by setting their isActive status to true.\n * @param userId - The ID of the user to activate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction activateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = true;\n}\n\n", "suffix": "// Example usage and assertions\ntry {\n    activateUser(2);\n    assert.strictEqual(users[1].isActive, true, 'User 2 should be activated');\n    deactivateUser(1);\n    assert.strictEqual(users[0].isActive, false, 'User 1 should be deactivated');\n    try {\n        getUserById(99);\n    } catch (error) {\n        assert(error instanceof UserNotFoundError, 'Should throw UserNotFoundError for non-existent user');\n    }\n} finally {\n    // Cleanup if necessary (not needed in this example as we are using an in-memory mock database)\n}", "golden_completion": "\n\n/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "LLM_justification": "This test case is a good example of translating between code and natural language because it includes complex business logic for user activation and deactivation, along with error handling. The prefix includes detailed documentation and type annotations, while the golden_completion requires comprehensive documentation of the activateUser and deactivateUser functions. The suffix includes additional assertions to verify the correctness of the implementation and error handling. This scenario tests the LLM's ability to generate accurate documentation and code translations in a realistic business context.", "assertions": "const docString = `/**\n * Activates a user by setting their isActive status to true.\n * @param userId - The ID of the user to activate.\n * @throws UserNotFoundError if the user is not found.\n */`;\nassert(docString.includes('Activates a user by setting their isActive status to true'));\nassert(docString.includes('@param userId'));\nassert(docString.includes('userId - The ID of the user to activate'));\nassert(docString.includes('throws UserNotFoundError if the user is not found'));\nconst docString2 = `/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */`;\nassert(docString2.includes('Deactivates a user by setting their isActive status to false'));\nassert(docString2.includes('@param userId'));\nassert(docString2.includes('userId - The ID of the user to deactivate'));\nassert(docString2.includes('throws UserNotFoundError if the user is not found'));\n", "DeepSeek-V3-0324_completion_0": "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "DeepSeek-V3-0324_completion_1": "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "DeepSeek-V3-0324_completion_2": "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "DeepSeek-V3-0324_completion_3": "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "DeepSeek-V3-0324_completion_4": "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "DeepSeek-V3-0324_completions": ["/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}", "/**\n * Deactivates a user by setting their isActive status to false.\n * @param userId - The ID of the user to deactivate.\n * @throws UserNotFoundError if the user is not found.\n */\nfunction deactivateUser(userId: number): void {\n    const user = getUserById(userId);\n    user.isActive = false;\n}"]}
