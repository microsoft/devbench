{"id": "1", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Person {\n\tname: string;\n\tconstructor(name: string) {\n\t\tthis.name = name;\n\t}\n}\n\nclass Employee extends Person {\n\tsalary: number;\n\tconstructor(name: string, salary: number) {", "suffix": "\n\t}\n}\n\nconst emp = new Employee('John Doe', 50000);\nconsole.log(emp.name); // Expected: John Doe\nconsole.log(emp.salary); // Expected: 50000\n", "golden_completion": "\n\t\tsuper(name);\n\t\tthis.salary = salary;", "LLM_justification": "This example tests the LLM's ability to recognize and complete an object-oriented inheritance pattern in TypeScript with minimal context. Specifically, it involves completing the constructor of a derived class by calling the constructor of the base class using 'super()'. This is a common pattern in object-oriented programming, making it a good test case.", "assertions": "import { strict as assert } from 'assert';\nconst emp = new Employee('John Doe', 50000);\nassert.equal(emp.name, 'John Doe');\nassert.equal(emp.salary, 50000);", "claude-3-7-sonnet": "\t\tsuper(name);\n\t\tthis.salary = salary;"}
{"id": "2", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Person {\n\tname: string;\n\tage: number;\n\n\tconstructor(name: string, age: number) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\n\tgetDetails(): string {", "suffix": "\n\t}\n}\n\nconst person = new Person('Alice', 30);\nconsole.assert(person.getDetails() === 'Name: Alice, Age: 30', 'Assertion failed: person.getDetails() should return correct details');", "golden_completion": "\n\t\treturn `Name: ${this.name}, Age: ${this.age}`;", "LLM_justification": "This test case checks the ability of the model to recognize and complete a common object-oriented pattern in TypeScript involving class methods. The context is minimal, but the pattern of constructing a string with class properties is widely recognizable.", "assertions": "console.assert(person.getDetails() === 'Name: Alice, Age: 30', 'Assertion failed: person.getDetails() should return correct details');", "claude-3-7-sonnet": "\t\treturn `Name: ${this.name}, Age: ${this.age}`;"}
{"id": "3", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Person {\n    private name: string;\n    private age: number;\n\n    constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public getName(): string {", "suffix": "    }\n\n    public getAge(): number {\n        return this.age;\n    }\n}\n\nconst person = new Person(\"Alice\", 30);\nconsole.assert(person.getName() === \"Alice\");\nconsole.assert(person.getAge() === 30);", "golden_completion": "        return this.name;", "LLM_justification": "This test case is good because it checks the LLM's ability to recognize an object-oriented pattern with classes and methods. The prefix sets up a class with a constructor and a method, and the completion requires the LLM to identify the correct return statement for the method. The suffix continues with a different method and assertions, making it a low-context scenario.", "assertions": "console.assert(person.getName() === \"Alice\");\nconsole.assert(person.getAge() === 30);", "claude-3-7-sonnet": "        return this.name;"}
{"id": "4", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Item {\n    constructor(public name: string, public price: number) {}\n}\n\nclass ShoppingCart {\n    private items: Item[] = [];\n\n    addItem(item: Item): void {", "suffix": "    }\n\n    getTotal(): number {\n        return this.items.reduce((total, item) => total + item.price, 0);\n    }\n}\n\n// Testing the ShoppingCart\nconst cart = new ShoppingCart();\ncart.addItem(new Item(\"Apple\", 1.5));\ncart.addItem(new Item(\"Banana\", 0.75));\nconsole.assert(cart.getTotal() === 2.25, \"Total should be 2.25\");", "golden_completion": "        this.items.push(item);", "LLM_justification": "This is a good test case because it involves a common object-oriented pattern: managing a collection of items within a class and performing operations on that collection. The pattern of adding an item to an array and calculating a total is universally recognizable with minimal context. The LLM must complete the method to add an item to the internal array, which is a typical task in such scenarios.", "assertions": "console.assert(cart.getTotal() === 2.25, \"Total should be 2.25\");", "claude-3-7-sonnet": "        this.items.push(item);"}
{"id": "5", "testsource": "devbench-low-context", "language": "typescript", "prefix": "function filterEvenNumbers(arr: number[]): number[] {\n\treturn arr.filter(num => ", "suffix": ");\n}\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst evenNumbers = filterEvenNumbers(numbers);\nconsole.log(evenNumbers); // Should output: [2, 4, 6, 8, 10]", "golden_completion": "num % 2 === 0", "LLM_justification": "This test case focuses on functional programming constructs, specifically filtering an array. The pattern of using the filter method is clear and recognizable with minimal context. The completion is simple yet tests the LLM's understanding of predicates and array methods.", "assertions": "import { strict as assert } from 'assert';\nconst result = filterEvenNumbers([1, 2, 3, 4, 5]);\nassert.deepEqual(result, [2, 4], 'Filtered array should only contain even numbers');\nassert.deepEqual(filterEvenNumbers([]), [], 'Empty array should return empty array');", "claude-3-7-sonnet": "num % 2 === 0"}
{"id": "6", "testsource": "devbench-low-context", "language": "typescript", "prefix": "function processArray(arr: number[]): number[] {\n\treturn arr.map(num => num * 2);\n}\n\nfunction filterArray(arr: number[]): number[] {", "suffix": "\n}\n\nconst inputArray = [1, 2, 3, 4, 5];\nconst processedArray = processArray(inputArray);\nconst filteredArray = filterArray(processedArray);\n\nconsole.log(filteredArray);", "golden_completion": "\n\treturn arr.filter(num => num > 5);", "LLM_justification": "This is a good test case because it tests the model's ability to recognize and complete a common array manipulation pattern (filtering elements based on a condition) with minimal context. The prefix establishes an array processing pattern, and the suffix shows the usage of the functions without duplicating the completion code. The completion should return a filtered array based on a condition, which is a widely-used pattern.", "assertions": "const inputArray = [1, 2, 3, 4, 5];\nconst processedArray = processArray(inputArray);\nconst filteredArray = filterArray(processedArray);\n\nconsole.assert(JSON.stringify(filteredArray) === JSON.stringify([6, 8, 10]), 'Filtered array does not match expected output');", "claude-3-7-sonnet": "\treturn arr.filter(num => num > 5);"}
{"id": "7", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class User {\n\tconstructor(public name: string, public age: number) {}\n}\n\nfunction createUser(name: string, age: number): User {\n\t", "suffix": "}\n\nconst user = createUser('Alice', 30);\nconsole.assert(user.name === 'Alice', 'User name should be Alice');\nconsole.assert(user.age === 30, 'User age should be 30');", "golden_completion": "return new User(name, age);", "LLM_justification": "This test case is a good example of a low-context scenario as it provides a clear pattern of object creation through a class and a factory function. The completion involves recognizing the need to instantiate a class and return it within a function. The minimal context provided in the prefix and suffix should be sufficient for an LLM to identify the appropriate completion. The assertions verify the correctness of the object creation and ensure that the function correctly initializes the properties of the User object.", "assertions": "const user = createUser('Alice', 30);\nconsole.assert(user.name === 'Alice', 'User name should be Alice');\nconsole.assert(user.age === 30, 'User age should be 30');", "claude-3-7-sonnet": "\treturn new User(name, age);"}
{"id": "8", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Person {\n\tname: string;\n\tconstructor(name: string) {\n\t\tthis.name = name;\n\t}\n}\n\nconst people: Person[] = [\n\tnew Person('Alice'),\n\tnew Person('Bob'),\n\tnew Person('Charlie')\n];\n\nfunction getNames(people: Person[]): string[] {", "suffix": "\n}\n\nconst names = getNames(people);\nconsole.assert(names.length === 3, 'Expected 3 names');\nconsole.assert(names.includes('Alice'), 'Expected name Alice');\nconsole.assert(names.includes('Bob'), 'Expected name Bob');\nconsole.assert(names.includes('Charlie'), 'Expected name Charlie');", "golden_completion": "\n\treturn people.map(person => person.name);", "LLM_justification": "This test case is designed to evaluate the model's ability to recognize and complete a common object-oriented pattern involving classes and array manipulation. Despite the minimal context, the pattern of mapping over an array of objects to extract a property is a widely-used convention. The assertions verify the correct behavior by checking the length and contents of the resulting array.", "assertions": "console.assert(names.length === 3, 'Expected 3 names');\nconsole.assert(names.includes('Alice'), 'Expected name Alice');\nconsole.assert(names.includes('Bob'), 'Expected name Bob');\nconsole.assert(names.includes('Charlie'), 'Expected name Charlie');", "claude-3-7-sonnet": "  return people.map(person => person.name);"}
{"id": "9", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Person {\n\tname: string;\n\tage: number;\n\n\tconstructor(name: string, age: number) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n", "suffix": "\n\tgreet() {\n\t\treturn `Hello, my name is ${this.name}`;\n\t}\n}\n\nconst person = new Person(\"Alice\", 30);\nconsole.log(person.greet());\n", "golden_completion": "\tincreaseAge(years: number) {\n\t\tthis.age += years;\n\t}\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize object-oriented patterns in TypeScript, specifically the definition and usage of a class with methods. The completion involves adding a method to the class, which is a common pattern in object-oriented programming. The minimal context provided should be sufficient for the LLM to understand the expected pattern and continue it correctly.", "assertions": "import assert from 'assert';\n\nconst person = new Person('Alice', 30);\nperson.increaseAge(5);\nassert.strictEqual(person.age, 35);\n", "claude-3-7-sonnet": "\n\tgetAge() {\n\t\treturn this.age;\n\t}"}
{"id": "10", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class User {\n\tname: string;\n\tconstructor(name: string) {\n\t\tthis.name = name;\n\t}\n}\n\nclass UserManager {\n\tusers: User[] = [];\n\n\taddUser(name: string): void {", "suffix": "\n\t}\n\n\tremoveUser(name: string): void {\n\t\tthis.users = this.users.filter(user => user.name !== name);\n\t}\n}\n\nconst manager = new UserManager();\nmanager.addUser(\"Alice\");\nmanager.addUser(\"Bob\");\nconsole.assert(manager.users.length === 2, \"Expected 2 users\");\nconsole.assert(manager.users.some(user => user.name === \"Alice\"), \"Expected Alice in users\");\nmanager.removeUser(\"Alice\");\nconsole.assert(manager.users.length === 1, \"Expected 1 user after removal\");\nconsole.assert(!manager.users.some(user => user.name === \"Alice\"), \"Expected Alice to be removed\");", "golden_completion": "\n\t\tthis.users.push(new User(name));", "LLM_justification": "This test case is a good example of an object-oriented pattern involving class instantiation and method definition. The prefix establishes a User class and part of a UserManager class with an addUser method. The completion requires recognizing the pattern of adding a new user to the users array, which is a common task. The suffix continues with a removeUser method and some assertions to verify the correctness of the addUser and removeUser methods. The test checks if the model can correctly complete the addUser method by following the established pattern of creating a new User instance and adding it to the users array.", "assertions": "console.assert(manager.users.length === 2, \"Expected 2 users\");\nconsole.assert(manager.users.some(user => user.name === \"Alice\"), \"Expected Alice in users\");\nmanager.removeUser(\"Alice\");\nconsole.assert(manager.users.length === 1, \"Expected 1 user after removal\");\nconsole.assert(!manager.users.some(user => user.name === \"Alice\"), \"Expected Alice to be removed\");", "claude-3-7-sonnet": "\t\tconst newUser = new User(name);\n\t\tthis.users.push(newUser);"}
{"id": "11", "testsource": "devbench-low-context", "language": "typescript", "prefix": "const numbers: number[] = [1, 2, 3, 4, 5];\n\nfunction doubleAndFilterEven(nums: number[]): number[] {", "suffix": "\n}\n\nconst result = doubleAndFilterEven(numbers);\nconsole.assert(JSON.stringify(result) === JSON.stringify([4, 8]), 'Test failed: expected [4, 8]');", "golden_completion": "\n\treturn nums.map(num => num * 2).filter(num => num % 2 === 0);", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common array manipulation pattern in TypeScript. The pattern involves mapping and filtering an array, which is a universal and widely-used convention in functional programming with arrays. The prefix establishes the context of an array of numbers and a function that processes this array. The suffix provides a test case to validate the correctness of the function, ensuring the model can complete the middle portion accurately. The assertions verify that the function correctly doubles the numbers and filters out the even ones, matching the expected result.", "assertions": "console.assert(JSON.stringify(result) === JSON.stringify([4, 8]), 'Test failed: expected [4, 8]');", "claude-3-7-sonnet": "  return nums\n    .map(num => num * 2)\n    .filter(num => num % 2 === 0);"}
{"id": "12", "testsource": "devbench-low-context", "language": "typescript", "prefix": "function processItems(items: number[]): number[] {", "suffix": "  return items.map(item => item * 2);\n}\n\nconst result = processItems([1, 2, 3, 4]);\nconsole.log(result); // [2, 4, 6, 8]", "golden_completion": "  if (!items) {\n    throw new Error('No items provided');\n  }", "LLM_justification": "This test case evaluates the model's ability to recognize and complete a common error handling pattern in TypeScript. The function `processItems` processes an array of numbers by doubling each item. The completion involves adding an error check for the `items` parameter, ensuring it is provided before proceeding. This pattern is common and should be easily recognizable with minimal context. The suffix continues the function's logic, ensuring the pattern is distinct and understandable.", "assertions": "import assert from 'assert';\n\ntry {\n  processItems(null as any);\n  assert.fail('Expected an error to be thrown');\n} catch (error) {\n  assert.strictEqual((error as Error).message, 'No items provided');\n}\nconst result = processItems([1, 2, 3, 4]);\nassert.deepStrictEqual(result, [2, 4, 6, 8]);", "claude-3-7-sonnet": "  return items.map(item => item * 2);"}
{"id": "13", "testsource": "devbench-low-context", "language": "typescript", "prefix": "const numbers: number[] = [1, 2, 3, 4, 5];\nconst doubledNumbers: number[] = numbers.map(num =>", "suffix": "console.log(doubledNumbers);\n// Expected output: [2, 4, 6, 8, 10]\n\nconst squaredNumbers: number[] = numbers.map(num => num * num);\nconsole.log(squaredNumbers);\n// Expected output: [1, 4, 9, 16, 25]", "golden_completion": " num * 2);", "LLM_justification": "This is a good test case because it checks the model's ability to recognize and complete a common array manipulation pattern using the map function. The pattern should be clear even with minimal context, as the prefix and suffix provide enough information to identify the expected transformation.", "assertions": "import * as assert from 'assert';\n\nconst numbers: number[] = [1, 2, 3, 4, 5];\nconst doubledNumbers: number[] = numbers.map(num => num * 2);\nassert.deepStrictEqual(doubledNumbers, [2, 4, 6, 8, 10]);\n\nconst squaredNumbers: number[] = numbers.map(num => num * num);\nassert.deepStrictEqual(squaredNumbers, [1, 4, 9, 16, 25]);", "claude-3-7-sonnet": " num * 2);"}
{"id": "14", "testsource": "devbench-low-context", "language": "typescript", "prefix": "function processStrings(strings: string[]): string[] {", "suffix": "\n\treturn strings.map(str => str.toUpperCase());\n}\n\nconst input = [\"hello\", \"world\"];\nconst expectedOutput = [\"HELLO\", \"WORLD\"];\nconst result = processStrings(input);\nconsole.assert(JSON.stringify(result) === JSON.stringify(expectedOutput), 'Test failed: Unexpected output');", "golden_completion": "\n\tstrings = strings.filter(str => str.length > 0);", "LLM_justification": "This example tests the LLM's ability to recognize and complete a common string processing pattern. The prefix function signature and the suffix's use of map indicate a pattern of processing strings in an array. The golden completion involves filtering out empty strings, a reasonable and common step in string processing. The assertions check that the final output meets expectations, ensuring the pattern is correctly recognized and applied.", "assertions": "console.assert(JSON.stringify(result) === JSON.stringify(expectedOutput), 'Test failed: Unexpected output');", "claude-3-7-sonnet": "\treturn strings.map(str => str.toUpperCase());"}
{"id": "15", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Animal {\n\tname: string;\n\tconstructor(name: string) {\n\t\tthis.name = name;\n\t}\n}\nclass Dog extends Animal {\n\tbreed: string;\n\tconstructor(name: string, breed: string) {\n\t\tsuper(name);\n\t\tthis.breed = breed;\n\t}\n\tbark() {\n\t\treturn `${this.name} barks!`;\n\t}\n}", "suffix": "const myDog = new Dog('Rex', 'German Shepherd');\nconsole.assert(myDog.name === 'Rex', 'Name should be Rex');\nconsole.assert(myDog.breed === 'German Shepherd', 'Breed should be German Shepherd');\nconsole.assert(myDog.bark() === 'Rex barks!', 'Bark message should be correct');\n", "golden_completion": "class Cat extends Animal {\n\tcolor: string;\n\tconstructor(name: string, color: string) {\n\t\tsuper(name);\n\t\tthis.color = color;\n\t}\n\tmeow() {\n\t\treturn `${this.name} meows!`;\n\t}\n}\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and extend object-oriented patterns using TypeScript classes and inheritance with minimal context. The prefix provides a clear example of a class hierarchy with methods and properties, and the golden completion requires the LLM to create a similar but distinct class following the same pattern. The suffix includes assertions to verify the correctness of object instantiation and method behavior.", "assertions": "const myCat = new Cat('Whiskers', 'Black');\nconsole.assert(myCat.name === 'Whiskers', 'Name should be Whiskers');\nconsole.assert(myCat.color === 'Black', 'Color should be Black');\nconsole.assert(myCat.meow() === 'Whiskers meows!', 'Meow message should be correct');", "claude-3-7-sonnet": "\nclass Cat extends Animal {\n\tcolor: string;\n\tconstructor(name: string, color: string) {\n\t\tsuper(name);\n\t\tthis.color = color;\n\t}\n\tmeow() {\n\t\treturn `${this.name} meows!`;\n\t}\n}\n"}
{"id": "16", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Animal {\n\tname: string;\n\tconstructor(name: string) {\n\t\tthis.name = name;\n\t}\n}\nclass Dog extends Animal {\n\tbreed: string;\n\tconstructor(name: string, breed: string) {", "suffix": "\n\t\tthis.breed = breed;\n\t}\n}\nconst myDog = new Dog(\"Rex\", \"German Shepherd\");\nconsole.assert(myDog.name === \"Rex\", \"Name should be Rex\");\nconsole.assert(myDog.breed === \"German Shepherd\", \"Breed should be German Shepherd\");", "golden_completion": "\n\t\tsuper(name);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete an object-oriented pattern involving class inheritance in TypeScript. The prefix establishes a base class and a derived class, while the golden completion requires the model to correctly use the 'super' keyword to call the parent class constructor. This pattern is a fundamental concept in object-oriented programming and is universally recognizable with minimal context.", "assertions": "console.assert(myDog.name === \"Rex\", \"Name should be Rex\");\nconsole.assert(myDog.breed === \"German Shepherd\", \"Breed should be German Shepherd\");", "claude-3-7-sonnet": "\t\tsuper(name);"}
{"id": "17", "testsource": "devbench-low-context", "language": "typescript", "prefix": "function processArray(arr: number[]): number[] {\n\treturn arr.map(num => num * 2);\n}\n\nfunction filterArray(arr: number[]): number[] {", "suffix": "\n\treturn arr.filter(num => num % 2 === 0);\n}\n\nconst input = [1, 2, 3, 4, 5];\nconst processed = processArray(input);\nconst filtered = filterArray(processed);\n\nconsole.log(filtered); // [4, 8]\n", "golden_completion": "\n\treturn arr.filter(num => num > 5);\n", "LLM_justification": "This test case checks the model's ability to recognize and complete a functional programming pattern with array methods in TypeScript. The prefix establishes a pattern with the map method, and the suffix uses the filter method. The completion requires understanding how to filter an array based on a given condition, maintaining consistency with the functional style and array manipulation context. Multiple valid completions are possible, making it a good test of the model's pattern recognition abilities.", "assertions": "import * as assert from 'assert';\nconst input = [1, 2, 3, 4, 5];\nconst processed = processArray(input);\nconst filtered = filterArray(processed);\nassert.deepStrictEqual(filtered, [6, 8, 10]);", "claude-3-7-sonnet": " "}
{"id": "18", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Example {\n\tprivate data: number[];\n\n\tconstructor() {\n\t\tthis.data = [1, 2, 3, 4, 5];\n\t}\n\n\tpublic getData(): number[] {\n\t\treturn this.data;", "suffix": "\n\t}\n\n\tpublic sumData(): number {\n\t\treturn this.data.reduce((acc, val) => acc + val, 0);\n\t}\n}\n\nconst example = new Example();\nconsole.assert(example.getData().length === 5, 'Expected array length to be 5');\nconsole.assert(example.sumData() === 15, 'Expected sum of array elements to be 15');", "golden_completion": "\n\t}\n\n\tpublic addData(value: number): void {\n\t\tthis.data.push(value);", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete an object-oriented pattern involving class methods and array manipulation with minimal context. The prefix establishes a pattern of class definition with a constructor and a method, and the completion continues this pattern by adding another method for manipulating the array. The suffix introduces a different method and assertions to verify the behavior, ensuring the model can infer the correct pattern completion.", "assertions": "console.assert(example.getData().length === 6, 'Expected array length to be 6 after adding an element');\nconsole.assert(example.getData()[5] === 6, 'Expected the last element to be 6 after adding it');", "claude-3-7-sonnet": ".slice()"}
{"id": "19", "testsource": "devbench-low-context", "language": "typescript", "prefix": "function processData(data: number[]): number {\n\tlet sum = 0;\n\tfor (const num of data) {\n\t\tsum += num;\n\t}\n\treturn sum;\n}\n\nfunction getAverage(data: number[]): number {", "suffix": "\n\treturn total / data.length;\n}\n\nconst data = [1, 2, 3, 4, 5];\nconst average = getAverage(data);\nconsole.assert(average === 3, `Expected 3, but got ${average}`);\n", "golden_completion": "\n\tconst total = processData(data);", "LLM_justification": "This is a good test case because it involves a clear and simple pattern of reusing a function to process data. The prefix establishes the pattern of summing numbers in an array, and the completion requires recognizing that the same sum calculation should be used to compute the average in the getAverage function. The suffix provides a different context where the completion is applied. This tests the LLM's ability to recognize and continue patterns with minimal context.", "assertions": "console.assert(getAverage([1, 2, 3, 4, 5]) === 3, 'Test case 1 failed');\nconsole.assert(getAverage([10, 20, 30, 40, 50]) === 30, 'Test case 2 failed');", "claude-3-7-sonnet": "\tconst total = processData(data);"}
{"id": "20", "testsource": "devbench-low-context", "language": "typescript", "prefix": "function processString(input: string): string {\n    let result = input.trim();\n", "suffix": "    return result.toUpperCase();\n}\n\nconst input = \"  hello world  \";\nconst expectedOutput = \"HELLO WORLD\";\nconst output = processString(input);\nconsole.assert(output === expectedOutput, `Expected ${expectedOutput}, but got ${output}`);\n", "golden_completion": "    result = result.replace(/\\s+/g, ' ');\n", "LLM_justification": "This is a good test case because it involves string processing and text manipulation, which are common tasks in programming. The completion involves a standard pattern of replacing multiple whitespace characters with a single space, which is a recognizable and widely-used string manipulation technique. The minimal context provided should be sufficient for an LLM to infer the expected pattern.", "assertions": "console.assert(output === expectedOutput, `Expected ${expectedOutput}, but got ${output}`);\n", "claude-3-7-sonnet": "    "}
{"id": "21", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Person {\n\tname: string;\n\tage: number;\n\n\tconstructor(name: string, age: number) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n}\n\nconst people: Person[] = [\n\tnew Person('Alice', 30),\n\tnew Person('Bob', 25),\n];\n\nfunction getNames(people: Person[]): string[] {", "suffix": "\n}\n\nconst names = getNames(people);\nconsole.assert(names.includes('Alice'), 'Alice should be in the names array');\nconsole.assert(names.includes('Bob'), 'Bob should be in the names array');\nconsole.assert(names.length === 2, 'There should be exactly two names in the array');", "golden_completion": "\n\treturn people.map(person => person.name);", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete a pattern of extracting specific properties from an array of objects using the map function. The context is minimal but includes enough information to identify the pattern of iterating over an array and transforming it.", "assertions": "\nconsole.assert(names.includes('Alice'), 'Alice should be in the names array');\nconsole.assert(names.includes('Bob'), 'Bob should be in the names array');\nconsole.assert(names.length === 2, 'There should be exactly two names in the array');", "claude-3-7-sonnet": "  return people.map(person => person.name);"}
{"id": "22", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Person {\n\tconstructor(public name: string, public age: number) {}\n}\n\nconst people: Person[] = [\n\tnew Person('Alice', 30),\n\tnew Person('Bob', 25),\n\tnew Person('Charlie', 35)\n];\n\nfunction getNamesOverAge(age: number): string[] {", "suffix": "\n}\n\nconsole.log(getNamesOverAge(28)); // Should print: [ 'Alice', 'Charlie' ]", "golden_completion": "\n\treturn people.filter(person => person.age > age).map(person => person.name);\n", "LLM_justification": "This is a good test case because it involves a common data structure manipulation pattern (filtering and mapping an array of objects). The pattern should be recognizable with minimal context as it follows a standard array manipulation sequence in TypeScript. The completion must correctly use TypeScript's array methods to filter and map the array based on the provided age criterion.", "assertions": "import { strict as assert } from 'assert';\n\nconst result = getNamesOverAge(28);\nassert.deepStrictEqual(result, ['Alice', 'Charlie']);\n", "claude-3-7-sonnet": "\treturn people.filter(person => person.age > age).map(person => person.name);"}
{"id": "23", "testsource": "devbench-low-context", "language": "typescript", "prefix": "class Calculator {\n\tadd(a: number, b: number): number {\n\t\treturn a + b;\n\t}\n\n\tdivide(a: number, b: number): number {\n\t\tif (b === 0) {\n\t\t\tthrow new Error('Division by zero');\n\t\t}\n\t\treturn a / b;\n\t}\n\n\tmultiply(a: number, b: number): number {", "suffix": "\n\t}\n}\n\nconst calc = new Calculator();\nconsole.log(calc.multiply(3, 4));", "golden_completion": "\n\t\treturn a * b;", "LLM_justification": "This is a good test case as it requires the LLM to recognize a common pattern in class method definitions and complete the multiplication method appropriately. The context provided by the other methods (add and divide) is minimal yet sufficient to establish the pattern of basic arithmetic operations in the Calculator class.", "assertions": "const calc = new Calculator();\nconsole.assert(calc.multiply(3, 4) === 12, '3 * 4 should equal 12');\nconsole.assert(calc.multiply(0, 5) === 0, '0 * 5 should equal 0');\nconsole.assert(calc.multiply(-1, 5) === -5, '-1 * 5 should equal -5');", "claude-3-7-sonnet": "\t\treturn a * b;"}
{"id": "24", "testsource": "devbench-low-context", "language": "typescript", "prefix": "const data = [1, 2, 3, 4, 5];\n\n// Filter out odd numbers\nconst evenNumbers = data.filter(", "suffix": ");\n\n// Check if the result is correct\nconsole.assert(evenNumbers.length === 2);\nconsole.assert(evenNumbers.includes(2));\nconsole.assert(evenNumbers.includes(4));", "golden_completion": "num => num % 2 === 0", "LLM_justification": "This test case focuses on a common array manipulation pattern: filtering. The prefix sets up an array and begins a filter operation. The expected completion is a function that filters out odd numbers, which is a universally recognizable pattern. The suffix contains assertions to verify the correctness of the filtering operation, ensuring that the model correctly identifies and completes the pattern.", "assertions": "console.assert(evenNumbers.length === 2);\nconsole.assert(evenNumbers.includes(2));\nconsole.assert(evenNumbers.includes(4));", "claude-3-7-sonnet": "num => num % 2 === 0"}
{"id": "25", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Filter<T> = (value: T) => boolean;\ntype MappedFilter<T> = { [K in keyof T]: Filter<T[K]> };\n\nfunction applyFilters<T>(obj: T, filters: MappedFilter<T>): Partial<T> {\n    const result: Partial<T> = {};\n    for (const key in filters) {\n        if (filters[key](obj[key])) {", "suffix": "        }\n    }\n    return result;\n}\n\nconst filters = {\n    name: (value: string) => value.startsWith('A'),\n    age: (value: number) => value > 20\n};\n\nconst person = { name: 'Alice', age: 25, location: 'Wonderland' };\nconst filteredPerson = applyFilters(person, filters);\nconsole.assert(filteredPerson.name === 'Alice');\nconsole.assert(filteredPerson.age === 25);\nconsole.assert(filteredPerson.location === undefined);", "golden_completion": "            result[key] = obj[key];", "LLM_justification": "This test case evaluates the LLM's ability to understand and complete an advanced TypeScript pattern involving conditional types and mapped types. The prefix establishes the pattern of using mapped types to create a type-safe filter function, while the suffix demonstrates the function's application. The golden completion requires understanding both TypeScript's type system and the functional logic of the `applyFilters` function, making it a suitable challenge for a senior TypeScript developer.", "assertions": "console.assert(filteredPerson.name === 'Alice');\nconsole.assert(filteredPerson.age === 25);\nconsole.assert(filteredPerson.location === undefined);", "claude-3-7-sonnet": "            result[key] = obj[key];"}
{"id": "26", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type ExtractFunction<T> = T extends (...args: any[]) => infer R ? R : never;\ntype FunctionMap = {\n  add: (a: number, b: number) => number;\n  concat: (a: string, b: string) => string;\n};\n\nfunction applyFunction<K extends keyof FunctionMap>(key: K, ...args: Parameters<FunctionMap[K]>): ExtractFunction<FunctionMap[K]> {\n", "suffix": "}\n\nconst result1 = applyFunction('add', 1, 2);\nconst result2 = applyFunction('concat', 'hello', 'world');\n\nconsole.assert(result1 === 3, 'Addition result should be 3');\nconsole.assert(result2 === 'helloworld', 'Concatenation result should be helloworld');", "golden_completion": "  const fn = FunctionMap[key];\n  return fn(...args);\n", "LLM_justification": "This example requires understanding of advanced TypeScript type system features such as conditional types with `infer`, and proper inference and application of function types from a mapped type. The low-context prefix and suffix ensure that the LLM must correctly infer the function type and implement the function call with appropriate type safety.", "assertions": "const result1 = applyFunction('add', 1, 2);\nconst result2 = applyFunction('concat', 'hello', 'world');\nconsole.assert(result1 === 3, 'Addition result should be 3');\nconsole.assert(result2 === 'helloworld', 'Concatenation result should be helloworld');", "claude-3-7-sonnet": "  const functionMap: FunctionMap = {\n    add: (a, b) => a + b,\n    concat: (a, b) => a + b\n  };\n  \n  return functionMap[key](...args) as ExtractFunction<FunctionMap[K]>;"}
{"id": "27", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends Array<infer U> ? U : T;\n\nfunction flatMap<T, U>(arr: T[], fn: (item: Flatten<T>) => U[]): U[] {", "suffix": "}\n\nconst numbers: number[] = [1, 2, 3];\nconst result = flatMap(numbers, (n) => [n, n * 2]);\nconsole.assert(result.length === 6, 'Expected length of 6');\nconsole.assert(result[0] === 1, 'Expected first element to be 1');\nconsole.assert(result[1] === 2, 'Expected second element to be 2');\nconsole.assert(result[2] === 2, 'Expected third element to be 2');\nconsole.assert(result[3] === 4, 'Expected fourth element to be 4');\nconsole.assert(result[4] === 3, 'Expected fifth element to be 3');\nconsole.assert(result[5] === 6, 'Expected sixth element to be 6');", "golden_completion": "return arr.reduce((acc, item) => acc.concat(fn(item as Flatten<T>)), [] as U[]);", "LLM_justification": "This example tests the LLM's ability to recognize and complete a higher-order function pattern with advanced TypeScript type inference. The `Flatten` type uses conditional types and `infer` to properly type the elements being mapped over. The `flatMap` function applies a transformation and flattens the result, demonstrating complex type manipulation and functional programming. The completion should correctly implement the pattern, and the assertions validate the functionality and type safety of the implementation.", "assertions": "const numbers: number[] = [1, 2, 3];\nconst result = flatMap(numbers, (n) => [n, n * 2]);\nconsole.assert(result.length === 6, 'Expected length of 6');\nconsole.assert(result[0] === 1, 'Expected first element to be 1');\nconsole.assert(result[1] === 2, 'Expected second element to be 2');\nconsole.assert(result[2] === 2, 'Expected third element to be 2');\nconsole.assert(result[3] === 4, 'Expected fourth element to be 4');\nconsole.assert(result[4] === 3, 'Expected fifth element to be 3');\nconsole.assert(result[5] === 6, 'Expected sixth element to be 6');", "claude-3-7-sonnet": "  return arr.reduce((acc, item) => {\n    const flatItem = Array.isArray(item) ? item[0] : item;\n    const mapped = fn(flatItem);\n    return [...acc, ...mapped];\n  }, [] as U[]);"}
{"id": "28", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends Array<infer U> ? U : T;\nfunction flattenArray<T>(arr: T[]): Flatten<T>[] {", "suffix": "}\n\nconst nestedArray = [[1, 2], [3, 4]];\nconst result = flattenArray(nestedArray);\n\nconsole.assert(Array.isArray(result), 'Result should be an array');\nconsole.assert(result.length === 4, 'Result array should have 4 elements');\nconsole.assert(result[0] === 1 && result[1] === 2 && result[2] === 3 && result[3] === 4, 'Result array should be flattened');", "golden_completion": " return arr.reduce((acc, val) => acc.concat(val), [] as Flatten<T>[]);", "LLM_justification": "This example tests the model's ability to recognize and complete a type-safe array flattening function in TypeScript. The pattern involves using conditional types with `infer` for type extraction and demonstrating a common type-safe operation with arrays. The low-context scenario requires the model to understand how to reduce and concatenate arrays while preserving type integrity, which is a non-trivial task requiring advanced TypeScript knowledge.", "assertions": "console.assert(Array.isArray(result), 'Result should be an array');\nconsole.assert(result.length === 4, 'Result array should have 4 elements');\nconsole.assert(result[0] === 1 && result[1] === 2 && result[2] === 3 && result[3] === 4, 'Result array should be flattened');", "claude-3-7-sonnet": "  return arr.flat() as Flatten<T>[];"}
{"id": "29", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends Array<infer U> ? U : T;\n\nfunction flatMap<T, U>(array: T[], callback: (value: T) => U | U[]): U[] {\n    const result: U[] = [];\n    for (const value of array) {", "suffix": "    }\n    return result;\n}\n\nconst numbers = [1, 2, 3];\nconst strings = flatMap(numbers, n => [n.toString(), (n * 2).toString()]);\n\n// assertions\nconsole.assert(strings.length === 6, 'Expected length of 6');\nconsole.assert(strings[0] === '1', 'Expected first element to be \"1\"');\nconsole.assert(strings[1] === '2', 'Expected second element to be \"2\"');\nconsole.assert(strings[2] === '2', 'Expected third element to be \"2\"');\nconsole.assert(strings[3] === '4', 'Expected fourth element to be \"4\"');\nconsole.assert(strings[4] === '3', 'Expected fifth element to be \"3\"');\nconsole.assert(strings[5] === '6', 'Expected sixth element to be \"6\"');", "golden_completion": "        const res = callback(value);\n        if (Array.isArray(res)) {\n            result.push(...res);\n        } else {\n            result.push(res);\n        }", "LLM_justification": "This example tests the LLM's ability to handle advanced type inference with conditional types and higher-order functions. The use of 'infer' in conditional types to extract the element type from an array and the implementation of a flatMap function with proper type handling require a deep understanding of TypeScript's type system. The minimal context provided ensures that the LLM must recognize and complete the pattern correctly, demonstrating its ability to infer and apply complex type transformations.", "assertions": "console.assert(strings.length === 6, 'Expected length of 6');\nconsole.assert(strings[0] === '1', 'Expected first element to be \"1\"');\nconsole.assert(strings[1] === '2', 'Expected second element to be \"2\"');\nconsole.assert(strings[2] === '2', 'Expected third element to be \"2\"');\nconsole.assert(strings[3] === '4', 'Expected fourth element to be \"4\"');\nconsole.assert(strings[4] === '3', 'Expected fifth element to be \"3\"');\nconsole.assert(strings[5] === '6', 'Expected sixth element to be \"6\"');", "claude-3-7-sonnet": "        const callbackResult = callback(value);\n        if (Array.isArray(callbackResult)) {\n            result.push(...callbackResult);\n        } else {\n            result.push(callbackResult);\n        }"}
{"id": "30", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends Array<infer U> ? U : T;\ntype DeepFlatten<T> = T extends Array<infer U> ? DeepFlatten<U> : T;\n\n// Test data\nconst nestedArray: number[][][] = [[[1, 2], [3, 4]], [[5, 6]]];\n", "suffix": "const flatArray: number[] = deepFlatten(nestedArray);\n\n// Assertions\nconsole.assert(flatArray.length === 6, 'The flattened array should have 6 elements');\nconsole.assert(flatArray[0] === 1 && flatArray[5] === 6, 'The elements should be 1 through 6');\n", "golden_completion": "function deepFlatten<T>(arr: T[]): DeepFlatten<T>[] {\n    return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? deepFlatten(val) : val), [] as DeepFlatten<T>[]);\n}", "LLM_justification": "This example requires an understanding of advanced TypeScript type system features, particularly conditional and recursive types. The `DeepFlatten` type recursively flattens nested arrays, and the `deepFlatten` function must correctly implement this type behavior. The low context is maintained by providing only the necessary type definitions and a nested array test case. The golden completion demonstrates the correct implementation of a deeply recursive flatten function with proper type handling.", "assertions": "console.assert(flatArray.length === 6, 'The flattened array should have 6 elements');\nconsole.assert(flatArray[0] === 1 && flatArray[5] === 6, 'The elements should be 1 through 6');", "claude-3-7-sonnet": "function deepFlatten<T>(arr: T[]): DeepFlatten<T>[] {\n  return arr.reduce((acc, val) => {\n    return acc.concat(Array.isArray(val) ? deepFlatten(val) : val);\n  }, [] as any[]);\n}\n"}
{"id": "31", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type ExtractFunction<Obj> = {\n\t[K in keyof Obj]: Obj[K] extends (...args: any[]) => any ? K : never\n}[keyof Obj];\n\ninterface Service {\n\tdoSomething(): void;\n\tvalue: number;\n}\n\nconst service: Service = {\n\tdoSomething() {\n\t\tconsole.log('Doing something');\n\t},\n\tvalue: 42\n};\n\nfunction callFunction<T, K extends ExtractFunction<T>>(obj: T, key: K): ReturnType<T[K]> {", "suffix": "\n}\n\nconst result = callFunction(service, 'doSomething');\n\n// Assertions\nimport * as assert from 'assert';\nassert.strictEqual(result, undefined);\n\n// Cleanup (if any)\n// No resources to clean up in this example", "golden_completion": "\n\treturn obj[key]();", "LLM_justification": "This example tests the LLM's ability to recognize and complete an advanced TypeScript pattern involving conditional types and function extraction from an object. The `ExtractFunction` type and the `callFunction` function are non-trivial and require understanding of advanced TypeScript features. The minimal context provided challenges the LLM to infer the correct completion.", "assertions": "import * as assert from 'assert';\nconst result = callFunction(service, 'doSomething');\nassert.strictEqual(result, undefined);", "claude-3-7-sonnet": "  return obj[key]();"}
{"id": "32", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Filter<T> = (item: T) => boolean;\n\nfunction filterArray<T>(arr: T[], filter: Filter<T>): T[] {\n    return arr.filter(filter);\n}\n\nconst isEven: Filter<number> = (num) => num % 2 === 0;\nconst numbers = [1, 2, 3, 4, 5, 6];\nconst evenNumbers = filterArray(numbers, isEven);", "suffix": "\nconsole.log(evenNumbers);\n\nconst isOdd: Filter<number> = (num) => num % 2 !== 0;\nconst oddNumbers = filterArray(numbers, isOdd);\nconsole.log(oddNumbers);", "golden_completion": "console.assert(JSON.stringify(evenNumbers) === '[2,4,6]', 'Expected [2,4,6] for even numbers');", "LLM_justification": "This test case demonstrates the use of higher-order functions with generics in TypeScript. The pattern involves defining a type for a filter function, using it to filter arrays, and then writing assertions to verify the correctness of the filtered results. This requires the model to understand functional programming constructs and generics in TypeScript.", "assertions": "console.assert(JSON.stringify(evenNumbers) === '[2,4,6]', 'Expected [2,4,6] for even numbers');", "claude-3-7-sonnet": " // [2, 4, 6]"}
{"id": "33", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Merge<A, B> = {\n  [K in keyof A | keyof B]: K extends keyof B ? B[K] : K extends keyof A ? A[K] : never;\n};\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\ninterface Employee {\n  employeeId: number;\n  department: string;\n}\n\nconst person: Person = { name: 'Alice', age: 30 };\nconst employee: Employee = { employeeId: 123, department: 'Engineering' };\n\nconst merged:", "suffix": "\nconsole.log(merged);\n\n// Ensure the merged object has properties from both Person and Employee\nconsole.assert(merged.name === 'Alice');\nconsole.assert(merged.age === 30);\nconsole.assert(merged.employeeId === 123);\nconsole.assert(merged.department === 'Engineering');", "golden_completion": "Merge<Person, Employee> = { ...person, ...employee };\n", "LLM_justification": "This example challenges an LLM to correctly merge two types using advanced TypeScript type features. It requires understanding of conditional types, union types, and intersection types. The pattern of merging objects and types is common in production code, and the LLM must infer the correct type manipulation to maintain type safety. The provided assertions test the properties of the merged object, ensuring the correct implementation.", "assertions": "console.assert(merged.name === 'Alice');\nconsole.assert(merged.age === 30);\nconsole.assert(merged.employeeId === 123);\nconsole.assert(merged.department === 'Engineering');", "claude-3-7-sonnet": " Merge<Person, Employee> = { ...person, ...employee };"}
{"id": "34", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type TupleToUnion<T extends any[]> = T[number];\n\ntype Flatten<T> = T extends (infer U)[] ? U : T;\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;\n\ntype Merge<T> = UnionToIntersection<Flatten<T>>;\n\ntype Foo = {a: string; b: number};\ntype Bar = {b: number; c: boolean};\n\ntype Merged = Merge<[Foo, Bar]>;\n\nconst obj: Merged = {", "suffix": "};\n\nconsole.assert(obj.a === 'hello');\nconsole.assert(obj.b === 42);\nconsole.assert(obj.c === true);\n", "golden_completion": "\"a\": \"hello\", \"b\": 42, \"c\": true", "LLM_justification": "This example tests the LLM's ability to handle advanced type manipulation in TypeScript, specifically focusing on merging complex types using conditional types, union-to-intersection conversions, and type inference. The completion requires understanding of how the Merge type works and correctly providing the properties for the merged type. This is a non-trivial task that involves several advanced TypeScript features.", "assertions": "console.assert(obj.a === 'hello');\nconsole.assert(obj.b === 42);\nconsole.assert(obj.c === true);", "claude-3-7-sonnet": "  a: 'hello',\n  b: 42,\n  c: true"}
{"id": "35", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type ExtractFunctionReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\nfunction example() {\n\tfunction add(a: number, b: number): number {\n\t\treturn a + b;\n\t}\n\tfunction greet(name: string): string {\n\t\treturn `Hello, ${name}!`;\n\t}\n\n\tconst addReturnType: ExtractFunctionReturnType<typeof add> = 5;\n\tconst greetReturnType: ExtractFunctionReturnType<typeof greet> = \"Hello, TypeScript!\";\n\tconst unknownFunction: ExtractFunctionReturnType<", "suffix": "> = true;\n\n\tconsole.log(addReturnType);\n\tconsole.log(greetReturnType);\n}\n\nexample();", "golden_completion": "(() => boolean)", "LLM_justification": "This example tests the LLM's ability to recognize and complete a complex TypeScript type extraction pattern using conditional types with `infer`. The `ExtractFunctionReturnType` type is designed to extract the return type of a function. The completion involves recognizing the pattern and correctly inferring the return type of a provided function type.", "assertions": "const assert = require('assert');\nassert.strictEqual(typeof addReturnType, 'number');\nassert.strictEqual(typeof greetReturnType, 'string');\nassert.strictEqual(typeof unknownFunction, 'boolean');", "claude-3-7-sonnet": "() => boolean"}
{"id": "36", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Box<T> = { value: T };\n\ntype UnboxArray<T> = T extends Array<infer U> ? U : T;\n\nfunction createBox<T>(value: T): Box<T> {\n    return { value };\n}\n\nconst stringBox = createBox(\"hello\");\nconst numberArrayBox = createBox([1, 2, 3]);\n\nfunction unbox<T>(box: Box<T>): UnboxArray<T> {", "suffix": "}\n\nconst unboxedString = unbox(stringBox);\nconst unboxedNumberArray = unbox(numberArrayBox);\n\nconsole.assert(unboxedString === \"hello\", \"Expected 'hello'\");\nconsole.assert(unboxedNumberArray === 1, \"Expected 1\");", "golden_completion": "    return box.value as UnboxArray<T>;", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete a type-level pattern involving conditional types and inferred types. The key challenge is understanding how to correctly unbox the value within a generic Box type, particularly when the boxed value could be an array. The completion requires recognizing the pattern of using conditional types with 'infer' to extract the type from the array, if applicable, and returning the correct type accordingly. This example tests advanced TypeScript features such as conditional types, type inference, and generic functions, making it a good test case for low-context pattern matching capabilities in an LLM.", "assertions": "console.assert(unboxedString === \"hello\", \"Expected 'hello'\");\nconsole.assert(unboxedNumberArray === 1, \"Expected 1\");", "claude-3-7-sonnet": "    if (Array.isArray(box.value)) {\n        return box.value[0] as UnboxArray<T>;\n    }\n    return box.value as UnboxArray<T>;"}
{"id": "37", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type DeepReadonly<T> = {\n    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\nfunction freezeObject<T>(obj: T): DeepReadonly<T> {\n    Object.freeze(obj);\n", "suffix": "    return obj as DeepReadonly<T>;\n}\n\nconst original = { a: { b: { c: 42 } } };\nconst frozen = freezeObject(original);\n\ntry {\n    (frozen.a.b.c as any) = 100;\n} catch (e) {\n    console.log('Cannot modify readonly property');\n}\n\nconsole.assert(frozen.a.b.c === 42, 'The value should remain unchanged');\n", "golden_completion": "    Object.keys(obj).forEach(key => {\n        const value = obj[key];\n        if (typeof value === 'object' && value !== null) {\n            freezeObject(value);\n        }\n    });\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving advanced TypeScript types and type-safe immutability. The `DeepReadonly` type uses conditional types and mapped types to recursively make an object deeply readonly. The `freezeObject` function should recursively freeze nested objects, ensuring immutability. This requires understanding of TypeScript's type system and how to apply Object.freeze correctly in a recursive manner.", "assertions": "console.assert(frozen.a.b.c === 42, 'The value should remain unchanged');", "claude-3-7-sonnet": "    if (obj !== null && typeof obj === 'object') {\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                freezeObject(obj[key]);\n            }\n        }\n    }"}
{"id": "38", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n\nasync function getData(): Promise<number> {\n  return 42;\n}\n\nasync function processData() {\n  const data: ", "suffix": "await getData();\n  console.log(data);\n}\n\nprocessData();", "golden_completion": "UnwrapPromise<ReturnType<typeof getData>> = ", "LLM_justification": "This example tests the model's ability to handle complex type inference with conditional types and the 'infer' keyword. The scenario involves unwrapping a promise return type, which is a non-trivial task requiring understanding of advanced TypeScript type system features. The minimal context provided (a type alias and a function returning a promise) establishes a clear pattern for the model to follow.", "assertions": "import assert from 'assert';\n\nasync function test() {\n  const data: UnwrapPromise<ReturnType<typeof getData>> = await getData();\n  assert.strictEqual(data, 42, 'The data should be 42');\n  assert.strictEqual(typeof data, 'number', 'The data should be a number');\n}\n\ntest();", "claude-3-7-sonnet": "UnwrapPromise<ReturnType<typeof getData>> = "}
{"id": "39", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type DeepReadonly<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };\n\ninterface User {\n  name: string;\n  address: {\n    street: string;\n    city: string;\n  };\n}\n\nconst user: DeepReadonly<User> = {", "suffix": "};\n\nuser.name = \"New Name\"; // This should cause a TypeScript error\nuser.address.city = \"New City\"; // This should also cause a TypeScript error\n\nconsole.log(user);\n\nconst isReadonly = <T>(obj: T): obj is DeepReadonly<T> => true;\n\nif (isReadonly(user)) {\n  console.log(\"User is deeply readonly\");\n}\n", "golden_completion": "\"name\": \"John Doe\",\n  \"address\": {\n    \"street\": \"123 Main St\",\n    \"city\": \"Anytown\"\n  }\n", "LLM_justification": "This example tests the LLM's ability to complete a TypeScript type-level pattern involving DeepReadonly, which recursively makes all properties of an object readonly. The provided completion must match the established pattern, ensuring that the user object is deeply readonly. The scenario also includes type-checking logic to ensure the readonly properties are enforced.", "assertions": "import assert from 'assert';\n\nassert.throws(() => { user.name = \"New Name\"; }, /Cannot assign to 'name'/);\nassert.throws(() => { user.address.city = \"New City\"; }, /Cannot assign to 'city'/);\nassert(isReadonly(user), 'User should be deeply readonly');", "claude-3-7-sonnet": "  name: \"John Doe\",\n  address: {\n    street: \"123 Main St\",\n    city: \"Anytown\"\n  }"}
{"id": "40", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends (infer U)[] ? U : T;\ntype DeepFlatten<T> = T extends (infer U)[] ? DeepFlatten<U> : T;\nfunction flattenArray<T>(arr: T[]): Flatten<T>[] {\n", "suffix": "\n}\n\nconst nestedArray = [[1, 2, [3, 4]], [5, 6]];\nconst flatArray = flattenArray(nestedArray);\nconsole.assert(JSON.stringify(flatArray) === JSON.stringify([1, 2, [3, 4], 5, 6]), 'Test failed');", "golden_completion": "  return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flattenArray(val) : val), [] as Flatten<T>[]);", "LLM_justification": "This example tests the LLM's ability to recognize and complete the pattern of flattening nested arrays using recursive type definitions and functional programming constructs. The example requires understanding of conditional types, type inference, and array manipulation in TypeScript. The prefix defines utility types for flattening and deep flattening arrays, and the function signature for flattening an array. The suffix includes a test case to validate the functionality. The golden completion involves a recursive array reduction, which is a non-trivial pattern requiring deeper understanding of TypeScript's type system and array methods.", "assertions": "const nestedArray = [[1, 2, [3, 4]], [5, 6]];\nconst flatArray = flattenArray(nestedArray);\nconsole.assert(JSON.stringify(flatArray) === JSON.stringify([1, 2, [3, 4], 5, 6]), 'Test failed');", "claude-3-7-sonnet": "  return arr.reduce((acc, item) => {\n    if (Array.isArray(item)) {\n      return [...acc, ...item];\n    }\n    return [...acc, item];\n  }, [] as Flatten<T>[]);"}
{"id": "41", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends (infer U)[] ? U : T;\ntype TupleToUnion<T> = T extends (infer U)[] ? U : never;\n\nfunction flattenArray<T>(arr: T[]): Flatten<T>[] {\n", "suffix": "\n}\n\nconst nestedArray = [[1, 2, 3], [4, 5], [6]];\nconst flattened: number[] = flattenArray(nestedArray);\n\nimport assert from 'assert';\nassert.deepStrictEqual(flattened, [1, 2, 3, 4, 5, 6], 'The array should be flattened correctly');", "golden_completion": "  return ([] as Flatten<T>[]).concat(...arr);\n", "LLM_justification": "This scenario tests the LLM's ability to recognize and complete an advanced TypeScript pattern involving type manipulation with conditional types and type inference. The function `flattenArray` uses a custom type `Flatten` to determine the element type of a nested array, which is a non-trivial pattern requiring understanding of conditional types and type operators. The completion requires generating a type-safe flattening operation, maintaining type safety, and ensuring the correct output. This example challenges the LLM by requiring it to infer the correct use of TypeScript types and array operations with minimal context.", "assertions": "import assert from 'assert';\nconst nestedArray = [[1, 2, 3], [4, 5], [6]];\nconst flattened: number[] = flattenArray(nestedArray);\nassert.deepStrictEqual(flattened, [1, 2, 3, 4, 5, 6], 'The array should be flattened correctly');", "claude-3-7-sonnet": "  return arr.reduce((acc, item) => {\n    if (Array.isArray(item)) {\n      return [...acc, ...item as Flatten<T>[]];\n    }\n    return [...acc, item as Flatten<T>];\n  }, [] as Flatten<T>[]);"}
{"id": "42", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends Array<infer U> ? Flatten<U> : T;\n\nfunction flattenArray<T>(arr: T[]): Flatten<T>[] {", "suffix": "}\n\nconst nestedArray = [1, [2, [3, [4, [5]]]]];\nconst flattenedArray = flattenArray(nestedArray);\nconsole.log(flattenedArray);\n\nimport * as assert from 'assert';\n\nassert.deepStrictEqual(flattenedArray, [1, 2, 3, 4, 5]);", "golden_completion": "\treturn arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flattenArray(val)) : acc.concat(val), [] as Flatten<T>[]);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete advanced TypeScript type system patterns, specifically recursive type definitions and conditional types with 'infer'. The pattern of recursively flattening an array using a type-safe approach is common in production code, and requires understanding of both type inference and functional programming constructs in TypeScript. The assertions verify that the implementation correctly flattens nested arrays while preserving type safety.", "assertions": "assert.deepStrictEqual(flattenedArray, [1, 2, 3, 4, 5]);", "claude-3-7-sonnet": "  return arr.reduce<Flatten<T>[]>((acc, item) => {\n    if (Array.isArray(item)) {\n      return [...acc, ...flattenArray(item as any)];\n    } else {\n      return [...acc, item as Flatten<T>];\n    }\n  }, []);"}
{"id": "43", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends (infer U)[] ? U : T;\n\ninterface NestedArray<T> {\n    value: T[];\n    flatten(): Flatten<T[]>;\n}\n\nclass NumberArray implements NestedArray<number> {\n    value: number[];\n\n    constructor(value: number[]) {\n        this.value = value;\n    }\n\n    flatten(): Flatten<number[]> {", "suffix": "    }\n}\n\nconst arr = new NumberArray([1, 2, 3]);\nconst flat = arr.flatten();\n\nconsole.assert(flat === 1, 'Flatten should return the first element of the array');\nconsole.log('All assertions passed.');", "golden_completion": "        return this.value[0];", "LLM_justification": "This example tests the model's ability to handle conditional types and type inference in TypeScript. The `Flatten` type uses a conditional type with `infer` to determine the inner type of an array. The `NestedArray` interface and `NumberArray` class use this type to implement a `flatten` method. This scenario is complex enough to challenge a senior developer and requires understanding of advanced TypeScript type features.", "assertions": "console.assert(flat === 1, 'Flatten should return the first element of the array');", "claude-3-7-sonnet": "        return this.value[0];"}
{"id": "44", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type Flatten<T> = T extends Array<infer U> ? U : T;\n\nfunction flattenArray<T>(arr: T[]): Flatten<T>[] {", "suffix": "    return arr.reduce<Flatten<T>[]>((acc, val) => acc.concat(Array.isArray(val) ? flattenArray(val) : val), [] as Flatten<T>[]);\n}\n\nconst nestedArray = [1, [2, [3, 4], 5], 6];\nconst flatArray = flattenArray(nestedArray);\n\nconsole.log(flatArray);\n// Assertions\nimport assert from 'assert';\nassert.deepStrictEqual(flatArray, [1, 2, 3, 4, 5, 6]);", "golden_completion": "    if (!Array.isArray(arr)) throw new TypeError('Input must be an array');", "LLM_justification": "This example tests the LLM's ability to recognize a complex type transformation pattern, specifically using conditional types with the 'infer' keyword in TypeScript. The 'Flatten' type and the 'flattenArray' function demonstrate advanced type manipulations. The golden completion involves adding a type check and error handling, which is a common yet non-trivial practice in production code. This tests the LLM's understanding of TypeScript's type system, error handling patterns, and functional programming constructs within a low-context scenario.", "assertions": "assert.throws(() => flattenArray((123 as unknown) as number[]), TypeError, 'Input must be an array');\nassert.throws(() => flattenArray((null as unknown) as number[]), TypeError, 'Input must be an array');\nassert.deepStrictEqual(flatArray, [1, 2, 3, 4, 5, 6]);", "claude-3-7-sonnet": "    return arr.reduce<Flatten<T>[]>((acc, val) => acc.concat(Array.isArray(val) ? flattenArray(val) : val), [] as Flatten<T>[]);"}
{"id": "45", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type ExtractPromiseType<T> = T extends Promise<infer U> ? U : never;\n\nasync function fetchData(): Promise<string> {\n    return 'data';\n}\n\nasync function main() {\n    const result: ExtractPromiseType<ReturnType<typeof fetchData>> = await fetchData();", "suffix": "\n    console.log(result);\n}\n\nmain();", "golden_completion": "\n    console.assert(typeof result === 'string', 'Expected result to be a string');", "LLM_justification": "This example demonstrates the use of advanced TypeScript type system features, specifically conditional types with 'infer'. The pattern involves extracting the resolved type of a Promise using a conditional type and then using it to type a variable. This scenario is complex enough to challenge a senior TypeScript developer and requires understanding of advanced type inference and type manipulation. The prefix and suffix provide minimal context while establishing a clear pattern recognizable by experienced developers.", "assertions": "console.assert(typeof result === 'string', 'Expected result to be a string');", "claude-3-7-sonnet": ""}
{"id": "46", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type ExtractFunction<T> = T extends (...args: any[]) => infer R ? R : never;\ninterface Person {\n  name: string;\n  age: number;\n}\nclass Developer implements Person {\n  name: string;\n  age: number;\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n  code(): string {\n    return `${this.name} is coding.`;\n  }\n}\nfunction getFunctionReturnType<T>(func: T): ExtractFunction<T> {\n", "suffix": "}\nconst dev = new Developer(\"Alice\", 30);\nconst returnType = getFunctionReturnType(dev.code);\nconsole.assert(returnType === \"Alice is coding.\", \"Return type should be string\");\nconsole.log(\"All assertions passed!\");", "golden_completion": "  return func();\n", "LLM_justification": "This example tests the model's ability to understand and complete a pattern involving TypeScript's advanced type system, specifically conditional types and infer keyword. The context is minimal, focusing on extracting the return type of a function. The completion requires knowledge of how to properly use TypeScript's type inference and function execution.", "assertions": "console.assert(typeof returnType === 'string', 'Return type should be a string');", "claude-3-7-sonnet": "  // This function uses type assertion to cast the result of calling the function to the extracted return type\n  return func() as ExtractFunction<T>;"}
{"id": "47", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type DeepReadonly<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };\n\nfunction deepFreeze<T>(obj: T): DeepReadonly<T> {\n  Object.freeze(obj);\n  Object.keys(obj).forEach((key) => {", "suffix": "  });\n  return obj as DeepReadonly<T>;\n}\n\nconst obj = { a: { b: 1 } };\nconst frozenObj = deepFreeze(obj);\n\n// Assertions\nimport * as assert from 'assert';\nassert.throws(() => { frozenObj.a.b = 2; }, /Cannot assign to read only property 'b'/);\nassert.strictEqual(frozenObj.a.b, 1);\n", "golden_completion": "    const value = obj[key as keyof T];\n    if (typeof value === 'object' && value !== null) {\n      deepFreeze(value);\n    }\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and complete an advanced type-level computation pattern with recursive type definitions and mapped types. The pattern involves creating a deeply readonly type, and the function `deepFreeze` must recursively freeze all nested objects. The assertions ensure that the object properties become immutable, demonstrating understanding of both TypeScript's type system and object manipulation.", "assertions": "assert.throws(() => { frozenObj.a.b = 2; }, /Cannot assign to read only property 'b'/);\nassert.strictEqual(frozenObj.a.b, 1);\n", "claude-3-7-sonnet": "    const prop = obj[key as keyof T];\n    if (prop !== null && typeof prop === 'object' && !Object.isFrozen(prop)) {\n      deepFreeze(prop);\n    }"}
{"id": "48", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type DeepReadonly<T> = { readonly [K in keyof T]: DeepReadonly<T[K]> };\n\ninterface User {\n  id: number;\n  name: string;\n  preferences: {\n    theme: string;\n    notifications: boolean;\n  };\n}\n\nconst user: DeepReadonly<User> = {\n  id: 1,\n  name: 'Alice',\n  preferences: {\n    theme: 'dark',\n    notifications: true,\n  },\n};\n\n", "suffix": "try {\n  // This line should cause a TypeScript error\n  user.preferences.theme = 'light';\n} catch (e) {\n  console.error(e);\n}\n\nconsole.log(user.preferences.theme);", "golden_completion": "type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K] };", "LLM_justification": "This test case evaluates the LLM's ability to complete an advanced TypeScript pattern involving recursive mapped types. The `DeepReadonly` type needs to be correctly defined to make all nested properties of an object immutable. This requires understanding conditional types and type recursion, which are more complex than simple type definitions. The prefix and suffix together provide minimal context, yet they establish a recognizable pattern that tests the LLM's comprehension of TypeScript's type system. The provided golden completion ensures that nested properties are correctly marked as readonly, and the assertions check for immutability.", "assertions": "import { strict as assert } from 'assert';\nassert.throws(() => { user.preferences.theme = 'light'; }, /Cannot assign to read only property/);\nassert.equal(user.preferences.theme, 'dark');", "claude-3-7-sonnet": "// "}
{"id": "49", "testsource": "devbench-low-context", "language": "typescript", "prefix": "type TupleToUnion<T> = T extends (infer U)[] ? U : never;\n\nconst exampleTuple: [string, number, boolean] = ['hello', 42, true];\n\n// Type should be 'string | number | boolean'\ntype ExampleUnion = TupleToUnion<typeof exampleTuple>;\n\nfunction processUnion(value: ExampleUnion) {", "suffix": "}\n\n// Test cases\nconst testValues: ExampleUnion[] = ['test', 123, false];\nfor (const val of testValues) {\n    processUnion(val);\n}\n\nconsole.log('All test cases passed.');", "golden_completion": "    if (typeof value === 'string') {\n        console.log(`String value: ${value}`);\n    } else if (typeof value === 'number') {\n        console.log(`Number value: ${value}`);\n    } else if (typeof value === 'boolean') {\n        console.log(`Boolean value: ${value}`);\n    }", "LLM_justification": "This example tests the LLM's ability to handle advanced TypeScript type system features, specifically conditional types with 'infer' and tuple to union type transformations. The prefix and suffix establish a context where the completion must correctly handle various types within a union, demonstrating understanding of type inference and type guards.", "assertions": "import * as assert from 'assert';\n\nconst loggedValues: string[] = [];\nconst originalLog = console.log;\nconsole.log = (message: string) => { loggedValues.push(message); };\n\nconst testValues: ExampleUnion[] = ['test', 123, false];\nfor (const val of testValues) {\n    processUnion(val);\n}\n\nassert.deepStrictEqual(loggedValues, ['String value: test', 'Number value: 123', 'Boolean value: false'], 'All values should be logged correctly based on their types.');\n\n// Restore original console.log\nconsole.log = originalLog;\n\nconsole.log('All assertions passed.');", "claude-3-7-sonnet": "  if (typeof value === 'string') {\n    console.log(`Processing string: ${value}`);\n  } else if (typeof value === 'number') {\n    console.log(`Processing number: ${value}`);\n  } else if (typeof value === 'boolean') {\n    console.log(`Processing boolean: ${value}`);\n  }"}
{"id": "50", "testsource": "devbench-low-context", "language": "typescript", "prefix": "interface Visitor<T> {\n    visit(node: T): void;\n}\n\nabstract class Node {\n    abstract accept<T>(visitor: Visitor<T>): void;\n}\n\nclass LeafNode extends Node {\n    value: number;\n    constructor(value: number) {\n        super();\n        this.value = value;\n    }\n    accept<T>(visitor: Visitor<T>): void {", "suffix": "    }\n}\n\nclass PrintVisitor implements Visitor<LeafNode> {\n    visit(node: LeafNode): void {\n        console.log(`LeafNode value: ${node.value}`);\n    }\n}\n\nconst node = new LeafNode(42);\nconst visitor = new PrintVisitor();\nnode.accept(visitor);\n\n// Assertions\nimport assert from 'assert';\nconst consoleLogSpy = console.log as unknown as { calls: string[] };\nconsole.log = (...args: string[]) => { consoleLogSpy.calls = args; };\nnode.accept(visitor);\nassert.strictEqual(consoleLogSpy.calls[0], 'LeafNode value: 42');\n", "golden_completion": "        visitor.visit(this);", "LLM_justification": "This example demonstrates the Visitor pattern in TypeScript, which is an advanced object-oriented pattern. The prefix defines an abstract class Node and a Visitor interface, while the suffix shows a concrete implementation of the Node class and a Visitor class. The completion requires understanding of how to correctly implement the accept method in the context of the Visitor pattern. This pattern requires the model to correctly infer the need to call visitor.visit(this) inside the accept method, showcasing its ability to recognize and complete advanced object-oriented design patterns with minimal context.", "assertions": "import assert from 'assert';\nconst consoleLogSpy = console.log as unknown as { calls: string[] };\nconsole.log = (...args: string[]) => { consoleLogSpy.calls = args; };\nnode.accept(visitor);\nassert.strictEqual(consoleLogSpy.calls[0], 'LeafNode value: 42');", "claude-3-7-sonnet": "        visitor.visit(this);"}
