{"id": "1", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Sequelize, DataTypes, Model } from 'sequelize';\nimport assert from 'assert';\n\n// Setting up a Sequelize instance and defining models\nconst sequelize = new Sequelize('sqlite::memory:');\n\nclass User extends Model {}\nUser.init({\n  username: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  birthday: {\n    type: DataTypes.DATE,\n    allowNull: false\n  }\n}, {\n  sequelize,\n  modelName: 'User'\n});\n\nclass Post extends Model {}\nPost.init({\n  title: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  content: {\n    type: DataTypes.TEXT,\n    allowNull: false\n  }\n}, {\n  sequelize,\n  modelName: 'Post'\n});\n\n// Helper function to create users\nasync function createUser(username: string, birthday: Date) {\n  return await User.create({ username, birthday });\n}\n\n// Helper function to create posts\nasync function createPost(title: string, content: string) {\n  return await Post.create({ title, content });\n}\n\n// Establishing associations between models\nUser.hasMany(Post, { as: 'posts' });\nPost.belongsTo(User, { as: 'user' });\n\nasync function main() {\n  await sequelize.sync({ force: true });\n\n  // Creating a user and a post\n  const user = await createUser('johndoe', new Date('1990-01-01'));\n  const post = await createPost('My First Post', 'This is the content of my first post.');\n\n  // Associating the post with the user\n  await user['addPost'](post);\n\n  // Fetching the user with associated posts\n  const fetchedUser = await User.findByPk(user.id, { include: [{ model: Post, as: 'posts' }] });\n\n  assert(fetchedUser !== null, 'Fetched user should not be null');\n  assert(fetchedUser.posts.length === 1, 'User should have one post');\n  assert(fetchedUser.posts[0].title === 'My First Post', 'Post title should match');", "suffix": "\n  // Clean up resources\n  await sequelize.close();\n}\n\nmain().catch(error => console.error('Error in main function:', error));", "golden_completion": "\n  assert(fetchedUser.posts[0].content === 'This is the content of my first post.', 'Post content should match');", "LLM_justification": "This test case demonstrates the use of Sequelize ORM with TypeScript, focusing on model associations and fetching related data. It tests the LLM's ability to recognize and complete patterns in a real-world scenario involving less common Sequelize functions like 'addPost' and fetching associated models. The completion includes a specific assertion to verify the content of the post, showcasing the correct usage of Sequelize's querying and association methods.", "assertions": "assert(fetchedUser.posts[0].content === 'This is the content of my first post.', 'Post content should match');", "o1-mini": ""}
{"id": "2", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Sequelize, Model, DataTypes } from 'sequelize';\nimport assert from 'assert';\n\n// Initialize a Sequelize instance for SQLite\nconst sequelize = new Sequelize('sqlite::memory:');\n\n// Define a User model\nclass User extends Model {\n  public id!: number;\n  public name!: string;\n  public age!: number;\n}\n\nUser.init({\n  id: {\n    type: DataTypes.INTEGER,\n    autoIncrement: true,\n    primaryKey: true,\n  },\n  name: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n  age: {\n    type: DataTypes.INTEGER,\n    allowNull: false,\n  },\n}, { sequelize, modelName: 'User' });\n\n// Sync the database\nawait sequelize.sync({ force: true });\n\n// Create a new user instance\nconst newUser = await User.create({ name: 'Alice', age: 30 });\n\n// Define a function to update user age\nasync function updateUserAge(userId: number, newAge: number): Promise<User | null> {\n  try {\n    const user = await User.findByPk(userId);\n    if (user) {\n      user.age = newAge;\n      await user.save();\n      return user;\n    }\n    return null;\n  } catch (error) {\n    console.error('Error updating user age:', error);\n    return null;\n  }\n}\n\n// Update the user age and retrieve the updated user\nconst updatedUser = await updateUserAge(newUser.id, 35);\n\n// Assert the updated user's age is correct\nassert(updatedUser !== null);\nassert.strictEqual(updatedUser!.age, 35);\n\n// Define a function to delete a user by ID\nasync function deleteUserById(userId: number): Promise<boolean> {\n  try {\n    const user = await User.findByPk(userId);\n    if (user) {\n      await user.destroy();\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error('Error deleting user:', error);\n    return false;\n  }\n}\n\n// Delete the user and assert the user is deleted\nconst deleteResult = await deleteUserById(newUser.id);\nassert(deleteResult);\n\n", "suffix": "console.log('User operations completed successfully.');\nawait sequelize.close();", "golden_completion": "\n\n// Check if the user still exists\nconst checkUser = await User.findByPk(newUser.id);\nassert.strictEqual(checkUser, null);", "LLM_justification": "This test case demonstrates the usage of Sequelize, an ORM for Node.js, to perform common database operations such as creating, updating, and deleting records. It tests the model's understanding of Sequelize's API, including handling asynchronous operations and proper error handling. By focusing on less frequently used methods like `destroy` and ensuring resources are properly cleaned up, this scenario provides a comprehensive evaluation of rare API usage capabilities.", "assertions": "assert(deleteResult);\nassert.strictEqual(checkUser, null);", "o1-mini": ""}
{"id": "3", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import AWS from 'aws-sdk';\nimport { assert } from 'assert';\n\nAWS.config.update({\n  region: 'us-west-2',\n  accessKeyId: 'your-access-key-id',\n  secretAccessKey: 'your-secret-access-key'\n});\n\nconst dynamoDb = new AWS.DynamoDB.DocumentClient();\n\n// Function to create a new item in DynamoDB\nasync function createItem(tableName: string, item: any): Promise<void> {\n  const params = {\n    TableName: tableName,\n    Item: item\n  };\n  await dynamoDb.put(params).promise();\n}\n\n// Function to get an item from DynamoDB\nasync function getItem(tableName: string, key: any): Promise<any> {\n  const params = {\n    TableName: tableName,\n    Key: key\n  };\n  const result = await dynamoDb.get(params).promise();\n  return result.Item;\n}\n\n// Function to delete an item from DynamoDB\nasync function deleteItem(tableName: string, key: any): Promise<void> {\n  const params = {\n    TableName: tableName,\n    Key: key\n  };\n  await dynamoDb.delete(params).promise();\n}\n\n// Function to update an item in DynamoDB\nasync function updateItem(tableName: string, key: any, updateExpression: string, expressionAttributeValues: any): Promise<void> {\n  const params = {\n    TableName: tableName,\n    Key: key,\n    UpdateExpression: updateExpression,\n    ExpressionAttributeValues: expressionAttributeValues\n  };\n  await dynamoDb.update(params).promise();\n}\n\n// Test functions\nconst tableName = 'TestTable';\nconst testItem = { id: '1', name: 'Test Item', description: 'This is a test item' };\nconst updatedItem = { ':name': 'Updated Test Item', ':description': 'This is an updated test item' };\nconst key = { id: '1' };\n\n(async () => {\n  await createItem(tableName, testItem);\n  const fetchedItem = await getItem(tableName, key);\n  assert.deepStrictEqual(fetchedItem, testItem, 'Item fetched should match the created item');\n", "suffix": "\n  await deleteItem(tableName, key);\n  const deletedItem = await getItem(tableName, key);\n  assert.strictEqual(deletedItem, undefined, 'Item should be deleted');\n})();\n", "golden_completion": "  await updateItem(tableName, key, 'set name = :name, description = :description', updatedItem);\n  const updatedFetchedItem = await getItem(tableName, key);\n  assert.deepStrictEqual(updatedFetchedItem.name, 'Updated Test Item', 'Item name should be updated');\n  assert.deepStrictEqual(updatedFetchedItem.description, 'This is an updated test item', 'Item description should be updated');\n", "LLM_justification": "This test case is a good example of using AWS SDK for DynamoDB with TypeScript. It demonstrates the ability to create, read, update, and delete items in a DynamoDB table. The golden_completion section specifically tests the rare but valid usage of the updateItem function with an uncommon parameter structure involving an update expression and expression attribute values, which is less commonly demonstrated in simple CRUD examples. This scenario ensures that the model can handle complex and less frequently used API patterns correctly.", "assertions": "assert.deepStrictEqual(updatedFetchedItem.name, 'Updated Test Item', 'Item name should be updated');\nassert.deepStrictEqual(updatedFetchedItem.description, 'This is an updated test item', 'Item description should be updated');", "o1-mini": ""}
{"id": "4", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as AWS from 'aws-sdk';\nimport { assert } from 'assert';\n\n// Initialize the AWS SDK with credentials\nAWS.config.update({\n  accessKeyId: 'AKID',\n  secretAccessKey: 'SECRET'\n});\n\n// Create an instance of the S3 service\nconst s3 = new AWS.S3();\n\n// Helper function to create a bucket\nasync function createBucket(bucketName: string) {\n  try {\n    const params = {\n      Bucket: bucketName\n    };\n    await s3.createBucket(params).promise();\n    console.log(`Bucket ${bucketName} created successfully`);\n  } catch (error) {\n    console.error(`Error creating bucket: ${error.message}`);\n  }\n}\n\n// Helper function to list objects in a bucket\nasync function listObjects(bucketName: string) {\n  try {\n    const params = {\n      Bucket: bucketName\n    };\n    const data = await s3.listObjectsV2(params).promise();\n    return data.Contents;\n  } catch (error) {\n    console.error(`Error listing objects: ${error.message}`);\n    return [];\n  }\n}\n\n// Helper function to delete a bucket\nasync function deleteBucket(bucketName: string) {\n  try {\n    const params = {\n      Bucket: bucketName\n    };\n    await s3.deleteBucket(params).promise();\n    console.log(`Bucket ${bucketName} deleted successfully`);\n  } catch (error) {\n    console.error(`Error deleting bucket: ${error.message}`);\n  }\n}\n\n// Test case setup\nconst testBucketName = 'test-bucket-api-usage';\n\n(async () => {\n  await createBucket(testBucketName);\n\n  // Upload an object to the bucket\n  const putObjectParams = {\n    Bucket: testBucketName,\n    Key: 'test-object.txt',\n    Body: 'Hello, world!'\n  };\n  await s3.putObject(putObjectParams).promise();\n  console.log('Object uploaded successfully');\n\n  // List objects to ensure the upload was successful\n  const objects = await listObjects(testBucketName);\n  assert(objects.length === 1, 'There should be one object in the bucket');\n  assert(objects[0].Key === 'test-object.txt', 'The object key should be test-object.txt');\n\n  // Example of using deprecated API\n  const deprecatedParams = {\n    Bucket: testBucketName,\n    Key: 'test-object.txt'\n  };\n\n", "suffix": "\n  const headData = await s3.headObject(deprecatedParams).promise();\n  assert(headData.ContentLength === 13, 'Object content length should be 13');\n  assert(headData.ContentType === 'text/plain', 'Object content type should be text/plain');\n\n  await deleteBucket(testBucketName);\n})();", "golden_completion": "\n  const data = await s3.getObject(deprecatedParams).promise();\n  assert(data.Body.toString('utf-8') === 'Hello, world!', 'The object content should be Hello, world!');\n", "LLM_justification": "This test case demonstrates the usage of AWS SDK with a mix of current and deprecated API functions. The use of `getObject` method is less common as compared to other S3 operations and tests the model's ability to recognize and complete deprecated but valid API patterns. The assertions ensure that the object was uploaded and retrieved correctly, verifying the correctness of API usage and parameter ordering.", "assertions": "assert(data.Body.toString('utf-8') === 'Hello, world!', 'The object content should be Hello, world!');", "o1-mini": ""}
{"id": "5", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Pusher } from 'pusher';\nimport assert from 'assert';\n\n// Initialize Pusher with deprecated configuration method\nconst pusher = new Pusher({\n  appId: 'your-app-id',\n  key: 'your-key',\n  secret: 'your-secret',\n  cluster: 'your-cluster',\n  useTLS: true\n});\n\n// Helper function to send a message\nasync function sendMessage(channel: string, event: string, message: any): Promise<void> {\n  return new Promise((resolve, reject) => {\n    pusher.trigger(channel, event, message, (error, request, response) => {\n      if (error) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n// Helper function to authenticate a user\nfunction authenticateUser(socketId: string, channel: string): string {\n  return pusher.authenticate(socketId, channel);\n}\n\n// Test data\nconst testChannel = 'my-channel';\nconst testEvent = 'my-event';\nconst testMessage = { text: 'Hello, World!' };\nconst testSocketId = '1234.5678';\nconst testChannelPrivate = 'private-my-channel';\n\nasync function main() {\n  try {\n    // Send a test message\n    await sendMessage(testChannel, testEvent, testMessage);\n    console.log('Message sent successfully');\n\n    // Authenticate a user\n    const auth = authenticateUser(testSocketId, testChannelPrivate);\n    console.log('User authenticated successfully', auth);\n\n    // Assert the message format\n    assert.strictEqual(typeof testMessage.text, 'string');\n    assert.strictEqual(testMessage.text, 'Hello, World!');\n\n    // Assert the authentication format\n    assert.strictEqual(typeof auth, 'string');\n", "suffix": "\n    // Cleanup resources\n    pusher.disconnect();\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n}\n\nmain();", "golden_completion": "    assert.ok(auth.includes('auth'));", "LLM_justification": "This test case demonstrates the usage of the Pusher library with a deprecated configuration method, focusing on less common API functions such as triggering events and authenticating users. The completion involves verifying the authentication response, which is a critical step in ensuring the proper functioning of real-time communication. The example includes appropriate setup and teardown, making it a robust and realistic scenario for testing the model's understanding of uncommon API usage.", "assertions": "assert.strictEqual(typeof testMessage.text, 'string');\nassert.strictEqual(testMessage.text, 'Hello, World!');\nassert.strictEqual(typeof auth, 'string');\nassert.ok(auth.includes('auth'));", "o1-mini": ""}
{"id": "6", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { assert } from 'assert';\n\n// Initialize Apollo Client\nconst client = new ApolloClient({\n  uri: 'https://example.com/graphql',\n  cache: new InMemoryCache()\n});\n\n// Define a query to get a list of books\nconst BOOKS_QUERY = gql`\n  query GetBooks {\n    books {\n      id\n      title\n      author\n    }\n  }\n`;\n\n// Define a function to fetch books\nasync function fetchBooks() {\n  try {\n    const result = await client.query({\n      query: BOOKS_QUERY\n    });\n    return result.data.books;\n  } catch (error) {\n    console.error('Error fetching books:', error);\n    throw error;\n  }\n}\n\n// Example usage of fetchBooks function\nfetchBooks().then(books => {\n  console.log('Fetched books:', books);\n}).catch(error => {\n  console.error('Error:', error);\n});\n\n// Define a mutation to add a new book\nconst ADD_BOOK_MUTATION = gql`\n  mutation AddBook($title: String!, $author: String!) {\n    addBook(title: $title, author: $author) {\n      id\n      title\n      author\n    }\n  }\n`;\n\n// Define a function to add a new book\nasync function addBook(title: string, author: string) {\n  try {\n    const result = await client.mutate({\n      mutation: ADD_BOOK_MUTATION,\n      variables: { title, author }\n    });\n    return result.data.addBook;\n  } catch (error) {\n    console.error('Error adding book:', error);\n    throw error;\n  }\n}\n\n// Example usage of addBook function\naddBook('New Book', 'Author Name').then(newBook => {\n  console.log('Added new book:', newBook);\n}).catch(error => {\n  console.error('Error:', error);\n});\n\n// Define a query to get a book by ID\nconst BOOK_BY_ID_QUERY = gql`\n  query GetBookById($id: ID!) {\n    book(id: $id) {\n      id\n      title\n      author\n    }\n  }\n`;\n\n// Define a function to fetch a book by ID\nasync function fetchBookById(id: string) {\n  try {\n    const result = await client.query({\n      query: BOOK_BY_ID_QUERY,\n      variables: { id }\n    });\n    return result.data.book;\n  } catch (error) {\n    console.error('Error fetching book by ID:', error);\n    throw error;\n  }\n}\n\n// Example usage of fetchBookById function\nfetchBookById('1').then(book => {\n  console.log('Fetched book by ID:', book);\n}).catch(error => {\n  console.error('Error:', error);\n});", "suffix": "// Example usage of deleteBook function\ndeleteBook('1').then(deletedBook => {\n  console.log('Deleted book:', deletedBook);\n}).catch(error => {\n  console.error('Error:', error);\n});", "golden_completion": "async function deleteBook(id: string) {\n  const DELETE_BOOK_MUTATION = gql`\n    mutation DeleteBook($id: ID!) {\n      deleteBook(id: $id) {\n        id\n        title\n        author\n      }\n    }\n  `;\n  try {\n    const result = await client.mutate({\n      mutation: DELETE_BOOK_MUTATION,\n      variables: { id }\n    });\n    return result.data.deleteBook;\n  } catch (error) {\n    console.error('Error deleting book:', error);\n    throw error;\n  }\n}", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and continue a pattern of using Apollo Client with GraphQL in TypeScript. The provided context includes multiple examples of queries and mutations, establishing a clear pattern. The completion requires defining a new mutation and using it with Apollo Client, which involves understanding the structure of GraphQL queries, variables, and the Apollo Client API. This scenario also tests the LLM's ability to handle errors and maintain consistent parameter ordering and naming conventions.", "assertions": "deleteBook('1').then(deletedBook => {\n  assert(deletedBook.id === '1', 'Book ID should be 1');\n  assert(deletedBook.title, 'Book should have a title');\n  assert(deletedBook.author, 'Book should have an author');\n}).catch(error => {\n  console.error('Assertion error:', error);\n});", "o1-mini": ""}
{"id": "7", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { DynamoDB } from 'aws-sdk';\nimport assert from 'assert';\n\n// Initialize the DynamoDB DocumentClient\nconst documentClient = new DynamoDB.DocumentClient();\n\n// Helper function to create a table\nasync function createTable() {\n    const params = {\n        TableName: 'TestTable',\n        KeySchema: [\n            { AttributeName: 'id', KeyType: 'HASH' }\n        ],\n        AttributeDefinitions: [\n            { AttributeName: 'id', AttributeType: 'S' }\n        ],\n        ProvisionedThroughput: {\n            ReadCapacityUnits: 1,\n            WriteCapacityUnits: 1\n        }\n    };\n    await new DynamoDB().createTable(params).promise();\n}\n\n// Helper function to delete a table\nasync function deleteTable() {\n    const params = {\n        TableName: 'TestTable'\n    };\n    await new DynamoDB().deleteTable(params).promise();\n}\n\n// Helper function to add an item to the table\nasync function addItem(id: string, value: string) {\n    const params = {\n        TableName: 'TestTable',\n        Item: {\n            'id': { S: id },\n            'value': { S: value }\n        }\n    };\n    await documentClient.put(params).promise();\n}\n\n// Helper function to get an item from the table\nasync function getItem(id: string) {\n    const params = {\n        TableName: 'TestTable',\n        Key: {\n            'id': { S: id }\n        }\n    };\n    const result = await documentClient.get(params).promise();\n    return result.Item;\n}\n\n// Main function to test the deprecated API usage\nasync function testDeprecatedAPI() {\n    await createTable();\n    try {\n        // Adding an item to the table\n        await addItem('123', 'testValue');\n\n        // Retrieving the item from the table\n        const item = await getItem('123');\n", "suffix": "\n        // Checking if the item retrieved is correct\n        assert.strictEqual(item.value.S, 'testValue');\n    } finally {\n        // Clean up: delete the table\n        await deleteTable();\n    }\n}\n\n// Run the test function\n(async () => {\n    await testDeprecatedAPI();\n})();", "golden_completion": "        // Validating the structure of the retrieved item\n        assert.strictEqual(item.id.S, '123');", "LLM_justification": "This test case uses the AWS SDK for JavaScript, specifically the DynamoDB.DocumentClient, to test uncommon API usage patterns. The focus is on using deprecated methods to interact with DynamoDB, such as using the 'S' attribute to specify string values in the Item object. This scenario involves creating a table, adding an item, retrieving the item, and validating its structure. The golden completion demonstrates the correct usage of these deprecated methods, ensuring that the item structure is validated properly. The test case includes setup and cleanup functions to manage the DynamoDB table, providing a realistic and comprehensive example.", "assertions": "assert.strictEqual(item.id.S, '123');", "o1-mini": ""}
{"id": "8", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { WebSocketLink } from '@apollo/client/link/ws';\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\n\n// Configuration for WebSocket connection\nconst wsClient = new SubscriptionClient('ws://localhost:4000/graphql', {\n  reconnect: true,\n});\n\n// Apollo Client setup with WebSocket link\nconst client = new ApolloClient({\n  link: new WebSocketLink(wsClient),\n  cache: new InMemoryCache(),\n});\n\n// Subscription query to listen for new messages\nconst NEW_MESSAGE_SUBSCRIPTION = gql`\n  subscription OnNewMessage {\n    newMessage {\n      id\n      content\n      author {\n        id\n        name\n      }\n    }\n  }\n`;\n\n// Function to handle new messages\nfunction handleNewMessage(message: any) {\n  console.log('New message received:', message);\n}\n\n// Subscribing to new messages\nconst subscription = client.subscribe({\n  query: NEW_MESSAGE_SUBSCRIPTION,\n})\n.subscribe({\n  next(response) {\n    handleNewMessage(response.data.newMessage);\n  },\n  error(err) {\n    console.error('Subscription error:', err);\n  }\n});", "suffix": "subscription.unsubscribe();\n\n// Assertions\nimport { strict as assert } from 'assert';\nassert(subscription, 'Subscription should be defined');\n\n// Assuming we have a mock function to send a new message for testing\nasync function mockSendNewMessage() {\n  // Implementation of sending a new message\n}\n\nawait mockSendNewMessage();\n\n// Add a delay to ensure the subscription receives the message\nawait new Promise(resolve => setTimeout(resolve, 1000));\n\n// Cleanup\nwsClient.close();", "golden_completion": "setTimeout(() => {\n  // Unsubscribe after a certain period\n  subscription.unsubscribe();\n}, 5000);", "LLM_justification": "This example tests the LLM's ability to correctly implement a subscription pattern with Apollo Client and WebSocketLink, specifically focusing on the rare usage of unsubscribing from a subscription after a delay. The completion demonstrates handling the unsubscription timing, which is a less common but valid use case. The prefix sets up the context with a subscription to new messages, and the suffix includes assertions to verify the subscription and a mock function to simulate sending a new message. The golden_completion correctly uses setTimeout to unsubscribe after 5 seconds, ensuring the subscription is cleaned up properly after testing.", "assertions": "assert(subscription, 'Subscription should be defined');", "o1-mini": ""}
{"id": "9", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Sequelize, DataTypes, Model } from 'sequelize';\nimport assert from 'assert';\n\n// Initialize Sequelize with SQLite dialect for testing purposes\nconst sequelize = new Sequelize('sqlite::memory:');\n\n// Define a User model with uncommon field options\nclass User extends Model {}\nUser.init({\n  id: {\n    type: DataTypes.UUID,\n    defaultValue: DataTypes.UUIDV4,\n    primaryKey: true\n  },\n  name: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    unique: true\n  },\n  email: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    validate: {\n      isEmail: true\n    }\n  },\n  metadata: {\n    type: DataTypes.JSONB,\n    allowNull: true,\n    defaultValue: {}\n  }\n}, {\n  sequelize,\n  modelName: 'User',\n  timestamps: false\n});\n\n(async () => {\n  try {\n    // Sync the model with the database\n    await sequelize.sync();\n\n    // Helper function to create a new user\n    async function createUser(name: string, email: string, metadata: object) {\n      const user = await User.create({ name, email, metadata });\n      return user;\n    }\n\n    // Create test user\n    const testUser = await createUser('Alice', 'alice@example.com', { age: 30 });\n\n    // Function to update user's metadata using uncommon Sequelize options\n    async function updateUserMetadata(userId: string, newMetadata: object) {\n      const [rowsUpdated] = await User.update({ metadata: newMetadata }, {\n        where: { id: userId },\n        returning: true,\n        individualHooks: true\n      });\n      return rowsUpdated;\n    }\n\n    // Update metadata of the test user\n    const rowsUpdated = await updateUserMetadata(testUser.id, { age: 31 });\n\n    // Assertions to verify the update\n    assert.strictEqual(rowsUpdated, 1, 'Exactly one row should be updated');\n    const updatedUser = await User.findByPk(testUser.id);\n    assert.strictEqual(updatedUser.metadata.age, 31, 'The metadata.age should be updated to 31');\n\n    // Additional uncommon usage of Sequelize\n    // Function to increment user's age using sequelize.fn\n    async function incrementUserAge(userId: string) {\n      await User.update({\n        'metadata.age': sequelize.fn('COALESCE', sequelize.col('metadata.age'), 0),\n        'metadata.age': sequelize.literal('metadata.age + 1')\n      }, {\n        where: { id: userId }\n      });\n    }\n\n    // Increment age of the test user\n    await incrementUserAge(testUser.id);\n\n    // Assertions to verify the increment\n    const incrementedUser = await User.findByPk(testUser.id);\n    assert.strictEqual(incrementedUser.metadata.age, 32, 'The metadata.age should be incremented to 32');\n\n", "suffix": "    // Additional assertions\n    assert.strictEqual(typeof incrementedUser.metadata, 'object', 'The metadata should be an object');\n    assert.strictEqual(incrementedUser.metadata.age, 32, 'The metadata.age should be 32 after increment');\n\n    // Cleanup\n    await User.destroy({ where: { id: testUser.id } });\n    await sequelize.close();\n  } catch (error) {\n    console.error('Error during test execution:', error);\n  }\n})();\n", "golden_completion": "    // Assertions to verify the increment\n    const incrementedUser = await User.findByPk(testUser.id);\n    assert.strictEqual(incrementedUser.metadata.age, 32, 'The metadata.age should be incremented to 32');\n\n", "LLM_justification": "This test case demonstrates the use of uncommon Sequelize options such as 'returning', 'individualHooks', and the combination of 'sequelize.fn' and 'sequelize.literal' for updating JSONB fields. These features are rarely used together and require a deep understanding of Sequelize's API. The assertions validate the correctness of these operations, ensuring that the metadata is updated and incremented as expected. This example is a good test case for an LLM as it involves complex and less common API usage patterns, making it challenging for the model to generate the correct completion without proper understanding.", "assertions": "assert.strictEqual(rowsUpdated, 1, 'Exactly one row should be updated');\nconst updatedUser = await User.findByPk(testUser.id);\nassert.strictEqual(updatedUser.metadata.age, 31, 'The metadata.age should be updated to 31');\nawait incrementUserAge(testUser.id);\nconst incrementedUser = await User.findByPk(testUser.id);\nassert.strictEqual(incrementedUser.metadata.age, 32, 'The metadata.age should be incremented to 32');", "o1-mini": ""}
{"id": "10", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { MongoClient, Db } from 'mongodb';\nimport assert from 'assert';\n\n// Helper function to connect to the database\nasync function connectToDatabase(uri: string): Promise<Db> {\n    const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });\n    await client.connect();\n    return client.db();\n}\n\n// Helper function to insert a document into a collection\nasync function insertDocument(db: Db, collectionName: string, document: object): Promise<void> {\n    const collection = db.collection(collectionName);\n    await collection.insertOne(document);\n}\n\n// Helper function to find a document in a collection\nasync function findDocument(db: Db, collectionName: string, query: object): Promise<object | null> {\n    const collection = db.collection(collectionName);\n    return await collection.findOne(query);\n}\n\nconst uri = 'mongodb://localhost:27017';\nconst dbName = 'testdb';\nconst collectionName = 'testcollection';\n\nasync function run() {\n    const db = await connectToDatabase(uri);\n\n    // Insert a document\n    const document = { name: 'test', value: 42 };\n    await insertDocument(db, collectionName, document);\n\n    // Find the inserted document\n    const foundDocument = await findDocument(db, collectionName, { name: 'test' });\n    assert(foundDocument !== null, 'Document should be found');\n    assert(foundDocument.name === 'test', 'Document name should match');\n    assert(foundDocument.value === 42, 'Document value should match');\n\n    // Update the document\n    const updatedValue = 84;", "suffix": "    const updatedDocument = await findDocument(db, collectionName, { name: 'test' });\n    assert(updatedDocument !== null, 'Updated document should be found');\n    assert(updatedDocument.value === 84, 'Updated document value should match');\n\n    // Clean up: delete the document\n    await db.collection(collectionName).deleteOne({ name: 'test' });\n}\n\nrun().catch(console.error);", "golden_completion": "    await db.collection(collectionName).updateOne({ name: 'test' }, { $set: { value: updatedValue } });", "LLM_justification": "This test case demonstrates the usage of the MongoDB Node.js driver, specifically focusing on the deprecated `useNewUrlParser` and `useUnifiedTopology` options in the `MongoClient` constructor. The completion involves using the `updateOne` method with a MongoDB update operator, which is a less common operation compared to find and insert operations. The scenario tests the model's ability to recognize and correctly complete the pattern of MongoDB CRUD operations, handle parameter ordering, and validate the API's behavior. The assertions verify that the document is correctly updated and the cleanup code ensures no leftover data in the database.", "assertions": "assert(updatedDocument !== null, 'Updated document should be found');\nassert(updatedDocument.value === 84, 'Updated document value should match');", "o1-mini": ""}
{"id": "11", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as AWS from 'aws-sdk';\nimport { assert } from 'assert';\n\n// Configuration for AWS SDK\nAWS.config.update({\n    accessKeyId: 'fakeAccessKeyId',\n    secretAccessKey: 'fakeSecretAccessKey',\n    region: 'us-west-2'\n});\n\n// Initialize S3 service\nconst s3 = new AWS.S3();\n\n// Function to upload a file to S3\nasync function uploadFileToS3(bucketName: string, key: string, body: Buffer) {\n    const params = {\n        Bucket: bucketName,\n        Key: key,\n        Body: body\n    };\n\n    try {\n        const data = await s3.upload(params).promise();\n        return data;\n    } catch (error) {\n        console.error('Error uploading file:', error);\n        throw error;\n    }\n}\n\n// Function to delete a file from S3\nasync function deleteFileFromS3(bucketName: string, key: string) {\n    const params = {\n        Bucket: bucketName,\n        Key: key\n    };\n\n    try {\n        const data = await s3.deleteObject(params).promise();\n        return data;\n    } catch (error) {\n        console.error('Error deleting file:', error);\n        throw error;\n    }\n}\n\n// Helper function to simulate file upload and deletion\nasync function simulateFileUploadAndDeletion() {\n    const bucketName = 'test-bucket';\n    const key = 'test-file.txt';\n    const body = Buffer.from('This is a test file');\n\n    // Upload the file\n    const uploadResponse = await uploadFileToS3(bucketName, key, body);\n    assert(uploadResponse.ETag, 'File upload failed');\n\n    // Verify the file exists\n    const headParams = {\n        Bucket: bucketName,\n        Key: key\n    };\n    const headResponse = await s3.headObject(headParams).promise();\n    assert(headResponse.ContentLength === body.length, 'File size mismatch');\n\n", "suffix": "    // Cleanup the uploaded file\n    await deleteFileFromS3(bucketName, key);\n    console.log('File upload and deletion simulation completed');\n}\n\n// Execute the simulation\nsimulateFileUploadAndDeletion().catch(error => console.error('Simulation failed:', error));", "golden_completion": "    // Use deprecated getObjectAcl API to check ACL\n    const aclParams = {\n        Bucket: bucketName,\n        Key: key\n    };\n    const aclResponse = await s3.getObjectAcl(aclParams).promise();\n    assert(aclResponse.Grants.length > 0, 'No ACL found for the uploaded file');\n", "LLM_justification": "This test case demonstrates the use of the AWS SDK for JavaScript, particularly focusing on the S3 service. It includes both common and deprecated API functions. The example sets up S3 operations such as uploading and deleting files and includes a check using the deprecated getObjectAcl API to verify the file's ACL. This tests the LLM's ability to understand and correctly use both current and deprecated APIs within the AWS SDK, ensuring proper parameter ordering and error handling.", "assertions": "assert(uploadResponse.ETag, 'File upload failed');\nassert(headResponse.ContentLength === body.length, 'File size mismatch');\nassert(aclResponse.Grants.length > 0, 'No ACL found for the uploaded file');", "o1-mini": ""}
{"id": "12", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Sequelize, Model, DataTypes } from 'sequelize';\nimport assert from 'assert';\n\n// Initialize Sequelize\nconst sequelize = new Sequelize('sqlite::memory:');\n\n// Define a User model\nclass User extends Model {}\nUser.init({\n  username: DataTypes.STRING,\n  birthday: DataTypes.DATE\n}, { sequelize, modelName: 'user' });\n\n// Define a Post model\nclass Post extends Model {}\nPost.init({\n  title: DataTypes.STRING,\n  content: DataTypes.TEXT,\n  userId: DataTypes.INTEGER\n}, { sequelize, modelName: 'post' });\n\n(async () => {\n  // Sync all defined models to the DB\n  await sequelize.sync();\n\n  // Create a new user\n  const jane = await User.create({\n    username: 'janedoe',\n    birthday: new Date(1980, 6, 20)\n  });\n\n  // Create a new post\n  const post = await Post.create({\n    title: 'Hello World',\n    content: 'This is my first post!',\n    userId: jane.id\n  });\n\n  // Find all posts by user\n  const posts = await Post.findAll({ where: { userId: jane.id } });\n", "suffix": "// Assertions\nassert.strictEqual(posts.length, 1);\nassert.strictEqual(posts[0].title, 'Hello World');\nassert.strictEqual(posts[0].content, 'This is my first post!');\nassert.strictEqual(posts[0].userId, jane.id);\n\n// Cleanup\nawait sequelize.close();\n})();", "golden_completion": "  // Update the post\n  await post.update({\n    title: 'Updated Title',\n    content: 'Updated content.'\n  });\n\n  // Refetch the updated post\n  const updatedPost = await Post.findByPk(post.id);\n\n  // Assertions for updated post\n  assert.strictEqual(updatedPost.title, 'Updated Title');\n  assert.strictEqual(updatedPost.content, 'Updated content.');", "LLM_justification": "This scenario demonstrates the use of Sequelize, an ORM for Node.js, focusing on less common operations such as updating a record and refetching it. The pattern includes model definitions, CRUD operations, and assertions to verify the correctness of the update operation. This tests the LLM's ability to recognize and complete ORM-related tasks, especially focusing on the update and retrieval of records which are less commonly demonstrated compared to simple create or read operations.", "assertions": "assert.strictEqual(updatedPost.title, 'Updated Title');\nassert.strictEqual(updatedPost.content, 'Updated content.');", "o1-mini": ""}
{"id": "13", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { initializeApp } from 'firebase/app';\nimport { getAuth, signInWithEmailAndPassword, onAuthStateChanged } from 'firebase/auth';\n\nconst firebaseConfig = {\n  apiKey: 'AIzaSyA...YOUR_API_KEY...',\n  authDomain: 'YOUR_AUTH_DOMAIN',\n  projectId: 'YOUR_PROJECT_ID',\n  storageBucket: 'YOUR_STORAGE_BUCKET',\n  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',\n  appId: 'YOUR_APP_ID'\n};\n\n// Initialize Firebase\nconst app = initializeApp(firebaseConfig);\n\n// Initialize Firebase Authentication and get a reference to the service\nconst auth = getAuth(app);\n\n// Function to handle user login\nasync function loginUser(email: string, password: string): Promise<void> {\n  try {\n    const userCredential = await signInWithEmailAndPassword(auth, email, password);\n    console.log('User signed in:', userCredential.user);\n  } catch (error) {\n    console.error('Error signing in:', error);\n  }\n}\n\n// Listen for authentication state changes\nfunction observeAuthState(): void {\n  onAuthStateChanged(auth, (user) => {\n    if (user) {\n      console.log('User is signed in:', user);\n    } else {\n      console.log('No user is signed in.');\n    }\n  });\n}\n\n// This section sets up a deprecated way to sign out a user\nfunction deprecatedSignOut(): void {\n  const user = auth.currentUser;\n  if (user) {\n    user.delete().then(() => {\n      console.log('User signed out.');\n    }).catch((error) => {\n      console.error('Error signing out user:', error);\n    });\n  }\n}\n\nloginUser('testuser@example.com', 'testpassword');\nobserveAuthState();\n", "suffix": "deprecatedSignOut();\n\n// Clean up resources\nfunction cleanUp(): void {\n  auth.signOut().catch((error) => {\n    console.error('Error during cleanup:', error);\n  });\n}\n\ncleanUp();", "golden_completion": "auth.signOut().then(() => {\n  console.log('User signed out using the recommended method.');\n}).catch((error) => {\n  console.error('Error signing out user:', error);\n});", "LLM_justification": "This test case involves using the Firebase Authentication API in TypeScript, which includes a deprecated method for signing out a user. The completion task is to replace this deprecated method with the recommended method, verifying that the API usage is correct and consistent. This ensures that the model understands both the old and new patterns, handles proper exception management, and follows best practices.", "assertions": "import { expect } from 'chai';\n\n// Mocking Firebase auth\nconst mockAuth = {\n  signOut: async () => 'Mock signOut invoked'\n};\n\nasync function testSignOut() {\n  try {\n    const result = await mockAuth.signOut();\n    expect(result).to.equal('Mock signOut invoked');\n    console.log('Test passed: signOut method works correctly.');\n  } catch (error) {\n    console.error('Test failed:', error);\n  }\n}\n\ntestSignOut();", "o1-mini": ""}
{"id": "14", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { DynamoDBClient, PutItemCommand, DeleteItemCommand, GetItemCommand } from \"@aws-sdk/client-dynamodb\";\nimport assert from \"assert\";\n\nconst client = new DynamoDBClient({ region: \"us-west-2\" });\n\nconst TABLE_NAME = \"TestTable\";\n\nasync function putItem(client: DynamoDBClient, item: { [key: string]: { S: string } }) {\n    const params = {\n        TableName: TABLE_NAME,\n        Item: item\n    };\n    const command = new PutItemCommand(params);\n    try {\n        const result = await client.send(command);\n        return result;\n    } catch (error) {\n        console.error(\"Error putting item:\", error);\n        throw error;\n    }\n}\n\nasync function deleteItem(client: DynamoDBClient, key: { [key: string]: { S: string } }) {\n    const params = {\n        TableName: TABLE_NAME,\n        Key: key\n    };\n    const command = new DeleteItemCommand(params);\n    try {\n        const result = await client.send(command);\n        return result;\n    } catch (error) {\n        console.error(\"Error deleting item:\", error);\n        throw error;\n    }\n}\n\nasync function getItem(client: DynamoDBClient, key: { [key: string]: { S: string } }) {\n    const params = {\n        TableName: TABLE_NAME,\n        Key: key\n    };\n    const command = new GetItemCommand(params);\n    try {\n        const result = await client.send(command);\n        return result.Item;\n    } catch (error) {\n        console.error(\"Error getting item:\", error);\n        throw error;\n    }\n}\n\n(async () => {\n    const item = { \"PrimaryKey\": { S: \"123\" }, \"Attribute\": { S: \"Value\" } };\n    const key = { \"PrimaryKey\": { S: \"123\" } };\n\n    // Put item\n    await putItem(client, item);\n\n    // Get item\n    const retrievedItem = await getItem(client, key);\n    assert.deepStrictEqual(retrievedItem, item);\n", "suffix": "    // Delete item\n    await deleteItem(client, key);\n\n    // Verify item deletion\n    const deletedItem = await getItem(client, key);\n    assert.strictEqual(deletedItem, undefined);\n})();", "golden_completion": "    // Confirm item exists\n    const existingItem = await getItem(client, key);\n    assert.deepStrictEqual(existingItem, item);\n", "LLM_justification": "This test case is designed to evaluate the LLM's understanding and capability to handle AWS SDK v3 for DynamoDB, focusing on the correct usage of PutItemCommand, GetItemCommand, and DeleteItemCommand. The example uses rare but valid patterns, such as checking item existence before deletion, which is not commonly demonstrated. The correct parameter ordering and handling of responses and errors are critical for this scenario. Moreover, this test case ensures that the model can follow the established pattern of DynamoDB operations and handle API versioning properly.", "assertions": "assert.deepStrictEqual(retrievedItem, item);\nconst existingItem = await getItem(client, key);\nassert.deepStrictEqual(existingItem, item);\nawait deleteItem(client, key);\nconst deletedItem = await getItem(client, key);\nassert.strictEqual(deletedItem, undefined);", "o1-mini": ""}
{"id": "15", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\nimport { Readable } from 'stream';\n\nconst bucketName = 'test-bucket';\nconst objectKey = 'test-object.txt';\nconst objectContent = 'Hello, this is a test object!';\n\n// Initialize the S3 client\nconst s3Client = new S3Client({ region: 'us-west-2' });\n\n// Function to upload an object to S3\nasync function uploadObject() {\n    try {\n        const putObjectParams = {\n            Bucket: bucketName,\n            Key: objectKey,\n            Body: objectContent,\n        };\n        const command = new PutObjectCommand(putObjectParams);\n        const response = await s3Client.send(command);\n        console.log('Object uploaded successfully:', response);\n    } catch (error) {\n        console.error('Error uploading object:', error);\n    }\n}\n\n// Function to download an object from S3\nasync function downloadObject() {\n    try {\n        const getObjectParams = {\n            Bucket: bucketName,\n            Key: objectKey,\n        };\n        const command = new GetObjectCommand(getObjectParams);\n        const response = await s3Client.send(command);\n        const objectData = await streamToString(response.Body);\n        console.log('Object downloaded successfully:', objectData);\n        return objectData;\n    } catch (error) {\n        console.error('Error downloading object:', error);\n    }\n}\n\n// Helper function to convert a Readable stream to a string\nfunction streamToString(stream: Readable): Promise<string> {\n    return new Promise((resolve, reject) => {\n        const chunks: any[] = [];\n        stream.on('data', (chunk) => chunks.push(chunk));\n        stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf-8')));\n        stream.on('error', reject);\n    });\n}\n\n// Upload the object to S3\nawait uploadObject();\n", "suffix": "\n// Clean up by deleting the object from S3\nasync function deleteObject() {\n    try {\n        const deleteObjectParams = {\n            Bucket: bucketName,\n            Key: objectKey,\n        };\n        const command = new DeleteObjectCommand(deleteObjectParams);\n        const response = await s3Client.send(command);\n        console.log('Object deleted successfully:', response);\n    } catch (error) {\n        console.error('Error deleting object:', error);\n    }\n}\n\n// Run the cleanup function\nawait deleteObject();\n", "golden_completion": "const downloadedContent = await downloadObject();\nif (downloadedContent === objectContent) {\n    console.log('Downloaded content matches uploaded content');\n} else {\n    console.error('Downloaded content does not match uploaded content');\n}", "LLM_justification": "This test case is designed to validate the model's ability to recognize and continue an established pattern involving AWS SDK for JavaScript v3. The specific focus is on the S3 Client's uncommon methods and proper handling of streaming data. The code demonstrates realistic usage of uploading, downloading, and verifying object content in S3, which requires understanding of both AWS SDK patterns and handling Readable streams.", "assertions": "const downloadedContent = await downloadObject();\nconsole.assert(downloadedContent === objectContent, 'The downloaded content does not match the uploaded content');", "o1-mini": ""}
{"id": "16", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as AWS from 'aws-sdk';\nimport { S3 } from 'aws-sdk';\nimport { assert } from 'assert';\n\n// AWS S3 configuration\nconst s3 = new S3({\n    accessKeyId: 'your-access-key-id',\n    secretAccessKey: 'your-secret-access-key',\n    region: 'us-east-1'\n});\n\n// Function to upload a file to S3\nasync function uploadFileToS3(bucketName: string, key: string, body: Buffer) {\n    const params = {\n        Bucket: bucketName,\n        Key: key,\n        Body: body\n    };\n\n    try {\n        const data = await s3.upload(params).promise();\n        return data;\n    } catch (error) {\n        console.error('Error uploading file:', error);\n        throw error;\n    }\n}\n\n// Function to list objects in an S3 bucket\nasync function listObjectsInS3Bucket(bucketName: string) {\n    const params = {\n        Bucket: bucketName\n    };\n\n    try {\n        const data = await s3.listObjectsV2(params).promise();\n        return data.Contents || [];\n    } catch (error) {\n        console.error('Error listing objects:', error);\n        throw error;\n    }\n}\n\n// Example usage\nasync function example() {\n    const bucketName = 'example-bucket';\n    const key = 'example-file.txt';\n    const body = Buffer.from('Hello, S3!');\n\n    // Upload a file\n    const uploadResult = await uploadFileToS3(bucketName, key, body);\n    console.log('Upload result:', uploadResult);\n\n    // List objects\n    const objects = await listObjectsInS3Bucket(bucketName);\n    console.log('Objects in bucket:', objects);\n\n    // Delete the uploaded file\n", "suffix": "    const deleteParams = {\n        Bucket: bucketName,\n        Key: key\n    };\n\n    try {\n        const deleteResult = await s3.deleteObject(deleteParams).promise();\n        console.log('Delete result:', deleteResult);\n    } catch (error) {\n        console.error('Error deleting object:', error);\n        throw error;\n    }\n}\n\nexample().catch(console.error);", "golden_completion": "    const deleteResult = await s3.deleteObject(deleteParams).promise();\n    assert(deleteResult.DeleteMarker === true, 'File should be marked as deleted');\n", "LLM_justification": "This test case demonstrates the usage of the AWS SDK for S3 operations, including uploading, listing, and deleting objects. The completion involves using the `deleteObject` method and includes an assertion to check that the file is marked as deleted. This scenario tests the LLM's ability to recognize and correctly use rare AWS SDK methods, handle API responses, and verify behavior through assertions. It also ensures proper handling of API parameters and error conditions.", "assertions": "assert(deleteResult.DeleteMarker === true, 'File should be marked as deleted');", "o1-mini": ""}
{"id": "17", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as AWS from 'aws-sdk';\nimport { S3 } from 'aws-sdk';\nimport { assert } from 'chai';\n\n// Initialize the S3 client\nconst s3 = new AWS.S3({\n  apiVersion: '2006-03-01',\n  region: 'us-west-2'\n});\n\n// Helper function to create a bucket\nasync function createBucket(bucketName: string): Promise<void> {\n  const params = {\n    Bucket: bucketName\n  };\n  await s3.createBucket(params).promise();\n  console.log(`Bucket ${bucketName} created successfully.`);\n}\n\n// Helper function to upload a file to S3\nasync function uploadFile(bucketName: string, key: string, body: string): Promise<void> {\n  const params = {\n    Bucket: bucketName,\n    Key: key,\n    Body: body\n  };\n  await s3.putObject(params).promise();\n  console.log(`File ${key} uploaded to bucket ${bucketName}.`);\n}\n\n// Helper function to list files in a bucket\nasync function listFiles(bucketName: string): Promise<string[]> {\n  const params = {\n    Bucket: bucketName\n  };\n  const data = await s3.listObjectsV2(params).promise();\n  return data.Contents ? data.Contents.map(item => item.Key!) : [];\n}\n\n// Helper function to delete a bucket\nasync function deleteBucket(bucketName: string): Promise<void> {\n  const params = {\n    Bucket: bucketName\n  };\n  await s3.deleteBucket(params).promise();\n  console.log(`Bucket ${bucketName} deleted successfully.`);\n}\n\n// Main function to demonstrate S3 operations\nasync function main() {\n  const bucketName = 'test-bucket-12345';\n  const fileName = 'test-file.txt';\n  const fileContent = 'Hello, AWS S3!';\n\n  // Create a new bucket\n  await createBucket(bucketName);\n\n  // Upload a file to the bucket\n  await uploadFile(bucketName, fileName, fileContent);\n\n  // List files in the bucket\n  const files = await listFiles(bucketName);\n  console.log('Files in bucket:', files);\n\n  // Validate file upload\n  assert.include(files, fileName, 'File should be uploaded to the bucket');\n\n  // Download the file from the bucket\n", "suffix": "\n  // List files in the bucket again to ensure file deletion\n  const filesAfterDeletion = await listFiles(bucketName);\n  console.log('Files in bucket after deletion:', filesAfterDeletion);\n  assert.notInclude(filesAfterDeletion, fileName, 'File should be deleted from the bucket');\n\n  // Clean up by deleting the bucket\n  await deleteBucket(bucketName);\n}\n\nmain().catch(err => console.error('Error in S3 operations:', err));", "golden_completion": "  const downloadedFile = await s3.getObject({ Bucket: bucketName, Key: fileName }).promise();\n  const downloadedContent = downloadedFile.Body?.toString();\n  assert.equal(downloadedContent, fileContent, 'Downloaded file content should match the uploaded content');\n\n  // Delete the file from the bucket\n  await s3.deleteObject({ Bucket: bucketName, Key: fileName }).promise();\n  console.log(`File ${fileName} deleted from bucket ${bucketName}.`);", "LLM_justification": "This test case demonstrates the usage of AWS S3 SDK for operations like creating a bucket, uploading a file, listing files, downloading a file, and deleting a file. It includes rare API calls such as getting an object from S3 and validating its content. The example focuses on ensuring the correct parameter ordering and handling of AWS S3 responses, which are crucial for cloud service interactions. The assertions verify the correctness of file upload, download, and deletion operations.", "assertions": "assert.equal(downloadedContent, fileContent, 'Downloaded file content should match the uploaded content');\nassert.include(files, fileName, 'File should be uploaded to the bucket');\nassert.notInclude(filesAfterDeletion, fileName, 'File should be deleted from the bucket');", "o1-mini": ""}
{"id": "18", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Sequelize, Model, DataTypes } from 'sequelize';\nimport { expect } from 'chai';\n\n// Database configuration\nconst sequelize = new Sequelize('sqlite::memory:');\n\n// Model definition\nclass User extends Model {\n  public id!: number;\n  public name!: string;\n  public age!: number;\n}\n\nUser.init({\n  id: {\n    type: DataTypes.INTEGER,\n    autoIncrement: true,\n    primaryKey: true,\n  },\n  name: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n  age: {\n    type: DataTypes.INTEGER,\n    allowNull: false,\n  }\n}, {\n  sequelize,\n  modelName: 'User'\n});\n\n(async () => {\n  await sequelize.sync({ force: true });\n\n  // Helper function to create users\n  const createUser = async (name: string, age: number) => {\n    return await User.create({ name, age });\n  };\n\n  // Populate the database with sample data\n  await createUser('Alice', 30);\n  await createUser('Bob', 25);\n  await createUser('Charlie', 35);\n\n  // Fetch all users from the database\n  const users = await User.findAll();\n\n  console.log('All users:', JSON.stringify(users, null, 2));\n\n  // Define a function to get users by age range\n  const getUsersByAgeRange = async (minAge: number, maxAge: number): Promise<User[]> => {", "suffix": "  };\n\n  // Fetch users with age between 26 and 34\n  const usersInRange = await getUsersByAgeRange(26, 34);\n\n  console.log('Users in range:', JSON.stringify(usersInRange, null, 2));\n\n  // Assertions\n  expect(usersInRange).to.have.lengthOf(2);\n  expect(usersInRange[0].name).to.equal('Alice');\n  expect(usersInRange[1].name).to.equal('Bob');\n\n  // Clean up resources\n  await sequelize.close();\n})();", "golden_completion": "    return await User.findAll({\n      where: {\n        age: {\n          [Sequelize.Op.between]: [minAge, maxAge]\n        }\n      }\n    });", "LLM_justification": "This test case is designed to evaluate the model's understanding of Sequelize's query capabilities, specifically the use of the `Op.between` operator for filtering records within a range. The `Op.between` operator is less commonly used than basic find operations and requires understanding of Sequelize's syntax and query API. This scenario also includes comprehensive setup and teardown steps to ensure a clean test environment.", "assertions": "expect(usersInRange).to.have.lengthOf(2);\nexpect(usersInRange[0].name).to.equal('Alice');\nexpect(usersInRange[1].name).to.equal('Bob');", "o1-mini": ""}
{"id": "19", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { S3 } from 'aws-sdk';\nimport { mock, MockProxy } from 'jest-mock-extended';\n\n// S3 client mock\nconst s3Client: MockProxy<S3> = mock<S3>();\n\ninterface FileUploadResult {\n  bucket: string;\n  key: string;\n  location: string;\n}\n\n// Function to upload file to S3\nasync function uploadFileToS3(bucket: string, key: string, body: Buffer): Promise<FileUploadResult> {\n  const params = {\n    Bucket: bucket,\n    Key: key,\n    Body: body,\n    ACL: 'public-read',\n  };\n\n  return new Promise((resolve, reject) => {\n    s3Client.upload(params, (err, data) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve({\n        bucket: data.Bucket,\n        key: data.Key,\n        location: data.Location,\n      });\n    });\n  });\n}\n\n// Test setup\nconst testBucket = 'test-bucket';\nconst testKey = 'test-key';\nconst testBody = Buffer.from('test content');\nconst mockUploadResponse = {\n  Bucket: testBucket,\n  Key: testKey,\n  Location: 'http://test-bucket.s3.amazonaws.com/test-key',\n};\n\n// Mock S3 upload method\ns3Client.upload.mockImplementation((params, callback) => {\n  callback(null, mockUploadResponse);\n});\n\n// Test function\nasync function testUploadFunction() {\n  try {\n    const result = await uploadFileToS3(testBucket, testKey, testBody);\n", "suffix": "    console.log('File uploaded successfully:', result);\n  } catch (error) {\n    console.error('Error uploading file:', error);\n  }\n}\n\ntestUploadFunction();\n\n// Assertions\nimport * as assert from 'assert';\nassert.strictEqual(mockUploadResponse.Bucket, testBucket);\nassert.strictEqual(mockUploadResponse.Key, testKey);\nassert.strictEqual(mockUploadResponse.Location, 'http://test-bucket.s3.amazonaws.com/test-key');\n\n// Cleanup\ns3Client.upload.mockReset();\n", "golden_completion": "    assert.deepStrictEqual(result, {\n      bucket: testBucket,\n      key: testKey,\n      location: 'http://test-bucket.s3.amazonaws.com/test-key',\n    });\n", "LLM_justification": "This test case demonstrates the usage of the AWS SDK's S3 upload method, which is a less common API usage scenario. It tests the ability of the LLM to correctly mock the S3 upload method, handle the callback pattern, and verify the result. The scenario includes setting up a mock for the S3 client, defining the function to be tested, and verifying the expected behavior using assertions. This example is beneficial for testing the LLM's understanding of asynchronous code, AWS SDK patterns, and handling of mock implementations.", "assertions": "assert.deepStrictEqual(result, {\n  bucket: testBucket,\n  key: testKey,\n  location: 'http://test-bucket.s3.amazonaws.com/test-key',\n});", "o1-mini": ""}
{"id": "20", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Sequelize, DataTypes, Model } from \"sequelize\";\n\n// Setting up the Sequelize connection and defining a model\nconst sequelize = new Sequelize('sqlite::memory:');\n\nclass User extends Model {\n    public id!: number;\n    public name!: string;\n    public email!: string;\n}\n\nUser.init({\n    id: {\n        type: DataTypes.INTEGER,\n        autoIncrement: true,\n        primaryKey: true\n    },\n    name: {\n        type: DataTypes.STRING,\n        allowNull: false\n    },\n    email: {\n        type: DataTypes.STRING,\n        allowNull: false,\n        unique: true\n    }\n}, {\n    sequelize,\n    modelName: 'User'\n});\n\nasync function setupDatabase() {\n    await sequelize.sync({ force: true });\n    await User.bulkCreate([\n        { name: 'John Doe', email: 'john@example.com' },\n        { name: 'Jane Doe', email: 'jane@example.com' }\n    ]);\n}\n\nsetupDatabase().then(async () => {\n    // Context: We want to implement a deprecated but still supported feature\n    // Using the 'findOrCreate' method which is not commonly used\n", "suffix": "\n    // Fetch all users to verify the insertion\n    const users = await User.findAll();\n    console.log(users.map(user => user.toJSON()));\n\n    // Cleaning up resources\n    await sequelize.close();\n}).catch(err => console.error(err));\n", "golden_completion": "    const [user, created] = await User.findOrCreate({\n        where: { email: 'john@example.com' },\n        defaults: { name: 'John Doe' }\n    });\n    console.log(`User created: ${created}`);\n", "LLM_justification": "This example tests the model's ability to handle a deprecated but still supported feature in Sequelize, the 'findOrCreate' method. This method is not commonly used and understanding its correct implementation is crucial for maintaining legacy codebases. The code verifies the creation of a user if it does not already exist, which is an uncommon but valid usage pattern. The test ensures that the model correctly interprets and uses the 'findOrCreate' method while maintaining proper parameter ordering and handling asynchronous operations.", "assertions": "const assert = require('assert');\nsetupDatabase().then(async () => {\n    const [user, created] = await User.findOrCreate({\n        where: { email: 'john@example.com' },\n        defaults: { name: 'John Doe' }\n    });\n    assert.strictEqual(created, false, 'User should not be created as it already exists');\n    assert.strictEqual(user.name, 'John Doe', 'User name should be John Doe');\n    assert.strictEqual(user.email, 'john@example.com', 'User email should be john@example.com');\n    const users = await User.findAll();\n    assert.strictEqual(users.length, 2, 'There should be exactly 2 users in the database');\n    await sequelize.close();\n}).catch(err => console.error(err));\n", "o1-mini": ""}
{"id": "21", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as AWS from 'aws-sdk';\nimport { assert } from 'assert';\n\n// AWS SDK configuration\nAWS.config.update({\n    region: 'us-west-2'\n});\n\n// S3 client initialization\nconst s3 = new AWS.S3();\n\n// Function to upload a file to S3\nasync function uploadFile(bucketName: string, key: string, body: Buffer): Promise<AWS.S3.ManagedUpload.SendData> {\n    const params: AWS.S3.PutObjectRequest = {\n        Bucket: bucketName,\n        Key: key,\n        Body: body\n    };\n    return new Promise((resolve, reject) => {\n        s3.upload(params, (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Function to list objects in an S3 bucket\nasync function listObjects(bucketName: string): Promise<AWS.S3.ListObjectsV2Output> {\n    const params: AWS.S3.ListObjectsV2Request = {\n        Bucket: bucketName\n    };\n    return new Promise((resolve, reject) => {\n        s3.listObjectsV2(params, (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Function to get a signed URL for an object\nasync function getSignedUrl(bucketName: string, key: string): Promise<string> {\n    const params: AWS.S3.GetObjectRequest = {\n        Bucket: bucketName,\n        Key: key\n    };\n    return new Promise((resolve, reject) => {\n        s3.getSignedUrl('getObject', params, (err, url) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(url);\n            }\n        });\n    });\n}\n\n// Example usage\n(async () => {\n    const bucketName = 'test-bucket';\n    const key = 'test-file.txt';\n    const body = Buffer.from('Hello, world!');\n\n    try {\n        // Upload the file\n        const uploadData = await uploadFile(bucketName, key, body);\n        console.log('File uploaded:', uploadData);\n\n        // List objects in the bucket\n        const listData = await listObjects(bucketName);\n        console.log('Objects in bucket:', listData);\n\n        // Get a signed URL for the uploaded file\n        const signedUrl = await getSignedUrl(bucketName, key);\n        console.log('Signed URL:', signedUrl);\n\n", "suffix": "        // Delete the uploaded file\n        const deleteParams: AWS.S3.DeleteObjectRequest = {\n            Bucket: bucketName,\n            Key: key\n        };\n        await s3.deleteObject(deleteParams).promise();\n        console.log('File deleted');\n    } catch (error) {\n        console.error('Error:', error);\n    }\n})();\n", "golden_completion": "        // Copy the uploaded file to a new key\n        const copyParams: AWS.S3.CopyObjectRequest = {\n            Bucket: bucketName,\n            CopySource: `/${bucketName}/${key}`,\n            Key: `${key}.copy`\n        };\n        const copyData = await s3.copyObject(copyParams).promise();\n        console.log('File copied:', copyData);\n", "LLM_justification": "This is a good test case because it demonstrates the use of a less common AWS SDK function, 'copyObject', which is used to copy objects within an S3 bucket. The golden completion involves correctly setting up the parameters and using the promise-based API for the 'copyObject' function, which is less frequently used compared to other S3 operations like 'putObject' or 'getObject'. The correct completion should handle the parameters and API conventions properly, following the same pattern established in the prefix code.", "assertions": "assert.ok(copyData.CopyObjectResult, 'CopyObjectResult should be present');\nassert.strictEqual(copyData.CopyObjectResult.ETag.length > 0, true, 'ETag should be a non-empty string');", "o1-mini": ""}
{"id": "22", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as aws from 'aws-sdk';\nimport { strict as assert } from 'assert';\n\n// AWS SDK Configuration\nconst s3 = new aws.S3({\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    region: 'us-east-1'\n});\n\n// Helper function to upload a file to S3\nasync function uploadFileToS3(bucketName: string, fileName: string, fileContent: Buffer): Promise<aws.S3.ManagedUpload.SendData> {\n    const params = {\n        Bucket: bucketName,\n        Key: fileName,\n        Body: fileContent\n    };\n\n    return s3.upload(params).promise();\n}\n\n// Helper function to download a file from S3\nasync function downloadFileFromS3(bucketName: string, fileName: string): Promise<Buffer> {\n    const params = {\n        Bucket: bucketName,\n        Key: fileName\n    };\n\n    const data = await s3.getObject(params).promise();\n    return data.Body as Buffer;\n}\n\n// Example usage of the upload and download functions\n(async () => {\n    const bucketName = 'my-test-bucket';\n    const fileName = 'test-file.txt';\n    const fileContent = Buffer.from('Hello, world!');\n\n    try {\n        // Upload the file\n        const uploadResult = await uploadFileToS3(bucketName, fileName, fileContent);\n        console.log('File uploaded successfully:', uploadResult);\n        assert.equal(uploadResult.Bucket, bucketName);\n        assert.equal(uploadResult.Key, fileName);\n\n", "suffix": "\n        // Download the file\n        const downloadedContent = await downloadFileFromS3(bucketName, fileName);\n        console.log('File downloaded successfully:', downloadedContent.toString());\n        assert.equal(downloadedContent.toString(), fileContent.toString());\n    } catch (error) {\n        console.error('Error during S3 operations:', error);\n    } finally {\n        // Cleanup: Delete the uploaded file\n        const deleteParams = {\n            Bucket: bucketName,\n            Key: fileName\n        };\n        await s3.deleteObject(deleteParams).promise();\n        console.log('File deleted successfully');\n    }\n})();\n", "golden_completion": "        // Check if the file exists\n        const headParams = {\n            Bucket: bucketName,\n            Key: fileName\n        };\n        const headResult = await s3.headObject(headParams).promise();\n        console.log('File exists:', headResult);\n        assert.equal(headResult.ContentLength, fileContent.length);\n\n", "LLM_justification": "This test case is a good scenario for verifying the LLM's ability to handle AWS SDK operations, specifically the use of the S3 service for file uploads, downloads, and metadata checks. The golden completion involves an uncommon but valid API usage pattern (headObject) to check if a file exists and retrieve its metadata, which is less frequently used compared to upload and download operations. This ensures the model can recognize and complete patterns involving various AWS SDK methods, correctly handle parameter ordering, and understand the context of S3 operations.", "assertions": "assert.equal(headResult.ContentLength, fileContent.length);", "o1-mini": ""}
{"id": "23", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as AWS from 'aws-sdk';\nimport { assert } from 'console';\n\nAWS.config.update({\n  accessKeyId: 'your-access-key-id',\n  secretAccessKey: 'your-secret-access-key',\n  region: 'us-west-2'\n});\n\nconst s3 = new AWS.S3();\n\n// Function to list objects in an S3 bucket\nasync function listObjects(bucketName: string) {\n  return new Promise((resolve, reject) => {\n    s3.listObjects({ Bucket: bucketName }, (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\n// Function to upload an object to S3\nasync function uploadObject(bucketName: string, key: string, body: string) {\n  return new Promise((resolve, reject) => {\n    s3.putObject({ Bucket: bucketName, Key: key, Body: body }, (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\n// Function to delete an object from S3\nasync function deleteObject(bucketName: string, key: string) {\n  return new Promise((resolve, reject) => {\n    s3.deleteObject({ Bucket: bucketName, Key: key }, (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nconst bucketName = 'example-bucket';\nconst objectKey = 'example-object';\nconst objectBody = 'This is a test object.';\n\nasync function testS3Operations() {\n  try {\n    // Upload object\n    await uploadObject(bucketName, objectKey, objectBody);\n\n    // List objects\n    const listResponse = await listObjects(bucketName);\n    assert(listResponse.Contents.some((item: any) => item.Key === objectKey));\n", "suffix": "    // Delete object\n    await deleteObject(bucketName, objectKey);\n\n    // Verify deletion\n    const finalListResponse = await listObjects(bucketName);\n    assert(!finalListResponse.Contents.some((item: any) => item.Key === objectKey));\n  } catch (error) {\n    console.error('An error occurred:', error);\n  }\n}\n\ntestS3Operations();", "golden_completion": "    // Verify object upload\n    const uploadResponse = await s3.headObject({ Bucket: bucketName, Key: objectKey }).promise();\n    assert(uploadResponse.ContentLength === objectBody.length);\n", "LLM_justification": "This test case demonstrates the use of the AWS SDK for JavaScript (v2) in a Node.js environment to interact with S3. It includes operations to list, upload, and delete objects in an S3 bucket. The golden completion focuses on verifying the upload of an object using the `headObject` method, which is less commonly used compared to the basic `putObject` and `getObject` methods. This API pattern is important for validating the existence and properties of an object after upload. The assertions ensure that the object was uploaded successfully and has the expected content length. The test case also handles errors appropriately and cleans up resources by deleting the object after verification.", "assertions": "assert(uploadResponse.ContentLength === objectBody.length);", "o1-mini": ""}
{"id": "24", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { WebSocketLink } from '@apollo/client/link/ws';\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\n\n// Setup WebSocket link for Apollo Client\nconst wsLink = new WebSocketLink(\n  new SubscriptionClient('ws://localhost:4000/graphql', {\n    reconnect: true\n  })\n);\n\n// Initialize Apollo Client with WebSocket link\nconst client = new ApolloClient({\n  link: wsLink,\n  cache: new InMemoryCache()\n});\n\n// Define subscription query for listening to new messages\nconst NEW_MESSAGES_SUBSCRIPTION = gql`\n  subscription OnNewMessage {\n    newMessage {\n      id\n      content\n      createdAt\n      author {\n        id\n        name\n      }\n    }\n  }\n`;\n\n// Helper function to format message\nfunction formatMessage(message: any): string {\n  return `${message.author.name}: ${message.content} (at ${message.createdAt})`;\n}\n\n// Log new messages received from subscription\nconst handleNewMessage = (data: any) => {\n  if (data.newMessage) {\n    console.log('New message received:', formatMessage(data.newMessage));\n  }\n};\n\n// Subscribe to new messages\nclient.subscribe({\n  query: NEW_MESSAGES_SUBSCRIPTION\n}).subscribe({\n  next: handleNewMessage,\n  error: (err) => console.error('Subscription error:', err)\n});\n\n// Mocking the Apollo Client subscription for testing\nconst mockData = {\n  newMessage: {\n    id: '1',\n    content: 'Hello World!',\n    createdAt: new Date().toISOString(),\n    author: {\n      id: '1',\n      name: 'John Doe'\n    }\n  }\n};\n\n// Simulate receiving a new message\nhandleNewMessage(mockData);\n\n", "suffix": "\n// Cleanup resources\nclient.stop();\nwsLink.subscriptionClient.close();\n", "golden_completion": "setTimeout(() => handleNewMessage(mockData), 1000);\n", "LLM_justification": "This test case focuses on using the Apollo Client with WebSocket subscriptions, an uncommon but valid usage pattern. By including the deprecated 'subscriptions-transport-ws' library, it tests the model's ability to recognize and correctly implement a subscription with Apollo Client. The test also verifies proper usage of parameters and handling of real-time data through subscriptions, making it a robust example for evaluating LLM capabilities.", "assertions": "import { strict as assert } from 'assert';\n\n// Verify that the mock data was handled correctly\nconst testData = {\n  newMessage: {\n    id: '1',\n    content: 'Hello World!',\n    createdAt: new Date().toISOString(),\n    author: {\n      id: '1',\n      name: 'John Doe'\n    }\n  }\n};\n\n// Capture console output\nlet consoleOutput: string[] = [];\nconst originalLog = console.log;\nconsole.log = (message: string) => consoleOutput.push(message);\n\n// Simulate receiving new message\nhandleNewMessage(testData);\n\n// Check the output\nassert(consoleOutput.length > 0, 'Expected console output for new message');\nassert(consoleOutput[0].includes('John Doe: Hello World!'), 'Expected correct message format in console output');\n\n// Restore original console.log\nconsole.log = originalLog;\n", "o1-mini": ""}
{"id": "25", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import express from 'express';\nimport { ApolloServer, gql } from 'apollo-server-express';\nimport { ApolloClient, InMemoryCache, HttpLink } from '@apollo/client';\nimport fetch from 'node-fetch';\nimport { assert } from 'chai';\n\nconst typeDefs = gql`\n  type Query {\n    hello: String\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    hello: () => 'Hello world!',\n  },\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers });\nconst app = express();\nserver.applyMiddleware({ app });\n\nconst PORT = 4000;\nlet httpServer;\n\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}${server.graphqlPath}`);\n});\n\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: `http://localhost:${PORT}${server.graphqlPath}`, fetch }),\n  cache: new InMemoryCache(),\n});\n\nconst GET_HELLO = gql`\n  query GetHello {\n    hello\n  }\n`;\n\nasync function fetchHello() {\n  return client.query({ query: GET_HELLO });\n}\n", "suffix": "", "golden_completion": "\nfetchHello().then(result => {\n  console.log('Result from GraphQL query:', result.data);\n  assert.strictEqual(result.data.hello, 'Hello world!');\n  // Clean up\n  httpServer.close();\n}).catch(error => {\n  console.error('Error fetching data:', error);\n  httpServer.close();\n});\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a setup for a GraphQL server using Apollo Server and Apollo Client. The pattern involves setting up a GraphQL server, defining a schema and resolver, and querying the server from the client. The completion demonstrates understanding of initiating a query, handling the result, and performing necessary cleanup. The assertions ensure the API behaves as expected and the resource cleanup is properly handled.", "assertions": "assert.strictEqual(result.data.hello, 'Hello world!');", "o1-mini": ""}
{"id": "26", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as ws from 'ws';\n\n// WebSocket server setup\nconst wss = new ws.Server({ port: 8080 });\n\n// Store connected clients\nconst clients: ws.WebSocket[] = [];\n\n// Broadcast message to all clients\nconst broadcast = (message: string) => {\n  clients.forEach(client => {\n    if (client.readyState === ws.WebSocket.OPEN) {\n      client.send(message);\n    }\n  });\n};\n\n// Handle new connections\nwss.on('connection', (ws: ws.WebSocket) => {\n  clients.push(ws);\n  ws.on('message', (message: string) => {\n    console.log(`Received message: ${message}`);\n    // Broadcast the received message to all clients\n    broadcast(message);\n  });\n\n  ws.on('close', () => {\n    // Remove the client from the clients array\n    const index = clients.indexOf(ws);\n    if (index !== -1) {\n      clients.splice(index, 1);\n    }\n  });\n});\n\n// Client setup\nconst client = new ws.WebSocket('ws://localhost:8080');\n\nclient.on('open', () => {\n  console.log('Client connected to server');\n  // Send a message to the server\n  client.send('Hello Server');\n});\n\nclient.on('message', (message: string) => {\n  console.log(`Client received: ${message}`);\n});\n\n// Utility function to close all clients\nconst closeAllClients = () => {\n  clients.forEach(client => client.close());\n};\n", "suffix": "client.on('close', () => {\n  console.log('Client disconnected');\n  closeAllClients();\n  wss.close();\n});\n\n// Additional client to test multiple connections\nconst anotherClient = new ws.WebSocket('ws://localhost:8080');\n\nanotherClient.on('open', () => {\n  console.log('Another client connected to server');\n  // Send a message to the server\n  anotherClient.send('Hello Again Server');\n});\n\nanotherClient.on('message', (message: string) => {\n  console.log(`Another client received: ${message}`);\n  // Close the client after receiving a message\n  anotherClient.close();\n});\n\nanotherClient.on('close', () => {\n  console.log('Another client disconnected');\n});\n", "golden_completion": "client.on('error', (err: Error) => {\n  console.error(`Client encountered error: ${err.message}`);\n  client.close();\n});\n", "LLM_justification": "This test case demonstrates the use of the 'ws' library for WebSocket communication, focusing on handling client errors using the 'error' event. This is an uncommon but crucial aspect of WebSocket communication to ensure robustness and proper error handling. The pattern established in the prefix includes setting up a WebSocket server, handling connections, broadcasting messages, and managing client connections. The completion tests the model's ability to recognize and implement error handling for the WebSocket client, which is a less commonly showcased feature but essential for production-grade applications.", "assertions": "import { strict as assert } from 'assert';\n\nclient.on('error', (err: Error) => {\n  assert(err instanceof Error, 'Error event should provide an error object');\n  assert(typeof err.message === 'string', 'Error message should be a string');\n});\n\nclient.on('open', () => {\n  // Simulate an error condition\n  client.emit('error', new Error('Simulated error'));\n});\n\n// Ensure error handling works as expected\nsetTimeout(() => {\n  assert(client.readyState === ws.WebSocket.CLOSED, 'Client should close on error');\n  closeAllClients();\n  wss.close();\n}, 1000);", "o1-mini": ""}
{"id": "27", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Socket } from 'socket.io';\nimport { Server } from 'http';\n\n// A helper function to create and configure an HTTP server\nfunction createServer(): Server {\n  const server = new Server();\n  server.listen(3000);\n  return server;\n}\n\n// A function to initialize and configure a Socket.io server\nfunction initializeSocket(server: Server): Socket {\n  const io = new Socket(server);\n  io.on('connection', (socket) => {\n    console.log('A user connected');\n    socket.on('disconnect', () => {\n      console.log('A user disconnected');\n    });\n  });\n  return io;\n}\n\n// Creating and configuring the HTTP server\nconst server = createServer();\n\n// Initializing the Socket.io server\nconst io = initializeSocket(server);\n\n// A function to broadcast a message to all connected clients\nfunction broadcastMessage(io: Socket, message: string): void {\n  io.emit('broadcast', message);\n}\n\n// Broadcasting a welcome message to all connected clients\nconst welcomeMessage = 'Welcome to the chat!';\nbroadcastMessage(io, welcomeMessage);\n\n// A function to handle user-specific messages\nfunction handleMessage(socket: Socket, message: string): void {\n  console.log(`Message from ${socket.id}: ${message}`);\n  socket.emit('message', `Received: ${message}`);\n}\n\n// Adding the message handler to the socket\nio.on('connection', (socket) => {\n  socket.on('message', (message) => handleMessage(socket, message));\n});\n\n// Mocking a connected client to test the message handling\nconst mockSocket = {\n  id: 'mock-socket-id',\n  emit: jest.fn(),\n  on: jest.fn((event, callback) => {\n    if (event === 'message') {\n      callback('Test message');\n    }\n  })\n};\n", "suffix": "io.close();\nserver.close();\n", "golden_completion": "handleMessage(mockSocket as unknown as Socket, 'Test message');\nexpect(mockSocket.emit).toHaveBeenCalledWith('message', 'Received: Test message');", "LLM_justification": "This test case involves Socket.io, a real-time communication library, and focuses on the correct usage of its API to handle and emit messages. The prefix sets up a comprehensive Socket.io server and includes helper functions to handle connections and messages. The golden completion demonstrates the correct way to handle a mocked socket message and verify the expected behavior using Jest. This scenario tests the LLM's ability to recognize and implement specific Socket.io patterns and correctly use Jest for assertions.", "assertions": "handleMessage(mockSocket as unknown as Socket, 'Test message');\nexpect(mockSocket.emit).toHaveBeenCalledWith('message', 'Received: Test message');\n", "o1-mini": ""}
{"id": "28", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as express from 'express';\nimport * as passport from 'passport';\nimport { Strategy as LocalStrategy } from 'passport-local';\nimport * as bcrypt from 'bcryptjs';\nimport * as bodyParser from 'body-parser';\nimport * as session from 'express-session';\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: false }));\napp.use(passport.initialize());\napp.use(passport.session());\n\ninterface User {\n  id: number;\n  username: string;\n  password: string;\n}\n\nconst users: User[] = [\n  { id: 1, username: 'user1', password: bcrypt.hashSync('password1', 10) },\n  { id: 2, username: 'user2', password: bcrypt.hashSync('password2', 10) }\n];\n\npassport.use(new LocalStrategy(\n  function(username, password, done) {\n    const user = users.find(u => u.username === username);\n    if (!user) {\n      return done(null, false, { message: 'Incorrect username.' });\n    }\n    if (!bcrypt.compareSync(password, user.password)) {\n      return done(null, false, { message: 'Incorrect password.' });\n    }\n    return done(null, user);\n  }\n));\n\npassport.serializeUser((user: User, done) => {\n  done(null, user.id);\n});\n\npassport.deserializeUser((id: number, done) => {\n  const user = users.find(u => u.id === id);\n  done(null, user);\n});\n\napp.post('/login',\n  passport.authenticate('local', { failureRedirect: '/login' }),\n  function(req, res) {\n    res.redirect('/');\n  }\n);\n\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\" action=\"/login\">\\n  <div>\\n    <label>Username:</label>\\n    <input type=\"text\" name=\"username\"/>\\n  </div>\\n  <div>\\n    <label>Password:</label>\\n    <input type=\"password\" name=\"password\"/>\\n  </div>\\n  <div>\\n    <input type=\"submit\" value=\"Login\"/>\\n  </div>\\n</form>');\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n\n// Test user login\nasync function testLogin() {\n  const response = await fetch('http://localhost:3000/login', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: 'username=user1&password=password1'\n  });\n", "suffix": "\n}\n\n// Run the test\n(async () => {\n  await testLogin();\n})();\n", "golden_completion": "if (response.status === 200) {\n    console.log('Login successful');\n  } else {\n    console.log('Login failed');\n  }\n", "LLM_justification": "This is a good test case because it uses Passport.js with the LocalStrategy for authentication, which is a less commonly documented approach compared to OAuth strategies. It tests the LLM's ability to recognize and complete a user login process using this specific authentication method. The completion involves handling the response from a login attempt, which is a critical part of the authentication flow.", "assertions": "import { strict as assert } from 'assert';\n\nasync function testAssertions() {\n  const response = await fetch('http://localhost:3000/login', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: 'username=user1&password=password1'\n  });\n  assert.equal(response.status, 200, 'Login should be successful');\n}\n\n// Run assertions\n(async () => {\n  await testAssertions();\n})();", "o1-mini": "      if (response.ok) {\n          console.log('Login successful');\n      } else {\n          console.log('Login failed');\n      }"}
{"id": "29", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { assert } from 'chai';\n\n// Firebase configuration\nconst firebaseConfig = {\n  apiKey: 'your-api-key',\n  authDomain: 'your-auth-domain',\n  projectId: 'your-project-id',\n  storageBucket: 'your-storage-bucket',\n  messagingSenderId: 'your-messaging-sender-id',\n  appId: 'your-app-id'\n};\n\n// Initialize Firebase\nfirebase.initializeApp(firebaseConfig);\n\n// Helper function to create a new user\nasync function createUser(email: string, password: string): Promise<firebase.auth.UserCredential> {\n  try {\n    const userCredential = await firebase.auth().createUserWithEmailAndPassword(email, password);\n    return userCredential;\n  } catch (error) {\n    throw new Error(`Error creating user: ${error.message}`);\n  }\n}\n\n// Helper function to sign in a user\nasync function signInUser(email: string, password: string): Promise<firebase.auth.UserCredential> {\n  try {\n    const userCredential = await firebase.auth().signInWithEmailAndPassword(email, password);\n    return userCredential;\n  } catch (error) {\n    throw new Error(`Error signing in user: ${error.message}`);\n  }\n}\n\n// Helper function to sign out a user\nasync function signOutUser(): Promise<void> {\n  try {\n    await firebase.auth().signOut();\n  } catch (error) {\n    throw new Error(`Error signing out user: ${error.message}`);\n  }\n}\n\n// Test case to verify user creation, sign-in, and sign-out\nasync function testFirebaseAuth() {\n  const testEmail = 'testuser@example.com';\n  const testPassword = 'password123';\n\n  // Create a new user\n  const createUserResult = await createUser(testEmail, testPassword);\n  assert.isNotNull(createUserResult.user, 'User should be created successfully');\n\n  // Sign in the user\n  const signInResult = await signInUser(testEmail, testPassword);\n  assert.isNotNull(signInResult.user, 'User should be signed in successfully');\n\n  // Check if the user is signed in\n  const currentUser = firebase.auth().currentUser;\n  assert.isNotNull(currentUser, 'User should be currently signed in');\n\n  // Send password reset email", "suffix": "\n  // Cleanup: Sign out the user\n  await signOutUser();\n  const signedOutUser = firebase.auth().currentUser;\n  assert.isNull(signedOutUser, 'User should be signed out successfully');\n}\n\n// Run the test\n(async () => {\n  try {\n    await testFirebaseAuth();\n    console.log('All assertions passed.');\n  } catch (error) {\n    console.error('Test failed:', error);\n  }\n})();", "golden_completion": "\n  await firebase.auth().sendPasswordResetEmail(testEmail);\n  console.log('Password reset email sent successfully');", "LLM_justification": "This test case demonstrates the usage of Firebase Authentication, focusing on the less commonly used function 'sendPasswordResetEmail'. It sets up a realistic scenario by creating, signing in, and signing out a user, ensuring that the API pattern is clear. The 'sendPasswordResetEmail' function is placed between the sign-in and sign-out operations, testing the model's understanding of API usage and parameter handling. Assertions verify the behavior at each step, and proper error handling and resource cleanup ensure a robust example.", "assertions": "assert.doesNotThrow(() => { firebase.auth().sendPasswordResetEmail('testuser@example.com'); }, 'Password reset email should be sent successfully');", "o1-mini": ""}
{"id": "30", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { WebSocketLink } from '@apollo/client/link/ws';\nimport { onError } from '@apollo/client/link/error';\nimport { ApolloLink, HttpLink, Observable } from '@apollo/client';\n\n// Setup WebSocketLink for subscriptions\nconst wsLink = new WebSocketLink({\n  uri: 'ws://localhost:4000/graphql',\n  options: {\n    reconnect: true\n  }\n});\n\n// Setup HttpLink for queries and mutations\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:4000/graphql'\n});\n\n// Error handling link\nconst errorLink = onError(({ graphQLErrors, networkError }) => {\n  if (graphQLErrors) {\n    graphQLErrors.forEach(({ message, locations, path }) => {\n      console.log(`GraphQL error: ${message}`);\n    });\n  }\n  if (networkError) {\n    console.log(`Network error: ${networkError.message}`);\n  }\n});\n\n// Custom ApolloLink for logging\nconst loggingLink = new ApolloLink((operation, forward) => {\n  console.log(`Starting request for ${operation.operationName}`);\n  return forward(operation).map((result) => {\n    console.log(`Completed request for ${operation.operationName}`);\n    return result;\n  });\n});\n\n// Setup ApolloClient with links and cache\nconst client = new ApolloClient({\n  link: ApolloLink.from([errorLink, loggingLink, wsLink, httpLink]),\n  cache: new InMemoryCache()\n});\n\n// Define a subscription query\nconst SUBSCRIBE_TO_MESSAGES = gql`\n  subscription OnMessageAdded {\n    messageAdded {\n      id\n      content\n      user {\n        name\n      }\n    }\n  }\n`;\n\n// Function to start the subscription\nfunction subscribeToMessages() {\n  const observable = client.subscribe({ query: SUBSCRIBE_TO_MESSAGES });\n  return observable;\n}\n\n// Function to handle new messages\nfunction handleNewMessage(message: any) {\n  console.log(`New message received: ${message.content} from ${message.user.name}`);\n}\n\n// Function to handle subscription errors\nfunction handleSubscriptionError(error: any) {\n  console.error('Subscription error:', error);\n}\n\n// Start the subscription and setup handlers\nconst subscription = subscribeToMessages();\nsubscription.subscribe({\n  next(response) {\n    handleNewMessage(response.data.messageAdded);\n  },\n  error(error) {\n    handleSubscriptionError(error);\n  }\n});\n\n// Mock data for testing\nconst mockMessage = {\n  data: {\n    messageAdded: {\n      id: '1',\n      content: 'Hello, World!',\n      user: {\n        name: 'Test User'\n      }\n    }\n  }\n};\n", "suffix": "// Cleanup resources (not required for this mock example)\n", "golden_completion": "subscription.subscribe({\n  next(response) {\n    handleNewMessage(response.data.messageAdded);\n  },\n  error(error) {\n    handleSubscriptionError(error);\n  }\n});", "LLM_justification": "This example tests the LLM's ability to handle the Apollo Client API, specifically focusing on the less common WebSocketLink for GraphQL subscriptions. It requires the model to recognize the correct setup and usage of subscription queries and handlers, which is uncommon compared to typical query/mutation usage. The golden completion demonstrates proper parameter ordering and error handling, ensuring robustness in real-time communication scenarios.", "assertions": "import { assert } from 'chai';\n\n// Mock the subscription response\nconst mockSubscription = {\n  subscribe: ({ next, error }: any) => {\n    try {\n      next(mockMessage);\n    } catch (err) {\n      error(err);\n    }\n  }\n};\n\n// Replace actual subscription with mock\nconst originalSubscribe = client.subscribe;\nclient.subscribe = () => mockSubscription;\n\n// Test the subscription and handlers\nconst subscriptionTest = subscribeToMessages();\n\nsubscriptionTest.subscribe({\n  next(response) {\n    assert.equal(response.data.messageAdded.content, 'Hello, World!');\n    assert.equal(response.data.messageAdded.user.name, 'Test User');\n  },\n  error(error) {\n    assert.fail('Subscription should not fail');\n  }\n});\n\n// Restore original subscription function\nclient.subscribe = originalSubscribe;\n", "o1-mini": ""}
{"id": "31", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { ApolloServer, makeExecutableSchema } from 'apollo-server';\nimport { assert } from 'chai';\n\n// Define the GraphQL schema\nconst typeDefs = `\n  type Query {\n    hello: String\n  }\n`;\n\n// Define the resolvers\nconst resolvers = {\n  Query: {\n    hello: () => 'Hello world!',\n  },\n};\n\n// Create the executable schema\nconst schema = makeExecutableSchema({\n  typeDefs,\n  resolvers,\n});\n\n// Initialize Apollo Server\nconst server = new ApolloServer({ schema });\n\n// Start the server\nserver.listen().then(({ url }) => {\n  console.log(`\ud83d\ude80 Server ready at ${url}`);\n});\n\n// Initialize Apollo Client\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000',\n  cache: new InMemoryCache(),\n});\n\n// Define the query\nconst HELLO_QUERY = gql`\n  query {\n    hello\n  }\n`;\n\n// This function will execute the query and return the result\nasync function fetchHello() {\n  try {\n    const result = await client.query({\n      query: HELLO_QUERY,\n    });\n    return result.data.hello;\n  } catch (error) {\n    throw new Error('Error fetching data');\n  }\n}\n\n// Fetch the data and perform assertions\nasync function testFetchHello() {\n  const hello = await fetchHello();\n  assert.strictEqual(hello, 'Hello world!', 'The response should be \"Hello world!\"');\n}\n\n// Run the test\n(async () => {\n  await testFetchHello();\n})();", "suffix": "server.stop().then(() => {\n  console.log('Server stopped');\n});", "golden_completion": "await server.stop();", "LLM_justification": "This test case uses Apollo Server and Apollo Client to set up a GraphQL server and client. It includes a query to fetch data and assertions to verify the correct behavior. The golden completion involves stopping the server, which is a less common operation, making it a good test of the LLM's ability to handle rare API usage patterns.", "assertions": "assert.strictEqual(typeof fetchHello, 'function', 'fetchHello should be a function');\nassert.strictEqual(typeof testFetchHello, 'function', 'testFetchHello should be a function');\nassert.strictEqual(typeof server.stop, 'function', 'server.stop should be a function');", "o1-mini": ""}
{"id": "32", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { WebSocketLink } from '@apollo/client/link/ws';\nimport { onError } from '@apollo/client/link/error';\nimport { split } from '@apollo/client';\nimport { getMainDefinition } from '@apollo/client/utilities';\n\n// Setup WebSocketLink for real-time updates\nconst wsLink = new WebSocketLink({\n  uri: 'ws://localhost:4000/graphql',\n  options: {\n    reconnect: true,\n  },\n});\n\n// Setup error handling link\nconst errorLink = onError(({ graphQLErrors, networkError }) => {\n  if (graphQLErrors) {\n    graphQLErrors.forEach(({ message, locations, path }) => {\n      console.log(`GraphQL error: ${message}`, locations, path);\n    });\n  }\n  if (networkError) {\n    console.log(`Network error: ${networkError}`);\n  }\n});\n\n// Use split for proper routing of queries and mutations\nconst splitLink = split(\n  ({ query }) => {\n    const definition = getMainDefinition(query);\n    return (\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'subscription'\n    );\n  },\n  wsLink,\n  errorLink\n);\n\n// Initialize Apollo Client\nconst client = new ApolloClient({\n  link: splitLink,\n  cache: new InMemoryCache(),\n});\n\n// Sample subscription query\nconst SUBSCRIBE_TO_MESSAGES = gql`\n  subscription OnMessageAdded {\n    messageAdded {\n      id\n      content\n      user {\n        id\n        name\n      }\n    }\n  }\n`;\n\n// Function to subscribe to messages\nfunction subscribeToMessages() {\n  const observable = client.subscribe({\n    query: SUBSCRIBE_TO_MESSAGES,\n  });\n\n  observable.subscribe({\n    next(response) {\n      console.log('New message:', response.data.messageAdded);\n    },\n    error(err) {\n      console.error('Subscription error:', err);\n    },\n  });\n}\n\n// Call the subscription function\nsubscribeToMessages();", "suffix": "console.log('Subscription setup complete.');", "golden_completion": "observable.subscribe({\n  next(response) {\n    console.log('New message:', response.data.messageAdded);\n  },\n  error(err) {\n    console.error('Subscription error:', err);\n  },\n});", "LLM_justification": "This test case examines the LLM's ability to recognize and implement a complex pattern involving Apollo Client's subscription setup using WebSocketLink. This scenario specifically tests rare but valid API interactions, such as handling subscriptions with real-time updates, proper error handling, and using split for routing. The context provided in the prefix ensures that the LLM must understand the setup and correctly complete the subscription logic, making it a comprehensive test of API pattern recognition and implementation.", "assertions": "import { strict as assert } from 'assert';\n\n// Mock client.subscribe to return a mock observable\nconst mockSubscribe = jest.fn().mockReturnValue({\n  subscribe: jest.fn(({ next, error }) => {\n    // Simulate a new message\n    next({ data: { messageAdded: { id: '1', content: 'Hello!', user: { id: '1', name: 'Alice' } } } });\n    // Simulate an error\n    error(new Error('Test error'));\n  })\n});\nclient.subscribe = mockSubscribe;\n\n// Capture console output\nconst consoleLog = jest.spyOn(console, 'log').mockImplementation(() => {});\nconst consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n\n// Run the subscription function\nsubscribeToMessages();\n\n// Verify subscription logic\nassert(mockSubscribe.mock.calls.length === 1, 'subscribe should be called once');\nassert(consoleLog.mock.calls[0][0] === 'New message:', 'First log should be New message:');\nassert(consoleLog.mock.calls[0][1].content === 'Hello!', 'Message content should be Hello!');\nassert(consoleError.mock.calls[0][0] === 'Subscription error:', 'First error log should be Subscription error:');\nassert(consoleError.mock.calls[0][1].message === 'Test error', 'Error message should be Test error');\n\n// Cleanup\nconsoleLog.mockRestore();\nconsoleError.mockRestore();", "o1-mini": ""}
{"id": "33", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as aws from 'aws-sdk';\nimport * as fs from 'fs';\nimport { createLogger, transports } from 'winston';\n\n// Initialize AWS S3 client\nconst s3 = new aws.S3({\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    region: process.env.AWS_REGION\n});\n\n// Initialize logger\nconst logger = createLogger({\n    level: 'info',\n    format: winston.format.json(),\n    transports: [\n        new transports.Console(),\n        new transports.File({ filename: 'combined.log' })\n    ]\n});\n\n// Function to upload file to S3\nconst uploadFileToS3 = async (filePath: string, bucketName: string, key: string): Promise<void> => {\n    try {\n        // Read file content\n        const fileContent = fs.readFileSync(filePath);\n\n        // Set up S3 upload parameters\n        const params = {\n            Bucket: bucketName,\n            Key: key,\n            Body: fileContent\n        };\n\n        // Uploading files to the bucket\n        await s3.upload(params).promise();\n        logger.info(`File uploaded successfully. ${key}`);\n    } catch (error) {\n        logger.error(`Error uploading file: ${error.message}`);\n        throw error;\n    }\n};\n\n// Function to list objects in S3 bucket\nconst listObjectsInBucket = async (bucketName: string): Promise<void> => {\n    try {\n        const params = {\n            Bucket: bucketName\n        };\n        const data = await s3.listObjectsV2(params).promise();\n        data.Contents?.forEach(item => {\n            logger.info(`Item: ${item.Key}`);\n        });\n    } catch (error) {\n        logger.error(`Error listing objects: ${error.message}`);\n        throw error;\n    }\n};\n\n// Test function to demonstrate the usage of uploadFileToS3 and listObjectsInBucket\nconst testS3Functions = async (): Promise<void> => {\n    const testFilePath = 'path/to/test/file.txt';\n    const testBucketName = 'my-test-bucket';\n    const testKey = 'test/file.txt';\n\n    // Ensure test file exists\n    fs.writeFileSync(testFilePath, 'This is a test file.');\n\n    // Upload test file to S3\n    await uploadFileToS3(testFilePath, testBucketName, testKey);\n\n    // List objects in the S3 bucket\n    await listObjectsInBucket(testBucketName);\n", "suffix": "    // Clean up test file\n    fs.unlinkSync(testFilePath);\n};\n\n// Run the test function\ntestS3Functions().catch(error => {\n    logger.error(`Test failed: ${error.message}`);\n});", "golden_completion": "    // Delete the test file from S3\n    const deleteParams = {\n        Bucket: testBucketName,\n        Key: testKey\n    };\n    await s3.deleteObject(deleteParams).promise();\n    logger.info(`Test file deleted successfully from S3. ${testKey}`);\n", "LLM_justification": "This test case involves AWS S3 operations using the aws-sdk library, focusing on a less common operation: deleting an object from an S3 bucket. The completion involves correctly forming and executing the deleteObject API call, which is not as frequently used as upload or list operations. The test ensures that the model can handle the pattern of creating parameters, invoking the AWS SDK method, and handling the promise. This scenario validates the model's ability to follow the established API usage pattern and complete it correctly.", "assertions": "import * as aws from 'aws-sdk';\nimport * as fs from 'fs';\nimport { createLogger, transports } from 'winston';\nimport assert from 'assert';\n\nconst s3 = new aws.S3({\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    region: process.env.AWS_REGION\n});\n\nconst logger = createLogger({\n    level: 'info',\n    format: winston.format.json(),\n    transports: [\n        new transports.Console(),\n        new transports.File({ filename: 'combined.log' })\n    ]\n});\n\nconst testS3Functions = async (): Promise<void> => {\n    const testFilePath = 'path/to/test/file.txt';\n    const testBucketName = 'my-test-bucket';\n    const testKey = 'test/file.txt';\n\n    fs.writeFileSync(testFilePath, 'This is a test file.');\n\n    await uploadFileToS3(testFilePath, testBucketName, testKey);\n    await listObjectsInBucket(testBucketName);\n\n    const deleteParams = {\n        Bucket: testBucketName,\n        Key: testKey\n    };\n    await s3.deleteObject(deleteParams).promise();\n    const data = await s3.listObjectsV2({ Bucket: testBucketName }).promise();\n    const fileExists = data.Contents?.some(item => item.Key === testKey);\n    assert.strictEqual(fileExists, false, 'Test file should be deleted from S3');\n\n    fs.unlinkSync(testFilePath);\n};\n\ntestS3Functions().catch(error => {\n    logger.error(`Test failed: ${error.message}`);\n});", "o1-mini": ""}
{"id": "34", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as jwt from 'jsonwebtoken';\nimport * as bcrypt from 'bcryptjs';\n\ninterface User {\n  id: string;\n  username: string;\n  password: string;\n}\n\nconst users: User[] = [\n  { id: '1', username: 'user1', password: '$2a$10$E9aXzHB4jFQOqTkZ4Gk3Oe' },\n  { id: '2', username: 'user2', password: '$2a$10$wq5dF1s5lCzv2J9e4Gk3Oe' }\n];\n\nconst JWT_SECRET = 'your_jwt_secret_key';\n\nfunction authenticate(username: string, password: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const user = users.find(u => u.username === username);\n    if (!user) {\n      return reject('User not found');\n    }\n    bcrypt.compare(password, user.password, (err, isMatch) => {\n      if (err) return reject(err);\n      if (!isMatch) return reject('Invalid credentials');\n      // Continue with generating the JWT token\n", "suffix": "      return reject('Authentication failed');\n    });\n  });\n}\n\n// Example usage\n(async () => {\n  try {\n    const token = await authenticate('user1', 'wrongpassword');\n    console.log('Authentication successful:', token);\n  } catch (err) {\n    console.error('Authentication error:', err);\n  }\n})();\n", "golden_completion": "      const token = jwt.sign({ id: user.id, username: user.username }, JWT_SECRET, { expiresIn: '1h' });\n      resolve(token);\n", "LLM_justification": "This test case involves using the jsonwebtoken and bcrypt.js libraries for authentication, which are important but less commonly seen APIs for handling JWT token generation and password comparison. The example tests the LLM's ability to correctly use the jwt.sign function to generate a token and handle bcrypt.compare for password validation. This scenario is realistic and represents common but less frequently demonstrated usage patterns in authentication systems.", "assertions": "import * as assert from 'assert';\n\n(async () => {\n  try {\n    const token = await authenticate('user1', '$2a$10$E9aXzHB4jFQOqTkZ4Gk3Oe');\n    assert.ok(token, 'Token should be generated');\n    const decoded = jwt.verify(token, JWT_SECRET);\n    assert.strictEqual(decoded.username, 'user1', 'Username should be user1');\n    assert.strictEqual(decoded.id, '1', 'ID should be 1');\n  } catch (err) {\n    assert.fail('Authentication failed with correct credentials');\n  }\n})();\n", "o1-mini": ""}
{"id": "35", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as jwt from 'jsonwebtoken';\nimport * as express from 'express';\nimport * as bodyParser from 'body-parser';\n\n// Define a user type for better type safety\ninterface User {\n  id: string;\n  username: string;\n  password: string;\n}\n\n// Sample user data\nconst users: User[] = [\n  { id: '1', username: 'user1', password: 'password1' },\n  { id: '2', username: 'user2', password: 'password2' }\n];\n\n// JWT secret key\nconst JWT_SECRET = 'your-secret-key';\n\n// Create an Express app\nconst app = express();\napp.use(bodyParser.json());\n\n// Middleware to authenticate JWT token\nfunction authenticateToken(req: express.Request, res: express.Response, next: express.NextFunction) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  if (token == null) return res.sendStatus(401);\n\n  jwt.verify(token, JWT_SECRET, (err: any, user: any) => {\n    if (err) return res.sendStatus(403);\n    req.user = user;\n    next();\n  });\n}\n\n// Login route to issue JWT token\napp.post('/login', (req, res) => {\n  // Authenticate User\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) {\n    return res.status(400).send('Username or password incorrect');\n  }\n\n  // Generate an access token\n  const accessToken = jwt.sign({ username: user.username, id: user.id }, JWT_SECRET);\n  res.json({ accessToken });\n});\n\n// Protected route\napp.get('/protected', authenticateToken, (req, res) => {\n  res.json({ message: 'This is a protected route', user: req.user });\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\n\n// For testing purposes\nconst request = require('supertest');\nlet token: string;\n\n// Test the login route to get a token\nbeforeAll(async () => {\n  const response = await request(app)\n    .post('/login')\n    .send({ username: 'user1', password: 'password1' });\n  token = response.body.accessToken;\n});", "suffix": "\n\n  expect(response.status).toBe(200);\n  expect(response.body).toHaveProperty('message', 'This is a protected route');\n  expect(response.body.user).toHaveProperty('username', 'user1');\n});\n\n// Cleanup resources if any\nafterAll(() => {\n  // Perform any necessary cleanup\n});", "golden_completion": "test('access protected route', async () => {\n  const response = await request(app)\n    .get('/protected')\n    .set('Authorization', `Bearer ${token}`);\n\n", "LLM_justification": "This test case demonstrates the use of the jsonwebtoken library for JWT authentication in an Express.js application. It includes a comprehensive setup with user authentication and a protected route. The test case verifies that the protected route can be accessed with a valid JWT token, ensuring proper API behavior and parameter correctness.", "assertions": "test('access protected route', async () => {\n  const response = await request(app)\n    .get('/protected')\n    .set('Authorization', `Bearer ${token}`);\n\n  expect(response.status).toBe(200);\n  expect(response.body).toHaveProperty('message', 'This is a protected route');\n  expect(response.body.user).toHaveProperty('username', 'user1');\n});", "o1-mini": ""}
{"id": "36", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport assert from 'assert';\n\n// Initializing Apollo Client with an in-memory cache\nconst client = new ApolloClient({\n  uri: 'https://example.com/graphql',\n  cache: new InMemoryCache()\n});\n\n// Query to fetch user data\nconst GET_USER = gql`\n  query GetUser($id: ID!) {\n    user(id: $id) {\n      id\n      name\n      email\n    }\n  }\n`;\n\n// Function to fetch user data by ID\nasync function fetchUserData(userId: string) {\n  try {\n    const result = await client.query({\n      query: GET_USER,\n      variables: { id: userId }\n    });\n    return result.data.user;\n  } catch (error) {\n    console.error('Error fetching user data:', error);\n    throw error;\n  }\n}\n\n// Utility function to verify user data\nfunction verifyUserData(user: any) {\n  assert(user, 'User data should not be null or undefined');\n  assert(typeof user.id === 'string', 'User ID should be a string');\n  assert(typeof user.name === 'string', 'User name should be a string');\n  assert(typeof user.email === 'string', 'User email should be a string');\n}\n\n// Sample user ID for testing\nconst sampleUserId = '12345';\n\n// Fetching and verifying user data\nfetchUserData(sampleUserId).then(user => {\n  verifyUserData(user);\n", "suffix": "\n  console.log('User data is valid:', user);\n}).catch(error => {\n  console.error('Test failed:', error);\n});\n", "golden_completion": "\n  assert(user.name === 'John Doe', 'User name should be John Doe');\n  assert(user.email === 'john.doe@example.com', 'User email should be john.doe@example.com');\n", "LLM_justification": "This test case uses the Apollo Client library to query a GraphQL endpoint and fetch user data. The test case is designed to verify that the LLM can correctly recognize and continue the pattern of fetching and asserting user data, including handling specific values for the user's name and email. The use of Apollo Client and GraphQL query patterns is uncommon compared to more frequently seen REST API clients, making this a good benchmark for rare API usage capabilities.", "assertions": "fetchUserData(sampleUserId).then(user => {\n  verifyUserData(user);\n  assert(user.name === 'John Doe', 'User name should be John Doe');\n  assert(user.email === 'john.doe@example.com', 'User email should be john.doe@example.com');\n  console.log('User data is valid:', user);\n}).catch(error => {\n  console.error('Test failed:', error);\n});", "o1-mini": ""}
{"id": "37", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as ws from 'ws';\n\n// Helper function to create a new WebSocket server\nfunction createWebSocketServer(port: number): ws.Server {\n    const server = new ws.Server({ port });\n    console.log(`WebSocket server started on port ${port}`);\n    return server;\n}\n\n// Function to handle incoming connections\nfunction handleConnection(socket: ws): void {\n    console.log('New client connected');\n    socket.on('message', (message) => {\n        console.log(`Received message: ${message}`);\n    });\n\n    socket.on('close', () => {\n        console.log('Client disconnected');\n    });\n}\n\n// Function to broadcast a message to all connected clients\nfunction broadcastMessage(server: ws.Server, message: string): void {\n    server.clients.forEach((client) => {\n        if (client.readyState === ws.OPEN) {\n            client.send(message);\n        }\n    });\n}\n\n// Create WebSocket server on port 8080\nconst server = createWebSocketServer(8080);\n\n// Handle new connections\nserver.on('connection', handleConnection);\n\n// Send a broadcast message after 5 seconds\nsetTimeout(() => {\n    broadcastMessage(server, 'Hello, clients!');\n}, 5000);\n\n// Function to gracefully shutdown the server\nfunction shutdownServer(server: ws.Server): void {\n    console.log('Shutting down WebSocket server');\n    server.close(() => {\n        console.log('WebSocket server closed');\n    });\n}\n", "suffix": "const client = new ws('ws://localhost:8080');\n\nclient.on('open', () => {\n    console.log('Connected to server');\n    client.send('Hello, server!');\n});\n\nclient.on('message', (message) => {\n    console.log(`Received from server: ${message}`);\n    if (message === 'Hello, clients!') {\n        client.close();\n        shutdownServer(server);\n    }\n});", "golden_completion": "server.on('error', (error) => {\n    console.error(`Server error: ${error}`);\n});\n", "LLM_justification": "This test case evaluates the model's ability to recognize and correctly implement an uncommon but crucial WebSocket server error-handling pattern using the 'ws' library. The correct completion involves attaching an 'error' event listener to the WebSocket server, which is essential for robust server operation and is often overlooked. This tests the model's understanding of proper error handling in real-time communication APIs.", "assertions": "const serverErrorHandler = jest.fn();\nserver.on('error', serverErrorHandler);\n\nserver.emit('error', new Error('Test Error'));\nexpect(serverErrorHandler).toHaveBeenCalledWith(expect.any(Error));", "o1-mini": ""}
{"id": "38", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { onError } from '@apollo/client/link/error';\nimport { HttpLink } from '@apollo/client/link/http';\nimport { ApolloLink } from '@apollo/client/link/core';\nimport fetch from 'cross-fetch';\n\n// Define GraphQL queries\nconst GET_USER = gql`\n  query GetUser($id: ID!) {\n    user(id: $id) {\n      id\n      name\n      email\n    }\n  }\n`;\n\n// Define error handling link\nconst errorLink = onError(({ graphQLErrors, networkError }) => {\n  if (graphQLErrors) {\n    graphQLErrors.forEach(({ message, locations, path }) => {\n      console.error(`GraphQL error: ${message}, Location: ${locations}, Path: ${path}`);\n    });\n  }\n  if (networkError) {\n    console.error(`Network error: ${networkError}`);\n  }\n});\n\n// Define HTTP link\nconst httpLink = new HttpLink({\n  uri: 'https://example.com/graphql',\n  fetch\n});\n\n// Combine links\nconst link = ApolloLink.from([errorLink, httpLink]);\n\n// Initialize Apollo Client\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link\n});\n\n// Function to fetch user data\nasync function fetchUserData(userId: string) {\n  try {\n    const result = await client.query({\n      query: GET_USER,\n      variables: { id: userId }\n    });\n    return result.data.user;\n  } catch (error) {\n    console.error('Error fetching user data:', error);\n    throw error;\n  }\n}\n\n// Sample user ID\nconst sampleUserId = '123';\n\n// Main function to execute the code\nasync function main() {\n  try {\n    const user = await fetchUserData(sampleUserId);\n    console.log('User data:', user);\n    // Verify user data\n", "suffix": "  } catch (error) {\n    console.error('Main function error:', error);\n  }\n}\n\nmain();\n", "golden_completion": "\n    if (user) {\n      console.assert(user.id === sampleUserId, 'User ID should match');\n      console.assert(typeof user.name === 'string', 'User name should be a string');\n      console.assert(typeof user.email === 'string', 'User email should be a string');\n    } else {\n      console.error('No user data returned');\n    }\n", "LLM_justification": "This test case is a good example of using Apollo Client with error handling and GraphQL queries. It tests the LLM's ability to understand the pattern of defining and using Apollo Client, setting up error handling, and fetching data with proper query and variable usage. The golden completion includes assertions to verify the correctness of the fetched data, ensuring the user data matches expected types and values.", "assertions": "console.assert(user.id === sampleUserId, 'User ID should match');\nconsole.assert(typeof user.name === 'string', 'User name should be a string');\nconsole.assert(typeof user.email === 'string', 'User email should be a string');", "o1-mini": ""}
{"id": "39", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import axios from 'axios';\nimport { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\n// Setup Apollo Client\nconst client = new ApolloClient({\n  uri: 'https://example.com/graphql',\n  cache: new InMemoryCache()\n});\n\n// Helper function to fetch data from REST API using Axios\nasync function fetchDataFromRestAPI(endpoint: string): Promise<any> {\n  try {\n    const response = await axios.get(endpoint);\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching data from REST API:', error);\n    throw error;\n  }\n}\n\n// Helper function to fetch data from GraphQL API using Apollo Client\nasync function fetchDataFromGraphQL(query: string): Promise<any> {\n  try {\n    const response = await client.query({ query: gql(query) });\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching data from GraphQL API:', error);\n    throw error;\n  }\n}\n\n// Sample data to use in the tests\nconst restAPIEndpoint = 'https://jsonplaceholder.typicode.com/posts/1';\nconst graphQLQuery = `{\n  post(id: 1) {\n    id\n    title\n    body\n  }\n}`;\n\n// Function to handle combined data fetching and processing\nasync function fetchAndProcessData(): Promise<void> {\n  try {\n    const restData = await fetchDataFromRestAPI(restAPIEndpoint);\n    console.log('REST API Data:', restData);\n\n    const graphQLData = await fetchDataFromGraphQL(graphQLQuery);\n    console.log('GraphQL API Data:', graphQLData);\n\n    // Process the fetched data\n    const processedData = {\n      restTitle: restData.title,\n      graphQLBody: graphQLData.post.body\n    };\n    console.log('Processed Data:', processedData);\n\n    // Assertions to verify the fetched data\n    // Ensure the REST API data has a title property\n    if (!restData.title) throw new Error('REST API data does not contain a title property');\n    // Ensure the GraphQL API data has a body property\n    if (!graphQLData.post || !graphQLData.post.body) throw new Error('GraphQL API data does not contain a body property');\n", "suffix": "\n  } catch (error) {\n    console.error('Error in fetchAndProcessData:', error);\n    throw error;\n  }\n}\n\n// Execute the function\nfetchAndProcessData().then(() => {\n  console.log('Data fetching and processing completed successfully.');\n}).catch((error) => {\n  console.error('Failed to fetch and process data:', error);\n});\n", "golden_completion": "    // Ensure the processed data is correct\n    if (processedData.restTitle !== restData.title) throw new Error('Processed data REST title does not match');\n    if (processedData.graphQLBody !== graphQLData.post.body) throw new Error('Processed data GraphQL body does not match');", "LLM_justification": "This example demonstrates the use of both Axios for REST API and Apollo Client for GraphQL API, combining data from both sources, and validating the combined data. The golden completion tests for the correct processing of data which is a crucial part of data integration scenarios. It also verifies the use of uncommon API functions and parameter correctness, making it a comprehensive test case.", "assertions": "const restData = { title: 'Test Title' };\nconst graphQLData = { post: { body: 'Test Body' } };\nconst processedData = { restTitle: restData.title, graphQLBody: graphQLData.post.body };\nif (processedData.restTitle !== restData.title) throw new Error('Processed data REST title does not match');\nif (processedData.graphQLBody !== graphQLData.post.body) throw new Error('Processed data GraphQL body does not match');", "o1-mini": ""}
{"id": "40", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import express from 'express';\nimport bodyParser from 'body-parser';\nimport Stripe from 'stripe';\nimport assert from 'assert';\n\nconst app = express();\nconst stripe = new Stripe('your-secret-key', { apiVersion: '2020-08-27' });\n\napp.use(bodyParser.json());\n\n// Helper function to create a new customer\ntype Customer = { id: string, email: string };\nasync function createCustomer(email: string): Promise<Customer> {\n  try {\n    const customer = await stripe.customers.create({ email });\n    return { id: customer.id, email: customer.email };\n  } catch (error) {\n    throw new Error('Failed to create customer');\n  }\n}\n\n// Helper function to create a payment intent\ntype PaymentIntent = { id: string, clientSecret: string };\nasync function createPaymentIntent(amount: number, currency: string, customerId: string): Promise<PaymentIntent> {\n  try {\n    const paymentIntent = await stripe.paymentIntents.create({\n      amount,\n      currency,\n      customer: customerId,\n    });\n    return { id: paymentIntent.id, clientSecret: paymentIntent.client_secret! };\n  } catch (error) {\n    throw new Error('Failed to create payment intent');\n  }\n}\n\n// Endpoint to handle payment creation\napp.post('/create-payment', async (req, res) => {\n  const { email, amount, currency } = req.body;\n  try {\n    const customer = await createCustomer(email);\n    const paymentIntent = await createPaymentIntent(amount, currency, customer.id);\n    res.status(200).send({ paymentIntentId: paymentIntent.id, clientSecret: paymentIntent.clientSecret });\n  } catch (error) {\n    res.status(500).send({ error: error.message });\n  }\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});", "suffix": "app.post('/refund-payment', async (req, res) => {\n  const { paymentIntentId } = req.body;\n  try {\n    const refund = await stripe.refunds.create({\n      payment_intent: paymentIntentId,\n    });\n    res.status(200).send({ refundId: refund.id });\n  } catch (error) {\n    res.status(500).send({ error: error.message });\n  }\n});", "golden_completion": "app.post('/capture-payment', async (req, res) => {\n  const { paymentIntentId } = req.body;\n  try {\n    const paymentIntent = await stripe.paymentIntents.capture(paymentIntentId);\n    res.status(200).send({ paymentIntentId: paymentIntent.id, status: paymentIntent.status });\n  } catch (error) {\n    res.status(500).send({ error: error.message });\n  }\n});", "LLM_justification": "This example tests the LLM's ability to recognize and implement a pattern involving the Stripe API for capturing a payment intent. The completion demonstrates handling the capture of a payment intent, an operation that is less commonly used compared to creating customers or payment intents. The prefix sets up the necessary context and helper functions, while the suffix handles a different Stripe operation (refund) to ensure the completion focuses on the capture operation. Assertions verify that the correct Stripe API methods are called with appropriate parameters.", "assertions": "assert.strictEqual(typeof paymentIntent.id, 'string');\nassert.strictEqual(paymentIntent.status, 'succeeded');", "o1-mini": ""}
{"id": "41", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as Stripe from 'stripe';\nimport assert from 'assert';\n\n// Initialize Stripe with a test API key\nconst stripe = new Stripe('sk_test_4eC39HqLyjWDarjtT1zdp7dc', {\n  apiVersion: '2020-08-27',\n});\n\n// Define a function to create a new customer\nasync function createCustomer(email: string, name: string) {\n  try {\n    const customer = await stripe.customers.create({\n      email,\n      name,\n    });\n    return customer;\n  } catch (error) {\n    throw new Error('Failed to create customer: ' + error.message);\n  }\n}\n\n// Define a function to create a new payment intent\nasync function createPaymentIntent(amount: number, currency: string, customerId: string) {\n  try {\n    const paymentIntent = await stripe.paymentIntents.create({\n      amount,\n      currency,\n      customer: customerId,\n    });\n    return paymentIntent;\n  } catch (error) {\n    throw new Error('Failed to create payment intent: ' + error.message);\n  }\n}\n\n// Define a function to handle a payment\nasync function handlePayment(email: string, name: string, amount: number, currency: string) {\n  const customer = await createCustomer(email, name);\n  const paymentIntent = await createPaymentIntent(amount, currency, customer.id);\n  return paymentIntent;\n}\n\n// Usage of handlePayment function\n(async () => {\n  const email = 'customer@example.com';\n  const name = 'John Doe';\n  const amount = 5000; // amount in cents\n  const currency = 'usd';\n  try {\n    const paymentIntent = await handlePayment(email, name, amount, currency);\n    console.log('Payment Intent created successfully:', paymentIntent);\n  } catch (error) {\n    console.error('Error handling payment:', error.message);\n  }\n})();\n// Create customer source\n", "suffix": "const paymentMethod = await stripe.paymentMethods.create({\n  type: 'card',\n  card: {\n    number: '4242424242424242',\n    exp_month: 12,\n    exp_year: 2023,\n    cvc: '123',\n  },\n});\n\nassert(paymentMethod.type === 'card');\nassert(paymentMethod.card !== undefined);\nassert(paymentMethod.card.exp_month === 12);\nassert(paymentMethod.card.exp_year === 2023);\nassert(paymentMethod.card.cvc_check === 'unchecked');\n\n// Cleanup: Delete the created customer\nawait stripe.customers.del(paymentIntent.customer as string);", "golden_completion": "const customerSource = await stripe.customers.createSource(customer.id, {\n  source: 'tok_visa',\n});\n\nassert(customerSource.object === 'card');\nassert(customerSource.brand === 'Visa');\nassert(customerSource.last4 === '4242');\nassert(customerSource.exp_month === 12);\nassert(customerSource.exp_year === 2023);", "LLM_justification": "This test case is a good example because it involves creating a customer and a payment intent using the Stripe API, which is a common but complex API interaction. It also includes the creation of a payment method, which is a less common operation. The golden completion involves adding a source to a customer, which is an uncommon operation in the Stripe API. The assertions check the correctness of the API usage, parameter ordering, and the expected attributes of the created source. This test will help ensure that the LLM can handle complex, multi-step API interactions and correctly use less common API methods.", "assertions": "assert(customerSource.object === 'card');\nassert(customerSource.brand === 'Visa');\nassert(customerSource.last4 === '4242');\nassert(customerSource.exp_month === 12);\nassert(customerSource.exp_year === 2023);", "o1-mini": ""}
{"id": "42", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as d3 from 'd3';\nimport { select, Selection } from 'd3-selection';\nimport { scaleLinear } from 'd3-scale';\nimport { axisBottom, axisLeft } from 'd3-axis';\n\ninterface DataPoint {\n  x: number;\n  y: number;\n}\n\nconst data: DataPoint[] = [\n  { x: 30, y: 20 },\n  { x: 50, y: 80 },\n  { x: 90, y: 50 },\n  { x: 120, y: 100 },\n  { x: 200, y: 150 }\n];\n\nconst margin = { top: 20, right: 30, bottom: 40, left: 40 };\nconst width = 500 - margin.left - margin.right;\nconst height = 400 - margin.top - margin.bottom;\n\nconst svg = select('body').append('svg')\n  .attr('width', width + margin.left + margin.right)\n  .attr('height', height + margin.top + margin.bottom)\n  .append('g')\n  .attr('transform', `translate(${margin.left},${margin.top})`);\n\nconst xScale = scaleLinear()\n  .domain([0, d3.max(data, d => d.x)!])\n  .range([0, width]);\n\nconst yScale = scaleLinear()\n  .domain([0, d3.max(data, d => d.y)!])\n  .range([height, 0]);\n\nsvg.append('g')\n  .attr('class', 'x-axis')\n  .attr('transform', `translate(0,${height})`)\n  .call(axisBottom(xScale));\n\nsvg.append('g')\n  .attr('class', 'y-axis')\n  .call(axisLeft(yScale));\n\n// Creating circles for data points\nconst circles = svg.selectAll('circle')\n  .data(data)\n  .enter().append('circle')\n  .attr('cx', d => xScale(d.x))\n  .attr('cy', d => yScale(d.y))\n  .attr('r', 5)\n  .attr('fill', 'blue');\n\n// Adding labels to the circles\nconst labels = svg.selectAll('text')\n  .data(data)\n  .enter().append('text')\n  .attr('x', d => xScale(d.x))\n  .attr('y', d => yScale(d.y))\n  .attr('dy', '-0.75em')\n  .text(d => `(${d.x}, ${d.y})`);\n\n// Adding tooltip functionality\nconst tooltip = select('body').append('div')\n  .attr('class', 'tooltip')\n  .style('position', 'absolute')\n  .style('background-color', 'white')\n  .style('border', '1px solid black')\n  .style('padding', '5px')\n  .style('display', 'none');\n\nfunction showTooltip(event: MouseEvent, d: DataPoint) {\n  tooltip.style('left', `${event.pageX + 5}px`)\n         .style('top', `${event.pageY - 28}px`)\n         .style('display', 'inline-block')\n         .html(`x: ${d.x}<br>y: ${d.y}`);\n}\n\nfunction hideTooltip() {\n  tooltip.style('display', 'none');\n}\n\ncircles.on('mouseover', function(event, d) {\n  showTooltip(event, d);\n})\n.on('mouseout', hideTooltip);\n\n// Adding transition to circles on hover\ncircles.on('mouseover', function(event, d) {\n  select(this)\n    .transition()\n    .duration(500)\n    .attr('r', 10)\n    .attr('fill', 'red');\n})\n.on('mouseout', function() {\n  select(this)\n    .transition()\n    .duration(500)\n    .attr('r', 5)\n    .attr('fill', 'blue');\n});", "suffix": "circles.on('click', function(event, d) {\n  select(this)\n    .transition()\n    .duration(500)\n    .attr('r', 10)\n    .attr('fill', 'green');\n});\n\nlabels.on('mouseover', function(event, d) {\n  select(this)\n    .transition()\n    .duration(500)\n    .attr('fill', 'orange');\n})\n.on('mouseout', function() {\n  select(this)\n    .transition()\n    .duration(500)\n    .attr('fill', 'black');\n});\n\n// Cleanup\nsvg.remove();\ntooltip.remove();", "golden_completion": "labels.on('click', function(event, d) {\n  select(this)\n    .transition()\n    .duration(500)\n    .attr('fill', 'purple');\n});", "LLM_justification": "This test case evaluates the LLM's ability to recognize and continue patterns in D3.js, focusing on less common interactions such as adding transitions to labels and handling various events like 'mouseover', 'mouseout', and 'click'. It tests the model's understanding of D3.js methods and chaining, as well as its ability to maintain consistency in API usage and parameter handling.", "assertions": "const circles = svg.selectAll('circle');\nconst labels = svg.selectAll('text');\n\ncircles.each(function(d) {\n  select(this).dispatch('mouseover');\n  assert.equal(select(this).attr('r'), '10', 'Circle radius should be 10 on mouseover');\n  assert.equal(select(this).attr('fill'), 'red', 'Circle fill should be red on mouseover');\n  select(this).dispatch('mouseout');\n  assert.equal(select(this).attr('r'), '5', 'Circle radius should be 5 on mouseout');\n  assert.equal(select(this).attr('fill'), 'blue', 'Circle fill should be blue on mouseout');\n});\n\nlabels.each(function(d) {\n  select(this).dispatch('click');\n  assert.equal(select(this).attr('fill'), 'purple', 'Label fill should be purple on click');\n});", "o1-mini": ""}
{"id": "43", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as d3 from 'd3';\ninterface DataPoint {\n  date: Date;\n  value: number;\n}\n\nconst data: DataPoint[] = [\n  { date: new Date('2021-01-01'), value: 10 },\n  { date: new Date('2021-02-01'), value: 20 },\n  { date: new Date('2021-03-01'), value: 30 },\n];\n\nconst margin = { top: 20, right: 30, bottom: 30, left: 40 };\nconst width = 800 - margin.left - margin.right;\nconst height = 400 - margin.top - margin.bottom;\n\nconst svg = d3.select('body').append('svg')\n  .attr('width', width + margin.left + margin.right)\n  .attr('height', height + margin.top + margin.bottom)\n  .append('g')\n  .attr('transform', `translate(${margin.left},${margin.top})`);\n\nconst x = d3.scaleTime()\n  .domain(d3.extent(data, d => d.date) as [Date, Date])\n  .range([0, width]);\n\nconst y = d3.scaleLinear()\n  .domain([0, d3.max(data, d => d.value) as number])\n  .nice()\n  .range([height, 0]);\n\nsvg.append('g')\n  .attr('class', 'x-axis')\n  .attr('transform', `translate(0,${height})`)\n  .call(d3.axisBottom(x));\n\nsvg.append('g')\n  .attr('class', 'y-axis')\n  .call(d3.axisLeft(y));\n\nconst line = d3.line<DataPoint>()\n  .x(d => x(d.date))\n  .y(d => y(d.value));\n\nsvg.append('path')\n  .datum(data)\n  .attr('fill', 'none')\n  .attr('stroke', 'steelblue')\n  .attr('stroke-width', 1.5)\n  .attr('d', line);\n\n// Adding a tooltip to show data points on hover\nconst tooltip = d3.select('body').append('div')\n  .attr('class', 'tooltip')\n  .style('position', 'absolute')\n  .style('background', '#f9f9f9')\n  .style('border', '1px solid #d3d3d3')\n  .style('padding', '5px')\n  .style('display', 'none');\n\nsvg.selectAll('.dot')\n  .data(data)\n  .enter().append('circle')\n  .attr('class', 'dot')\n  .attr('cx', d => x(d.date))\n  .attr('cy', d => y(d.value))\n  .attr('r', 5)\n  .attr('fill', 'red')\n  .on('mouseover', function(event, d) {\n    tooltip.style('display', 'block');\n    tooltip.html(`Date: ${d.date}<br>Value: ${d.value}`);\n  })\n  .on('mousemove', function(event) {\n    tooltip.style('left', (event.pageX + 5) + 'px')\n      .style('top', (event.pageY - 5) + 'px');\n  })\n  .on('mouseout', function() {\n    tooltip.style('display', 'none');\n  });\n", "suffix": "\nconst legend = svg.append('g')\n  .attr('class', 'legend')\n  .attr('transform', `translate(${width - 100},${margin.top})`);\n\nlegend.append('rect')\n  .attr('x', 0)\n  .attr('y', 0)\n  .attr('width', 10)\n  .attr('height', 10)\n  .attr('fill', 'steelblue');\n\nlegend.append('text')\n  .attr('x', 20)\n  .attr('y', 10)\n  .text('Data Line');\n", "golden_completion": "\nd3.select(window).on('resize', function() {\n  const newWidth = parseInt(d3.select('body').style('width')) - margin.left - margin.right;\n  const newHeight = parseInt(d3.select('body').style('height')) - margin.top - margin.bottom;\n\n  svg.attr('width', newWidth + margin.left + margin.right)\n    .attr('height', newHeight + margin.top + margin.bottom);\n\n  x.range([0, newWidth]);\n  y.range([newHeight, 0]);\n\n  svg.selectAll('.x-axis').call(d3.axisBottom(x));\n  svg.selectAll('.y-axis').call(d3.axisLeft(y));\n\n  svg.selectAll('.dot')\n    .attr('cx', d => x(d.date))\n    .attr('cy', d => y(d.value));\n\n  svg.selectAll('path').attr('d', line);\n});\n", "LLM_justification": "This test case evaluates the LLM's ability to recognize and continue a complex D3.js pattern involving responsive design. The completion demonstrates how to handle window resize events to update the chart dimensions dynamically, which is a less common but important use case in data visualization. The prefix sets up a full D3 line chart with tooltips, while the suffix adds a legend to the chart. The golden completion focuses on adding resize handling, which is a rare but critical feature for responsive charts.", "assertions": "import { JSDOM } from 'jsdom';\nimport * as assert from 'assert';\n\nconst { window } = new JSDOM('<body></body>', { pretendToBeVisual: true });\nconst { document } = window;\nglobal.document = document;\nglobal.window = window;\nglobal.navigator = { userAgent: 'node.js' };\n\nconst svg = document.querySelector('svg');\nassert(svg !== null, 'SVG element should exist');\nconst dots = svg.querySelectorAll('.dot');\nassert(dots.length === data.length, 'There should be a dot for each data point');\n\nconst initialWidth = svg.getAttribute('width');\nconst initialHeight = svg.getAttribute('height');\n\nwindow.resizeTo(600, 300);\nconst resizedWidth = svg.getAttribute('width');\nconst resizedHeight = svg.getAttribute('height');\n\nassert.notStrictEqual(initialWidth, resizedWidth, 'SVG width should change on resize');\nassert.notStrictEqual(initialHeight, resizedHeight, 'SVG height should change on resize');\n", "o1-mini": ""}
{"id": "44", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Chart } from 'chart.js';\nimport { expect } from 'chai';\n\n// Create a canvas element for the chart\nconst canvas = document.createElement('canvas');\ndocument.body.appendChild(canvas);\n\n// Configuration for the chart\nconst config = {\n    type: 'line',\n    data: {\n        labels: ['January', 'February', 'March', 'April', 'May', 'June', 'July'],\n        datasets: [{\n            label: 'My First dataset',\n            backgroundColor: 'rgba(75,192,192,0.4)',\n            borderColor: 'rgba(75,192,192,1)',\n            data: [65, 59, 80, 81, 56, 55, 40],\n        }]\n    },\n    options: {\n        responsive: true,\n        plugins: {\n            title: {\n                display: true,\n                text: 'Chart.js Line Chart'\n            },\n            tooltip: {\n                mode: 'index',\n                intersect: false,\n            },\n        },\n        hover: {\n            mode: 'nearest',\n            intersect: true\n        },\n        scales: {\n            x: {\n                display: true,\n                title: {\n                    display: true,\n                    text: 'Month'\n                }\n            },\n            y: {\n                display: true,\n                title: {\n                    display: true,\n                    text: 'Value'\n                }\n            }\n        }\n    }\n};\n\n// Initialize the chart\nconst myChart = new Chart(canvas, config);\n\n// Function to update the chart data\nfunction updateChartData(chart: Chart, newData: number[]): void {\n    chart.data.datasets[0].data = newData;\n    chart.update();\n}\n\n// Initial data\nconst initialData = [65, 59, 80, 81, 56, 55, 40];\n\n// Update data\nconst newData = [28, 48, 40, 19, 86, 27, 90];\n\n// Update the chart with new data\nupdateChartData(myChart, newData);\n", "suffix": "// Cleanup the canvas element after test\ncanvas.remove();\n\n// Ensure that the canvas element is removed\nexpect(document.body.contains(canvas)).to.be.false;\n", "golden_completion": "expect(myChart.data.datasets[0].data).to.deep.equal(newData);\nexpect(myChart.data.datasets[0].data).to.not.deep.equal(initialData);\n", "LLM_justification": "This test case is designed to evaluate the LLM's ability to recognize and complete patterns involving the Chart.js library, specifically focusing on the update of chart data and the validation of this update. Chart.js is a popular data visualization library, but its update methods and data structures might not be as frequently used or well-known. The scenario includes setting up a chart, updating its data, and verifying the update through assertions. The correct completion should ensure that the chart data has been updated as expected and that it no longer matches the initial data. This tests the LLM's understanding of the Chart.js API, including the proper use of the 'update' method and data structure manipulation.", "assertions": "expect(myChart.data.datasets[0].data).to.deep.equal(newData);\nexpect(myChart.data.datasets[0].data).to.not.deep.equal(initialData);\n", "o1-mini": ""}
{"id": "45", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { Chart } from 'chart.js';\n\n// Type definition for chart data\ninterface ChartData {\n  labels: string[];\n  datasets: Array<{\n    label: string;\n    data: number[];\n    backgroundColor: string;\n    borderColor: string;\n    borderWidth: number;\n  }>;\n}\n\n// Sample chart data\nconst data: ChartData = {\n  labels: ['January', 'February', 'March', 'April', 'May', 'June'],\n  datasets: [\n    {\n      label: 'Monthly Sales',\n      data: [65, 59, 80, 81, 56, 55],\n      backgroundColor: 'rgba(75, 192, 192, 0.2)',\n      borderColor: 'rgba(75, 192, 192, 1)',\n      borderWidth: 1\n    }\n  ]\n};\n\n// Configuration for the chart\nconst config = {\n  type: 'bar',\n  data: data,\n  options: {\n    scales: {\n      y: {\n        beginAtZero: true\n      }\n    }\n  }\n};\n\n// Create chart instance\nlet myChart: Chart | null = null;\n\n// Function to initialize the chart\nfunction initChart(ctx: CanvasRenderingContext2D) {\n  myChart = new Chart(ctx, config);\n}\n\n// Mock canvas context for testing purposes\nconst mockCanvasContext = {\n  canvas: {},\n  clearRect: jest.fn(),\n  beginPath: jest.fn(),\n  moveTo: jest.fn(),\n  lineTo: jest.fn(),\n  stroke: jest.fn(),\n  fillText: jest.fn(),\n  measureText: jest.fn(() => ({ width: 100 })),\n  save: jest.fn(),\n  restore: jest.fn()\n} as unknown as CanvasRenderingContext2D;\n\n// Initialize the chart with the mock context\ninitChart(mockCanvasContext);\n\n// Function to update chart data\nfunction updateChartData(newData: ChartData) {\n  if (myChart) {\n    myChart.data = newData;\n    myChart.update();\n  }\n}\n\n// New data to update the chart\nconst newData: ChartData = {\n  labels: ['July', 'August', 'September', 'October', 'November', 'December'],\n  datasets: [\n    {\n      label: 'Monthly Sales Updated',\n      data: [75, 69, 90, 91, 66, 65],\n      backgroundColor: 'rgba(54, 162, 235, 0.2)',\n      borderColor: 'rgba(54, 162, 235, 1)',\n      borderWidth: 1\n    }\n  ]\n};\n\n// Update the chart with the new data\nupdateChartData(newData);\n", "suffix": "// Asserting chart data update\nimport * as assert from 'assert';\n\nassert.strictEqual(myChart!.data.labels.length, 6);\nassert.strictEqual(myChart!.data.datasets[0].label, 'Monthly Sales Updated');\nassert.strictEqual(myChart!.data.datasets[0].data[0], 75);\n\n// Clean up chart instance\nmyChart?.destroy();\nmyChart = null;\n", "golden_completion": "myChart!.update();", "LLM_justification": "This test case provides a comprehensive example of initializing and updating a Chart.js chart instance using TypeScript. It involves setting up chart data, configuration, and properly updating the chart with new data. The completion focuses on calling the 'update' method on the chart instance, which is a less common but critical part of using the Chart.js library effectively. The assertions check for correct data updates, ensuring the LLM understands and correctly implements the API usage pattern.", "assertions": "assert.strictEqual(myChart!.data.labels.length, 6);\nassert.strictEqual(myChart!.data.datasets[0].label, 'Monthly Sales Updated');\nassert.strictEqual(myChart!.data.datasets[0].data[0], 75);", "o1-mini": ""}
{"id": "46", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as moment from 'moment';\nimport { assert } from 'chai';\n\n/**\n * Utility function to format dates.\n * @param date The date to format\n * @param format The format string\n * @returns The formatted date string\n */\nfunction formatDate(date: Date, format: string): string {\n    return moment(date).format(format);\n}\n\n/**\n * Utility function to calculate the difference between two dates.\n * @param date1 The first date\n * @param date2 The second date\n * @param unit The unit of measurement for the difference (e.g., 'days', 'months')\n * @returns The difference between the two dates in the specified unit\n */\nfunction dateDifference(date1: Date, date2: Date, unit: moment.unitOfTime.Diff): number {\n    return moment(date1).diff(moment(date2), unit);\n}\n\n/**\n * Example usage of the utility functions\n */\nconst date1 = new Date(2023, 0, 1);\nconst date2 = new Date(2023, 11, 31);\nconst formattedDate = formatDate(date1, 'YYYY-MM-DD');\nconst daysDifference = dateDifference(date2, date1, 'days');\n\nconsole.log('Formatted Date:', formattedDate);\nconsole.log('Days Difference:', daysDifference);\n\n// Assertions to verify the utility functions work as expected\nassert.strictEqual(formattedDate, '2023-01-01');\nassert.strictEqual(daysDifference, 364);\n\n/**\n * Utility function to add a duration to a date.\n * @param date The date to which the duration is added\n * @param amount The amount of time to add\n * @param unit The unit of time to add (e.g., 'days', 'months')\n * @returns The new date with the added duration\n */\nfunction addDuration(date: Date, amount: number, unit: moment.unitOfTime.DurationConstructor): Date {\n    return moment(date).add(amount, unit).toDate();\n}\n\n/**\n * Utility function to subtract a duration from a date.\n * @param date The date from which the duration is subtracted\n * @param amount The amount of time to subtract\n * @param unit The unit of time to subtract (e.g., 'days', 'months')\n * @returns The new date with the subtracted duration\n */\nfunction subtractDuration(date: Date, amount: number, unit: moment.unitOfTime.DurationConstructor): Date {\n    return moment(date).subtract(amount, unit).toDate();\n}\n\nconst initialDate = new Date(2023, 0, 1);\nconst newDate = addDuration(initialDate, 1, 'month');\nconst prevDate = subtractDuration(initialDate, 1, 'month');\n\nconsole.log('New Date:', newDate);\nconsole.log('Previous Date:', prevDate);\n\n// Assertions to verify the duration functions work as expected\nassert.strictEqual(newDate.toISOString(), '2023-02-01T00:00:00.000Z');\nassert.strictEqual(prevDate.toISOString(), '2022-12-01T00:00:00.000Z');\n\n", "suffix": "\nconst nextYearDate = moment(initialDate).add(1, 'year').toDate();\nconst lastYearDate = moment(initialDate).subtract(1, 'year').toDate();\n\nconsole.log('Next Year Date:', nextYearDate);\nconsole.log('Last Year Date:', lastYearDate);\n\nassert.strictEqual(nextYearDate.toISOString(), '2024-01-01T00:00:00.000Z');\nassert.strictEqual(lastYearDate.toISOString(), '2022-01-01T00:00:00.000Z');\n", "golden_completion": "const newDateWithWeek = addDuration(initialDate, 1, 'week');\nconst prevDateWithWeek = subtractDuration(initialDate, 1, 'week');\n\nconsole.log('New Date with Week:', newDateWithWeek);\nconsole.log('Previous Date with Week:', prevDateWithWeek);\n\nassert.strictEqual(newDateWithWeek.toISOString(), '2023-01-08T00:00:00.000Z');\nassert.strictEqual(prevDateWithWeek.toISOString(), '2022-12-25T00:00:00.000Z');\n", "LLM_justification": "This test case demonstrates the use of the moment.js library for date manipulation, focusing on the less common functions of adding and subtracting durations with different units such as weeks. The scenario sets up a comprehensive context with utility functions and examples, making it a good test for recognizing and continuing patterns involving date calculations. The assertions verify that the API behaves as expected with correct parameter ordering and results.", "assertions": "assert.strictEqual(newDateWithWeek.toISOString(), '2023-01-08T00:00:00.000Z');\nassert.strictEqual(prevDateWithWeek.toISOString(), '2022-12-25T00:00:00.000Z');\n", "o1-mini": ""}
{"id": "47", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as d3 from 'd3';\nimport { select } from 'd3-selection';\nimport { scaleLinear } from 'd3-scale';\nimport { axisBottom } from 'd3-axis';\n\n// Helper functions for generating random data\nfunction generateRandomData(numPoints: number): { x: number, y: number }[] {\n    return Array.from({ length: numPoints }, () => ({\n        x: Math.floor(Math.random() * 100),\n        y: Math.floor(Math.random() * 100)\n    }));\n}\n\n// Initialize SVG dimensions\nconst width = 500;\nconst height = 300;\nconst margin = { top: 20, right: 30, bottom: 30, left: 40 };\n\n// Create SVG container\nconst svg = select('body').append('svg')\n    .attr('width', width + margin.left + margin.right)\n    .attr('height', height + margin.top + margin.bottom)\n    .append('g')\n    .attr('transform', `translate(${margin.left},${margin.top})`);\n\n// Generate random data points\nconst data = generateRandomData(50);\n\n// Define scales for x and y axes\nconst x = scaleLinear()\n    .domain([0, d3.max(data, d => d.x)!])\n    .range([0, width]);\n\nconst y = scaleLinear()\n    .domain([0, d3.max(data, d => d.y)!])\n    .range([height, 0]);\n\n// Append x-axis to the SVG\nsvg.append('g')\n    .attr('transform', `translate(0,${height})`)\n    .call(axisBottom(x));\n\n// Initial scatter plot points\nconst points = svg.selectAll('.dot')\n    .data(data)\n    .enter().append('circle')\n    .attr('class', 'dot')\n    .attr('r', 3.5)\n    .attr('cx', d => x(d.x))\n    .attr('cy', d => y(d.y));\n\n// Update function for points\nfunction updateData(newData: { x: number, y: number }[]) {\n    const updatedPoints = svg.selectAll('.dot')\n        .data(newData);\n\n    updatedPoints.enter().append('circle')\n        .attr('class', 'dot')\n        .attr('r', 3.5)\n        .attr('cx', d => x(d.x))\n        .attr('cy', d => y(d.y));\n\n    updatedPoints.exit().remove();\n\n    updatedPoints\n        .attr('cx', d => x(d.x))\n        .attr('cy', d => y(d.y));\n}\n\n// Generate new random data points\nconst newData = generateRandomData(50);\n", "suffix": "// Incorrectly attempting to update points without merging existing data\nsvg.selectAll('.dot')\n    .data(newData)\n    .enter().append('circle')\n    .attr('class', 'dot')\n    .attr('r', 3.5)\n    .attr('cx', d => x(d.x))\n    .attr('cy', d => y(d.y));\n\n// Assertions to verify the correctness of the data update\nconst updatedPoints = svg.selectAll('.dot').nodes();\nconsole.assert(updatedPoints.length === newData.length, `Expected ${newData.length} points, but got ${updatedPoints.length}`);", "golden_completion": "updateData(newData);", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern for updating data in a D3.js scatter plot. The correct approach involves properly merging the new data with the existing data and updating the existing elements, which is a less common pattern in D3.js. The provided suffix shows an incorrect attempt to update the data, which helps in distinguishing the correct approach from a common mistake. The golden completion demonstrates the correct usage of the update pattern in D3.js, ensuring all points are updated and none are duplicated.", "assertions": "const updatedPointsAfterCompletion = svg.selectAll('.dot').nodes();\nconsole.assert(updatedPointsAfterCompletion.length === newData.length, `Expected ${newData.length} points, but got ${updatedPointsAfterCompletion.length}`);\nnewData.forEach((d, i) => {\n    const point = updatedPointsAfterCompletion[i] as SVGCircleElement;\n    console.assert(Math.abs(parseFloat(point.getAttribute('cx')!) - x(d.x)) < 0.1, `Point ${i} x-coordinate incorrect`);\n    console.assert(Math.abs(parseFloat(point.getAttribute('cy')!) - y(d.y)) < 0.1, `Point ${i} y-coordinate incorrect`);\n});", "o1-mini": ""}
{"id": "48", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as d3 from 'd3';\nimport { select } from 'd3-selection';\nimport { scaleLinear } from 'd3-scale';\nimport { axisBottom, axisLeft } from 'd3-axis';\nimport { line } from 'd3-shape';\n\n// Define the dimensions and margins of the graph\nconst margin = { top: 10, right: 30, bottom: 30, left: 60 },\n    width = 460 - margin.left - margin.right,\n    height = 400 - margin.top - margin.bottom;\n\n// Append the SVG object to the body of the page\nconst svg = select('body')\n    .append('svg')\n    .attr('width', width + margin.left + margin.right)\n    .attr('height', height + margin.top + margin.bottom)\n  .append('g')\n    .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n// Create a function to parse the date\nconst parseDate = d3.timeParse('%Y-%m-%d');\n\n// Create a scale for the x-axis\nconst x = scaleLinear()\n    .domain([0, 100])\n    .range([0, width]);\n\n// Create a scale for the y-axis\nconst y = scaleLinear()\n    .domain([0, 100])\n    .range([height, 0]);\n\n// Add the x-axis to the svg\nsvg.append('g')\n    .attr('transform', 'translate(0,' + height + ')')\n    .call(axisBottom(x));\n\n// Add the y-axis to the svg\nsvg.append('g')\n    .call(axisLeft(y));\n\n// Define the data\nconst data = [\n    { date: '2020-01-01', value: 10 },\n    { date: '2020-02-01', value: 20 },\n    { date: '2020-03-01', value: 30 },\n    { date: '2020-04-01', value: 40 },\n    { date: '2020-05-01', value: 50 },\n];\n\n// Parse the date and value from the data\nconst parsedData = data.map(d => ({\n    date: parseDate(d.date),\n    value: d.value\n}));\n\n// Define the line\nconst lineGenerator = line()\n    .x(d => x(d.value))\n    .y(d => y(d.value));\n\n// Add the line to the svg\nsvg.append('path')\n    .datum(parsedData)\n    .attr('fill', 'none')\n    .attr('stroke', 'steelblue')\n    .attr('stroke-width', 2)\n    .attr('d', lineGenerator);", "suffix": "svg.append('text')\n    .attr('text-anchor', 'end')\n    .attr('x', width)\n    .attr('y', height + margin.top + 20)\n    .text('Date');", "golden_completion": "svg.append('g')\n    .attr('class', 'grid')\n    .attr('transform', 'translate(0,' + height + ')')\n    .call(axisBottom(x)\n        .tickSize(-height)\n        .tickFormat(''));\n\nsvg.append('g')\n    .attr('class', 'grid')\n    .call(axisLeft(y)\n        .tickSize(-width)\n        .tickFormat(''));", "LLM_justification": "This test case demonstrates the usage of the D3.js library to create a line chart with grid lines. The pattern involves setting up scales and axes, creating a line generator, and appending paths and text elements to the SVG. The golden completion specifically tests the ability to add grid lines to the chart, which is a less common but valid API usage in D3.js. The suffix then adds a text label, ensuring the completion is distinct and follows the pattern.", "assertions": "const gridLinesX = document.querySelectorAll('.grid line');\nconst gridLinesY = document.querySelectorAll('.grid line');\nassert(gridLinesX.length > 0, 'X-axis grid lines should be present');\nassert(gridLinesY.length > 0, 'Y-axis grid lines should be present');\nconst textElement = document.querySelector('text');\nassert(textElement !== null, 'Text label should be present');\nassert(textElement.textContent === 'Date', 'Text label should read \"Date\"');", "o1-mini": ""}
{"id": "49", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport { Action, Reducer } from 'redux';\n\n// Define action types\nconst INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n\n// Define action creators\ninterface IncrementAction extends Action<typeof INCREMENT> {}\ninterface DecrementAction extends Action<typeof DECREMENT> {}\n\nconst increment = (): IncrementAction => ({ type: INCREMENT });\nconst decrement = (): DecrementAction => ({ type: DECREMENT });\n\n// Define the initial state\ninterface CounterState {\n  count: number;\n}\n\nconst initialState: CounterState = { count: 0 };\n\n// Define the reducer\nconst counterReducer: Reducer<CounterState, IncrementAction | DecrementAction> = (\n  state = initialState,\n  action\n) => {\n  switch (action.type) {\n    case INCREMENT:\n      return { ...state, count: state.count + 1 };\n    case DECREMENT:\n      return { ...state, count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n\n// Create the Redux store with middleware\nconst store = createStore(counterReducer, applyMiddleware(thunk));\n\n// Define a thunk action creator for asynchronous actions\nconst incrementAsync = () => {\n  return (dispatch: any) => {\n    setTimeout(() => {\n      dispatch(increment());\n    }, 1000);\n  };\n};\n\n// Dispatch actions to test the store\nstore.dispatch(increment());\nstore.dispatch(decrement());\n", "suffix": "store.dispatch(decrement());\n\n// Cleanup code (if needed)\n// No resources to clean up in this example\n", "golden_completion": "store.dispatch(incrementAsync() as any);\n", "LLM_justification": "This example tests the LLM's ability to recognize and complete a pattern involving Redux with thunk middleware. The prefix provides extensive context by defining action types, creators, the reducer, and the store setup. The golden completion demonstrates the usage of a thunk action creator for dispatching asynchronous actions, which is a less common but valid usage pattern in Redux. The suffix includes a different action dispatch to ensure clear distinction. Assertions will verify that the asynchronous increment action works as expected, testing both API behavior and parameter correctness.", "assertions": "import { expect } from 'chai';\n\n// Assertion to verify the initial state\nexpect(store.getState().count).to.equal(0);\n\n// Dispatch asynchronous increment action\nstore.dispatch(incrementAsync() as any);\n\n// Assertion to verify the state after asynchronous action\nsetTimeout(() => {\n  expect(store.getState().count).to.equal(1);\n}, 1500);", "o1-mini": ""}
{"id": "50", "testsource": "devbench-api-usage", "language": "typescript", "prefix": "import * as d3 from 'd3';\nimport { select, Selection } from 'd3-selection';\nimport { scaleLinear } from 'd3-scale';\nimport { axisBottom, axisLeft } from 'd3-axis';\nimport { line } from 'd3-shape';\nimport { format } from 'd3-format';\n\ninterface DataPoint {\n  date: Date;\n  value: number;\n}\n\nconst data: DataPoint[] = [\n  { date: new Date('2020-01-01'), value: 30 },\n  { date: new Date('2020-02-01'), value: 200 },\n  { date: new Date('2020-03-01'), value: 100 },\n  { date: new Date('2020-04-01'), value: 400 },\n  { date: new Date('2020-05-01'), value: 150 }\n];\n\nconst margin = { top: 20, right: 20, bottom: 30, left: 50 };\nconst width = 960 - margin.left - margin.right;\nconst height = 500 - margin.top - margin.bottom;\n\nconst x = scaleLinear().domain([0, data.length - 1]).range([0, width]);\nconst y = scaleLinear().domain([0, d3.max(data, d => d.value)]).range([height, 0]);\n\nconst xAxis = axisBottom(x);\nconst yAxis = axisLeft(y);\n\nconst svg = select('body').append('svg')\n  .attr('width', width + margin.left + margin.right)\n  .attr('height', height + margin.top + margin.bottom)\n  .append('g')\n  .attr('transform', `translate(${margin.left},${margin.top})`);\n\nsvg.append('g')\n  .attr('class', 'x axis')\n  .attr('transform', `translate(0,${height})`)\n  .call(xAxis);\n\nsvg.append('g')\n  .attr('class', 'y axis')\n  .call(yAxis);\n\nconst lineGenerator = line<DataPoint>()\n  .x((d, i) => x(i))\n  .y(d => y(d.value));\n\nsvg.append('path')\n  .datum(data)\n  .attr('class', 'line')\n  .attr('d', lineGenerator);\n\n// Create a tooltip element\nconst tooltip = select('body').append('div')\n  .attr('class', 'tooltip')\n  .style('position', 'absolute')\n  .style('padding', '8px')\n  .style('background', 'lightsteelblue')\n  .style('border', '1px solid #ddd')\n  .style('border-radius', '4px')\n  .style('pointer-events', 'none')\n  .style('opacity', 0);\n\n// Mouseover event for displaying tooltip\nsvg.selectAll('.dot')\n  .data(data)\n  .enter().append('circle')\n  .attr('class', 'dot')\n  .attr('r', 5)\n  .attr('cx', (d, i) => x(i))\n  .attr('cy', d => y(d.value))\n  .on('mouseover', function(event, d) {\n    tooltip.transition()\n      .duration(200)\n      .style('opacity', .9);\n    tooltip.html(`Value: ${format('.2f')(d.value)}`)\n      .style('left', `${event.pageX}px`)\n      .style('top', `${event.pageY - 28}px`);\n  })\n  .on('mouseout', function(d) {\n    tooltip.transition()\n      .duration(500)\n      .style('opacity', 0);\n  });\n", "suffix": "svg.selectAll('.dot')\n  .on('click', function(event, d) {\n    alert(`You clicked on value: ${d.value}`);\n  });\n", "golden_completion": "svg.selectAll('.dot')\n  .on('mousemove', function(event, d) {\n    tooltip.style('left', `${event.pageX}px`)\n      .style('top', `${event.pageY - 28}px`);\n  });\n", "LLM_justification": "This test case uses D3.js, a powerful but complex library for data visualization. The scenario focuses on creating an interactive line chart with tooltips, a less common use case involving mouse events and dynamic tooltip positioning. It tests the LLM's ability to recognize and complete patterns involving mouse events and D3.js selection API. The example ensures the model handles rare API interactions with correct parameter usage and chaining patterns.", "assertions": "import { select } from 'd3-selection';\nimport { JSDOM } from 'jsdom';\nimport assert from 'assert';\n\n// Create a mock DOM environment for testing\nconst { window } = new JSDOM('<!DOCTYPE html><body></body>');\nglobal.document = window.document;\nglobal.window = window;\n\n// Mock data and SVG setup\nconst data = [\n  { date: new Date('2020-01-01'), value: 30 },\n  { date: new Date('2020-02-01'), value: 200 },\n  { date: new Date('2020-03-01'), value: 100 },\n  { date: new Date('2020-04-01'), value: 400 },\n  { date: new Date('2020-05-01'), value: 150 }\n];\n\nconst svg = select('body').append('svg')\n  .attr('width', 960)\n  .attr('height', 500)\n  .append('g')\n  .attr('transform', 'translate(50,20)');\n\n// Append dots\nsvg.selectAll('.dot')\n  .data(data)\n  .enter().append('circle')\n  .attr('class', 'dot')\n  .attr('r', 5)\n  .attr('cx', (d, i) => i * 50)\n  .attr('cy', d => 500 - d.value);\n\n// Tooltip setup\nconst tooltip = select('body').append('div')\n  .attr('class', 'tooltip')\n  .style('position', 'absolute')\n  .style('opacity', 0);\n\n// Simulate mousemove event\nsvg.selectAll('.dot').dispatch('mousemove', { pageX: 100, pageY: 200 });\n\n// Check if the tooltip is positioned correctly\nconst tooltipElement = document.querySelector('.tooltip');\nassert(tooltipElement !== null);\nassert(tooltipElement.style.left === '100px');\nassert(tooltipElement.style.top === '172px');\n", "o1-mini": ""}
